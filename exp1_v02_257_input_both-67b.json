{"input_both": ["\n\treturn max(0.0,cos( a ));\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    p = p - rotDir*dot(p,rotDir);\n\n    // Rotate the whole thing\n    p = Rotate(p,rotAngle);\n\n    // Scale\n    p *= scale;\n\n    // Translate\n    p += translate;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Get the distance to the voxel\n\tfloat d = length(p) - 0.5;\n\n\t// Return the distance\n\treturn d;\n}\n\n// Distance to the voxel\nfloat", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Distance to the scene\n\tfloat d = sdScene(p);\n\n\t// Color of the closest point\n\tP = vec3(0.0);\n\n\t// If the point is in the scene\n\tif (d < EPS) {\n\n\t\t// Get the color of the closest point\n\t\tP = getColor(p);\n\n\t\t// If the point is in the glow area\n\t\tif (d < GLOW_RADIUS) {\n\n\t\t\t// Add the glow\n\t\t\tP = P + glow(p);\n\t\t}\n\t}\n\n\t// Return the distance and the color\n\treturn vec2(d, P);\n}\n\n// Ray marching\nvec", " coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos2 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos3 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos4 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos5 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos6 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos7 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos8 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0", "\n\tvec4 colors[4];\n\tcolors[0] = vec4(0.0, 0.0, 0.0, 1.0);\n\tcolors[1] = vec4(0.0, 0.0, 1.0, 1.0);\n\tcolors[2] = vec4(0.0, 1.0, 0.0, 1.0);\n\tcolors[3] = vec4(1.0, 0.0, 0.0, 1.0);\n\n\tfloat x0 = floor(x);\n\tfloat x1 = x0 + 1.0;\n\tfloat w0 = x1 - x;\n\tfloat w1 = x - x0;\n\n\tvec4 c0 = colors[int(x0)];\n\tvec4 c1 = colors[int(x1)];\n\n\treturn c0 * w0 + c1 * w1;\n}\n\nvoid main()\n{\n\tvec4 color = gradient(v_color);\n\tgl_FragColor = color;\n}\n", "\n\tvec4 color = texture(colorGradient, d);\n\n\t// add ambient light\n\tcolor += ambient;\n\n\t// add diffuse light\n\tcolor += diffuse * max(dot(normal, lightDir), 0.0);\n\n\t// add specular light\n\tcolor += specular * pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), shininess);\n\n\treturn color;\n}\n\nvoid main()\n{\n\t// get the distance to the point\n\tfloat d = distance(position, cameraPos);\n\n\t// shade the point\n\tvec4 color = shade(d);\n\n\t// set the fragment color\n\tfragColor = color;\n}\n", " up to the top\n    float fade = (rayDir.y + 1.0) * 0.5;\n\n    // softbox\n    float dist = RayBox(rayDir, vec3(0.0), vec3(100.0), 0.0);\n\n    // 4 lights in a horizontal circle\n    float dist2 = RayBox(rayDir, vec3(0.0, 0.0, 10.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist3 = RayBox(rayDir, vec3(0.0, 0.0, 20.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist4 = RayBox(rayDir, vec3(0.0, 0.0, 30.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist5 = RayBox(rayDir, vec3(0.0, 0.0, 40.0), vec3(10.0, 10.0, 10.0), 0.0);\n\n    // get the closest distance\n    float distClosest = min(dist, min(dist2, min(dist3, min(dist4, dist5))));\n\n    // if the ray hit the softbox, return the softbox color\n    if (distClosest == dist)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // if the ray hit the lights, return the light color\n    if (distClosest == dist2)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (distClosest == dist3)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (distClosest == dist4)\n    {\n        return vec3", "\n    float t = mod(time, 6.0);\n    if (t < 2.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a parabola\n    float x = coords.x;\n    float y = coords.y;\n    return (x - 2.0) * (x - 4.0) - y;\n}\n\n// the derivative of F(x,y)\nvec", "\n    float t = mod(time, 10.0);\n    if (t < 2.0 || t > 8.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of time\n    float tt = t - 2.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of x and y\n    float xxx = xx * xx;\n    float yyy = yy * yy;\n\n    // the curve is a function of x and y\n    float xxxx = xxx * xxx;\n    float yyyy = yyy * yyy;\n\n    // the curve is a function of x and y\n    float xxxxx = xxxx * xxx;\n    float yyyyy = yyyy * yyy;\n\n    // the curve is a function of x and y\n    float xxxxxx = xxxxx * xx;\n    float yyyyyy = yyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxx = xxxxxx * xx;\n    float yyyyyyy = yyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxx = xxxxxxx * xx;\n    float yyyyyyyy = yyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxx = xxxxxxxx * xx;\n    float yyyyyyyyy = yyyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxxx = xxxxxxxxx * xx;\n    float yyyyyyyyyy = yyyyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxxxx = xxxxxxxxxx * xx;\n    float yyyyyyyyyyy = yyyyyyyyyy * yy;\n\n   ", "\n    float t = mod(time, 5.0);\n    if (t < 1.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of t\n    float tt = t - 1.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of t, x and y\n    float ttt = tt * tt * tt;\n    float xxx = xx * xx * xx;\n    float yyy = yy * yy * yy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y^3\n    float f = ttt * xxx * yyy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y^3\n    // and the value is between 0.0 and 1.0\n    return f * 0.5 + 0.5;\n}\n\n// the main function\nvoid main()\n{\n    // get the texture coordinates\n    vec2 coords = gl_TexCoord[0].st;\n\n    // get the texture value\n    float f = F(coords);\n\n    // set the output color\n    gl_FragColor = vec4(f, f, f, 1.0);\n}\n", " by changing the value of the variable\n    float time = iTime * 0.5;\n\n    //get the position of the pixel in the screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv4 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv5 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv6 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv7 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv8 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv9 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv10 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv11 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv12 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv13 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv14 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the", "\n    vec3 q = p + vec3(0.0, 0.0, p.z * 0.00001);\n\n    // The time dialation is applied to the position and time frequencies.\n    float f = pow(2.0, 1.0 - 1.0 * u_time);\n    float g = pow(2.0, 1.0 - 1.0 * u_time);\n\n    // The noise is generated from the position and time frequencies.\n    float n = fbm(f * p);\n    float m = fbm(g * q);\n\n    // The noise is then returned.\n    return n + m;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(", "\n    vec2 i = floor(p + (p.x + p.y) *.125);\n    vec2 x0 = i - (i.x + i.y) *.25;\n    vec2 g = step(vec2(.5), fract(abs(x0) + vec2(.5,.75)));\n    vec2 o = g.yx * g.x + g.xy * (1. - g.x);\n    vec2 d = p - x0 - (o -.5);\n    float h = dot(d, d);\n    \n    // Simplex grid stuff.\n    //\n    vec2 i1;\n    if(o.y < o.x) i1 = vec2(1., 0.);\n    else i1 = vec2(0., 1.);\n    vec2 x1 = x0 + i1;\n    vec2 g1 = step(vec2(.5), fract(abs(x1) + vec2(.5,.75)));\n    vec2 o1 = g1.yx * g1.x + g1.xy * (1. - g1.x);\n    vec2 d1 = p - x1 - (o1 -.5);\n    float h1 = dot(d1, d1);\n    \n    // Simplex grid stuff.\n    //\n    vec2 i2;\n    if(o1.y < o1.x) i2 = vec2(1., 0.);\n    else i2 = vec2(0., 1.);\n    vec2 x2 = x0 + i1 + i2;\n    vec2 g2 = step(vec2(.5), fract(abs(x2) + vec2(.5,.75)));\n    vec2 o2 = g2.yx * g2.x + g2.xy * (1. - g2.x);\n    vec2 d2 = p - x2 - (o2 -.5);\n    float h2 = dot(d2, d2);\n    \n    // Return the minimum distance.\n    //\n    return", "\n    vec2 cell = floor(p);\n    // Get the distance to the cell.\n    vec2 cell_dist = p - cell;\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the", "\n  vec3 color = vec3(0.0,0.0,0.0);\n\n  // get the position of the hit\n  vec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n\n  // get the normal of the hit\n  vec3 hitNormal = getNormal( hitPosition );\n\n  // get the material of the hit\n  Material material = getMaterial( hitPosition );\n\n  // get the light direction\n  vec3 lightDirection = normalize( vec3(1.0,1.0,1.0) );\n\n  // get the light color\n  vec3 lightColor = vec3(1.0,1.0,1.0);\n\n  // get the ambient color\n  vec3 ambientColor = vec3(0.1,0.1,0.1);\n\n  // get the diffuse color\n  vec3 diffuseColor = material.diffuseColor;\n\n  // get the specular color\n  vec3 specularColor = material.specularColor;\n\n  // get the specular exponent\n  float specularExponent = material.specularExponent;\n\n  // get the reflection color\n  vec3 reflectionColor = vec3(0.0,0.0,0.0);\n\n  // get the refraction color\n  vec3 refractionColor = vec3(0.0,0.0,0.0);\n\n  // get the refraction index\n  float refractionIndex = material.refractionIndex;\n\n  // get the refraction exponent\n  float refractionExponent = material.refractionExponent;\n\n  // get the reflection exponent\n  float reflectionExponent = material.reflectionExponent;\n\n  // get the reflection direction\n  vec3 reflectionDirection = reflect( rayDirection, hitNormal );\n\n  // get the refraction direction\n  vec3 refractionDirection = refract( rayDirection, hitNormal, refractionIndex );\n\n  // get the reflection ray hit info\n  vec2 reflectionRayHitInfo = rayMarch( hitPosition, reflectionDirection );\n\n  // get the refraction ray hit info\n  vec2 refractionRayHitInfo =", "\n    vec2 res = vec2(1000.0, 0.0);\n\n    // sphere\n    res = opU(res, vec2(length(p - vec3(0.0, 0.0, 0.0)) - 1.0, 1.0));\n\n    // plane\n    res = opU(res, vec2(p.y + 1.0, 2.0));\n\n    // box\n    res = opU(res, vec2(length(max(abs(p.xz) - vec2(1.0, 1.0), 0.0)) - 0.1, 3.0));\n\n    return res;\n}\n\n// ~~~~~~~ get normal\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec", "\n\tfloat tmin = 0.001;\n\tfloat tmax = 100.0;\n\tfloat t = tmin;\n\t\n\t// variables used to store the hit object's ID\n\tfloat id = -1.0;\n\t\n\t// variables used to store the hit object's position\n\tvec3 qhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's normal\n\tvec3 nhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's color\n\tvec3 chit = vec3(0.0);\n\t\n\t// variables used to store the hit object's material\n\tfloat mhit = 0.0;\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit2 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit3 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit4 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit5 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit6 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit7 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit8 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit9 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit10 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit11 = vec2(0.0);\n\t\n\t// variables used to store the hit object", "\n    vec4 res = vec4(0.0);\n\n    // distance to the closest object\n    float d = INFINITY;\n\n    // loop through all the objects\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the distance to the object\n        float d_obj = objects[i].sdf(p);\n\n        // if the distance is less than the current closest distance\n        if (d_obj < d)\n        {\n            // update the closest distance\n            d = d_obj;\n\n            // get the color of the object\n            vec3 col = objects[i].color;\n\n            // if the object is a sphere\n            if (objects[i].type == SPHERE)\n            {\n                // get the normal of the sphere\n                vec3 n = normalize(p - objects[i].pos);\n\n                // get the light direction\n                vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n                // get the ambient light\n                vec3 ambient = vec3(0.1, 0.1, 0.1);\n\n                // get the diffuse light\n                vec3 diffuse = vec3(0.5, 0.5, 0.5) * max(dot(n, l), 0.0);\n\n                // get the specular light\n                vec3 specular = vec3(1.0, 1.0, 1.0) * pow(max(dot(reflect(l, n), normalize(p - objects[i].pos)), 0.0), 10.0);\n\n                // get the final color\n                col = ambient + diffuse + specular;\n            }\n\n            // set the result to the color of the object\n            res = vec4(col, d);\n        }\n    }\n\n    // return the result\n    return res;\n}\n\n// ~~~~~~~ ray marching\n// input p --> is ray position\n// input d --> is ray direction\n// basically march along the ray until we hit something\n// outputs the distance to the object\n", "\n    float t = 0.0;\n    float mint = 0.0;\n    float maxt = 1000.0;\n    float precis = 0.001;\n    float maxd = 100.0;\n    float h = 1.0;\n    float tt = 0.0;\n    float id = 0.0;\n    float itter = 0.0;\n    float itterMax = 100.0;\n    float itterStep = 0.0;\n    float itterStepMax = 10.0;\n    float itterStepMin = 0.0;\n    float itterStepRatio = 0.0;\n    float itterStepRatioMax = 1.0;\n    float itterStepRatioMin = 0.0;\n    float itterStepRatioStep = 0.0;\n    float itterStepRatioStepMax = 1.0;\n    float itterStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioMin = 0.0;\n    float itterStepRatioStepRatioStep = 0.0;\n    float itterStepRatioStepRatioStepMax = 1.0;\n    float itterStepRatioStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioStepRatioMin = 0.0;\n    float itterStepRatioStepRatioStepRatioStep = 0.0;\n    float itterStepRatioStepRatioStepRatioStepMax = 1.0;\n    float itterStepRatioStepRatioStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatioStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioStepRatioStep", "s\n    vec3 diffs[4];\n    diffs[0] = vec3(0.0, 0.0, 0.0);\n    diffs[1] = vec3(0.0, 0.0, 0.0);\n    diffs[2] = vec3(0.0, 0.0, 0.0);\n    diffs[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs2[4];\n    diffs2[0] = vec3(0.0, 0.0, 0.0);\n    diffs2[1] = vec3(0.0, 0.0, 0.0);\n    diffs2[2] = vec3(0.0, 0.0, 0.0);\n    diffs2[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs3[4];\n    diffs3[0] = vec3(0.0, 0.0, 0.0);\n    diffs3[1] = vec3(0.0, 0.0, 0.0);\n    diffs3[2] = vec3(0.0, 0.0, 0.0);\n    diffs3[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs4[4];\n    diffs4[0] = vec3(0.0, 0.0, 0.0);\n    diffs4[1] = vec3(0.0, 0.0, 0.0);\n    diffs4[2] = vec3(0.0, 0.0, 0.0);\n    diffs4[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs5", "\n    vec3 s = vec3(7, 157, 113);\n    \n    // The dot product of the input and the stride.\n    float h = dot(p, s);\n    \n    // The fractional part of the dot product.\n    vec3 f = fract(vec3(h, h+1, h+2) * (1.0 / 31.0));\n    \n    // The fractional part of the dot product, raised to the power of 3.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    // The dot product of the input and the stride, modulo 289.\n    h = mod(h, 289.0);\n    \n    // The index of the first vector.\n    vec3 i = floor(h * (1.0 / 41.0));\n    \n    // The index of the second vector.\n    vec3 j = floor((h - i * 41.0) * (1.0 / 41.0));\n    \n    // The index of the third vector.\n    vec3 k = mod(i * 41.0 + j, 289.0);\n    \n    // The index of the fourth vector.\n    vec3 g = mod(k * 41.0, 7.0);\n    \n    // The index of the fifth vector.\n    vec3 l = mod(k * 41.0 + g, 289.0);\n    \n    // The index of the sixth vector.\n    vec3 m = mod(l * 41.0, 7.0);\n    \n    // The index of the seventh vector.\n    vec3 n = mod(l * 41.0 + m, 289.0);\n    \n    // The index of the eighth vector.\n    vec3 o = mod(n * 41.0, 7.0);\n    \n    // The index of the ninth vector.\n    vec3 q = mod(n * 41.0 + o, 289.", "\n\tvec3 col = vec3(0.);\n\tfloat t = 0.;\n\tfloat tmax = 1000.;\n\tfloat tmin = 0.001;\n\tfloat tstep = 0.01;\n\tfloat tstep2 = 0.001;\n\tfloat tstep3 = 0.0001;\n\tfloat tstep4 = 0.00001;\n\tfloat tstep5 = 0.000001;\n\tfloat tstep6 = 0.0000001;\n\tfloat tstep7 = 0.00000001;\n\tfloat tstep8 = 0.000000001;\n\tfloat tstep9 = 0.0000000001;\n\tfloat tstep10 = 0.00000000001;\n\tfloat tstep11 = 0.000000000001;\n\tfloat tstep12 = 0.0000000000001;\n\tfloat tstep13 = 0.00000000000001;\n\tfloat tstep14 = 0.000000000000001;\n\tfloat tstep15 = 0.0000000000000001;\n\tfloat tstep16 = 0.00000000000000001;\n\tfloat tstep17 = 0.000000000000000001;\n\tfloat tstep18 = 0.0000000000000000001;\n\tfloat tstep19 = 0.00000000000000000001;\n\tfloat tstep20 = 0.000000000000000000001;\n\tfloat tstep21 = 0.0000000000000000000", "\n    vec2 AB = B - A;\n    vec2 AB_normal = vec2(-AB.y, AB.x);\n    float AB_length = length(AB);\n    vec2 AB_normalized = AB / AB_length;\n    \n    // calculate distance from line segment\n    float dist = dot(AB_normal, coords - A);\n    dist = dist / AB_length;\n    \n    // calculate distance from line segment\n    float dist_from_line = abs(dist);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared = dist_from_line * dist_from_line;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped = clamp(dist_from_line_squared, 0.0, 1.0);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted = 1.0 - dist_from_line_squared_clamped;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared = dist_from_line_squared_clamped_inverted * dist_from_line_squared_clamped_inverted;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted = 1.0 - dist_from_line_squared_clamped_inverted_squared;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted_squared = dist_from_line_squared_clamped_inverted_squared_inverted * dist_from_line_squared_clamped_inverted_squared_inverted;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted_squared_inverted = 1.0 - dist_from_line_squared_clamped_inverted_squared_inverted_squared;\n    \n    //", "\n     float dot = dot(start, end);\n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot);\n     // Adjust start and reflect it about the relative vector\n     return (start*cos(theta)) + (RelativeVec*sin(theta));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    float camFov = 45.0;\n    float camNear = 0.1;\n    float camFar = 100.0;\n    float camAspect = iResolution.x / iResolution.y;\n    mat4 camView = lookAt(camPos, camTarget, camUp);\n    mat4 camProj = perspective(camFov, camAspect, camNear, camFar);\n    mat4 camViewProj = camProj * camView;\n\n    // set up our ray\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 rayStart = vec4(camPos, 1.0);\n    vec4 rayDir = normalize(camViewProj * vec4(uv, 1.0, 0.0));\n\n    // set up our scene\n    vec3 sceneColor = vec3(0.0);\n    float sceneDist = 100000.0;\n    vec3 sceneNormal = vec3(0.0);\n    vec3 scenePos = vec3(0.0);\n    vec3 sceneColor2 = vec3(0.0);\n    float sceneDist2 = 100000.0;\n    vec3 sceneNormal2 = vec3(0.0);\n    vec3 scenePos2 = vec3(0.0);\n\n    // set up our sphere\n    vec3 spherePos = vec3(0.0, 0.0, 1.0);\n    float sphereRadius = 0.5;\n\n    // set up our plane\n    vec3 planePos = vec3(0.0, 0.0, 0.0);\n    vec3 planeNormal =", "\n    //\n    //e = a + e * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a", " and forth\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = t * t * t;\n\n    // make a softbox light\n    vec3 lightColor = vec3(1.0, 0.9, 0.8) * 10.0;\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n    float lightDist = 10.0;\n    float lightAtten = 1.0 / (1.0 + 0.01 * lightDist * lightDist);\n    vec3 light = lightColor * lightAtten * max(0.0, dot(lightDir, rayDir));\n\n    // make a softbox shadow\n    float shadow = 1.0;\n    if (t < 0.99)\n    {\n        float shadowDist = RayMarch(rayDir * lightDist, 0.0, 1.0);\n        shadow = max(0.0, 1.0 - shadowDist / lightDist);\n    }\n\n    return light * shadow;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The ball-roller is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.", "^2\n\t// => (org.x^2 + 2*org.x*t*dir.x + t^2*dir.x^2) + (org.y^2 + 2*org.y*t*dir.y + t^2*dir.y^2) = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.", "\n    vec3 q = abs(p) - s.xyz;\n    vec3 q2 = q - s.w;\n    vec3 q3 = q - s.w * 2.0;\n    vec3 q4 = q - s.w * 3.0;\n    // corner radius\n    vec3 r2 = r.xyz * r.xyz;\n    // bottom radius offset\n    vec3 r3 = r.xyz * r.w;\n    // corner distance\n    vec3 d = q * r2 + q2 * r3 + q3 * r.w + q4 * r.w;\n    // bottom distance\n    vec3 d2 = q * r.w + q2 * r.w + q3 * r.w + q4 * r.w;\n    // distance to the nearest corner\n    float dmin = min(min(d.x, d.y), d.z);\n    // distance to the nearest bottom\n    float dmin2 = min(min(d2.x, d2.y), d2.z);\n    // distance to the nearest side\n    float dmin3 = min(min(d.x + d.y, d.y + d.z), d.z + d.x);\n    // distance to the nearest corner\n    float dmin4 = min(min(d2.x + d2.y, d2.y + d2.z), d2.z + d2.x);\n    // distance to the nearest side\n    float dmin5 = min(min(d.x + d.y + d.z, d.y + d.z + d.x), d.z + d.x + d.y);\n    // distance to the nearest corner\n    float dmin6 = min(min(d2.x + d2.y + d2.z, d2.y + d2.z + d2.x), d2.z + d2.x + d2.y);\n    // distance to the nearest side\n    float dmin7 = min(min(d.x + d.y + d.z + d.w, d.y + d.z + d.", "\n    float x = p.x * 1.0;\n    float y = p.y * 1.0;\n    float z = p.z * 1.0;\n    \n    // The first part of the hash function.\n    float x1 = x * 1.0;\n    float y1 = y * 1.0;\n    float z1 = z * 1.0;\n    \n    // The second part of the hash function.\n    float x2 = x * 1.0;\n    float y2 = y * 1.0;\n    float z2 = z * 1.0;\n    \n    // The third part of the hash function.\n    float x3 = x * 1.0;\n    float y3 = y * 1.0;\n    float z3 = z * 1.0;\n    \n    // The fourth part of the hash function.\n    float x4 = x * 1.0;\n    float y4 = y * 1.0;\n    float z4 = z * 1.0;\n    \n    // The fifth part of the hash function.\n    float x5 = x * 1.0;\n    float y5 = y * 1.0;\n    float z5 = z * 1.0;\n    \n    // The sixth part of the hash function.\n    float x6 = x * 1.0;\n    float y6 = y * 1.0;\n    float z6 = z * 1.0;\n    \n    // The seventh part of the hash function.\n    float x7 = x * 1.0;\n    float y7 = y * 1.0;\n    float z7 = z * 1.0;\n    \n    // The eighth part of the hash function.\n    float x8 = x * 1.0;\n    float y8 = y * 1.0;\n    float z8 = z * 1.0;\n    \n    // The ninth part of the hash function.\n    float x9 = x * 1.0;\n    float y9 = y * 1.0;\n    float z9 = z * 1.0;", "\n    float d = dot(p,p);\n    \n    // The circle radius.\n    float r = 0.25;\n    \n    // The circle distance.\n    float c = d - r;\n    \n    // The circle distance squared.\n    float c2 = c*c;\n    \n    // The circle distance cubed.\n    float c3 = c2*c;\n    \n    // The circle distance to the power of 5.\n    float c5 = c3*c2;\n    \n    // The circle distance to the power of 7.\n    float c7 = c5*c2;\n    \n    // The circle distance to the power of 9.\n    float c9 = c7*c2;\n    \n    // The circle distance to the power of 11.\n    float c11 = c9*c2;\n    \n    // The circle distance to the power of 13.\n    float c13 = c11*c2;\n    \n    // The circle distance to the power of 15.\n    float c15 = c13*c2;\n    \n    // The circle distance to the power of 17.\n    float c17 = c15*c2;\n    \n    // The circle distance to the power of 19.\n    float c19 = c17*c2;\n    \n    // The circle distance to the power of 21.\n    float c21 = c19*c2;\n    \n    // The circle distance to the power of 23.\n    float c23 = c21*c2;\n    \n    // The circle distance to the power of 25.\n    float c25 = c23*c2;\n    \n    // The circle distance to the power of 27.\n    float c27 = c25*c2;\n    \n    // The circle distance to the power of 29.\n    float c29 = c27*c2;\n    \n    // The circle distance to the power of 31.\n    float c31 = c29*c2;\n    \n    // The circle distance to the power", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // n - Normal vector\n    // nx - Change in \"n\" in in the X-direction.\n    // ny - Change in \"n\" in in the Y-direction.\n    // nz - Change in \"n\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bumpiness.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Slower, but more evenly disperses things.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n  vec3 l = normalize(light_pos - p);\n  float lambert = max(dot(n, l), 0.0);\n  vec3 diffuse = lambert * light_color;\n\n  // ambient\n  vec3 ambient = ambient_color;\n\n  // specular\n  vec3 v = normalize(camera_pos - p);\n  vec3 h = normalize(l + v);\n  float specular = pow(max(dot(n, h), 0.0), 16.0);\n  vec3 spec = specular * light_color;\n\n  return ambient + diffuse + spec;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    Ray ray = createRay(fragCoord);\n    //creates a color object\n    vec3 color = vec3(0.0);\n    //creates a hit object\n    Hit hit = Hit(1000000.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //checks if the ray hits the sphere\n    if (intersectRaySphere(ray, sphere, hit))\n    {\n        //if it does, it sets the color to the normal of the sphere\n        color = hit.normal;\n    }\n    //sets the color of the fragment\n    fragColor = vec4(color, 1.0);\n}\n", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float shininess = 64.0;\n\n    // raymarch\n    float t = raymarch(ro, rd);\n\n    // if we hit something\n    if (t < MAX_DIST)\n    {\n        // get the position of the hit\n        vec3 pos = ro + rd * t;\n\n        // get the normal of the hit\n        vec3 nor = calcNormal(pos);\n\n        // get the color of the hit\n        vec3 col = vec3(0.0);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 0.0));\n\n        // ambient\n        vec3 ambient = ka * vec3(1.0);\n\n        // diffuse\n        float diff = max(dot(nor, lightDir), 0.0);\n        vec3 diffuse = kd * diff * vec3(1.0);\n\n        // specular\n        vec3 reflectDir = reflect(-lightDir, nor);\n        float spec = pow(max(dot(rd, reflectDir), 0.0), shininess);\n        vec3 specular = ks * spec * vec3(1.0);\n\n        // combine\n        col = ambient + diffuse + specular;\n\n        // return the color\n        return col;\n    }\n\n    // if we didn't hit anything, return the background color\n    return vec3(0.0);\n}\n\nvoid main()\n{\n    // get the screen position\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // get the ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // get the ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n\n    // get the color\n    ve", "\n    return length(p) - rad;\n}\n\n//box\nfloat", "\n    float d = p.y;\n    d = max(d, -p.y - param.y);\n\n    // walls\n    d = max(d, abs(p.x) - param.x);\n    d = max(d, abs(p.z) - param.z);\n\n    return d;\n}\n\n// scene normal\nvec", "\n    float d = min(p.y, -p.y);\n    // walls\n    d = min(d, p.x);\n    d = min(d, -p.x);\n    d = min(d, p.z);\n    d = min(d, -p.z);\n    // sphere\n    d = min(d, length(p - vec3(0.0, 0.0, 0.0)) - param.x);\n    return d;\n}\n\n// scene distance without light gathering\nfloat", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float sh = 10.0;\n\n    // get the normal\n    vec3 n = normal(ro + rd * ti);\n\n    // get the light direction\n    vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n    // get the view direction\n    vec3 v = normalize(-ro);\n\n    // get the reflection direction\n    vec3 r = reflect(l, n);\n\n    // calculate the ambient, diffuse, and specular components\n    float amb = ka;\n    float dif = kd * max(dot(n, l), 0.0);\n    float spe = ks * pow(max(dot(r, v), 0.0), sh);\n\n    // calculate the final color\n    return vec3(amb + dif + spe);\n}\n\nvoid main()\n{\n    // get the ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(v_texcoord, 1.0));\n\n    // get the intersection time\n    float ti = intersect(ro, rd);\n\n    // if the ray intersects the sphere, color it\n    if (ti > 0.0)\n    {\n        // get the color of the ray\n        vec3 col = rayColor(ro, rd, ti);\n\n        // output the color\n        out_color = vec4(col, 1.0);\n    }\n    else\n    {\n        // if the ray does not intersect the sphere, output a black color\n        out_color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    p = mat2(0.70710678118654757, -0.70710678118654757, 0.70710678118654757, 0.70710678118654757) * p;\n    p = abs(p);\n    return max(p.x, p.y) - diamond.z;\n}\n\n// 2D rotation matrix.\nmat", "\n    // so that the background is not transformed.\n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n   ", "\n\tfloat d = sdSphere( pos, 1.0 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 4.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 6.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 8.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 10.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 12.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 14.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 16.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 18.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 20.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion", "\n\tvec3 light1 = vec3( 1.0, 1.0, 1.0 );\n\tvec3 light2 = vec3( -1.0, 1.0, 1.0 );\n\tvec3 light3 = vec3( 1.0, -1.0, 1.0 );\n\tvec3 light4 = vec3( -1.0, -1.0, 1.0 );\n\tvec3 light5 = vec3( 1.0, 1.0, -1.0 );\n\tvec3 light6 = vec3( -1.0, 1.0, -1.0 );\n\tvec3 light7 = vec3( 1.0, -1.0, -1.0 );\n\tvec3 light8 = vec3( -1.0, -1.0, -1.0 );\n\n\tvec3 ambient = vec3( 0.1, 0.1, 0.1 );\n\tvec3 diffuse = vec3( 0.0, 0.0, 0.0 );\n\tvec3 specular = vec3( 0.0, 0.0, 0.0 );\n\n\tvec3 l1 = normalize( light1 - v );\n\tvec3 l2 = normalize( light2 - v );\n\tvec3 l3 = normalize( light3 - v );\n\tvec3 l4 = normalize( light4 - v );\n\tvec3 l5 = normalize( light5 - v );\n\tvec3 l6 = normalize( light6 - v );\n\tvec3 l7 = normalize( light7 - v );\n\tvec3 l8 = normalize( light8 - v );\n\n\tvec3 e = normalize( eye - v );\n\n\tfloat d1 = max( dot( n, l1 ), 0.0 );\n\tfloat d2 = max( dot( n, l2 ), 0.0 );\n\tfloat d3 = max( dot( n, l3 ), 0.0 );\n\tfloat d4 = max( dot( n, l4 ), 0.0 );\n\tfloat d5 = max( dot(", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(", "\n    // 0.0    0.0000 |     0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float activity = a;\n    //Increase Activity Level For Better Performance\n    float activity2 = a;\n    //Increase Activity Level For Better Performance\n    float activity3 = a;\n    //Increase Activity Level For Better Performance\n    float activity4 = a;\n    //Increase Activity Level For Better Performance\n    float activity5 = a;\n    //Increase Activity Level For Better Performance\n    float activity6 = a;\n    //Increase Activity Level For Better Performance\n    float activity7 = a;\n    //Increase Activity Level For Better Performance\n    float activity8 = a;\n    //Increase Activity Level For Better Performance\n    float activity9 = a;\n    //Increase Activity Level For Better Performance\n    float activity10 = a;\n    //Increase Activity Level For Better Performance\n    float activity11 = a;\n    //Increase Activity Level For Better Performance\n    float activity12 = a;\n    //Increase Activity Level For Better Performance\n    float activity13 = a;\n    //Increase Activity Level For Better Performance\n    float activity14 = a;\n    //Increase Activity Level For Better Performance\n    float activity15 = a;\n    //Increase Activity Level For Better Performance\n    float activity16 = a;\n    //Increase Activity Level For Better Performance\n    float activity17 = a;\n    //Increase Activity Level For Better Performance\n    float activity18 = a;\n    //Increase Activity Level For Better Performance\n    float activity19 = a;\n    //Increase Activity Level For Better Performance\n    float activity20 = a;\n    //Increase Activity Level For Better Performance\n    float activity21 = a;\n    //Increase Activity Level For Better Performance\n    float activity22 = a;\n    //Increase Activity Level For Better Performance\n    float activity23 = a;\n    //Increase Activity Level For Better Performance\n    float activity24 = a;\n    //Increase Activity Level For Better Performance\n    float activity25 = a;\n    //Increase Activity Level For Better Performance\n    float activity26 = a;\n    //Increase Activity Level For Better Performance\n   ", ".\n    float d = length(p.xy) - r;\n    // How far up or down the point is, along the z-axis.\n    float z = abs(p.z) - h;\n    // Return the smallest distance to the cylinder.\n    return min(max(d, z), 0.0) + length(max(vec2(d, z), 0.0));\n}\n\n/**\n * Signed distance function for a box centered at the origin with the given dimensions.\n */\nfloat", "\n    p.yz *= rotate(iTime * 0.5);\n\n    // Add a sphere\n    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // Add a plane\n    float plane = p.y + 1.0;\n\n    // Add a box\n    float box = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // Add a torus\n    float torus = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a cylinder\n    float cylinder = length(p.xz - vec2(0.0, 2.0)) - 0.5;\n\n    // Add a cone\n    float cone = length(p - vec3(0.0, 0.0, 2.0)) - 1.0;\n\n    // Add a torus knot\n    float knot = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a sphere\n    float sphere2 = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // Add a plane\n    float plane2 = p.y + 1.0;\n\n    // Add a box\n    float box2 = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // Add a torus\n    float torus2 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a cylinder\n    float cylinder2 = length(p.xz - vec2(0.0, 2.0)) - 0.5;\n\n    // Add a cone\n    float cone2 = length(p - vec3(0.0, 0.0, 2.0)) - 1.", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = snoise(p);\n    n = n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*", "\n    //The only difference is that we are using a biomorph instead of a mandlebrot\n    //The biomorph is defined by the function z^2 + c\n    //Where c is the coordinate of the pixel\n    //z is the current value of the biomorph\n    //The biomorph is iterated until the magnitude of z is greater than 2\n    //or the maximum number of iterations is reached\n    //The color of the pixel is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of", "\n    // The \"w\" parameter is the \"width\" of the pattern.\n    p = mod(p, w);\n\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern", "\n    float r = length(p.xz);\n    float h = p.y;\n    \n    // The bump function.\n    return 1.0 - smoothstep(0.0, 0.01, abs(h) - 0.005 * r);\n}\n\n// The bump mapping function.\nfloat", "\n    //\n    // view_inv: inverse of the view matrix\n    // proj_inv: inverse of the projection matrix\n    // viewp_inv: inverse of the view-projection matrix\n    // scr_pt: screen coordinates of a point\n    //\n    // Returns:\n    //   vec4(0,0,0,0) if scr_pt is outside the viewport\n    //   vec4(0,0,0,1) if scr_pt is inside the viewport\n    //   vec4(x,y,z,1) if scr_pt is inside the viewport\n    //\n    // Note:\n    //   The returned vector is in world coordinates.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1", "\n    rounded = min(rounded, thick.y);\n\n    // Get the distance from the line.\n    float dist = LineDist(uv, pA, pB, thick, rounded);\n\n    // Get the distance from the dash.\n    float dashDist = LineDist(uv, pA, pB, thick, thick.y);\n\n    // If the dash is on, then we want to subtract the dash from the line.\n    // If the dash is off, then we want to add the dash to the line.\n    // This is a simple way to do a subtract or add operation.\n    return dist - dashOn * dashDist;\n}\n\n// This is the same as the above, but it returns a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\nfloat", "\n  vec3 lightPos = vec3(0.0, 10.0, 0.0);\n  vec3 lightDir = normalize(lightPos - p);\n  float diffuse = max(dot(n, lightDir), 0.0);\n  vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n  vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n  vec3 diffuseLight = diffuse * diffuseColor;\n  vec3 ambientLight = ambientColor;\n  vec3 light = diffuseLight + ambientLight;\n\n  // ambient occlusion\n  float ao = texture(aoMap, p.xz * 0.01).r;\n  light *= ao;\n\n  return light;\n}\n\n// Ray marching\n// p : ray origin\n// d : ray direction\n// t : distance to intersection\n// n : normal at intersection\n// m : material at intersection\nbool RayMarch(vec3 p, vec3 d, out float t, out vec3 n, out Material m)\n{\n  t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++)\n  {\n    vec3 p = p + d * t;\n    float h = Map(p);\n    if (h < 0.001)\n    {\n      n = GetNormal(p);\n      m = GetMaterial(p);\n      return true;\n    }\n    t += h;\n    if (t > MAX_DIST)\n    {\n      return false;\n    }\n  }\n  return false;\n}\n\n// Ray marching\n// p : ray origin\n// d : ray direction\n// t : distance to intersection\n// n : normal at intersection\n// m : material at intersection\nbool RayMarch(vec3 p, vec3 d, out float t, out vec3 n, out Material m, out vec3 p2)\n{\n  t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++)\n  {", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec", "          ___\n    float y = (x - a) / (b - a);                 //  /     \\      /     \\      /     \\      /     \\\n    y = y - floor(y);                           // /   ___  \\  /   ___  \\  /   ___  \\  /   ___  \\\n    y = y * 2;                                  // | /     \\ | | /     \\ | | /     \\ | | /     \\ |\n    y = y - 1;                                  // |/   ___  \\| |/   ___  \\| |/   ___  \\| |/   ___  \\\n    y = y * y;                                  // | | /     \\ | | | /     \\ | | | /     \\ | | | /     \\ |\n    y = y * y;                                  // | |/   ___  \\| | |/   ___  \\| | |/   ___  \\| | |/   ___  \\\n    y = y * y;                                  // | | | /     \\ | | | | /     \\ | | | | /     \\ | | | | /     \\ |\n    y = y * y;                                  // | | |/   ___  \\| | | |/   ___  \\| | | |/   ___  \\| | | |/   ___  \\\n    y = y * y;                                  // | | | | /     \\ | | | | | /     \\ | | | | | /     \\ | | | | | /     \\ |\n    y = y * y;                                  // | | | |/   ___  \\| | | | |/   ___  \\| | | | |/   ___  \\| | | | |/   ___  \\\n    y = y * y;                                  // | | | | | /     \\ | | | | | | /     \\ | | | | | | /     \\ | | | | | | /     \\ |\n    y = y * y;                                  // | | | | |/   ___  \\| | | | | |/   ___  \\| | | | | |/   ___  \\| | | | | |/   ___ ", "\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float a = rdrd*baba - bard*bard;\n    float b = rdrd*baoa - bard*rdoa;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    float t = (-b - sqrt(h))/a;\n    if( t<0.0 ) return vec4(-1.0);\n    vec3  n = oaoa + t*bard*ba - oa;\n    float d = dot(n,n);\n    return vec4( t, n*inversesqrt(d) );\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n\n\tvec2 p = P-U;\n\tfloat d = length(p);\n\t\n\tO = vec4(C, smoothstep(r,r-1.,d));\n}\n\nvoid main(void)\n{\n\tvec2 U = gl_FragCoord.xy;\n\tvec2 P = iMouse.xy;\n\t\n\tvec4 O = vec4(0.);\n\t\n\tsphere(O, U, P, 100., vec3(1.));\n\t\n\tgl_FragColor = O;\n}", "\n    p.xz *= rot(iTime * 0.5);\n    p.yz *= rot(iTime * 0.5);\n    p.xy *= rot(iTime * 0.5);\n\n    // add a sphere\n    float d = length(p) - 1.0;\n\n    // add a box\n    d = max(d, -box(p, vec3(0.5)));\n\n    // add a torus\n    d = max(d, -torus(p, vec2(0.5, 0.1)));\n\n    // add a cylinder\n    d = max(d, -cylinder(p, vec2(0.5, 0.1)));\n\n    // add a plane\n    d = max(d, p.y + 0.5);\n\n    return d;\n}\n\n// raymarching\nvec", "\n    float scale = float(N)/float(N-1);\n    float scale2 = scale*scale;\n    float scale3 = scale2*scale;\n    float scale4 = scale3*scale;\n    float scale5 = scale4*scale;\n    float scale6 = scale5*scale;\n    float scale7 = scale6*scale;\n    float scale8 = scale7*scale;\n    float scale9 = scale8*scale;\n    float scale10 = scale9*scale;\n    float scale11 = scale10*scale;\n    float scale12 = scale11*scale;\n    float scale13 = scale12*scale;\n    float scale14 = scale13*scale;\n    float scale15 = scale14*scale;\n    float scale16 = scale15*scale;\n    float scale17 = scale16*scale;\n    float scale18 = scale17*scale;\n    float scale19 = scale18*scale;\n    float scale20 = scale19*scale;\n    float scale21 = scale20*scale;\n    float scale22 = scale21*scale;\n    float scale23 = scale22*scale;\n    float scale24 = scale23*scale;\n    float scale25 = scale24*scale;\n    float scale26 = scale25*scale;\n    float scale27 = scale26*scale;\n    float scale28 = scale27*scale;\n    float scale29 = scale28*scale;\n    float scale30 = scale29*scale;\n    float scale31 = scale30*scale;\n    float scale32 = scale31*scale;\n    float scale33 = scale32*scale;\n    float scale34 = scale33*scale;\n    float scale35 = scale34*scale;\n    float scale36 = scale35*scale;\n    float scale37 = scale36*scale;\n    float scale38 = scale37*scale;\n    float scale39 = scale38*scale;\n    float scale40 = scale39*scale;\n    float scale41 = scale", "\n    p.x *= 1.0 + sin(p.y * 10.0) * 0.05;\n    p.y *= 1.0 + sin(p.x * 10.0) * 0.05;\n    \n    // The scale tiles are made of two sets of fans.\n    float fan1 = fan(p, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c", "\n    float flameDistance = length(currentRayPosition - flamePosition) - flameRadius;\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float wallDistance = sdBox(currentRayPosition, vec3(0.0), vec3(1.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float sphereDistance = sdSphere(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float planeDistance = sdPlane(currentRayPosition, vec3(0.0, 1.0, 0.0), vec3(0.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float boxDistance = sdBox(currentRayPosition, vec3(-0.5), vec3(0.5));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float cylinderDistance = sdCylinder(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float coneDistance = sdCone(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float torusDistance = sdTorus(currentRayPosition, vec3(0.0), 0.5, 0.1);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float capsuleDistance = sdCapsule(currentRayPosition, vec3(0.0), vec3(0.0, 0.0, 1.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float capsuleDistance2 = sdCapsule(currentRayPosition, vec3(0.0), vec3(0.0, 0.0, 1.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f", "\n    float sm2 = sm * sm;\n    \n    // Smoothing factor.\n    float sm3 = sm2 * sm;\n    \n    // Fractional part.\n    float fract = x - floor(x);\n    \n    // Smoothing factor.\n    float fract2 = fract * fract;\n    \n    // Smoothing factor.\n    float fract3 = fract2 * fract;\n    \n    // Smoothing factor.\n    float fract4 = fract2 * fract2;\n    \n    // Smoothing factor.\n    float fract5 = fract4 * fract;\n    \n    // Smoothing factor.\n    float fract6 = fract4 * fract2;\n    \n    // Smoothing factor.\n    float fract7 = fract6 * fract2;\n    \n    // Smoothing factor.\n    float fract8 = fract4 * fract4;\n    \n    // Smoothing factor.\n    float fract9 = fract8 * fract;\n    \n    // Smoothing factor.\n    float fract10 = fract8 * fract2;\n    \n    // Smoothing factor.\n    float fract11 = fract10 * fract2;\n    \n    // Smoothing factor.\n    float fract12 = fract8 * fract4;\n    \n    // Smoothing factor.\n    float fract13 = fract12 * fract2;\n    \n    // Smoothing factor.\n    float fract14 = fract12 * fract4;\n    \n    // Smoothing factor.\n    float fract15 = fract14 * fract2;\n    \n    // Smoothing factor.\n    float fract16 = fract12 * fract8;\n    \n    // Smoothing factor.\n    float fract17 = fract16 * fract2;\n    \n    // Smoothing factor.\n    float fract18 = fract16 * fract4;\n    \n    // Smoothing factor.\n    float fract19 = fract18 * fract2;\n    \n    // Smoothing factor.\n    float fract20 = fract16 * fract8;\n    \n    // Smoothing factor.\n    float fract21 = fract20 * fract2;\n    \n", "\n    //\n    // p = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n\n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n\n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 s0 = v0;\n    vec3 s1 = v1;\n    vec3 s2 = v2;\n    vec3 s3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 t0 = v0;\n    vec3 t1 = v1;\n    vec3 t2 = v2;\n    vec3 t3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 u0 = v0;\n    vec3 u1 = v1;\n    vec3 u2 = v2;\n    vec3 u3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 v0 = v0;\n    vec3 v1 = v1;\n    vec3 v2 = v2;\n    vec3 v3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simple", "\n    float n = snoise(p);\n    \n    // The quantized value.\n    float q = floor(n*10.0)/10.0;\n    \n    // The tapered value.\n    float t = smoothstep(-0.1, 0.1, n);\n    \n    // The final value.\n    return q*t;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel coordinates.\n    vec2 p = gl_FragCoord.xy;\n    \n    // The function value.\n    float f = func(p);\n    \n    // The final color.\n    vec3 c = vec3(f);\n    \n    // The output color.\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n  vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n  \n  // Then we define the radius of the balloon\n  float balloonRadius = 0.5;\n  \n  // Then we define the height of the balloon\n  float balloonHeight = 1.0;\n  \n  // Then we define the balloon color\n  vec3 balloonColor = vec3(1.0, 0.0, 0.0);\n  \n  // Then we define the balloon specular color\n  vec3 balloonSpecularColor = vec3(1.0, 1.0, 1.0);\n  \n  // Then we define the balloon specular power\n  float balloonSpecularPower = 10.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\t// return the intersection t value\n\tif( tN > tF ) return vec4(-1.0);\n\treturn vec4(tN, tF, tN, tF);\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n    \n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n    \n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square.\n    vec3 q0 = c0;\n    vec3 q1 = c1;\n    vec3 q2 = c2;\n    vec3 q3 = c3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle.\n    vec3 r0 = q0;\n    vec3 r1 = q1;\n    vec3 r2 = q2;\n    vec3 r3 = q3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle's point.\n    vec3 a0 = r0;\n    vec3 a1 = r1;\n    vec3 a2 = r2;\n    vec3 a3 = r3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle's point's \n    // fractional position.\n    vec3 b0 = a0;\n    vec3 b1 = a1", "\n //c=vec3(0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(", "\n    //Use a counter instead.\n    int i;\n    for(i=0; i<MAX_ITERATIONS; i++){\n        //Calculate the next iteration\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        //Check if the point is outside the circle with radius 2:\n        //(x*x+y*y) > 4\n        if(dot(z,z) > 4.0) break;\n    }\n    return float(i)/float(MAX_ITERATIONS);\n}\n\nvoid main() {\n    //Calculate the complex number for this pixel:\n    vec2 c = vec2(\n        (gl_FragCoord.x/float(width) - 0.5) * 4.0,\n        (gl_FragCoord.y/float(height) - 0.5) * 4.0\n    );\n    //Start the iteration at the origin\n    vec2 z = vec2(0.0, 0.0);\n    //Calculate the number of iterations\n    float m = mandelbrot(c, z);\n    //Output the number of iterations\n    gl_FragColor = vec4(vec3(m), 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    //we need to create the translation matrix\n    mat4 translation = mat4(1.0);\n    translation[3] = vec4(-cam, 1.0);\n\n    //we need to create the rotation matrix\n    mat4 rotation = mat4(1.0);\n    rotation[0] = vec4(x, 0.0);\n    rotation[1] = vec4(y, 0.0);\n    rotation[2] = vec4(z, 0.0);\n\n    //we need to create the view matrix\n    return rotation * translation;\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    p = p * 2.0;\n    \n    // Get the integer part of the grid position.\n    vec2 i = floor(p);\n    \n    // Get the fractional part of the grid position.\n    vec2 f = fract(p);\n    \n    // Get the direction of the grid.\n    vec2 dir = vec2(1.0, 0.0);\n    \n    // Rotate the grid.\n    mat2 rot = mat2(dir.x, -dir.y, dir.y, dir.x);\n    \n    // Rotate the fractional part of the grid position.\n    f = rot * f;\n    \n    // Get the distance to the grid.\n    float d = dot(f, f);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f -", "\n    float t = (x - a) / (b - a);\n    t = clamp(t, 0.0, 1.0);\n    return t;\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float dist = func(xy.x);\n    // if distance is less than 0.001, draw the curve\n    if (dist < 0.001)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold, float scale)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold, float scale, float offset)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale + offset)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func", "\n vec2 n=vec2(0.0,1.0);\n vec2 ne=vec2(1.0,1.0);\n vec2 e=vec2(1.0,0.0);\n vec2 se=vec2(1.0,-1.0);\n vec2 s=vec2(0.0,-1.0);\n vec2 sw=vec2(-1.0,-1.0);\n vec2 w=vec2(-1.0,0.0);\n vec2 nw=vec2(-1.0,1.0);\n // get the value of the current pixel\n float c=texture2D(iChannel0,p).x;\n // get the value of the neighbors\n float nv=texture2D(iChannel0,p+n).x;\n float nev=texture2D(iChannel0,p+ne).x;\n float ev=texture2D(iChannel0,p+e).x;\n float sev=texture2D(iChannel0,p+se).x;\n float sv=texture2D(iChannel0,p+s).x;\n float swv=texture2D(iChannel0,p+sw).x;\n float wv=texture2D(iChannel0,p+w).x;\n float nwv=texture2D(iChannel0,p+nw).x;\n // get the difference of the current pixel and its neighbors\n float dc=c-nv;\n float dn=nv-nev;\n float de=ev-nev;\n float ds=sev-ev;\n float dse=sev-sv;\n float dsw=swv-sv;\n float dw=wv-swv;\n float dnw=nwv-wv;\n // get the average of the differences\n float d=(dc+dn+de+ds+dse+dsw+dw+dnw)/8.0;\n // get the sign of the average\n float s=sign(d);\n // get the absolute value of the average\n float a=abs(d);\n // get the jitter value\n float jv=j*a;\n // get", "\n //f+=.05*sin(p.y*5.);\n //f+=.05*cos(p.x*5.);\n //f+=.05*sin(p.x*5.+p.y*5.);\n //f+=.05*cos(p.x*5.+p.y*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.+p.x*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p", ", but it works\n    c.r = c.r*1.05-0.05;\n    c.g = c.g*0.95+0.05;\n    c.b = c.b*1.05-0.05;\n    return c;\n}\n\n//this is a very simple \"color space\" conversion,\n//it's not a true conversion, but it's close enough\n//for our purposes.\nvec", "\n  vec3 d=abs(p)-s;\n  return vec4(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),1.0);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5", "\n    float dist = distScene(pos, depth, steps);\n    int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    Material mat = materials[matrIndex];\n    return Material(matrIndex, mat.color, mat.reflectivity, mat.refractiveIndex, mat.transparency);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float time)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    float dist = distScene(pos, depth, steps, time);\n    int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    Material mat = materials[matrIndex];\n    return Material(matrIndex, mat.color, mat.reflectivity, mat.refractiveIndex, mat.transparency);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float time, vec3 camPos)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distSc", "\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Tone mapping\nvec", "\n    p.z -= 1.0;\n    \n    // The number of iterations.\n    float n = 1.0;\n    \n    // The radius of the first circle.\n    float r = 1.0;\n    \n    // The radius of the next circle.\n    float r2 = 1.0;\n    \n    // The distance to the next circle.\n    float d = 1.0;\n    \n    // The distance to the next circle.\n    float d2 = 1.0;\n    \n    // The distance to the next circle.\n    float d3 = 1.0;\n    \n    // The distance to the next circle.\n    float d4 = 1.0;\n    \n    // The distance to the next circle.\n    float d5 = 1.0;\n    \n    // The distance to the next circle.\n    float d6 = 1.0;\n    \n    // The distance to the next circle.\n    float d7 = 1.0;\n    \n    // The distance to the next circle.\n    float d8 = 1.0;\n    \n    // The distance to the next circle.\n    float d9 = 1.0;\n    \n    // The distance to the next circle.\n    float d10 = 1.0;\n    \n    // The distance to the next circle.\n    float d11 = 1.0;\n    \n    // The distance to the next circle.\n    float d12 = 1.0;\n    \n    // The distance to the next circle.\n    float d13 = 1.0;\n    \n    // The distance to the next circle.\n    float d14 = 1.0;\n    \n    // The distance to the next circle.\n    float d15 = 1.0;\n    \n    // The distance to the next circle.\n    float d16 = 1.0;\n    \n    // The distance to the next circle.\n    float d17 = 1.0;\n    \n    // The distance to the next circle.\n    float d18 = 1.0;\n    \n    // The distance to the next circle.\n    float d19 = 1.0;\n    \n    // The distance to the next circle.", "\n    float d = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    if (d < 0.0) {\n        return mat(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n    mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    // initialize the fractal sum\n    float f = 0.0;\n\n    // octaves of noise\n    float amp = 0.5;\n    float freq = 4.0;\n    for ( int i=0; i<5; i++ ) {\n        // rotate the point\n        p = m * p * 2.02;\n\n        // add the noise\n        f += amp * noise( p );\n\n        // scale up the wavelenghts\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n\n    return f;\n}\n\nvoid main() {\n    // get the position of the fragment\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n\n    // get the noise value\n    float n = fbm( p * 10.0 );\n\n    // set the color\n    gl_FragColor = vec4( n, n, n, 1.0 );\n}\n", "\n    \n    // The first point is the wrapped cell point.\n    vec2 cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The second point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The third point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The fourth point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The fifth point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -", "\n return u.x*m.y-u.y*m.x;\n}\n\n//return __signed distance of [u] to line trough [a] and [b], a and b must be normalized.\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),dot(m,u)<0.);//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-", "\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1", "\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n\tfloat alpha = acos(dot(A, B));\n\tfloat beta = acos(dot(B, C));\n\tfloat gamma = acos(dot(C, A));\n\n\t//calculate area of spherical triangle\n\tfloat area = alpha + beta + gamma - PI;\n\n\t//calculate probability of sampling each triangle\n\tfloat pA = alpha / area;\n\tfloat pB = beta / area;\n\tfloat pC = gamma / area;\n\n\t//sample spherical triangle\n\tfloat r1 = Xi1;\n\tfloat r2 = Xi2;\n\tfloat p = r1 * area;\n\tif (p < pA) {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pA / area;\n\t} else if (p < pA + pB) {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pB / area;\n\t} else {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pC / area;\n\t}\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// *", "\n  v2 x;\n  x.x = U.x;\n  x.y = U.y;\n  return x;\n}\n\nv2 main(){\n  v1 a;\n  a.x = 1;\n  a.y = 2;\n  v2 b;\n  b = c(a);\n  return b;\n}\n", "\n    \n    // The tube is a square with a beveled edge.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with", "\n    float w = 0.05;\n\n    // The tube is made of two cylinders.\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0*w) - w;\n    float d = length(q.xz) - w;\n    float d2 = length(p.xz) - 0.95;\n\n    // The bands are made of two cylinders.\n    vec3 q2 = p;\n    q2.xz = mod(q2.xz, 2.0*w) - w;\n    float d3 = length(q2.xz) - 0.02;\n    float d4 = length(p.xz) - 0.97;\n\n    // The bands are made of two cylinders.\n    vec3 q3 = p;\n    q3.xz = mod(q3.xz, 2.0*w) - w;\n    float d5 = length(q3.xz) - 0.04;\n    float d6 = length(p.xz) - 0.99;\n\n    // The bands are made of two cylinders.\n    vec3 q4 = p;\n    q4.xz = mod(q4.xz, 2.0*w) - w;\n    float d7 = length(q4.xz) - 0.06;\n    float d8 = length(p.xz) - 1.01;\n\n    // The bands are made of two cylinders.\n    vec3 q5 = p;\n    q5.xz = mod(q5.xz, 2.0*w) - w;\n    float d9 = length(q5.xz) - 0.08;\n    float d10 = length(p.xz) - 1.03;\n\n    // The bands are made of two cylinders.\n    vec3 q6 = p;\n    q6.xz = mod(q6.xz, 2.0*w) - w;\n    float d11 = length(q6", "\n    vec3 id = floor(p);\n    \n    // Distance to the grid cell.\n    float d = length(max(abs(p)-gID,0.0));\n    \n    // Blink effect.\n    float blink = sin(iTime*10.0);\n    blink = blink*blink*blink;\n    \n    // Return the distance.\n    return d*blink;\n}\n\n// Distance function for the scene.\nfloat", "\n    float t = 0., d;\n    \n    // Raymarching loop.\n    for(int i = 0; i < 128; i++){\n        \n        // Get the distance to the scene at the current ray position.\n        d = map(o + r * t);\n        \n        // If the distance is less than the minimum distance, return the current ray distance.\n        if(d < EPS){\n            //glow = float(i) / 128.;\n            return t;\n        }\n        \n        // Increment the ray distance.\n        t += d;\n    }\n    \n    // If the ray didn't hit anything, return a large value.\n    return 1000.;\n}\n\n// Calculate the normal at a given point in the scene.\nvec", "\n    const int N = 10;\n    float h = 0.001;\n    float d = 0.0;\n    float s = 0.0;\n    for(int i = 0; i < N; i++){\n        d = sdf(ro + h * lp);\n        s += k * d;\n        h += d;\n    }\n    return clamp(1.0 - s / t, 0.0, 1.0);\n}\n\n// The main function.\nvec", "\n    float e =.0005 * (1.0 / t);\n\n    // Calculate the normal.\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec3 eps = vec3(e,0.0,0.0);\n        eps.xy *= HASH12(p.xy);\n        vec3 v = vec3(\n            map(p+eps.xyy, edge, crv, t),\n            map(p+eps.yxy, edge, crv, t),\n            map(p+eps.yyx, edge, crv, t)\n        );\n        n += v - map(p, edge, crv, t);\n    }\n\n    return normalize(n);\n}\n\n// Calculate the normal, and also the edge and curvature values.\nvec", "\n    vec3 w = vec3(dot(p3, m[0]), dot(p3, m[1]), dot(p3, m[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.", "\n    vec2 uv = vec2(df_truchet(p, dir), atan(p.y, p.x) / 3.1415926535897932384626433832795);\n    \n    // The Truchet distance field is a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.", "\n    q.x += sin(u_time * 0.5) * 0.05;\n    q.y += cos(u_time * 0.5) * 0.05;\n    \n    // Polar conversion.\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    \n    // The animation.\n    a += u_time * 0.5;\n    \n    // The color.\n    float c = cos(a * 10.0);\n    \n    // The color.\n    float f = smoothstep(0.0, 0.01, abs(r - 0.5 + c * 0.5));\n    \n    // The color.\n    return f;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel.\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    \n    // The color.\n    float f = getPolarCoord(q, 1.0);\n    \n    // The color.\n    vec3 col = vec3(f);\n    \n    // The color.\n    gl_FragColor = vec4(col, 1.0);\n}", "\n    vec3 w = vec3(dot(p3, n[0]), dot(p3, n[1]), dot(p3, n[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w.x, w.y, w.z, 1.0 - w.x - w.y - w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", ".\n  if (abs(r.w) < 1e-6 || abs(p.w) < 1e-6) {\n    return 0.0;\n  }\n  // The line is defined by the equation\n  //   r.x + t * (p.x - r.x) / r.w = q.x\n  //   r.y + t * (p.y - r.y) / r.w = q.y\n  //   r.z + t * (p.z - r.z) / r.w = q.z\n  //\n  // We can solve for t by substituting the above\n  // into the equation for the distance squared\n  //   (q.x - r.x)^2 + (q.y - r.y)^2 + (q.z - r.z)^2\n  //   = (p.x - r.x)^2 / r.w^2 + (p.y - r.y)^2 / r.w^2 + (p.z - r.z)^2 / r.w^2\n  //   + 2 * t * ((p.x - r.x) * (q.x - r.x) / r.w^2 + (p.y - r.y) * (q.y - r.y) / r.w^2 + (p.z - r.z) * (q.z - r.z) / r.w^2)\n  //\n  // We can solve for t by substituting the above\n  // into the equation for the distance squared\n  //   (q.x - r.x)^2 + (q.y - r.y)^2 + (q.z - r.z)^2\n  //   = (p.x - r.x)^2 / r.w^2 + (p.y - r.y)^2 / r.w^2 + (p.z - r.z)^2 / r.w^2\n  //   + 2 * t * ((p.x - r.x) * (q.x - r.x) / r.w^2 + (p.y - r.y) * (q", "\n    float t = floor(p.x) + floor(p.y);\n    float s = step(1.0, mod(t, 2.0));\n    \n    // The shadow.\n    float sh = s;\n    \n    // The line width.\n    float lW2 = lW * 0.5;\n    \n    // The line width.\n    float lW4 = lW2 * 0.5;\n    \n    // The line width.\n    float lW8 = lW4 * 0.5;\n    \n    // The line width.\n    float lW16 = lW8 * 0.5;\n    \n    // The line width.\n    float lW32 = lW16 * 0.5;\n    \n    // The line width.\n    float lW64 = lW32 * 0.5;\n    \n    // The line width.\n    float lW128 = lW64 * 0.5;\n    \n    // The line width.\n    float lW256 = lW128 * 0.5;\n    \n    // The line width.\n    float lW512 = lW256 * 0.5;\n    \n    // The line width.\n    float lW1024 = lW512 * 0.5;\n    \n    // The line width.\n    float lW2048 = lW1024 * 0.5;\n    \n    // The line width.\n    float lW4096 = lW2048 * 0.5;\n    \n    // The line width.\n    float lW8192 = lW4096 * 0.5;\n    \n    // The line width.\n    float lW16384 = lW8192 * 0.5;\n    \n    // The line width.\n    float lW32768 = lW16384 * 0.5;\n    \n    // The line width.\n    float lW65536 = lW32768 * 0.", "\n\tvec2 w = max(abs(ddx), abs(ddy));\n\t// analytical integral (box filter)\n\tvec2 i = 2.0*(p*p + (w*w - 0.25))/w;\n\t// x(t) = (i0 + 0.5*i1)*t + 0.5*(i0 - i1)\n\treturn (i.x + i.y)*0.5 + 0.5*(i.y - i.x);\n}\n\n// grid ratio\nfloat", "\n    mr = floor(n) + vec2(0.5);\n    // take half-cell position\n    mg = floor(f) + vec2(0.5);\n    // take cell corners\n    vec2 m[4];\n    m[0] = mr;\n    m[1] = mr + vec2(1.0, 0.0);\n    m[2] = mr + vec2(0.0, 1.0);\n    m[3] = mr + vec2(1.0, 1.0);\n    // find closest corner\n    float d = dot(m[0] - n, m[0] - n);\n    float d2 = dot(m[1] - n, m[1] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[1];\n    }\n    d2 = dot(m[2] - n, m[2] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[2];\n    }\n    d2 = dot(m[3] - n, m[3] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[3];\n    }\n    // find closest side\n    d2 = dot(m[0] - f, m[0] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[0];\n    }\n    d2 = dot(m[1] - f, m[1] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[1];\n    }\n    d2 = dot(m[2] - f, m[2] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[2];\n    }\n    d2 = dot(m[3] - f, m[3] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[", "\n    vec2 pos = vec2(0.0);\n    if(t < 0.0){\n        pos = vec2(0.0);\n    }else if(t < 0.25){\n        pos = vec2(0.0, 0.5);\n    }else if(t < 0.5){\n        pos = vec2(0.5, 0.5);\n    }else if(t < 0.75){\n        pos = vec2(0.5, 0.0);\n    }else if(t < 1.0){\n        pos = vec2(0.0, 0.0);\n    }\n    return pos;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    //\n    // 1 out, 2 in...\n    //\n    // vec3 p3 = fract(vec3(p.xyx) *.1031);\n    // p3 += dot(p3, p3.yzx + 33.33);\n    // return fract((p3.xx+p3.yz)*p3.zy);\n\n    // 2 out, 2 in...\n    //\n    // const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n    //                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n    //                    -0.577350269189626,  // -1.0 + 2.0 * C.x\n    //                     0.024390243902439); // 1.0 / 41.0\n    // vec4 p4 = fract(vec4(p.xyxy) * C.www);\n    // p4 += dot(p4, p4.wzxy+C.xxzz);\n    // return vec2(p4.x, p4.y + p4.z);\n\n    // 2 out, 3 in...\n    //\n    // const vec3 C = vec3(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n    //                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n    //                    -0.577350269189626); // -1.0 + 2.0 * C.x\n    // vec4 p4 = fract(vec4(p.xyxy) * C.xyzz);\n    // p4 += dot(p4, p4.wzxy+", "\n    //\n    // float n = sin(p.x) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // n += sin(p.y) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // return n;\n\n    // This is a pretty standard 2D hash, but it's a bit slower than the one above,\n    // so if you're in a hurry, and framerate is not a huge issue for you, go with\n    // this one.\n    float n = p.x * 17.0 + p.y * 23.0;\n    return fract(sin(n) * 43758.5453123);\n}\n\n// vec3 to float hash.\nfloat", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n    \n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n    \n    // Incenter.\n    return (a * p0 + b * p1 + c * p2) / (a + b + c);\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can be drawn around a triangle.\nvec", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float A = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Radius of the incircle.\n    return A / s;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat", "\n   // The projection is a plane in 3D space.\n   // The plane is defined by three points.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the", "\n    vec2 v0, v1, v2, v3, v4, v5, v6, v7;\n    \n    // The first step is to find the cell that the point is in.\n    // We do this by finding the cell that contains the point, and then iterating through the cell's neighbors\n    // until we find a quadrilateral.\n    //\n    // The cell that contains the point is the cell that contains the point's x and y coordinates.\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //set background color\n    vec3 col = vec3(0.0);\n\n    //set up camera\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    //set up ray\n    vec3 rayOrigin = camPos;\n    vec3 rayDir = normalize(camRight * uv.x + camUp * uv.y + camDir);\n\n    //set up sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 1.0);\n    float sphereRadius = 0.5;\n\n    //intersect ray with sphere\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayOrigin - sphereCenter, rayDir);\n    float c = dot(rayOrigin - sphereCenter, rayOrigin - sphereCenter) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant > 0.0) {\n        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n        if (t > 0.0) {\n            vec3 hitPos = rayOrigin + rayDir * t;\n            vec3 normal = normalize(hitPos - sphereCenter);\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    }\n\n    //output color\n    fragColor", "\n    //p = fract(p * vec2(233.34, 851.73));\n    //p += dot(p, p + 23.45);\n    \n    // I like this one best.\n    p = p*p*157.139 + p*137.549;\n    return fract((p + vec2(233.34, 851.73))*p);\n    \n    // Another nice one from IQ\n    //p = p*p*p*p*521.0 + p*p*p*196.0 + p*p*39.346 + p*78.253;\n    //return fract(p);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float distance( in vec3 a, in vec3 b ) { return length( a - b ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the cross product of two//\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 cross( in vec3 a, in vec3 b ) { return vec3( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the normalize of a     //\n    // vector.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 normalize( in vec3 a ) { return a / length(a); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the reflection of a    //\n    // vector.                                                                  ", "\n    // Find whether the hit point is in shadow or not.\n    // If there is no intersection, return the background color.\n    // If there is intersection, return the color.\n    /////////////////////////////////////////////////////////////////////////////\n    // \u627e\u5230\u5149\u7ebf\u662f\u5426\u4e0e\u67d0\u4e9b\u7269\u4f53\u76f8\u4ea4\u3002\n    // \u627e\u5230\u6700\u8fd1\u7684\u4ea4\u70b9\u3002\n    // \u627e\u5230\u4ea4\u70b9\u662f\u5426\u5728\u9634\u5f71\u4e2d\u3002\n    // \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\u3002\n    // \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u989c\u8272\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    hasHit = false;\n    float tmin = 1e10;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        if (objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp)) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;\n            k_rg = k_rg_temp;\n        }\n    }\n    if (!hasHit) {\n        return backgroundColor;\n    }\n\n    // Compute the color using Phong Lighting Model.\n    /////////////////////////////////////////////////////////////////////////////\n    // \u4f7f\u7528Phong\u7167\u660e\u6a21\u578b\u8ba1\u7b97\u989c\u8272\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < numLights; i++) {\n        // Compute the diffuse and specular components.\n        /////////////////////////////////////////////////////////////////////////////\n        // \u8ba1\u7b97\u6f2b\u53cd\u5c04\u548c\u955c\u9762\u53cd\u5c04\u5206\u91cf\u3002\n        /////////////////////////////////////////////////////////////////////////////\n        vec3 lightDir = normalize(lights[i].position - hitPos);\n        float diffuse = max(dot(lightDir, hitNormal), 0.0);\n        vec3 reflectDir = reflect(-lightDir, hitNormal);\n        float specular = pow(max(dot(reflectDir, normalize(ray.direction)), 0.0), 16.0);\n\n        // Compute the shadow.\n       ", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p20 = p0 - p2;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // angles\n    float a01 = atan(p01.y, p01.x);\n    float a12 = atan(p12.y, p12.x);\n    float a20 = atan(p20.y, p20.x);\n\n    // min/max angles\n    float amin = min(a01, min(a12, a20));\n    float amax = max(a01, max(a12, a20));\n\n    // min/max distances\n    float dmin = min(d01, min(d12, d20));\n    float dmax = max(d01, max(d12, d20));\n\n    // compute bounding box\n    vec2 pmin = vec2(cos(amin), sin(amin)) * dmin;\n    vec2 pmax = vec2(cos(amax), sin(amax)) * dmax;\n\n    return vec4(pmin, pmax);\n}\n\n// Exact BBox to a cubic bezier\nvec", "\n    vec3 pmin = min( min( p0, p1 ), min( p2, p3 ) );\n    vec3 pmax = max( max( p0, p1 ), max( p2, p3 ) );\n\n    // control points\n    vec3 c0 = ( p0 + p1 ) * 0.5;\n    vec3 c1 = ( p1 + p2 ) * 0.5;\n    vec3 c2 = ( p2 + p3 ) * 0.5;\n    vec3 c3 = ( c0 + c1 ) * 0.5;\n    vec3 c4 = ( c1 + c2 ) * 0.5;\n    vec3 c5 = ( c3 + c4 ) * 0.5;\n\n    // control points\n    vec3 c6 = ( c0 + c3 ) * 0.5;\n    vec3 c7 = ( c3 + c5 ) * 0.5;\n    vec3 c8 = ( c5 + c6 ) * 0.5;\n    vec3 c9 = ( c6 + c7 ) * 0.5;\n    vec3 c10 = ( c7 + c8 ) * 0.5;\n    vec3 c11 = ( c8 + c9 ) * 0.5;\n    vec3 c12 = ( c9 + c10 ) * 0.5;\n    vec3 c13 = ( c10 + c11 ) * 0.5;\n    vec3 c14 = ( c11 + c12 ) * 0.5;\n    vec3 c15 = ( c12 + c13 ) * 0.5;\n    vec3 c16 = ( c13 + c14 ) * 0.5;\n    vec3 c17 = ( c14 + c15 ) * 0.5;\n    vec3 c18 = ( c15 + c16 ) * 0.5;\n    vec3 c19 = ( c16 + c17 ) * 0.5;\n", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TWO_PI = 6.283185307179586476925286766559;\n    const float HALF_PI = 1.5707963267948966192313216916398;\n    const float INV_PI = 0.31830988618379067153776752674503;\n    const float INV_TWO_PI = 0.15915494309189533576888378337251;\n    const float INV_HALF_PI = 0.63661977236758134307553505349006;\n    const float SQRT_TWO = 1.4142135623730950488016887242097;\n    const float SQRT_THREE = 1.7320508075688772935274463415059;\n    const float SQRT_TWO_PI = 2.5066282746310005024157652848110;\n    const float SQRT_HALF_PI = 1.2533141373155002512078826424055;\n    const float SQRT_INV_TWO_PI = 0.79788456080286535587989211986876;\n    const float SQRT_INV_", "\n    return 0.5 * ( 1.0 - cos( k * PI ) ); // EaseInOut\n}\n\n/**\n * Linear Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    // i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    // i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n                        + i.x + vec3(0.0, i1.x, 1", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    coord -= res/2.0;\n\n    // Scale the coordinate so that the julia set is in the [-2;-2] - [2;2] space.\n    coord *= 4.0/res.x;\n\n    return coord;\n}\n\n// Calculate the distance from the origin to the point (x;y).\nfloat", "\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Higher quality, more disperse, but slower.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D simplex noise.\n//\n// Should match the noise function in the noise module.\nfloat", "\n    const float eps = 0.0005;\n    const vec2 h = vec2(eps,0);\n    return normalize( p - vec3(\n        map(p-h.xyy).x,\n        map(p-h.yxy).x,\n        map(p-h.yyx).x ) );\n}\n\n// Tetrahedral distance function.\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float angle = width * 2. * PI;\n    float r = radius * cos(angle);\n    float h = radius * sin(angle);\n    float d = sqrt(r*r + h*h);\n    float a = atan(h, r);\n    float b = atan(h, d-r);\n    float c = atan(h, d);\n    float d1 = a - b;\n    float d2 = c - b;\n    float d3 = c - a;\n    float d4 = b - a;\n    float d5 = c - a;\n    float d6 = c - b;\n    float d7 = b - a;\n    float d8 = c - b;\n    float d9 = a - b;\n    float d10 = c - a;\n    float d11 = b - a;\n    float d12 = c - b;\n    float d13 = a - b;\n    float d14 = c - a;\n    float d15 = b - a;\n    float d16 = c - b;\n    float d17 = a - b;\n    float d18 = c - a;\n    float d19 = b - a;\n    float d20 = c - b;\n    float d21 = a - b;\n    float d22 = c - a;\n    float d23 = b - a;\n    float d24 = c - b;\n    float d25 = a - b;\n    float d26 = c - a;\n    float d27 = b - a;\n    float d28 = c - b;\n    float d29 = a - b;\n    float d30 = c - a;\n    float d31 = b - a;\n    float d32 = c - b;\n    float d33 = a - b;\n    float d34 = c - a;\n    float d35 = b - a;\n    float d36 = c - b;\n    float d37 = a - b;\n    float d38 = c - a;\n    float d39 = b - a;\n   ", "\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0),\n                            dot(x1, x1),\n                            dot(x2, x2)),\n                0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h =", "\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t\n\t// camera\n\tvec3 camPos = vec3(0.0, 0.0, 2.0);\n\tvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n\t\n\t// ray\n\tvec3 rayDir = normalize(camDir + uv.x*camRight + uv.y*camUp);\n\t\n\t// sphere\n\tvec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n\tfloat sphereRadius = 1.0;\n\t\n\t// ray-sphere intersection\n\tvec3 oc = camPos - sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(oc, rayDir);\n\tfloat c = dot(oc, oc) - sphereRadius*sphereRadius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d < 0.0){\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\tfloat t = (-b - sqrt(d)) / (2.0*a);\n\tvec3 hitPos = camPos + t*rayDir;\n\tvec3 normal = normalize(hitPos - sphereCenter);\n\t\n\t// lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 5.0);\n\tvec3 lightDir = normalize(lightPos - hitPos);\n\tfloat diffuse = max(dot(normal, lightDir), 0.0);\n\t\n\t// shading\n\tfragColor = vec4(diffuse, diffuse, diffuse, 1.0);\n}", "\n    vec3 s = vec3(7, 157, 113);\n\n    // Integer part, floor(p), then mod 289.\n    vec3 i = floor(mod(p, 289.0));\n\n    // Fractional part, after the decimal point.\n    vec3 f = fract(p);\n\n    // This is the first part of the hash.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // This is the second part of the hash.\n    return mix(mix(mix( dot( s, i + vec3(0.0, 0.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 0.0, 0.0) ), u.x),\n                   mix( dot( s, i + vec3(0.0, 1.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 1.0, 0.0) ), u.x), u.y),\n               mix(mix( dot( s, i + vec3(0.0, 0.0, 1.0) ),\n                        dot( s, i + vec3(1.0, 0.0, 1.0) ), u.x),\n                   mix( dot( s, i + vec3(0.0, 1.0, 1.0) ),\n                        dot( s, i + vec3(1.0, 1.0, 1.0) ), u.x), u.y), u.z);\n}\n\n// Thanks Shane.\nfloat", "\n\tsp = log_spherical(p);\n\n\t// Apply the tiling\n\ttp = tiling(sp);\n\n\t// Apply the rotation\n\trp = rotation(tp);\n\n\t// Compute the scaling factor\n\tmul = scaling(rp);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d, out float d1, out float d2)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n\n\t// Compute the log-spherical distance of the first point\n\td1 = length(p1);\n\n\t// Compute the log-spherical distance of the second point\n\td2 = length(p2);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d, out float d1, out float d2, out float d3)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n\n\t// Compute the log-spherical distance of the first point\n\td1 = length(p1);\n\n\t// Compute the log-spherical distance of the second point\n\td2 = length(p2);\n\n\t// Compute the log-spherical distance of the third point\n\td3 = length(p1 + p2);\n}\n\n/*", "\n    float y = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float r = cos(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d = length(p-vec3(0.0,y,0.0))-r;\n    \n    //distance to plane = distance to plane minus height\n    float h = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d2 = p.y-h;\n    \n    //return the minimum of the two distances\n    return vec2(min(d,d2),0.0);\n}\n\n//the normal function returns the normal at a point\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\t// T to R\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), aaSize);\n\t// R to B\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), aaSize);\n\t// B to L\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0), aaSize);\n\n\t// L to R\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\t// R to T\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), aaSize);\n\t// T to L\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0), aaSize);\n\t// L to T\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\n\t// T to B\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1", "\n    mat3 rot = getRotationMatrix(boxRotation);\n\n    // rotate the position\n    pos = rot * pos;\n\n    // get the distance to the box\n    float dist = length(max(abs(pos) - boxSize, 0.0));\n\n    // return the distance and the material ID\n    return vec2(dist, boxMaterial);\n}\n\n// returns the distance to our sphere and the its associated material ID packed into a vec2\nvec", "\n    float y = sin(pos.x * 0.5 + time * 0.5) * 0.5 + 0.5;\n\n    // return the distance to the sphere and the material ID\n    return vec2(length(pos - vec3(0.0, y, 0.0)) - 0.5, 0.0);\n}\n\n// returns the distance to the ground plane\nfloat", "\n    vec2 s1 = sdSphere(pos, vec3(0.0, 0.0, 0.0), 1.0);\n    vec2 s2 = sdBox(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec2 s3 = sdCylinder(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s4 = sdCone(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s5 = sdPlane(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec2 s6 = sdTriangle(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec2 s7 = sdTorus(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s8 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s9 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s10 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0", "\n    vec3 rayDir = normalize(camDir + (fragCoord.x * u_camRight) + (fragCoord.y * u_camUp));\n    \n    // march the ray through the scene\n    vec4 color = march(camPos, rayDir);\n    \n    // apply lighting\n    color.rgb *= (0.5 + dot(lightDir, rayDir) * 0.5);\n    \n    return color;\n}\n\nvoid main() {\n    \n    // calculate the camera position and direction\n    vec3 camPos = u_camPos;\n    vec3 camDir = normalize(u_camDir);\n    \n    // calculate the direction of the light\n    vec3 lightDir = normalize(u_lightDir);\n    \n    // raymarch the scene\n    vec4 color = marchScene(v_fragCoord, camPos, camDir, lightDir);\n    \n    // output the color\n    gl_FragColor = color;\n}\n", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n//https://www.shadertoy.com/view/XsXXD1\nfloat", "\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\t// ray direction\n\tvec3 rayDir = normalize(vec3(uv, 1.0));\n\n\t// ray origin\n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\n\t// ray marching\n\tfloat t = 0.0;\n\tfloat maxDist = 100.0;\n\tfloat minDist = 0.001;\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\tvec3 color = vec3(0.0);\n\tfloat specular = 0.0;\n\tfloat shadow = 1.0;\n\tfloat shadowDist;\n\tvec3 shadowRayOrigin;\n\tvec3 shadowRayDir;\n\tvec3 shadowPos;\n\tvec3 shadowNormal;\n\tfloat shadowT;\n\tfloat shadowMaxDist;\n\tfloat shadowMinDist;\n\tfloat shadowDist;\n\tvec3 shadowColor = vec3(0.0);\n\tfloat shadowSpecular = 0.0;\n\tfloat shadowShadow = 1.0;\n\tfloat shadowShadowDist;\n\tvec3 shadowShadowRayOrigin;\n\tvec3 shadowShadowRayDir;\n\tvec3 shadowShadowPos;\n\tvec3 shadowShadowNormal;\n\tfloat shadowShadowT;\n\tfloat shadowShadowMaxDist;\n\tfloat shadowShadowMinDist;\n\tfloat shadowShadowDist;\n\tvec3 shadowShadowColor = vec3(0.0);\n\tfloat shadowShadowSpecular = 0.0;\n\tfloat shadowShadowShadow = 1.0;\n\tfloat shadowShadowShadowDist;\n\tvec3 shadowShadowShadowRayOrigin;\n\tvec3 shadowShadowShadowRayDir;\n\tvec3 shadowShadowShadowPos;\n\tvec3 shadowShadowShadowNormal;\n\tfloat shadowShadowShadowT;\n\tfloat shadowShadowShadowMaxDist;\n\tfloat shadowShadowShadowMinDist;\n\tfloat shadowShadowShadowDist;\n\tvec3 shadowShadowShadowColor", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", " cell\n    ivec3 g = ix >> uvec3(1,1,1);\n    // grid cell offset\n    vec3 gf = fract(fx);\n    // grid cell corners\n    vec3 g000 = vec3(g.x, g.y, g.z);\n    vec3 g100 = vec3(g.x+1, g.y, g.z);\n    vec3 g010 = vec3(g.x, g.y+1, g.z);\n    vec3 g110 = vec3(g.x+1, g.y+1, g.z);\n    vec3 g001 = vec3(g.x, g.y, g.z+1);\n    vec3 g101 = vec3(g.x+1, g.y, g.z+1);\n    vec3 g011 = vec3(g.x, g.y+1, g.z+1);\n    vec3 g111 = vec3(g.x+1, g.y+1, g.z+1);\n    // grid cell corners offset\n    vec3 g000f = fract(g000);\n    vec3 g100f = fract(g100);\n    vec3 g010f = fract(g010);\n    vec3 g110f = fract(g110);\n    vec3 g001f = fract(g001);\n    vec3 g101f = fract(g101);\n    vec3 g011f = fract(g011);\n    vec3 g111f = fract(g111);\n    // grid cell corners random value\n    float n000 = hash(g000);\n    float n100 = hash(g100);\n    float n010 = hash(g010);\n    float n110 = hash(g110);\n    float n001 = hash(g001);\n", "\n    // and integer octaves\n    int period = 100;\n    int lacunarity = 2;\n    int octaves = 5;\n    float h = 0.0;\n    float g = -0.7;\n    float f = 0.5;\n    float a = 0.5;\n    float t = 1.0;\n    for(int i = 0; i < octaves; i++){\n        h += a * noise(fxyz);\n        fxyz = f * fxyz;\n        a *= g;\n        t *= lacunarity;\n    }\n    return h;\n}\n\nvoid main() {\n    // get the position of the current pixel\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    // get the position of the current pixel in the world\n    vec3 pos = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos2 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos3 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos4 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos5 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos6 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos7 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos8 = vec3(uv * 2.0 -", "\n    p.y -= h * 0.5;\n\n    // Capsule\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h*0.5);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos", "\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n\n  // Compute the normal by taking the gradient of the distance function\n  vec3 n = vec3(\n    distance_function(p + eps.xyy) - distance_function(p - eps.xyy),\n    distance_function(p + eps.yxy) - distance_function(p - eps.yxy),\n    distance_function(p + eps.yyx) - distance_function(p - eps.yyx)\n  );\n\n  return normalize(n);\n}\n\n// Compute the color of a point on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float a = dot(rd,rd);\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - ra*ra;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float t1 = (-b-d)/a;\n    float t2 = (-b+d)/a;\n    if( t1>t2 ) { float tmp=t1; t1=t2; t2=tmp; }\n    if( t1<0.0 ) t1 = t2;\n    if( t1<0.0 ) return -1.0;\n    return t1;\n}\n\n// -----------------------------\n// sphere\n// -----------------------------\nfloat", "\n    vec2 w = abs(dpdx) + abs(dpdy);\n    // analytic 2D gradient\n    vec2 g = vec2(dpdy.x*p.x - dpdx.x*p.y, dpdy.y*p.x - dpdx.y*p.y);\n    // range in [-w,w]\n    g = clamp(g,-w,w);\n    // range in [0,1]\n    g = (g + w) / (2.0*w);\n    // range in [-1,1]\n    g = g * 2.0 - 1.0;\n    // range in [0,1]\n    g = (g + 1.0) / 2.0;\n    // range in [0,1] again\n    g = smoothstep(0.0,1.0,g);\n    // return 1D gradient\n    return g.x*g.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -2.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 2.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 2.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -2.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].center.x = 0.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = -2.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].center.x = 0.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n    // Compute the intersection between the ray and the sphere.\n    // If there is an intersection, return true and output the value of t,\n    // the position of the intersection and the normal vector at the intersection.\n    // Otherwise, return false.\n    //\n    // Hint: You can use the quadratic equation to solve the intersection.\n    //\n    // Hint: You can use the following functions:\n    //       dot(vec3 a, vec3 b)\n    //       length(vec3 v)\n    //       normalize(vec3 v)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint: You can use the following operators:\n    //       + - * /\n    //\n    // Hint: You can use the following functions:\n    //       pow(float x, float y)\n    //       sqrt(float x)\n    //       min(float x, float y)\n    //       max(float x, float y)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint: You can use the following operators:\n    //       + - * /\n    //\n    // Hint: You can use the following functions:\n    //       pow(float x, float y)\n    //       sqrt(float x)\n    //       min(float x, float y)\n    //       max(float x, float y)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint", "\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float distance( in vec3 a, in vec3 b ) { return length( a - b ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the cross product of two//\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 cross( in vec3 a, in vec3 b ) { return vec3( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the normalize of a     //\n    // vector.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 normalize( in vec3 a ) { return a / length(a); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the reflection of a    //\n    // vector.                                                                   //\n    //////////////////////////////////////////////////////////////////////////", "\n    hasHit = false;\n    float tmin = INFINITY;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        bool hit = objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp);\n        if (hit) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;\n            k_rg = k_rg_temp;\n        }\n    }\n\n    // If there was no intersection, return background color\n    if (!hasHit) {\n        return backgroundColor;\n    }\n\n    // Compute color using Phong Lighting Model\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < numLights; i++) {\n        // Compute the color from the ith light source\n        vec3 lightColor = lights[i].ComputeColor(hitPos, hitNormal, k_rg);\n        color += lightColor;\n    }\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of the pixel at (x, y) by casting a ray into the scene\n// and finding the color at the nearest intersection point.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float tp = (0.5-ro.y)/rd.y; if( tp>0.0 ) mint = max( mint, tp );\n    float tm = (1.5-ro.y)/rd.y; if( tm>0.0 ) tmax = min( tmax, tm );\n    if( mint>tmax ) return 1.0;\n\n    // raymarch loop\n    float res = 1.0;\n    for( int i=ZERO; i<NUM_STEPS; i++ )\n    {\n        float h = map( ro + rd*mint );\n        res = min( res, 8.0*h/mint );\n        mint += clamp( h, 0.02, 0.1 );\n        if( mint>tmax ) break;\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid main()\n{\n    vec3 pos = position;\n    vec3 normal = normalize(normalMatrix * normal);\n    vec3 tangent = normalize(normalMatrix * tangent);\n    vec3 bitangent = normalize(normalMatrix * bitangent);\n    \n    vec3 viewDir = normalize(viewPos - pos);\n    vec3 reflectDir = reflect(-viewDir, normal);\n    \n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0);\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambient = 0.1 * lightColor;\n    vec3 diffuse = diff * lightColor;\n    vec3 specular = spec * lightColor;\n    \n    vec3 color = texture(texture_diffuse1, texCoord).rgb;\n    vec3 normalMap = texture(texture_normal1, texCoord).rgb;\n    normalMap = normalize(normalMap * 2.0 - 1.0);\n    normalMap = normalize", "\n    vec3 camera_pos = start + dir * planet_radius;\n\n    // calculate the rayleigh and mie scattering\n    vec3 rayleigh_scattering = beta_ray * exp(-beta_absorption * height_ray);\n    vec3 mie_scattering = beta_mie * exp(-beta_absorption * height_mie);\n\n    // calculate the primary ray\n    vec3 primary_ray = primary_ray_trace(\n        camera_pos, \n        dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_absorption, \n        height_absorption, \n        absorption_falloff, \n        steps_i\n    );\n\n    // calculate the light ray\n    vec3 light_ray = light_ray_trace(\n        camera_pos, \n        light_dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_absorption, \n        height_absorption, \n        absorption_falloff, \n        steps_l\n    );\n\n    // calculate the final color\n    vec3 color = primary_ray * rayleigh_scattering + light_ray * mie_scattering + scene_color * beta_ambient;\n\n    // return the final color\n    return color;\n}\n\n/*\nThe main function.\nThis is the function that is called when the shader is run.\nIt takes in the camera position, the camera vector, the maximum distance the ray can travel, the color of the scene, the direction of the light, the intensity of the light, the position of the planet, the radius of the planet, the radius of the atmosphere, the amount of rayleigh scattering, the amount of mie scattering, the amount of absorption, the amount of ambient scattering, the direction of mie scattering, the height at which there is no rayleigh scattering, the height at which there is no mie scattering, the height at which there is no absorption, the falloff of the absorption, the amount of steps along the primary ray, and the amount of steps along the", "\n    vec3 bent_normal = normalize(mix(surface_normal, light_dir, 0.5));\n\n    // sample the atmosphere\n    vec3 sample_col = sample_atmosphere(sample_pos, bent_normal);\n\n    // mix the sample with the background color\n    return mix(sample_col, background_col, 0.5);\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the ray origin and direction, the current time, and the background color.\n\nIt returns the color of the planet at the given ray.\n*/\nvec", "\n    vec4 color = vec4(0.0);\n    \n    // the distance to the surface\n    float dist = 0.0;\n    \n    // the raymarching step\n    float step = 0.0;\n    \n    // the raymarching distance\n    float march = 0.0;\n    \n    // the raymarching distance\n    float march_dist = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = ", " and position\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(fragCoord.x - 0.5 * iResolution.x, fragCoord.y - 0.5 * iResolution.y, 1.0));\n    \n    // get the light direction\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    // draw the atmosphere\n    fragColor = drawAtmosphere(camPos, camDir, lightDir);\n}\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b * b - c;\n    if (discr < 0.0) return -1.0;\n    else return b - sqrt(discr);\n}\n\n//-----------------------------------------------------------------------\nfloat", "ialize the ray\n    vec3 rayPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    //initialize the color\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    //initialize the distance\n    float distance = 0.0;\n\n    //initialize the material\n    Material material;\n\n    //initialize the hit\n    bool hit = false;\n\n    //initialize the normal\n    vec3 normal;\n\n    //initialize the hit position\n    vec3 hitPos;\n\n    //initialize the hit normal\n    vec3 hitNormal;\n\n    //initialize the hit material\n    Material hitMaterial;\n\n    //initialize the hit distance\n    float hitDistance;\n\n    //initialize the hit object\n    int hitObject;\n\n    //initialize the hit object index\n    int hitObjectIndex;\n\n    //initialize the hit object index\n    int hitObjectIndex2;\n\n    //initialize the hit object index\n    int hitObjectIndex3;\n\n    //initialize the hit object index\n    int hitObjectIndex4;\n\n    //initialize the hit object index\n    int hitObjectIndex5;\n\n    //initialize the hit object index\n    int hitObjectIndex6;\n\n    //initialize the hit object index\n    int hitObjectIndex7;\n\n    //initialize the hit object index\n    int hitObjectIndex8;\n\n    //initialize the hit object index\n    int hitObjectIndex9;\n\n    //initialize the hit object index\n    int hitObjectIndex10;\n\n    //initialize the hit object index\n    int hitObjectIndex11;\n\n    //initialize the hit object index\n    int hitObjectIndex12;\n\n    //initialize the hit object index\n    int hitObjectIndex13;\n\n    //initialize the hit object index\n    int hitObjectIndex14;\n\n    //initialize the hit object index\n    int hitObjectIndex15;\n\n    //initialize the hit object index\n    int hitObjectIndex16;\n\n    //initialize the hit object index\n    int hit", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", " ray\n    RayQueue ray_queue = RayQueue(ray_origin, ray_target);\n\n    // Initialize the sample color\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the number of reflections and refractions\n    int num_reflections = 0;\n    int num_refractions = 0;\n\n    // Initialize the number of bounces\n    int num_bounces = 0;\n\n    // Initialize the number of samples\n    int num_samples = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg_min = 0;\n\n", "\n    vec2 id = floor(p);\n    vec2 pos = p - id;\n    \n    // Local cell color ID.\n    float cid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 color = vec3(0.0);\n    \n    // Local cell color ID.\n    float nid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 ncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance to sphere\n    return length(p - sphere_pos) - sphere_radius;\n}\n\n// Get normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // calculate the hash\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0 );\n    FAST32_hash_3D( Pi + vec3(1.0, 0.0, 0.0), hashx1, hashy1, hashz1 );\n\n    // calculate the gradients\n    vec4 gradx0 = hashx0 - 0.49999;\n    vec4 grady0 = hashy0 - 0.49999;\n    vec4 gradz0 = hashz0 - 0.49999;\n    vec4 gradx1 = hashx1 - 0.49999;\n    vec4 grady1 = hashy1 - 0.49999;\n    vec4 gradz1 = hashz1 - 0.49999;\n\n    // normalize gradients\n    vec4 normx0 = inversesqrt( gradx0 * gradx0 + vec4(1.0) );\n    vec4 normy0 = inversesqrt( grady0 * grady0 + vec4(1.0) );\n    vec4 normz0 = inversesqrt( gradz0 * gradz0 + vec4(1.0) );\n    vec4 normx1 = inversesqrt( gradx1 * gradx1 + vec4(1.0) );\n    vec4 normy1 = inversesqrt( grady1 * grady1 + vec4(1.0) );\n    vec4 normz1 = inversesqrt( gradz1 * gradz1 + vec4(1.0) );\n\n    // gradient dot product\n    vec4 m00 = dot( gradx0, normx0 ) * normx0;\n    vec4 m01 = dot( gr", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    // hash lookup\n    float a = hash(i);\n    float b = hash(i + 1.0);\n\n    // interpolate\n    return lerp(a, b, u);\n}\n\n// 2D noise\nfloat", "\n    float d = p.y + 1.0;\n    float id = 1.0;\n\n    // sphere\n    vec3 q = p - vec3(0.0, 1.0, 0.0);\n    float r = 0.5;\n    float d2 = length(q) - r;\n    if (d2 < d)\n    {\n        d = d2;\n        id = 2.0;\n    }\n\n    return vec2(d, id);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n\n    // add a sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n    d = opU(d, sd);\n\n    // add a box\n    sd = sdBox(p, vec3(0.5));\n    d = opU(d, sd);\n\n    return vec2(d, 0.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n\tvec2 st = fragCoord/iResolution.xy;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = distance(st,vec2(0.5));\n\t\n\tfloat r = d*10.0;\n\t\n\tfloat f = sin(r);\n\t\n\tcolor = vec3(f);\n\t\n\tfragColor = vec4(color,1.0);\n}", "\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Pointed top hexagons.\n    p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1", "\n    return (sin(ix*1600)*1376+sin(iy*1600)*1376+sin(ix*1600+iy*1600)*1376)/3000;\n}\n\nfloat", "\n    p = rotate(p, vec3(0.0, 0.0, 1.0), 0.5*iTime);\n\n    // solve the quadratic polynomial\n    float a = dot(p, p);\n    float b = dot(p, p*p);\n    float c = dot(p, p*p*p);\n    float d = dot(p, p*p*p*p);\n\n    // get the solutions\n    float s1 = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*a);\n    float s2 = (-b - sqrt(b*b - 4.0*a*c)) / (2.0*a);\n\n    // get the colors\n    vec3 c1 = getColor(s1);\n    vec3 c2 = getColor(s2);\n\n    // mix the colors\n    return mix(c1, c2, 0.5);\n}\n\n//------------------------------------------------------------------\n// main\n//------------------------------------------------------------------\nvoid main()\n{\n    // get the ray direction\n    vec3 rayDir = normalize(vec3(gl_FragCoord.xy - 0.5*iResolution.xy, iResolution.y));\n\n    // get the ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 1.0);\n\n    // get the ray intersection\n    float t = intersect(rayOrigin, rayDir);\n\n    // if the ray intersects the sphere\n    if (t > 0.0)\n    {\n        // get the intersection point\n        vec3 p = rayOrigin + t*rayDir;\n\n        // get the color\n        vec3 color = getColor(p);\n\n        // set the fragment color\n        gl_FragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // set the fragment color\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    p *= 10.0;\n\n    // add a few elements\n    float e1 = sdBox(p, vec3(1.0, 1.0, 1.0));\n    float e2 = sdBox(p + vec3(2.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e3 = sdBox(p + vec3(4.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e4 = sdBox(p + vec3(6.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e5 = sdBox(p + vec3(8.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // combine elements\n    float d = min(e1, min(e2, min(e3, min(e4, e5))));\n\n    // scale back\n    d /= 10.0;\n\n    return d;\n}\n\n// Fifth scene (many elements)\nfloat", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* calculate dot products */\n\t vec4 p1 = permute(permute(permute(s.z) + s.y) + s.x);\n\t vec4 p2 = permute(permute(permute(s.z + i1.z) + s.y) + s.x);\n\t vec4 p3 = permute(permute(permute(s.z + i2.z) + s.y) + s.x);\n\t vec4 p4 = permute(permute(permute(s.z + 1.0) + s.y) + s.x);\n\t \n\t vec4 w, d1, d2, d3;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w.x will always be less than or equal to the other three, so we can use it to find the largest component */\n\t w = max(0.6 - w, 0.0);\n\t \n\t d1 = x.xyxy * p1.xyxy + p1.zwzw;\n\t d2 = x1.xyxy * p2.xy", "\n    float t = mod(iTime, 25.0);\n    float t1 = t;\n    float t2 = t + 12.5;\n    float t3 = t + 25.0;\n    float t4 = t + 37.5;\n    float t5 = t + 50.0;\n    float t6 = t + 62.5;\n    float t7 = t + 75.0;\n    float t8 = t + 87.5;\n    float t9 = t + 100.0;\n    float t10 = t + 112.5;\n    float t11 = t + 125.0;\n    float t12 = t + 137.5;\n    float t13 = t + 150.0;\n    float t14 = t + 162.5;\n    float t15 = t + 175.0;\n    float t16 = t + 187.5;\n    float t17 = t + 200.0;\n    float t18 = t + 212.5;\n    float t19 = t + 225.0;\n    float t20 = t + 237.5;\n    float t21 = t + 250.0;\n    float t22 = t + 262.5;\n    float t23 = t + 275.0;\n    float t24 = t + 287.5;\n    float t25 = t + 300.0;\n    float t26 = t + 312.5;\n    float t27 = t + 325.0;\n    float t28 = t + 337.5;\n    float t29 = t + 350.0;\n    float t30 = t + 362.5;\n    float t31 = t + 375.0;\n    float t32 = t + 387.5;\n    float t33 = t + 400.0;\n    float t34 = t + 412.5;\n    float t35 = t", " in the scene\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.", "\n    float k = floor(rp.x*.5)*.5;\n    float d = sdBox(rp-vec3(k,0,0),vec3(.25,.5,.25));\n    return d;\n}\n\n// The normal of the surface at point p\nvec", "\n\treturn max(0.0, min(1.0, (end - d) / (end - start)));\n}\n\nvoid main() {\n\tvec3 color = texture(tex, texCoord).rgb;\n\tfloat fog = linearFog(gl_FragCoord.z, 0.0, 100.0);\n\tcolor = mix(color, fogColor, fog);\n\toutColor = vec4(color, 1.0);\n}\n", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons centered at \n    // (0,0), and the second row centered at (0,1), etc.\n    hex.xy = floor(p);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    //", "\n    float r = rand(floor(p));\n    \n    // The distance to the center of the cell.\n    float d = length(p);\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d2 = length(p + vec2(r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d3 = length(p + vec2(r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d4 = length(p + vec2(-r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d5 = length(p + vec2(-r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d6 = length(p + vec2(r, 0.0));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d7 = length(p + vec2(-r, 0.0));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d8 = length(p + vec2(0.0, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d9 = length(p + vec2(0.0, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d10 = length(p + vec2(r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d11 = length(p + vec2(r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d12 = length(p + vec2(-r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d13 = length(p + vec2(-r, -r));\n    ", "\n    float scale = iMouse.x / iResolution.x;\n\n    // Set color according to scale.\n    // If scale is 0.0, color is red.\n    // If scale is 1.0, color is blue.\n    // If scale is 0.5, color is green.\n    // If scale is 0.25, color is yellow.\n    // If scale is 0.75, color is purple.\n    // If scale is 0.125, color is orange.\n    // If scale is 0.875, color is cyan.\n    // If scale is 0.375, color is magenta.\n    // If scale is 0.625, color is brown.\n    // If scale is 0.1875, color is pink.\n    // If scale is 0.8125, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale", "\n    float theta = atan(pc.y, pc.x);\n    float r = length(pc);\n    float theta_spiral = atan(b*theta, a+b*theta);\n    \n    //If the polar coordinate is on the spiral, return theta.\n    //If not, return -1.0\n    if(abs(theta_spiral - theta) < 0.0001){\n        return theta;\n    }else{\n        return -1.0;\n    }\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//Given a polar coordinate (r, theta), return the cartesian coordinate (x, y)\nvec", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Plot a line\n  color = vec3(plot(st,0.5));\n\n  gl_FragColor = vec4(color,1.0);\n}\n", "\n    //\n    // The following is a diagram of the initial circular domain.\n    //\n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // ", "\n    float a = atan(p.y, p.x);\n    float ia = floor(a / (2.0 * PI) +.5);\n    a -= ia * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float r = length(p);\n    float ir = floor(r / circ.z +.5);\n    r -= ir * circ.z;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float b = atan(p.y, p.x);\n    float ib = floor(b / (2.0 * PI) +.5);\n    b -= ib * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float c = atan(p.y, p.x);\n    float ic = floor(c / (2.0 * PI) +.5);\n    c -= ic * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float d = atan(", "\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Invert mouse coordinates.\n    m = (m - 0.5) * 2.0;\n    \n    // Invert mouse coordinates.\n    m.y *= -1.0;\n    \n    // Return inverted mouse coordinates.\n    return m;\n}\n\n// Mouse pointer inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec3 camPos = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 camUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 camSide = normalize(cross(camDir, camUp));\n\t\n\t// Camera\n\tvec3 rayDir = normalize(camSide * (fragCoord.x - iResolution.x * 0.5) + camUp * (fragCoord.y - iResolution.y * 0.5) + camDir * 1.0);\n\t\n\t// Raymarch\n\tvec3 rayPos = camPos;\n\tfloat dist = 0.0;\n\tfloat totalDist = 0.0;\n\tfloat t = 0.0;\n\tfloat tMax = 100.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tdist = map(rayPos);\n\t\ttotalDist += dist;\n\t\trayPos += rayDir * dist;\n\t\tt += dist;\n\t\tif (dist < 0.001 || t > tMax)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// Lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 10.0);\n\tvec3 lightDir = normalize(lightPos - rayPos);\n\tfloat lightDist = length(lightPos - rayPos);\n\tfloat lightAtten = 1.0 / (1.0 + 0.01 * lightDist + 0.001 * lightDist * lightDist);\n\tfloat lightDiffuse = max(dot(lightDir, normalize(normal(rayPos))), 0.0);\n\tfloat lightSpecular = pow(max(dot(reflect(-lightDir, normal(rayPos)), -rayDir), 0.0), 16.0);\n\t\n\t// Shading\n\tvec3 color = vec3(0.0);\n\tif (dist < 0.001)\n\t{\n\t\tcolor = vec3(", "\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI);\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n", "\n    vec3 cube = mod(floor(hash * 6.0), 2.0) * 2.0 - 1.0;\n    \n    // Random vertex of a rhombic dodecahedron\n    float cb = (cube.x + cube.y + cube.z) / 3.0;\n    float cr = (cube.x + cube.y) / 2.0;\n    float cs = (cube.x + cube.z) / 2.0;\n    float ct = (cube.y + cube.z) / 2.0;\n    vec3 rhomb = vec3(cr + cb, ct + cb, cs + cb);\n    \n    // Expand outwards\n    float scale = 1.0 / (sqrt(3.0) * (abs(rhomb.x) + abs(rhomb.y) + abs(rhomb.z)));\n    return rhomb * scale;\n}\n\n// 2D simplex noise\nfloat", "\n    // This is a bit of a hack, but it's the only way to get a triangular\n    // alignment.\n    X.yz = X.yz * mat2(0.866025404, -0.5, 0.5, 0.866025404);\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repe", "\n  float d = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the YZ plane\n  float d2 = length(p.yz) - 0.5;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d8 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d9 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d11 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d12 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d13 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d14 = length(p.xz) - 0.5;\n  // distance from the point `p", "\n    // \ub9cc\uc57d \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \uc815\ud655\ud55c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub530\ub77c\uc11c \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ufffd", "\n\tmat2 rot = mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n\t\n\t// Get the pixel coordinates\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\t\n\t// Rotate the pixel coordinates\n\tuv = rot * uv;\n\t\n\t// Get the distance from the center\n\tfloat dist = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist2 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle2 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist3 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle3 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist4 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle4 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist5 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle5 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist6 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle6 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist7 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle7 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist8 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle8 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist9 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle9 = atan(uv.y", "\n    vec4 s = vec4(p, 0.0);\n    s.y -= 0.5;\n    s.y = pModPolar(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.", "\n    vec3 targetDir = normalize( targetPos - ray.origin );\n    float targetDist = length( targetPos - ray.origin );\n    float targetAngle = dot( targetDir, ray.direction );\n    float targetAngle2 = targetAngle * targetAngle;\n    float targetAngle3 = targetAngle2 * targetAngle;\n    float targetAngle4 = targetAngle2 * targetAngle2;\n    float targetAngle5 = targetAngle3 * targetAngle2;\n    float targetAngle6 = targetAngle3 * targetAngle3;\n    float targetAngle7 = targetAngle4 * targetAngle3;\n    float targetAngle8 = targetAngle4 * targetAngle4;\n    float targetAngle9 = targetAngle5 * targetAngle4;\n    float targetAngle10 = targetAngle5 * targetAngle5;\n    float targetAngle11 = targetAngle6 * targetAngle5;\n    float targetAngle12 = targetAngle6 * targetAngle6;\n    float targetAngle13 = targetAngle7 * targetAngle6;\n    float targetAngle14 = targetAngle7 * targetAngle7;\n    float targetAngle15 = targetAngle8 * targetAngle7;\n    float targetAngle16 = targetAngle8 * targetAngle8;\n    float targetAngle17 = targetAngle9 * targetAngle8;\n    float targetAngle18 = targetAngle9 * targetAngle9;\n    float targetAngle19 = targetAngle10 * targetAngle9;\n    float targetAngle20 = targetAngle10 * targetAngle10;\n    float targetAngle21 = targetAngle11 * targetAngle10;\n    float targetAngle22 = targetAngle11 * targetAngle11;\n    float targetAngle23 = targetAngle12 * targetAngle11;\n    float targetAngle24 = targetAngle12 * targetAngle12;\n    float targetAngle25 = targetAngle13 * targetAngle12;\n    float targetAng", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    // noise\n    return mix(\n        hash(i),\n        hash(i + 1.0),\n        u\n    );\n}\n\n// 2D noise\nfloat", "\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n    \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec3 p1, vec3 p2, vec3 p3, vec3 uv){\n    \n    //Delicious math\n    vec3 v0 = p3 - p1;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = uv - p1;\n    \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot0", "\n    float n = log(start_radius/uv.x)/log(1.5);\n    return int(n);\n}\n\n//Find the hexagon a point is in\nvec", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    //Check if uv is inside the triangle.\n    if(inside_triangle(uv, p0, p1, p2) || inside_triangle(uv, p1, p2, p3) ||\n       inside_triangle(uv, p2, p3, p4) || inside_triangle(uv, p3, p4, p5) ||\n       inside_triangle(uv, p4, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    //Check if uv is inside the first triangle.\n    if(inside_triangle(uv, p0, p1, p2)){\n        return 1;\n    }\n    \n    //Check if uv is inside the second triangle.\n    if(inside_triangle(uv, p0, p2, p3)){\n        return 2;\n    }\n    \n    //Check if uv is inside the third triangle.\n    if(inside_triangle(uv, p0, p3, p4)){\n        return 3;\n    }\n    \n    //Check if uv is inside the fourth triangle.\n    if(inside_triangle(uv, p0, p4, p5)){\n        return 4;\n    }\n    \n    //Check if uv is inside the fifth triangle.\n    if(inside_triangle(uv, p0, p5, p1)){\n        return 5;\n    }\n    \n    //Check if uv is inside the sixth triangle.\n    if(inside_triangle(uv, p1, p5, p2)){\n        return ", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = 1.0;\n    float U1 = U.x;\n    while (U1 > L) {\n        k += 1.0;\n        p *= (d / k);\n        U1 *= U.y;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "'s work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash6(uint n)", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // time\n    float t = iTime;\n\n    // color\n    vec3 col = vec3(0.0);\n\n    // loop\n    for (float i = 0.0; i < 10.0; i++) {\n        // position\n        vec2 pos = vec2(sin(t * 0.1 + i * 0.1), cos(t * 0.1 + i * 0.1)) * 0.5;\n\n        // distance\n        float d = length(uv - pos);\n\n        // color\n        col += vec3(1.0 / d);\n    }\n\n    // output\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n  float epsilon = 0.0001;\n  // Compute normal using central differences method\n  vec3 normal = vec3(\n    calcD(pos, epsilon, 0),\n    calcD(pos, 0, epsilon),\n    calcD(pos, epsilon, epsilon)\n  );\n  return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n  float t = castRay(ro, rd);\n  if (t < 0.0) {\n    return vec3(0.0, 0.0, 0.0);\n  }\n  vec3 pos = ro + rd * t;\n  vec3 normal = calcNormal(pos);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  if (t < tmin) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (t < tmax) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else {\n    color = vec3(0.0, 0.0, 0.0);\n  }\n  return color;\n}\n\nvoid main() {\n  // camera\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 rd = normalize(vec3(vUv.x - 0.5, vUv.y - 0.5, 1.0));\n  vec3 color = render(ro, rd);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float epsilon = 0.0001;\n    // Compute normal using central differences method\n    vec3 normal = vec3(\n        calcD(pos, epsilon, 0),\n        calcD(pos, 0, epsilon),\n        calcD(pos, epsilon, epsilon)\n    );\n    return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    float t = castRay(ro, rd);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // get position and normal at hit point\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // get material color at hit point\n    vec3 col = getMaterialColor(pos);\n\n    // calculate lighting\n    float occ = calcAO(pos, nor);\n    vec3 lig = calcLighting(pos, nor, col, occ);\n\n    // calculate fog\n    float fogAmount = calcFog(t);\n    vec3 fogCol = vec3(0.5, 0.6, 0.7);\n    vec3 colFog = mix(col, fogCol, fogAmount);\n\n    // calculate reflections\n    vec3 ref = reflect(rd, nor);\n    vec3 refCol = render(pos + nor * 0.001, ref);\n\n    // calculate refractions\n    vec3 refr = refract(rd, nor, 1.0 / 1.333);\n    vec3 refrCol = render(pos + nor * 0.001, refr);\n\n    // calculate final color\n    vec3 finalCol = mix(colFog, refCol, 0.5) + mix(colFog, refrCol, 0.5);\n\n    return finalCol;\n}\n\nvoid main() {\n    // get normalized device coordinates\n    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;\n\n    // get ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // get ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n\n    // render scene\n    vec3 col = render(ro, rd);\n\n    // output final color\n    gl_FragColor = vec4(col, 1", "\n    vec3 s = vec3(0.0);\n    for (int i=ZERO; i<8; i++) {\n        float j = float(i);\n        vec2 e = vec2(cos(j), sin(j))*0.02;\n        s += vec3(0.5 + 0.5*dot(e, e));\n    }\n    s = s*s*(3.0 - 2.0*s);\n\n    //normal\n    vec2 e = vec2(1.0, 0.0)*0.001;\n    vec3 n = sdf(p + e.xyy) - sdf(p - e.xyy);\n    n.x = sdf(p + e.yxy) - sdf(p - e.yxy);\n    n.y = sdf(p + e.yyx) - sdf(p - e.yyx);\n    return normalize(n);\n}\n\n/**\n * Raymarching using the gradient of the SDF.\n */\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat", "els\n\tvec2 texel = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x", "\n    p = abs(p);\n\n    // normalize\n    float a = ab.x;\n    float b = ab.y;\n    float r = a / b;\n    p *= r;\n\n    // project\n    float l = length(p);\n    float m = l*l/(a*a+b*b);\n    vec2 n = m*p;\n\n    // distance\n    float d = l*sqrt(m*m+1.0-m);\n\n    // gradient\n    vec3 g;\n    g.x = d;\n    g.yz = n;\n\n    return g;\n}\n\n// signed distance to ellipse\nfloat", "\n    vec3 q = vec3(dot(vec2(1.0, 1.0), vec2(p, p + iGlobalTime)),\n                  dot(vec2(7.0, 13.0), vec2(p, p + 1.0)),\n                  dot(vec2(17.0, 19.0), vec2(p, p + 2.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Plot a line\n    float y = plot(uv, vec2(0.4, 0.6));\n    col = vec3(y);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float dist = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    // Calculate the Rotation Matrix\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy, cx*cz + sx*sy*sz, cx*sz - cy*sx*sz,\n        -sy, cy*sx + sy*sz*cx, cy*cx - sx*sy*sz\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    rayori = rayori - camera;\n    // Raymarching\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // Get the distance to the nearest object\n        d = map(rayori + raydir * t);\n        // If we are close enough to the object, break\n        if(d < MIN_DIST){\n            break;\n        }\n        // Move the ray forward\n        t += d;\n        // If we are too far away, break\n        if(t > MAX_DIST){\n            break;\n        }\n    }\n    // Get the normal of the object\n    vec3 normal = getNormal(rayori + raydir * t);\n    // Get the color of the object\n    vec3 color = getColor(rayori + raydir * t);\n    // Get the light direction\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    // Get the ambient light\n    float ambient = 0.1;\n    // Get the diffuse light\n    float diffuse = max(dot(normal, light), 0.0);\n    // Get the specular light\n    float specular = pow(max(dot(reflect(raydir.xyz, normal), light), 0.0), 16.0);\n    // Get the final color\n    vec3 finalColor = color * (ambient + diffuse + specular);\n    // Return the final color\n    return finalColor;\n}\n\n// 3D Ray-Marching\nvec", "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Distance of the Ray\n    float rayDist = rayMarch(rayPos, rayDir);\n    // Calculate the Position of the Ray\n    vec3 rayPos2 = rayPos + rayDist * rayDir;\n    // Calculate the Normal of the Ray\n    vec3 rayNorm = calcNormal(rayPos2);\n    // Calculate the Light of the Ray\n    vec3 rayLight = calcLight(rayPos2, rayNorm);\n    // Calculate the Color of the Ray\n    vec3 rayColor = rayLight * calcColor(rayPos2);\n    // Return the Color of the Ray\n    return rayColor;\n}\n\n// 4D Screen Output Image\nvec", "\n    rayori = cameraPos;\n    // Set the Raymarching Distance\n    float dist = 0.0;\n    // Set the Raymarching Maximum Distance\n    float maxDist = 100.0;\n    // Set the Raymarching Step Size\n    float stepSize = 0.01;\n    // Set the Raymarching Color\n    vec3 color = vec3(0.0);\n    // Set the Raymarching Normal\n    vec3 normal = vec3(0.0);\n    // Set the Raymarching Material\n    vec3 material = vec3(0.0);\n    // Set the Raymarching Light\n    vec3 light = vec3(0.0);\n    // Set the Raymarching Light Color\n    vec3 lightColor = vec3(1.0);\n    // Set the Raymarching Light Position\n    vec3 lightPos = vec3(0.0, 10.0, 0.0);\n    // Set the Raymarching Light Attenuation\n    float lightAttenuation = 1.0;\n    // Set the Raymarching Light Ambient\n    float lightAmbient = 0.1;\n    // Set the Raymarching Light Diffuse\n    float lightDiffuse = 0.5;\n    // Set the Raymarching Light Specular\n    float lightSpecular = 0.5;\n    // Set the Raymarching Light Specular Power\n    float lightSpecularPower = 10.0;\n    // Set the Raymarching Light Specular Color\n    vec3 lightSpecularColor = vec3(1.0);\n    // Set the Raymarching Light Specular Attenuation\n    float lightSpecularAttenuation = 1.0;\n    // Set the Raymarching Light Specular Ambient\n    float lightSpecularAmbient = 0.1;\n    // Set the Raymarching Light Specular Diffuse\n    float lightSpecularDiffuse = 0.5;\n    // Set the Raymarching Light Specular Specular\n    float lightSpecularSpecular = 0.5;\n    // Set the Raymarching Light Spec", "\n    float seed = dot(fragCoord, iResolution.xy);\n    seed = seed + iGlobalTime;\n    seed = seed * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float fade = clamp(1.0 - abs(coord.x - 0.5) * 2.0, 0.0, 1.0);\n\n    // Calculate the ray's position\n    float rayPos = coord.x + travelRate * frequency;\n\n    // Calculate the ray's strength\n    float rayStrength = clamp(1.0 - abs(rayPos - 0.5) * 2.0, 0.0, 1.0);\n\n    // Return the ray's strength multiplied by the fade\n    return rayStrength * fade * maxStrength;\n}\n\n// Calculate the color of the fragment\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n", " right now\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    vec2 p3 = p - vec2(d.x, -d.y);\n    vec2 p4 = p + vec2(d.x, -d.y);\n    vec2 p5 = p - vec2(-d.x, d.y);\n    vec2 p6 = p + vec2(-d.x, d.y);\n    vec2 p7 = p - vec2(-d.x, -d.y);\n    vec2 p8 = p + vec2(-d.x, -d.y);\n    float d1 = distance(p, p1);\n    float d2 = distance(p, p2);\n    float d3 = distance(p, p3);\n    float d4 = distance(p, p4);\n    float d5 = distance(p, p5);\n    float d6 = distance(p, p6);\n    float d7 = distance(p, p7);\n    float d8 = distance(p, p8);\n    float dmin = min(d1, min(d2, min(d3, min(d4, min(d5, min(d6, min(d7, d8)))))));\n    if (dmin == d1) {\n        e1 = p1;\n        e2 = p2;\n        e3 = p3;\n        e4 = p4;\n    } else if (dmin == d2) {\n        e1 = p2;\n        e2 = p1;\n        e3 = p4;\n        e4 = p3;\n    } else if (dmin == d3) {\n        e1 = p3;\n        e2 = p4;\n        e3 = p1;\n        e4 = p2;\n    } else if (dmin == d4) {\n        e1 = p4;\n        e2 = p3;\n        e3 = p2;\n        e4 = p1;\n    } else if (dmin == d5) {\n        e1 = p5;\n", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 dir = normalize(b-a);\n    vec2 n = vec2(-dir.y,dir.x);\n    float k = w1+w2;\n\n    // start with a box\n    float d = sdBox(p,a,b,vec2(w1,w1));\n\n    // subtract the arrowhead\n    float d2 = sdSegment(p,a,b);\n    d2 = max(d2,-dot(p-a,n));\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    // subtract the arrowhead\n    d2 = sdSegment(p,b-n*k,b);\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    return d;\n}\n\n//------------------------------------------------------------------\n// sdSegment\n//\n// Returns the distance from p to the line segment ab.\n//\n// The line segment is defined by two points a and b.\n//\n// The parameter t is clamped to the range [0.0, 1.0].\n//\n// The function returns a negative value if p is on the backward\n// side of the line segment.\n//\n// The function returns a positive value if p is on the forward\n// side of the line segment.\n//\n// The function returns zero if p is on the line segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if", "\n    uv = (uv - 0.5) * mat2(0.8,0.6,-0.6,0.8);\n    \n    //get the distance to the center\n    float d = length(uv);\n    \n    //get the angle of the uv\n    float a = atan(uv.y,uv.x);\n    \n    //get the distance to the edge\n    float e = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float f = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float g = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float h = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float i = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float j = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float k = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float l = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float m = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float n = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float o = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float p = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float q = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float r = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float s = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float t = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float u = abs(d - 0.5);\n    \n    //get", "\n    vec3 colA = vec3(0.0,0.0,0.0);\n    vec3 colB = vec3(1.0,1.0,1.0);\n    return mix( colA, colB, rnd ) * falloff;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n   vec3 q = vec3(dot(vec2(1.0, 1.0), p),\n                 dot(vec2(57.0, 113.0), p),\n                 dot(vec2(157.0, 213.0), p));\n   return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n  //  return x - x*x*x/3 + x*x*x*x*x/5;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13 - x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*", ", I don't remember where.\n  //  It's a post-processing effect that makes the image look more like a\n  //  film.\n  col = pow(col, vec3(0.4545));\n  col = col * (col * 0.5 + 0.5);\n  col = col * (1.0 - pow(clamp(1.0 - max(dot(q, q), 0.0), 0.0, 1.0), 1.5));\n  col = col * (0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.75));\n  return clamp(col, 0.0, 1.0);\n}\n\n//  This is the main function that is called by the shadertoy API.\n//  It is called once per frame, and it is responsible for rendering the scene.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //  The following code is a bit of a hack, but it works.\n  //  The shadertoy API passes the mouse position in the fragCoord variable.\n  //  We use this to set the mouse position in the scene.\n  //  The mouse position is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is", "\n    vec3 d = abs(p) - vec3(1.0);\n    // Return the maximum component of d\n    return max(d.x, max(d.y, d.z));\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a circle\n    float radius = iMouse.x / iResolution.x;\n    float radius_last = iMouse.x / iResolution.x;\n    float radius_diff = radius - radius_last;\n    float brightness = radius_diff;\n    col = vec3(brightness, brightness, brightness);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"]}