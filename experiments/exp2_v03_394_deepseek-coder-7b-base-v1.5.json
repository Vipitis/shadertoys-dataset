{"generations": [" return 1.0; }\nfloat SH_1_0( in vec3 s ) { return s.z; }\nfloat SH_1_1( in vec3 s ) { return s.y; }\nfloat SH_1_2( in vec3 s ) { return s.x; }\nfloat SH_2_0( in vec3 s ) { return 0.5*(3.0*s.z*s.z-1.0); }\nfloat SH_2_1( in vec3 s ) { return s.y*s.z; }\nfloat SH_2_2( in vec3 s ) { return 0.5*(3.0*s.x*s.x-1.0); }\nfloat SH_2_3( in vec3 s ) { return s.x*s.y; }\nfloat SH_3_0( in vec3 s ) { return 0.5*(5.0*s.z*s.z*s.z-3.0*s.z); }\nfloat SH_3_1( in vec3 s ) { return 0.5*(5.0*s.y*s.z*s.z-1.0*s.y); }\nfloat SH_3_2( in vec3 s ) { return 0.5*(5.0*s.x*s.z*s.z-1.0*s.x); }\nfloat SH_3_3( in vec3 s ) { return 0.5*(5.0*s.x*s.y*s.y-3.0*s.y); }\nfloat SH_3_4( in vec3 s ) { return 0.5*(5.0*s.x*s.x*s.x-3.0*s.x); }\nfloat SH_4_0( in vec3 s ) { return 0.125*(35.0*s.z*s.z*s.z*s.z-30.0*s.z*s.z+3.0); }\nfloat SH_4_1( in vec3 s ) { return 0.125*(35.0*s.y*s.z*s.", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSeg( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat circle( in vec2 p, in vec2 c, in float r )\n{\n    return length( p-c ) - r;\n}\n\n// distance to a rectangle\nfloat rect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to a rectangle\nfloat rect( in vec2 p, in vec2 b, in vec4 r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) +\n        max(\n            (p.x<0.0)?r.x:r.y,\n            (p.y<0.0)?r.z:r.w\n        )\n        - min(max(d.x,d.y),0.0);\n}\n\n// distance to a rectangle\nfloat rect( in vec2 p, in vec2 b, in vec4 r, in float a )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) +\n        max(\n            (p.x<0.0)?r.x:r.y,\n            (p.y<0.0)?r.z:r.w\n        )\n        - min(max(d.x,d.y),0.0)\n        - a;\n}\n\n// distance to a rectangle\nfloat rect", "\n    return ( dot(v,r) < 0.0 )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return ( dot(v,r) < 0.0 )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return ( dot(v,r) < 0.0 )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in float d )\n{\n    return ( dot(v,r) < d )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in float d )\n{\n    return ( dot(v,r) < d )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r, in float d )\n{\n    return ( dot(v,r) < d )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in vec2 d )\n{\n    return ( dot(v,r) < dot(d,r) )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in vec3 d )\n{\n    return ( dot(v,r) < dot(d,r) )? -v : v;\n}\n\n// Flip v if in the negative", "\n    float d = dot(v,r);\n    if( d < 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    float d = dot(v,r);\n    if( d > 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    float d = dot(v,r);\n    if( d > 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    float d = dot(v,r);\n    if( d > 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    float d = dot(v,r);\n    if( d > 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    float d = dot(v,r);\n    if( d > 0.0 )\n        return v - 2.0*d*r;\n    else\n        return v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D", "\n    return v * clamp( dot(v,r), 0.0, 1.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v * clamp( dot(v,r), -1.0, 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*(1.0-h)*0.5 - w2*h*0.5;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow( p, a, b, 0.01, 0.01 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\n    vec2 pa = p-a, ba = b-a;\n    float hh = clamp( dot(pa,ba)/dot(ba,ba), 0.0, h );\n    return length( pa - ba*hh ) - w1*(1.0-hh)*0.5 - w2*hh*0.5;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w, 1.0 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h1, float h2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float hh = clamp( dot(pa,ba)/dot(ba,ba), 0.0, h1 );\n    return length( pa - ba*hh ) - w1*(1.0-hh)*0.5 - w2*hh*0.5;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w, 1.0, 1.0 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a,", "\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle4 = sunAngle2 * sunAngle2;\n    float sunAngle8 = sunAngle4 * sunAngle4;\n    float sunAngle16 = sunAngle8 * sunAngle8;\n    float sunAngle32 = sunAngle16 * sunAngle16;\n    float sunAngle64 = sunAngle32 * sunAngle32;\n    float sunAngle128 = sunAngle64 * sunAngle64;\n    float sunAngle256 = sunAngle128 * sunAngle128;\n    float sunAngle512 = sunAngle256 * sunAngle256;\n    float sunAngle1024 = sunAngle512 * sunAngle512;\n    float sunAngle2048 = sunAngle1024 * sunAngle1024;\n    float sunAngle4096 = sunAngle2048 * sunAngle2048;\n    float sunAngle8192 = sunAngle4096 * sunAngle4096;\n    float sunAngle16384 = sunAngle8192 * sunAngle8192;\n    float sunAngle32768 = sunAngle16384 * sunAngle16384;\n    float sunAngle65536 = sunAngle32768 * sunAngle32768;\n    float sunAngle131072 = sunAngle65536 * sunAngle65536;\n    float sunAngle262144 = sunAngle131072 * sunAngle131072;\n    float sunAngle524288 = sunAngle262144 * sunAngle262144;\n    float sunAngle1048576 = sunAngle524288 * sunAngle524288;\n    float sunAngle2097152 = sunAngle1048576 * sunAngle1048576;\n    float sunAngle4194304 = sunAngle20", "\n    vec4 a0 = p1;\n    vec4 a1 = (p2 - p0) * 0.5;\n    vec4 a2 = (p0 - (2.0 * p1) + p2) * 0.5;\n    vec4 a3 = (p1 - p0 + (2.0 * p2) - p3) * 0.5;\n\n    return a0 + (a1 * t) + (a2 * t * t) + (a3 * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float t2)\n{\n    vec4 a0 = p1;\n    vec4 a1 = (p2 - p0) * 0.5;\n    vec4 a2 = (p0 - (2.0 * p1) + p2) * 0.5;\n    vec4 a3 = (p1 - p0 + (2.0 * p2) - p3) * 0.5;\n\n    return a0 + (a1 * t) + (a2 * t2) + (a3 * t * t2);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float t2, float t3)\n{\n    vec4 a0 = p1;\n    vec4 a1 = (p2 - p0) * 0.5;\n    vec4 a2 = (p0 - (2.0 * p1) + p2) * 0.5;\n    vec4 a3 = (p1 - p0 + (2.0 * p2) - p3) * 0.5;\n\n    return a0 + (a1 * t) + (a2 * t2) + (a3 * t3);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += f * sin(p.x + n);\n\t\tn += f * sin(p.y + n);\n\t\tn += f * sin(p.z + n);\n\t\tf *= 2.0;\n\t\tp.xy *= nudge;\n\t\tp.xz *= nudge;\n\t\tp.yz *= nudge;\n\t\tp.x += n;\n\t\tp.y += n;\n\t\tp.z += n;\n\t\tp *= normalizer;\n\t}\n\treturn n;\n}\n\n// This is a 3D noise function that uses a hash function to generate the noise.\n// It's not as fast as the SpiralNoiseC function, but it's more accurate.\nfloat Hash3D(vec3 p)\n{\n\tvec3 q = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\treturn fract(sin(q) * 43758.5453);\n}\n\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// quintic interpolation\n\tvec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n\t// quintic interpolation\n\tvec3 du = 30.0 * u * u * (u * (u - 2.0) + 1.0);\n\n\t// gradient\n\tvec3 g = vec3(Hash3D(i + vec3(0.0, 0.0, 0.0)),\n\t\tHash3D(i + vec3(1.0, 0.0, 0.0)),\n\t\tHash3D(i +", "\n    vec4 p = vec4(0.0);\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float b0 = 0.5 * (-t3 + 2.0 * t2 - t);\n    float b1 = 0.5 * (3.0 * t3 - 5.0 * t2 + 2.0);\n    float b2 = 0.5 * (-3.0 * t3 + 4.0 * t2 + t);\n    float b3 = 0.5 * (t3 - t2);\n    for (int i = 0; i < 4; i++)\n    {\n        p += b0 * CamPath[i * 3 + 0] + b1 * CamPath[i * 3 + 1] + b2 * CamPath[i * 3 + 2] + b3 * CamPath[i * 3 + 3];\n    }\n    return p;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamRot(float t)\n{\n    vec4 p = vec4(0.0);\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float b0 = 0.5 * (-t3 + 2.0 * t2 - t);\n    float b1 = 0.5 * (3.0 * t3 - 5.0 * t2 + 2.0);\n    float b2 = 0.5 * (-3.0 * t3 + 4.0 * t2 + t);\n    float b3 = 0.5 * (t3 - t2);\n    for (int i = 0; i < 4; i++)\n    {\n        p += b0 * CamPath[i * 3 + 4] + b1 * CamPath[i * 3 + 5] + b2 * CamPath[i * 3 + 6] + b3 * CamPath[i * 3 + 7];\n    }\n    return p;\n}\n\n// from a time t, this finds", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat Hash2d(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\nfloat Noise1d(float u)\n{\n    float i = floor(u);\n    float f = fract(u);\n    float u1 = Hash1d(i);\n    float u2 = Hash1d(i + 1.0);\n    return mix(u1, u2, f);\n}\n\nfloat Noise2d(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float u1 = Hash2d(i);\n    float u2 = Hash2d(i + vec2(1.0, 0.0));\n    float u3 = Hash2d(i + vec2(0.0, 1.0));\n    float u4 = Hash2d(i + vec2(1.0, 1.0));\n    float u = mix(mix(u1, u2, f.x), mix(u3, u4, f.x), f.y);\n    return u;\n}\n\nfloat Noise3d(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float u1 = Hash3d(i);\n    float u2 = Hash3d(i + vec3(1.0, 0.0, 0.0));\n    float u3 = Hash3d(i + vec3(0.0, 1.0, 0.0));\n    float u4 = Hash3d(i + vec3(1.0, 1.0, 0", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tn += f * sin(p.x * f + p.y * f + p.z * f + n);\n\t\tf *= 1.1;\n\t}\n\treturn n;\n}\n\n// This is a 3D noise function that uses a hash function to generate the noise.\n// It's not as fast as the spiral noise function, but it's more accurate.\nfloat Hash3D(vec3 p)\n{\n\tvec3 q = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\treturn fract(sin(q.x + q.y * q.z) * 43758.5453);\n}\n\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// quintic interpolation\n\tvec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n\t// quintic interpolation\n\tvec3 du = 30.0 * f * f * (f * (f - 2.0) + 1.0);\n\n\tfloat n = 0.0;\n\tfloat w = 1.0;\n\tfor (int k = -1; k <= 1; k++)\n\t{\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t{\n\t\t\tfor (int i = -1; i <= 1; i++)\n\t\t\t{\n\t\t\t\tvec3 g = vec3(float(i), float(j), float(k));\n\t\t\t\tn += w * Hash3D(i + g + p);\n\t\t\t\tw *= 0.5;\n\t\t\t}\n\t\t}\n\t}\n\treturn", "\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        p = abs(p) / dot(p, p) - 0.5;\n        d += s * length(p);\n        s *= 0.5;\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n{\n    float d = DistanceToObject(p);\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nfloat DistanceToScene(vec3 p)\n", "\n    vec3 color = vec3(0.0);\n\n    // Overhead softbox\n    float softbox = 1.0 - smoothstep(0.0, 0.05, rayDir.y);\n    color += vec3(0.0, 0.0, 0.005) * softbox;\n\n    // Lights\n    float light = 0.0;\n    float light2 = 0.0;\n    float light3 = 0.0;\n    float light4 = 0.0;\n    float light5 = 0.0;\n    float light6 = 0.0;\n    float light7 = 0.0;\n    float light8 = 0.0;\n    float light9 = 0.0;\n    float light10 = 0.0;\n    float light11 = 0.0;\n    float light12 = 0.0;\n    float light13 = 0.0;\n    float light14 = 0.0;\n    float light15 = 0.0;\n    float light16 = 0.0;\n    float light17 = 0.0;\n    float light18 = 0.0;\n    float light19 = 0.0;\n    float light20 = 0.0;\n    float light21 = 0.0;\n    float light22 = 0.0;\n    float light23 = 0.0;\n    float light24 = 0.0;\n    float light25 = 0.0;\n    float light26 = 0.0;\n    float light27 = 0.0;\n    float light28 = 0.0;\n    float light29 = 0.0;\n    float light30 = 0.0;\n    float light31 = 0.0;\n    float light32 = 0.0;\n    float light33 = 0.0;\n    float light34 = 0.0;\n    float light35 = 0.0;\n    float light36 = 0.0;\n    float light37 = ", "\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat max( float a, float b, float k )\n{\n    float res = exp( k*a ) + exp( k*b );\n    return log( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat max( float a, float b, float k )\n{\n    float res = exp( k*a ) + exp( k*b );\n    return log( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat max( float a, float b, float k )\n{\n    float res = exp( k*a ) + exp( k*b );\n    return log( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat max( float a, float b, float k )\n{\n    float res = exp( k*a ) + exp( k*b );\n    return log( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -", "\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 posToSphere = spherePos - pos;\n    float b = dot(posToSphere, dirVec);\n    float c = dot(posToSphere, posToSphere) - rad * rad;\n    float d = b * b - c;\n    if (d < 0.0)\n        return -1.0;\n    else\n        return -b - sqrt(d);\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 normal)\n{\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 posToSphere = spherePos - pos;\n    float b = dot(posToSphere, dirVec);\n    float c = dot(posToSphere, posToSphere) - rad * rad;\n    float d = b * b - c;\n    if (d < 0.0)\n        return -1.0;\n    else\n    {\n        float t = -b - sqrt(d);\n        normal = normalize(pos + t * dirVec - spherePos);\n        return t;\n    }\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 normal, out vec3 hitPos)\n{\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 posToSphere = spherePos - pos;\n    float b = dot(posToSphere, dirVec);\n    float c = dot(posToSphere, posToSphere) - rad * rad;\n    float d = b * b - c;\n    if (d < 0.0)\n        return -1.0;\n    else\n    {\n        float t = -b - sqrt(d);\n        normal = normalize(pos + t * dirVec - spherePos);\n        hitPos = pos + t * dirVec;\n        return t;\n    }\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 normal,", "\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the distance and the object ID.\n    return vec2(d, 0.0);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the distance and the object ID.\n    return vec2(d, 0.0);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the distance and the object ID.\n    return vec2(d, 0.0);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the distance and the object ID.\n    return vec2(d, 0.0);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the distance and the object ID.\n    return vec2(d, 0.0);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p)\n{\n    // Distance to the object.\n    float d = 0.0;\n\n    // Distance to the object.\n    d = length(p) - 1.0;\n\n    // Return the", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n    return vec3(0.0, 0.0, 0", "\n    return vec3(\n        cos(t),\n        sin(t),\n        t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        -sin(t),\n        cos(t),\n        1.0\n    );\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n    return vec3(\n        -cos(t),\n        -sin(t),\n        0.0\n    );\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n    return vec3(\n        sin(t),\n        -cos(t),\n        0.0\n    );\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        0.0\n    );\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n    return vec3(\n        -sin(t),\n        -cos(t),\n        0.0\n    );\n}\n\n// curve seventh derivative (clop)\nvec3 mapD7(float t)\n{\n    return vec3(\n        -cos(t),\n        sin(t),\n        0.0\n    );\n}\n\n// curve eighth derivative (clop)\nvec3 mapD8(float t)\n{\n    return vec3(\n        sin(t),\n        -cos(t),\n        0.0\n    );\n}\n\n// curve ninth derivative (clop)\nvec3 mapD9(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        0.0\n    );\n}\n\n// curve tenth derivative (clop)\nvec3 mapD10(float t)\n{\n    return vec3(\n        -sin(t),\n        -cos(t),\n        0.0\n    );\n}\n\n// curve eleventh derivative (clop)\nvec3 mapD11(float t)\n{\n    return vec", "\n    return vec3(0.0);\n}\n\n// curve first derivative (velocity)\nvec3 mapD1(float t)\n{\n    return vec3(0.0);\n}\n\n// curve position\nvec3 map(float t)\n{\n    return vec3(0.0);\n}\n\n// curve length\nfloat mapLength()\n{\n    return 0.0;\n}\n\n// curve length at time t\nfloat mapLength(float t)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2\nfloat mapLength(float t1, float t2)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2, with a maximum of n segments\nfloat mapLength(float t1, float t2, int n)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2, with a maximum of n segments and a minimum segment length of d\nfloat mapLength(float t1, float t2, int n, float d)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2, with a maximum of n segments and a minimum segment length of d, and a maximum segment length of m\nfloat mapLength(float t1, float t2, int n, float d, float m)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2, with a maximum of n segments and a minimum segment length of d, and a maximum segment length of m, and a minimum segment length of m\nfloat mapLength(float t1, float t2, int n, float d, float m, float m2)\n{\n    return 0.0;\n}\n\n// curve length between times t1 and t2, with a maximum of n segments and a minimum segment length of d, and a maximum segment length of m, and a minimum segment length of m, and a maximum segment length of m\nfloat mapLength(float t1, float t2, int n, float d, float m, float m2, float m3)\n{\n    return 0.0;\n}\n\n// curve length between times t1", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot( pa, pa ), h );\n}\n\n// squared distance between point and segment\nvec2 sqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot( pa, pa ) - h*dot(pa,ba), h );\n}\n\n// squared distance between point and triangle\nvec2 sqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a, cb = c - b, ca = a - c;\n    vec3 pa = p - a, pb = p - b, pc = p - c;\n    float h = max( 0.0, dot(ba,pa) );\n    float s = max( 0.0, dot(cb,pb) );\n    float t = max( 0.0, dot(ca,pc) );\n    float d = 0.0;\n    d = min( d, pa.x*ba.x + pa.y*ba.y + pa.z*ba.z - h*dot(ba,ba) );\n    d = min( d, pb.x*cb.x + pb.y*cb.y + pb.z*cb.z - s*dot(cb,cb) );\n    d = min( d, pc.x*ca.x + pc.y*ca.y + pc.z*ca.z - t*dot(ca,ca) );\n    return vec2( d, max(h,max(s,t)) );\n}\n\n// squared distance between point and sphere\nvec2 sqdPointSphere( in vec3 p, in vec3 c, float r )\n{\n    vec3 d = p - c;\n    return vec2( dot(d,d", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    vec3 ad = d;\n\n    float e = dot(ab, ad);\n    float f = dot(ao, ad);\n    float t = f / e;\n\n    vec3 p = a + t * ab;\n\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n\n    float u = dot(ap, ap);\n    float v = dot(bp, bp);\n\n    return vec2(u, v);\n}\n\n// squared distance between ray and segment\nvec2 sqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment(a, b, o, d);\n    return vec2(sqrt(usqd.x), sqrt(usqd.y));\n}\n\n// squared distance between ray and segment\nfloat sqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t )\n{\n    vec2 usqd = usqdLineSegment(a, b, o, d);\n    t = usqd.x / usqd.y;\n    return sqrt(usqd.x);\n}\n\n// squared distance between ray and segment\nfloat sqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t, out float u )\n{\n    vec2 usqd = usqdLineSegment(a, b, o, d);\n    t = usqd.x / usqd.y;\n    u = usqd.y;\n    return sqrt(usqd.x);\n}\n\n// squared distance between ray and segment\nfloat sqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t, out float u, out float v )\n{\n    vec2 usqd = usqdLineSegment(a, b, o, d);\n    t = usqd.x / usqd.y;\n    u = usqd.y;\n    v = usqd.x;\n    return sqrt(", "\n  r = (abs(p)-b)*r;\n  return length(max(r.xy,r.zw)) + min(0.0, max(r.x,r.y) + max(r.z,r.w) - 1.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n  return sdRoundBox(p,b,vec4(r,r,r,r));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float tl, in float tr, in float bl, in float br ) \n{\n  return sdRoundBox(p,b,vec4(tl,tr,bl,br));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float tl, in float tr, in float bl, in float br ) \n{\n  return sdRoundBox(p,b,vec4(r,r,r,r),vec4(tl,tr,bl,br));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float tl, in float tr, in float bl, in float br, in float t ) \n{\n  return sdRoundBox(p,b,vec4(r,r,r,r),vec4(tl,tr,bl,br),t);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in float t ) \n{\n  r = (abs(p)-b)*r;\n  return length(max(r.xy,r.zw)) + min(0.0, max(r.x,r.y) + max(r.z,r.w) - 1.0) - t;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float tl, in float tr, in float bl, in float br, in float t, in float d ) \n{\n  return sdRoundBox(p,b,vec4(r,r,r,r),vec4(tl,tr,bl,br),t,d);\n}\n", "\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle4 = sunAngle2 * sunAngle2;\n    float sunAngle8 = sunAngle4 * sunAngle4;\n    float sunAngle16 = sunAngle8 * sunAngle8;\n    float sunAngle32 = sunAngle16 * sunAngle16;\n    float sunAngle64 = sunAngle32 * sunAngle32;\n    float sunAngle128 = sunAngle64 * sunAngle64;\n    float sunAngle256 = sunAngle128 * sunAngle128;\n    float sunAngle512 = sunAngle256 * sunAngle256;\n    float sunAngle1024 = sunAngle512 * sunAngle512;\n    float sunAngle2048 = sunAngle1024 * sunAngle1024;\n    float sunAngle4096 = sunAngle2048 * sunAngle2048;\n    float sunAngle8192 = sunAngle4096 * sunAngle4096;\n    float sunAngle16384 = sunAngle8192 * sunAngle8192;\n    float sunAngle32768 = sunAngle16384 * sunAngle16384;\n    float sunAngle65536 = sunAngle32768 * sunAngle32768;\n    float sunAngle131072 = sunAngle65536 * sunAngle65536;\n    float sunAngle262144 = sunAngle131072 * sunAngle131072;\n    float sunAngle524288 = sunAngle262144 * sunAngle262144;\n    float sunAngle1048576 = sunAngle524288 * sunAngle524288;\n    float sunAngle2097152 = sunAngle1048576 * sunAngle1048576;\n    float sunAngle4194304 = sunAngle20", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the function that will be called for each pixel in the window.\n// It will be called in a loop and the x and y values will be passed in.\n// The x and y values will be between 0 and 1.\n// The x value will be between 0 and 1 and will be the horizontal position of the pixel.\n// The y value will be between 0 and 1 and will be the vertical position of the pixel.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n// The x and y values will be passed in as normalized device coordinates.\n", "\n    vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n    float balloonRadius = 0.5;\n    float balloonHeight = 1.0;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength = 1.0;\n    float balloonWidth = 1.0;\n    float balloonHeight = 1.0;\n    float balloonRadius = 0.5;\n    float balloonThickness = 0.1;\n    float balloonLength", "\n    // This is the distance to thing1\n    float distanceToThing1 = distance( thing1, gl_FragCoord.xy );\n    // This is the distance to thing2\n    float distanceToThing2 = distance( thing2, gl_FragCoord.xy );\n    // If the distance to thing1 is less than the distance to thing2\n    if( distanceToThing1 < distanceToThing2 ){\n        // Return thing1\n        return thing1;\n    }\n    // Otherwise, return thing2\n    return thing2;\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){\n    // This is the distance to thing1\n    float distanceToThing1 = distance( thing1, gl_FragCoord.xy );\n    // This is the distance to thing2\n    float distanceToThing2 = distance( thing2, gl_FragCoord.xy );\n    // If the distance to thing1 is less than the distance to thing2\n    if( distanceToThing1 < distanceToThing2 ){\n        // Return thing1\n        return thing1;\n    }\n    // Otherwise, return thing2\n    return thing2;\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){\n    // This is the distance to thing1\n    float distanceToThing1 = distance( thing1, gl_FragCoord.xy );\n    // This is the distance to thing2\n    float distanceToThing2 = distance( thing2, gl_FragCoord.xy );\n    // If the distance to thing1 is less than the distance to thing2\n    if( distanceToThing1 < distanceToThing2 ){\n        // Return thing1\n        return thing1;\n    }\n    // Otherwise, return thing2\n    return thing2;\n}", "\n\n    // The distance to the closest thing in the world\n    float closestDistance = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // This is the epsilon value, which is the amount we are going to\n    // move the position of the hit point in order to calculate the normal.\n    // This is a very small value, and it is used to avoid division by zero.\n    // It is also used to avoid the normal being calculated at the same point\n    // as the hit point.\n    float epsilon = 0.0001;\n\n    // This is the normal of the surface.\n    vec3 normal;\n\n    // This is the position of the hit point.\n    vec3 p = positionOfHit;\n\n    // This is the position of the hit point, but with the x value increased by epsilon.\n    vec3 p1 = vec3( p.x + epsilon, p.y, p.z );\n\n    // This is the position of the hit point, but with the y value increased by epsilon.\n    vec3 p2 = vec3( p.x, p.y + epsilon, p.z );\n\n    // This is the position of the hit point, but with the z value increased by epsilon.\n    vec3 p3 = vec3( p.x, p.y, p.z + epsilon );\n\n    // This is the SDF of the hit point.\n    float d1 = sdf( p1 );\n\n    // This is the SDF of the hit point.\n    float d2 = sdf( p2 );\n\n    // This is the SDF of the hit point.\n    float d3 = sdf( p3 );\n\n    // This is the normal of the surface.\n    normal = normalize( vec3( d1 - d2, d2 - d3, d3 - d1 ) );\n\n    // This is the normal of the surface.\n    return normal;\n}\n\n// This is the function that is used to calculate the color of the surface.\n// It is called from the main function.\nvec3 getColorOfSurface( in vec3 positionOfHit ){\n    // This is the color of the surface.\n    vec3 color;\n\n    // This is the normal of the surface.\n    vec3 normal = getNormalOfSurface( positionOfHit );\n\n    // This is the color of", "\n    return vec3(0.0);\n}\n\n// this is the function that will be called\n// to get the color of the pixel at the given\n// coordinates.\nvec3 getPixelColor(vec2 coords){\n    // we'll just return the background color\n    // for now.\n    return doBackgroundColor();\n}\n", "\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doTorusColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doPlaneColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doTriangleColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doMeshColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doLightColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doPointLightColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}\n\nvec3 doSpotLightColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    vec3 color = vec3(0.0);\n    color = normalOfSurface;\n    return color;\n}", "\n\n    // This is the color of the world\n    vec3 worldColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the sky\n    vec3 skyColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the ground\n    vec3 groundColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the sun\n    vec3 sunColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the moon\n    vec3 moonColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the stars\n    vec3 starColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the clouds\n    vec3 cloudColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the fog\n    vec3 fogColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the water\n    vec3 waterColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the fire\n    vec3 fireColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the lava\n    vec3 lavaColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the ice\n    vec3 iceColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the snow\n    vec3 snowColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color of the grass\n    vec3 grassColor = vec3( 0.0, 0.0, 0.0 );\n\n    // This is the color", "\n    return (x / (1.0 - b)) - (b / x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    return (x / (1.0 - b)) - (b / x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    return (x / (1.0 - b)) - (b / x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    return (x / (1.0 - b)) - (b / x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    return (x / (1.0 - b)) - (b / x);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 144.7272))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 144.7272, 987.6543))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(int p){\n    return fract(sin(float(p) * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(uint p){\n    return fract(sin(float(p) * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(ivec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(ivec3 p){\n    return fract(sin(dot(", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.00001;\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.000001;\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_exclusive_inclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.999999;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_inclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.0000001;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.9999999;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_exclusive_inclusive(vec2 p){", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r --> is torus radius\n// input t --> is torus thickness\n// pretty simple, just compare point to torus radius and thickness\nfloat sdTorus(vec3 p, float r, float t)\n{\n    vec2 q = vec2(length(p.xz) - r, p.y);\n    return length(q) - t;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to cylinder radius and height\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to cone radius and height\nfloat sdCone(vec3 p, float r, float h)\n{\n    float d1 = -p.y;\n    float q = p.y - h;\n    float d2 = max(q, sqrt(dot(p.xz, p.xz)) - r);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input p --> is plane position\n// input n --> is plane normal\n// pretty simple, just compare point to", "\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\n//  \nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\n//  \nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\n//  \nfloat sdCylinder(vec3 p, vec2 c)\n{\n  return length(p.xz)-c.x;\n}\n\n// ~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n// \tc.x = cone radius\n//\tc.y = cone height\n//  \nfloat sdCone(vec3 p, vec2 c)\n{\n  vec2 q = vec2(length(p.xz),p.y);\n  return max(dot(q,c),-p.y);\n}\n\n// ~~~~~~~ signed distance function for plane\n// input p --> plane specs where:\n// \tp.x = plane width\n//\tp.y = plane height\n//\tp.z = plane depth\n//  \nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n// ~~~~~~~ signed distance function for torus knot\n// input t --> torus knot specs where:\n// \tt.x = torus knot radius\n//\tt.y = torus knot thickness\n//\tt.z = torus knot p\n//\tt.w", "\n    float a = 10.0;\n    float k = 10.0;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float a)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float a, float b)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.", "\n    return (d1 * d2) / (d1 + d2);\n}\n\n// ~~~~~~~ distance deformation, blends 3 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input d3 --> distance of object 3\n// output --> blended object\nfloat opBlend3( float d1, float d2, float d3)\n{\n    return (d1 * d2 * d3) / (d1 + d2 + d3);\n}\n\n// ~~~~~~~ distance deformation, blends 4 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input d3 --> distance of object 3\n// input d4 --> distance of object 4\n// output --> blended object\nfloat opBlend4( float d1, float d2, float d3, float d4)\n{\n    return (d1 * d2 * d3 * d4) / (d1 + d2 + d3 + d4);\n}\n\n// ~~~~~~~ distance deformation, blends 5 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input d3 --> distance of object 3\n// input d4 --> distance of object 4\n// input d5 --> distance of object 5\n// output --> blended object\nfloat opBlend5( float d1, float d2, float d3, float d4, float d5)\n{\n    return (d1 * d2 * d3 * d4 * d5) / (d1 + d2 + d3 + d4 + d5);\n}\n\n// ~~~~~~~ distance deformation, blends 6 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input d3 --> distance of object 3\n// input d4 --> distance of object 4\n// input d5 --> distance of object 5\n// input d6 --> distance of object 6\n// output --> blended object\nfloat opBlend6( float d1, float d2, float d3, float d4, float d5, float d6)\n{\n   ", "\n    float c = cos( t * yaw );\n    float s = sin( t * yaw );\n    mat2  m = mat2( c, -s, s, c );\n    vec3  q = vec3( m * p.xz, p.y );\n    return q;\n}\n\n// ~~~~~~~ domain deformation, folds the shape\n// input p --> original ray position\n// input t --> fold scale factor\n// output --> folded ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opFold( vec3 p, float t )\n{\n    p.x = abs( p.x ) - t;\n    p.y = abs( p.y ) - t;\n    p.z = abs( p.z ) - t;\n    return p;\n}\n\n// ~~~~~~~ domain deformation, folds the shape\n// input p --> original ray position\n// input t --> fold scale factor\n// output --> folded ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opFold( vec3 p, float t, float yaw )\n{\n    float c = cos( t * yaw );\n    float s = sin( t * yaw );\n    mat2  m = mat2( c, -s, s, c );\n    vec3  q = vec3( m * p.xz, p.y );\n    return q;\n}\n\n// ~~~~~~~ domain deformation, folds the shape\n// input p --> original ray position\n// input t --> fold scale factor\n// output --> folded ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opFold( vec3 p, float t, float yaw, float pitch )\n{\n    float c = cos( t * yaw );\n    float s = sin( t * yaw );\n    mat2  m = mat2( c, -s, s, c );\n    vec3  q = vec3( m * p.xz, p.y );\n    return q;\n}\n\n// ~~~~~~~ domain deformation, folds the shape\n// input p --> original ray position\n// input t --> fold", "\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n    if (o1.x > o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Subtraction / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n    if (o1.x > -o2.x)\n        return o1;\n    else\n        return vec2(-o2.x, o2.y);\n}\n\n// ~~~~~~~ do Smooth Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSU(vec2 o1, vec2 o2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (o2.x - o1.x) / k, 0.0, 1.0);\n    return vec2(mix(o2.x, o1.x, h) - k * h * (1.0 - h), o1.y);\n}\n\n// ~~~~~~~ do Smooth Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opSI(vec2 o1, vec2 o2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (o2.x - o1.x) / k, 0.0, 1.0);\n    return vec2", "\n    vec2 res = vec2(1e10, 0.0);\n    // sphere\n    vec4 s = vec4(0.0, 0.0, 0.0, 1.0);\n    float d = length(p - s.xyz) - s.w;\n    res = vec2(d, 1.0);\n    // box\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(1.0, 1.0, 1.0);\n    vec3 q = abs(p - b) - r;\n    float d2 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    res = vec2(d2, 2.0);\n    // torus\n    vec2 t = vec2(0.0, 1.0);\n    vec2 q2 = vec2(length(p.xz) - t.x, p.y);\n    float d3 = length(q2) - t.y;\n    res = vec2(d3, 3.0);\n    // cylinder\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    float h = 1.0;\n    float r2 = 1.0;\n    vec3 q3 = vec3(length(p.xz) - r2, p.y, 0.0);\n    float d4 = length(max(abs(q3) - vec3(r2, h * 0.5, 0.0), 0.0)) + min(max(q3.x, max(q3.y, q3.z)), 0.0);\n    res = vec2(d4, 4.0);\n    // cone\n    vec3 c2 = vec3(0.0, 0.0, 0.0);\n    float h2 = 1.0;\n    float r3 = 1.0;\n    vec3 q4 = vec3(length(p.xz), p.y, 0", "\n    vec2 res = vec2(-1.0);\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if (d < 0.001)\n        {\n            res = vec2(t, i);\n            break;\n        }\n        t += d;\n    }\n    return res;\n}\n\n// ~~~~~~~ get normal at point p on surface\n// input p --> point on surface\n// output is vec3 normal\n//\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    );\n    return normalize(n);\n}\n\n// ~~~~~~~ get color of surface at point p\n// input p --> point on surface\n// output is vec3 color\n//\nvec3 getColor(vec3 p)\n{\n    vec3 n = getNormal(p);\n    vec3 col = vec3(0.0);\n    col += 0.5 * vec3(1.0, 0.0, 0.0) * pow(max(0.0, dot(n, vec3(0.0, 1.0, 0.0))), 100.0);\n    col += 0.5 * vec3(0.0, 1.0, 0.0) * pow(max(0.0, dot(n, vec3(1.0, 0.0, 0.0))), 100.0);\n    col += 0.5 * vec3(0.0, 0.0, 1.0) * pow(max(0.0, dot(n, vec3(0.0, 0.0, 1.0))), 10", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    vec3 n;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        if (i > 50)\n        {\n            col = vec3(0.0, 0.0, 0.0);\n            break;\n        }\n        p = ro + t * rd;\n        n = normal(p);\n        if (dot(n, rd) < 0.0)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += 0.01;\n    }\n    return col;\n}\n\n// ~~~~~~~ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 col = render(ro, rd);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec3 c = normalize( targetPos - camPos );\n    vec3 a = normalize( cross( vec3(0.0,1.0,0.0), c ) );\n    vec3 b = normalize( cross( c, a ) );\n    mat3 m = mat3( a.x, a.y, a.z,\n                   b.x, b.y, b.z,\n                   c.x, c.y, c.z );\n    return m * rotate( roll );\n}\n\n// ~~~~~~~ creates ray from camera matrix and screen position\n// input cam --> camera matrix\n// input screenPos --> screen position\n// output --> ray point/direction\nvec3 getRay( in mat3 cam, in vec2 screenPos )\n{\n    vec3 p = vec3( screenPos, 1.0 );\n    return normalize( cam * p );\n}\n\n// ~~~~~~~ creates ray from camera matrix and screen position\n// input cam --> camera matrix\n// input screenPos --> screen position\n// output --> ray point/direction\nvec3 getRay( in mat3 cam, in vec2 screenPos, in float fov )\n{\n    vec3 p = vec3( screenPos, 1.0 );\n    return normalize( cam * p );\n}\n\n// ~~~~~~~ creates ray from camera matrix and screen position\n// input cam --> camera matrix\n// input screenPos --> screen position\n// output --> ray point/direction\nvec3 getRay( in mat3 cam, in vec2 screenPos, in float fov, in float aspect )\n{\n    vec3 p = vec3( screenPos, 1.0 );\n    return normalize( cam * p );\n}\n\n// ~~~~~~~ creates ray from camera matrix and screen position\n// input cam --> camera matrix\n// input screenPos --> screen position\n// output --> ray point/direction\nvec3 getRay( in mat3 cam, in vec2 screenPos, in float fov, in float aspect, in float near, in float far )\n{\n    vec3 p = vec3( screenPos, 1.0 );\n    return normalize( cam * p );\n}\n\n// ~~~~~~~ creates ray from camera matrix and screen position\n// input cam --> camera matrix\n// input screenPos --> screen", "\n    if (id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (id == 7.0)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if (id == 8.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (id == 9.0)\n    {\n        return vec3(0.5, 0.0, 0.0);\n    }\n    else if (id == 10.0)\n    {\n        return vec3(0.0, 0.5, 0.0);\n    }\n    else if (id == 11.0)\n    {\n        return vec3(0.0, 0.0, 0.5);\n    }\n    else if (id == 12.0)\n    {\n        return vec3(0.5, 0.5, 0.0);\n    }\n    else if (id == 13.0)\n    {", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n//  s.x = sphere radius\n//  \n// think of the sphere as a circle\n// get the distance to the sphere radius\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for box\n// input b --> box specs where:\n//  b.x = box width\n//  b.y = box height\n//  b.z = box depth\n//  \n// think of the box as a cube\n// get the distance to the box width, height, and depth\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\n//  \n// think of the cylinder as a circle\n// get the distance to the cylinder radius\n// then subtract the cylinder height from that\nfloat sdCylinder(vec3 p, vec2 c)\n{\n    return length(p.xz)-c.x;\n}\n\n// ~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n//  c.x = cone radius\n//  c.y = cone height\n//  \n// think of the cone as a circle\n// get the distance to the cone radius\n// then subtract the cone height from that\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xz);\n    return max(q-c.x,abs(p.y)-c.y);\n}\n\n// ~~~~~~~ signed distance function for plane\n// input p --> plane specs where:\n//  p.x = plane width\n//  p.y = plane height\n//  p.z = plane", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n// sphere extends indefinately in all directions, \n// so just return distance from center\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size z\n// box extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdBox(vec3 p)\n{\n    vec3 d = abs(p) - ps;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> thickness\n// torus extends indefinately in all directions, \n// so just return distance from center\nfloat sdTorus(vec3 p)\n{\n    vec2 q = vec2(length(p.xz)-ps.x,p.y);\n    return length(q)-ps.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n// cylinder extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCylinder(vec3 p)\n{\n    return length(p.xz)-ps.x;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> height\n// cone extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdCone(vec3 p)\n{\n    float q = length(p.xz);\n    return max(q-ps.x,p.y-ps.y);\n}\n\n// ~~~~~~~ signed distance function for capsule\n//  input ps -->", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (", "\n    return max(d1, -d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n    return min(d1, d2);\n}\n\n// ~~~~~~~ do shape intersection, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1, d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference(float d1,float d2)\n{\n    return max(d1, -d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n    return min(d1, d2);\n}\n\n// ~~~~~~~ do shape intersection, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1, d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wr", "\n    vec3 lightPos = vec3(0.0);\n    lightPos.x = (u_lightPos.x + 0.5) * u_worldSize.x;\n    lightPos.y = (u_lightPos.y + 0.5) * u_worldSize.y;\n    lightPos.z = (u_lightPos.z + 0.5) * u_worldSize.z;\n    return lightPos;\n}\n\n// ~~~~~~~~ calculates the light intensity\n// input --> world pos of point light\n// output --> light intensity\nfloat calculateLightIntensity(vec3 lightPos)\n{\n    float lightIntensity = 0.0;\n    float dist = distance(lightPos, v_worldPos);\n    lightIntensity = 1.0 / (dist * dist);\n    return lightIntensity;\n}\n\n// ~~~~~~~~ calculates the light intensity\n// input --> world pos of point light\n// output --> light intensity\nvec3 calculateLightColor(vec3 lightPos)\n{\n    vec3 lightColor = vec3(0.0);\n    lightColor = vec3(1.0, 1.0, 1.0);\n    return lightColor;\n}\n\n// ~~~~~~~~ calculates the light intensity\n// input --> world pos of point light\n// output --> light intensity\nvec3 calculateLightDirection(vec3 lightPos)\n{\n    vec3 lightDirection = vec3(0.0);\n    lightDirection = normalize(lightPos - v_worldPos);\n    return lightDirection;\n}\n\n// ~~~~~~~~ calculates the light intensity\n// input --> world pos of point light\n// output --> light intensity\nvec3 calculateLight(vec3 lightPos)\n{\n    vec3 lightIntensity = vec3(0.0);\n    lightIntensity = calculateLightIntensity(lightPos);\n    lightIntensity *= calculateLightColor(lightPos);\n    lightIntensity *= calculateLightDirection(lightPos);\n    return lightIntensity;\n}\n\n// ~~~~~~~~ calculates the light intensity\n// input --> world pos of point light\n// output --> light intensity\nvec3 calculateLighting(vec3 lightPos)\n{\n    vec3 lightIntensity = vec3(0.0);", "\n    vec4 res = vec4(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec4 hit = vec4(0.0);\n    float t = 0.0;\n    float id = 0.0;\n    float d = 0.0;\n    float itter = 0.0;\n    float itterMax = 100.0;\n    float itterMin = 0.0;\n    float itterStep = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0;\n    float itterRatioMin = 0.0;\n    float itterRatioStep = 0.0;\n    float itterRatio = 0.0;\n    float itterRatioMax = 1.0", "\n    vec3  rd = normalize(lp - sp);\n    float t = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(sp + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (h < 0.001 || t > 20.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ hardShadow\n// input sp --> position of surface we are shading\n// input lp --> light position\n// output float --> amount of shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    vec3  rd = normalize(lp - sp);\n    float t = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(sp + rd * t);\n        if (h < 0.001) return 0.0;\n        t += h;\n        if (t > 20.0) return 1.0;\n    }\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    vec3  rd = normalize(lp - sp);\n    float t = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(sp + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (h < 0.001", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = sp + nor * hr;\n        float dd = map(aopos);\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// ~~~~~~~ ambientOcclusion\n\n// ~~~~~~~ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(p.x, p.y, -1.0));\n\n    vec3 col = vec3(0.0);\n\n    float t = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float d = map(pos);\n        t += d;\n        if (d < 0.001)\n        {\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect(rd, nor);\n            vec3 ref2 = refract(rd, nor, 1.0 / 1.5);\n            vec3 ref3 = refract(rd, nor, 1.0 / 1.33);\n            vec3 ref4 = refract(rd, nor, 1.0 / 1.7);\n            vec3 ref5 = refract(rd, nor, 1.0 / 1.6);\n            vec3 ref6 = refract(rd, nor, 1.0 / 1.65);\n            vec", "\n    vec3 nD = vec3(0.0);\n    vec3 nD1 = vec3(0.0);\n    vec3 nD2 = vec3(0.0);\n    vec3 nD3 = vec3(0.0);\n    vec3 nD4 = vec3(0.0);\n    vec3 nD5 = vec3(0.0);\n    vec3 nD6 = vec3(0.0);\n    vec3 nD7 = vec3(0.0);\n    vec3 nD8 = vec3(0.0);\n    vec3 nD9 = vec3(0.0);\n    vec3 nD10 = vec3(0.0);\n    vec3 nD11 = vec3(0.0);\n    vec3 nD12 = vec3(0.0);\n    vec3 nD13 = vec3(0.0);\n    vec3 nD14 = vec3(0.0);\n    vec3 nD15 = vec3(0.0);\n    vec3 nD16 = vec3(0.0);\n    vec3 nD17 = vec3(0.0);\n    vec3 nD18 = vec3(0.0);\n    vec3 nD19 = vec3(0.0);\n    vec3 nD20 = vec3(0.0);\n    vec3 nD21 = vec3(0.0);\n    vec3 nD22 = vec3(0.0);\n    vec3 nD23 = vec3(0.0);\n    vec3 nD24 = vec3(0.0);\n    vec3 nD25 = vec3(0.0);\n    vec3 nD26 = vec3(0.0);\n    vec3 nD27 = vec3(0.0);\n    vec3 nD28 = vec3(0.0);\n    vec3 nD29 = vec3(0.0);\n    vec3 nD30 = vec3(0.0);\n    vec3 nD31 = vec3(0.0);\n    vec3 nD32 = vec3", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do", "\n    float f = exp(-fs.x*d);\n    vec3  fc = mix(fc1,fc2,f);\n    float f2 = 1.0-pow(1.0-f,fs.y);\n    vec3  fc2 = mix(fc1,fc2,f2);\n    vec3  fc3 = mix(fc2,fc1,f2);\n    vec3  fc4 = mix(fc3,fc2,f2);\n    vec3  fc5 = mix(fc4,fc3,f2);\n    vec3  fc6 = mix(fc5,fc4,f2);\n    vec3  fc7 = mix(fc6,fc5,f2);\n    vec3  fc8 = mix(fc7,fc6,f2);\n    vec3  fc9 = mix(fc8,fc7,f2);\n    vec3  fc10 = mix(fc9,fc8,f2);\n    vec3  fc11 = mix(fc10,fc9,f2);\n    vec3  fc12 = mix(fc11,fc10,f2);\n    vec3  fc13 = mix(fc12,fc11,f2);\n    vec3  fc14 = mix(fc13,fc12,f2);\n    vec3  fc15 = mix(fc14,fc13,f2);\n    vec3  fc16 = mix(fc15,fc14,f2);\n    vec3  fc17 = mix(fc16,fc15,f2);\n    vec3  fc18 = mix(fc17,fc16,f2);\n    vec3  fc19 = mix(fc18,fc17,f2);\n    vec3  fc20 = mix(fc19,fc18,f2);\n    vec3  fc21 = mix(fc20,fc19,f2);\n    vec3  fc22 = mix(fc21,fc20,f2);\n    vec3  fc23 = mix(fc22,fc21,f2);\n   ", "\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist)\n{\n    return cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist, float minAttn)\n{\n    float attn = cF + lF*d + qF*d*d;\n    if (attn < minAttn)\n        attn = minAttn;\n    return attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist, float minAttn, float maxAttn)\n{\n    float attn = cF + lF*d + qF*d*d;\n    if (attn < minAttn)\n        attn = minAttn;\n    if (attn > maxAttn)\n        attn = maxAttn", "\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, -1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ calculate ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output", "\n    vec3 color = vec3(0.0);\n    vec3 ray = normalize(cMat * vec3(fCoord,1.0));\n    vec3 pos = cPos;\n    float d = 0.0;\n    float i = 0.0;\n    float maxIter = 100.0;\n    float maxDist = 100.0;\n    float minDist = 0.001;\n    float dist = 0.0;\n    float step = 0.01;\n    float stepSize = 0.01;\n    float stepCount = 0.0;\n    float stepCountMax = 100.0;\n    float stepCountMin = 1.0;\n    float stepCountStep = 1.0;\n    float stepCountStepSize = 1.0;\n    float stepCountStepSizeMax = 100.0;\n    float stepCountStepSizeMin = 1.0;\n    float stepCountStepSizeStep = 1.0;\n    float stepCountStepSizeStepSizeMax = 100.0;\n    float stepCountStepSizeStepSizeMin = 1.0;\n    float stepCountStepSizeStepSizeStep = 1.0;\n    float stepCountStepSizeStepSizeStepSizeMax = 100.0;\n    float stepCountStepSizeStepSizeStepSizeMin = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStep = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeMax = 100.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeMin = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeStep = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeStepSizeMax = 100.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeStepSizeMin = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeStepSizeStep = 1.0;\n    float stepCountStepSizeStepSizeStepSizeStepSizeStepSizeStepSizeMax = 100.0;\n    float stepCountStepSizeStepSize", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c is the sin/cos of the angle of the cone\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y));\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b", "\n    vec2 d = vec2(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 z = c;\n    for (int i = 0; i < 4; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 5; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 6; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 7; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 8; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 10\nvec2 complex", "\n    vec4 color = vec4(0.0);\n    float morph = morphConstant.x;\n    float morph2 = morphConstant.y;\n    float morph3 = morphConstant.z;\n    float morph4 = morphConstant.w;\n    float morph5 = morphConstant.x;\n    float morph6 = morphConstant.y;\n    float morph7 = morphConstant.z;\n    float morph8 = morphConstant.w;\n    float morph9 = morphConstant.x;\n    float morph10 = morphConstant.y;\n    float morph11 = morphConstant.z;\n    float morph12 = morphConstant.w;\n    float morph13 = morphConstant.x;\n    float morph14 = morphConstant.y;\n    float morph15 = morphConstant.z;\n    float morph16 = morphConstant.w;\n    float morph17 = morphConstant.x;\n    float morph18 = morphConstant.y;\n    float morph19 = morphConstant.z;\n    float morph20 = morphConstant.w;\n    float morph21 = morphConstant.x;\n    float morph22 = morphConstant.y;\n    float morph23 = morphConstant.z;\n    float morph24 = morphConstant.w;\n    float morph25 = morphConstant.x;\n    float morph26 = morphConstant.y;\n    float morph27 = morphConstant.z;\n    float morph28 = morphConstant.w;\n    float morph29 = morphConstant.x;\n    float morph30 = morphConstant.y;\n    float morph31 = morphConstant.z;\n    float morph32 = morphConstant.w;\n    float morph33 = morphConstant.x;\n    float morph34 = morphConstant.y;\n    float morph35 = morphConstant.z;\n    float morph36 = morphConstant.w;\n    float morph37 = morphConstant.x;\n    float morph38 = morphConstant.y;\n    float morph39 = morphConstant.z;\n    float morph40 = morphConstant.w;\n    float morph41 = morphConstant.x;\n    float morph42 = morphConstant.y;\n    float morph4", "\n    vec4 color = vec4(0.0);\n    vec2 pixelSize = 1.0 / resolution;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(x, y) * pixelSize;\n            color += texture(biomorph, uv + offset);\n        }\n    }\n    color /= 9.0;\n    return color;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv)\n{\n    return antiAliasedBiomorph(uv, vec2(0.0));\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, float scale)\n{\n    vec4 color = vec4(0.0);\n    vec2 pixelSize = 1.0 / resolution;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(x, y) * pixelSize;\n            color += texture(biomorph, uv + offset);\n        }\n    }\n    color /= 9.0;\n    return color;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, float scale)\n{\n    return antiAliasedBiomorph(uv, vec2(0.0), scale);\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, float scale, float scale2)\n{\n    vec4 color = vec4(0.0);\n    vec2 pixelSize = 1.0 / resolution;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(x, y) * pixelSize;\n            color += texture(biomorph, uv + offset);\n        }\n    }\n    color /= 9.0;\n    return color;\n}\n\nvec4 antiAliasedBiomorph(vec2 uv, float scale, float scale2)\n{\n    return antiAli", "\n    return x - floor(x);\n}\n\nfloat triangle(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_2(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_3(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_4(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_5(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_6(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_7(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_8(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_9(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_10(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_11(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_12(float x) {\n    return 2.0 * repeat(x + 0.5) - 1.0;\n}\n\nfloat triangle_wave_13(", "\n    // First we need to find the line segment that we are on.\n    vec2 pAtoB = pB - pA;\n    vec2 pAtoU = uv - pA;\n    float t = dot(pAtoU, pAtoB) / dot(pAtoB, pAtoB);\n    t = clamp(t, 0.0, 1.0);\n    vec2 p = pA + t * pAtoB;\n    vec2 pU = uv - p;\n    // Now we need to find the distance to the line segment.\n    float d = length(pU);\n    // Now we need to find the distance to the line end points.\n    float dA = length(pAtoU - pAtoB * min(t, 1.0 - t));\n    float dB = length(pAtoU - pAtoB * max(t, 1.0 - t));\n    // Now we need to find the distance to the line end points rounded.\n    float dAR = length(pAtoU - pAtoB * min(t, 1.0 - t) - pAtoB * max(t, 1.0 - t) * rounded);\n    float dBR = length(pAtoU - pAtoB * max(t, 1.0 - t) - pAtoB * min(t, 1.0 - t) * rounded);\n    // Now we need to find the distance to the line end points rounded and thick.\n    float dARt = length(pAtoU - pAtoB * min(t, 1.0 - t) - pAtoB * max(t, 1.0 - t) * rounded - pAtoB * max(t, 1.0 - t) * thick.y);\n    float dBRt = length(pAtoU - pAtoB * max(t, 1.0 - t) - pAtoB * min(t, 1.0 - t) * rounded - pAtoB * min(t, 1.0 - t) * thick.y);\n    // Now we need to find the distance to the line end points rounded and thick", "\n    vec2 pa = pA - uv;\n    vec2 pb = pB - uv;\n    vec2 ba = pa - pb;\n    vec2 n = normalize(ba);\n    vec2 t = vec2(-n.y, n.x);\n    float d = dot(pa, n);\n    float da = dot(pa, t);\n    float db = dot(pb, t);\n    float w = abs(da - db) - thick.x;\n    float r = abs(da - db) - thick.y;\n    float a = smoothstep(0.0, 0.01, w);\n    float b = smoothstep(0.0, 0.01, r);\n    float c = smoothstep(0.0, 0.01, d);\n    float d = smoothstep(0.0, 0.01, -d);\n    float e = smoothstep(0.0, 0.01, d - thick.x);\n    float f = smoothstep(0.0, 0.01, d + thick.x);\n    float g = smoothstep(0.0, 0.01, d - thick.y);\n    float h = smoothstep(0.0, 0.01, d + thick.y);\n    float i = smoothstep(0.0, 0.01, d - thick.x - thick.y);\n    float j = smoothstep(0.0, 0.01, d + thick.x - thick.y);\n    float k = smoothstep(0.0, 0.01, d + thick.x + thick.y);\n    float l = smoothstep(0.0, 0.01, d - thick.x + thick.y);\n    float m = smoothstep(0.0, 0.01, d - thick.x - thick.y - thick.x);\n    float n = smoothstep(0.0, 0.01, d + thick.x - thick.y - thick.x);\n    float o = smoothstep(0.0, 0.01, d + thick.x + thick.y - thick.x);\n    float", "\n    float d = LineDistance(uv, pA, pB, rounded);\n    float outline = smoothstep(outlineThick, 0.0, d);\n    float line = smoothstep(thick.x, 0.0, d) - smoothstep(thick.y, 0.0, d);\n    return outline - line;\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    return DrawOutlinePix(uv, pA, pB, vec2(thick), rounded, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float outlineThick) {\n    return DrawOutlinePix(uv, pA, pB, thick, 0.0, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    return DrawOutlinePix(uv, pA, pB, thick, 0.0, 0.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB) {\n    return DrawOutlinePix(uv, pA, pB, 0.0, 0.0, 0.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float outlineThick, float rounded) {\n    return DrawOutlinePix(uv, pA, pB, vec2(thick), rounded, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick", "\n    vec2 pa = pA - uv;\n    vec2 pb = pB - uv;\n    vec2 ba = pb - pa;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 ph = pa + h * ba;\n    float d = length(ph) * sign(dot(ph, ba));\n    float w = length(ba);\n    float r = w * 0.5 * rounded;\n    float s = smoothstep(w * 0.5 - r, w * 0.5 + r, d) - smoothstep(w * 0.5 - r - thick.x, w * 0.5 - r, d);\n    return s;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    return FillLine(uv, pA, pB, vec2(thick), rounded);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return FillLine(uv, pA, pB, vec2(thick), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB) {\n    return FillLine(uv, pA, pB, vec2(1.0), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float offset) {\n    vec2 pa = pA - uv;\n    vec2 pb = pB - uv;\n    vec2 ba = pb - pa;\n    float h = clamp", "\n    vec2 pa = pA - uv;\n    vec2 pb = pB - uv;\n    vec2 ba = pb - pa;\n    vec2 n = normalize(ba);\n    vec2 t = vec2(-n.y, n.x);\n    float d = dot(pa, n);\n    float da = dot(pa, t);\n    float db = dot(pb, t);\n    float dth = 0.5 * thick.x;\n    float dta = abs(da) - dth;\n    float dtb = abs(db) - dth;\n    float dta2 = dta * dta;\n    float dtb2 = dtb * dtb;\n    float d2 = d * d;\n    float d2a = d2 + dta2;\n    float d2b = d2 + dtb2;\n    float d2ab = d2a * d2b;\n    float d2ab2 = d2ab * d2ab;\n    float d2ab4 = d2ab2 * d2ab2;\n    float d2ab6 = d2ab4 * d2ab2;\n    float d2ab8 = d2ab6 * d2ab2;\n    float d2ab10 = d2ab8 * d2ab2;\n    float d2ab12 = d2ab10 * d2ab2;\n    float d2ab14 = d2ab12 * d2ab2;\n    float d2ab16 = d2ab14 * d2ab2;\n    float d2ab18 = d2ab16 * d2ab2;\n    float d2ab20 = d2ab18 * d2ab2;\n    float d2ab22 = d2ab20 * d2ab2;\n    float d2ab24 = d2ab22 * d2ab2;\n    float d2ab26 = d2ab24 * d2ab2;\n    float d2ab28 = d2ab26 * d2ab2;\n    float d2ab30 = d2ab28 * d2ab2;\n    float d2ab32 =", "\n    float d = 0.0;\n    vec2 pa = pA - uv;\n    vec2 pb = pB - uv;\n    vec2 ba = pb - pa;\n    vec2 n = vec2(-ba.y, ba.x);\n    float l = length(ba);\n    float t = clamp(dot(pa, ba) / l, 0.0, 1.0);\n    vec2 pc = pa + ba * t;\n    float d1 = length(pc - uv);\n    float d2 = abs(dot(n, pc));\n    float d3 = abs(d2 - l * 0.5) - (l * 0.5 - thick.x);\n    float d4 = abs(d2 - l * 0.5) - (l * 0.5 - thick.y);\n    float d5 = abs(d2 - l * 0.5) - (l * 0.5 - outlineThick);\n    d = min(d1, min(d2, min(d3, min(d4, d5))));\n    if (rounded > 0.0) {\n        float r = l * 0.5 - rounded;\n        float d6 = abs(d2 - l * 0.5) - r;\n        d = min(d, d6);\n    }\n    return d;\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    return DrawOutline(uv, pA, pB, vec2(thick), rounded, outlineThick);\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return DrawOutline(uv, pA, pB, vec2(thick), 0.0, 0.0);\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span", "\n    float d = length(uv - p);\n    col = vec3(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = vec2(0.5);\n    vec3 col = vec3(0.0);\n    DrawPoint(uv, p, col);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float b = dot( cen-ro, nor );\n    float c = dot( cen-ro, cen-ro ) - rad*rad;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) // sphere: center, radius\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad ) // box: radius\n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return -1.0;\n    return tN;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 p = cross( rd, e1 );\n    float det = dot( e0, p );\n    if( det<0.0001 ) return -1.0;\n    vec3 t = ro - v0;\n    float u", "\n    vec3 m = ro - cen;\n    vec3 n = m / rd;\n    vec3 k = abs(n);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0); // or < 0.0\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float denom = dot( rd, pla.xyz );\n    if( abs(denom)<0.0001 ) return vec2(-1.0);\n    float t = -(dot(ro,pla.xyz)+pla.w)/denom;\n    return vec2(t,t);\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v1;\n    vec3 e2 = v0 - v2;\n    vec3 q = cross( rd, e2 );\n    float a = dot( e0, q );\n    if( a>0.0 ) return vec2(-1.0);\n    float f =", "\n    vec3  ba = pb - pa;\n    float l  = length( ba );\n    vec3  ba_n = ba / l;\n    vec3  ba_t = vec3( -ba_n.y, ba_n.x, 0.0 );\n    vec3  ba_b = cross( ba_n, ba_t );\n    vec3  ra_t = ba_t * ra;\n    vec3  ra_b = ba_b * ra;\n    vec3  a = pa - ra_t - ra_b;\n    vec3  b = pb + ra_t + ra_b;\n    return bound3( a, b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - r, p + r );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 p, in vec3 b )\n{\n    return bound3( p - b, p + b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    float l  = length( ba );\n    vec3  ba_n = ba / l;\n    vec3  ba_t = vec3( -ba_n.y, ba_n.x, 0.0 );\n    vec3  ba_b = cross( ba_n, ba_t );\n    vec3  ra_t = ba_t * ra;\n    vec3  ra_b = ba_b * ra;\n    vec3  a = pa - ra_t - ra_b;\n    vec3  b = pb + ra_t + ra_b;\n    return bound3( a, b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    float l  = length", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    vec3 ob = ro - pb;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float obdo = dot(ob,rd);\n    float raba = dot(ra,ba);\n\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*rdoa*rdoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        h = -b - sqrt(h);\n        float t = h / a;\n        float y = baoa + h*bard / baba;\n        if( y>0.0 && y<baba && t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = normalize( pos-pa );\n            return vec4(t,nor);\n        }\n    }\n    return vec4(-1.0);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) // sphere (center,radius)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc,rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 )\n    {\n        h = -b - sqrt(h);\n        return vec4( h, normalize(ro+h*rd-sph.xyz) );\n    }\n    return vec4(-1.0);\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) // plane (center,normal)\n{\n    float", "\n    vec3 m = ro - cen;\n    vec3 invR = 1.0 / rd;\n    vec3 t0 = -m * invR;\n    vec3 t1 = (rad - m) * invR;\n    float tN = max( max( t0.x, t0.y ), t0.z );\n    float tF = min( min( t1.x, t1.y ), t1.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 m = ro - sph.xyz;\n    float b = dot(m, rd);\n    float c = dot(m, m) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float d = dot(ro, pla.xyz) - pla.w;\n    float t = -d / dot(rd, pla.xyz);\n    return vec2(t, 0.0);\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v1;\n    vec3 e2 = v0 - v2;\n    vec3 q = cross(rd, e2);\n    float a = dot(e0, q);\n    if( a>0.0 ) return vec2(-1.0);\n    vec3 s = ro - v0;\n    float u = dot(s, q);\n    if( u<0.0 || u>", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    vec3 ob = ro - pb;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float baob = dot(ba,ob);\n    float ococ = dot(oc,oc);\n    float ocoa = dot(oc,oa);\n    float rdoa = dot(rd,oa);\n    float rdbo = dot(rd,ob);\n    float rdrx = dot(rd,ba);\n    float rdrx2 = rdrx*rdrx;\n    float ococ2 = ococ*ococ;\n    float baba2 = baba*baba;\n    float baba3 = baba2*baba;\n    float baba4 = baba3*baba;\n    float baba5 = baba4*baba;\n    float baba6 = baba5*baba;\n    float baba7 = baba6*baba;\n    float baba8 = baba7*baba;\n    float baba9 = baba8*baba;\n    float baba10 = baba9*baba;\n    float baba11 = baba10*baba;\n    float baba12 = baba11*baba;\n    float baba13 = baba12*baba;\n    float baba14 = baba13*baba;\n    float baba15 = baba14*baba;\n    float baba16 = baba15*baba;\n    float baba17 = baba16*baba;\n    float baba18 = baba17*baba;\n    float baba19 = baba18*baba;\n    float baba20 = baba19*baba;\n    float baba21 = baba20*baba;\n    float baba22 = baba21*baba;\n    float baba23 = baba22*b", "\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h  = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return normalize( pa - ba*h );\n}\n\n// compute distance to a capped cylinder\nfloat capCylinder( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h  = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// compute distance to a capped cone\nfloat capCone( in vec3 pos, in vec3 a, in vec3 b, in float ra, in float rb )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h  = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix( ra, rb, h );\n}\n\n// compute distance to a capped cone\nfloat capCone( in vec3 pos, in vec3 a, in vec3 b, in float ra, in float rb, in float h )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float hh = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*hh ) - mix( ra, rb, hh );\n}\n\n// compute distance to a capped cone\nfloat capCone( in vec3 pos, in vec3 a, in vec3 b, in float ra, in float rb, in float h, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float hh = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*hh ) - mix", "\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0); // or : return vec2( -1.0, -1.0 );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in mat4 boxToWorld ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0); // or : return vec2( -1.0, -1.0 );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in mat4 boxToWorld, in mat4 worldToBox ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n", "\n    float t = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float d = map( p );\n        if( d<0.001 )\n            return vec4( p, t );\n        t += d;\n    }\n    return vec4(0.0);\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(\n           map(pos+e.xyy) - map(pos-e.xyy),\n           map(pos+e.yxy) - map(pos-e.yxy),\n           map(pos+e.yyx) - map(pos-e.yyx) ) );\n}\n\n// lighting\nvec3 calcLighting( in vec3 pos, in vec3 nor )\n{\n    vec3  lightPos = vec3( 0.0, 0.0, 0.0 );\n    float lightIntensity = 1.0;\n    vec3  lightDir = normalize( lightPos - pos );\n    float diff = max( dot(nor,lightDir), 0.0 );\n    vec3  col = vec3(0.0);\n    col += diff * vec3(1.0,0.9,0.8);\n    col += 0.15 * vec3(1.0,0.9,0.8);\n    return col;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 rd = normalize( vec3(uv,2.0) );\n\n    vec4 res = interesect( ro, rd );\n    vec3 pos = res.xyz;\n    vec3 nor =", "\n    float phi = 2.0 * PI * (i + 0.5) / n;\n    float theta = PI * (3.0 - sqrt(5.0)) * i / n;\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nvec3 forwardSF( float i, float n, float radius) \n{\n    return forwardSF(i, n) * radius;\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset) \n{\n    return forwardSF(i, n) * radius + offset;\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale) \n{\n    return forwardSF(i, n) * radius * scale + offset;\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation) \n{\n    return rotate(forwardSF(i, n) * radius * scale + offset, rotation);\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation, float rotation_axis) \n{\n    return rotate(forwardSF(i, n) * radius * scale + offset, rotation, rotation_axis);\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation, float rotation_axis, float rotation_angle) \n{\n    return rotate(forwardSF(i, n) * radius * scale + offset, rotation, rotation_axis, rotation_angle);\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation, float rotation_axis, float rotation_angle, float rotation_angle_axis) \n{\n    return rotate(forwardSF(i, n) * radius * scale + offset, rotation, rotation_axis, rotation_angle, rotation_angle_axis);\n}\n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation, float rotation_axis, float rotation_angle, float rotation_angle_axis, float rotation_angle_axis_angle) \n{\n   ", "\n    float t = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float f = 0.0;\n    float gf = 0.0;\n    float sf = 0.0;\n    float rf = 0.0;\n    float bf = 0.0;\n    float af = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 =", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( hash( i + vec3(0.0,0.0,0.0) ), \n                          hash( i + vec3(1.0,0.0,0.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,0.0) ), \n                          hash( i + vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( hash( i + vec3(0.0,0.0,1.0) ), \n                          hash( i + vec3(1.0,0.0,1.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,1.0) ), \n                          hash( i + vec3(1.0,1.0,1.0) ), u.x), u.y), u.z);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec4 p )\n{\n    vec4 i = floor( p );\n    vec4 f = fract( p );\n\n    vec4 u = f*f*(3.0-2.0*f);\n\n    return mix", "\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat scene(vec2 p)\n{\n    float d = boxDist(p, vec2(0.5), 0.05);\n    d = smoothMerge(d, boxDist(p, vec2(0.5), 0.05), 0.05);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float d = scene(uv);\n\n    vec3 col = vec3(0.0);\n    col = vec3(1.0 - smoothstep(0.0, 0.01, d));\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float f = fract(a * 10.0);\n    float g = fract(d * 10.0);\n    float e = fract(a * 100.0);\n    float h = fract(d * 100.0);\n    float c = fract(a * 1000.0);\n    float b = fract(d * 1000.0);\n    float i = fract(a * 10000.0);\n    float j = fract(d * 10000.0);\n    float k = fract(a * 100000.0);\n    float l = fract(d * 100000.0);\n    float m = fract(a * 1000000.0);\n    float n = fract(d * 1000000.0);\n    float o = fract(a * 10000000.0);\n    float p = fract(d * 10000000.0);\n    float q = fract(a * 100000000.0);\n    float r = fract(d * 100000000.0);\n    float s = fract(a * 1000000000.0);\n    float t = fract(d * 1000000000.0);\n    float u = fract(a * 10000000000.0);\n    float v = fract(d * 10000000000.0);\n    float w = fract(a * 100000000000.0);\n    float x = fract(d * 100000000000.0);\n    float y = fract(a * 1000000000000.0);\n    float z = fract(d", "\n    vec2 p = uv * 2.0 - 1.0;\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float f = fract(a * 10.0);\n    float d = smoothstep(0.0, 0.01, abs(f - 0.5));\n    float g = smoothstep(0.0, 0.01, abs(f - 0.5) - 0.2);\n    float c = smoothstep(0.0, 0.01, abs(f - 0.5) - 0.4);\n    float e = smoothstep(0.0, 0.01, abs(f - 0.5) - 0.6);\n    float b = smoothstep(0.0, 0.01, abs(f - 0.5) - 0.8);\n    float h = smoothstep(0.0, 0.01, abs(f - 0.5) - 1.0);\n    float i = smoothstep(0.0, 0.01, abs(f - 0.5) - 1.2);\n    float j = smoothstep(0.0, 0.01, abs(f - 0.5) - 1.4);\n    float k = smoothstep(0.0, 0.01, abs(f - 0.5) - 1.6);\n    float l = smoothstep(0.0, 0.01, abs(f - 0.5) - 1.8);\n    float m = smoothstep(0.0, 0.01, abs(f - 0.5) - 2.0);\n    float n = smoothstep(0.0, 0.01, abs(f - 0.5) - 2.2);\n    float o = smoothstep(0.0, 0.01, abs(f - 0.5) - 2.4);\n    float p = smoothstep(0.0, 0.01, abs(f - 0.5) - 2.", "\n    vec2 f = fract( p * ddx );\n    vec2 g = ddx * ddy;\n    float a = textureGrad( iChannel0, p, ddx, ddy ).x;\n    float b = textureGrad( iChannel0, p + g, ddx, ddy ).x;\n    float c = textureGrad( iChannel0, p + vec2( g.x, 0.0 ), ddx, ddy ).x;\n    float d = textureGrad( iChannel0, p + vec2( 0.0, g.y ), ddx, ddy ).x;\n    float e = textureGrad( iChannel0, p + g + vec2( g.x, 0.0 ), ddx, ddy ).x;\n    float f0 = mix( mix( a, b, f.x ), mix( c, d, f.x ), f.y );\n    float f1 = mix( mix( b, e, f.x ), mix( d, f, f.x ), f.y );\n    return mix( f0, f1, step( f.x, f.y ) );\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p )\n{\n    vec2 f = fract( p * iChannelResolution[0].xy );\n    vec2 g = iChannelResolution[0].xy;\n    float a = texture( iChannel0, p ).x;\n    float b = texture( iChannel0, p + g ).x;\n    float c = texture( iChannel0, p + vec2( g.x, 0.0 ) ).x;\n    float d = texture( iChannel0, p + vec2( 0.0, g.y ) ).x;\n    float e = texture( iChannel0, p + g + vec2( g.x, 0.0 ) ).x;\n    float f0 = mix( mix( a, b, f.x ), mix( c, d, f.x ), f.y );\n    float f1 = mix( mix( b, e, f.x ), mix( d, f, f.x ), f.y );\n    return mix( f0, f1, step( f.x, f", "\n    vec3 d = vec3(0.0);\n    d.x = map(vec3(p.x+eps,p.y,p.z)) - map(vec3(p.x-eps,p.y,p.z));\n    d.y = map(vec3(p.x,p.y+eps,p.z)) - map(vec3(p.x,p.y-eps,p.z));\n    d.z = map(vec3(p.x,p.y,p.z+eps)) - map(vec3(p.x,p.y,p.z-eps));\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap2( in vec3 p )\n{\n    vec3 d = vec3(0.0);\n    d.x = map(vec3(p.x+eps,p.y,p.z)) - map(vec3(p.x-eps,p.y,p.z));\n    d.y = map(vec3(p.x,p.y+eps,p.z)) - map(vec3(p.x,p.y-eps,p.z));\n    d.z = map(vec3(p.x,p.y,p.z+eps)) - map(vec3(p.x,p.y,p.z-eps));\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap3( in vec3 p )\n{\n    vec3 d = vec3(0.0);\n    d.x = map(vec3(p.x+eps,p.y,p.z)) - map(vec3(p.x-eps,p.y,p.z));\n    d.y = map(vec3(p.x,p.y+eps,p.z)) - map(vec3(p.x,p.y-eps,p.z));\n    d.z = map(vec3(p.x,p.y,p.z+eps)) - map(vec3(p.x,p.y,p.z-eps));", "\n  v33 c=a;\n  a.x=b.x;\n  a.y=b.y;\n  a.z=b.z;\n  b.x=c.x;\n  b.y=c.y;\n  b.z=c.z;\n}\n\n//and this is the ray-transpose function that is actually useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n  v33 c=a;\n  a.x=b.x;\n  a.y=b.y;\n  a.z=b.z;\n  b.x=c.x;\n  b.y=c.y;\n  b.z=c.z;\n}\n\n//and this is the ray-transpose function that is actually useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n  v33 c=a;\n  a.x=b.x;\n  a.y=b.y;\n  a.z=b.z;\n  b.x=c.x;\n  b.y=c.y;\n  b.z=c.z;\n}\n\n//and this is the ray-transpose function that is actually useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n  v33 c=a;\n  a.x=b.x;\n  a.y=b.y;\n  a.z=b.z;\n  b.x=c.x;\n  b.y=c.y;\n  b.z=c.z;\n}\n\n//and this is the ray-transpose function that is actually useful here:\nvoid rayTransp(inout v33 a,inout v33 b){\n  v33 c=a;\n  a.x=b.x;\n  a.y=b.y;\n  a.z=b.z;\n  b.x=c.x;\n  b.y=c.y;\n  b.z=c.z;\n}\n\n//and this", "\n    return vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 add(v33 a,vec3 b){\n    return vec3(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n    return vec3(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mod(v33 a,vec3 b){\n    return vec3(a.x%b.x,a.y%b.y,a.z%b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 pow(v33 a,vec3 b){\n    return vec3(pow(a.x,b.x),pow(a.y,b.y),pow(a.z,b.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 min(v33 a,vec3 b){\n    return vec3(min(a.x,b.x),min(a.y,b.y),min(a.z,b.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 max(v33 a,vec3 b){\n    return vec3(max(a.x,b.x),max(a.y,b.", "\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return (v33){a.x-b.x,a.y-b.y,a.z-b.z};\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v", "\n    return vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-dot product for AA\nfloat dp(v33 a,v33 b){\n    return a.x*b.x+a.y*b.y;\n}\n\n//v33-cross product for AA\nfloat cp(v33 a,v33 b){\n    return a.x*b.y-a.y*b.x;\n}\n\n//v33-length for AA\nfloat l(v33 a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\n//v33-normalize for AA\nv33 n(v33 a){\n    float l=sqrt(a.x*a.x+a.y*a.y);\n    return v33(a.x/l,a.y/l);\n}\n\n//v33-rotate for AA\nv33 r(v33 a,float t){\n    float c=cos(t),s=sin(t);\n    return v33(a.x*c-a.y*s,a.x*s+a.y*c);\n}\n\n//v33-reflect for AA\nv33 rf(v33 a,v33 n){\n    return a-2.0*dp(a,n)*n;\n}\n\n//v33-refract for AA\nv33 rf(v33 a,v33 n,float eta){\n    float d=dp(a,n);\n    float k=1.0-eta*eta*(1.0-d*d);\n    return k<0.0?v33(0.0,0.0):a*eta-n*(eta*d+sqrt(k));\n}\n\n//v33-reflectance for AA\nfloat rr(v33 a,v33 n,float eta){\n    float d=dp(a,n);\n    float k=1.0-eta*eta*(1.0-d*d);\n    return k<0.0?1", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,v33 b){\n    return vec2(dot(a,b.x),dot(a,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n    return vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b){\n    return vec2(dot(a,b),0.0);\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c){\n    return vec2(dot(a,b),dot(a,c));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c,vec3 d){\n    return vec2(dot(a,b),dot(a,c));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e){\n    return vec2(dot(a,b),dot(a,c));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f){\n    return vec2(dot(a,b),dot(a,c));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g){\n    return vec2(dot(a,b),dot(a,c));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec", "\n    return v33(a.x*b.x,a.y*b.y,a.z*b.x,a.w*b.y);\n}\n\n//dual div\nv33 div(v33 a,vec2 b){\n    return v33(a.x/b.x,a.y/b.y,a.z/b.x,a.w/b.y);\n}\n\n//dual add\nv33 add(v33 a,v33 b){\n    return v33(a.x+b.x,a.y+b.y,a.z+b.z,a.w+b.w);\n}\n\n//dual sub\nv33 sub(v33 a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w);\n}\n\n//dual dot\nfloat dot(v33 a,v33 b){\n    return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w;\n}\n\n//dual cross\nv33 cross(v33 a,v33 b){\n    return v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x,0.0);\n}\n\n//dual length\nfloat length(v33 a){\n    return sqrt(dot(a,a));\n}\n\n//dual normalize\nv33 normalize(v33 a){\n    return div(a,vec2(length(a),1.0));\n}\n\n//dual distance\nfloat distance(v33 a,v33 b){\n    return length(sub(a,b));\n}\n\n//dual lerp\nv33 lerp(v33 a,v33 b,float t){\n    return add(mul(a,vec2(1.0-t)),mul(b,vec2(t)));", "\n    vec3 q=p-w*floor(p/w);\n    return (fract(q.x*0.5+q.y*0.5+q.z*0.5)>0.5)?-1.0:1.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (fract(q.x*0.5+q.y*0.5+q.z*0.5)>0.5)?-1.0:1.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (fract(q.x*0.5+q.y*0.5+q.z*0.5)>0.5)?-1.0:1.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF5(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (fract(q.x*0.5+q.y*0.5+q.z*0.5)>0.5)?-1.0:1.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF6(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (fract(q.x*0.5+q.y*0.5+q.z*0.5)>0.5)?-1.0:1.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF7(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n", "\n    vec3 q=p-w*floor(p/w);\n    return (q.x+q.y+q.z)*(q.x+q.y+q.z-2.0);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF3()\nfloat checkerF4(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (q.x+q.y+q.z)*(q.x+q.y+q.z-1.0);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF4()\nfloat checkerF5(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (q.x+q.y+q.z)*(q.x+q.y+q.z-0.5);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF5()\nfloat checkerF6(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (q.x+q.y+q.z)*(q.x+q.y+q.z-0.25);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF6()\nfloat checkerF7(vec3 p,vec3 w){\n    vec3 q=p-w*floor(p/w);\n    return (q.x+q.y+q.z)*(q.x+q.y+q.z-0.125);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF7()\nfloat checker", "\n    float t=0.0;\n    float d=0.0;\n    float m=0.0;\n    float b=0.0;\n    float c=0.0;\n    float h=0.0;\n    float k=0.0;\n    float l=0.0;\n    float n=0.0;\n    float p=0.0;\n    float q=0.0;\n    float rr=0.0;\n    float s=0.0;\n    float t=0.0;\n    float u=0.0;\n    float v=0.0;\n    float w=0.0;\n    float x=0.0;\n    float y=0.0;\n    float z=0.0;\n    float a=0.0;\n    float b=0.0;\n    float c=0.0;\n    float d=0.0;\n    float e=0.0;\n    float f=0.0;\n    float g=0.0;\n    float h=0.0;\n    float i=0.0;\n    float j=0.0;\n    float k=0.0;\n    float l=0.0;\n    float m=0.0;\n    float n=0.0;\n    float o=0.0;\n    float p=0.0;\n    float q=0.0;\n    float r=0.0;\n    float s=0.0;\n    float t=0.0;\n    float u=0.0;\n    float v=0.0;\n    float w=0.0;\n    float x=0.0;\n    float y=0.0;\n    float z=0.0;\n    float a=0.0;\n    float b=0.0;\n    float c=0.0;\n    float d=0.0;\n    float e=0.0;\n    float f=0.0;\n    float g=0.0;\n    float h=0.0;\n    float i=0.0;\n    float j=0.0;\n    float k=0.", "\n    float d=dot(u,n);\n    float r=s.w;\n    float t=r-sqrt(r*r-d*d);\n    return t;\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 p){\n    float d=dot(u,n);\n    float t=p.w/d;\n    return t;\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 b){\n    vec3 v=u*n;\n    vec3 d=abs(v)-b.xyz;\n    float t=min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n    return t;\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 c){\n    vec3 v=u*n;\n    float d=v.x;\n    float r=c.w;\n    float t=d-sqrt(r*r-v.y*v.y);\n    return t;\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 c){\n    vec3 v=u*n;\n    float d=v.x;\n    float r=c.w;\n    float t=d-r*v.y/sqrt(v.y*v.y+r*r);\n    return t;\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 t){\n    vec3 v=u*n;\n    float d=v.x;\n    float r=t.w;\n    float t1=d-sqrt(r*r-v.y*v.y);\n    float t2=d+sqrt(r*r-v.y*v.y);\n    return min(t1,t2);\n}\n\n//capsule occlusion\nfloat occCapsule(vec3 u,vec3 n,vec4 c){\n    vec3 v=u*n;\n    float d=v.x;\n    float r=c.w;\n    float", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p0 - 2.0*p1 + p2;\n    vec2 d = p0 - 3.0*p1 + 3.0*p2;\n    vec2 e = p0 - 2.0*p1 + p2;\n    vec2 f = p0 - p1;\n    vec2 g = p1 - p2;\n    vec2 h = p0;\n    vec2 i = p2;\n    vec2 j = vec2(0.0);\n    vec2 k = vec2(0.0);\n    vec2 l = vec2(0.0);\n    vec2 m = vec2(0.0);\n    vec2 n = vec2(0.0);\n    vec2 o = vec2(0.0);\n    vec2 p = vec2(0.0);\n    vec2 q = vec2(0.0);\n    vec2 r = vec2(0.0);\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n    vec2 u = vec2(0.0);\n    vec2 v = vec2(0.0);\n    vec2 w = vec2(0.0);\n    vec2 x = vec2(0.0);\n    vec2 y = vec2(0.0);\n    vec2 z = vec2(0.0);\n    vec2 A = vec2(0.0);\n    vec2 B = vec2(0.0);\n    vec2 C = vec2(0.0);\n    vec2 D = vec2(0.0);\n    vec2 E = vec2(0.0);\n    vec2 F = vec2(0.0);\n    vec2 G = vec2(0.0);\n    vec2 H = vec2(0.0);\n    vec2 I = vec2(0.0);\n    vec2 J = vec2(0.0);\n    vec2 K = vec2(0.0);\n    vec2 L = vec2(0.0);\n    vec2", "\n    vec2 p01 = p0 + p1;\n    vec2 p12 = p1 + p2;\n    vec2 p012 = p01 + p12;\n    vec2 p0123 = p01 + p012;\n    vec2 p01234 = p012 + p0123;\n    vec2 p012345 = p0123 + p01234;\n    vec2 p0123456 = p01234 + p012345;\n    vec2 p01234567 = p012345 + p0123456;\n    vec2 p012345678 = p0123456 + p01234567;\n    vec2 p0123456789 = p01234567 + p012345678;\n    vec2 p0123456789a = p012345678 + p0123456789;\n    vec2 p0123456789ab = p0123456789 + p0123456789a;\n    vec2 p0123456789abc = p0123456789a + p0123456789ab;\n    vec2 p0123456789abcd = p0123456789ab + p0123456789abc;\n    vec2 p0123456789abcde = p0123456789abc + p0123456789abcd;\n    vec2 p0123456789abcdef = p0123456789abcd + p0123456789abcde;\n    vec2 p0123456789", "\n    vec3  d = p1 - p0;\n    vec3  e = p2 - p1;\n    vec3  f = p3 - p2;\n    vec3  g = p0 - p1;\n    vec3  h = p1 - p2;\n    vec3  i = p2 - p3;\n    vec3  j = p0 - p2;\n    vec3  k = p1 - p3;\n    vec3  l = p0 - p3;\n\n    vec3  a = cross( d, e );\n    vec3  b = cross( e, f );\n    vec3  c = cross( f, d );\n    vec3  d1 = cross( g, h );\n    vec3  e1 = cross( h, i );\n    vec3  f1 = cross( i, g );\n    vec3  g1 = cross( j, k );\n    vec3  h1 = cross( k, l );\n    vec3  i1 = cross( l, j );\n\n    vec3  m = cross( a, d1 );\n    vec3  n = cross( b, e1 );\n    vec3  o = cross( c, f1 );\n    vec3  p = cross( d, g1 );\n    vec3  q = cross( e, h1 );\n    vec3  r = cross( f, i1 );\n\n    vec3  s = cross( m, n );\n    vec3  t = cross( n, o );\n    vec3  u = cross( o, p );\n    vec3  v = cross( p, q );\n    vec3  w = cross( q, r );\n    vec3  x = cross( r, m );\n\n    vec3  min = min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min( min", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return vec4(min(min(p0, p1), min(p2, p3)), max(max(p0, p1), max(p2, p3)), min(min(p01, p12), min(p23, p0123)), max(max(p01, p12), max(p23, p0123)));\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return vec4(min(min(p0, p1), min(p2, p3)), max(max(p0, p1), max(p2, p3)), min(min(p01, p12), min(p23, p0123)), max(max(p01, p12), max(p23, p0123)));\n}\n\n// Appro", "\n    vec2 a = p0 - p1;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p1;\n    vec2 d = p0 - 2.0 * p1 + p2;\n    vec2 e = p0 - 3.0 * p1 + 3.0 * p2 - p3;\n    vec2 f = p0 - p1;\n    vec2 g = p2 - p1;\n    vec2 h = p3 - p1;\n    vec2 i = p0 - 2.0 * p1 + p2;\n    vec2 j = p0 - 3.0 * p1 + 3.0 * p2 - p3;\n    vec2 k = p0 - 4.0 * p1 + 6.0 * p2 - 4.0 * p3 + p1;\n    vec2 l = p0 - 5.0 * p1 + 10.0 * p2 - 10.0 * p3 + 5.0 * p1;\n    vec2 m = p0 - 6.0 * p1 + 15.0 * p2 - 20.0 * p3 + 15.0 * p1;\n    vec2 n = p0 - 7.0 * p1 + 21.0 * p2 - 35.0 * p3 + 35.0 * p1;\n    vec2 o = p0 - 8.0 * p1 + 28.0 * p2 - 56.0 * p3 + 56.0 * p1;\n    vec2 p = p0 - 9.0 * p1 + 36.0 * p2 - 84.0 * p3 + 105.0 * p1;\n    vec2 q = p0 - 10.0 * p1 + 45.0 * p2 - 120.0 * p3 + 210.0 * p1;\n    vec2 r = p0 - 11.0 * p1 + 55.0 * p2 - 165.0 * p3 + 330", "\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 p = cross( rd, e1 );\n    float det = dot( e0, p );\n    if( det < 0.00001 ) return vec3( -1.0 );\n    float invDet = 1.0 / det;\n    vec3 t = ro - v0;\n    float u = dot( t, p ) * invDet;\n    if( u < 0.0 || u > 1.0 ) return vec3( -1.0 );\n    vec3 q = cross( t, e0 );\n    float v = dot( rd, q ) * invDet;\n    if( v < 0.0 || u + v > 1.0 ) return vec3( -1.0 );\n    float t0 = dot( e1, q ) * invDet;\n    return vec3( t0, u, v );\n}\n\n// Raymarching. Returns { t, id }\nvec2 raymarch( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor, in vec3 col )\n{\n    float t = 0.0;\n    for( int i = 0; i < 128; i++ )\n    {\n        vec3 p = ro + t * rd;\n        vec3 q = p - pos;\n        float d = length( q ) - 0.5;\n        if( d < 0.001 ) return vec2( t, 0.0 );\n        t += d;\n    }\n    return vec2( -1.0, 0.0 );\n}\n\n// Main. Returns { t, id }\nvec2 main( in vec3 ro, in vec3 rd )\n{\n    vec3 pos = vec3( 0.0, 0.0, 0.0 );\n    vec3 nor = vec3( 0.0, 0.0, 1.0 );\n    vec3 col = vec3( 1.0, 0.0, 0.0 );\n    vec3 v0 = vec3( -0.5,", "\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v1;\n    vec3 e2 = v0 - v2;\n\n    vec3 p = pos - v0;\n    vec3 q = pos - v1;\n    vec3 r = pos - v2;\n\n    vec3 n = cross( e0, e1 );\n    vec3 m = cross( e1, e2 );\n    vec3 l = cross( e2, e0 );\n\n    vec3 d = cross( nor, n );\n    vec3 e = cross( nor, m );\n    vec3 f = cross( nor, l );\n\n    float v = dot( d, p ) * dot( e, q ) * dot( f, r );\n    float w = dot( d, q ) * dot( e, r ) * dot( f, p );\n    float x = dot( d, r ) * dot( e, p ) * dot( f, q );\n\n    return clamp( ( v + w + x ) / ( v + w - x ), 0.0, 1.0 );\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 n0, in vec3 n1, in vec3 n2 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v1;\n    vec3 e2 = v0 - v2;\n\n    vec3 p = pos - v0;\n    vec3 q = pos - v1;\n    vec3 r = pos - v2;\n\n    vec3 n = cross( e0, e1 );\n    vec3 m = cross( e1, e2 );\n    vec3 l = cross( e2, e0 );\n\n    vec3 d = cross( nor, n );\n    vec3 e = cross( nor, m );\n    vec3 f = cross( nor, l );\n\n    float v = dot( d, p ) * dot( e, q ) * dot( f, r );\n    float w = dot(", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk*dot(d,a);\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float q = kx - 2.0*kz;\n    float disc = q*q + 4.0*p*kz;\n\n    if( disc > 0.0 )\n    {\n        float tmp = sqrt(disc);\n        float t0 = (-q + tmp)/2.0;\n        float t1 = (-q - tmp)/2.0;\n        float t = 0.0;\n        if( t0 > 0.0 )\n        {\n            t = t0;\n        }\n        else if( t1 > 0.0 )\n        {\n            t = t1;\n        }\n        vec2 T = a*t + b*t*t;\n        res = dot(T,d-A);\n    }\n    else\n    {\n        float tmp = sqrt(-p);\n        float u = tmp - kx;\n        res = dot(a,d-A) + u*dot(b,d-A) + u*u*dot(c,d-A);\n    }\n    return res;\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in float t )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);", "\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp(dot(k1-p,k2)/dot2(k2),0.0,1.0);\n    float s = (cb.x<0.0 && ca.y<0.0)? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c, float h, float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( length(c.xz), c.y );\n    float d1 = (q.x*abs(sin(c.y))+q.y*abs(cos(c.y)))-v.x*r1;\n    float d2 = q.y - v.y + h;\n    float d3 = abs(q.x*v.y-q.y*v.x) - v.x*r2;\n    return min(min(d1,d2),d3);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 a, in vec3 b, float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign( pa.y*ba.x-pa.x*ba.y );\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 a, in vec3 b, in float ra, float rb )\n{\n    vec3  ba = b - a;\n    float rba = rb - ra;\n    float baba = dot(ba,ba);\n    float paba = dot(ba,p-a);\n    float x = length(p-a);\n    float y = abs(paba)/sqrt(baba);\n    float z = x*x + y*y - rba*rba;\n    if( z>0.0 && y>rba ) return sqrt(z);\n    else return max(x*sin(ra),y)-ra;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 a, in vec3 b, in float ra, float rb, in float h )\n{\n    vec3  ba = b - a;\n    float rba = rb - ra;\n    float baba = dot(ba,ba);\n    float papa = dot(ba,p-a);\n    float paba = dot(ba,p-b);\n    float x = papa/baba;\n    float y = paba/baba;\n    float z = clamp( (x*x + y*y - 1.0)/rba, -1.0, 1.0 );\n    x = sqrt( 1.0 - z*z );\n    float k = dot(ba,p-a);\n    float ca = length(p-a) - x*ra;\n    float cb = (abs(k) - baba*h)/2.0 - x*rb;\n    float s = (cb > ca)? sign(k) : -sign(paba);\n    return max(ca,s*cb);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 a, in", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/warp/warp.htm\nvec3 calcNormal2( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal3( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/warp/warp.htm\nvec3 calcNormal4( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.", "\n    float res = 1.0;\n    for( float t=tmin; t<tmax; )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    for( float t=tmin; t<tmax; )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const float bias )\n{\n    float res = 1.0;\n    for( float t=tmin; t<tmax; )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += max( h, bias );\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const float bias, const float maxdist )\n{\n    float res = 1.0;\n    for( float t=tmin; t<tmax; )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.", "\n    return fract(sin(dot(q,ivec2(127,31)))*43758.5453);\n}\n\n// random noise\nfloat noise( in ivec2 p )\n{\n    ivec2 q = p >> 1;\n    float f = hash(p);\n    float f2 = hash(q);\n    return mix(f,f2,smoothstep(0.0,1.0,float(p.x&1)));\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    ivec2 q = p + ivec2(1,0);\n    ivec2 r = p + ivec2(0,1);\n    ivec2 s = p + ivec2(1,1);\n    float t = noise(p);\n    float u = noise(q);\n    float v = noise(r);\n    float w = noise(s);\n    return mix(mix(t,u,smoothstep(0.0,1.0,x.x-float(p.x))),\n               mix(v,w,smoothstep(0.0,1.0,x.x-float(p.x))),\n               smoothstep(0.0,1.0,x.y-float(p.y)));\n}\n\n// 2D noise\nfloat noise( in vec2 x, in float t )\n{\n    ivec2 p = ivec2(floor(x));\n    ivec2 q = p + ivec2(1,0);\n    ivec2 r = p + ivec2(0,1);\n    ivec2 s = p + ivec2(1,1);\n    float a = noise(p,t);\n    float b = noise(q,t);\n    float c = noise(r,t);\n    float d = noise(s,t);\n    return mix(mix(a,b,smoothstep(0.0,1.0,x.x-float(p.x))),\n               mix(c,d,smoothstep(0.0,1.0,x.x-float(p.", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0,p), hash(n+  1.0,p),f.x),\n                    mix( hash(n+ 57.0,p), hash(n+ 58.0,p),f.x),f.y);\n    return res;\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0,p), hash(n+  1.0,p),f.x),\n                        mix( hash(n+ 57.0,p), hash(n+ 58.0,p),f.x),f.y),\n                    mix(mix( hash(n+113.0,p), hash(n+114.0,p),f.x),\n                        mix( hash(n+170.0,p), hash(n+171.0,p),f.x),f.y),f.z);\n    return res;\n}\n\n// basic value noise\nfloat noise( in vec4 x, in int p )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z + 17.0*p.w;\n\n    float res = mix(mix(mix(mix( hash(n+  0.0,p), hash(n+  ", "\n    float f = 0.0;\n    float w = 1.0;\n    for( int i=0; i<p; i++ )\n    {\n        f += w*noise( x );\n        x *= 2.0;\n        w *= 0.5;\n    }\n    return f;\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 1D noise\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p + p;\n\n    return mix( hash(n+  0.0), hash(n+  1.0),f);\n}\n\n// 1D hash\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// 2D hash\nfloat hash( in vec2 p )\n{\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  float d1 = -q.y-c.z;\n  float d2 = max( dot(q,c.xy), q.y);\n  return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\n\n// https://www.shadertoy.com/view/XsXSzf\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n", "\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k = k0/r.x + k1/r.y;\n    float c = sqrt(k*k-k0*k0);\n    return k-c;\n}\n\n// symmetric ellipsoid - ITERATIVE distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k = k0/r.x + k1/r.y;\n    float c = sqrt(k*k-k0*k0);\n    return max(k-c,0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k = k0/r.x + k1/r.y;\n    float c = sqrt(k*k-k0*k0);\n    return k-c;\n}\n\n// symmetric ellipsoid - ITERATIVE distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k = k0/r.x + k1/r.y;\n    float c = sqrt(k*k-k0*k0);\n    return max(k-c,0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length(p.xz);\n    float k1 = p.y;\n    float k = k0/r.x + k1/r.y;\n    float c = sqrt(k*k-k0*k0);\n    return k-c;\n}\n\n// symmetric ellipsoid - ITERATIVE distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    float k0 = length", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0 - k1;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r ) \n{\n    float k0 = length(p/r.xyz);\n    float k1 = length(p/(r.xyz*r.xyz));\n    return k0 - k1;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, out vec3 n ) \n{\n    float k0 = length(p/r.xyz);\n    float k1 = length(p/(r.xyz*r.xyz));\n    n = p/k0;\n    return k0 - k1;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, out vec3 n, out float d ) \n{\n    float k0 = length(p/r.xyz);\n    float k1 = length(p/(r.xyz*r.xyz));\n    n = p/k0;\n    d = k0 - k1;\n    return d;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, out vec3 n, out float d, out float k0, out float k1 ) \n{\n    k0 = length(p/r.xyz);\n    k1 = length(p/(r.xyz*r.xyz));\n    n = p/k0;\n    d = k0 - k1;\n    return d;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, out vec3 n, out float d, out float k0, out float k1", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 q ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    q = p/k1;\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r ) \n{\n    float k0 = length(p/r.xyz);\n    float k1 = length(p/(r.xyz*r.xyz));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, out vec3 q ) \n{\n    float k0 = length(p/r.xyz);\n    float k1 = length(p/(r.xyz*r.xyz));\n    q = p/k1;\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float k, out vec3 q ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    q = p/k1;\n    return k0*(k0-k)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec4 r, in float k ) \n{\n    float k0 = length(p/r.", "\n    vec2 w = fwidth( p );\n    vec2 i = floor( p );\n    vec2 f = p - i;\n    vec2 u = fwidth( f );\n    vec2 du = fwidth( i );\n    vec2 df = f - 0.5 * u;\n    vec2 df2 = df * df;\n    vec2 df3 = df2 * df;\n    vec2 df4 = df3 * df;\n    vec2 df5 = df4 * df;\n    vec2 df6 = df5 * df;\n    vec2 df7 = df6 * df;\n    vec2 df8 = df7 * df;\n    vec2 df9 = df8 * df;\n    vec2 df10 = df9 * df;\n    vec2 df11 = df10 * df;\n    vec2 df12 = df11 * df;\n    vec2 df13 = df12 * df;\n    vec2 df14 = df13 * df;\n    vec2 df15 = df14 * df;\n    vec2 df16 = df15 * df;\n    vec2 df17 = df16 * df;\n    vec2 df18 = df17 * df;\n    vec2 df19 = df18 * df;\n    vec2 df20 = df19 * df;\n    vec2 df21 = df20 * df;\n    vec2 df22 = df21 * df;\n    vec2 df23 = df22 * df;\n    vec2 df24 = df23 * df;\n    vec2 df25 = df24 * df;\n    vec2 df26 = df25 * df;\n    vec2 df27 = df26 * df;\n    vec2 df28 = df27 * df;\n    vec2 df29 = df28 * df;\n    vec2 df30 = df29 * df;\n    vec2 df31 = df30 * df;\n    vec2 df32 = df31 * df;\n    vec2 df33 = df32 * df;\n    vec2 df34 = df33 * df;", "\n    return a * pow( 1.0 - x, 5.0 );\n}\n\n// Schlick's approximation to the Fresnel equation\nvec3 fresnel( vec3 f0, float cosTheta )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, 5.0 );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias\nvec3 fresnel( vec3 f0, float cosTheta, float bias )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, bias );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias and power\nvec3 fresnel( vec3 f0, float cosTheta, float bias, float power )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, bias * power );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias and power and bias\nvec3 fresnel( vec3 f0, float cosTheta, float bias, float power, float bias2 )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, bias * power + bias2 );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias and power and bias and power\nvec3 fresnel( vec3 f0, float cosTheta, float bias, float power, float bias2, float power2 )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, bias * power + bias2 * power2 );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias and power and bias and power and bias\nvec3 fresnel( vec3 f0, float cosTheta, float bias, float power, float bias2, float power2, float bias3 )\n{\n    return f0 + ( 1.0 - f0 ) * pow( 1.0 - cosTheta, bias * power + bias2 * power2 + bias3 );\n}\n\n// Schlick's approximation to the Fresnel equation, with bias", "\n    return 2.0 * (x - floor(0.5 + x));\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return 2.0 * abs(2.0 * (x - floor(0.5 + x)) - 1.0);\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return step(0.5, fract(x));\n}\n\n// biased pulse\nfloat my_pulse( float x, float p )\n{\n    return step(0.5, fract(x));\n}\n\n// biased random\nfloat my_rand( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased noise\nfloat my_noise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased white noise\nfloat my_wnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased pink noise\nfloat my_pnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased brown noise\nfloat my_bnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased pink noise\nfloat my_pnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased brown noise\nfloat my_bnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased pink noise\nfloat my_pnoise( float x, float p )\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// biased brown noise\nfloat my_bnoise( float", "\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float h2 = h * h;\n    float h3 = h2 * h;\n    float h4 = h3 * h;\n    float h5 = h4 * h;\n    float h6 = h5 * h;\n    float h7 = h6 * h;\n    float h8 = h7 * h;\n    float h9 = h8 * h;\n    float h10 = h9 * h;\n    float h11 = h10 * h;\n    float h12 = h11 * h;\n    float h13 = h12 * h;\n    float h14 = h13 * h;\n    float h15 = h14 * h;\n    float h16 = h15 * h;\n    float h17 = h16 * h;\n    float h18 = h17 * h;\n    float h19 = h18 * h;\n    float h20 = h19 * h;\n    float h21 = h20 * h;\n    float h22 = h21 * h;\n    float h23 = h22 * h;\n    float h24 = h23 * h;\n    float h25 = h24 * h;\n    float h26 = h25 * h;\n    float h27 = h26 * h;\n    float h28 = h27 * h;\n    float h29 = h28 * h;\n    float h30 = h29 * h;\n    float h31 = h30 * h;\n    float h32 = h31 * h;\n    float h33 = h32 * h;\n    float h34 = h33 * h;\n    float h35 = h34 * h;\n    float h36 = h35 * h;\n    float h37 = h36 * h;\n    float h38 = h37 * h;\n    float h39 = h38 * h;\n    float h40", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    vec3 ob = ro - pb;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float baob = dot(ba,ob);\n    float ococ = dot(oc,oc);\n    float ocoa = dot(oc,oa);\n    float rdoa = dot(rd,oa);\n    float rdbo = dot(rd,ob);\n    float rdor = dot(rd,rd);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*ocoa - baoa*rdoa - baba*r*r + ococ;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        h = -b - sqrt(h);\n        float t = h / a;\n        float y = rdoa + t*bard;\n        if( y>0.0 && y<baba ) return t;\n    }\n    return -1.0;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 )\n    {\n        h = -b - sqrt( h );\n        return h;\n    }\n    return -1.0;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float denom = dot( rd, pla.xyz );\n    if( denom>0.0 ) return -1.0;\n    return -( dot( ro, pla.xyz ) + pla.w ) / denom;\n}\n\nfloat iBox( in vec3 ro, in vec3 rd", "\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(ra,rb,h);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float m = dot(pa,ba)/dot(ba,ba);\n    float bb = length(ba);\n    float d = length(pa-ba*clamp(m, 0.0, 1.0)) - mix(ra,rb,m);\n    float y = abs(length(pa*clamp(m, 0.0, 1.0))-h);\n    float x = max(d,y);\n    return x;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float phi)\n{\n    // cone slope\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float m = dot(pa,ba)/dot(ba,ba);\n    // signed distance\n    float y = abs(length(pa*clamp(m, 0.0, 1.0))-h);\n    float d = length(pa-ba*clamp(m, 0.0, 1.0)) - mix(ra,rb,m);\n    float da = acos(clamp(dot(normalize(pa),normalize(ba)),-1.0,1.0));\n    if( pa.y > 0.0 ) da = 2.0*PI - da;\n    float x = length(pa) - (m*bb + h);\n    float e = 1.0e-3;\n    return max(x,max(d,y)) + min(0.0,da-phi);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float phi,", "\n    float t = 0.0;\n    float res = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = length( pos-a ) - r;\n        float h2 = length( pos-b ) - r;\n        res = min( res, h*h*h*h*h2*k );\n        t += max( 0.01, 0.1*t );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, h*h*h*h*k );\n        t += max( 0.01, 0.1*t );\n        if( h<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k, in float r )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, h*h*h*h*k );\n        res = min( res, capShadow( ro, rd, ro+rd*t, ro+rd*t+rd*r, r, k ) );\n        t += max( 0.01, 0.1*t );\n        if( h<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadow( in vec3 ro, in vec3", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float d = smoothstep(rad1, rad1 + th, r) - smoothstep(rad2, rad2 - th, r);\n    return vec2(d * cos(a), d * sin(a));\n}\n\n/**\n * uv: us-space to deform\n * rad: Radius of the arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad, float th)\n{\n    return snake(uv, rad, rad, th);\n}\n\n/**\n * uv: us-space to deform\n * rad: Radius of the arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad, float th, float a)\n{\n    float r = length(uv);\n    float d = smoothstep(rad, rad + th, r) - smoothstep(rad, rad - th, r);\n    return vec2(d * cos(a), d * sin(a));\n}\n\n/**\n * uv: us-space to deform\n * rad: Radius of the arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad, float th, float a, float b)\n{\n    float r = length(uv);\n    float d = smoothstep(rad, rad + th, r) - smoothstep(rad, rad - th, r);\n    return vec2(d * cos(a), d * sin(a)) + vec2(d * cos(b), d * sin(b));\n}\n\n/**\n * uv: us-space to deform\n * rad: Radius of the arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad, float th, float a, float b, float c)\n{\n    float r = length(uv);\n    float d = smoothstep(rad, rad + th, r) - smoothstep(rad, rad - th, r);\n    return vec2(d * cos(a), d * sin(a)) + vec2(d * cos(b), d * sin(b)) + vec2(d", "\n    p.x = abs(p.x);\n    vec2 q = vec2(c.x*p.x, c.y*p.y);\n    return length(q) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float thickness )\n{\n    p.x = abs(p.x);\n    vec2 q = vec2(c.x*p.x, c.y*p.y);\n    return length(q) - r + thickness;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float thickness, in float offset )\n{\n    p.x = abs(p.x);\n    vec2 q = vec2(c.x*p.x, c.y*p.y);\n    return length(q) - r + thickness + offset;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float thickness, in float offset, in float scale )\n{\n    p.x = abs(p.x);\n    vec2 q = vec2(c.x*p.x, c.y*p.y);\n    return length(q) - r + thickness + offset + scale;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float thickness, in float offset, in float scale, in float skew )\n{\n    p.x = abs(p.x);\n    vec2 q = vec2(c.x*p.x, c.y*p.y);\n    return length(q) - r + thickness + offset + scale + skew;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float thickness, in float offset, in float scale, in float skew, in float bias", "\n    vec3  n = vec3(4.0*pos.x*pos.x*pos.x,4.0*pos.y*pos.y*pos.y,4.0*pos.z*pos.z*pos.z);\n    return n;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra )\n{\n    vec3  n = vec3(4.0*pos.x*pos.x*pos.x,4.0*pos.y*pos.y*pos.y,4.0*pos.z*pos.z*pos.z);\n    return n;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb )\n{\n    vec3  n = vec3(4.0*pos.x*pos.x*pos.x,4.0*pos.y*pos.y*pos.y,4.0*pos.z*pos.z*pos.z);\n    return n;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb, in float rc )\n{\n    vec3  n = vec3(4.0*pos.x*pos.x*pos.x,4.0*pos.y*pos.y*pos.y,4.0*pos.z*pos.z*pos.z);\n    return n;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float rb, in float rc, in float rd )\n{", "\n    // transform to the coordinate system of the arc\n    p = p - sca*ra;\n    // project onto the x axis\n    float x = dot(p,sca);\n    // project onto the y axis\n    float y = dot(p,scb);\n    // distance to the arc\n    float l = length(p);\n    // distance to the arc\n    float d = sqrt(x*x + y*y);\n    // distance to the arc\n    float da = abs(d-ra);\n    // distance to the arc\n    float db = abs(d-rb);\n    // distance to the arc\n    float dc = abs(l-ra);\n    // distance to the arc\n    float dd = abs(l-rb);\n    // distance to the arc\n    float d1 = max(da,db);\n    // distance to the arc\n    float d2 = max(dc,dd);\n    // distance to the arc\n    return min(d1,d2);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra, in float rb )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra, in float rb, in float rc )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra, in float rb, in float rc, in float rd )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra, in float rb, in float rc, in float rd, in float re )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float ra, in float rb, in float rc, in float rd, in float re, in float rf )\n{\n    return length(p)-r;\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcHardshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles", "\n    float eps = 0.0001;\n    float d = sdf(pos, time);\n    vec3 n = vec3(\n        d - sdf(pos+vec3(eps,0.0,0.0), time),\n        d - sdf(pos+vec3(0.0,eps,0.0), time),\n        d - sdf(pos+vec3(0.0,0.0,eps), time)\n    );\n    return normalize(n);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = sdf( ro + rd*t, time );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    float eps = 0.0001;\n    float d = sdf(pos, time);\n    vec3 n = vec3(\n        d - sdf(pos+vec3(eps,0.0,0.0), time),\n        d - sdf(pos+vec3(0.0,eps,0.0), time),\n        d - sdf(pos+vec3(0.0,0.0,eps), time)\n    );\n    return normalize(n);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcHardshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps", "\n    vec2 w = fwidth( p );\n    vec2 s = -dpdx * (step( vec2(0.5), w) - 0.5)\n            -dpdy * (step( vec2(0.5), w) - 0.5);\n    return smoothstep( -w.x, w.x, p.x + s.x ) * smoothstep( -w.y, w.y, p.y + s.y );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale )\n{\n    vec2 w = fwidth( p * scale );\n    vec2 s = -dpdx * (step( vec2(0.5), w) - 0.5)\n            -dpdy * (step( vec2(0.5), w) - 0.5);\n    return smoothstep( -w.x, w.x, p.x * scale + s.x ) * smoothstep( -w.y, w.y, p.y * scale + s.y );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale, in float offset )\n{\n    vec2 w = fwidth( p * scale );\n    vec2 s = -dpdx * (step( vec2(0.5), w) - 0.5)\n            -dpdy * (step( vec2(0.5), w) - 0.5);\n    return smoothstep( -w.x, w.x, p.x * scale + s.x + offset ) * smoothstep( -w.y, w.y, p.y * scale + s.y + offset );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale, in float offset, in float threshold )\n{\n    vec2 w = fwidth( p * scale );\n    vec2 s = -dpdx * (step( vec2(0.5), w) - 0.5)\n            -dpdy * (step( vec2(0.5), w) - 0.5", "\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<", "\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 light_dir_reflect = reflect(light_dir_norm, surface_normal);\n    vec3 light_dir_reflect_norm = normalize(light_dir_reflect);\n    vec3 light_dir_reflect_sample = sample_pos + light_dir_reflect_norm * 0.001;\n    vec3 light_dir_reflect_col = texture(iChannel0, light_dir_reflect_sample).rgb;\n    vec3 light_dir_reflect_col_norm = normalize(light_dir_reflect_col);\n    vec3 light_dir_reflect_col_norm_scaled = light_dir_reflect_col_norm * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled = light_dir_reflect_col_norm_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled = light_dir_reflect_col_norm_scaled_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled_scaled = light_dir_reflect_col_norm_scaled_scaled_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled = light_dir_reflect_col_norm_scaled_scaled_scaled_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled_scaled = light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled_scaled_scaled = light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled_scaled * 0.5 + 0.5;\n    vec3 light_dir_reflect_col_norm_scaled_scaled_scaled_scaled_scaled_scaled_scaled_scaled = light_dir_reflect", "\n    vec3 color = vec3(0.0);\n    float depth = 0.0;\n\n    // render a green sphere\n    float sphere_dist = length(pos - vec3(0.0, 0.0, 0.0)) - 0.5;\n    if (sphere_dist < 0.0) {\n        color = vec3(0.0, 1.0, 0.0);\n        depth = -sphere_dist;\n    }\n\n    return vec4(color, depth);\n}\n\n/*\nThe following function returns the color of the atmosphere\n\nin this case, the function renders a blue sphere on the place where the planet should be\ncolor is in.xyz, distance in.w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_atmosphere(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0);\n    float depth = 0.0;\n\n    // render a blue sphere\n    float sphere_dist = length(pos - vec3(0.0, 0.0, 0.0)) - 0.5;\n    if (sphere_dist < 0.0) {\n        color = vec3(0.0, 0.0, 1.0);\n        depth = -sphere_dist;\n    }\n\n    return vec4(color, depth);\n}\n\n/*\nThe following function returns the color of the planet\n\nin this case, the function renders a red sphere on the place where the planet should be\ncolor is in.xyz, distance in.w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_planet(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0);\n    float depth = 0.0;\n\n    // render a red sphere\n    float sphere_dist = length(pos - vec3(0.0, 0.0, 0.0)) - 0.5;\n    if (sphere_dist < 0.0)", "\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0));\n}\n\n/*\nthis function calculates the color of the pixel at coord\n*/\nvec3 get_pixel_color(vec2 coord) {\n    vec3 camera_vector = get_camera_vector(iResolution, coord);\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 100; i++) {\n        color += get_color(camera_vector, i);\n    }\n    return color / 100.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = fragCoord;\n    vec3 color = get_pixel_color(coord);\n    fragColor = vec4(color, 1.0);\n}\n", "\n    float l = length(p.xz);\n    float d = l - ra;\n    float m = length(p.xz - c*clamp(l,0.0,ra));\n    return max(d,m*c.y-c.x);\n}\n\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    return length(p.xz)-h.x;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone(vec3 p, vec2 c, float ra, float rb)\n{\n    float l = length(p.xz);\n    float m = max(l-min(l,ra),0.0);\n    return dot(vec2(l,p.y),vec2(c.x,c.y)) +\n           sqrt(m*m+p.y*p.y-m*c.y*c.y)-rb;\n}\n\nfloat", "\n    switch (material) {\n        case 0:\n            return vec3(0.0, 0.0, 0.0);\n        case 1:\n            return vec3(0.0, 0.0, 0.0);\n        case 2:\n            return vec3(0.0, 0.0, 0.0);\n        case 3:\n            return vec3(0.0, 0.0, 0.0);\n        case 4:\n            return vec3(0.0, 0.0, 0.0);\n        case 5:\n            return vec3(0.0, 0.0, 0.0);\n        case 6:\n            return vec3(0.0, 0.0, 0.0);\n        case 7:\n            return vec3(0.0, 0.0, 0.0);\n        case 8:\n            return vec3(0.0, 0.0, 0.0);\n        case 9:\n            return vec3(0.0, 0.0, 0.0);\n        case 10:\n            return vec3(0.0, 0.0, 0.0);\n        case 11:\n            return vec3(0.0, 0.0, 0.0);\n        case 12:\n            return vec3(0.0, 0.0, 0.0);\n        case 13:\n            return vec3(0.0, 0.0, 0.0);\n        case 14:\n            return vec3(0.0, 0.0, 0.0);\n        case 15:\n            return vec3(0.0, 0.0, 0.0);\n        case 16:\n            return vec3(0.0, 0.0, 0.0);\n        case 17:\n            return vec3(0.0, 0.0, 0.0);\n        case 18:\n            return vec3(0.0, 0.0, 0.0);\n       ", "\n    switch (material) {\n        case MATERIAL_DIAMOND:\n            return 0.1;\n        case MATERIAL_GOLD:\n            return 0.1;\n        case MATERIAL_IRON:\n            return 0.1;\n        case MATERIAL_LEAD:\n            return 0.1;\n        case MATERIAL_SILVER:\n            return 0.1;\n        case MATERIAL_STEEL:\n            return 0.1;\n        case MATERIAL_WOOD:\n            return 0.1;\n        case MATERIAL_GLASS:\n            return 0.1;\n        case MATERIAL_PLASTIC:\n            return 0.1;\n        case MATERIAL_METAL:\n            return 0.1;\n        case MATERIAL_METAL_GOLD:\n            return 0.1;\n        case MATERIAL_METAL_SILVER:\n            return 0.1;\n        case MATERIAL_METAL_STEEL:\n            return 0.1;\n        case MATERIAL_METAL_IRON:\n            return 0.1;\n        case MATERIAL_METAL_LEAD:\n            return 0.1;\n        case MATERIAL_METAL_GLASS:\n            return 0.1;\n        case MATERIAL_METAL_PLASTIC:\n            return 0.1;\n        case MATERIAL_METAL_WOOD:\n            return 0.1;\n        case MATERIAL_METAL_DIAMOND:\n            return 0.1;\n        case MATERIAL_METAL_GOLD_GLASS:\n            return 0.1;\n        case MATERIAL_METAL_GOLD_PLASTIC:\n            return 0.1;\n        case MATERIAL_METAL_GOLD_WOOD:\n            return 0.1;\n        case MATERIAL_METAL_GOLD_DIAMOND:\n            return 0.1;\n        case MATERIAL_METAL_SILVER_GLASS:\n            return 0.1;\n        case MATERIAL_METAL_SILVER_PLASTIC:\n            return 0.1;\n        case MATERIAL_METAL_SILVER", "\n    switch (material) {\n        case MATERIAL_AIR:\n            return 1.0;\n        case MATERIAL_GLASS:\n            return 1.5;\n        case MATERIAL_WATER:\n            return 1.333;\n        case MATERIAL_ICE:\n            return 1.309;\n        case MATERIAL_DIAMOND:\n            return 2.417;\n        case MATERIAL_GOLD:\n            return 0.999;\n        case MATERIAL_SILVER:\n            return 0.962;\n        case MATERIAL_PLASTIC:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_2:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_3:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_4:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_5:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_6:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_7:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_8:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_9:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_10:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_11:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_12:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_13:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_14:\n            return 1.5;\n        case MATERIAL_PLASTIC_GLASS_15:\n            return 1.5;\n        case MATERIAL_PLASTIC_", "\n    switch (material) {\n        case MATERIAL_AIR:\n            return 0.0;\n        case MATERIAL_WATER:\n            return 0.5;\n        case MATERIAL_STONE:\n            return 1.0;\n        case MATERIAL_DIRT:\n            return 1.0;\n        case MATERIAL_GRASS:\n            return 1.0;\n        case MATERIAL_SAND:\n            return 1.0;\n        case MATERIAL_WOOD:\n            return 1.0;\n        case MATERIAL_LEAVES:\n            return 1.0;\n        case MATERIAL_GLASS:\n            return 0.5;\n        case MATERIAL_ICE:\n            return 0.5;\n        case MATERIAL_SNOW:\n            return 0.5;\n        case MATERIAL_CLAY:\n            return 1.0;\n        case MATERIAL_SANDSTONE:\n            return 1.0;\n        case MATERIAL_GOLD:\n            return 1.0;\n        case MATERIAL_IRON:\n            return 1.0;\n        case MATERIAL_COAL:\n            return 1.0;\n        case MATERIAL_DIAMOND:\n            return 1.0;\n        case MATERIAL_LAPIS:\n            return 1.0;\n        case MATERIAL_REDSTONE:\n            return 1.0;\n        case MATERIAL_GLOWSTONE:\n            return 1.0;\n        case MATERIAL_QUARTZ:\n            return 1.0;\n        case MATERIAL_NETHERRACK:\n            return 1.0;\n        case MATERIAL_NETHERBRICK:\n            return 1.0;\n        case MATERIAL_NETHERSTONE:\n            return 1.0;\n        case MATERIAL_ENDSTONE:\n            return 1.0;\n        case MATERIAL_ENDSTONE_BRICK:\n            return 1.0;\n        case MATERIAL_ENDSTONE_STONE:\n            return 1.0;\n        case MATERIAL_ENDSTONE_BRICK_MOSSY:\n            return 1.0;", "\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 e3 = line_b - line_a;\n    vec3 e4 = line_a - tri_a;\n\n    float det = dot(e1, cross(e3, e2));\n    if (det == 0.0) {\n        return vec3(0.0);\n    }\n\n    float u = dot(cross(e3, e4), e2) / det;\n    float v = dot(cross(e1, e4), e3) / det;\n\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, out float u, out float v) {\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 e3 = line_b - line_a;\n    vec3 e4 = line_a - tri_a;\n\n    float det = dot(e1, cross(e3, e2));\n    if (det == 0.0) {\n        u = 0.0;\n        v = 0.0;\n        return vec3(0.0);\n    }\n\n    u = dot(cross(e3, e4), e2) / det;\n    v = dot(cross(e1, e4), e3) / det;\n\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a", "\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle", "\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    return mat4(\n        2.0 / (right - left), 0.0, 0.0, -(right + left) / (right - left),\n        0.0, 2.0 / (top - bottom), 0.0, -(top + bottom) / (top - bottom),\n        0.0, 0.0, -2.0 / (far - near), -(far + near) / (far - near),\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(fov / 2.0);\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) / (near - far), (2.0 * far * near) / (near - far),\n        0.0, 0.0, -1.0, 0.0\n    );\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = 1e10;\n    result.position = vec3(0, 0, 0);\n    result.normal = vec3(0, 0, 0);\n    result.color = vec3(0, 0, 0);\n    result.specular = 0;\n    result.reflectivity = 0;\n    result.refraction = 0;\n    result.refraction_index = 0;\n\n    for (int i = 0; i < triangles.size(); i++) {\n        vec3 p0 = triangles[i].p0;\n        vec3 p1 = triangles[i].p1;\n        vec3 p2 = triangles[i].p2;\n        vec3 n = triangles[i].n;\n        vec3 c = triangles[i].c;\n        float s = triangles[i].s;\n        float r = triangles[i].r;\n        float ri = triangles[i].ri;\n        float ref = triangles[i].ref;\n\n        vec3 e1 = p1 - p0;\n        vec3 e2 = p2 - p0;\n        vec3 s = ray_origin - p0;\n        vec3 s1 = cross(ray_target - ray_origin, e2);\n        vec3 s2 = cross(s, e1);\n\n        float d = dot(s1, e1);\n        if (d == 0) {\n            continue;\n        }\n\n        float t = dot(s2, e2) / d;\n        float u = dot(s1, s) / d;\n        float v = dot(s2, ray_target - ray_origin) / d;\n\n        if (t > 0 && u >= 0 && v >= 0 && u + v <= 1) {\n            if (t < result.distance) {\n                result.hit = true;\n                result.distance = t;\n                result.position = ray_origin + t * (ray_target - ray_origin);\n                result.normal = n;\n                result.color = c;\n                result.specular = s;\n", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float ray_length = length(ray_target - ray_origin);\n\n    float shadow_factor = 1.0;\n    float shadow_distance = 0.0;\n    float shadow_step = 0.01;\n    float shadow_max_distance = 100.0;\n\n    for (float i = 0.0; i < shadow_max_distance; i += shadow_step) {\n        vec3 shadow_position = ray_origin + ray_direction * i;\n        vec3 shadow_normal = get_normal(shadow_position);\n        float shadow_distance_to_light = length(shadow_position - light_position);\n\n        if (shadow_distance_to_light > shadow_max_distance) {\n            break;\n        }\n\n        if (shadow_distance_to_light > shadow_distance) {\n            shadow_distance = shadow_distance_to_light;\n        }\n\n        if (shadow_distance_to_light > ray_length) {\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step) {\n            shadow_factor = 0.0;\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step * 2.0) {\n            shadow_factor = 0.5;\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step * 4.0) {\n            shadow_factor = 0.25;\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step * 8.0) {\n            shadow_factor = 0.125;\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step * 16.0) {\n            shadow_factor = 0.0625;\n            break;\n        }\n\n        if (shadow_distance_to_light < shadow_step * 32.0) {\n            shadow_factor = 0.03125;\n            break;\n        }", "\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix( rand(p), rand(p+1.0), f );\n    return res;\n}\n\n// 2D noise\nfloat bnoise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix( mix( rand(p), rand(p+vec2(1.0,0.0)), f.x), mix( rand(p+vec2(0.0,1.0)), rand(p+vec2(1.0,1.0)), f.x), f.y);\n    return res;\n}\n\n// 3D noise\nfloat bnoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix( mix( mix( rand(p), rand(p+vec3(1.0,0.0,0.0)), f.x), mix( rand(p+vec3(0.0,1.0,0.0)), rand(p+vec3(1.0,1.0,0.0)), f.x), f.y), mix( mix( rand(p+vec3(0.0,0.0,1.0)), rand(p+vec3(1.0,0.0,1.0)), f.x), mix( rand(p+vec3(0.0,1.0,1.0)), rand(p+vec3(1.0,1.0,1.0)), f.x), f.y), f.z);\n    return res;\n}\n\n// 4D noise\nfloat bnoise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f*f*(3.0-2.0*f);\n    return mix( rand(i), rand(i+1.0), u );\n}\n\n// 1D gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// 2D gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( rand( i + vec3(0.0,0.0,0.0) ), \n                          rand( i + vec3(1.0,0.0,0.0) ), u.x),\n                     mix( rand( i + vec3(0.0,1.0,0.0) ), \n                          rand( i + vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( rand( i + vec3(0.0,0.0,1.0) ), \n                          rand( i + vec3(1.0,0.0,1.0) ), u.x),\n                     mix( rand( i + vec3(0.0,1.0,1.0) ), \n                          rand( i + vec3(1.0,1.0,1.0) ), u.x), u.y), u.z);\n}\n\n// 3D gradient noise\nfloat gnoise( in", "\n    n = (n << 13) ^ n;\n    return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    n = (n * 125692.0) + 135762.0;\n    n = (n * n) * 191.0;\n    return fract( n );\n}\n\n// 2D float hash copied from Hugo Elias\nfloat hash( vec2 p ) \n{\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 3D float hash copied from Hugo Elias\nfloat hash( vec3 p ) \n{\n    p  = fract( p *.1031 );\n    p += dot( p, p.yxz + 33.33 );\n    return fract( (p.x + p.y) * p.z );\n}\n\n// 2D integer hash copied from Hugo Elias\nint hash( vec2 p ) \n{\n    int n = int(p.x + p.y * 57.0);\n    n = (n << 13) ^ n;\n    return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n}\n\n// 3D integer hash copied from Hugo Elias\nint hash( vec3 p ) \n{\n    int n = int(p.x + p.y * 57.0 + p.z * 113.0", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f*f*(3.0-2.0*f);\n    return mix( hash( i ), hash( i + 1.0 ), u );\n}\n\n// 2D gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// 3D gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( hash( i + vec3(0.0,0.0,0.0) ), hash( i + vec3(1.0,0.0,0.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,0.0) ), hash( i + vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( hash( i + vec3(0.0,0.0,1.0) ), hash( i + vec3(1.0,0.0,1.0) ), u.x),\n                     mix( hash( i + vec3(0.0,1.0,1.0) ), hash( i + vec3(1.0,1.0,1.0) ), u.x), u.y), u.z);\n}\n\n// 4D gradient noise\nfloat gnoise( in vec4 p )\n{\n    vec4 i = floor( p );\n", "\n    float f = 0.0;\n    float w = 1.0;\n    float a = 1.0;\n    float b = 0.5;\n\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( x );\n        x = b * x + G;\n        a *= 0.5;\n        w += a;\n    }\n    return f/w;\n}\n\n// fbm\nfloat fbm( in vec2 p, in float G )\n{\n    float f = 0.0;\n    float w = 1.0;\n    float a = 1.0;\n    float b = 0.5;\n\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p );\n        p = b * p + G;\n        a *= 0.5;\n        w += a;\n    }\n    return f/w;\n}\n\n// fbm\nfloat fbm( in vec3 p, in float G )\n{\n    float f = 0.0;\n    float w = 1.0;\n    float a = 1.0;\n    float b = 0.5;\n\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p );\n        p = b * p + G;\n        a *= 0.5;\n        w += a;\n    }\n    return f/w;\n}\n\n// fbm\nfloat fbm( in vec4 p, in float G )\n{\n    float f = 0.0;\n    float w = 1.0;\n    float a = 1.0;\n    float b = 0.5;\n\n    for( int i=0; i<5; i++ )\n    {\n        f += a * noise( p );\n        p = b * p + G;\n        a *= 0.5;\n        w += a;\n    }\n    return f/w;\n}\n\n// fbm\nfloat fbm( in vec2 p, in float G, in float", "\n    vec3 c = vec3(0.0);\n    float d = 0.0;\n    float t = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float h = 0.0;\n    float s2 = 0.0;\n    float v = 0.0;\n    float h2 = 0.0;\n    float s3 = 0.0;\n    float v2 = 0.0;\n    float h3 = 0.0;\n    float s4 = 0.0;\n    float v3 = 0.0;\n    float h4 = 0.0;\n    float s5 = 0.0;\n    float v4 = 0.0;\n    float h5 = 0.0;\n    float s6 = 0.0;\n    float v5 = 0.0;\n    float h6 = 0.0;\n    float s7 = 0.0;\n    float v6 = 0.0;\n    float h7 = 0.0;\n    float s8 = 0.0;\n    float v7 = 0.0;\n    float h8 = 0.0;\n    float s9 = 0.0;\n    float v8 = 0.0;\n    float h9 = 0.0;\n    float s10 = 0.0;\n    float v9 = 0.0;\n    float h10 = 0.0;\n    float s11 = 0.0;\n    float v10 = 0.0;\n    float h11 = 0.0;\n    float s12 = 0.0;\n    float v11 = 0.0;\n    float h12 = 0.0;\n    float s13 = 0.0;\n    float v12 = 0.0;\n    float h13 = 0.0;\n    float s14 = 0.0;\n", "\n    vec3 p = pb*0.5 + 0.5;\n    vec3 c = vec3(0.0);\n    float a = 0.0;\n    float b = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float w", "\n    vec3 m = ro - cen;\n    vec3 n = m / rd;\n    vec3 k = abs(n);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec4(-1.0); // no intersection\n    return vec4(tN, tF, -sign(t1.x*t2.x)*sign(t1.y*t2.y)*sign(t1.z*t2.z), 0.0);\n}\n\nvec4 boxUnion( in vec4 d1, in vec4 d2 ) \n{\n    return (d1.x < d2.x)? d1 : d2;\n}\n\nvec4 boxSubtract( in vec4 d1, in vec4 d2 ) \n{\n    return (d2.x < 0.0)? d1 : d2;\n}\n\nvec4 boxOp( in vec3 ro, in vec3 rd, in vec4 box0, in vec4 box1, in int op ) \n{\n    vec4 d1 = box0;\n    vec4 d2 = box1;\n    if( op == 1 ) d1 = boxUnion(d1, d2);\n    if( op == 2 ) d1 = boxSubtract(d1, d2);\n    if( op == 3 ) d2 = boxSubtract(d2, d1);\n    if( op == 4 ) d1 = boxUnion(d1, d2);\n    if( op == 5 ) d2 = boxUnion(d2, d1);\n    return boxOp( ro, rd, d1, d2, 0 );\n}\n\nvec4 boxOp( in vec3 ro, in vec3 rd, in vec4 box0, in vec4 box1, in int op, in int op2 ) \n{\n    vec4 d1 =", "\n    vec3 m = ro - cen;\n    vec3 b = m - rad;\n    vec3 t = m + rad;\n    vec3 s = sign(rd);\n    vec3 r = 1.0 - s*(t-b);\n    float l = max(r.x,max(r.y,r.z));\n    float h = max(r.x,max(r.y,r.z));\n    float d = (h<0.0)? -l : l;\n    return d;\n}\n\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 m = ro - cen;\n    vec3 b = m - rad;\n    vec3 t = m + rad;\n    vec3 s = sign(rd);\n    vec3 r = 1.0 - s*(t-b);\n    float l = max(r.x,max(r.y,r.z));\n    float h = max(r.x,max(r.y,r.z));\n    float d = (h<0.0)? -l : l;\n    return d;\n}\n\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float k ) \n{\n    vec3 m = ro - cen;\n    vec3 b = m - rad;\n    vec3 t = m + rad;\n    vec3 s = sign(rd);\n    vec3 r = 1.0 - s*(t-b);\n    float l = max(r.x,max(r.y,r.z));\n    float h = max(r.x,max(r.y,r.z));\n    float d = (h<0.0)? -l : l;\n    return d;\n}\n\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float k ) \n{\n    vec3 m = ro - cen;\n    vec3 b = m - rad;\n    vec3 t = m + rad;\n    vec3 s = sign(rd);\n    vec3 r = ", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, h / t);\n        t += h;\n        if (t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float bias)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, h / t);\n        t += h;\n        if (t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);", " seed = fmod(seed * 19370817.0, 2147483647.0); return seed / 2147483647.0; }\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float res = 1.0;\n    for (int i = 0; i < 16; i++) {\n        float t = mint + rand() * (maxt - mint);\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if (h < 0.001 * t)\n            return 0.0;\n        res = min(res, 8.0 * h / t);\n        mint = t;\n    }\n    return res;\n}\n\n// raymarching\nfloat map(vec3 p) {\n    float d = 1e10;\n    for (int i = 0; i < 16; i++) {\n        vec3 q = p - vec3(0.5, 0.5, 0.5);\n        q.xz *= rot(0.5);\n        q.xy *= rot(0.5);\n        q.yz *= rot(0.5);\n        q += vec3(0.5, 0.5, 0.5);\n        d = min(d, length(q) - 0.5);\n    }\n    return d;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(p.x, p.y, -1.0));\n    float t = 0.0;\n    for (int i = 0; i < 64; i++) {\n        float h = map(ro + t * rd);\n        if", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Hash Function\n//https://www.shadertoy.com/view/ll2GD3\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n//Inigo Quilez's Hash Function\n//https://www.shadertoy.com/view/ll2GD3\nfloat hash( vec2 p )\n{\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453);\n}\n\n//Inigo Quilez's Hash Function\n//https://www.shadertoy.com/view/ll2GD3\nfloat hash( vec3 p )\n{\n    float h = dot(p,vec3(70.1,151.7,212.2));\t\n    return fract(sin(h)*43758.5453);\n}\n\n//Inigo Quilez's Hash Function\n//https://www.shadertoy.com/view/ll2GD3\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}", "\n    p.xz=abs(p.xz);\n    vec3 q=vec3(la*p.x,h*p.y,lb*p.z);\n    float k=max(q.x,q.y);\n    float d=max(q.z-k,0.0);\n    d=max(d,q.x+q.y-k-ra);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb)\n{\n    p.xz=abs(p.xz);\n    vec3 q=vec3(la*p.x,h*p.y,lb*p.z);\n    float k=max(q.x,q.y);\n    float d=max(q.z-k,0.0);\n    d=max(d,q.x+q.y-k-ra);\n    d=max(d,max(q.x,q.z)-rb);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb, float rc)\n{\n    p.xz=abs(p.xz);\n    vec3 q=vec3(la*p.x,h*p.y,lb*p.z);\n    float k=max(q.x,q.y);\n    float d=max(q.z-k,0.0);\n    d=max(d,q.x+q.y-k-ra);\n    d=max(d,max(q.x,q.z)-rb);\n    d=max(d,max(q.y,q.z)-rc);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb, float rc, float rd)\n{\n    p.xz=abs(p.xz);\n   ", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 d = pa - ba*h;\n    float x = length(d);\n    float y = x - r;\n    float z = abs(y) - band;\n    float w = x;\n    return vec4(x,y,z,w);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r ) \n{\n    return paSegment(p,a,b,r,0.0);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b ) \n{\n    return paSegment(p,a,b,0.0);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float band2 ) \n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 d = pa - ba*h;\n    float x = length(d);\n    float y = x - r;\n    float z = abs(y) - band;\n    float w = x;\n    float z2 = abs(y) - band2;\n    return vec4(x,y,z,w);\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float band2, float band3 ) \n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 d = pa - ba*h;\n    float x = length(d);\n    float y = x - r;\n    float z = abs(y) - band;\n    float w = x;\n    float z2 = abs(y) - band2;\n", "\n    vec2 d = abs(p) - b;\n    float x = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    float y = length(d) - r;\n    float z = max(x,y);\n    float w = s - x;\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec3 p, \n            in vec3 b, in float r, \n            in float s )\n{\n    vec3 d = abs(p) - b;\n    float x = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n    float y = length(d) - r;\n    float z = max(x,y);\n    float w = s - x;\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec4 p, \n            in vec4 b, in float r, \n            in float s )\n{\n    vec4 d = abs(p) - b;\n    float x = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n    float y = length(d) - r;\n    float z = max(x,y);\n    float w = s - x;\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 d = abs(p) - b;\n    float x = length(max(d,0.0)) + min(max", "\n    vec2 q = abs(p)-b;\n    return vec3(length(max(q,0.0)) + min(max(q.x,q.y),0.0), q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs(p)-b;\n    return vec3(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b, out vec3 n )\n{\n    vec3 q = abs(p)-b;\n    n = -sign(q);\n    return vec3(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b, out vec3 n, out vec3 g )\n{\n    vec3 q = abs(p)-b;\n    n = -sign(q);\n    g = -n;\n    return vec3(length(max(q,0.0)) + min(max(q.x,", "\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d = length(q-r);\n    return vec4(d,q.x,q.y,d);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float d ) \n{\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d2 = length(q-r);\n    return vec4(d2,q.x,q.y,d2);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float d, float d2 ) \n{\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d3 = length(q-r);\n    return vec4(d3,q.x,q.y,d3);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float d, float d2, float d3 ) \n{\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d4 = length(q-r);\n    return vec4(d4,q.x,q.y,d4);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float d, float d2, float d3, float d4 ) \n{\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d5 = length(q-r);\n    return vec4(d5,q.x,q.y,d5);\n}\n\nvec4 paCircle( in vec2 p, float r, float band, float d, float d2, float d3, float d4, float d5 ) \n{\n    vec2  q = vec2(length(p),atan(p.y,p.x));\n    float d6 = length(q-r);\n    return vec4(d6,q.x,q.y,d6);\n}\n\nvec4 paCircle(", "\n    vec2 q = p;\n    float d = dot(p,p);\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i] - p;\n        float l = dot(v,v);\n        if( l<d )\n        {\n            d = l;\n            q = v;\n        }\n    }\n    return sqrt(d) - r;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h ) \n{\n    vec2 q = p;\n    float d = dot(p,p);\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i] - p;\n        float l = dot(v,v);\n        if( l<d )\n        {\n            d = l;\n            q = v;\n        }\n    }\n    return sqrt(d) - r - h*abs(dot(q,vec2(0.0,1.0)));\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h, in float w ) \n{\n    vec2 q = p;\n    float d = dot(p,p);\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i] - p;\n        float l = dot(v,v);\n        if( l<d )\n        {\n            d = l;\n            q = v;\n        }\n    }\n    return sqrt(d) - r - h*abs(dot(q,vec2(0.0,1.0))) - w*abs(dot(q,vec2(1.0,0.0)));\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h, in float w, in float d ) \n{\n    vec2 q = p;\n    float d2 = dot(p,p);\n    for( int i=0; i<5; i++ )\n    {\n        vec2", "\n    vec4 res = vec4( 0.0 );\n    float d = 1e10;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i] - p;\n        float l = length( v );\n        float m = max( l-r, 0.0 );\n        float n = max( l-r-band, 0.0 );\n        float f = n/m;\n        d = min( d, m*f );\n        res.x += m;\n        res.y += m*f;\n        res.z += m*f*f;\n    }\n    res.w = d;\n    return res;\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5], float r ) \n{\n    return paPoly( p, verts, r, 0.0 );\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5] ) \n{\n    return paPoly( p, verts, 0.0 );\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band, float w ) \n{\n    vec4 res = vec4( 0.0 );\n    float d = 1e10;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 v = verts[i] - p;\n        float l = length( v );\n        float m = max( l-r, 0.0 );\n        float n = max( l-r-band, 0.0 );\n        float f = n/m;\n        d = min( d, m*f );\n        res.x += m;\n        res.y += m*f;\n        res.z += m*f*f;\n    }\n    res.w = d;\n    return res;\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band, float w, float ww ) \n{\n    vec4 res = vec4( 0.0 );\n    float d = ", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length( pa-ba*h ), ba.x, ba.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    return vec3( length(p-c)-r, p.x-c.x, p.y-c.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    return vec3( length(p-c)/r, (p.x-c.x)/r.x, (p.y-c.y)/r.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRectangle( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 d = abs(p-c)-r;\n    return vec3( length(max(d,0.0)), sign(d.x)*step(0.0,d.x), sign(d.y)*step(0.0,d.y) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = ", "\n    const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    vec2 q = abs(p - vec2(clamp(p.x, -k.z*r, k.z*r), r));\n    float d = length(max(q - k.yx*r, 0.0)) - r;\n    return vec3(d, q.x - r, q.y - r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgOctogon( in vec2 p, in float r ) \n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n    vec2 q = abs(p - vec2(clamp(p.x, -k.z*r, k.z*r), r));\n    float d = length(max(q - k.yx*r, 0.0)) - r;\n    return vec3(d, q.x - r, q.y - r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgStar( in vec2 p, in float r, in float n ) \n{\n    const vec3 k = vec3(-", "\n  vec3 n = X * p;\n  float l = length(n);\n  if (l < 1e-4) return false;\n  tan1 = normalize(n / l);\n  tan2 = normalize(cross(n, vec3(0, 0, 1)));\n  return true;\n}\n\n// Return the point on the conic X closest to p.\nvec3 closest(vec3 p, mat3 X) {\n  vec3 n = X * p;\n  float l = length(n);\n  return n / l;\n}\n\n// Return the point on the conic X closest to p, and the two tangents.\n// Return false if no tangents (eg. inside an ellipse).\nbool closest(vec3 p, mat3 X, out vec3 q, out vec3 tan1, out vec3 tan2) {\n  q = closest(p, X);\n  return tangents(q, X, tan1, tan2);\n}\n\n// Return the point on the conic X closest to p, and the two tangents.\n// Return false if no tangents (eg. inside an ellipse).\nbool closest(vec3 p, mat3 X, out vec3 q, out vec3 tan1, out vec3 tan2, out float d) {\n  q = closest(p, X);\n  d = length(p - q);\n  return tangents(q, X, tan1, tan2);\n}\n\n// Return the point on the conic X closest to p, and the two tangents.\n// Return false if no tangents (eg. inside an ellipse).\nbool closest(vec3 p, mat3 X, out vec3 q, out vec3 tan1, out vec3 tan2, out float d, out float l) {\n  q = closest(p, X);\n  d = length(p - q);\n  l = length(X * q);\n  return tangents(q, X, tan1, tan2);\n}\n\n// Return the point on the conic X closest to p, and the two tangents.\n// Return false if no tangents (eg. inside an ellipse).\nbool closest(vec3 p, mat3 X, out vec3 q, out vec3 tan", "\n    return a / (b + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 r)\n{\n    return RotateZ(RotateX(RotateY(p, r.x), r.y), r.z);\n}\n\nvec3 Rotate(vec3 p, float rx, float ry, float rz)\n{\n    return RotateZ(RotateX(RotateY(p, rx), ry), rz);\n}\n\nvec3 Rotate(vec3 p, vec3 r, vec3 s)\n{\n    return RotateZ(RotateX(RotateY(p, r.x), r.y), r.z) * s;\n}\n\nvec3 Rotate(vec3 p, float rx, float ry, float rz, vec3 s)\n{\n    return RotateZ(RotateX(RotateY(p, rx), ry), rz) * s;\n}\n\nvec3 Rotate(vec3 p, vec3 r, vec3 s, vec3 t)\n{\n    return RotateZ(RotateX(RotateY(p, r.x), r.y), r.z) * s + t;\n}\n\nvec3 Rotate(vec3 p, float rx, float ry, float rz, vec3 s, vec3 t)\n{\n    return RotateZ(RotateX(RotateY(p, rx), ry), rz) * s + t", "\n    float a = 1.0 / R;\n    float b = 2.0 / R;\n    float c = 1.0 / R;\n    float d = 1.0 / R;\n    float e = 1.0 / R;\n    float f = 1.0 / R;\n    float g = 1.0 / R;\n    float h = 1.0 / R;\n    float i = 1.0 / R;\n    float j = 1.0 / R;\n    float k = 1.0 / R;\n    float l = 1.0 / R;\n    float m = 1.0 / R;\n    float n = 1.0 / R;\n    float o = 1.0 / R;\n    float p = 1.0 / R;\n    float q = 1.0 / R;\n    float r = 1.0 / R;\n    float s = 1.0 / R;\n    float t = 1.0 / R;\n    float u = 1.0 / R;\n    float v = 1.0 / R;\n    float w = 1.0 / R;\n    float x = 1.0 / R;\n    float y = 1.0 / R;\n    float z = 1.0 / R;\n    float A = 1.0 / R;\n    float B = 1.0 / R;\n    float C = 1.0 / R;\n    float D = 1.0 / R;\n    float E = 1.0 / R;\n    float F = 1.0 / R;\n    float G = 1.0 / R;\n    float H = 1.0 / R;\n    float I = 1.0 / R;\n    float J = 1.0 / R;\n    float K = 1.0 / R;\n    float L = 1.0 / R;\n    float M = 1.0 / R;\n    float N = 1.0 / R;\n    float O = 1.0 / R;\n    float P = 1.0 / R;\n    float Q = 1.", "\n    float k = 1.0;\n    if (e > 0.0)\n    {\n        k = 1.0 / (1.0 + e * R);\n    }\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// k: global lipschitz bound\nfloat FalloffK(float e, float R, float k)\n{\n    float k = 1.0;\n    if (e > 0.0)\n    {\n        k = 1.0 / (1.0 + e * R);\n    }\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// k: global lipschitz bound\n// k: global lipschitz bound\nfloat FalloffK(float e, float R, float k, float k_max)\n{\n    float k = 1.0;\n    if (e > 0.0)\n    {\n        k = 1.0 / (1.0 + e * R);\n    }\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// k: global lipschitz bound\n// k: global lipschitz bound\n// k: global lipschitz bound\nfloat FalloffK(float e, float R, float k, float k_max, float k_min)\n{\n    float k = 1.0;\n    if (e > 0.0)\n    {\n        k = 1.0 / (1.0 + e * R);\n    }\n    return k;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// k: global lipschitz bound\n// k: global lipschitz bound\n// k: global lipschitz bound\n// k: global lipschitz bound\nfloat FalloffK(float e, float R, float k, float k_max, float k_min, float k_min_max)\n{\n    float k = 1.0;\n    if (e > 0.0)\n    {", "\n    float k = 0.0;\n    if (a == b)\n    {\n        k = 1.0;\n    }\n    else\n    {\n        k = (a - b) / (R * R * e);\n    }\n    return k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k)\n{\n    float k_new = 0.0;\n    if (a == b)\n    {\n        k_new = 1.0;\n    }\n    else\n    {\n        k_new = (a - b) / (R * R * e);\n    }\n    return k_new;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k_new)\n{\n    float k_new = 0.0;\n    if (a == b)\n    {\n        k_new = 1.0;\n    }\n    else\n    {\n        k_new = (a - b) / (R * R * e);\n    }\n    return k_new;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k_new, float k_new_new)\n{\n    float k_new_new = 0.0;\n    if (a == b)\n    {\n        k_new_new = 1.0;\n    }\n    else\n    {\n        k_new_new = (a - b) / (R * R * e);\n    }\n    return k_new_new;\n}\n\n// Computes the local", "\n    return length(p - c) - R + e;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R + e;\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, vec3 R, float e)\n{\n    vec3 d = abs(p - c) - R;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - e;\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n    return length(p.xz - c.xz) - R + e;\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n    vec2 q = vec2(length(p.xz - c.xz), p.y);\n    return max(q.x, q.y * tan(R)) - R + e;\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float e)\n{\n    vec2 q = vec2(length(p.xz - c.xz) - R, p.y);\n    return length(q) - e;\n}\n\n// Plane primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, float R, float e)\n{\n    return p.y - c.y + e;\n}\n\n// Triangle primitive field function", "\n    vec3 d = b - a;\n    float l = length(d);\n    vec3 n = d / l;\n    vec3 m = (a + b) / 2.0;\n    vec3 p = m - c;\n    float p_dot_n = dot(p, n);\n    float p_dot_p = dot(p, p);\n    float R_sq = R * R;\n    float e_sq = e * e;\n    float l_sq = l * l;\n    float p_dot_n_sq = p_dot_n * p_dot_n;\n    float p_dot_p_sq = p_dot_p * p_dot_p;\n    float R_sq_p_dot_n_sq = R_sq * p_dot_n_sq;\n    float R_sq_p_dot_p_sq = R_sq * p_dot_p_sq;\n    float R_sq_l_sq = R_sq * l_sq;\n    float e_sq_p_dot_n_sq = e_sq * p_dot_n_sq;\n    float e_sq_p_dot_p_sq = e_sq * p_dot_p_sq;\n    float e_sq_l_sq = e_sq * l_sq;\n    float R_sq_p_dot_n_sq_p_dot_p_sq = R_sq_p_dot_n_sq + R_sq_p_dot_p_sq;\n    float e_sq_p_dot_n_sq_p_dot_p_sq = e_sq_p_dot_n_sq + e_sq_p_dot_p_sq;\n    float R_sq_p_dot_n_sq_p_dot_p_sq_l_sq = R_sq_p_dot_n_sq_p_dot_p_sq + R_sq_l_sq;\n    float e_sq_p_dot_n_sq_p_dot_p_sq_l_sq = e_sq_p_dot_n_sq_p_dot_p_sq + e_sq_l", "\n    float d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return length(b - a);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k)\n{\n    return length(b - a) / k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2)\n{\n    return length(b - a) / k + k2;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3)\n{\n    return length(b - a) / k + k2 + k3;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3, float k4)\n{\n    return length(b - a) / k + k2 + k3 + k4;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3, float k4, float k5)\n{\n    return length(b - a) / k + k2 + k3 + k4 + k5;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3, float k4, float k5, float k6)\n{\n    return length(b - a) / k + k2 + k3 + k4 + k5 + k6;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3, float k4, float k5, float k6, float k7)\n{\n    return length(b - a) / k + k2 + k3 + k4 + k5 + k6 + k7;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k, float k2, float k3, float k4, float k5, float k6, float k7, float k8)\n{\n    return length(b - a) / k + k2 + k3 + k4 + k5 + k6 + k7 + k8;\n}\n\n// K root\nfloat KSegment", "\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    n.x = ObjUnion(p + e.xyz, p - e.xyz);\n    e = vec3(0.0, 0.001, 0.0);\n    n.y = ObjUnion(p + e.xyz, p - e.xyz);\n    e = vec3(0.0, 0.0, 0.001);\n    n.z = ObjUnion(p + e.xyz, p - e.xyz);\n    return normalize(n);\n}\n\n// Normal evaluation with a distance field\nvec3 ObjectNormal(in vec3 p, in float d)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    n.x = ObjUnion(p + e.xyz, p - e.xyz) - d;\n    e = vec3(0.0, 0.001, 0.0);\n    n.y = ObjUnion(p + e.xyz, p - e.xyz) - d;\n    e = vec3(0.0, 0.0, 0.001);\n    n.z = ObjUnion(p + e.xyz, p - e.xyz) - d;\n    return normalize(n);\n}\n\n// Normal evaluation with a distance field and a normal map\nvec3 ObjectNormal(in vec3 p, in float d, in vec3 n)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    n.x = ObjUnion(p + e.xyz, p - e.xyz) - d;\n    e = vec3(0.0, 0.001, 0.0);\n    n.y = ObjUnion(p + e.xyz, p - e.xyz) - d;\n    e = vec3(0.0, 0.", "\n    float d = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = o + d * u;\n        float r = length(p);\n        if (r > 1.0)\n        {\n            h = true;\n            break;\n        }\n        d += r;\n        s++;\n    }\n    return d;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, float maxDist)\n{\n    float d = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = o + d * u;\n        float r = length(p);\n        if (r > maxDist)\n        {\n            h = true;\n            break;\n        }\n        d += r;\n        s++;\n    }\n    return d;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, float maxDist, float maxSteps)\n{\n    float d = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 p = o + d * u;\n        float r = length(p);\n        if (r > maxDist)\n        {\n            h = true;\n            break;\n        }\n        d += r;\n        s++;\n    }\n    return d;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, float", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = o + t * u;\n        if (p.y < 0.0)\n        {\n            h = true;\n            break;\n        }\n        t += STEP_SIZE;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = o + t * u;\n        if (p.y < 0.0)\n        {\n            h = true;\n            break;\n        }\n        t += STEP_SIZE;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = o + t * u;\n        if (p.y < 0.0)\n        {\n            h = true;\n            break;\n        }\n        t += STEP_SIZE;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n, out", "\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Sky(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Ground(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Wall(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Floor(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Ceiling(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.6, 0.7, 1.0), vec3(1.0), t);\n    return col;\n}\n\nvec3 Light(vec3 rd)\n{\n    vec3 col = vec3", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n// arbitrary orientation\nfloat sdCone( vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n    float rba  = rb - ra;\n    float baba = dot(b - a, b - a);\n    float papa = dot(p - a, p - a);\n    float paba = dot(p - a, b - a) / baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0, x - (paba*rba + ra));\n    float cay = abs(paba*ra - x);\n    float k = rba*rba + baba;\n    float f = clamp( (rba*paba - x*paba + ra)/k, 0.0, 1.0 );\n    float cbx = x - rba*f;\n    float cby = paba*ra - x*f;\n    float s = (cbx < 0.0 && cay < 0.0)? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       min(cbx*cbx + cby*cby*baba,\n                           k*x*x)))/baba;\n}\n\n// arbitrary orientation\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// arbitrary orientation\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos, in vec3 rot ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\nvec", "\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return uv_coord(coord / size);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return uv_coord(coord / size + offset);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return uv_coord(coord / size + offset) * scale;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation) {\n    return uv_coord(coord / size + offset) * scale * rotation;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation, vec2 pivot) {\n    return uv_coord(coord / size + offset) * scale * rotation - pivot;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation, vec2 pivot, vec2 flip) {\n    return uv_coord(coord / size + offset) * scale * rotation - pivot * flip;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation, vec2 pivot, vec2 flip, vec2 skew) {\n    return uv_coord(coord / size + offset) * scale * rotation - pivot * flip + skew;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation, vec2 pivot, vec2 flip, vec2 skew, vec2 perspective) {\n    return uv_coord(coord / size + offset) * scale * rotation - pivot * flip + skew * perspective;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotation, vec2 pivot, vec2 flip,", "\n    vec2 a = p - q;\n    vec2 b = p - vec2(q.x, -q.y);\n    vec2 c = p - vec2(-q.x, q.y);\n    vec2 d = p - vec2(-q.y, q.x);\n    vec2 e = p - vec2(q.y, -q.x);\n    vec2 f = p - vec2(q.y, q.x);\n    vec2 g = p - vec2(-q.y, -q.x);\n    vec2 h = p - vec2(q.x, q.y);\n    vec2 i = p - vec2(-q.x, -q.y);\n    vec2 j = p - vec2(0.0, 0.0);\n    vec2 k = p - vec2(q.x, 0.0);\n    vec2 l = p - vec2(0.0, q.y);\n    vec2 m = p - vec2(-q.x, 0.0);\n    vec2 n = p - vec2(0.0, -q.y);\n    vec2 o = p - vec2(q.y, 0.0);\n    vec2 p = p - vec2(0.0, q.x);\n    vec2 q = p - vec2(-q.y, 0.0);\n    vec2 r = p - vec2(0.0, -q.x);\n    vec2 s = p - vec2(q.y, -q.x);\n    vec2 t = p - vec2(-q.y, q.x);\n    vec2 u = p - vec2(q.x, -q.y);\n    vec2 v = p - vec2(-q.x, q.y);\n    vec2 w = p - vec2(q.x, q.y);\n    vec2 x = p - vec2(-q.x, -q.y);\n    vec2 y = p - vec2(q.y, -q.x);\n    vec2 z = p - vec2(-q.y, q.x);\n    vec2 aa = p - vec2(q", "\n    vec2 q = vec2(length(p), atan(p.y, p.x));\n    float l = length(q - vec2(r, 0.0));\n    float m = length(q - vec2(d, 0.0));\n    float n = length(q - vec2(d, 0.0));\n    float k1 = r*r;\n    float k2 = d*d;\n    float k3 = n*n;\n    float k4 = m*m;\n    float k5 = q.x*q.x;\n    float k6 = q.y;\n    float k7 = k5 - k2;\n    float k8 = k4 - k1;\n    float k9 = k7*k7;\n    float k10 = k8*k8;\n    float k11 = sqrt(0.5*((k9 + k10) + sqrt((k9 - k10)*(k9 + k10) + 4.0*k7*k8*k5)));\n    float k12 = 0.25*k11;\n    float k13 = 0.5*((k9 + k10) - k11);\n    float k14 = 0.25*sqrt(k13*k13 + 4.0*k7*k8);\n    float k15 = (k12 + k14)*(k12 + k14);\n    float k16 = 0.5*((k9 + k10) + k11);\n    float k17 = 0.25*sqrt(k13*k13 + 4.0*k7*k8);\n    float k18 = (k12 - k14)*(k12 - k14);\n    float k19 = k16*k16;\n    float k20 = k17*k17;\n    float k21 = sqrt(k19 - 4.0*k20);\n    float k22 = 0.5*(k19 + k21);\n    float k23 =", "\n    vec2 q = p - c;\n    float l = length(q);\n    float d = l - r;\n    float s = sign(d);\n    float a = atan(q.y,q.x);\n    float da = acos(s*r/l);\n    float d1 = abs(a);\n    float d2 = abs(d1-da);\n    float d3 = abs(d1+da);\n    return vec3(d1,s*d2,s*d3);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p - c;\n    float l = length(q);\n    float d = l - r;\n    float s = sign(d);\n    float a = atan(q.y,q.x);\n    float da = acos(s*r/l);\n    float d1 = abs(a);\n    float d2 = abs(d1-da);\n    float d3 = abs(d1+da);\n    return vec3(d1,s*d2,s*d3);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p - c;\n    float l = length(q);\n    float d = l - r;\n    float s = sign(d);\n    float a = atan(q.y,q.x", "\n    vec2 e0 = v[1] - v[0];\n    vec2 e1 = v[2] - v[1];\n    vec2 e2 = v[0] - v[2];\n\n    vec2 v0 = p - v[0];\n    vec2 v1 = p - v[1];\n    vec2 v2 = p - v[2];\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    vec2 qr0 = pq0 - v0;\n    vec2 qr1 = pq1 - v1;\n    vec2 qr2 = pq2 - v2;\n\n    vec2 qr = qr0*sign(dot(qr0,e0)) + qr1*sign(dot(qr1,e1)) + qr2*sign(dot(qr2,e2));\n\n    vec2 q = -sign(dot(qr,e0))*qr0 - sign(dot(qr,e1))*qr1 - sign(dot(qr,e2))*qr2;\n\n    return vec3( length(q), dot(qr,e0), dot(qr,e1) );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    return vec3( length(d) - r, d.x, d.y );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p", "\n    vec2 q = vec2( dot(p,sca), dot(p,scb) );\n    float l = length(q);\n    float m = ra-rb;\n    float n = ra+rb;\n    float t = clamp( (l-m)/(n-m), 0.0, 1.0 );\n    float d = l-n*t + m*sqrt(1.0-t*t);\n    return vec3( d, q/l, vec2(t,sqrt(1.0-t*t)) );\n}\n\n//.x = f(p)\n//.yz = \u2202f(p)/\u2202x, \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.w = \u2202f(p)/\u2202t\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec4 sdgArc( in vec3 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    vec3 q = vec3( dot(p.xy,sca), dot(p.xy,scb), p.z );\n    float l = length(q.xy);\n    float m = ra-rb;\n    float n = ra+rb;\n    float t = clamp( (l-m)/(n-m), 0.0, 1.0 );\n    float d = l-n*t + m*sqrt(1.0-t*t);\n    return vec4( d, q.xy/l, q.z, sqrt(1.0-t*t) );\n}\n\n//.x = f(p)\n//.yz = \u2202f(p)/\u2202x, \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.w = \u2202f(p)/\u2202t\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec4 sdgArc( in vec4 p, in vec2 sca, in vec2 scb, in float ra, in float", " return a.x*b.x + a.y*b.y; }\nfloat crs( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w )\n{\n    return abs(length(p)-r)-w;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d )\n{\n    return abs(length(p)-r)-w-d;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d, in float s )\n{\n    return abs(length(p)-r)-w-d-s;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d, in float s, in float t )\n{\n    return abs(length(p)-r)-w-d-s-t;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d, in float s, in float t, in float u )\n{\n    return abs(length(p)-r)-w-d-s-t-u;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d, in float s, in float t, in float u, in float v )\n{\n    return abs(length(p)-r)-w-d-s-t-u-v;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float w, in float d, in float s, in float t, in float u, in float v, in float a )\n{\n    return abs(length(p)-r)-w-d-s-t-", "\n    vec2 q = vec2( ab.x*p.x, ab.y*p.y );\n    float f = dot(q,q);\n    return vec3( f, 2.0*q.x, 2.0*q.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( vec2 p, float r )\n{\n    float f = dot(p,p);\n    return vec3( f, 2.0*p.x, 2.0*p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( vec2 p, vec2 b )\n{\n    vec2 q = abs(p) - b;\n    float f = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return vec3( f, sign(q.x)*step(0.0,q.x) + sign(q.y)*step(0.0,q.y), -sign(q.x)*step(0.0,q.x) + sign(q.y)*step(0.0,q.y) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( vec2 p, vec2 b, vec2 c )\n{\n    vec2 q = abs(p) - b;\n    float f = length(max(q,0.0)) + min(", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,q.x,q.y,p.z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n    return vec4(length(p.xz)-ra,p.x,p.z,p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n    float d = (p.y - rb);\n    float q = length(p.xz);\n    float s = (q - ra);\n    vec2  a = vec2(s,d);\n    vec2  b = vec2(q,p.y);\n    float h = max(a.x,b.y);\n    float m = max(b.x,h);\n    return vec4(m,a.x,b.y,a.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return vec4(dot(p,n.", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r*h, ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )", "\n    vec2 q = vec2( p.x*cos(sk)-p.y*sin(sk), p.x*sin(sk)+p.y*cos(sk) );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c = vec2( wi+sk*he, he );\n    vec2 ba = b-a; vec2 ca = c-a;\n    vec2 pa = p -a;\n    vec2 pb = p -b;\n    vec2 pc = p -c;\n    float s = sign( pa.x*ca.y - pa.y*ca.x );\n    float d1 = s*length( min(0.0,dot(ba,pa))*ba + min(0.0,dot(ca,pa))*ca );\n    s = sign( pb.x*ba.y - pb.y*ba.x );\n    float d2 = s*length( min(0.0,dot(ca,pb))*ca + min(0.0,dot(ba,pb))*ba );\n    s = sign( pc.x*ca.y - pc.y*ca.x );\n    float d3 = s*length( min(0.0,dot(ba,pc))*ba + min(0.0,dot(ca,pc))*ca );\n    return min( min(d1,d2), d3 );\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = vec2( p.x*cos(sk)-p.y*sin(sk), p.x*sin(sk)+p.y*cos(sk) );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c = vec2( wi+sk*he, he );\n    vec2 ba = b-a; vec2 ca = c-a;\n    vec2 pa =", "\n    vec2 q = vec2( p.x + sk*p.y, p.y );\n    vec2 r = vec2( p.x - sk*p.y, p.y );\n    vec2 a = vec2( wi, he );\n    vec2 b = vec2( wi, he );\n    vec2  f = vec2( dot(q,a), dot(r,b) );\n    vec2  g = vec2( dot(q,b), dot(r,a) );\n    float h = max( f.x, g.x );\n    float i = min( f.y, g.y );\n    float s = max( f.y, g.y );\n    float t = min( f.x, g.x );\n    float x = (h-i)*0.5;\n    float y = (s-t)*0.5;\n    float z = (s+t)*0.5;\n    float w = (h+i)*0.5;\n    float d = min( x, y );\n    d = min( d, z );\n    d = min( d, w );\n    vec3 res = vec3( d, x, y );\n    if( x<y ) res.yz = res.yz*vec2(-1.0, 1.0);\n    if( z<w ) res.yz = res.yz*vec2( 1.0,-1.0);\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk, float sdg )\n{\n    vec2 q = vec2( p.x + sk*p.y, p.y );\n    vec2 r = vec2( p.x - sk*p.y, p.y );\n    vec2 a = vec2( wi, he );\n    vec2 b = vec2( wi, he );", "\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tr += c;\n\t\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tfor( int j = 0; j < p; j++ )\n\t\t\t\tr += c;\n\t\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tfor( int j = 0; j < p; j++ )\n\t\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\t\tr += c;\n\t\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tfor( int j = 0; j < p; j++ )\n\t\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\t\tr += c;\n\t\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tfor( int j = 0; j < p; j++ )\n\t\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\t\tfor( int m = 0; m < p; m++ )\n\t\t\t\t\t\t\tr += c;\n\t\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\t\tfloat r = 0;\n\t\tfor( int i = 0; i < p; i++ )\n\t\t\tfor( int j = 0; j < p; j++ )\n\t\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\t\tfor( int l = 0; l < p", "\n    return a * (1.0 - k) + b * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return a * k + b * (1.0 - k);\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n    return pmin(pmax(a, b, k), pmax(a, b, 1.0 - k), k);\n}\n\n// IQ's polynominal mix\nfloat pmix(float a, float b, float k) {\n    return pclamp(a, b, k);\n}\n\n// IQ's polynominal lerp\nfloat plerp(float a, float b, float k) {\n    return pmix(a, b, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n    return pclamp(a, b, k * k * (3.0 - 2.0 * k));\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    return pclamp(a, b, k * k * k * (k * (k * 6.0 - 15.0) + 10.0));\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    return pclamp(a, b, k * k * k * (k * (k * 6.0 - 15.0) + 10.0));\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    return pclamp(a, b, k * k * k * (k * (k * 6.0 - 15.0) + 10.0));\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    return pclamp(a, b, k * k * k * (k * (k * 6.", "\n  vec2 c = floor((p + size * 0.5) / size);\n  p = mod(p + size * 0.5, size) - size * 0.5;\n  return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w) {\n  return abs(length(p) - r) - w;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w, float d) {\n  return abs(length(p) - r) - w - d;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w, float d, float s) {\n  return abs(length(p) - r) - w - d + s;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w, float d, float s, float t) {\n  return abs(length(p) - r) - w - d + s - t;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w, float d, float s, float t, float u) {\n  return abs(length(p) - r) - w - d + s - t - u;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat circle(vec2 p, float r, float w, float d, float s, float t, float u, float v) {\n  return abs(length(p", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        outNormal = vec3(0.0);\n        return vec2(-1.0);\n    }\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2(tN, tF);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 plane) {\n    float denom = dot(rd, plane.xyz);\n    if (denom > 1e-6) {\n        float t = dot(plane.xyz, ro) + plane.w;\n        return vec2(t / denom);\n    }\n    return vec2(-1.0);\n}\n\n// IQ's ray cylinder intersection\nvec2 rayCylinder(vec3 ro, vec3 rd, vec4 c) {\n    vec3 oc = ro - c.xyz;\n    float a = dot(rd, rd) - rd.y * rd.y;\n    float b = 2.0 * (dot(", "\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec2(-1.0); // or set tN to \"infinity\"\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n// IQ's ray sphere intersection\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt(h);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 pla) {\n    float denom = dot(rd, pla.xyz);\n    if( abs(denom)<0.0001 ) return -1.0;\n    return -(dot(ro, pla.xyz) + pla.w)/denom;\n}\n\n// IQ's ray cylinder intersection\nfloat rayCylinder(vec3 ro, vec3 rd, vec4 cy) {\n    vec3 oc = ro - cy.xyz;\n    float a = dot(rd, rd) - rd.y*rd.y;\n    float b = 2.0*dot(oc, rd) - 2.0*oc.y*rd.y;\n    float c = dot(", "\n    vec2 s = sign(p);\n    vec2 r = abs(p);\n    vec2 q = abs(p - d);\n    vec2 t = min(r, q);\n    vec2 u = max(r, q);\n    vec2 v = s * t;\n    vec2 w = s * u;\n    e1 = v.x < v.y? vec2(v.x, w.x) : vec2(w.x, v.x);\n    e2 = v.y < v.z? vec2(v.y, w.y) : vec2(w.y, v.y);\n    e3 = v.z < v.w? vec2(v.z, w.z) : vec2(w.z, v.z);\n    e4 = v.w < v.x? vec2(v.w, w.w) : vec2(w.w, v.w);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 s = sign(p);\n    vec3 r = abs(p);\n    vec3 q = abs(p - d);\n    vec3 t = min(r, q);\n    vec3 u = max(r, q);\n    vec3 v = s * t;\n    vec3 w = s * u;\n    e1 = v.x < v.y? vec3(v.x, w.x, 0.0) : vec3(w.x, v.x, 0.0);\n    e2 = v.y < v.z? vec3(v.y, w.y, 0.0) : vec3(w.y, v.y, 0.0);\n    e3 = v.z < v.w? vec3(v.z, w.z, 0.0) : vec3(w.z, v.z, 0.0);\n   ", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n    return box(p, b) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t) {\n    return box(p, b) - r + t;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d) {\n    return box(p, b) - r + t + d;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d, float s) {\n    return box(p, b) - r + t + d + s;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d, float s, float c) {\n    return box(p, b) - r + t + d + s + c;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d, float s, float c, float v) {\n    return box(p, b) - r + t + d + s + c + v;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d, float s, float c, float v, float h) {\n    return box(p, b) - r + t + d + s + c + v + h;\n}\n\nfloat box(vec2 p, vec2 b, float r, float t, float d, float s, float c, float v, float h, float g) {\n    return box(p, b) - r + t + d + s + c + v + h + g;\n}\n\nfloat box", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*(1.0-h);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*(1.0-h);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*(1.0-h);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2, float h3 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*(1.0-h);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec", "\n    vec2 q = vec2(length(ro.xz)-tor.x,ro.y);\n    float r = length(q);\n    float l = -q.y/rd.y;\n    float m = l*l + r*r - tor.y*tor.y;\n    if( m<0.0 ) return -1.0;\n    float t = l - sqrt(m);\n    return t;\n}\n\nfloat raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt(h);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, float h) {\n    return -(ro.y-h)/rd.y;\n}\n\nfloat rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return -1.0;\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return tN;\n}\n\nfloat rayCapsule(vec3 ro, vec3 rd, vec3 a, vec3 b, float r, out vec3 outNormal) {\n    vec3  ba = b - a;\n    float h  = dot(ba,ba);\n    float t  = dot(ba,ro-a);\n    float y  = abs(t);\n    float x  = sqrt(h-", "\n    vec2 q = vec2(length(pos.xz)-tor.x,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2) {\n    vec2 q = vec2(length(pos.xz)-r1,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2, float r3) {\n    vec2 q = vec2(length(pos.xz)-r1,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2, float r3, float r4) {\n    vec2 q = vec2(length(pos.xz)-r1,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2, float r3, float r4, float r5) {\n    vec2 q = vec2(length(pos.xz)-r1,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos, float r1, float r2, float r3, float r4, float r5, float r6) {\n    vec2 q = vec2(length(pos.xz)-r1,pos.y);\n    return normalize(vec3(2.0*q.x*pos.z,2.0*q.x*pos.x,q.y));\n}\n\nvec3 torusNormal(vec3 pos,", "\n    float x2 = x * x;\n    return x * (27 + x2) / (27 + 9 * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx(float x) {\n    return 1.0f / (1.0f + expf(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu_approx(float x) {\n    return x * (x > 0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu_approx(float x) {\n    return x * (x > 0) + 0.01f * x * (x <= 0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat elu_approx(float x) {\n    return x * (x >= 0) + 1.0f * (expf(x) - 1) * (x < 0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat swish_approx(float x) {\n    return x * sigmoid_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat mish_approx(float x) {\n    return x * tanh_approx(logf(1 + expf(x)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat gelu_approx(float x) {\n    return x * sigmoid_approx(1.702f * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat softplus_approx(float x) {\n    return logf(1 + expf(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat softsign_approx(float x) {\n    return x / (1 + abs(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat softshrink_approx(float x) {\n    return x * (abs(x)", "\n    col = pow(col, vec3(0.4545));\n    col *= 0.6 + 0.4 * sin(13.0 * q.x + q.y * 0.01);\n    return col;\n}\n", "\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCone(vec3 p, vec2 c) {\n    // c is the sin/cos of the angle, where sin is the height\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y));\n}\n", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n\n    f += 0.5000 * noise(uv); uv = uv * 2.02;\n    f += 0.2500 * noise(uv); uv = uv * 2.03;\n    f += 0.1250 * noise(uv); uv = uv * 2.01;\n    f += 0.0625 * noise(uv); uv = uv * 2.04;\n    f += 0.0312 * noise(uv); uv = uv * 2.01;\n    f += 0.0156 * noise(uv); uv = uv * 2.02;\n    f += 0.0078 * noise(uv); uv = uv * 2.01;\n    f += 0.0039 * noise(uv); uv = uv * 2.04;\n    f += 0.0019 * noise(uv); uv = uv * 2.01;\n    f += 0.0009 * noise(uv); uv = uv * 2.02;\n    f +=", "\n    return length(p-c)-r;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s )\n{\n    vec2 d = abs(p-c)-s;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s, in float r )\n{\n    vec2 d = abs(p-c)-s;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s, in float r, in float r2 )\n{\n    vec2 d = abs(p-c)-s;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s, in float r, in float r2, in float r3 )\n{\n    vec2 d = abs(p-c)-s;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2 - r3;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s, in float r, in float r2, in float r3, in float r4 )\n{\n    vec2 d = abs(p-c)-s;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2 - r3 - r4;\n}\n", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 sz )\n{\n    vec2 d = abs(p)-sz;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 sz, in float r )\n{\n    vec2 d = abs(p)-sz+r;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to a polygon\nfloat sdPoly( in vec2 p, in vec2 center, in float radius, in int sides )\n{\n    float a = atan(p.x-center.x,p.y-center.y);\n    float r = length(p-center);\n    float da = 6.28318530718/float(sides);\n    float d = cos(floor(.5+a/da)*da-a)*r;\n    return abs(d-radius);\n}\n\n// distance to a polygon with rounded corners\nfloat sdPolyRound( in vec2 p, in vec2 center, in float radius, in int sides, in float r )\n{\n    float a = atan(p.x-center.x,p.y-center.y);\n    float r2 = radius-r;\n    float d = cos(floor(.5+a/6.28318530718)*6.28318530718-a)*r2;\n    return length(vec2(d,radius))-r;\n}\n\n// distance to a polygon with rounded corners\nfloat sdPoly", " return a.x*b.y - a.y*b.x; }\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec3 d = vec3( dot(ba,ba), dot(cb,cb), dot(ac,ac) );\n    vec2 e = vec2(-dot(ba,pa), -dot(cb,pb) );\n    vec2 f = e / d;\n    vec2 g = vec2( clamp(f.x,0.0,1.0), clamp(f.y,0.0,1.0) );\n    return sqrt( dot(e,e)*f.x*f.y/dot(f,f) ) * sign(cro(ba,pa)) * sign(cro(cb,pb)) * sign(cro(ac,pc));\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n    return sdTriangle(p,a,b,c) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float h )\n{\n    return sdTriangle(p,a,b,c,r) - h;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float h, in float d )\n{\n    return sdTriangle(p,a,b,c,r,h) - d;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float h, in float d, in float s )\n{\n    return sdTriangle(p,a,b,c,r,h,d) - s;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2", "\n  p = abs(p);\n  p.x = max(p.x,p.y);\n  vec2 q = vec2(max(p.x-r,0.0),p.y);\n  return length(q)-s;\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r);\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle, in float thickness ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r,thickness);\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle, in float thickness, in float thicknessOffset ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r,thickness,thicknessOffset);\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle, in float thickness, in float thicknessOffset, in float thicknessOffsetAngle ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r,thickness,thicknessOffset,thicknessOffsetAngle);\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle, in float thickness, in float thicknessOffset, in float thicknessOffsetAngle, in float thicknessOffsetAngleOffset ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r,thickness,thicknessOffset,thicknessOffsetAngle,thicknessOffsetAngleOffset);\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float angle, in float thickness, in float thicknessOffset, in float thicknessOffsetAngle, in float thicknessOffsetAngleOffset, in float thicknessOffsetAngleOffsetAngle ) \n{\n  p = rotate(p,angle);\n  return sdRoundSquare(p,s,r,thickness,thicknessOffset,thicknessOffsetAngle,thicknessOffsetAngleOffset,thicknessOffsetAngle", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 s_curve_inv(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(c*x+d)+e)/(x*(a*x+b)), 0.0, 1.0);\n}\n\nvec3 s_curve_deriv(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((a*x+b)/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 s_curve_deriv_inv(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((c*x+d)/(x*(a*x+b)), 0.0, 1.0);\n}\n\nvec3 s_curve_deriv2(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((a*a*x", "\n    return 2.0 * x * (1.0 - x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_2(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_3(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x) * (1.0 - 3.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_4(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x) * (1.0 - 3.0 * x) * (1.0 - 4.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_5(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x) * (1.0 - 3.0 * x) * (1.0 - 4.0 * x) * (1.0 - 5.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_6(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x) * (1.0 - 3.0 * x) * (1.0 - 4.0 * x) * (1.0 - 5.0 * x) * (1.0 - 6.0 * x);\n}\n\n// derivative of s-curve\nvec3 d_s_curve_7(vec3 x)\n{\n    return 2.0 * x * (1.0 - x) * (1.0 - 2.0 * x) * (1.0 - 3.0 * x) * (1.0 - 4.0", "\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    vec2  q = vec2(dot(p,vec2(c,-s)),dot(p,vec2(s,c)));\n    return length( q-0.5*w )*sqrt(dot(q,q))+p.y;\n}\n\nfloat sdSpiral( in vec2 p, float w, in float k, in float h )\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    vec2  q = vec2(dot(p,vec2(c,-s)),dot(p,vec2(s,c)));\n    return length( q-0.5*w )*sqrt(dot(q,q))+p.y-h;\n}\n\nfloat sdSpiral( in vec2 p, float w, in float k, in float h, in float r )\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    vec2  q = vec2(dot(p,vec2(c,-s)),dot(p,vec2(s,c)));\n    return length( q-0.5*w )*sqrt(dot(q,q))+p.y-h-r;\n}\n\nfloat sdSpiral( in vec2 p, float w, in float k, in float h, in float r, in float d )\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    vec2  q = vec2(dot(p,vec2(c,-s)),dot(p,vec2(s,c)));\n    return length( q-0.5*w )*sqrt(dot(q,q))+p.y-h-r-d;\n}\n\nfloat sdSpiral( in vec2 p, float w, in float k, in float h, in float r, in float d, in float t )\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    vec2  q", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float opticalDepth2)\n{\n    return exp(-opticalDepth - opticalDepth2);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2)\n{\n    return exp(-opticalDepth - opticalDepth2);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3)\n{\n    return exp(-opticalDepth - opticalDepth2 - opticalDepth3);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4)\n{\n    return exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4, vec3 opticalDepth5)\n{\n    return exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4 - opticalDepth5);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4, vec3 opticalDepth5, vec3 opticalDepth6)\n{\n    return exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4 - opticalDepth5 - opticalDepth6);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4, vec3 opticalDepth5, vec3 opticalDepth6, vec3 opticalDepth7)\n{\n    return exp(-opticalDepth - opticalDepth2 - opticalDepth3 -", "\n    vec3 scattering = vec3(0.0);\n    transmittance = vec3(1.0);\n\n    float opticalDepth = 0.0;\n    float stepSize = 0.1;\n    float sampleLength = stepSize;\n\n    vec3 samplePoint = rayStart;\n\n    while (sampleLength < rayLength)\n    {\n        vec3 sampleTransmittance = exp(-SampleScattering(samplePoint) * sampleLength);\n        transmittance *= sampleTransmittance;\n\n        opticalDepth += sampleTransmittance.r;\n\n        scattering += SampleScattering(samplePoint) * sampleLength * sampleTransmittance * lightColor * max(0.0, dot(lightDir, samplePoint));\n\n        samplePoint += rayDir * stepSize;\n        sampleLength += stepSize;\n    }\n\n    return scattering;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor)\n{\n    vec3 scattering = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n\n    float opticalDepth = 0.0;\n    float stepSize = 0.1;\n    float sampleLength = stepSize;\n\n    vec3 samplePoint = rayStart;\n\n    while (sampleLength < rayLength)\n    {\n        vec3 sampleTransmittance = exp(-SampleScattering(samplePoint) * sampleLength);\n        transmittance *= sampleTransmittance;\n\n        opticalDepth += sampleTransmittance.r;\n\n        scattering += SampleScattering(samplePoint) * sampleLength * sampleTransmittance * lightColor * max(0.0, dot(lightDir, samplePoint));\n\n        samplePoint += rayDir * stepSize;\n        sampleLength += stepSize;\n    }\n\n    return scattering;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 Integ", "\n    vec3 p = p2;\n    float r = ra;\n    float k = rb;\n    float h = d;\n    float l = h*h + r*r - k*k;\n    float m = dot(p,vec3(h,r,k));\n    float n = m*m - l;\n    if( n>0.0 )\n    {\n        float q = sqrt(n);\n        return abs(m-q) - r;\n    }\n    return abs(m) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -length(q);\n    float d2 = max( dot(q,c.xy), q.y*c.z );\n    return max(d1,d2);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q", "\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  float d = length(p) - r;\n  float m = length(p.xz) - h;\n  return max(d,max(m, -m - t));\n}\n\n// r = sphere's", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float mint )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001*t ) return 0.0;\n        res = min( res, h/t );\n        t += max( h, mint );\n        if( t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float mint, float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<0.001*t ) return 0.0;\n        res = min( res, h/t );\n        t += max( h, mint*res );\n        if( t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float mint, float k, float bias )\n{\n", "\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere2( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere3( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere4( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere5( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere6( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere7( in vec3 p, in float r, in float h )\n{\n  float d = length(p.xz) - r;\n  return max(d, abs(p.y) - h);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere8( in vec3 p, in float r, in float h )\n{\n  float d = length(p", "\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 nor )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( e.xyy*map( pos + e.xyy*nor ).x +\n                      e.yyx*map( pos + e.yyx*nor ).x +\n                      e.yxy*map( pos + e.yxy*nor ).x +\n                      e.xxx*map( pos + e.xxx*nor ).x );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 nor, in vec2 uv )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( e.xyy*map( pos + e.xyy*nor, uv ).x +\n                      e.yyx*map( pos + e.yyx*nor, uv ).x +\n                      e.yxy*map( pos + e.yxy*nor, uv ).x +\n                      e.xxx*map( pos + e.xxx*nor, uv ).x );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in vec3 nor, in vec2 uv, in float time )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( e.xyy*map( pos + e.xyy*nor, uv, time ).x +\n                      e.yyx*map( pos + e.yyx*nor, uv, time ).x +\n                      e.yxy*map(", "\n    return length(p.xy) - r - h*abs(p.y);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in float angle )\n{\n    p = rotate(p, angle);\n    return sdCutDisk(p, r, h);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in float angle )\n{\n    p -= center;\n    p = rotate(p, angle);\n    return sdCutDisk(p, r, h);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center )\n{\n    p -= center;\n    return sdCutDisk(p, r, h);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in vec2 axis )\n{\n    p -= center;\n    p = rotate(p, axis);\n    return sdCutDisk(p, r, h);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in vec2 axis, in float angle )\n{\n    p -= center;\n    p = rotate(p, axis, angle);\n    return sdCutDisk(p, r, h);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in vec2 axis, in float angle, in float angle2 )\n{\n    p -= center;\n    p = rotate(p, axis, angle2);\n    return sdCutDisk(p, r, h, center, axis, angle);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in vec2 axis, in float angle, in float angle2, in float angle3 )\n{\n    p -= center;\n    p = rotate(p, axis, angle3);\n    return sdCutDisk(p, r, h, center, axis, angle, angle2);\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h, in vec2 center, in vec", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3d noise function with different speed in x, y and z\nfloat noise( in vec3 x, in vec3 speed )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*speed.x + p.z*speed.y;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+  speed.x), hash(n+  speed.x+1.0),f.x),f.y),\n               mix(mix( hash(n+speed.y), hash(n+speed.y+1.0),f.x),\n                   mix( hash(n+speed.y+speed.x), hash(n+speed.y+speed.x+1.0),f.x),f.y),f.z);\n}\n\n// 3d noise function with different speed in x, y and z\nfloat noise( in vec3 x, in vec3 speed, in float scale )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2", "\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p, float rot )\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n//value noise\nfloat noise31(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\tvec3 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash31(i + vec3(0,0,0)),  hash31(i + vec3(1,0,0)), u.x),\n                   mix( hash31(i + vec3(0,1,0)),  hash31(i + vec3(1,1,0)), u.x), u.y),\n               mix(mix( hash31(i + vec3(0,0,1)),  hash31(i + vec3(1,0,1)), u.x),\n                   mix( hash31(i + vec3(0,1,1)),  hash31(i + vec3(1,1,1)), u.x), u.y), u.z);\n}\n\n//value noise\nfloat noise31(vec3 p, float freq)\n{\n    vec3 i = floor(p * freq);\n    vec3 f = fract(p * freq);\n\tvec3 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash31(i + vec3(0,0,0)),  hash31(i + vec3(1,0,0)), u.x),\n                   mix( hash31(i + vec3(0,1,0)),  hash31(i + vec3(1,1,0)), u.x), u.y),\n               mix(mix( hash31(i + vec3(0,0,1)),  hash31(i + vec3(1,0,1)), u.x),\n                   mix( hash31(i + vec3(", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = vec3(uv, 0.5);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(", "\n  float halfsize = size*0.5;\n  p = mod(p+halfsize,size)-halfsize;\n  return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  float d1 = -q.y-c.z;\n  float d2 = max( dot(q,c.xy), q.y);\n  return length(max(vec2(d", "\n    return fract(sin(co) * 43758.5453);\n}\n\nfloat noise(float p) {\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(hash(fl), hash(fl + 1.0), fc);\n}\n\nfloat noise(vec2 p) {\n    vec2 fl = floor(p);\n    vec2 fc = fract(p);\n    return mix(mix(hash(fl.x + fl.y * 57.0), hash(fl.x + 1.0 + fl.y * 57.0), fc.x), mix(hash(fl.x + (fl.y + 1.0) * 57.0), hash(fl.x + 1.0 + (fl.y + 1.0) * 57.0), fc.x), fc.y);\n}\n\nfloat noise(vec3 p) {\n    vec3 fl = floor(p);\n    vec3 fc = fract(p);\n    return mix(mix(mix(hash(fl.x + fl.y * 57.0 + fl.z * 113.0), hash(fl.x + 1.0 + fl.y * 57.0 + fl.z * 113.0), fc.x), mix(hash(fl.x + (fl.y + 1.0) * 57.0 + fl.z * 113.0), hash(fl.x + 1.0 + (fl.y + 1.0) * 57.0 + fl.z * 113.0), fc.x), fc.y), mix(mix(hash(fl.x + fl.y * 57.0 + (fl.z + 1.0) * 113.0), hash(fl.x + 1.0 + fl.y * 57.0 + (fl.z + 1.0) * 113.0), fc.x), mix(hash(fl.x + (fl.y + 1.0) * 57.0 + (fl.z + 1", "\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nfloat sRGB(vec3 t) {\n    return sRGB(t.r) + sRGB(t.g) + sRGB(t.b);\n}\n\nfloat sRGB(vec4 t) {\n    return sRGB(t.rgb);\n}\n\nfloat sRGB(vec2 t) {\n    return sRGB(t.r) + sRGB(t.g);\n}\n\nfloat sRGB(float t, float a) {\n    return sRGB(t) * a;\n}\n\nfloat sRGB(vec3 t, float a) {\n    return sRGB(t) * a;\n}\n\nfloat sRGB(vec4 t, float a) {\n    return sRGB(t) * a;\n}\n\nfloat sRGB(vec2 t, float a) {\n    return sRGB(t) * a;\n}\n\nfloat sRGB(float t, vec2 a) {\n    return sRGB(t) * a.x + a.y;\n}\n\nfloat sRGB(vec3 t, vec2 a) {\n    return sRGB(t) * a.x + a.y;\n}\n\nfloat sRGB(vec4 t, vec2 a) {\n    return sRGB(t) * a.x + a.y;\n}\n\nfloat sRGB(vec2 t, vec2 a) {\n    return sRGB(t) * a.x + a.y;\n}\n\nfloat sRGB(float t, vec3 a) {\n    return sRGB(t) * a.x + a.y + a.z;\n}\n\nfloat sRGB(vec3 t, vec3 a) {\n    return sRGB(t) * a.x + a.y + a.z;\n}\n\nfloat sRGB(vec4 t, vec3 a) {\n    return sRGB(t) * a.x + a.y + a.z;\n}\n\nfloat sRGB(vec2", "\n    return pow(c, vec3(2.2));\n}\n\nvec3 RGB(in vec3 c) {\n    return pow(c, vec3(1.0/2.2));\n}\n\nvec3 sRGB(in float c) {\n    return pow(vec3(c), vec3(2.2));\n}\n\nvec3 RGB(in float c) {\n    return pow(vec3(c), vec3(1.0/2.2));\n}\n\nvec3 sRGB(in vec4 c) {\n    return pow(c.rgb, vec3(2.2));\n}\n\nvec3 RGB(in vec4 c) {\n    return pow(c.rgb, vec3(1.0/2.2));\n}\n\nvec3 sRGB(in vec2 c) {\n    return pow(vec3(c), vec3(2.2));\n}\n\nvec3 RGB(in vec2 c) {\n    return pow(vec3(c), vec3(1.0/2.2));\n}\n\nvec3 sRGB(in float c) {\n    return pow(vec3(c), vec3(2.2));\n}\n\nvec3 RGB(in float c) {\n    return pow(vec3(c), vec3(1.0/2.2));\n}\n\nvec3 sRGB(in vec3 c) {\n    return pow(c, vec3(2.2));\n}\n\nvec3 RGB(in vec3 c) {\n    return pow(c, vec3(1.0/2.2));\n}\n\nvec3 sRGB(in vec4 c) {\n    return pow(c.rgb, vec3(2.2));\n}\n\nvec3 RGB(in vec4 c) {\n    return pow(c.rgb, vec3(1.0/2.2));\n}\n\nvec3 sRGB(in vec2 c) {\n    return pow(vec3(c), vec3(2.2));\n}\n\nvec3 RGB(in vec2 c) {\n    return pow(vec3(c), vec3(1.0/2.2));\n}\n\nvec3 sRGB(in float", "\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * 0.25 / k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat psmoothmin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * h * (1.0 / 6.0) / k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat psmoothmax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * h * (1.0 / 6.0) / k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat psmoothmin(float a, float b, float k, float n) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * h * pow(1.0 / 6.0, n) / k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat psmoothmax(float a, float b, float k, float n) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) {\n        h = -b - sqrt(h);\n        if( h>0.0 ) {\n            return h;\n        }\n    }\n    return dbuffer;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n   ", "\n    p.xy = abs(p.xy);\n    p.xy = abs(p.xy - 0.5);\n    p.xy = abs(p.xy - 0.25);\n    p.xy = abs(p.xy - 0.125);\n    p.xy = abs(p.xy - 0.0625);\n    p.xy = abs(p.xy - 0.03125);\n    p.xy = abs(p.xy - 0.015625);\n    p.xy = abs(p.xy - 0.0078125);\n    p.xy = abs(p.xy - 0.00390625);\n    p.xy = abs(p.xy - 0.001953125);\n    p.xy = abs(p.xy - 0.0009765625);\n    p.xy = abs(p.xy - 0.00048828125);\n    p.xy = abs(p.xy - 0.000244140625);\n    p.xy = abs(p.xy - 0.0001220703125);\n    p.xy = abs(p.xy - 0.00006103515625);\n    p.xy = abs(p.xy - 0.000030517578125);\n    p.xy = abs(p.xy - 0.0000152587890625);\n    p.xy = abs(p.xy - 0.00000762939453125);\n    p.xy = abs(p.xy - 0.000003814697265625);\n    p.xy = abs(p.xy - 0.0000019073486328125);\n    p.xy =", "\n    vec3 q = vec3( p.x/r.x, p.y/r.y, p.z/r.z );\n    float x = length(q);\n    float y = dot(q, vec3(1.0, 1.0, 1.0));\n    float z = dot(q, vec3(1.0, 1.0, 1.0));\n    float w = dot(q, vec3(1.0, 1.0, 1.0));\n    return vec4( x - r.x, y/r.x, z/r.y, w/r.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec3 r )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float x = length(q);\n    float y = dot(q, vec2(1.0, 1.0));\n    float z = dot(q, vec2(1.0, 1.0));\n    float w = dot(q, vec2(1.0, 1.0));\n    return vec4( x - r.x, y/r.x, z/r.y, w/r.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, vec3 r )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float x = length(q);\n    float y = dot(q", "\n    return vec4(front.rgb * front.a + back.rgb * (1.0 - front.a), front.a + back.a * (1.0 - front.a));\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha) {\n    return vec4(front.rgb * frontAlpha + back.rgb * (1.0 - frontAlpha), frontAlpha + back.a * (1.0 - frontAlpha));\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha, float backAlpha) {\n    return vec4(front.rgb * frontAlpha + back.rgb * (1.0 - frontAlpha), frontAlpha + backAlpha * (1.0 - frontAlpha));\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha, float backAlpha, float backOpacity) {\n    return vec4(front.rgb * frontAlpha + back.rgb * (1.0 - frontAlpha), frontAlpha + backAlpha * (1.0 - frontAlpha) * backOpacity);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha, float backAlpha, float backOpacity, float frontOpacity) {\n    return vec4(front.rgb * frontAlpha * frontOpacity + back.rgb * (1.0 - frontAlpha) * backOpacity, frontAlpha * frontOpacity + backAlpha * (1.0 - frontAlpha) * backOpacity);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha, float backAlpha, float backOpacity, float frontOpacity, float backOpacity2) {\n    return vec4(front.rgb * frontAlpha * frontOpacity + back.rgb * (1.0 - frontAlpha) * backOpacity * backOpacity2, frontAlpha * frontOpacity + backAlpha * (1.0 - frontAlpha) * backOpacity * backOpacity2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float frontAlpha, float backAlpha, float backOpacity, float frontOpacity, float backOpacity2, float frontOpacity2) {\n    return vec4(front.rgb * frontAlpha * frontOpacity * frontOpacity2 + back.rgb * (1.0 - frontAlpha) * backOpacity * back", "\n    return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return alpha * front + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2) {\n    return alpha * front + (1.0 - alpha) * (alpha2 * front + (1.0 - alpha2) * back);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3) {\n    return alpha * front + (1.0 - alpha) * (alpha2 * front + (1.0 - alpha2) * (alpha3 * front + (1.0 - alpha3) * back));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3, float alpha4) {\n    return alpha * front + (1.0 - alpha) * (alpha2 * front + (1.0 - alpha2) * (alpha3 * front + (1.0 - alpha3) * (alpha4 * front + (1.0 - alpha4) * back)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5) {\n    return alpha * front + (1.0 - alpha) * (alpha2 * front + (1.0 - alpha2) * (alpha3 * front + (1.0 - alpha3) * (alpha4 * front + (1.0 - alpha4) * (alpha5 * front + (1.0 - alpha5) * back))));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back", "\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if( p.x + k*p.y > r ) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    float d = dot(p, vec2(-k, 1.0));\n    return -d;\n}\n\nfloat hex(vec2 p, float r, float h ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if( p.x + k*p.y > r ) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    float d = dot(p, vec2(-k, 1.0));\n    return -d;\n}\n\nfloat hex(vec2 p, float r, float h, float s ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if( p.x + k*p.y > r ) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    float d = dot(p, vec2(-k, 1.0));\n    return -d;\n}\n\nfloat hex(vec2 p, float r, float h, float s, float t ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if( p.x + k*p.y > r ) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.", "\n    v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nvec3 tonemap(vec3 color) {\n    return aces_approx(color);\n}\n", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\n               u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n\n    f += 0.5000 * noise2(p);\n    p = p * 2.02;\n    f += 0.2500 * noise2(p);\n    p = p * 2.03;\n    f += 0.1250 * noise2(p);\n    p = p * 2.01;\n    f += 0.0625 * noise2(p);\n\n    return f / 0.9375;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm3(vec3 p) {\n    float f = 0", "\n    float t = Temp / 100.0;\n    float x = t / 1000.0;\n    float y = 1.0 - x;\n    float r = 0.0, g = 0.0, b = 0.0;\n    if (t < 66.0) {\n        r = 255.0;\n        g = 99.4708025861 * log(x) - 161.1195681661;\n        b = 0.0;\n    } else {\n        r = 329.698727446 * pow(x, -0.1332047592);\n        g = 288.1221695283 * pow(x, -0.0755148492) + 15.3781605362;\n        b = 128.0;\n    }\n    return vec3(r, g, b) / 255.0;\n}\n\nvec3 blackbody(float Temp, float x, float y) {\n    float t = Temp / 100.0;\n    float r = 0.0, g = 0.0, b = 0.0;\n    if (t < 66.0) {\n        r = 255.0;\n        g = 99.4708025861 * log(x) - 161.1195681661;\n        b = 0.0;\n    } else {\n        r = 329.698727446 * pow(x, -0.1332047592);\n        g = 288.1221695283 * pow(x, -0.0755148492) + 15.3781605362;\n        b = 128.0;\n    }\n    return vec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( i + vec2(0.0,0.0), i + vec2(0.0,0.0) ), \n                     dot( i + vec2(1.0,0.0), i + vec2(1.0,0.0) ), u.x),\n                mix( dot( i + vec2(0.0,1.0), i + vec2(0.0,1.0) ), \n                     dot( i + vec2(1.0,1.0), i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p;\n    f += 0.25000*noise( p ); p = m*p;\n    f += 0.12500*noise( p ); p = m*p;\n    f += 0.06250*noise( p ); p = m*p;\n    f += 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = m*p;\n    f += 0.25000*noise( p ); p = m*p;\n    f += 0.12500*noise( p ); p = m*p;\n    f += 0.06250*noise( p ); p = m*p;\n    f += 0.03125*noise( p ); p = m*p;\n    f += 0.015625*noise( p ); p = m*p;\n    f += 0.0078125*noise( p", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opU( float d1, float d2 ) { return min(d1,d2); }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opI( float d1, float d2 ) { float h = clamp( 0.5 + 0.5*(d2-d1)/d2, 0.0, 1.0 ); return mix( d2, d1, h ) - h*(1.0-h)*d2*2.0; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opD( float d1, float d2 ) { return max(d1,d2); }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opD( vec3 p, float s ) { return length(p)-s; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat opD( vec3 p, vec3 s ) { p = abs(p  )-s; return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0); }\n\n// License", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = pow(r, 2.0 / n) - 1.0;\n    return vec3(d, d * r / n, a);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse(vec2 p, float n)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = pow(r, 2.0 / n) - 1.0;\n    return vec3(d, d * r / n, a);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdCircle(vec2 p)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = r - 1.0;\n    return vec3(d, d * r, a);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdRectangle(vec2 p, vec2 s)\n{\n    vec2 d = abs(p) - s;\n    float d1 = length(max(d, 0.0));\n    float d2 = min(max(d.x, d.y), 0.0);\n    return vec3(d1 + d2, d1, 0.0);\n}\n\n//.x = f(p", "\n    float y = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float a = 0.0;\n    float b = 1.0;\n    float c = 0.0;\n    float d = 1.0;\n    float e = 0.0;\n    float f = 1.0;\n    float g = 0.0;\n    float h = 1.0;\n    float i = 0.0;\n    float j = 1.0;\n    float k = 0.0;\n    float l = 1.0;\n    float m = 0.0;\n    float n = 1.0;\n    float o = 0.0;\n    float p = 1.0;\n    float q = 0.0;\n    float r = 1.0;\n    float s = 0.0;\n    float t = 1.0;\n    float u = 0.0;\n    float v = 1.0;\n    float w = 0.0;\n    float x = 1.0;\n    float y = 0.0;\n    float z = 1.0;\n    float aa = 0.0;\n    float ab = 1.0;\n    float ac = 0.0;\n    float ad = 1.0;\n    float ae = 0.0;\n    float af = 1.0;\n    float ag = 0.0;\n    float ah = 1.0;\n    float ai = 0.0;\n    float aj = 1.0;\n    float ak = 0.0;\n    float al = 1.0;\n    float am = 0.0;\n    float an = 1.0;\n    float ao = 0.0;\n    float ap = 1.0;\n    float aq = 0.0;\n    float ar = 1.0;\n    float as = 0.0;\n    float at = 1.0;\n    float au = 0.0;\n    float av = 1.0;\n", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness )\n{\n    return abs(length(p)-r)-thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float angleOffset )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float angleOffset, in float angleOffset2 )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float angleOffset, in float angleOffset2, in float angleOffset3 )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float angleOffset, in float angleOffset2, in float angleOffset3, in float angleOffset4 )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in", "\n    float d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float t = 1.0 / (abs(x) + 1.0);\n    float r = (1.0 - t) * (y / (x + 0.01 * sign(x)));\n    r += t * atan(y, x);\n    return r;\n}\n\nfloat atan2_approx(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast_fast_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x, 0.0);\n}\n\nfloat atan2_approx_fast_fast_fast_fast_fast_fast_fast_fast(float y, float x) {\n    return atan_approx(y, x) + PI * step(x", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / dot(w, w);\n}\n\nvec2 cpow(vec2 z, float k) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    return vec2(pow(r, k) * cos(k * theta), pow(r, k) * sin(k * theta));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return cpow(z, w.x) * cpow(vec2(cos(w.y), sin(w.y)), z);\n}\n\nvec2 cpow(vec2 z, vec2 w, float k) {\n    return cpow(z, w.x) * cpow(vec2(cos(w.y), sin(w.y)), z) * cpow(z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec2 k) {\n    return cpow(z, w.x) * cpow(vec2(cos(w.y), sin(w.y)), z) * cpow(z, k.x) * cpow(vec2(cos(k.y), sin(k.y)), z);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec2 k, float l) {\n    return cpow(z, w.x) * cpow(vec2(cos(w.y), sin(w.y)), z) * cpow(z, k.x) * cpow(vec2(cos(k.y), sin(k.y)), z) * cpow(z, l);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec2 k, vec2 l) {\n    return cpow(z, w.x) * cpow", "\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic secant \nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic cosecant \nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cotangent \nvec2 catanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic secant \nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic cosecant \nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cotangent \nvec2 catanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n   ", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return cexp(z) / (cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_prime(vec2 z) {\n    return 1.0 / (cexp(z) + cexp(-z)) - 1.0 / (cexp(z) - cexp(-z));\n}\n\nvec2 ctanh_prime_prime(vec2 z) {\n    return 2.0 / (cexp(z) + cexp(-z)) * (cexp(z) - cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime(vec2 z) {\n    return 2.0 / (cexp(z) + cexp(-z)) * (cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime_prime(vec2 z) {\n    return 4.0 / (cexp(z) + cexp(-z)) * (cexp(z) - cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime_prime_prime(vec2 z) {\n    return 4.0 / (cexp(z) + cexp(-z)) * (cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime_prime_prime_prime(vec2 z) {\n    return 8.0 / (cexp(z) + cexp(-z)) * (cexp(z) - cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime_prime_prime_prime_prime(vec2 z) {\n    return 8.0 / (cexp(z) + cexp(-z)) * (cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_prime_prime_prime_prime_prime_prime_prime_prime(vec2 z) {\n    return 16.0 / (cexp(z) + cexp(-z)) * (cexp", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / dot(w, w);\n}\n\nvec2 cpow(vec2 z, float k) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    return vec2(pow(r, k) * cos(k * theta), pow(r, k) * sin(k * theta));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return cpow(z, w.x) * cpow(w, z);\n}\n\nvec2 cpow(vec2 z, vec2 w, float k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec2 k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec3 k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec4 k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec5 k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec6 k) {\n    return cpow(z, w.x) * cpow(w, z, k);\n}\n\nvec2 cpow(vec2 z, vec2 w, vec7 k) {\n    return cpow(z, w.x) * c", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return cexp(z) / (cexp(z) + cexp(-z));\n}\n\nvec2 csinh(vec2 z) {\n    return (cexp(z) - cexp(-z)) / 2.0;\n}\n\nvec2 ccosh(vec2 z) {\n    return (cexp(z) + cexp(-z)) / 2.0;\n}\n\nvec2 ctanh_inv(vec2 z) {\n    return log(z / (1.0 - z));\n}\n\nvec2 csinh_inv(vec2 z) {\n    return log(z + ccosh(z));\n}\n\nvec2 ccosh_inv(vec2 z) {\n    return log(z + csinh(z));\n}\n\nvec2 ctanh_inv_prime(vec2 z) {\n    return 1.0 / (1.0 - z * z);\n}\n\nvec2 csinh_inv_prime(vec2 z) {\n    return 1.0 / (z + ccosh(z));\n}\n\nvec2 ccosh_inv_prime(vec2 z) {\n    return 1.0 / (z + csinh(z));\n}\n\nvec2 ctanh_prime(vec2 z) {\n    return 1.0 / (cexp(z) + cexp(-z)) / (cexp(z) - cexp(-z));\n}\n\nvec2 csinh_prime(vec2 z) {\n    return 1.0 / (cexp(z) + cexp(-z));\n}\n\nvec2 ccosh_prime(vec2 z) {\n    return 1.0 / (cexp(z) - cexp(-z));\n}\n\nvec2 ctanh_prime_prime(vec2 z) {\n    return -2.0 * ctanh(z) / (cexp(z) - cexp(-z)) / (cexp(z) + cexp(-z));\n}\n\nvec2 csinh", "\n    return vec4(\n        smoothstep(0.0, 1.0, pow(alpha.r, contrast)),\n        smoothstep(0.0, 1.0, pow(alpha.g, contrast)),\n        smoothstep(0.0, 1.0, pow(alpha.b, contrast)),\n        smoothstep(0.0, 1.0, pow(alpha.a, contrast))\n    );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast) {\n    return vec4(\n        smoothstep(0.0, 1.0, pow(alpha.r, contrast.r)),\n        smoothstep(0.0, 1.0, pow(alpha.g, contrast.g)),\n        smoothstep(0.0, 1.0, pow(alpha.b, contrast.b)),\n        smoothstep(0.0, 1.0, pow(alpha.a, contrast.a))\n    );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2) {\n    return vec4(\n        smoothstep(0.0, 1.0, pow(alpha.r, contrast)),\n        smoothstep(0.0, 1.0, pow(alpha.g, contrast2)),\n        smoothstep(0.0, 1.0, pow(alpha.b, contrast)),\n        smoothstep(0.0, 1.0, pow(alpha.a, contrast))\n    );\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrast2, float contrast3) {\n    return vec", "\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Rhombic", "\n  tilingVal3D tile;\n  tile.uvw = uvw;\n  tile.tileType = 1;\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.tileColor = vec3(0.0, 0.0, 0.0);\n  tile.", "\n    vec3 cell = floor(uvw * gridRes);\n    vec3 pos = fract(uvw * gridRes) - 0.5;\n    vec3 cellPos = cell + offset;\n    vec3 cellPos2 = cellPos + vec3(0.5, 0.5, 0.5);\n    vec3 cellPos3 = cellPos + vec3(0.5, 0.5, -0.5);\n    vec3 cellPos4 = cellPos + vec3(0.5, -0.5, 0.5);\n    vec3 cellPos5 = cellPos + vec3(0.5, -0.5, -0.5);\n    vec3 cellPos6 = cellPos + vec3(-0.5, 0.5, 0.5);\n    vec3 cellPos7 = cellPos + vec3(-0.5, 0.5, -0.5);\n    vec3 cellPos8 = cellPos + vec3(-0.5, -0.5, 0.5);\n    vec3 cellPos9 = cellPos + vec3(-0.5, -0.5, -0.5);\n    vec3 cellPos10 = cellPos + vec3(0.5, 0.5, 0.5);\n    vec3 cellPos11 = cellPos + vec3(0.5, 0.5, -0.5);\n    vec3 cellPos12 = cellPos + vec3(0.5, -0.5, 0.5);\n    vec3 cellPos13 = cellPos + vec3(0.5, -0.5, -0.5);\n    vec3 cellPos14 = cellPos + vec3(-0.5, 0.5, 0.5);\n    vec3 cellPos15 = cellPos + vec3(-0.5, 0.5, -0.5);\n    vec3 cellPos16 = cellPos + vec3(-0.5, -0.5, 0.5);\n    vec3 cellPos17 = cellPos + vec3(-0.5, -0.5, -0.5);\n    vec3 cellPos18 = cellPos", "\n    vec3 grid = vec3(0.0);\n    vec3 gridPos = floor(uvw * gridRes);\n    vec3 gridPosF = fract(uvw * gridRes);\n    vec3 gridPosM = mod(gridPos, 2.0);\n    vec3 gridPosE = step(gridPosM, vec3(0.5));\n    vec3 gridPosO = step(gridPosM, vec3(0.0));\n    vec3 gridPosE2 = step(gridPosM, vec3(1.0));\n    vec3 gridPosO2 = step(gridPosM, vec3(0.5));\n    vec3 gridPosE3 = step(gridPosM, vec3(0.25));\n    vec3 gridPosO3 = step(gridPosM, vec3(0.75));\n    vec3 gridPosE4 = step(gridPosM, vec3(0.125));\n    vec3 gridPosO4 = step(gridPosM, vec3(0.875));\n    vec3 gridPosE5 = step(gridPosM, vec3(0.0625));\n    vec3 gridPosO5 = step(gridPosM, vec3(0.9375));\n    vec3 gridPosE6 = step(gridPosM, vec3(0.03125));\n    vec3 gridPosO6 = step(gridPosM, vec3(0.96875));\n    vec3 gridPosE7 = step(gridPosM, vec3(0.015625));\n    vec3 gridPosO7 = step(gridPosM, vec3(0.984375));\n    vec3 gridPosE8 = step(gridPosM, vec3(0.0078125));\n    vec3 gridPosO8 = step(gridPosM, vec3(0.9921875));\n    vec3 gridPosE9 = step(gridPosM, vec3(0.00390625));\n    vec3 gridPosO9 = step(gridPosM, vec3(0.99609375));", "\n    float d = dot(p, normalize(p));\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c) {\n    float d = dot(p - c, normalize(p - c));\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e, float f) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e, float f, float g) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e, float f, float g, float h) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e, float f, float g, float h, float i) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//Icosahedron Distance from Point\nfloat IcoDist(vec3 p, vec3 c, float r, float e, float f, float g, float h, float i, float j) {\n    float d = dot(p - c, normalize(p - c)) - r;\n    return d;\n}\n\n//", "\n    return vec3(\n        pow(t, 3.0) * (3.0 * t - 5.0) + 1.0,\n        pow(t, 2.0) * (t - 1.0),\n        t * t * (2.0 - t)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(\n        pow(t, 3.0) * (3.0 * t - 5.0) + 1.0,\n        pow(t, 2.0) * (t - 1.0),\n        t * t * (2.0 - t)\n    );\n}\n\n// makes CoolWarm colormap with polynimal 6\nvec3 CoolWarm(float t) {\n    return vec3(\n        pow(t, 3.0) * (3.0 * t - 5.0) + 1.0,\n        pow(t, 2.0) * (t - 1.0),\n        t * t * (2.0 - t)\n    );\n}\n\n// makes CoolWarm colormap with polynimal 6\nvec3 CoolWarm(float t) {\n    return vec3(\n        pow(t, 3.0) * (3.0 * t - 5.0) + 1.0,\n        pow(t, 2.0) * (t - 1.0),\n        t * t * (2.0 - t)\n    );\n}\n\n// makes CoolWarm colormap with polynimal 6\nvec3 CoolWarm(float t) {\n    return vec3(\n        pow(t, 3.0) * (3.0 * t - 5.0) + 1.0,\n        pow(t, 2.0) * (t - 1.0),\n        t * t * (2.0 - t)\n    );\n}\n\n// makes CoolWarm colormap with polynimal 6\nvec3 CoolWarm(float t) {\n    return vec3(\n        pow(t, 3.0) * (", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    float t = 1.0 - c;\n    float x = a.x;\n    float y = a.y;\n    float z = a.z;\n    mat3 m = mat3(\n        t*x*x + c, t*x*y - z*s, t*x*z + y*s,\n        t*x*y + z*s, t*y*y + c, t*y*z - x*s,\n        t*x*z - y*s, t*y*z + x*s, t*z*z + c\n    );\n    return m * v;\n}\n\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/Xl2XWt\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// https://www.shadertoy.com/view/Xl2XWt\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = rotate(p, vec3(0.0, 0.0,", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p); p = p * 2.04;\n    f += 0.03125 * noise(p);\n\n    return f / 0.984375;\n}\n\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p); p = p * 2.0", "\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r, float s) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r - s;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r, float s, float t) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r - s - t;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r, float s, float t, float u) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r - s - t - u;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r, float s, float t, float u, float v) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r - s - t - u - v;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, float r, float s, float t, float u, float v, float w) {\n    return (abs(p.x) + abs(p.y) + abs(p.x + p.y)) / 2.0 - r - s - t - u - v - w;\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist", "\n    vec2 p = uv;\n    vec2 q = vec2(p.x * sqrt(3.0), p.y * 3.0 - p.x * (sqrt(3.0) / 2.0));\n    vec2 r = vec2(p.x * 3.0, p.y - p.x * (sqrt(3.0) / 3.0));\n    vec2 s = vec2(p.x * sqrt(3.0) * 2.0, p.y * 3.0 - p.x * (sqrt(3.0) / 2.0) * 2.0);\n    vec2 t = vec2(p.x * 3.0 * 2.0, p.y - p.x * (sqrt(3.0) / 3.0) * 2.0);\n    vec2 u = vec2(p.x * sqrt(3.0) * 3.0, p.y * 3.0 - p.x * (sqrt(3.0) / 2.0) * 3.0);\n    vec2 v = vec2(p.x * 3.0 * 3.0, p.y - p.x * (sqrt(3.0) / 3.0) * 3.0);\n    vec2 w = vec2(p.x * sqrt(3.0) * 4.0, p.y * 3.0 - p.x * (sqrt(3.0) / 2.0) * 4.0);\n    vec2 x = vec2(p.x * 3.0 * 4.0, p.y - p.x * (sqrt(3.0) / 3.0) * 4.0);\n    vec2 y = vec2(p.x * sqrt(3.0) * 5.0, p.y * 3.0 - p.x * (sqrt(3.0) / 2.0) * 5.0);\n    vec2 z = vec2(p.x * 3.0 * 5.0, p.y - p.x * (sqrt(3.0) / 3.", "\n    vec3 a = vec3(0.2980392156862745, 0.4470588235294118, 0.6901960784313725);\n    vec3 b = vec3(0.8941176470588236, 0.8470588235294118, 0.7490196078431373);\n    vec3 c = vec3(0.7686274509803922, 0.803921568627451, 0.596078431372549);\n    vec3 d = vec3(0.6313725490196078, 0.6588235294117647, 0.5058823529411764);\n    vec3 e = vec3(0.49019607843137253, 0.5019607843137255, 0.40784313725490196);\n    vec3 f = vec3(0.34901960784313724, 0.3607843137254902, 0.27058823529411763);\n    vec3 g = vec3(0.20784313725490197, 0.24705882352941178, 0.19607843137254902);\n    vec3 h = vec3(0.1568627450980392, 0.", "\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to 0-10\nfloat make0to10(float x) {\n    return x * 10.0;\n}\n\n//shifts value range from 0-1 to 0-100\nfloat make0to100(float x) {\n    return x * 100.0;\n}\n\n//shifts value range from 0-1 to 0-1000\nfloat make0to1000(float x) {\n    return x * 1000.0;\n}\n\n//shifts value range from 0-1 to 0-10000\nfloat make0to10000(float x) {\n    return x * 10000.0;\n}\n\n//shifts value range from 0-1 to 0-100000\nfloat make0to100000(float x) {\n    return x * 100000.0;\n}\n\n//shifts value range from 0-1 to 0-1000000\nfloat make0to1000000(float x) {\n    return x * 1000000.0;\n}\n\n//shifts value range from 0-1 to 0-10000000\nfloat make0to10000000(float x) {\n    return x * 10000000.0;\n}\n\n//shifts value range from 0-1 to 0-100000000\nfloat make0to100000000(float x) {\n    return x * 100000000.0;\n}\n\n//shifts value range from 0-1 to 0-1000000000\nfloat make", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 cell = fract(uv * gridRes);\n    vec2 cellOffset = fract(offset * gridRes);\n    vec2 cellCenter = (grid + cellOffset) / gridRes;\n    vec2 cellCenterOffset = cellCenter - cell;\n    float cellDist = length(cellCenterOffset);\n    float cellLen = len * (1.0 - cellDist);\n    float cellTime = time + cellLen;\n    float cellWave = sin(cellTime * 10.0) * 0.5 + 0.5;\n    return cellWave;\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float wave = 0.0;\n    for (int i = 0; i < 6; i++) {\n        float angle = float(i) * 60.0 * PI / 180.0;\n        vec2 dir = vec2(cos(angle), sin(angle));\n        wave += flowHexCell(uv, offset + dir, gridRes, time, len);\n    }\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowHex2(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float wave = 0.0;\n    for (int i = 0; i < 6; i++) {\n        float angle = float(i) * 60.0 * PI / 180.0;\n        vec2 dir = vec2(cos(angle), sin(angle));\n        wave += flowHexCell(uv, offset + dir, gridRes, time, len);\n    }\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowHex3(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float wave = 0.0;\n    for (int i = 0; i < 6; i++) {\n        float angle = float(i) * 60.0 * PI / 180.0;\n        vec2 dir = vec2(cos(angle), sin", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 pos = fract(uv * gridRes);\n    vec2 vel = vec2(0.0);\n    float d = 0.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 vel = texture(iChannel0, (grid + neighbor) / gridRes).xy;\n            vec2 diff = neighbor - pos;\n            d += sin(dot(diff, vel) * len + time) / dot(diff, diff);\n        }\n    }\n    return d;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow2(vec2 uv, float gridRes, float time, float len) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 pos = fract(uv * gridRes);\n    vec2 vel = vec2(0.0);\n    float d = 0.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 vel = texture(iChannel0, (grid + neighbor) / gridRes).xy;\n            vec2 diff = neighbor - pos;\n            d += sin(dot(diff, vel) * len + time) / dot(diff, diff);\n        }\n    }\n    return d;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow3(vec2 uv, float gridRes, float time, float len) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 pos = fract(uv * gridRes);\n    vec2 vel = vec2(0.0);\n    float d = 0.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n", "\n    float angle = atan(point.y, point.x);\n    float speed = 0.005;\n    float noise = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    float flow = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    return vec2(cos(angle + noise), sin(angle + noise)) * flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow2(vec2 point, float radius, float time) {\n    float angle = atan(point.y, point.x);\n    float speed = 0.005;\n    float noise = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    float flow = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    return vec2(cos(angle + noise), sin(angle + noise)) * flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow3(vec2 point, float radius, float time) {\n    float angle = atan(point.y, point.x);\n    float speed = 0.005;\n    float noise = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    float flow = 0.005 * (sin(angle * 10.0 + time * 10.0) + 1.0);\n    return vec2(cos(angle + noise), sin(angle + noise)) * flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow4(vec2 point, float radius, float time) {\n    float angle = atan(point.y, point.x);\n    float speed = 0.005;\n    float noise = 0.005 * (sin(angle", "\n    vec2 tile = floor(pos / TILE_SIZE);\n    return tile * TILE_SIZE + TILE_SIZE / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n    vec2 tile = floor((pos - tileOffset) / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSizeOffset) {\n    vec2 tile = floor((pos - tileOffset - tileSizeOffset) / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileSizeOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSizeOffset, vec2 tileSizeOffset2) {\n    vec2 tile = floor((pos - tileOffset - tileSizeOffset - tileSizeOffset2) / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileSizeOffset + tileSizeOffset2;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSizeOffset, vec2 tileSizeOffset2, vec2 tileSizeOffset3) {\n    vec2 tile = floor((pos - tileOffset - tileSizeOffset - tileSizeOffset2 - tileSizeOffset3) / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileSizeOffset + tileSizeOffset2 + tileSizeOffset3;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTile", "\n    vec2 d = p2 - p1;\n    vec2 f = p - p1;\n    float t = dot(f, d) / dot(d, d);\n    t = clamp(t, 0.0, 1.0);\n    return length(f - d * t);\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\n// Computes the signed distance from a rectangle\nfloat rect(vec2 p, vec2 c, vec2 s) {\n    vec2 d = abs(p - c) - s;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Computes the signed distance from a rounded rectangle\nfloat roundedRect(vec2 p, vec2 c, vec2 s, float r) {\n    vec2 d = abs(p - c) - s;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float s = sign(dot(cross(ba, pa), ca));\n    return length(cross(ba, pa)) * s;\n}\n\n// Computes the signed distance from a polygon\nfloat polygon(vec2 p, vec2 c, float r, int n) {\n    float a = atan(p.y - c.y, p.x - c.x);\n    float da = TAU / float(n);\n    float d = length(p - c);\n    float v = abs(sin(floor(0.5 + a / da) * da - a));\n    return d * v;\n}\n\n// Computes the signed distance from a star\nfloat star(vec2 p, vec2 c, float r, float R, int n) {", "\n    float a = atan(v.y, v.x);\n    float d = length(v);\n    float da = 0.05;\n    float da2 = 0.025;\n    float da3 = 0.0125;\n    float da4 = 0.00625;\n    float da5 = 0.003125;\n    float da6 = 0.0015625;\n    float da7 = 0.00078125;\n    float da8 = 0.000390625;\n    float da9 = 0.0001953125;\n    float da10 = 0.00009765625;\n    float da11 = 0.000048828125;\n    float da12 = 0.0000244140625;\n    float da13 = 0.00001220703125;\n    float da14 = 0.000006103515625;\n    float da15 = 0.0000030517578125;\n    float da16 = 0.00000152587890625;\n    float da17 = 0.000000762939453125;\n    float da18 = 0.0000003814697265625;\n    float da19 = 0.00000019073486328125;\n    float da20 = 0.000000095367431640625;\n    float da21 = 0.0000000476837158203125;\n    float da22 = 0.0000", "\n    return (x + 1.0) * 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeNeg1to1(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to 0-2\nvec2 make0to2(vec2 x) {\n    return x * 2.0;\n}\n\n//shifts value range from 0-1 to 0-10\nvec2 make0to10(vec2 x) {\n    return x * 10.0;\n}\n\n//shifts value range from 0-1 to 0-100\nvec2 make0to100(vec2 x) {\n    return x * 100.0;\n}\n\n//shifts value range from 0-1 to 0-1000\nvec2 make0to1000(vec2 x) {\n    return x * 1000.0;\n}\n\n//shifts value range from 0-1 to 0-10000\nvec2 make0to10000(vec2 x) {\n    return x * 10000.0;\n}\n\n//shifts value range from 0-1 to 0-100000\nvec2 make0to100000(vec2 x) {\n    return x * 100000.0;\n}\n\n//shifts value range from 0-1 to 0-1000000\nvec2 make0to1000000(vec2 x) {\n    return x * 1000000.0;\n}\n\n//shifts value range from 0-1 to 0-10000000\nvec2 make0to10000000(vec2 x) {\n    return x * 10000000.0;\n}\n\n//shifts value range from 0-1 to 0-100000000\nvec2 make0to1000", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angle2 = angle + (radius * spread) + offset;\n    return vec2(cos(angle2), sin(angle2));\n}\n\n// makes a simple flowmap in the shape of a swirl centered on point\nvec2 swirlFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angle2 = angle + (radius * spread) + offset;\n    return vec2(cos(angle2), sin(angle2));\n}\n\n// makes a simple flowmap in the shape of a swirl centered on point\nvec2 swirlFlow(vec2 point, float spread, float offset, float radius)\n{\n    float angle = atan(point.y, point.x);\n    float radius2 = length(point);\n    float angle2 = angle + (radius2 * spread) + offset;\n    return vec2(cos(angle2), sin(angle2)) * radius;\n}\n\n// makes a simple flowmap in the shape of a swirl centered on point\nvec2 swirlFlow(vec2 point, float spread, float offset, float radius, float radius2)\n{\n    float angle = atan(point.y, point.x);\n    float radius3 = length(point);\n    float angle2 = angle + (radius3 * spread) + offset;\n    return vec2(cos(angle2), sin(angle2)) * radius * radius2;\n}\n\n// makes a simple flowmap in the shape of a swirl centered on point\nvec2 swirlFlow(vec2 point, float spread, float offset, float radius, float radius2, float radius3)\n{\n    float angle = atan(point.y, point.x);\n    float radius4 = length(point);\n    float angle2 = angle + (radius4 * spread) + offset;\n    return vec2(cos(angle2), sin(angle2)) * radius * radius2 * radius3;\n}\n\n// makes a simple flowmap in the shape of a swirl centered on point\nvec2 swirlFlow", "\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n  return length(p) - r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation, in float scale ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation, in float scale, in float offset ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation, in float scale, in float offset, in float rotationOffset ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation, in float scale, in float offset, in float rotationOffset, in float scaleOffset ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float angle, in float rotation, in float scale, in float offset, in float rotationOffset, in float scaleOffset, in float offsetOffset ) \n{\n  return abs(length(p) - r) - thickness;\n}\n\nfloat sdCircle( in", "\n    float d = 0.0;\n    float s = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = abs(mod(a+time,sp)-sp*0.5)-ra;\n    return min(r,max(h,0.0));\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float thickness )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = abs(mod(a+time,sp)-sp*0.5)-ra;\n    return max(r,max(h,0.0)) - thickness;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float thickness, float thickness2 )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = abs(mod(a+time,sp)-sp*0.5)-ra;\n    return max(r,max(h,0.0)) - thickness - thickness2;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float thickness, float thickness2, float thickness3 )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = abs(mod(a+time,sp)-sp*0.5)-ra;\n    return max(r,max(h,0.0)) - thickness - thickness2 - thickness3;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float thickness, float thickness2, float thickness3, float thickness4 )\n{\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = abs(mod(a+time,sp)-sp*0.5)-ra;\n    return max(r,max(h,0.0)) - thickness - thickness2 - thickness3 - thickness4;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra", "\n    vec3 cube = abs(uvw) - 1.0;\n    return length(max(cube, 0.0)) + min(max(cube.x, max(cube.y, cube.z)), 0.0);\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 1.0;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    vec2 q = vec2(length(uvw.xy) - 1.0, uvw.z);\n    return length(q) - 1.0;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return max(length(uvw.xy) - 1.0, abs(uvw.z) - 1.0);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float d = length(uvw.xy);\n    return max(d - uvw.z, abs(uvw.z) - 1.0);\n}\n\n//edge distance of a Plane\nfloat planeDist(vec3 uvw) {\n    return uvw.z;\n}\n\n//edge distance of a Box\nfloat boxDist(vec3 uvw) {\n    vec3 cube = abs(uvw) - 1.0;\n    return length(max(cube, 0.0)) + min(max(cube.x, max(cube.y, cube.z)), 0.0);\n}\n\n//edge distance of a Hexagon\nfloat hexagonDist(vec3 uvw) {\n    vec2 q = vec2(abs(uvw.x) - 1.0, uvw.y);\n    return length(max(q.xy, 0.0)) + min(max(q.x, q.y), 0.0) - 1.0;\n}\n\n//edge distance of a Octagon\nfloat octagonDist(vec3 uvw) {\n    vec2 q = vec2(abs(uvw.x) - 1.0, uvw.y);\n    return", "\n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw2 * uvw2;\n    vec3 uvw4 = uvw3 * uvw2;\n    vec3 uvw5 = uvw4 * uvw2;\n    vec3 uvw6 = uvw5 * uvw2;\n    vec3 uvw7 = uvw6 * uvw2;\n    vec3 uvw8 = uvw7 * uvw2;\n    vec3 uvw9 = uvw8 * uvw2;\n    vec3 uvw10 = uvw9 * uvw2;\n    vec3 uvw11 = uvw10 * uvw2;\n    vec3 uvw12 = uvw11 * uvw2;\n    vec3 uvw13 = uvw12 * uvw2;\n    vec3 uvw14 = uvw13 * uvw2;\n    vec3 uvw15 = uvw14 * uvw2;\n    vec3 uvw16 = uvw15 * uvw2;\n    vec3 uvw17 = uvw16 * uvw2;\n    vec3 uvw18 = uvw17 * uvw2;\n    vec3 uvw19 = uvw18 * uvw2;\n    vec3 uvw20 = uvw19 * uvw2;\n    vec3 uvw21 = uvw20 * uvw2;\n    vec3 uvw22 = uvw21 * uvw2;\n    vec3 uvw23 = uvw22 * uvw2;\n    vec3 uvw24 = uvw23 * uvw2;\n    vec3 uvw25 = uvw24 * uvw2;\n    vec3 uvw26 = uvw25 * uvw2;\n    vec3 uvw27 = uvw26 * uvw2;\n    vec3 uvw28 = uvw27 * uvw2;\n    vec3 uvw29 = uvw28 * uvw2;\n    vec3 uvw30 = uvw29 * uvw2;\n    vec3 uvw3", "\n    vec3 cell = floor(uvw * gridRes) + offset;\n    vec3 cellCenter = cell + 0.5;\n    vec3 cellSize = 1.0 / gridRes;\n    vec3 cellCenterUVW = cellCenter * cellSize;\n    vec3 cellCenterUVWOffset = cellCenterUVW - offset;\n    vec3 cellCenterUVWOffsetScaled = cellCenterUVWOffset * gridRes;\n    vec3 cellCenterUVWOffsetScaledOffset = cellCenterUVWOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaled = cellCenterUVWOffsetScaledOffset * gridRes;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffset = cellCenterUVWOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaled = cellCenterUVWOffsetScaledOffsetScaledOffset * gridRes;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffset = cellCenterUVWOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaled = cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffset = cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled = cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffset = cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled = cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScaled + offset;\n    vec3 cellCenterUVWOffsetScaledOffsetScaledOffsetScaledOffsetScaledOffsetScal", "\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    if (t > 1.0) {\n        t = 1.0;\n    }\n    if (t < 0.5) {\n        r = 2.0 * t;\n        g = 2.0 * t - 1.0;\n    } else {\n        r = 2.0 * t - 1.0;\n        g = -2.0 * t + 3.0;\n    }\n    if (r < 0.0) {\n        r = 0.0;\n    }\n    if (r > 1.0) {\n        r = 1.0;\n    }\n    if (g < 0.0) {\n        g = 0.0;\n    }\n    if (g > 1.0) {\n        g = 1.0;\n    }\n    if (t < 0.25) {\n        b = 4.0 * t;\n    } else if (t < 0.75) {\n        b = -4.0 * t + 2.0;\n    } else {\n        b = 4.0 * t - 3.0;\n    }\n    if (b < 0.0) {\n        b = 0.0;\n    }\n    if (b > 1.0) {\n        b = 1.0;\n    }\n    return vec3(r, g, b);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r_2(float t) {\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    if (t > 1.0) {\n", "\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Rhombicuboctahedron\nfloat rhocDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Rhombicosidodecahedron\nfloat rhodDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Icosidodecahedron\nfloat icodDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodeDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    return d;\n}\n\n//Distance from the", "\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes blackbody colormap with polynimal 6\nvec3 blackbody(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes jet colormap with polynimal 6\nvec3 jet(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes hot colormap with polynimal 6\nvec3 hot(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 1.0),\n        pow(t, 1.0)\n   ", "\n    vec2 uv_ = uv * 2.0;\n    vec2 uv_i = floor(uv_);\n    vec2 uv_f = fract(uv_);\n    vec2 uv_c = uv_i + 0.5;\n    vec2 uv_s = uv_c + uv_f;\n    vec2 uv_e = uv_c - uv_f;\n    vec2 uv_n = uv_s + vec2(0.0, 1.0);\n    vec2 uv_w = uv_s + vec2(1.0, 0.0);\n    vec2 uv_ne = uv_e + vec2(0.0, 1.0);\n    vec2 uv_nw = uv_e + vec2(1.0, 0.0);\n    vec3 color = vec3(0.0);\n    color += texture2D(u_texture, uv_s).rgb;\n    color += texture2D(u_texture, uv_n).rgb;\n    color += texture2D(u_texture, uv_w).rgb;\n    color += texture2D(u_texture, uv_ne).rgb;\n    color += texture2D(u_texture, uv_nw).rgb;\n    color /= 5.0;\n    return color;\n}\n\n// simple square Tiling\nvec3 squareTile2(vec2 uv) {\n    vec2 uv_ = uv * 2.0;\n    vec2 uv_i = floor(uv_);\n    vec2 uv_f = fract(uv_);\n    vec2 uv_c = uv_i + 0.5;\n    vec2 uv_s = uv_c + uv_f;\n    vec2 uv_e = uv_c - uv_f;\n    vec2 uv_n = uv_s + vec2(0.0, 1.0);\n    vec2 uv_w = uv_s + vec2(1.0, 0.0);\n    vec2 uv_ne = uv_e + vec2(0.0, 1.0);\n    vec2 uv_nw = uv_e + vec2(1.0, 0.0);\n    vec3 color = vec3", "\n    vec2 p = uv;\n    p.x = abs(p.x);\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x, -p.y);\n    vec2 s = vec2(-p.x, p.y);\n    vec2 t = vec2(-p.x, -p.y);\n    float d = min(min(length(q), length(r)), min(length(s), length(t)));\n    return vec3(d, 0.0, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale) {\n    vec2 p = uv;\n    p.x = abs(p.x);\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x, -p.y);\n    vec2 s = vec2(-p.x, p.y);\n    vec2 t = vec2(-p.x, -p.y);\n    float d = min(min(length(q), length(r)), min(length(s), length(t)));\n    return vec3(d, 0.0, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset) {\n    vec2 p = uv;\n    p.x = abs(p.x);\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x, -p.y);\n    vec2 s = vec2(-p.x, p.y);\n    vec2 t = vec2(-p.x, -p.y);\n    float d = min(min(length(q), length(r)), min(length(s), length(t)));\n    return vec3(d, 0.0, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float time) {\n    vec2 p = uv;\n    p.x = abs(p", "\n    vec2 grid = vec2(gridRes);\n    vec2 pixel = vec2(1.0) / grid;\n    vec2 pixelOffset = pixel * offset;\n    vec2 pixelPos = floor(uv * grid + pixelOffset) * pixel;\n    return texture2D(u_texture, pixelPos).rgb;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes) {\n    return squarePixelizor(uv, gridRes, vec2(0.0));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset) {\n    return squarePixelizor(uv, gridRes, vec2(offset));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale) {\n    return squarePixelizor(uv * scale, gridRes, offset) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float scale) {\n    return squarePixelizor(uv * scale, gridRes, vec2(offset)) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float offset2) {\n    return squarePixelizor(uv * scale, gridRes, offset + offset2) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float scale, float offset2) {\n    return squarePixelizor(uv * scale, gridRes, vec2(offset) + offset2) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, vec2 offset2) {\n    return squarePixelizor(uv * scale, gridRes, offset + offset2) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float", "\n    vec2 grid = vec2(gridRes);\n    vec2 gridSize = vec2(1.0) / grid;\n    vec2 gridPos = floor(uv * grid) * gridSize;\n    vec2 gridPosCenter = gridPos + gridSize * 0.5;\n    vec2 gridPosOffset = gridPosCenter - uv;\n    float dist = length(gridPosOffset);\n    float pixelSize = 1.0 / gridRes;\n    float pixelSizeHalf = pixelSize * 0.5;\n    float pixelSizeQuarter = pixelSize * 0.25;\n    float pixelSizeEighth = pixelSize * 0.125;\n    float pixelSizeSixteenth = pixelSize * 0.0625;\n    float pixelSizeThirtySecond = pixelSize * 0.03125;\n    float pixelSizeSixtyFourth = pixelSize * 0.015625;\n    float pixelSizeOneHundredTwentyEighth = pixelSize * 0.0078125;\n    float pixelSizeTwoHundredFiftySixth = pixelSize * 0.00390625;\n    float pixelSizeFiveHundredTwelfth = pixelSize * 0.001953125;\n    float pixelSizeOneThousandTwentyFourth = pixelSize * 0.0009765625;\n    float pixelSizeTwoThousandFortyEighth = pixelSize * 0.00048828125;\n    float pixelSizeFourThousandNinetySixth = pixelSize * 0.000244140625;\n    float pixelSizeEightThousandOneHundredNinetySecond = pixelSize * 0.0001220703125;\n    float pixelSizeSixteenThousandThreeHundredEighth = pixelSize * 0.00006103515625;\n    float pixelSizeThirtyTwoThousandSevenHundredFortyFourth = pixelSize * 0.000030517578125;\n    float pixelSizeSixtyFourThousandOneHundredFortyEighth", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 cell = fract(uv * gridRes);\n    vec2 cellOffset = vec2(0.5) - cell;\n    vec2 cellCenter = grid + cellOffset;\n    vec2 cellCenterOffset = cellOffset * len;\n    vec2 cellCenterOffset2 = cellCenterOffset * 0.5;\n    vec2 cellCenterOffset3 = cellCenterOffset * 0.25;\n    vec2 cellCenterOffset4 = cellCenterOffset * 0.125;\n    vec2 cellCenterOffset5 = cellCenterOffset * 0.0625;\n    vec2 cellCenterOffset6 = cellCenterOffset * 0.03125;\n    vec2 cellCenterOffset7 = cellCenterOffset * 0.015625;\n    vec2 cellCenterOffset8 = cellCenterOffset * 0.0078125;\n    vec2 cellCenterOffset9 = cellCenterOffset * 0.00390625;\n    vec2 cellCenterOffset10 = cellCenterOffset * 0.001953125;\n    vec2 cellCenterOffset11 = cellCenterOffset * 0.0009765625;\n    vec2 cellCenterOffset12 = cellCenterOffset * 0.00048828125;\n    vec2 cellCenterOffset13 = cellCenterOffset * 0.000244140625;\n    vec2 cellCenterOffset14 = cellCenterOffset * 0.0001220703125;\n    vec2 cellCenterOffset15 = cellCenterOffset * 0.00006103515625;\n    vec2 cellCenterOffset16 = cellCenterOffset * 0.000030517578125;\n    vec2 cellCenterOffset17 = cellCenterOffset * 0.0000152587890625;\n    vec2 cellCenterOffset18 = cellCenterOffset * 0.00000762939", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 cell = fract(uv * gridRes);\n    vec2 cellCenter = (grid + 0.5) / gridRes;\n    vec2 cellCenterOffset = cellCenter - 0.5;\n    float cellCenterDist = length(cellCenterOffset);\n    float cellCenterDist2 = cellCenterDist * cellCenterDist;\n    float cellCenterDist3 = cellCenterDist2 * cellCenterDist;\n    float cellCenterDist4 = cellCenterDist3 * cellCenterDist;\n    float cellCenterDist5 = cellCenterDist4 * cellCenterDist;\n    float cellCenterDist6 = cellCenterDist5 * cellCenterDist;\n    float cellCenterDist7 = cellCenterDist6 * cellCenterDist;\n    float cellCenterDist8 = cellCenterDist7 * cellCenterDist;\n    float cellCenterDist9 = cellCenterDist8 * cellCenterDist;\n    float cellCenterDist10 = cellCenterDist9 * cellCenterDist;\n    float cellCenterDist11 = cellCenterDist10 * cellCenterDist;\n    float cellCenterDist12 = cellCenterDist11 * cellCenterDist;\n    float cellCenterDist13 = cellCenterDist12 * cellCenterDist;\n    float cellCenterDist14 = cellCenterDist13 * cellCenterDist;\n    float cellCenterDist15 = cellCenterDist14 * cellCenterDist;\n    float cellCenterDist16 = cellCenterDist15 * cellCenterDist;\n    float cellCenterDist17 = cellCenterDist16 * cellCenterDist;\n    float cellCenterDist18 = cellCenterDist17 * cellCenterDist;\n    float cellCenterDist19 = cellCenterDist18 * cellCenterDist;\n    float cellCenterDist20 = cellCenterDist19 * cellCenterDist;\n    float cellCenterDist21 = cellCenterDist20 * cellCenterDist;\n    float cellCenterDist22 = cellCenterDist21 * cellCenterDist;\n    float cellCenterDist23 = cellCenterDist22 * cellCenterDist;\n    float cellCenterDist24 = cellCenterDist23 * cellCenterDist;\n    float cellCenterDist25 = cellCenterDist24 * cellCenterDist;", "\n    vec2 w = fwidth( p );\n    vec2 i = floor( p );\n    vec2 f = p - i;\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return ( 1.0 - u.x ) * ( 1.0 - u.y ) * textureGrad( iChannel0, i / iResolution.xy, ddx, ddy ).x +\n           ( 1.0 - u.x ) * u.y * textureGrad( iChannel0, ( i + vec2( 0.0, 1.0 ) ) / iResolution.xy, ddx, ddy ).x +\n           u.x * ( 1.0 - u.y ) * textureGrad( iChannel0, ( i + vec2( 1.0, 0.0 ) ) / iResolution.xy, ddx, ddy ).x +\n           u.x * u.y * textureGrad( iChannel0, ( i + vec2( 1.0, 1.0 ) ) / iResolution.xy, ddx, ddy ).x;\n}\n\nfloat gridTextureGradBox( in vec2 p )\n{\n    return gridTextureGradBox( p, dFdx( p ), dFdy( p ) );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGradBox( p * scale, ddx * scale, ddy * scale );\n}\n\nfloat gridTextureGradBox( in vec2 p, in float scale )\n{\n    return gridTextureGradBox( p, dFdx( p ), dFdy( p ), scale );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset )\n{\n    return gridTextureGradBox( p * scale + offset, ddx * scale, ddy * scale );\n}\n\nfloat gridTextureGradBox( in vec2 p, in float scale, in float offset )\n{\n    return gridTextureGradBox( p, dFdx( p ), dFdy( p ), scale, offset );\n", "\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if (p.x + k * p.y > r) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    vec2 q = vec2(p.x, p.y * k);\n    return length(max(q.x, q.y) * vec2(1.0, k) + min(q.x, q.y) * vec2(0.0, 1.0)) - r * 0.5;\n}\n\nfloat hexagon(vec2 p, float r, float h) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if (p.x + k * p.y > r) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    vec2 q = vec2(p.x, p.y * k);\n    return length(max(q.x, q.y) * vec2(1.0, k) + min(q.x, q.y) * vec2(0.0, 1.0)) - r * 0.5;\n}\n\nfloat hexagon(vec2 p, float r, float h, float w) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    if (p.x + k * p.y > r) return length(p - vec2(clamp(p.x, -r, r), r * k - p.y));\n    p.x -= r;\n    p.y -= r * k;\n    vec2 q = vec2(p.x, p.y * k);\n    return length(max(q.", "\n    p = mod(p, 2.0);\n    return p;\n}\n\nvec2 hexround(vec2 p) {\n    return round(p);\n}\n\nvec2 hexcorner(int i) {\n    float angle = 2.0 * PI / 6.0 * (float(i) + 0.5);\n    return vec2(cos(angle), sin(angle));\n}\n\nvec2 hexneighbor(vec2 p, int i) {\n    return p + hexcorner(i);\n}\n\nvec2 hexneighbor(vec2 p, int i, float size) {\n    return p + hexcorner(i) * size;\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset) {\n    return p + hexcorner(i) * size + vec2(0.0, offset);\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset, float rotation) {\n    return p + hexcorner(i) * size + vec2(0.0, offset) * rotation;\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset, float rotation, float rotationOffset) {\n    return p + hexcorner(i) * size + vec2(0.0, offset) * rotation + vec2(0.0, rotationOffset);\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset, float rotation, float rotationOffset, float rotationOffset2) {\n    return p + hexcorner(i) * size + vec2(0.0, offset) * rotation + vec2(0.0, rotationOffset) * rotationOffset2;\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset, float rotation, float rotationOffset, float rotationOffset2, float rotationOffset3) {\n    return p + hexcorner(i) * size + vec2(0.0, offset) * rotation + vec2(0.0, rotationOffset) * rotationOffset2 + vec2(0.0, rotationOffset3);\n}\n\nvec2 hexneighbor(vec2 p, int i, float size, float offset, float rotation, float rotationOffset, float rotation", "\n    return 0.5 + 0.5*sin( 6.28318*(x + 0.5*sin(x*x*x) ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( fun(n+0.0), fun(n+1.0),f.x), mix( fun(n+57.0), fun(n+58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p;\n    f += 0.25000*noise( p ); p = m*p;\n    f += 0.12500*noise( p ); p = m*p;\n    f += 0.06250*noise( p ); p = m*p;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat fbm2( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p;\n    f += 0.25000*noise( p ); p = m*p;\n    f += 0.12500*noise( p ); p = m*p;\n    f += 0.06250*noise( p ); p = m*p;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat fbm3( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p", "\n    return pow(t, vec3(2.2));\n}\n\nvec3 RGB(vec3 t) {\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGB(float t) {\n    return pow(t, 2.2);\n}\n\nfloat RGB(float t) {\n    return pow(t, 1.0 / 2.2);\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return pow(t, vec3(gamma));\n}\n\nvec3 RGB(vec3 t, float gamma) {\n    return pow(t, vec3(1.0 / gamma));\n}\n\nvec3 sRGB(float t, float gamma) {\n    return pow(t, gamma);\n}\n\nfloat RGB(float t, float gamma) {\n    return pow(t, 1.0 / gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma) {\n    return pow(t, gamma);\n}\n\nvec3 RGB(vec3 t, vec3 gamma) {\n    return pow(t, vec3(1.0) / gamma);\n}\n\nvec3 sRGB(float t, vec3 gamma) {\n    return pow(t, gamma);\n}\n\nfloat RGB(float t, vec3 gamma) {\n    return pow(t, 1.0 / gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, vec3 offset) {\n    return pow(t - offset, gamma);\n}\n\nvec3 RGB(vec3 t, vec3 gamma, vec3 offset) {\n    return pow(t, vec3(1.0) / gamma) + offset;\n}\n\nvec3 sRGB(float t, vec3 gamma, vec3 offset) {\n    return pow(t - offset, gamma);\n}\n\nfloat RGB(float t, vec3 gamma, vec3 offset) {\n    return pow(t, 1.0 / gamma) + offset;\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, float offset) {\n    return pow(t - offset, gamma);\n}\n\nvec3 RGB(vec", "\n    p = abs(p);\n    return max(p.x, p.y);\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 0.2;\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 0.4;\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 0.6;\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 0.8;\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 1.0;\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 1.2;\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 1.4;\n}\n\n// Classic truchet pattern\nfloat df8(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 1.6;\n}\n\n// Classic truchet pattern\nfloat df9(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 1.8;\n}\n\n// Classic truchet pattern\nfloat df10(vec2 p) {\n    p = abs(p);\n    return max(p.x, p.y) - 2.0;\n}\n\n// Classic truchet pattern\nfloat df11(vec2 p) {\n    p = abs(p);\n   ", "\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float f = fract(a * 0.14285714285714285714285714285714);\n    float g = fract(r * 0.14285714285714285714285714285714);\n    float h = fract(a * 0.28571428571428571428571428571428);\n    float i = fract(r * 0.28571428571428571428571428571428);\n    float j = fract(a * 0.42857142857142857142857142857143);\n    float k = fract(r * 0.42857142857142857142857142857143);\n    float l = fract(a * 0.57142857142857142857142857142857);\n    float m = fract(r * 0.57142857142857142857142857142857);\n    float n = fract(a * 0.71428571428571428571428571428571);\n    float o = fract(r * 0.71428571428571428571428571428571);\n    float p = fract(a * 0.8571428571428571428571428", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// signed distance to a 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    return (length(p-c)-r.x)*r.y;\n}\n\n// signed distance to a 2D rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s )\n{\n    p = abs(p-c)-s;\n    return length(max", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) {\n        h = -b - sqrt(h);\n        if( h>0.0 ) {\n            return h;\n        }\n    }\n    return dbuffer;\n}\n\nfloat spheref(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) {\n        h = -b - sqrt(h);\n        if( h>0.0 ) {\n            return h;\n        }\n    }\n    return dbuffer;\n}\n\nfloat spherei(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) {\n        h = -b - sqrt(h);\n        if( h>0.0 ) {\n            return h;\n        }\n    }\n    return dbuffer;\n}\n\nfloat sphereu(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) {\n        h = -b - sqrt(h);\n        if( h>0.0 ) {\n            return h;\n        }\n    }\n    return dbuffer;\n}\n\nfloat sphere", "\n    p.x += w * 0.5;\n    float d = p.x;\n    d = max(d, abs(p.x + w * 0.5) - r);\n    d = max(d, abs(p.x - w * 0.5) - r);\n    return d;\n}\n\nfloat roundedY(vec2 p, float w, float r) {\n    p.y += w * 0.5;\n    float d = p.y;\n    d = max(d, abs(p.y + w * 0.5) - r);\n    d = max(d, abs(p.y - w * 0.5) - r);\n    return d;\n}\n\nfloat rounded(vec2 p, float w, float r) {\n    return max(roundedX(p, w, r), roundedY(p, w, r));\n}\n\nfloat rounded(vec2 p, float w, float r, float d) {\n    return max(roundedX(p, w, r), roundedY(p, w, r)) - d;\n}\n\nfloat rounded(vec2 p, float w, float r, float d, float s) {\n    return max(roundedX(p, w, r), roundedY(p, w, r)) - d - s;\n}\n\nfloat rounded(vec2 p, float w, float r, float d, float s, float t) {\n    return max(roundedX(p, w, r), roundedY(p, w, r)) - d - s - t;\n}\n\nfloat rounded(vec2 p, float w, float r, float d, float s, float t, float u) {\n    return max(roundedX(p, w, r), roundedY(p, w, r)) - d - s - t - u;\n}\n\nfloat rounded(vec2 p, float w, float r, float d, float s, float t, float u, float v) {\n    return max(roundedX(p, w, r), roundedY(p, w, r)) - d - s - t - u - v;\n}\n\nfloat rounded(vec2 p, float w, float r,", "\n    p = abs(p);\n    float c = max(p.x,p.y);\n    float s = min(p.x,p.y);\n    float d = max(c,s/k);\n    return sqrt(d*d+s*s)-s;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y), 0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r.x;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec4 r, in float k )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r.x - k*min(max(q.x,q.y), 0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec4 r, in float k, in float s )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r.x - k*min(max(q.x,q.y), 0.0) - s*max(q.x,q.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec4 r, in float k, in float s, in float t )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r.x - k*min(max(q.x,q.y), 0", "\n    return abs(p.x-p.y);\n}\n\n// distance to y=1/x^2\nfloat sdOOX2( in vec2 p )\n{\n    return abs(p.x-p.y*p.y);\n}\n\n// distance to y=1/x^3\nfloat sdOOX3( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y);\n}\n\n// distance to y=1/x^4\nfloat sdOOX4( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^5\nfloat sdOOX5( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^6\nfloat sdOOX6( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^7\nfloat sdOOX7( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^8\nfloat sdOOX8( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^9\nfloat sdOOX9( in vec2 p )\n{\n    return abs(p.x-p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y);\n}\n\n// distance to y=1/x^10\nfloat sdOOX10( in vec2 p", "\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat pmax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * 0.25 / k;\n}\n\nfloat pclamp(float a, float k) {\n    return pmax(pmin(a, 1.0, k), 0.0, k);\n}\n\nfloat pclamp(float a, float b, float k) {\n    return pmax(pmin(a, b, k), 0.0, k);\n}\n\nfloat pclamp(float a, float b, float c, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float e, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float e, float f, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float e, float f, float g, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float e, float f, float g, float h, float k) {\n    return pmax(pmin(a, b, k), c, k);\n}\n\nfloat pclamp(float a, float b, float c, float d, float e, float f, float g, float h, float i, float k) {\n    return pmax(", "\n    return (a < 0.0)? -pow(-a, k) : pow(a, k);\n}\n\nfloat pabs(vec2 a, float k) {\n    return (a.x < 0.0)? -pow(-a.x, k) : pow(a.x, k);\n}\n\nfloat pabs(vec3 a, float k) {\n    return (a.x < 0.0)? -pow(-a.x, k) : pow(a.x, k);\n}\n\nfloat pabs(vec4 a, float k) {\n    return (a.x < 0.0)? -pow(-a.x, k) : pow(a.x, k);\n}\n\nfloat pabs(vec2 a, vec2 k) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec3 a, vec3 k) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec4 a, vec4 k) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec2 a, vec2 k, vec2 b) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec3 a, vec3 k, vec3 b) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec4 a, vec4 k, vec4 b) {\n    return (a.x < 0.0)? -pow(-a.x, k.x) : pow(a.x, k.x);\n}\n\nfloat pabs(vec2 a,", "\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart2(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart3(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart4(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart5(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart6(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart7(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart8(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p.x * p.x + p.y * p.y)));\n}\n\nfloat heart9(vec2 p) {\n    p.x = abs(p.x);\n    return (1.0 - (1.0 / (0.25 * p", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p, float seed) {\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed);\n}\n\nfloat hash12(vec2 p, vec2 seed) {\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed.x + seed.y);\n}\n\nfloat hash12(vec2 p, vec2 seed, float seed2) {\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed.x + seed.y + seed2);\n}\n\nfloat hash12(vec2 p, vec2 seed, vec2 seed2) {\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed.x + seed.y + seed2.x + seed2.y);\n}\n\nfloat hash12(vec2 p, vec2 seed, vec2 seed2, float seed3) {\n    vec3 p3  = fract(vec3(p.xyx) *.1", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    vec3  o = vec3(0.0, 0.0, 1.0);\n    vec3  od = vec3(d, 0.0);\n    vec3  oc = vec3(c, 0.0);\n    vec3  ob = vec3(b, 0.0);\n    vec3  oa = vec3(a, 0.0);\n\n    float k = 1.0/(od.x*oc.y - oc.x*od.y);\n    vec3  od2 = od*od;\n    vec3  oc2 = oc*oc;\n    vec3  ob2 = ob*ob;\n    vec3  oa2 = oa*oa;\n\n    vec3  o1 = k*(od2*oc - od*oc2);\n    vec3  o2 = k*(od2*ob - od*ob2);\n    vec3  o3 = k*(od2*oa - od*oa2);\n    vec3  o4 = k*(oc2*ob - oc*ob2);\n    vec3  o5 = k*(oc2*oa - oc*oa2);\n    vec3  o6 = k*(ob2*oa - ob*oa2);\n\n    vec3  o7 = o1 + o2 + o3;\n    vec3  o8 = o4 + o5 + o6;\n\n    vec3  o9 = o7*o8;\n    vec3  o10 = o7*o7;\n    vec3  o11 = o8*o8;\n\n    vec3  o12 = o9*o10;\n    vec3  o13 = o9*o11;\n\n    vec3  o14 = o12 + o13;\n\n    vec3  o15 = o14*o14;\n    vec3  o16 = o14*o15;\n\n    vec", "\n    vec2  p = pos;\n    float d = dot(p,p);\n    float k = wi*he;\n    float f = 0.5*(d/k);\n    return vec3( f, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in float wi, in float he )\n{\n    vec2  p = pos;\n    float d = dot(p,p);\n    float k = wi*he;\n    float f = 0.5*(d-k);\n    return vec3( f, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdCircle( in vec2 pos, in float r )\n{\n    vec2  p = pos;\n    float d = dot(p,p);\n    float f = 0.5*(d-r);\n    return vec3( f, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdRectangle( in vec2 pos, in vec2 wh )\n{\n    vec2  p = pos;\n    vec2  q = abs(p)-wh;\n    float f = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return vec3( f, p.x, p.y );\n}\n\n//.x = f(", "\n    float y = pos.y;\n    float x = pos.x;\n    float f = (y*y + k*x*x) / (y*y + k*k*x*x);\n    float df = (2.0*y*y + 2.0*k*k*x*x) / (y*y + k*k*x*x);\n    float ddf = (2.0*k*k*x*x + 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf2 = (2.0*k*k*x*x - 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf3 = (2.0*y*y - 2.0*k*k*x*x) / (y*y + k*k*x*x);\n    float ddf4 = (2.0*k*k*x*x - 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf5 = (2.0*y*y - 2.0*k*k*x*x) / (y*y + k*k*x*x);\n    float ddf6 = (2.0*k*k*x*x + 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf7 = (2.0*k*k*x*x - 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf8 = (2.0*y*y - 2.0*k*k*x*x) / (y*y + k*k*x*x);\n    float ddf9 = (2.0*k*k*x*x + 2.0*y*y) / (y*y + k*k*x*x);\n    float ddf10 = (2.0*k*k*x*x - 2.0*y*y) / (y*y + k", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float h = (r - ra) / d;\n    float h2 = (r - rb) / d;\n    float f = smoothstep(0.0, 1.0, h2) - smoothstep(0.0, 1.0, h);\n    return vec3(f, h, a);\n}\n\nvec3 sdMoon(vec2 p, float d, float ra, float rb, float r )\n{\n    float a = atan(p.y, p.x);\n    float r2 = length(p);\n    float h = (r2 - ra) / d;\n    float h2 = (r2 - rb) / d;\n    float f = smoothstep(0.0, 1.0, h2) - smoothstep(0.0, 1.0, h);\n    return vec3(f, h, a);\n}\n\nvec3 sdMoon(vec2 p, float d, float ra, float rb, float r, float r2 )\n{\n    float a = atan(p.y, p.x);\n    float r2 = length(p);\n    float h = (r2 - ra) / d;\n    float h2 = (r2 - rb) / d;\n    float f = smoothstep(0.0, 1.0, h2) - smoothstep(0.0, 1.0, h);\n    return vec3(f, h, a);\n}\n\nvec3 sdMoon(vec2 p, float d, float ra, float rb, float r, float r2, float r3 )\n{\n    float a = atan(p.y, p.x);\n    float r2 = length(p);\n    float h = (r2 - ra) / d;\n    float h2 = (r2 - rb) / d;\n    float f = smoothstep(0.0, 1.0, h2) - smoothstep(0.0, 1.0, h);\n    return vec3(f, h, a);\n}\n\nvec3 sdMoon(vec2 p, float", "\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, int seed)\n{\n    v = v * 1664525 + 1013904223 + seed;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 seed)\n{\n    v = v * 1664525 + 1013904223 + seed;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 seed, int seed2)\n{\n    v = v * 1664525 + 1013904223 + seed + seed2;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 seed, ivec2 seed2)\n{\n    v = v * 1664525 + 1013904223 + seed + seed2;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, int seed, int seed2)\n{\n    v = v * 1664525 + 1013904223 + seed + seed2;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\nivec2 P", "\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed)\n{\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += seed;\n    v.y += seed;\n    v.z += seed;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 seed)\n{\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += seed.x;\n    v.y += seed.y;\n    v.z += seed.z;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 seed, int offset)\n{\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += seed.x;\n    v.y += seed.y;\n    v.z += seed.z;\n    v.x += offset;\n    v.y += offset;\n    v.z += offset;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 seed, ivec3 offset)\n{\n    v.x += v.y;\n    v.y += v.z;\n    v.z += v.x;\n    v.x += v.y;\n    v.y +=", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0*dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float q = kx - kz;\n    float disc = q*q + 4.0*p*kz;\n\n    if (disc > 0.0) {\n        float sd = sqrt(disc);\n        float z = (q > 0.0)? -0.5 * (q + sd) : -0.5 * (q - sd);\n        float x = z*z*z*kk;\n        float y = kx*z - z*z;\n        float d2 = dot(d, vec2(x, y));\n        float md2 = d2*d2;\n        float b2 = dot(b, vec2(x, y));\n        float a2 = dot(a, vec2(x, y));\n        float h = md2 - a2*b2*kk;\n        if (h > 0.0) {\n            h = sqrt(h);\n            float t1 = z - h;\n            float t2 = z + h;\n            float t = (t1 < 0.0)? t2 : ((t2 < 0.0)? t1 : min(t1, t2));\n            vec2 r = d + t*b;\n            res = length(r);\n        }\n    }\n\n    return res;\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in float t) {\n    vec2 a = B - A;\n   ", "\n    return (p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x);\n}\n\nfloat winding_number(in vec2 p, in vec2[] v) {\n    float w = 0.0;\n    for (int i = 0; i < v.length(); i++) {\n        w += winding_sign(p, v[i], v[(i + 1) % v.length()]);\n    }\n    return w;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_number(p, vec2[](a, b, c, d));\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_number(p, vec2[](a, b, c));\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b) {\n    return winding_number(p, vec2[](a, b));\n}\n\nfloat winding_number(in vec2 p, in vec2 a) {\n    return winding_number(p, vec2[](a));\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i, in vec2 j, in vec2 k, in vec2 l, in vec2 m, in vec2 n, in vec2 o, in vec2 p_, in vec2 q, in vec2 r, in vec2 s, in vec2 t, in vec2 u, in vec2 v, in vec2 w, in vec2 x, in vec2 y, in vec2 z) {\n    return winding_number(p, vec2[](a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p_, q, r, s, t, u, v, w", "\n    vec3  m = vec3(0.0, 0.5*s.y, 0.0);\n    float t = -dot(m-ro,rd)/dot(rd,m);\n    vec3  q = ro + t*rd;\n    vec3  n = normalize( q.x*vec3(1.0,0.0,0.0) + q.y*vec3(0.0,0.0,1.0) + q.z*vec3(0.0,1.0,0.0) );\n    float d = abs(q.x);\n    if( d>s.x || q.y<0.0 || q.y>s.y || q.z<0.0 || q.z>s.z )\n    {\n        d = 1e20;\n        n = vec3(0.0);\n    }\n    return vec4(d,n);\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec4 s )\n{\n    vec3  m = vec3(0.0, 0.5*s.y, 0.0);\n    float t = -dot(m-ro,rd)/dot(rd,m);\n    vec3  q = ro + t*rd;\n    vec3  n = normalize( q.x*vec3(1.0,0.0,0.0) + q.y*vec3(0.0,0.0,1.0) + q.z*vec3(0.0,1.0,0.0) );\n    float d = abs(q.x);\n    if( d>s.x || q.y<0.0 || q.y>s.y || q.z<0.0 || q.z>s.z )\n    {\n        d = 1e20;\n        n = vec3(0.0);\n    }\n   ", "\n    int a_n = a >> 12;\n    int a_f = a & 0xfff;\n    int b_n = int(b);\n    int b_f = int(b*0x1000);\n    int a_n_b_n = a_n*b_n;\n    int a_n_b_f = a_n*b_f;\n    int a_f_b_n = a_f*b_n;\n    int a_f_b_f = a_f*b_f;\n    int a_n_b_n_x = a_n_b_n + int(x);\n    int a_n_b_f_x = a_n_b_f + int(x);\n    int a_f_b_n_x = a_f_b_n + int(x);\n    int a_f_b_f_x = a_f_b_f + int(x);\n    int a_n_b_n_x_f = a_n_b_n_x & 0xfff;\n    int a_n_b_f_x_f = a_n_b_f_x & 0xfff;\n    int a_f_b_n_x_f = a_f_b_n_x & 0xfff;\n    int a_f_b_f_x_f = a_f_b_f_x & 0xfff;\n    int a_n_b_n_x_f_f = a_n_b_n_x_f + a_n_b_f_x_f;\n    int a_f_b_n_x_f_f = a_f_b_n_x_f + a_f_b_f_x_f;\n    int a_n_b_n_x_f_f_f = a_n_b_n_x_f_f + a_n_b_f_x_f;\n    int a_f_b_n_x_f_f_f = a_f_b_n_x_f_f +", "\n    vec3 h = max(k-abs(a-b),0.0);\n    return min(a,b) - h*h*h*0.1666666667;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a,b) + h*h*h*0.1666666667;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSUnion( in vec3 a, in vec3 b, in float k )\n{\n    vec3 h = max(k-abs(a.x-b.x),0.0);\n    vec3 n = h*h*h*0.1666666667;\n    return vec3(min(a.x,b.x) - n.x, a.y + b.y - n.y, a.z + b.z - n.z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSInter( in vec3 a, in vec3 b, in float k )\n{\n    vec3 h = max(k-abs(a.x-b.x),0.0);\n    vec3 n", "\n    return (p.x*p.x)/(ab.x*ab.x) + (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat inside_Ellipse( vec2 p, in vec2 ab){\n    return (p.x*p.x)/(ab.x*ab.x) + (p.y*p.y)/(ab.y*ab.y);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in float r){\n    return (p.x*p.x) + (p.y*p.y) - (r*r);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola( vec2 p, in float a){\n    return (p.x*p.x) - (2.0*a*p.y);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola_2( vec2 p, in float a){\n    return (p.x*p.x) - (2.0*a*p.y);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola_3( vec2 p, in float a){\n    return (p.x*p.x) - (2.0*a*p.y);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola_4( vec2 p, in float a){\n    return (p.x*p.x) - (2.0*a*p.y);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola_5( vec2 p, in float a){\n    return (p.x*p.x) - (2.0*a*p.y);\n}\n\n//using the \"locus of points\" geometric defn of parabola\nfloat inside_Parabola_6( vec2 p,", "\n    return a + b;\n}\n\nfloat sub_ploss(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss(in float a, in float b){\n    return a / b;\n}\n\nfloat mod_ploss(in float a, in float b){\n    return a % b;\n}\n\nfloat neg_ploss(in float a){\n    return -a;\n}\n\nfloat abs_ploss(in float a){\n    return abs(a);\n}\n\nfloat min_ploss(in float a, in float b){\n    return min(a, b);\n}\n\nfloat max_ploss(in float a, in float b){\n    return max(a, b);\n}\n\nfloat pow_ploss(in float a, in float b){\n    return pow(a, b);\n}\n\nfloat sqrt_ploss(in float a){\n    return sqrt(a);\n}\n\nfloat exp_ploss(in float a){\n    return exp(a);\n}\n\nfloat log_ploss(in float a){\n    return log(a);\n}\n\nfloat sin_ploss(in float a){\n    return sin(a);\n}\n\nfloat cos_ploss(in float a){\n    return cos(a);\n}\n\nfloat tan_ploss(in float a){\n    return tan(a);\n}\n\nfloat asin_ploss(in float a){\n    return asin(a);\n}\n\nfloat acos_ploss(in float a){\n    return acos(a);\n}\n\nfloat atan_ploss(in float a){\n    return atan(a);\n}\n\nfloat sinh_ploss(in float a){\n    return sinh(a);\n}\n\nfloat cosh_ploss(in float a){\n    return cosh(a);\n}\n\nfloat tanh_ploss(in float a){\n    return tanh(a);\n}\n\nfloat asinh_ploss(in float a){\n    return", "\n    vec2 q = p;\n    float a = ab.x;\n    float b = ab.y;\n    float s = s1;\n    float t = s2;\n    float a2 = a*a;\n    float b2 = b*b;\n    float s2 = s*s;\n    float t2 = t*t;\n    float a2b2 = a2*b2;\n    float a2b2s2 = a2b2*s2;\n    float a2b2t2 = a2b2*t2;\n    float a2b2s2t2 = a2b2s2*t2;\n    float a2b2s2t2_1 = a2b2s2t2 - 1.0;\n    float a2b2s2t2_1_2 = a2b2s2t2_1*a2b2s2t2_1;\n    float a2b2s2t2_1_3 = a2b2s2t2_1*a2b2s2t2_1_2;\n    float a2b2s2t2_1_4 = a2b2s2t2_1*a2b2s2t2_1_3;\n    float a2b2s2t2_1_5 = a2b2s2t2_1*a2b2s2t2_1_4;\n    float a2b2s2t2_1_6 = a2b2s2t2_1*a2b2s2t2_1_5;\n    float a2b2s2t2_1_7 = a2b2s2t2_1*a2b2s2t2_1_6;\n    float a2b2s2t2_1_8 = a2b2s2t2_1*a2b2s2t2_1_7;\n    float a2b2s2t2_1_9 = a2b2s2t2_1*a2b2s2t2_1_8;\n    float a2b2s2t2_", "\n    vec3  ba = b - a;\n    float h = length(ba);\n    float r = ra - rb;\n    ba /= h;\n    vec3  q = p - a;\n    float y = dot(ba, q);\n    float d = max(abs(y) - h, 0.0);\n    float s = y > 0.0? ra : rb;\n    float t = y - s;\n    vec3  oc = q - ba * y;\n    float oc2 = dot(oc, oc);\n    float ra2 = ra * ra;\n    float rb2 = rb * rb;\n    float f = ba.y * oc.x - ba.x * oc.y;\n    float g = ba.y * oc.z - ba.z * oc.y;\n    float h = ba.x * oc.x + ba.z * oc.z;\n    float c = oc2 + (t * (f * f + g * g) - h * h) / (4.0 * oc2);\n    float b = f * f + g * g - 4.0 * oc2 * c / (oc2 + h * h);\n    float e = 0.0;\n    if (b > 0.0)\n    {\n        float l = sqrt(b);\n        float t0 = l - e;\n        float t1 = c / (t0 + min(l, e));\n        if (t1 > 0.0)\n        {\n            float z0 = y + t0;\n            float z1 = y + t1;\n            if (z1 > 0.0 && z1 < h)\n            {\n                if (z0 < 0.0)\n                {\n                    d = sqrt(oc2 + z1 * z1);\n                }\n                else if (z0 > h)\n                {\n                    d = sqrt(oc2 + (z1 - h) * (z1 - h));\n                }\n                else\n                {\n                    d = sqrt(oc2 + (z1 - y) * (z1 - y));\n                }\n                return vec4(d, z1, oc.x + ba.x", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -length(q) + c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone", "\n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return length(p.xz)-h.x;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0,", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        sdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n        sdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n        sdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        sdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n        sdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n        sdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        sdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n        sdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n        sdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        sdf( pos + eps.xyy ) - sdf", "\n    float t = 0.0;\n    float res = 1.0;\n    float ph = 1e20;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = map( p );\n        float y = h*h/(2.0*ph);\n        float d = sqrt( h*h-y*y );\n        res = min( res, 8.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if( res<0.0001 || t>100.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*res );\n        if( h<0.001 ) return 0.0;\n        res += h;\n    }\n    return 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float maxDist )\n{\n    float res = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*res );\n        if( h<0.001 ) return 0.0;\n        res += h;\n        if( res>maxDist ) return 1.0;\n    }\n    return 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcHardShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float maxDist, float bias )\n{\n    float res = 1.0;\n    for( int", "\n    vec2 q = vec2( p.x, p.y );\n    float k = ( ra - rb ) / he;\n    float d = -k * q.x - 0.5 * k * q.y;\n    float s = 1.0 / sqrt( 0.25 * k * k + 1.0 );\n    vec2  ss = vec2( s, s );\n    ocl = vec2( -0.25 * k, -0.5 ) * ss;\n    vec2  p0 = vec2( -d, -0.5 * he );\n    vec2  p1 = vec2( -d - ra, 0.0 );\n    vec2  p2 = vec2( -d - rb, he );\n    vec2  p3 = vec2( -d, he + 0.5 * he );\n    vec2  a = p1 - p0;\n    vec2  b = p2 - p1;\n    vec2  c = p3 - p2;\n    vec2  d = p0 - p3;\n    vec2  e = a - b;\n    vec2  f = a + b;\n    vec2  g = c + d;\n    vec2  h = c - d;\n    vec4  m = vec4( e.x, f.x, g.x, h.x ) * ss.x;\n    vec4  n = vec4( e.y, f.y, g.y, h.y ) * ss.y;\n    vec4  k4 = vec4( 1.0, -1.0, 1.0, -1.0 );\n    vec4  t = vec4( p.x, p.y, p.x - he, p.y - he ) * ss;\n    vec4  p4 = t - vec4( m.x, n.x, m.z, n.z );\n    vec4  q4 = t - vec4( m.y, n.y, m.w, n.w );\n    float s4 = vec4( clamp( p4.x, -k4.x, k4.x ) + clamp( q", "\n  vec2 q = vec2(length(p.xz)-ra,p.y);\n  return vec4(length(q)-rb,q);\n}\n\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n  return vec4(length(p.xz)-ra,p.y-rb);\n}\n\nvec4 sdgBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return vec4(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), q);\n}\n\nvec4 sdgSphere( vec3 p, float r )\n{\n  return vec4(length(p)-r,p);\n}\n\nvec4 sdgPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return vec4(dot(p,n.xyz) + n.w,p);\n}\n\nvec4 sdgCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return vec4(min(max(d.x,d.y),0.0) + length(max(d,0.0)),p);\n}\n\nvec4 sdgCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2(length(p.xz),p.y);\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp(dot(k1-q,k2)/dot2(k2),0.0,1.0);\n  float s = (cb.x<ca.x && ca.y<0.0)? -", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - d;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d, in float s )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - d - s;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d, in float s, in float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - d - s - t;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d, in float s, in float t, in float u )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(", " return dot(v,v); }\nfloat sdRoundedCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Rounded cone https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCone( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n    // cone body\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\n// Rounded cylinder https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Rounded torus https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedTorus( vec3 p, float r1, float r2, float r )\n{\n    vec2 q = vec2(length(p.xz)-r1,p.y);\n    return length(q)-r2-r;\n}\n\n// R", "\n    vec2 d = max( abs(p-minCorner), abs(p-maxCorner) );\n    return dot(d,d);\n}\n\n// AABB\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    vec2 d = max( abs(p-minCorner), abs(p-maxCorner) ) - vec2(0.0,0.0);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// AABB\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float thickness ) \n{\n    vec2 d = max( abs(p-minCorner), abs(p-maxCorner) ) - vec2(0.0,0.0);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - thickness;\n}\n\n// AABB\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float thickness, in float thickness2 ) \n{\n    vec2 d = max( abs(p-minCorner), abs(p-maxCorner) ) - vec2(0.0,0.0);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - thickness - thickness2;\n}\n\n// AABB\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float thickness, in float thickness2, in float thickness3 ) \n{\n    vec2 d = max( abs(p-minCorner), abs(p-maxCorner) ) - vec2(0.0,0.0);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - thickness - thickness2 - thickness3;\n}\n\n// AABB\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float thickness, in float thickness2, in float thickness3, in float thickness4", "\n    vec3 color = vec3(0.0);\n    float time = iTime * 0.1;\n    float speed = 0.005;\n    float scale = 0.05;\n    float noise = 0.0;\n    float noise2 = 0.0;\n    float noise3 = 0.0;\n    float noise4 = 0.0;\n    float noise5 = 0.0;\n    float noise6 = 0.0;\n    float noise7 = 0.0;\n    float noise8 = 0.0;\n    float noise9 = 0.0;\n    float noise10 = 0.0;\n    float noise11 = 0.0;\n    float noise12 = 0.0;\n    float noise13 = 0.0;\n    float noise14 = 0.0;\n    float noise15 = 0.0;\n    float noise16 = 0.0;\n    float noise17 = 0.0;\n    float noise18 = 0.0;\n    float noise19 = 0.0;\n    float noise20 = 0.0;\n    float noise21 = 0.0;\n    float noise22 = 0.0;\n    float noise23 = 0.0;\n    float noise24 = 0.0;\n    float noise25 = 0.0;\n    float noise26 = 0.0;\n    float noise27 = 0.0;\n    float noise28 = 0.0;\n    float noise29 = 0.0;\n    float noise30 = 0.0;\n    float noise31 = 0.0;\n    float noise32 = 0.0;\n    float noise33 = 0.0;\n    float noise34 = 0.0;\n    float noise35 = 0.0;\n    float noise36 = 0.0;\n    float noise37 = 0.0;\n    float noise38 = 0.0;\n    float noise39 = 0.0;\n    float noise4", "\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 1.0 - dot(xy, xy);\n    if (z < 0.0)\n        return vec3(0.0);\n    return normalize(vec3(xy, sqrt(z)));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 pos, vec3 dir, vec3 up)\n{\n    vec3 right = cross(dir, up);\n    vec3 ray = pos + dir + right * (uv.x - 0.5) + up * (uv.y - 0.5);\n    return normalize(ray - pos);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 pos, vec3 dir, vec3 up, float fov)\n{\n    vec3 right = cross(dir, up);\n    vec3 ray = pos + dir + right * (uv.x - 0.5) + up * (uv.y - 0.5);\n    return normalize(ray - pos);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 pos, vec3 dir, vec3 up, float fov, float aspect)\n{\n    vec3 right = cross(dir, up);\n    vec3 ray = pos + dir + right * (uv.x - 0.5) + up * (uv.y - 0.5);\n    return normalize(ray - pos);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 pos, vec3 dir, vec3 up, float fov, float aspect, float near, float far)\n{\n    vec3 right = cross(dir, up);\n    vec3 ray = pos + dir + right * (uv.x - 0.5) + up * (uv.y - 0.5);\n    return normalize(ray - pos);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 pos,", "\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,\n        q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2, vec4 q3)\n{\n    return quatmul(quatmul(q1, q2), q3);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2, vec4 q3, vec4 q4)\n{\n    return quatmul(quatmul(quatmul(q1, q2), q3), q4);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2, vec4 q3, vec4 q4, vec4 q5)\n{\n    return quatmul(quatmul(quatmul(quatmul(q1, q2), q3), q4), q5);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2, vec4 q3, vec4 q4, vec4 q5, vec4 q6)\n{\n    return quatmul(quatmul(quatmul(quatmul(quatmul(q", "\n    return length(p-c)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness )\n{\n    return abs(length(p)-r)-thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion, in float noise )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion, in float noise, in float", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness )\n{\n    return abs(length(p)-r)-thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle )\n{\n    return abs(length(p)-r)-thickness+offset+angle;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation )\n{\n    return abs(length(p)-r)-thickness+offset+angle+rotation;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale )\n{\n    return abs(length(p)-r)-thickness+offset+angle+rotation+scale;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew )\n{\n    return abs(length(p)-r)-thickness+offset+angle+rotation+scale+skew;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion )\n{\n    return abs(", "\n    if( m.x > d )\n    {\n        m.x = d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opUnion( vec2 m, vec2 d )\n{\n    if( m.x > d.x )\n    {\n        m.x = d.x;\n        m.y = d.y;\n    }\n    return m;\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    if( m.x > -d )\n    {\n        m.x = -d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opSubtraction( vec2 m, vec2 d )\n{\n    if( m.x > -d.x )\n    {\n        m.x = -d.x;\n        m.y = d.y;\n    }\n    return m;\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    if( m.x > d )\n    {\n        m.x = d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opIntersection( vec2 m, vec2 d )\n{\n    if( m.x > d.x )\n    {\n        m.x = d.x;\n        m.y = d.y;\n    }\n    return m;\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5 + 0.5*( m.x - d )/k, 0.0, 1.0 );\n    return vec2( m.x - k*h*(1.0-h), a );\n}\n\nvec2 opSmoothUnion( vec2 m, vec2 d, float k )\n{\n    float h = clamp( 0.5 + 0.5*( m.x - d.x )/k, 0.0, 1.0 );\n    return vec2( m.x - k*h*(1.0-h), d", "\n    vec2 oc = ro - vec2(0.0,0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n        return;\n    }\n    h = sqrt(h);\n    p1 = vec4( ro + rd*(b-h), 0.0, 1.0 );\n    p2 = vec4( ro + rd*(b+h), 0.0, 1.0 );\n}\n\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p )\n{\n    vec2 oc = ro - vec2(0.0,0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p = vec4(0.0);\n        return;\n    }\n    h = sqrt(h);\n    p = vec4( ro + rd*(b-h), 0.0, 1.0 );\n}\n\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2, out vec4 p3 )\n{\n    vec2 oc = ro - vec2(0.0,0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n        p3 = vec4(0.0);\n        return;\n    }\n    h = sqrt(h);\n    p1 = vec4( ro + rd*(b-h), 0.0, 1.0 );\n    p2 = vec4( ro + rd*(b+", "\n    vec2 q = p - c;\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    return sdgCircle( p, vec2(0), r );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float b ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float b, in float c ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float b, in float c, in float d ) \n{\n    vec2 q = p - vec2(0,r);\n    return vec3( length(q) - r, q );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float b, in float c, in float d, in float e ) \n{\n    vec", "\n  vec2 q = abs(p)-b;\n  return vec3( length(max(q,0.0)) + min(max(q.x,q.y),0.0), -sign(q.x)*vec2(1,0) + -sign(q.y)*vec2(0,1) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{\n  return vec3( length(p)-r, -normalize(p) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w )\n{\n  float d = length(p)-r;\n  return vec3( d, -normalize(p), vec2(d>0.0? 1.0 : -w,0.0) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h )\n{\n  float d = length(p)-r;\n  return vec3( d, -normalize(p), vec2(d>0.0? 1.0 : -w,d>0.0? 0.0 : -h) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a )\n{\n  float d = length(p)-r;\n  return vec3( d, -normalize(p), vec2(d>0.0? 1.0 : -w,d>0.0? 0.0 : -h) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float da )\n{\n  float d = length(p)-r;\n  return vec3( d, -normalize(p), vec2(d>0.0? 1.0 : -w,d>0.0? 0.0 : -h) );\n}\n\nvec3 sdgCircle( in vec2 p, in float r, in float w, in float h, in float a, in float da, in float dda )\n{\n  float d = length(p)-r;\n  return vec3( d", "\n    vec2 q = vec2(p.x,p.y*0.5);\n    float l = length(q);\n    float d = 0.5*sin(0.5*atan(q.y,q.x)) + 0.5*sin(0.5*atan(q.x,q.y));\n    d = abs(d)-0.15;\n    return vec3(d,d*length(q),d*length(q));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p )\n{\n    float d = length(p)-0.5;\n    return vec3(d,d*length(p),d*length(p));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    float d = length(p)-r;\n    return vec3(d,d*length(p),d*length(p));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r, in float w )\n{\n    float d = length(p)-r;\n    return vec3(d,d*length(p),d*length(p));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.", "\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n    return a1 * pow(x, b1) + a2 * pow(x, b2);\n}", "\n    return a * pow(abs(x), 1.0 / n) * pow(1.0 - pow(abs(x), 1.0 / n), 1.0 / n - 1.0) * sign(x) + b;\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat v(float a, float b, float n, float y) {\n    return a * pow(abs(y), 1.0 / n) * pow(1.0 - pow(abs(y), 1.0 / n), 1.0 / n - 1.0) * sign(y) + b;\n}\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat w(float a, float b, float n, float z) {\n    return a * pow(abs(z), 1.0 / n) * pow(1.0 - pow(abs(z), 1.0 / n), 1.0 / n - 1.0) * sign(z) + b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return a * pow(abs(x), 1.0 / n) * pow(1.0 - pow(abs(x), 1.0 / n), 1.0 / n - 1.0) * sign(", "\n                uv = fract(uv * vec2(123.34, 456.21));\n                float x = dot(uv, vec2(127.1, 311.7));\n                return fract(sin(x) * 43758.5453);\n            }\n\n            float paperNoise(vec2 uv, float time){\n                uv = fract(uv * vec2(123.34, 456.21));\n                float x = dot(uv, vec2(127.1, 311.7));\n                return fract(sin(x + time) * 43758.5453);\n            }\n\n            float paperNoise(vec2 uv, float time, float speed){\n                uv = fract(uv * vec2(123.34, 456.21));\n                float x = dot(uv, vec2(127.1, 311.7));\n                return fract(sin(x + time * speed) * 43758.5453);\n            }\n\n            float paperNoise(vec2 uv, float time, float speed, float scale){\n                uv = fract(uv * vec2(123.34, 456.21));\n                float x = dot(uv, vec2(127.1, 311.7));\n                return fract(sin(x + time * speed) * 43758.5453 * scale);\n            }\n\n            float paperNoise(vec2 uv, float time, float speed, float scale, float offset){\n                uv = fract(uv * vec2(123.34, 456.21));\n                float x = dot(uv, vec2(127.1, 311.7));\n                return fract(sin(x + time * speed) * 43758.5453 * scale + offset);\n            }\n\n            float paperNoise(vec2 uv, float time, float speed, float scale, float offset, float seed){\n                uv = fract(uv * vec2(1", "\n    vec3 color = vec3( 0.0 );\n    color += texture2D( texture, vec2( x, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 1, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 2, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 3, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 4, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 5, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 6, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 7, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 8, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 9, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 10, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 11, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 12, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 13, y ) ).rgb;\n    color += texture2D( texture, vec2( x + 14, y ) ).rgb;\n    return color;\n}\n", "\n    return length(p-c)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness )\n{\n    return abs(length(p)-r)-thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion, in float noise )\n{\n    return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion, in float noise, in float", "\n  vec2 d = abs(p-c)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness )\n{\n  return abs(length(p)-r)-thickness;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset )\n{\n  return abs(length(p)-r)-thickness+offset;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle )\n{\n  return abs(length(p)-r)-thickness+offset+angle;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation )\n{\n  return abs(length(p)-r)-thickness+offset+angle+rotation;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale )\n{\n  return abs(length(p)-r)-thickness+offset+angle+rotation+scale;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew )\n{\n  return abs(length(p)-r)-thickness+offset+angle+rotation+scale+skew;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion )\n{\n  return abs(length(p)-r)-thickness+offset+angle+rotation+scale+skew+distortion;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float thickness, in float offset, in float angle, in float rotation, in float scale, in float skew, in float distortion, in float noise )\n{\n", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return -length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) { p=p.yx; ab=ab.yx; }\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m;\n    float n = ab.y*p.y/l;      float n2 = n*n;\n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3+m2*n2*2.0;\n    float d = c3+m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-", "\n    vec2 pa = p-a, ba = b-a;\n    float h2 = h*h, d2 = dot(pa,ba)*dot(pa,ba)/h2 - dot(pa,pa);\n    float k = sign(d2-h2);\n    float si = sqrt(max( 0.0, h2-d2 ));\n    vec2  d = pa - ba*clamp( dot(pa,ba)/h2, 0.0, 1.0 );\n    return vec2( si*k, k );\n}\n\nvec2 sdSqSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 sdSqSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d2min )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d2 = dot(pa-ba*h,pa-ba*h);\n    float k = sign(d2-d2min);\n    float si = sqrt(max( 0.0, d2min-d2 ));\n    vec2  d = pa - ba*h;\n    return vec2( si*k, k );\n}\n\nvec2 sdSqSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float d2min, in float d2max )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d2 = dot(pa-ba*h,pa-ba*h);\n    float k = sign(d2-d2min);\n    float si = sqrt(max( 0", "\n    float d = 1e10;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2], kPath[i*2+1] ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3], kPath[i*2+4] ) );\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kScale )\n{\n    float d = 1e10;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2], kPath[i*2+1] ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3], kPath[i*2+4] ) );\n        }\n    }\n    return d * kScale;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kScale, float kOffset )\n{\n    float d = 1e10;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2], kPath[i*2+1] ) );\n       ", "\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdB( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdc( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdd( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sde( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdf( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdh( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdi( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdj( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdk( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdl( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdm( in vec2 p )\n{\n    float d = length(p) - 1.0;\n    return d;\n}\n\n// correct outside, correct inside\nfloat sdn( in vec2 p )\n{\n    float d = length(p)", "\n    float d = 0.0;\n    float s = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        vec2 a = mod( p*s, 2.0 )-1.0;\n        d += s*length( a )/dot( a, a );\n        s *= 2.0;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB2( in vec2 p )\n{\n    float d = 0.0;\n    float s = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        vec2 a = mod( p*s, 2.0 )-1.0;\n        d += s*length( a )/dot( a, a );\n        s *= 2.0;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB3( in vec2 p )\n{\n    float d = 0.0;\n    float s = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        vec2 a = mod( p*s, 2.0 )-1.0;\n        d += s*length( a )/dot( a, a );\n        s *= 2.0;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB4( in vec2 p )\n{\n    float d = 0.0;\n    float s = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        vec2 a = mod( p*s, 2.0 )-1.0;\n        d += s*length( a )/dot( a, a );\n        s *= 2.0;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB5( in vec2 p )\n{\n    float d = 0.0;\n    float s = 1.0;\n    for( int i=0; i<10; i++", "\n    vec3 col = vec3(0.0);\n\n    // The pattern is a grid of squares.\n    // Each square is a checkerboard pattern of black and white squares.\n    // The squares are arranged in a grid, with the squares in the top row\n    // alternating between black and white.\n    // The squares in the bottom row are the same as the squares in the top row,\n    // but they are offset by half a square.\n    // The squares in the second-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square.\n    // The squares in the third-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square.\n    // The squares in the fourth-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square and half a square.\n    // The squares in the fifth-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square and half a square and half a square.\n    // The squares in the sixth-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square and half a square and half a square and half a square.\n    // The squares in the seventh-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square and half a square and half a square and half a square and half\n    // a square.\n    // The squares in the eighth-to-last row are the same as the squares in the\n    // top row, but they are offset by half a square and half a square and half\n    // a square and half a square and half a square and half a square and half\n    // a square and half a square.\n    // The squares in the ninth-to-last row are the same as the squares in the\n    //", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    return a + ba*h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th )\n{\n    vec2 d = p - c;\n    float h = clamp( dot(d,d), 0.0, r*r );\n    return c + d*sqrt(h)/r;\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 s, in float th )\n{\n    vec2 d = abs(p-c)-s;\n    return p - sign(d)*max(d,0.0);\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 s, in float th, in float r )\n{\n    vec2 d = abs(p-c)-s;\n    return p - sign(d)*max(d,0.0);\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 s, in float th, in float r, in float a )\n{\n    vec2 d = abs(p-c)-s;\n    return p - sign(d)*max(d,0.0);\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 s, in float th, in float r, in float a, in float b )\n{\n    vec2 d = abs(p-c)-s;\n    return p - sign(d)*max(d,0.0);\n}", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// distance to rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    return (length(p/ab) - 1.0) * min(ab.x,ab.y);\n}\n\n// distance to rounded ellipse\nfloat sdRoundEllipse( in vec2 p, in vec2 ab, in float r )\n{\n    return (length(p/ab) - 1.0) * min(ab.x,ab.y) - r;\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2 center, in vec2 radius, in int N )\n{\n    float a = atan(p.x-center.x,p.y-center.y);\n    float da = 6.28318530718/float(N);\n    return length( p-center ) - radius.x*cos(floor(.5+a/da)*da);\n}\n\n// distance to star\nfloat sdStar( in vec2 p, in vec2 center, in float r, in float r2, in int N )\n{\n    float a = at", "\n  vec2 q = vec2( max(abs(p.x)-b.x,0.0), max(abs(p.y)-b.y,0.0) );\n  return p - vec2(clamp(q.x,0.0,r),clamp(q.y,0.0,r));\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, out vec2 q )\n{\n  q = vec2( max(abs(p.x)-b.x,0.0), max(abs(p.y)-b.y,0.0) );\n  return p - vec2(clamp(q.x,0.0,r),clamp(q.y,0.0,r));\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, out vec2 q, out vec2 d )\n{\n  q = vec2( max(abs(p.x)-b.x,0.0), max(abs(p.y)-b.y,0.0) );\n  d = vec2(clamp(q.x,0.0,r),clamp(q.y,0.0,r));\n  return p - d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, out vec2 q, out vec2 d, out vec2 s )\n{\n  q = vec2( max(abs(p.x)-b.x,0.0), max(abs(p.y)-b.y,0.0) );\n  d = vec2(clamp(q.x,0.0,r),clamp(q.y,0.0,r));\n  s = vec2( sign(p.x), sign(p.y) );\n  return p - d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, out vec2 q, out vec2 d, out vec2 s, out vec2 m )\n{\n  q = vec2( max(abs(p", "\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) - length(min(q,0.0)) +\n    max(dot(q,vec3(sign(q.x),sign(q.y),sign(q.z))), 0.0) * r.z - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) - length(min(q,0.0)) +\n    max(dot(q,vec3(sign(q.x),sign(q.y),sign(q.z))), 0.0) * r.w - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r, in float s )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) - length(min(q,0.0)) +\n    max(dot(q,vec3(sign(q.x),sign(q.y),sign(q.z))), 0.0) * r.w - r.x;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r, in float s, in float t )\n{\n", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float s )\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*s;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float s, in float t )\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*s + t;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float s, in float t, in float u )\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*s + t*u;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float s, in float t, in float u, in float v )\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p, float seed){\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed);\n}\n\nfloat hash12(vec2 p, float seed, float seed2){\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed + seed2);\n}\n\nfloat hash12(vec2 p, float seed, float seed2, float seed3){\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed + seed2 + seed3);\n}\n\nfloat hash12(vec2 p, float seed, float seed2, float seed3, float seed4){\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z + seed + seed2 + seed3 + seed4);\n}\n\nfloat hash12(vec2 p, float seed, float seed2, float seed3, float seed4, float seed5){\n    vec3 p3  = fract(vec3(p.xyx) *.1", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// This is the main function that will be called by the shader\n// It will be called for every pixel in the screen\n// The input is the pixel coordinates on the screen\n// The output is the color of the pixel\n// The color is a vec4, which is a vector of 4 floats\n// The first 3 floats are the RGB values, the last one is the alpha value\n// The alpha value is used to control the transparency of the pixel\n// The alpha value is 1.0 by default, which means the pixel is fully opaque\n// The alpha value is 0.0 when the pixel is fully transparent\n// The alpha value is between 0.0 and 1.0 when the pixel is partially transparent\n// The alpha value is used to control the blending of the pixel with the background\n// The alpha value is used to control the blending of the pixel with the foreground\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used to control the blending of the pixel with the other pixels\n// The alpha value is used", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/Xl2XWt\nfloat fbm(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *=.5;\n    }\n    return value;\n}\n\n// https://www.shadertoy.com/view/Xl2XWt\nfloat fbm2(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0;\n\n    return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nfloat triValueNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y), mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\n\nfloat triValueNoise(vec4 x)\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + p.z * 113.0 + p.w * 171.0;\n\n    return mix(mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y), mix(mix(hash(n + 113.0", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) \n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D noise function\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n           (c - a)* u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// Random float from 0.0 to 1.0\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// Value noise\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0 * pow(1.0 - f.x, 4.0) * pow(1.0 - f.y, 4.0);\n    return sqrt(k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    // Tile the space\n    uv = fract(uv * 3.0);\n\n    // Use the pattern function to create a grid of values\n    float v = pattern(uv);\n\n    // Use the value to modulate the color\n    col = vec3(v);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r);\n    float dTheta = 1.0 / r;\n    float dPhi = 1.0 / r;\n    float dA = dTheta * dPhi;\n    return dA;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r);\n    float dTheta = 1.0 / r;\n    float dPhi = 1.0 / r;\n    float dA = dTheta * dPhi;\n    float dOmega = dA / (r * r);\n    return dOmega;\n}\n\nvec3 getTexel(vec3 dir)\n{\n    vec3 texel = vec3(0.0);\n    float solidAngle = 0.0;\n    float solidAngleSum = 0.0;\n    float solidAngleThreshold = 0.000001;\n    float texelThreshold = 0.000001;\n    float texelSum = 0.0;\n    float texelSumThreshold = 0.000001;\n    float texelSolidAngleSum = 0.0;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0.000001;\n    float texelSolidAngleSumThreshold = 0", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( dot(hash33(n+  0.0),f-vec3(0.0,0.0,0.0)),\n                       dot(hash33(n+  1.0),f-vec3(1.0,0.0,0.0)),f.x),\n                   mix( dot(hash33(n+ 57.0),f-vec3(0.0,0.0,1.0)),\n                       dot(hash33(n+ 58.0),f-vec3(1.0,0.0,1.0)),f.x),f.y),\n               mix(mix( dot(hash33(n+113.0),f-vec3(0.0,1.0,0.0)),\n                       dot(hash33(n+114.0),f-vec3(1.0,1.0,0.0)),f.x),\n                   mix( dot(hash33(n+170.0),f-vec3(0.0,1.0,1.0)),\n                       dot(hash33(n+171.0),f-vec3(1.0,1.0,1.0)),f.x),f.y),f.z);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW", "\n    // 1. find current tetrahedron T and it's four vertices\n    // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n    // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\n    // calculate s and x\n    vec4 s = floor(p + dot(p, vec3(F3)));\n    vec4 x = p - s + dot(s, vec3(G3));\n\n    // calculate i1 and i2\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    // x1, x2, x3\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    // 2. find four surflets and store them in d\n    vec4 w, d;\n\n    // calculate surflet weights\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n    w = max(0.6 - w, 0.0);\n\n    // calculate surflet components\n    d.x = dot(vec3(x), vec3(F3));\n    d.y = dot(vec3(x1), vec3(F3));\n    d.z = dot(vec3(x2), vec3(F3));\n    d.w = dot(vec3(x3), vec3(F3));\n\n    // multiply d by w^4\n    w *= w;\n    w *= w;\n    d *= w;\n\n    // ", "\n    vec2 p = mod(x, 289.0);\n    p = p*p;\n    vec2 f = p*p*p*123.0;\n    vec2 a = fract(f);\n    vec2 b = mod(f, 7.0);\n    vec2 c = mod(f, 15.0);\n    vec3 r = vec3( dot(x,x), dot(x,y), dot(y,y) );\n    return vec2( dot(r,vec3(a.x, b.x, c.x)), dot(r,vec3(a.y, b.y, c.y)) );\n}\n\nvec2 hash( in vec3 x )   \n{\n    vec3 p = mod(x, 289.0);\n    p = p*p;\n    vec3 f = p*p*p*123.0;\n    vec3 a = fract(f);\n    vec3 b = mod(f, 7.0);\n    vec3 c = mod(f, 15.0);\n    vec3 r = vec3( dot(x,x), dot(x,y), dot(y,y) );\n    return vec2( dot(r,vec3(a.x, b.x, c.x)), dot(r,vec3(a.y, b.y, c.y)) );\n}\n\nvec2 hash( in vec4 x )   \n{\n    vec4 p = mod(x, 289.0);\n    p = p*p;\n    vec4 f = p*p*p*123.0;\n    vec4 a = fract(f);\n    vec4 b = mod(f, 7.0);\n    vec4 c = mod(f, 15.0);\n    vec4 r = vec4( dot(x,x), dot(x,y), dot(y,y), dot(z,z) );\n    return vec2( dot(r,vec4(a.x, b.x, c.x, r.w)), dot(r,vec4(a.y, b.y, c.y,", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, in float r )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, in float r, in float h )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - h*h;\n}\n\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, in float r, in float h, in float d )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - h*h - d;\n}\n\nfloat sdSegment(", "\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x - r.y;\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x - r.y;\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x - r.y;\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x - r.y;\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x - r.y;\n}\n\n// This is the original form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,", "\n    // Project the center of the disk onto the plane.\n    proj_center = center.xy - normal.xy * dot(center.xy, normal.xy);\n\n    // Project the normal onto the plane.\n    float normal_z = normal.z;\n    normal.xy -= proj_center;\n    normal.xy /= length(normal.xy);\n    normal.z = 0.0;\n\n    // Project the radius onto the plane.\n    float radius_z = center.z - proj_center.y * normal.y;\n    radius /= length(normal.xy);\n\n    // Compute the major and minor axes.\n    major = vec2(radius, radius_z / normal_z);\n    minor = vec2(radius, radius_z / normal_z);\n\n    // Rotate the axes.\n    float angle = proj_info.x;\n    float cos_angle = cos(angle);\n    float sin_angle = sin(angle);\n    float temp = major.x;\n    major.x = major.x * cos_angle - major.y * sin_angle;\n    major.y = temp * sin_angle + major.y * cos_angle;\n    temp = minor.x;\n    minor.x = minor.x * cos_angle - minor.y * sin_angle;\n    minor.y = temp * sin_angle + minor.y * cos_angle;\n\n    // Scale the axes.\n    major *= proj_info.y;\n    minor *= proj_info.y;\n}\n\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor,\n    out float angle\n){\n    // Project the center of the disk onto the plane.\n    proj_center = center.xy - normal.xy * dot(center.xy, normal.xy);\n\n    // Project the normal onto the plane.\n    float normal_z = normal.z;\n    normal.xy -= proj_center;\n    normal.xy /= length(normal.xy);\n    normal.z = 0.0;\n\n    // Project the", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash12(vec3 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash12(vec4 p)\n{\n    vec4 p4  = fract(vec4(p.xyxy) *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\nfloat Hash12(float p)\n{\n    vec2 p2 = vec2(p, p);\n    vec3 p3  = fract(vec3(p2.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash12(float p, float q)\n{\n    vec2 p2 = vec2(p, q);\n    vec3 p3  = fract(vec3(p2.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash12(float p, float q, float r)\n{\n    vec3 p3  = fract(vec3(p, q, r) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p", "\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float da = abs(a);\n    float da0 = mod(da, an);\n    float da1 = mod(da + bn, an);\n    float da2 = mod(da + 2.0*bn, an);\n    float da3 = mod(da + 3.0*bn, an);\n    float da4 = mod(da + 4.0*bn, an);\n    float da5 = mod(da + 5.0*bn, an);\n    float da6 = mod(da + 6.0*bn, an);\n    float da7 = mod(da + 7.0*bn, an);\n    float da8 = mod(da + 8.0*bn, an);\n    float da9 = mod(da + 9.0*bn, an);\n    float da10 = mod(da + 10.0*bn, an);\n    float da11 = mod(da + 11.0*bn, an);\n    float da12 = mod(da + 12.0*bn, an);\n    float da13 = mod(da + 13.0*bn, an);\n    float da14 = mod(da + 14.0*bn, an);\n    float da15 = mod(da + 15.0*bn, an);\n    float da16 = mod(da + 16.0*bn, an);\n    float da17 = mod(da + 17.0*bn, an);\n    float da18 = mod(da + 18.0*bn, an);\n    float da19 = mod(da + 19.0*bn, an);\n    float da20 = mod(da + 20.0*bn, an);\n    float da21 = mod(da + 21.0*bn, an);\n    float da22 = mod(da + 22.0*bn, an);\n    float da23 = mod(da + 23.0*bn, an);\n    float da24", "\n    vec3 n = vec3(0.0);\n    for( int i=1; i<=3; i++ )\n    {\n        vec3 e = 0.5 + 0.5*sin( i*p.yzx + p.xxx );\n        n += normalize( e.zxy*e.yzx );\n    }\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\n\n// https://iquilezles.org/articles/", "\n    float t = t0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < EPSILON)\n            return 0.0;\n        t += h;\n        if (t > t1)\n            return 1.0;\n    }\n    return 1.0;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvec3 getColor(vec3 p)\n{\n    vec3 n = getNormal(p);\n    vec3 color = vec3(0.0);\n    color += 0.5 * vec3(1.0, 0.0, 0.0) * (1.0 - dot(n, vec3(0.0, 1.0, 0.0)));\n    color += 0.5 * vec3(0.0, 1.0, 0.0) * (1.0 - dot(n, vec3(1.0, 0.0, 0.0)));\n    color += 0.5 * vec3(0.0, 0.0, 1.0) * (1.0 - dot(n, vec3(0.0, 0.0, 1.0)));\n    return color;\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return normalize(uv.x * cu + uv.y * cv + 1.", "\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO2( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO3( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    vec3 axis_ = normalize(axis);\n    return mat3(\n        t * axis_.x * axis_.x + c,\n        t * axis_.x * axis_.y - axis_.z * s,\n        t * axis_.z * axis_.x + axis_.y * s,\n        t * axis_.x * axis_.y + axis_.z * s,\n        t * axis_.y * axis_.y + c,\n        t * axis_.y * axis_.z - axis_.x * s,\n        t * axis_.z * axis_.x - axis_.y * s,\n        t * axis_.y * axis_.z + axis_.x * s,\n        t * axis_.z * axis_.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    return createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), angle);\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    return createRotationMatrixAxisAngle(vec3(0.0, 1.0, 0.0), angle);\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    return createRotationMatrixAxisAngle(vec3(0.0, 0.0, 1.0), angle);\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrix(vec3 axis, float angle) {\n    return createRotationMatrixAxisAngle(axis, angle);\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    return createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), angle);\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    return createRotationMatrix", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray = inverse(iCamera) * ray;\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray = inverse(iCamera) * ray;\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec3 cameraPos, vec3 cameraTarget) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray = inverse(iCamera) * ray;\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec3 cameraPos, vec3 cameraTarget, vec3 cameraUp) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray = inverse(iCamera) * ray;\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec3 cameraPos, vec3 cameraTarget, vec3 cameraUp, vec3 cameraRight) {\n    vec2 uv = frag", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,144.7272,98.5221))) * 43758.5453);\n}\n\nfloat rand4dTime(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,144.7272,98.5221))) * 43758.5453);\n}\n\nfloat rand2d(vec2 co, float seed){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + seed) * 43758.5453);\n}\n\nfloat rand3d(vec3 co, float seed){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,144.7272)) + seed) * 437", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 151.7182, 100.0001))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 151.7182, 100.0001)))", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n                   mix(hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with octaves\nfloat noise3d(vec3 x, int octaves){\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < octaves; i++){\n        total += noise3d(x * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// 3D value noise with octaves and lacunarity\nfloat noise3d(vec3 x, int octaves, float lacunarity){\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < octaves; i++){\n        total += noise3d(x * frequency) * amplitude;\n        frequency *= lacunarity;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// 3D value noise with octaves, lacunarity and persistence\nfloat noise3d(vec3 x, int octaves, float lacunarity, float persistence){\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0 + 113.0*i.z;\n    return mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n                   mix(hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0;\n    return mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n               mix(hash(n+57.0), hash(n+58.0),f.x),f.y);\n}\n\n// 1D simplex noise, cool trick\nfloat supernoise1d(float p){\n    float i = floor(p);\n    float f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(hash(i), hash(i+1.0),f);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0 + 113.0*i.z;\n    return mix(mix(mix(hash(n+0", "\n    float f = 0.0;\n    f += 0.50000*noise(p); p = m*p*2.02;\n    f += 0.25000*noise(p); p = m*p*2.03;\n    f += 0.12500*noise(p); p = m*p*2.01;\n    f += 0.06250*noise(p);\n    return f/0.9375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM2(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p = m*p*2.02;\n    f += 0.25000*noise(p); p = m*p*2.03;\n    f += 0.12500*noise(p); p = m*p*2.01;\n    f += 0.06250*noise(p);\n    return f/0.9375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM3(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p = m*p*2.02;\n    f += 0.25000*noise(p); p = m*p*2.03;\n    f += 0.12500*noise(p); p = m*p*2.01;\n    f += 0.06250*noise(p);\n    return f/0.9375;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM4(vec3 p){\n    float f = 0.0;\n    f += 0.50000*noise(p); p = m*p*2.02;\n    f += 0.25000*noise(p); p = m*p*2.03;\n    f += 0.1", "\n    vec3 p = pos;\n    vec2 res = vec2(0.0);\n    float dens = 0.0;\n    float dens2 = 0.0;\n    float dens3 = 0.0;\n    float dens4 = 0.0;\n    float dens5 = 0.0;\n    float dens6 = 0.0;\n    float dens7 = 0.0;\n    float dens8 = 0.0;\n    float dens9 = 0.0;\n    float dens10 = 0.0;\n    float dens11 = 0.0;\n    float dens12 = 0.0;\n    float dens13 = 0.0;\n    float dens14 = 0.0;\n    float dens15 = 0.0;\n    float dens16 = 0.0;\n    float dens17 = 0.0;\n    float dens18 = 0.0;\n    float dens19 = 0.0;\n    float dens20 = 0.0;\n    float dens21 = 0.0;\n    float dens22 = 0.0;\n    float dens23 = 0.0;\n    float dens24 = 0.0;\n    float dens25 = 0.0;\n    float dens26 = 0.0;\n    float dens27 = 0.0;\n    float dens28 = 0.0;\n    float dens29 = 0.0;\n    float dens30 = 0.0;\n    float dens31 = 0.0;\n    float dens32 = 0.0;\n    float dens33 = 0.0;\n    float dens34 = 0.0;\n    float dens35 = 0.0;\n    float dens36 = 0.0;\n    float dens37 = 0.0;\n    float dens38 = 0.0;\n    float dens39 = 0.0;\n    float dens40 = 0.0;\n    float dens41 = 0.0;\n    float dens42 = 0", "\n\tvec3 color = vec3(0.0);\n\tvec3 dir = normalize(point);\n\tvec3 sunDir = normalize(sunDir);\n\tfloat sun = dot(dir, sunDir);\n\tfloat sun2 = dot(dir, sunDir*0.5+0.5);\n\tfloat sun3 = dot(dir, sunDir*0.25+0.75);\n\tfloat sun4 = dot(dir, sunDir*0.125+0.875);\n\tfloat sun5 = dot(dir, sunDir*0.0625+0.9375);\n\tfloat sun6 = dot(dir, sunDir*0.03125+0.96875);\n\tfloat sun7 = dot(dir, sunDir*0.015625+0.984375);\n\tfloat sun8 = dot(dir, sunDir*0.0078125+0.9921875);\n\tfloat sun9 = dot(dir, sunDir*0.00390625+0.99609375);\n\tfloat sun10 = dot(dir, sunDir*0.001953125+0.998046875);\n\tfloat sun11 = dot(dir, sunDir*0.0009765625+0.9990234375);\n\tfloat sun12 = dot(dir, sunDir*0.00048828125+0.99951171875);\n\tfloat sun13 = dot(dir, sunDir*0.000244140625+0.999755859375);\n\tfloat sun14 = dot(dir, sunDir*0.0001220703125+0.9998779296875);\n\tfloat sun15 = dot(dir, sunDir*0.00006103515625+0.9999389648437", "\n    vec3 ray = pointEnd - pointStart;\n    vec3 rayDir = normalize(ray);\n    vec3 rayStart = pointStart;\n    vec3 rayEnd = pointEnd;\n    vec3 rayColor = vec3(0.0);\n    float rayLength = length(ray);\n    float rayLength2 = rayLength * rayLength;\n    float rayLength3 = rayLength2 * rayLength;\n    float rayLength4 = rayLength3 * rayLength;\n    float rayLength5 = rayLength4 * rayLength;\n    float rayLength6 = rayLength5 * rayLength;\n    float rayLength7 = rayLength6 * rayLength;\n    float rayLength8 = rayLength7 * rayLength;\n    float rayLength9 = rayLength8 * rayLength;\n    float rayLength10 = rayLength9 * rayLength;\n    float rayLength11 = rayLength10 * rayLength;\n    float rayLength12 = rayLength11 * rayLength;\n    float rayLength13 = rayLength12 * rayLength;\n    float rayLength14 = rayLength13 * rayLength;\n    float rayLength15 = rayLength14 * rayLength;\n    float rayLength16 = rayLength15 * rayLength;\n    float rayLength17 = rayLength16 * rayLength;\n    float rayLength18 = rayLength17 * rayLength;\n    float rayLength19 = rayLength18 * rayLength;\n    float rayLength20 = rayLength19 * rayLength;\n    float rayLength21 = rayLength20 * rayLength;\n    float rayLength22 = rayLength21 * rayLength;\n    float rayLength23 = rayLength22 * rayLength;\n    float rayLength24 = rayLength23 * rayLength;\n    float rayLength25 = rayLength24 * rayLength;\n    float rayLength26 = rayLength25 * rayLength;\n    float rayLength27 = rayLength26 * rayLength;\n    float rayLength28 = rayLength27 * rayLength;\n    float rayLength29 = rayLength28 * rayLength;\n    float rayLength30 = rayLength29 * rayLength", "\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return clamp((color*(A*color+B))/(color*(C*color+D)+E), 0.0, 1.0);\n}\n\nvec3 tonemap(vec3 color) {\n    return aces_tonemap(color);\n}\n"]}