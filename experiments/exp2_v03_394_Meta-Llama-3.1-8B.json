{"generations": [" return 0.0; }\nfloat SH_1_0( in vec3 s ) { return s.x; }\nfloat SH_1_1( in vec3 s ) { return s.y; }\nfloat SH_1_2( in vec3 s ) { return s.z; }\nfloat SH_2_0( in vec3 s ) { return s.x*s.x - 0.5; }\nfloat SH_2_1( in vec3 s ) { return s.x*s.y; }\nfloat SH_2_2( in vec3 s ) { return s.x*s.z; }\nfloat SH_2_3( in vec3 s ) { return s.y*s.z; }\nfloat SH_2_4( in vec3 s ) { return s.y*s.y - 0.5; }\nfloat SH_2_5( in vec3 s ) { return s.z*s.z - 0.5; }\nfloat SH_3_0( in vec3 s ) { return s.x*s.x*(s.x*s.x - 1.5); }\nfloat SH_3_1( in vec3 s ) { return s.x*s.y*(s.x*s.x - 0.5); }\nfloat SH_3_2( in vec3 s ) { return s.x*s.z*(s.x*s.x - 0.5); }\nfloat SH_3_3( in vec3 s ) { return s.y*s.z*(s.y*s.y - 0.5); }\nfloat SH_3_4( in vec3 s ) { return s.x*s.y*s.y; }\nfloat SH_3_5( in vec3 s ) { return s.x*s.y*s.z; }\nfloat SH_3_6( in vec3 s ) { return s.x*s.z*s.z; }\nfloat SH_3_7( in vec3 s ) { return s.y*s.z*s.z; }\nfloat SH_3_8( in vec3 s ) { return s.y*s.y*(s.y*s.y - 1.5); }\nfloat SH_3_9( in vec3 s ) { return s.z*s.z*(s.z*s.z - 1.5); }\nfloat SH_4_0( in vec3 s ) { return s.x*s.x*(s.x*s.x*(s.x*s.x - 2.5) + 1.5); }\nfloat SH_4_1(", " return distance( p, mix( a, b, step( dot( a-b, p-a ), 0.0 ) ) ); }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{ return min( line( a, b, p ), length( a-b ) ); }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r )\n{ return min( line( a, b, p ), length( a-b ) ) - r; }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r, in float s )\n{ return min( line( a, b, p ), length( a-b ) ) - r - s; }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r, in float s, in float t )\n{ return min( line( a, b, p ), length( a-b ) ) - r - s - t; }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r, in float s, in float t, in float u )\n{ return min( line( a, b, p ), length( a-b ) ) - r - s - t - u; }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r, in float s, in float t, in float u, in float v )\n{ return min( line( a, b, p ), length( a-b ) ) - r - s - t - u - v; }\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, in float r, in float s, in float t, in float u, in float v, in float w )\n{ return min( line( a, b, p ), length( a-b ) ) -", " \n    return abs(v) < r? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{ \n    return abs(v) < r? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{ \n    return abs(v) < r? v : -v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in float t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in float t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r, in float t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in vec2 t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in vec3 t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r, in vec4 t )\n{ \n    return abs(v) < r? v : -v + t;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec", " \n    vec2 n = normalize( r );\n    vec2 v2 = v - 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{ \n    vec2 n = normalize( r );\n    vec2 v2 = v + 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{ \n    vec3 n = normalize( r );\n    vec3 v2 = v + 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{ \n    vec3 n = normalize( r );\n    vec3 v2 = v - 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{ \n    vec4 n = normalize( r );\n    vec4 v2 = v + 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{ \n    vec4 n = normalize( r );\n    vec4 v2 = v - 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r, in float t )\n{ \n    vec4 n = normalize( r );\n    vec4 v2 = v + 2.0 * dot( n, v ) * n;\n    return v2;\n}\n\n// Reflect v if in the negative half plane defined by r (this", "\t\n\treturn abs(v) < r? v : vec2(0.0);\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\t\n\treturn abs(v) < r? v : vec3(0.0);\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\t\n\treturn abs(v) < r? v : vec4(0.0);\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r, in vec2 c )\n{\t\n\treturn abs(v) < r? v : c;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r, in vec3 c )\n{\t\n\treturn abs(v) < r? v : c;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r, in vec4 c )\n{\t\n\treturn abs(v) < r? v : c;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r, in vec2 c, in float t )\n{\t\n\treturn abs(v) < r? v : c + t * (c - v);\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r, in vec3 c, in float t )\n{\t\n\treturn abs(v) < r? v : c + t * (c - v);\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r, in vec4 c, in float t )\n{\t\n\treturn abs(v) < r? v : c + t * (c - v);\n}\n\n// Clip v if in the negative half plane defined by r (", "\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - max(w1,w2);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h2 ) - max(w1,w2);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2 )\n{\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h3 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h3 ) - max(w1,w2);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2, float h3 )\n{\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h4 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h4 ) - max(w1,w2);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2, float h3, float h4 )\n{\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h5 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h5 ) - max(w1,w2);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float h2, float h3, float h4, float h5 )\n{\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h6 = clamp( dot", "\t\n\tvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\n\tvec3 sunCol2 = vec3(1.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol3 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol4 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol5 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol6 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol7 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol8 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol9 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol10 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol11 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol12 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol13 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol14 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol15 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol16 = vec3(0.0, 0.0, 0.0) / 4255.0;\n\tvec3 sunCol17 = vec3(0.0, 0.0", "\t\n\tvec4 p = p0 * (2.0 * t * t * t) + p1 * (t * t * (3.0 - 2.0 * t)) + p2 * (t * (3.0 * t - 5.0 * t + 2.0)) + p3 * ((t - 1.0) * (t - 1.0) * (t - 1.0));\n\treturn p;\n}\n\n// This is a spline used for the camera path\nvec4 Bezier(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\t\n\tvec4 p = p0 * (t * t * t) + p1 * (3.0 * t * t * (1.0 - t)) + p2 * (3.0 * t * (1.0 - t) * (1.0 - t)) + p3 * ((1.0 - t) * (1.0 - t) * (1.0 - t));\n\treturn p;\n}\n\n// This is a spline used for the camera path\nvec4 Hermite(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\t\n\tvec4 p = p0 * (2.0 * t * t * t - 3.0 * t * t + 1.0) + p1 * (t * t * t - 2.0 * t * t + t) + p2 * (t * t * t - t * t) + p3 * (t * t * t - 2.0 * t * t * t + t * t);\n\treturn p;\n}\n\n// This is a spline used for the camera path\nvec4 Akima(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\t\n\tvec4 p = p0 * (t * t * t) + p1 * (3.0 * t * t * (1.0 - t)) + p2 * (3.0 * t * (1.0 - t) * (1.0 - t)) + p3 * ((1.0 - t) * (1.0 - t) * (1.0 - t));\n\treturn p;\n}\n\n// This is a spline used for the camera path\n", "\t\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\t\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\t\n\tfloat f = 0.0;\n\t\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\ta = sin(x + f);\n\t\tb = sin(y + f);\n\t\tc = sin(z + f);\n\t\t\n\t\tf += 0.5;\n\t}\n\t\n\treturn normalizer * (a + b + c);\n}\n", "\t\n\tvec4 p0 = CamPos0;\n\tvec4 p1 = CamPos1;\n\tvec4 p2 = CamPos2;\n\tvec4 p3 = CamPos3;\n\t\n\tvec4 p0p1 = p1 - p0;\n\tvec4 p1p2 = p2 - p1;\n\tvec4 p2p3 = p3 - p2;\n\t\n\tvec4 p0p2 = p2 - p0;\n\tvec4 p1p3 = p3 - p1;\n\t\n\tvec4 p0p3 = p3 - p0;\n\t\n\tvec4 p0p1p2 = p1p2 - p0p1;\n\tvec4 p1p2p3 = p2p3 - p1p2;\n\t\n\tvec4 p0p2p3 = p2p3 - p0p2;\n\t\n\tvec4 p0p1p3 = p1p3 - p0p1;\n\t\n\tvec4 p0p1p2p3 = p1p2p3 - p0p1p2;\n\t\n\tvec4 p0p2p3p1 = p1p3 - p0p2p3;\n\t\n\tvec4 p0p1p3p2 = p2p3 - p0p1p3;\n\t\n\tvec4 p0p1p2p3p2 = p2p3 - p0p1p2p3;\n\t\n\tvec4 p0p2p3p1p2 = p1p3 - p0p2p3p1;\n\t\n\tvec4 p0p1p3p2p1 = p2p3 - p0p1p3p2;\n\t\n\tvec4 p0p1p2p3p2p1 = p2p3 - p0p1p2p3p2;\n\t\n\tvec4 p0p2p3p1p2p1 = p1p3 - p0p2p3p1p2;\n\t\n\tvec4 p0p1p3p2p1p2 = p2p3 - p0p1p3p2p1;\n\t\n\tvec4 p0p1p2p3p2p1p2 = p2p3 - p0p1p2p3p2p1;\n\t\n\tvec4 p0p2p3p1p2p1p2 = p1p3 - p0", "\t\n\tu = (u + 37.0) * 0.1031;\n\treturn fract(u);\n}\n\nfloat Hash2d(float x, float y)\n{\n\tfloat u = (x + y) * 0.1031;\n\treturn fract(u);\n}\n\nfloat Hash3d(float x, float y, float z)\n{\n\tfloat u = (x + y + z) * 0.1031;\n\treturn fract(u);\n}\n\nfloat Hash4d(float x, float y, float z, float w)\n{\n\tfloat u = (x + y + z + w) * 0.1031;\n\treturn fract(u);\n}\n\nfloat Noise1d(float x)\n{\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = Hash1d(i);\n\tfloat v = Hash1d(i + 1.0);\n\treturn mix(u, v, f);\n}\n\nfloat Noise2d(float x, float y)\n{\n\tfloat i = floor(x);\n\tfloat j = floor(y);\n\tfloat f = fract(x);\n\tfloat u = Hash2d(i, j);\n\tfloat v = Hash2d(i + 1.0, j);\n\tfloat w = Hash2d(i, j + 1.0);\n\tfloat x = Hash2d(i + 1.0, j + 1.0);\n\treturn mix(mix(u, v, f), mix(w, x, f), j);\n}\n\nfloat Noise3d(float x, float y, float z)\n{\n\tfloat i = floor(x);\n\tfloat j = floor(y);\n\tfloat k = floor(z);\n\tfloat f = fract(x);\n\tfloat u = Hash3d(i, j, k);\n\tfloat v = Hash3d(i + 1.0, j, k);\n\tfloat w = Hash3d(i, j + 1.0, k);\n\tfloat x = Hash3d(i + 1.0, j + 1.0, k);\n\tfloat y = Hash3d(i, j, k + 1.0);\n\tfloat z = Hash3d(i + 1.0, j, k + 1.0);\n\tfloat w = Hash3d(i, j + 1.0, k + 1.0);\n\tfloat x = Hash3d(i + 1.0, j + 1.0, k + 1.0);\n\treturn mix(mix(mix(u, v, f), mix(w, x, f), j), mix(mix(y, z,", "\t\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat aw = 0.0;\n\tfloat ax = 0.0;\n\tfloat ay = 0.0;\n\tfloat az = 0.0;\n\tfloat ba = 0.0;\n\tfloat bb = 0.0;\n\tfloat bc = 0.0;\n\tfloat bd = 0.0;\n\tfloat be = 0.0;\n\tfloat bf = 0.0;\n\tfloat bg = 0.0;\n\tfloat bh = 0.0;\n\tfloat bi = 0.0;\n\tfloat bj = ", "\t\n\tfloat d = 0.0;\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x) + abs(p.y) + abs(p.z);\n\t\n\t// This is the main fractal shape\n\td = abs(p.x)", "\t\n\tvec3 color = vec3(0.0);\n\t\n\t// Softbox\n\tcolor += 0.5 * (1.0 - dot(rayDir, sunDir)) * vec3(0.5, 0.5, 0.5);\n\t\n\t// Lights\n\tcolor += 0.5 * (1.0 - dot(rayDir, sunDir)) * vec3(0.5, 0.5, 0.5);\n\t\n\t// Bottom-to-top fade\n\tcolor *= 1.0 - (rayDir.y + 1.0) * 0.5;\n\t\n\treturn color;\n}\n", " \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);  \n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) + k*h*(1.0-h);  \n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);  \n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) + k*h*(1.0-h);  \n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);  \n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) + k*h*(1.0-h);  \n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ \n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h", "\t\n\tfloat a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n\tfloat b = 2.0 * dot(dirVecPLZNormalizeMeFirst, pos - spherePos);\n\tfloat c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t\treturn -1.0;\n\telse\n\t\treturn (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nfloat PlaneIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos, vec3 planeNormal)\n{\n\tfloat denom = dot(dirVecPLZNormalizeMeFirst, planeNormal);\n\tif (denom == 0.0)\n\t\treturn -1.0;\n\telse\n\t\treturn (dot(planePos - pos, planeNormal) + dot(planeNormal, pos)) / denom;\n}\n\nfloat TriangleIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 v0, vec3 v1, vec3 v2)\n{\n\tvec3 edge1 = v1 - v0;\n\tvec3 edge2 = v2 - v0;\n\tvec3 h = cross(dirVecPLZNormalizeMeFirst, edge2);\n\tfloat a = dot(edge1, h);\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn -1.0;\n\tfloat f = 1.0 / a;\n\tvec3 s = pos - v0;\n\tfloat u = f * dot(s, h);\n\tif (u < 0.0 || u > 1.0)\n\t\treturn -1.0;\n\tvec3 q = cross(s, edge1);\n\tfloat v = f * dot(dirVecPLZNormalizeMeFirst, q);\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn -1.0;\n\tfloat t = f * dot(edge2, q);\n\treturn t;\n}\n\nfloat TriangleIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 v0, vec3 v1, vec3 v2, vec3 normal)\n{\n\tvec3 edge1 = v1 - v0;\n\tvec3 edge2 = v2 - v0;\n\tvec3 h = cross(dirVecPLZNormalizeMeFirst, edge2);\n\tfloat a = dot(edge1, h", "\t\n\tvec3 q = p - vec3(0.0, 0.0, 0.0);\n\tfloat d = length(q);\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToSphere(vec3 p, float r)\n{\n\tvec3 q = p - vec3(0.0, 0.0, 0.0);\n\tfloat d = length(q) - r;\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToPlane(vec3 p, vec3 n)\n{\n\tfloat d = dot(p, n);\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToBox(vec3 p, vec3 b)\n{\n\tvec3 q = p - b;\n\tfloat d = max(abs(q.x), max(abs(q.y), abs(q.z)));\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToCylinder(vec3 p, vec3 b, float r)\n{\n\tvec3 q = p - b;\n\tfloat d = length(q.xz) - r;\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToCone(vec3 p, vec3 b, float r)\n{\n\tvec3 q = p - b;\n\tfloat d = length(q.xz) - r;\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToTorus(vec3 p, vec3 b, float r1, float r2)\n{\n\tvec3 q = p - b;\n\tfloat d = length(q.xz) - r1;\n\td = max(d, length(q.yz) - r2);\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToTorus(vec3 p, vec3 b, float r1, float r2, float h)\n{\n\tvec3 q = p - b;\n\tfloat d = length(q.xz) - r1;\n\td = max(d, length(q.yz) - r2);\n\td = max(d, abs(q.y) - h);\n\treturn vec2(d, d);\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToTorus(vec3 p, vec3 b, float r1, float r2, float h, float a)\n{\n\tvec3 q =", "\t\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n\treturn vec3(0.0, 0.0, 1.0);\n}\n\nvec3 mapD2(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD15(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD16(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD17(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD18(float t)\n{\n\treturn vec3(0.0", "\t\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 2.0 * t - 1.0;\n\tp.y = 2.0 * t * t - 1.0;\n\tp.z = 4.0 * t * t * t - 3.0 * t;\n\treturn p;\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 2.0;\n\tp.y = 4.0 * t;\n\tp.z = 12.0 * t * t - 3.0;\n\treturn p;\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 0.0;\n\tp.y = 4.0;\n\tp.z = 24.0 * t;\n\treturn p;\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 0.0;\n\tp.y = 0.0;\n\tp.z = 24.0;\n\treturn p;\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 0.0;\n\tp.y = 0.0;\n\tp.z = 0.0;\n\treturn p;\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 0.0;\n\tp.y = 0.0;\n\tp.z = 0.0;\n\treturn p;\n}\n\n// curve seventh derivative (bounce)\nvec3 mapD7(float t)\n{\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tp.x = 0.0;\n\tp.y = 0.0;\n\tp.z = 0.0;\n\treturn p;\n}\n\n// curve eighth derivative (crunch)\nvec3 mapD8(float t)\n{\n\tvec3 p = vec3(0.0", "\t\n\tvec3 p = position;\n\tp.yz *= mat2(0.8, 0.6, -0.6, 0.8);\n\tp.xz *= mat2(0.8, 0.6, -0.6, 0.8);\n\tp.xy *= mat2(0.8, 0.6, -0.6, 0.8);\n\tp *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xy *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.yz *= 1.0 + 0.5 * sin(10.0 * t);\n\tp.xz *=", "\t\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\t\n\tfloat t = dot( pa, ba ) / dot( ba, ba );\n\t\n\tif( t < 0.0 ) return vec2( dot( pa, pa ), 0.0 );\n\tif( t > 1.0 ) return vec2( dot( pa - ba, pa - ba ), 1.0 );\n\t\n\treturn vec2( dot( pa - ba * t, pa - ba * t ), t );\n}\n\n// signed squared distance between point and segment\nvec2 ssqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\t\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\t\n\tfloat t = dot( pa, ba ) / dot( ba, ba );\n\t\n\tif( t < 0.0 ) return vec2( dot( pa, pa ), -1.0 );\n\tif( t > 1.0 ) return vec2( dot( pa - ba, pa - ba ), 1.0 );\n\t\n\treturn vec2( dot( pa - ba * t, pa - ba * t ), t );\n}\n\n// signed squared distance between point and line\nvec2 ssqdPointLine( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\t\n\tfloat t = dot( pa, ba ) / dot( ba, ba );\n\t\n\tif( t < 0.0 ) return vec2( dot( pa, pa ), -1.0 );\n\tif( t > 1.0 ) return vec2( dot( pa - ba, pa - ba ), 1.0 );\n\t\n\treturn vec2( dot( pa - ba * t, pa - ba * t ), t );\n}\n\n// signed squared distance between point and triangle\nvec2 ssqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n\tvec2 ca = ssqdPointLine( p, a, c );\n\tvec2 ab = ssqdPointLine( p, a, b );\n\tvec2 bc = ssqdPointLine( p, b, c );\n\t\n\tif( ca.x < ab.x && ca.x < bc.x ) return ca;\n\tif( ab.x < ca.x && ab.x < bc.x ) return ab;\n\treturn bc;\n}\n\n//", "\t\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat t = dot( ab, ao ) / dot( ab, d );\n\tif( t < 0.0 ) return vec2( dot( ao, ao ), 0.0 );\n\tif( t > 1.0 ) return vec2( dot( ab, ab ), 1.0 );\n\treturn vec2( dot( ao - t * d, ao - t * d ), t );\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\t\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat t = dot( ab, ao ) / dot( ab, d );\n\tif( t < 0.0 ) return vec2( dot( ao, ao ), -1.0 );\n\tif( t > 1.0 ) return vec2( dot( ab, ab ), 1.0 );\n\treturn vec2( dot( ao - t * d, ao - t * d ), t );\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\t\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat t = dot( ab, ao ) / dot( ab, d );\n\tif( t < 0.0 ) return vec2( dot( ao, ao ), -1.0 );\n\tif( t > 1.0 ) return vec2( dot( ab, ab ), 1.0 );\n\treturn vec2( dot( ao - t * d, ao - t * d ), t );\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\t\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat t = dot( ab, ao ) / dot( ab, d );\n\tif( t < 0.0 ) return vec2( dot( ao, ao ), -1.0 );\n\tif( t > 1.0 ) return vec2( dot( ab, ab ), 1.0 );\n\treturn vec2( dot( ao - t * d, ao - t * d ), t );\n}\n\n// signed squared distance between", " \n    vec2 q = abs(p)-b;\n    return min(max(q.x,r.x),max(q.y,r.y))-min(min(q.x,r.z),min(q.y,r.w)); \n} \n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{ \n    vec3 q = abs(p)-b;\n    return min(max(q.x,r.x),max(q.y,r.y))-min(min(q.x,r.z),min(q.y,r.w)); \n} \n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,r.x),max(q.y,r.y))-min(min(q.x,r.z),min(q.y,r.w)); \n} \n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r ) \n{ \n    vec2 q = abs(p)-b;\n    return min(max(q.x,r.x),max(q.y,r.y))-min(min(q.x,r.z),min(q.y,r.w)); \n} \n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec2 r ) \n{ \n    vec3 q = abs(p)-b;\n    return min(max(q.x,r.x),max(q.y,r.y))-min(min(q.x,r.z),min(q.y,r.w)); \n} \n\n// b.x = width\n// b.y = height\n// r.x = roundness", "\t\n\tvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\n\tvec3 sunCol2 = vec3(1.0, 1.0, 1.0) / 3555.0;\n\t\n\tvec3 sunColFinal = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal2 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal3 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal4 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal5 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal6 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal7 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal8 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal9 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal10 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal11 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal12 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal13 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal14 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal15 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal16 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal17 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal18 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal19 = mix(sunCol, sunCol2, 0.5);\n\t\n\tvec3 sunColFinal20 = mix(sunCol, sunCol2, 0.", "\t\n\t// This is the rotation matrix that we will use to rotate the window\n\t// to the direction we want it to be facing.\n\tmat3 m = mat3( vec3( cos(roll), sin(roll), 0.0 ), \n\t\t\t\t  vec3( -sin(roll), cos(roll), 0.0 ), \n\t\t\t\t  vec3( 0.0, 0.0, 1.0 ) );\n\t\n\t// This is the translation matrix that we will use to move the window\n\t// to the position we want it to be in.\n\tmat3 t = mat3( vec3( 1.0, 0.0, 0.0 ), \n\t\t\t\t  vec3( 0.0, 1.0, 0.0 ), \n\t\t\t\t  vec3( ro.x, ro.y, ro.z ) );\n\t\n\t// This is the final matrix that we will use to transform the rays\n\t// coming out of our eyes and going through the window.\n\treturn t * m;\n}", " //x: radius, y: height, z: width\n    vec2 result = vec2(0.0, 0.0);\n    vec3 currentRayPosition2 = currentRayPosition;\n    currentRayPosition2.y += 0.5;\n    float distance = length(currentRayPosition2);\n    float radius = currentRayPosition.x;\n    float height = currentRayPosition.y;\n    float width = currentRayPosition.z;\n    float height2 = height * 0.5;\n    float width2 = width * 0.5;\n    float radius2 = radius * 0.5;\n    float distance2 = distance * 0.5;\n    float distance3 = distance * 0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", " \n  float dist1 = distance( thing1, vec2( 0.0, 0.0 ) );\n  float dist2 = distance( thing2, vec2( 0.0, 0.0 ) );\n  if( dist1 < dist2 ){\n    return thing1;\n  } else {\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){ \n  float dist1 = distance( thing1, vec2( 0.0, 0.0 ) );\n  float dist2 = distance( thing2, vec2( 0.0, 0.0 ) );\n  if( dist1 < dist2 ){\n    return thing1;\n  } else {\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){ \n  float dist1 = distance( thing1, vec2( 0.0, 0.0 ) );\n  float dist2 = distance( thing2, vec2( 0.0, 0.0 ) );\n  if( dist1 < dist2 ){\n    return thing1;\n  } else {\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){ \n  float dist1 = distance( thing1, vec2( 0.0, 0.0 ) );\n  float dist2 = distance( thing2, vec2( 0.0, 0.0 ) );\n  if( dist1 < dist2 ){\n    return thing1;\n  } else {\n    return thing2;\n  }\n}\n\n// 'TAG : WHICH AM I C", " // 0.0f = no collision, 1.0f = collision\n    vec3 rayDirection = normalize( currentRayPosition );\n    vec3 rayPosition = currentRayPosition;\n    float rayLength = 0.0f;\n    float rayLengthToClosest = 0.0f;\n    float rayLengthToSecondClosest = 0.0f;\n    float rayLengthToThirdClosest = 0.0f;\n    float rayLengthToFourthClosest = 0.0f;\n    float rayLengthToFifthClosest = 0.0f;\n    float rayLengthToSixthClosest = 0.0f;\n    float rayLengthToSeventhClosest = 0.0f;\n    float rayLengthToEighthClosest = 0.0f;\n    float rayLengthToNinthClosest = 0.0f;\n    float rayLengthToTenthClosest = 0.0f;\n    float rayLengthToEleventhClosest = 0.0f;\n    float rayLengthToTwelfthClosest = 0.0f;\n    float rayLengthToThirteenthClosest = 0.0f;\n    float rayLengthToFourteenthClosest = 0.0f;\n    float rayLengthToFifteenthClosest = 0.0f;\n    float rayLengthToSixteenthClosest = 0.0f;\n    float rayLengthToSeventeenthClosest = 0.0f;\n    float rayLengthToEighteenthClosest = 0.0f;\n    float rayLengthToNineteenthClosest = 0.0f;\n    float rayLengthToTwentiethClosest = 0.0f;\n    float rayLengthToTwentyFirstClosest = 0.0f;\n    float rayLengthToTwentySecondClosest = 0.0f;\n    float rayLengthToTwentyThirdClosest = 0.0f;\n    float rayLengthToTwentyFourthClosest = 0.0f;\n    float rayLengthToTwentyFifthClosest = 0.0f;\n    float rayLengthToTwentySixthClosest = 0.0f;\n    float rayLengthToTwentySeventhClosest = 0.0f;\n    float rayLengthToTwentyEighthClosest = 0.0f;\n    float rayLengthToTwentyNinthClose", " \n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec2 epsilon = vec2(0.001, 0.0);\n    vec3 posPlusEps = vec3(positionOfHit.x + epsilon.x, positionOfHit.y, positionOfHit.z);\n    vec3 posMinusEps = vec3(positionOfHit.x - epsilon.x, positionOfHit.y, positionOfHit.z);\n    vec3 posPlusEpsY = vec3(positionOfHit.x, positionOfHit.y + epsilon.y, positionOfHit.z);\n    vec3 posMinusEpsY = vec3(positionOfHit.x, positionOfHit.y - epsilon.y, positionOfHit.z);\n    float sdfPlusEps = getDistanceFromSurface(posPlusEps);\n    float sdfMinusEps = getDistanceFromSurface(posMinusEps);\n    float sdfPlusEpsY = getDistanceFromSurface(posPlusEpsY);\n    float sdfMinusEpsY = getDistanceFromSurface(posMinusEpsY);\n    normal.x = sdfPlusEps - sdfMinusEps;\n    normal.y = sdfPlusEpsY - sdfMinusEpsY;\n    normal.z = 0.0;\n    return normalize(normal);\n}", " return vec3(0.0); }\n\n// this is the main function that will be called\n// for every pixel in the scene. it will be called\n// once for every pixel in the scene, and it will\n// be called in the order that the pixels are\n// drawn in. so if you want to draw something\n// in the background, you should draw it first.\n// if you want to draw something in the foreground,\n// you should draw it last.\nvec4 doPixel(vec2 pixelPosition, vec2 pixelSize, vec3 pixelColor, vec3 pixelNormal, vec3 pixelPositionInWorldSpace, vec3 pixelPositionInCameraSpace, vec3 pixelPositionInEyeSpace, vec3 pixelPositionInEyeSpaceNormalized, vec3 pixelPositionInEyeSpaceNormalizedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrected, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClamped, vec3 pixelPositionInEyeSpaceNormalizedAndClampedAndPerspectiveCorrectedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClampedAndClamped", "\n\n\n    // This is the color of the box\n    vec3 boxColor = vec3(0.0, 0.0, 0.0);\n\n    // This is the color of the light\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    // This is the position of the light\n    vec3 lightPosition = vec3(0.0, 0.0, 0.0);\n\n    // This is the intensity of the light\n    float lightIntensity = 1.0;\n\n    // This is the distance from the light to the surface\n    float distanceToLight = length(lightPosition - positionOfHit);\n\n    // This is the intensity of the light at the surface\n    float intensityAtSurface = lightIntensity / (distanceToLight * distanceToLight);\n\n    // This is the color of the light at the surface\n    vec3 lightAtSurface = lightColor * intensityAtSurface;\n\n    // This is the color of the surface\n    vec3 surfaceColor = boxColor;\n\n    // This is the color of the surface with the light\n    vec3 surfaceWithLight = surfaceColor + lightAtSurface;\n\n    // This is the color of the surface with the light and the normal\n    vec3 surfaceWithLightAndNormal = surfaceWithLight + normalOfSurface;\n\n    // This is the color of the surface with the light and the normal and the intensity\n    vec3 surfaceWithLightAndNormalAndIntensity = surfaceWithLightAndNormal * intensityAtSurface;\n\n    // This is the color of the surface with the light and the normal and the intensity and the distance\n    vec3 surfaceWithLightAndNormalAndIntensityAndDistance = surfaceWithLightAndNormalAndIntensity * distanceToLight;\n\n    // This is the color of the surface with the light and the normal and the intensity and the distance and the position\n    vec3 surfaceWithLightAndNormalAndIntensityAndDistanceAndPosition = surfaceWithLightAndNormalAndIntensityAndDistance * positionOfHit;\n\n    // This is the color of the surface with the light and the normal and the intensity and the distance and the position and the light\n    vec3 surfaceWithLightAndNormalAndIntensityAndDistanceAndPositionAndLight = surfaceWithLightAndNormalAndIntensityAndDistanceAndPosition * lightPosition;\n\n    // This is the color of the surface with the light and the normal and the intensity and the distance and the position and the light", "\n\n\n    // This is the color of the sky\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient from blue to purple\n    // It is a gradient", " return pow(x, b) / (pow(x, b) + pow(1.0 - x, b)); }\n\n// smoothstep with bias\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat biasstep(float x, float b) { return bias(x, b) * (1.0 - bias(1.0 - x, b)); }\n\n// smoothstep with bias\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat biasstep(float x, float b) { return bias(x, b) * (1.0 - bias(1.0 - x, b)); }\n\n// smoothstep with bias\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat biasstep(float x, float b) { return bias(x, b) * (1.0 - bias(1.0 - x, b)); }\n\n// smoothstep with bias\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat biasstep(float x, float b) { return bias(x, b) * (1.0 - bias(1.0 - x, b)); }\n\n// smoothstep with bias\n//", " return fract(sin(dot(p.xy, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){ return fract(sin(dot(p.xyz, vec3(12.9898, 4.1414, 1.0))) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){ return fract(sin(dot(p.xyzw, vec4(12.9898, 4.1414, 1.0, 1.0))) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float seed){ return fract(sin(dot(p.xy, vec2(12.9898, 4.1414)) + seed) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float seed){ return fract(sin(dot(p.xyz, vec3(12.9898, 4.1414, 1.0)) + seed) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p, float seed){ return fract(sin(dot(p.xyzw, vec4(12.9898, 4.1414, 1.0, 1.0)) + seed) * 43758.5453); }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float seed, float scale){ return fract(sin(dot(p.xy, vec2(12.9898, 4.1414)) + seed) * 43758.5453) * scale; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float seed, float scale){ return fract(sin(dot(p.xyz, vec3(12.9898, 4.1414, 1.0)) + seed) * 43758.5453) * scale; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p, float", " return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453) - 0.5; }\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_exclusive_inclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453) - 0.5; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453) - 1.0; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_inclusive_exclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_exclusive_inclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453) - 1.0; }\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453) - 1.0; }\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_inclusive_exclusive(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 4.1414)))", " \n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r --> is torus radius\n// input t --> is torus tube radius\n// pretty simple, just compare point to torus size\nfloat sdTorus(vec3 p, float r, float t)\n{\n    vec2 q = vec2(length(p.xz) - r, p.y);\n    return length(q) - t;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to cylinder size\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h/2.0);\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to cone size\nfloat sdCone(vec3 p, float r, float h)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = length(q) - r;\n    float h2 = h*h;\n    float qy = q.y;\n    float qy2 = qy*qy;\n    float h1 = h2 - qy2;\n    float h3 = h1*h1;\n    float h4 = h3 - h2*qy2;\n    float h5 = h4*h4;\n    float h6 = h5 - h3*h4;\n    float h7 = h6*h6;\n    float h8 = h7 - h5*h6;\n    float h9 = h8*h8;\n    float h10 = h9 - h7*h8;\n    float h11 = h10*h10;\n    float h12 = h11 - h9*h10", "\t\n\tp = p.xz;\n\tfloat r = length(p);\n\tfloat d = r - t.x;\n\treturn d - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\t\n\tp = p.xz;\n\tfloat r = length(p);\n\tfloat d = r - t.x;\n\treturn d - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\t\n\tp = p.xz;\n\tfloat r = length(p);\n\tfloat d = r - t.x;\n\treturn d - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\t\n\tp = p.xz;\n\tfloat r = length(p);\n\tfloat d = r - t.x;\n\treturn d - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n// \tt.x = torus circumference\n//\tt.y = torus thickness\n//  \n// think", " \n    float h = clamp( 0.5 + 0.5*(d2-d1)/length(d2-d1), 0.0, 1.0 );\n    return mix( d2, d1, h ) - h*h*h*h*h; \n}\n\n// ~~~~~~~ smooth minimum function (quadratic version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{ \n    float h = clamp( 0.5 + 0.5*(d2-d1)/length(d2-d1), 0.0, 1.0 );\n    return lerp( d2, d1, h*h*h ) - (h*(1.0-h*h*h)*h); \n}\n\n// ~~~~~~~ smooth minimum function (cubic version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{ \n    float h = clamp( 0.5 + 0.5*(d2-d1)/length(d2-d1), 0.0, 1.0 );\n    return lerp( d2, d1, h*h ) - h*(1.0-h)*h; \n}\n\n// ~~~~~~~ smooth minimum function (quartic version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{ \n    float h = clamp( 0.5 + 0.5*(d2-d1)/length(d2-d1), 0.0, 1.0 );\n    return lerp( d2, d1, h*h*h ) - h*(1.0-h*h)*h; \n}\n\n// ~~~~~~~ smooth minimum function (quintic version) from iq's page\n// http://iquilezles.org/www", " \n    float d = d1 + d2;\n    float d1d = d1 / d;\n    float d2d = d2 / d;\n    return d1d * d1d * d1d + d2d * d2d * d2d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{ \n    float d = d1 + d2;\n    float d1d = d1 / d;\n    float d2d = d2 / d;\n    return d1d * d1d * d1d + d2d * d2d * d2d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{ \n    float d = d1 + d2;\n    float d1d = d1 / d;\n    float d2d = d2 / d;\n    return d1d * d1d * d1d + d2d * d2d * d2d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{ \n    float d = d1 + d2;\n    float d1d = d1 / d;\n    float d2d = d2 / d;\n    return d1d * d1d * d1d + d2d * d2d * d2d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{ \n    float d = d1 + d2;\n    float d1d = d1 / d;\n    float d2d = d2 / d;\n    return d1d * d1d * d", "\t\n\tfloat maxItter = 100.0;\n\tfloat itter = 0.0;\n\tfloat twist = 0.0;\n\tfloat twistScale = 0.0;\n\tfloat twistScale2 = 0.0;\n\tfloat twistScale3 = 0.0;\n\tfloat twistScale4 = 0.0;\n\tfloat twistScale5 = 0.0;\n\tfloat twistScale6 = 0.0;\n\tfloat twistScale7 = 0.0;\n\tfloat twistScale8 = 0.0;\n\tfloat twistScale9 = 0.0;\n\tfloat twistScale10 = 0.0;\n\tfloat twistScale11 = 0.0;\n\tfloat twistScale12 = 0.0;\n\tfloat twistScale13 = 0.0;\n\tfloat twistScale14 = 0.0;\n\tfloat twistScale15 = 0.0;\n\tfloat twistScale16 = 0.0;\n\tfloat twistScale17 = 0.0;\n\tfloat twistScale18 = 0.0;\n\tfloat twistScale19 = 0.0;\n\tfloat twistScale20 = 0.0;\n\tfloat twistScale21 = 0.0;\n\tfloat twistScale22 = 0.0;\n\tfloat twistScale23 = 0.0;\n\tfloat twistScale24 = 0.0;\n\tfloat twistScale25 = 0.0;\n\tfloat twistScale26 = 0.0;\n\tfloat twistScale27 = 0.0;\n\tfloat twistScale28 = 0.0;\n\tfloat twistScale29 = 0.0;\n\tfloat twistScale30 = 0.0;\n\tfloat twistScale31 = 0.0;\n\tfloat twistScale32 = 0.0;\n\tfloat twistScale33 = 0.0;\n\tfloat twistScale34 = 0.0;\n\tfloat twistScale35 = 0.0;\n\tfloat twistScale36 = 0.0;\n\tfloat twistScale37 = 0.0;\n\tfloat twistScale38 = 0.0;\n\tfloat twistScale39 = 0.0;\n\tfloat twistScale40 = 0.0;\n\tfloat twistScale41 = 0.0;\n\tfloat twistScale42 = 0.0;\n\tfloat twistScale43 = 0.0;\n\tfloat twistScale44 = 0.0;\n\tfloat twistScale45 = 0.0;\n\tfloat twistScale46 = 0.0;\n\tfloat twistScale47 = 0.0;\n\tfloat twistScale48 = 0.0;\n\tfloat twistScale49 =", "\t\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\t\n\tif(o1.x < o2.x)\n\t\treturn o2;\n\telse\n\t\treturn o1;\n}\n\n// ~~~~~~~ do Subtraction / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\t\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opD(vec2 o1, vec2 o2)\n{\t\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opA(vec2 o1, vec2 o2)\n{\t\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opB(vec2 o1, vec2 o2)\n{\t\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opC", "\t\n\t// ~~~~~~~~ floor\n\tfloat d = p.y;\n\t\n\t// ~~~~~~~~ ceiling\n\td = min(d, -p.y - 1.0);\n\t\n\t// ~~~~~~~~ walls\n\td = min(d, p.x - 1.0);\n\td = min(d, -p.x - 1.0);\n\td = min(d, p.z - 1.0);\n\td = min(d, -p.z - 1.0);\n\t\n\treturn vec2(d, 1.0);\n}\n\n// ~~~~~~~~ raymarch\n// input p --> is ray position\n// input d --> is ray direction\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 raymarch(vec3 p, vec3 d)\n{\n\tvec2 res = map(p);\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp += d * res.x;\n\t\tres = map(p);\n\t}\n\t\n\treturn res;\n}\n\n// ~~~~~~~~ raymarch with texture\n// input p --> is ray position\n// input d --> is ray direction\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 raymarch(vec3 p, vec3 d, sampler2D tex)\n{\n\tvec2 res = map(p);\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp += d * res.x;\n\t\tres = map(p);\n\t}\n\t\n\treturn res;\n}\n\n// ~~~~~~~~ raymarch with texture\n// input p --> is ray position\n// input d --> is ray direction\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec2 raymarch(vec3 p, vec3 d, sampler2D tex, float scale)\n{\n\tvec2 res = map(p);\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp += d * res.x;\n\t\tres = map(p);\n\t}\n\t\n\treturn res;\n}\n\n// ~~~~~~~~ raymarch with texture\n// input p --> is ray position\n// input d --> is ray direction\n//", "\t\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~~~~ raymarch through the word\n\t// ~~~~~", "\t\n\t// ~~~~~~~~ ray marching\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tvec3 color = vec3(0.0);\n\tvec3 pos = ro;\n\tvec3 dir = rd;\n\tvec3 normal = vec3(0.0);\n\tvec3 light = vec3(0.0);\n\tvec3 lightDir = vec3(0.0);\n\tvec3 lightColor = vec3(0.0);\n\tvec3 lightPos = vec3(0.0);\n\tvec3 lightDirPos = vec3(0.0);\n\tvec3 lightDirPos2 = vec3(0.0);\n\tvec3 lightDirPos3 = vec3(0.0);\n\tvec3 lightDirPos4 = vec3(0.0);\n\tvec3 lightDirPos5 = vec3(0.0);\n\tvec3 lightDirPos6 = vec3(0.0);\n\tvec3 lightDirPos7 = vec3(0.0);\n\tvec3 lightDirPos8 = vec3(0.0);\n\tvec3 lightDirPos9 = vec3(0.0);\n\tvec3 lightDirPos10 = vec3(0.0);\n\tvec3 lightDirPos11 = vec3(0.0);\n\tvec3 lightDirPos12 = vec3(0.0);\n\tvec3 lightDirPos13 = vec3(0.0);\n\tvec3 lightDirPos14 = vec3(0.0);\n\tvec3 lightDirPos15 = vec3(0.0);\n\tvec3 lightDirPos16 = vec3(0.0);\n\tvec3 lightDirPos17 = vec3(0.0);\n\tvec3 lightDirPos18 = vec3(0.0);\n\tvec3 lightDirPos19 = vec3(0.0);\n\tvec3 lightDirPos20 = vec3(0.0);\n\tvec3 lightDirPos21 = vec3(0.0);\n\tvec3 lightDirPos22 = vec3(0.0);\n\tvec3 lightDirPos23 = vec3(0.0);\n\tvec3 lightDirPos24 = vec3(0.0);\n\tvec3 lightDirPos25 = vec3(0.0);\n\tvec3 lightDirPos26 = vec3(0.0);\n\tvec3 lightDirPos27 = vec3(0.0);\n\tvec3 lightDirPos28 = vec3(0.0);\n\tvec3 lightDirPos29 = vec3(0.0);\n", "\t\n\t// calculate camera up vector\n\tvec3 camUp = normalize( cross( targetPos - camPos, vec3( 0.0, 1.0, 0.0 ) ) );\n\t\n\t// calculate camera right vector\n\tvec3 camRight = normalize( cross( camUp, targetPos - camPos ) );\n\t\n\t// calculate camera look at vector\n\tvec3 camLookAt = normalize( targetPos - camPos );\n\t\n\t// calculate camera matrix\n\tmat3 camMatrix = mat3( camRight, camUp, camLookAt );\n\t\n\t// rotate camera matrix\n\tcamMatrix = rotateMatrix( camMatrix, roll, camRight );\n\t\n\treturn camMatrix;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\t\n\t// calculate camera up vector\n\tvec3 camUp = normalize( cross( targetPos - camPos, vec3( 0.0, 1.0, 0.0 ) ) );\n\t\n\t// calculate camera right vector\n\tvec3 camRight = normalize( cross( camUp, targetPos - camPos ) );\n\t\n\t// calculate camera look at vector\n\tvec3 camLookAt = normalize( targetPos - camPos );\n\t\n\t// calculate camera matrix\n\tmat3 camMatrix = mat3( camRight, camUp, camLookAt );\n\t\n\t// rotate camera matrix\n\tcamMatrix = rotateMatrix( camMatrix, roll, camRight );\n\t\n\treturn camMatrix;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\t\n\t// calculate camera up vector\n\tvec3 camUp = normalize( cross( targetPos - camPos, vec3( 0.0, 1.0, 0.0 ) ) );\n\t\n\t// calculate camera right vector\n\tvec3 camRight = normalize( cross( camUp, targetPos - camPos ) );\n\t\n\t// calculate camera look", " \n    if (id < 0.0) return vec3(0.0, 0.0, 0.0);\n    if (id < 1.0) return vec3(1.0, 0.0, 0.0);\n    if (id < 2.0) return vec3(0.0, 1.0, 0.0);\n    if (id < 3.0) return vec3(0.0, 0.0, 1.0);\n    if (id < 4.0) return vec3(1.0, 1.0, 0.0);\n    if (id < 5.0) return vec3(1.0, 0.0, 1.0);\n    if (id < 6.0) return vec3(0.0, 1.0, 1.0);\n    if (id < 7.0) return vec3(1.0, 1.0, 1.0);\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// ~~~~~~~~ 3D array of colors\nvec3 colors[8][8][8] = \n{\n    {\n        {vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0)},\n        {vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.", " \n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{ \n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{ \n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{ \n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//", " \n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        ps.o --> offset\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> size\n//        ps.o --> offset\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.o --> offset\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.o --> offset\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.o --> offset\nfloat sdCone(vec3 p, vec2 c)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q) - c.x;\n    float h = c.y - q.x;\n    return d*d/h/h + max(0.0,q.x-h);\n}\n\n// ~~~~~~~ signed distance function for capsule\n//  input ps --> specs of capsule\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.o --> offset\nfloat sdCapsule(vec3 p, vec2 r, vec2 h)\n{\n    vec3 q = vec", " \n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{ \n    float h = exp( -k*d1-k*d2 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{ \n    float h = exp( -k*d1-k*d2 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{ \n    float h = exp( -k*d1-k*d2 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float", "\t\n\tvec4 o = vec4(0.0);\n\t\n\t// blend distance\n\to.z = mix(o1.z, o2.z, bf);\n\t\n\t// blend color\n\to.rgb = mix(o1.rgb, o2.rgb, bf);\n\t\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\t\n\tvec4 o = vec4(0.0);\n\t\n\t// blend distance\n\to.z = mix(o1.z, o2.z, bf);\n\t\n\t// blend color\n\to.rgb = mix(o1.rgb, o2.rgb, bf);\n\t\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\t\n\tvec4 o = vec4(0.0);\n\t\n\t// blend distance\n\to.z = mix(o1.z, o2.z, bf);\n\t\n\t// blend color\n\to.rgb = mix(o1.rgb, o2.rgb, bf);\n\t\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\t\n\tvec4 o = vec4(0.0);\n\t\n\t// blend distance\n\to.z = mix(o1.z, o2.z, bf);\n\t\n\t// blend color\n\to.rgb = mix(o1.rgb, o2.rgb, bf);\n\t\n\treturn o;\n", " \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n  return d1 - d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{ \n ", "\t\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\t\n\t// ~~~~~~~~ generate light pos\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0, 0.0);\n\t// lightPos = vec3(0.0, 0.0", "\t\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\tfloat d = 1000.0;\n\t\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\t// outputs closest distance and blended colors for that surface as a vec4\n\t// ~~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to", "\t\n\t// ~~~~~~~~ ray march\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.01;\n\tfloat tstep2 = 0.001;\n\tfloat tstep3 = 0.0001;\n\tfloat tstep4 = 0.00001;\n\tfloat tstep5 = 0.000001;\n\tfloat tstep6 = 0.0000001;\n\tfloat tstep7 = 0.00000001;\n\tfloat tstep8 = 0.000000001;\n\tfloat tstep9 = 0.0000000001;\n\tfloat tstep10 = 0.00000000001;\n\tfloat tstep11 = 0.000000000001;\n\tfloat tstep12 = 0.0000000000001;\n\tfloat tstep13 = 0.00000000000001;\n\tfloat tstep14 = 0.000000000000001;\n\tfloat tstep15 = 0.0000000000000001;\n\tfloat tstep16 = 0.00000000000000001;\n\tfloat tstep17 = 0.000000000000000001;\n\tfloat tstep18 = 0.0000000000000000001;\n\tfloat tstep19 = 0.00000000000000000001;\n\tfloat tstep20 = 0.000000000000000000001;\n\tfloat tstep21 = 0.0000000000000000000001;\n\tfloat tstep22 = 0.00000000000000000000001;\n\tfloat tstep23 = 0.000000000000000000000001;\n\tfloat tstep24 = 0.0000000000000000000000001;\n\tfloat tstep25 = 0.00000000000000000000000001;\n\tfloat tstep26 = 0.000000000000000000000000001;\n\tfloat tstep27 = 0.0000000000000000000000000001;\n\tfloat tstep28 = 0.00000000000000000000000000001;\n\tfloat tstep29 = 0.000000000000000000000000000001;\n\tfloat tstep30 = 0.0000000000000000000000000000001;\n\tfloat tstep31 = 0.00000000000000000000000000000001;\n\tfloat tstep", "\t\n\tvec3 dir = normalize(lp-sp);\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat h = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\tfloat Z = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0", "\t\n\tvec3 dir = normalize(nor);\n\tfloat dist = 0.0;\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat occlusion = 1.0;\n\t\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tt = dist + 0.01;\n\t\td = length(sp + t * dir);\n\t\tocclusion -= 0.1 * (d - t);\n\t\tdist += d;\n\t}\n\t\n\treturn occlusion;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor, float dist)\n{\t\n\tvec3 dir = normalize(nor);\n\tfloat occlusion = 1.0;\n\t\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfloat t = dist + 0.01;\n\t\tfloat d = length(sp + t * dir);\n\t\tocclusion -= 0.1 * (d - t);\n\t\tdist += d;\n\t}\n\t\n\treturn occlusion;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor, float dist, float radius)\n{\t\n\tvec3 dir = normalize(nor);\n\tfloat occlusion = 1.0;\n\t\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfloat t = dist + 0.01;\n\t\tfloat d = length(sp + t * dir);\n\t\tocclusion -= 0.1 * (d - t);\n\t\tdist += d;\n\t}\n\t\n\treturn occlusion;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor, float dist, float radius, float radius", "\t\n\tvec3 n = vec3(0.0);\n\tvec3 d = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\t\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal at point p\n\t// ~~~~~~~~ calculate the normal", "\t\n\t// gamma correction\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t// c = pow(c, vec3(1.0/2.2));\n\t//", "\t\n\tfloat d2 = d*d;\n\tfloat d3 = d2*d;\n\tfloat d4 = d3*d;\n\tfloat d5 = d4*d;\n\tfloat d6 = d5*d;\n\tfloat d7 = d6*d;\n\tfloat d8 = d7*d;\n\tfloat d9 = d8*d;\n\tfloat d10 = d9*d;\n\tfloat d11 = d10*d;\n\tfloat d12 = d11*d;\n\tfloat d13 = d12*d;\n\tfloat d14 = d13*d;\n\tfloat d15 = d14*d;\n\tfloat d16 = d15*d;\n\tfloat d17 = d16*d;\n\tfloat d18 = d17*d;\n\tfloat d19 = d18*d;\n\tfloat d20 = d19*d;\n\tfloat d21 = d20*d;\n\tfloat d22 = d21*d;\n\tfloat d23 = d22*d;\n\tfloat d24 = d23*d;\n\tfloat d25 = d24*d;\n\tfloat d26 = d25*d;\n\tfloat d27 = d26*d;\n\tfloat d28 = d27*d;\n\tfloat d29 = d28*d;\n\tfloat d30 = d29*d;\n\tfloat d31 = d30*d;\n\tfloat d32 = d31*d;\n\tfloat d33 = d32*d;\n\tfloat d34 = d33*d;\n\tfloat d35 = d34*d;\n\tfloat d36 = d35*d;\n\tfloat d37 = d36*d;\n\tfloat d38 = d37*d;\n\tfloat d39 = d38*d;\n\tfloat d40 = d39*d;\n\tfloat d41 = d40*d;\n\tfloat d42 = d41*d;\n\tfloat d43 = d42*d;\n\tfloat d44 = d43*d;\n\tfloat d45 = d44*d;\n\tfloat d46 = d45*d;\n\tfloat d47 = d46*d;\n\tfloat d48 = d47*d;\n\tfloat d49 = d48*d;\n\tfloat d50 = d49*d;\n\tfloat d51 = d50*d;\n\tfloat d52 = d51*d;\n\tfloat d53 = d52*d;\n\tfloat d54 = d53*d;\n\tfloat d55 = d54*d;\n\tfloat d56 = d55*d;\n\tfloat d57 = d56*d;\n\tfloat d58 = d57*d;\n\tfloat d59 = d58*d;\n\tfloat d60 = d59*d;\n\tfloat d61 = d60*d;\n\tfloat d62 = d61*d;\n\tfloat d63 = d62*d;\n\tfloat d64 = d63*d;\n\tfloat d65 = d64*d;\n", " \n  float attn = 1.0;\n  attn = attn * cF;\n  attn = attn + (lF * d);\n  attn = attn + (qF * d * d);\n  return attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d2)\n{ \n  float attn = 1.0;\n  attn = attn * cF;\n  attn = attn + (lF * d);\n  attn = attn + (qF * d * d);\n  attn = attn + (d2 * d2);\n  return attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d2, float d3)\n{ \n  float attn = 1.0;\n  attn = attn * cF;\n  attn = attn + (lF * d);\n  attn = attn + (qF * d * d);\n  attn = attn + (d2 * d2);\n  attn = attn + (d3 * d3);\n  return attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d2, float d3, float", "\t\n\tvec3 rayDir = vec3(0.0);\n\trayDir.x = (2.0 * fCoord.x - 1.0) / cMatrix[0][0];\n\trayDir.y = (2.0 * fCoord.y - 1.0) / cMatrix[1][1];\n\trayDir.z = 1.0 / cMatrix[2][2];\n\treturn rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n\tvec3 rayOrigin = vec3(0.0);\n\trayOrigin.x = cMatrix[0][0] * fCoord.x + cMatrix[0][1] * fCoord.y + cMatrix[0][2];\n\trayOrigin.y = cMatrix[1][0] * fCoord.x + cMatrix[1][1] * fCoord.y + cMatrix[1][2];\n\trayOrigin.z = cMatrix[2][0] * fCoord.x + cMatrix[2][1] * fCoord.y + cMatrix[2][2];\n\treturn rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nvec3 calculateRay(vec2 fCoord, mat3 cMatrix)\n{\n\tvec3 rayOrigin = calculateRayOrigin(fCoord, cMatrix);\n\tvec3 rayDir = calculateRayDir(fCoord, cMatrix);\n\treturn rayOrigin + rayDir;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nvec3 calculateRay(vec2 fCoord, mat3 cMatrix)\n{\n\tvec3 rayOrigin = calculateRayOrigin(fCoord, cMatrix);\n\tvec3 rayDir = calculateRayDir(fCoord, cMatrix);\n\treturn rayOrigin + rayDir;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nvec3 calculateRay(vec2 fCoord, mat3 cMatrix)\n{\n\tvec3 rayOrigin = calculateRayOrigin(fCoord, cMatrix);\n\tvec", "\t\n\tvec3 color = vec3(0.0);\n\t\n\t// get pixel's position in world space\n\tvec3 pPos = cMat * vec3(fCoord,1.0);\n\t\n\t// get pixel's normal in world space\n\tvec3 pNormal = normalize(cross(dFdx(pPos),dFdy(pPos)));\n\t\n\t// get pixel's ray direction in world space\n\tvec3 pRay = normalize(pPos - cPos);\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in camera space\n\tvec3 pRayCam = cMat * pRay;\n\t\n\t// get pixel's ray direction in", "\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n\t\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\t\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\t\n\tfloat i = 0.0;\n\t\n\tfloat maxIterations = 100.0;\n\t\n\tfloat zoom = 1.0;\n\t\n\tfloat x0 = 0.0;\n\tfloat y0 = 0.0;\n\t\n\tfloat x1 = 0.0;\n\tfloat y1 = 0.0;\n\t\n\tfloat x2 = 0.0;\n\tfloat y2 = 0.0;\n\t\n\tfloat x3 = 0.0;\n\tfloat y3 = 0.0;\n\t\n\tfloat x4 = 0.0;\n\tfloat y4 = 0.0;\n\t\n\tfloat x5 = 0.0;\n\tfloat y5 = 0.0;\n\t\n\tfloat x6 = 0.0;\n\tfloat y6 = 0.0;\n\t\n\tfloat x7 = 0.0;\n\tfloat y7 = 0.0;\n\t\n\tfloat x8 = 0.0;\n\tfloat y8 = 0.0;\n\t\n\tfloat x9 = 0.0;\n\tfloat y9 = 0.0;\n\t\n\tfloat x10 = 0.0;\n\tfloat y10 = 0.0;\n\t\n\tfloat x11 = 0.0;\n\tfloat y11 = 0.0;\n\t\n\tfloat x12 = 0.0;\n\tfloat y12 = 0.0;\n\t\n\tfloat x13 = 0.0;\n\tfloat y13 = 0.0;\n\t\n\tfloat x14 = 0.0;\n\tfloat y14 = 0.0;\n\t\n\tfloat x15 = 0.0;\n\tfloat y15 = 0.0;\n\t\n\tfloat x16 = 0.0;\n\tfloat y16 = 0.0;\n\t\n\tfloat x17 = 0.0;\n\tfloat y17 = 0.0;\n\t\n\tfloat x18 = 0.0;\n\tfloat y18 = 0.0;\n\t\n\tfloat x19 = 0.0;\n\tfloat y19 = 0.0;\n\t\n\tfloat x20 = 0.0;\n\tfloat y20 = 0.0;\n\t\n\tfloat x21 = 0.0;\n\tfloat y21", " \n    vec3 q = abs(p) - radius;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = length(q) - c.x;\n    float h = abs(q.x) - c.y;\n    return length(max(vec2(d,h),0.0)) + min(max(d,h),0.0);\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n)\n{\n    return dot(p,n);\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz) - n.w;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n)\n{\n    return dot(p,n);\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n, float d)\n{\n    return dot(p,n) - d;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n, float d, float w)\n{\n    return dot(p,n) - d - w;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n, float d, float w, float h)\n{\n    return dot(p,n) - d - w - h;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n, float d, float w, float h, float l)\n{\n    return dot(p,n) - d - w - h - l;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, float n, float d, float w, float h, float l, float m)\n{\n    return dot(p,n) - d - w -", "\t\n\treturn length(p) - r;\n}\n\n// simple sphere distance field\nfloat sph(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c, float d)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c, float d, float e)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c, float d, float e, float f)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c, float d, float e, float f, float g)\n{\n\treturn length(vec2(length(p) - r, t)) - t;\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r, float t, float s, float a, float b, float c, float d, float e, float f, float g, float h)\n{\n", "\t\n\t// The distance to the surface is the distance to the nearest point on the surface.\n\t// The material number is the material number of the surface.\n\t\n\t// The surface is a sphere.\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The sphere is centered at the origin.\n\t// The radius of the sphere is 1.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the sphere.\n\t// The material number is the material number of the sphere.\n\t\n\t// The distance to the surface is the distance to the center of the", "\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2*c;\n\tvec2 z4 = z3*c;\n\tvec2 z5 = z4*c;\n\treturn z5;\n}\n\n//Function that returns a complex number to power of 5\nvec2 complexPower5(vec2 c)\n{\t\n\tvec2 z = c;\n\tvec2 z2 = c*c;\n\tvec2 z3 = z2", "\t\n\t//Get the color of the biomorph at position coord\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\t\n\t//Get the x and y components of the morphConstant\n\tfloat x = morphConstant.x;\n\tfloat y = morphConstant.y;\n\t\n\t//Get the x and y components of the coord\n\tfloat xCoord = coord.x;\n\tfloat yCoord = coord.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color\n\tfloat xColor = color.x;\n\tfloat yColor = color.y;\n\t\n\t//Get the x and y components of the color", "\t\n\tvec2 uv2 = uv * 2.0;\n\tvec2 uv3 = uv * 3.0;\n\tvec2 uv4 = uv * 4.0;\n\tvec2 uv5 = uv * 5.0;\n\tvec2 uv6 = uv * 6.0;\n\tvec2 uv7 = uv * 7.0;\n\tvec2 uv8 = uv * 8.0;\n\tvec2 uv9 = uv * 9.0;\n\tvec2 uv10 = uv * 10.0;\n\tvec2 uv11 = uv * 11.0;\n\tvec2 uv12 = uv * 12.0;\n\tvec2 uv13 = uv * 13.0;\n\tvec2 uv14 = uv * 14.0;\n\tvec2 uv15 = uv * 15.0;\n\tvec2 uv16 = uv * 16.0;\n\tvec2 uv17 = uv * 17.0;\n\tvec2 uv18 = uv * 18.0;\n\tvec2 uv19 = uv * 19.0;\n\tvec2 uv20 = uv * 20.0;\n\tvec2 uv21 = uv * 21.0;\n\tvec2 uv22 = uv * 22.0;\n\tvec2 uv23 = uv * 23.0;\n\tvec2 uv24 = uv * 24.0;\n\tvec2 uv25 = uv * 25.0;\n\tvec2 uv26 = uv * 26.0;\n\tvec2 uv27 = uv * 27.0;\n\tvec2 uv28 = uv * 28.0;\n\tvec2 uv29 = uv * 29.0;\n\tvec2 uv30 = uv * 30.0;\n\tvec2 uv31 = uv * 31.0;\n\tvec2 uv32 = uv * 32.0;\n\tvec2 uv33 = uv * 33.0;\n\tvec2 uv34 = uv * 34.0;\n\tvec2 uv35 = uv * 35.0;\n\tvec2 uv36 = uv * 36.0;\n\tvec2 uv37 = uv * 37.0;\n\tvec2 uv38 = uv * 38.0;\n\tvec2 uv39 = uv * 39.0;\n\tvec2 uv40 = uv * 40.0;\n\tvec2 uv41 = uv * 41.0;\n\tvec2 uv42 = uv * 42.0;\n\tvec2 uv43 = uv * 43.0;\n\tvec2 uv44 = uv *", " return x - floor(x); }\nfloat triangle(float x) { return 2.0 * repeat(x) - 1.0; }\n\n// A sawtooth wave\nfloat saw(float x) { return 2.0 * repeat(x) - 1.0; }\n\n// A square wave\nfloat square(float x) { return 2.0 * repeat(x) - 1.0; }\n\n// A sine wave\nfloat sine(float x) { return sin(x * PI); }\n\n// A cosine wave\nfloat cosine(float x) { return cos(x * PI); }\n\n// A triangle wave with a 0.5 offset\nfloat triangle2(float x) { return 2.0 * repeat(x + 0.5) - 1.0; }\n\n// A sawtooth wave with a 0.5 offset\nfloat saw2(float x) { return 2.0 * repeat(x + 0.5) - 1.0; }\n\n// A square wave with a 0.5 offset\nfloat square2(float x) { return 2.0 * repeat(x + 0.5) - 1.0; }\n\n// A sine wave with a 0.5 offset\nfloat sine2(float x) { return sin((x + 0.5) * PI); }\n\n// A cosine wave with a 0.5 offset\nfloat cosine2(float x) { return cos((x + 0.5) * PI); }\n\n// A triangle wave with a 0.25 offset\nfloat triangle3(float x) { return 2.0 * repeat(x + 0.25) - 1.0; }\n\n// A sawtooth wave with a 0.25 offset\nfloat saw3(float x) { return 2.0 * repeat(x + 0.25) - 1.0; }\n\n// A square wave with a 0.25 offset\nfloat square3(float x) { return 2.0 * repeat(x + 0.25) - 1.0; }\n\n// A sine wave with a 0.25 offset\nfloat sine3(float x) { return sin((x + 0.25) * PI); }\n\n// A cosine wave with a 0.25 offset\nfloat cosine3(float x) { return cos((x + 0.25) * PI); }\n\n// A triangle wave with a 0.75 offset\nfloat triangle4", " // 0.0 is the line, 1.0 is the edge\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    vec2 perp = vec2(dir.y, -dir.x);\n    float d = dot(uv - pA, perp);\n    float t = dot(uv - pA, dir);\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41 * t;\n    float t43 = t42 * t;\n    float t44 = t43 * t;\n   ", " // pA and pB are in pixel units\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(uv - pA, dir);\n    float d = length(t * dir - uv + pA);\n    float thickHalf = thick * 0.5;\n    float thickHalf2 = thickHalf * thickHalf;\n    float thickHalf3 = thickHalf2 * thickHalf;\n    float thickHalf4 = thickHalf3 * thickHalf;\n    float thickHalf5 = thickHalf4 * thickHalf;\n    float thickHalf6 = thickHalf5 * thickHalf;\n    float thickHalf7 = thickHalf6 * thickHalf;\n    float thickHalf8 = thickHalf7 * thickHalf;\n    float thickHalf9 = thickHalf8 * thickHalf;\n    float thickHalf10 = thickHalf9 * thickHalf;\n    float thickHalf11 = thickHalf10 * thickHalf;\n    float thickHalf12 = thickHalf11 * thickHalf;\n    float thickHalf13 = thickHalf12 * thickHalf;\n    float thickHalf14 = thickHalf13 * thickHalf;\n    float thickHalf15 = thickHalf14 * thickHalf;\n    float thickHalf16 = thickHalf15 * thickHalf;\n    float thickHalf17 = thickHalf16 * thickHalf;\n    float thickHalf18 = thickHalf17 * thickHalf;\n    float thickHalf19 = thickHalf18 * thickHalf;\n    float thickHalf20 = thickHalf19 * thickHalf;\n    float thickHalf21 = thickHalf20 * thickHalf;\n    float thickHalf22 = thickHalf21 * thickHalf;\n    float thickHalf23 = thickHalf22 * thickHalf;\n    float thickHalf24 = thickHalf23 * thickHalf;\n    float thickHalf25 = thickHalf24 * thickHalf;\n    float thickHalf26 = thickHalf25 * thickHalf;\n    float thickHalf27 = thickHalf26 * thickHalf;\n    float thickHalf28 = thickHalf27 * thickHalf;\n    float thickHalf29 = thickHalf28 * thickHalf;\n    float thickHalf30 = thickHalf29 * thickHalf;\n    float thickHalf31 = thickHalf30 * thickHalf;\n    float thickHalf32 = thickHalf31 * thickHalf;\n    float thickHalf33 = thickHalf32 * thickHalf;\n    float thickHalf34 = thickHalf33 * thickHalf;\n    float thickHalf35 = thickHalf34 * thick", " \n    float d = 0.0;\n    float dA = 0.0;\n    float dB = 0.0;\n    float dAB = 0.0;\n    float dAB2 = 0.0;\n    float dAB3 = 0.0;\n    float dAB4 = 0.0;\n    float dAB5 = 0.0;\n    float dAB6 = 0.0;\n    float dAB7 = 0.0;\n    float dAB8 = 0.0;\n    float dAB9 = 0.0;\n    float dAB10 = 0.0;\n    float dAB11 = 0.0;\n    float dAB12 = 0.0;\n    float dAB13 = 0.0;\n    float dAB14 = 0.0;\n    float dAB15 = 0.0;\n    float dAB16 = 0.0;\n    float dAB17 = 0.0;\n    float dAB18 = 0.0;\n    float dAB19 = 0.0;\n    float dAB20 = 0.0;\n    float dAB21 = 0.0;\n    float dAB22 = 0.0;\n    float dAB23 = 0.0;\n    float dAB24 = 0.0;\n    float dAB25 = 0.0;\n    float dAB26 = 0.0;\n    float dAB27 = 0.0;\n    float dAB28 = 0.0;\n    float dAB29 = 0.0;\n    float dAB30 = 0.0;\n    float dAB31 = 0.0;\n    float dAB32 = 0.0;\n    float dAB33 = 0.0;\n    float dAB34 = 0.0;\n    float dAB35 = 0.0;\n    float dAB36 = 0.0;\n    float dAB37 = 0.0;\n    float dAB38 = 0.0;\n    float dAB39 = 0.0;\n    float dAB40 = 0.0;\n    float dAB41 = 0.0;\n    float dAB42 = 0.0;\n    float dAB43 = 0.0;\n    float dAB44 = 0.0;\n", " // pA and pB are in UV space\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(uv - pA, dir);\n    float d = length(uv - pA - t * dir);\n    float r = rounded * thick.y;\n    float a = 1.0 - smoothstep(r, r + thick.y, d);\n    return a;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) { // pA and pB are in UV space\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(uv - pA, dir);\n    float d = length(uv - pA - t * dir);\n    float r = rounded * thick.y;\n    float a = 1.0 - smoothstep(r, r + thick.y, d);\n    return a;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) { // pA and pB are in UV space\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(uv - pA, dir);\n    float d = length(uv - pA - t * dir);\n    float r = rounded * thick.y;\n    float a = 1.0 - smoothstep(r, r + thick.y, d);\n    return a;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) { // pA and pB are in UV space\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float t = dot(uv - pA, dir);\n    float d = length(uv - pA - t * dir);\n    float r", " // pA and pB are in UV space\n    float d = distance(pA, pB);\n    float t = 0.0;\n    float d2 = d * 0.5;\n    float d3 = d * 0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", " \n    vec2 d = pB - pA;\n    float l = length(d);\n    float a = atan(d.y, d.x);\n    float s = sin(a);\n    float c = cos(a);\n    vec2 p = pA + d * 0.5;\n    vec2 n = vec2(c, s) * thick * 0.5;\n    vec2 p1 = p + vec2(-n.x, n.y);\n    vec2 p2 = p + vec2(n.x, -n.y);\n    vec2 p3 = p + vec2(n.x, n.y);\n    vec2 p4 = p + vec2(-n.x, -n.y);\n    float d1 = distance(uv, p1);\n    float d2 = distance(uv, p2);\n    float d3 = distance(uv, p3);\n    float d4 = distance(uv, p4);\n    float dmin = min(d1, min(d2, min(d3, d4)));\n    float dmax = max(d1, max(d2, max(d3, d4)));\n    float davg = (d1 + d2 + d3 + d4) * 0.25;\n    float d = davg;\n    float d2 = davg * davg;\n    float d3 = davg * davg * davg;\n    float d4 = davg * davg * davg * davg;\n    float d5 = davg * davg * davg * davg * davg;\n    float d6 = davg * davg * davg * davg * davg * davg;\n    float d7 = davg * davg * davg * davg * davg * davg * davg;\n    float d8 = davg * davg * davg * davg * davg * davg * davg * davg;\n    float d9 = davg * davg * davg * davg * davg * davg * davg * davg * davg;\n    float d10 = davg * davg * davg * davg * davg * davg * davg * davg * davg * davg;\n    float d11 = davg * davg * davg * davg * davg * davg * davg * davg * davg * davg * davg;\n    float", " // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d, d, d);\n}\n\n// This draws a point using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) { // uv is the screen space coordinates\n    float d = distance(uv, p);\n    col = vec3(d", " \n    float t = dot( rd, nor );\n    float d = dot( ro - cen, nor );\n    float b = rad*rad - d*d;\n    if( t < 0.0 ) t = -d / t;\n    else          t = sqrt( b ) / abs( t );\n    return t;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd,              // ray: origin, direction\n               in vec3 pos, float rad )              // sphere: position, radius\n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd,               // ray: origin, direction\n              in vec3 nor, float dist )              // plane: normal, distance\n{\n    float t = -dot( ro, nor ) + dist;\n    if( t < 0.0 ) return -1.0;\n    return t;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd,             // ray: origin, direction\n                 in vec3 p0, in vec3 p1, in vec3 p2 ) // triangle: vertices\n{\n    vec3 e1 = p1 - p0;\n    vec3 e2 = p2 - p0;\n    vec3 h = cross( rd, e2 );\n    float a = dot( e1, h );\n    if( a > -0.00001 && a < 0.00001 ) return -1.0;\n    float f = 1.0 / a;\n    vec3 s = ro - p0;\n    float b = dot( s, h );\n    if( b < 0.0 || b > a ) return -1.0;\n    vec3 q = cross( s, e1 );\n    float c = dot( rd, q );\n    if( c < 0.0 || b > a * c ) return -1.0;\n    return f * b;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd,                ", " \n    vec3 oc = ro - cen;\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad.x*rad.x;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return vec2( -1.0, -1.0 );\n    h = sqrt( h );\n    float t0 = (-b-h)/(2.0*a);\n    float t1 = (-b+h)/(2.0*a);\n    if( t0 > t1 ) { float t = t0; t0 = t1; t1 = t; }\n    if( t0<0.0 ) t0 = t1;\n    if( t0<0.0 ) return vec2( -1.0, -1.0 );\n    return vec2( t0, t1 );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 pos, float rad ) \n{ \n    vec3 oc = ro - pos;\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return vec2( -1.0, -1.0 );\n    h = sqrt( h );\n    float t0 = (-b-h)/(2.0*a);\n    float t1 = (-b+h)/(2.0*a);\n    if( t0 > t1 ) { float t = t0; t0 = t1; t1 = t; }\n    if( t0<0.0 ) t0 = t1;\n    if( t0<0.0 ) return vec2( -1.0, -1.0 );\n    return vec2( t0, t1 );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 pos, vec3 nor ) \n{ \n    float denom = dot( rd, nor );\n    if( abs( denom ) < 0.0001 ) return vec2( -1.0, -1.0 );\n    float t = dot", "\t\n\tvec3 v = pb - pa;\n\tfloat h = length(v);\n\tfloat r = ra + 0.0001;\n\t\n\tvec3 n = normalize(cross(v, vec3(0.0, 0.0, 1.0)));\n\tvec3 u = normalize(cross(n, v));\n\t\n\tvec3 p1 = pa + r*n;\n\tvec3 p2 = pa - r*n;\n\tvec3 p3 = pb + r*n;\n\tvec3 p4 = pb - r*n;\n\t\n\tvec3 p5 = pa + r*u;\n\tvec3 p6 = pa - r*u;\n\tvec3 p7 = pb + r*u;\n\tvec3 p8 = pb - r*u;\n\t\n\tvec3 p9 = pa + r*(u+n);\n\tvec3 p10 = pa - r*(u+n);\n\tvec3 p11 = pb + r*(u+n);\n\tvec3 p12 = pb - r*(u+n);\n\t\n\tvec3 p13 = pa + r*(u-n);\n\tvec3 p14 = pa - r*(u-n);\n\tvec3 p15 = pb + r*(u-n);\n\tvec3 p16 = pb - r*(u-n);\n\t\n\tvec3 p17 = pa + r*(n-u);\n\tvec3 p18 = pa - r*(n-u);\n\tvec3 p19 = pb + r*(n-u);\n\tvec3 p20 = pb - r*(n-u);\n\t\n\tvec3 p21 = pa + r*(n+u);\n\tvec3 p22 = pa - r*(n+u);\n\tvec3 p23 = pb + r*(n+u);\n\tvec3 p24 = pb - r*(n+u);\n\t\n\tvec3 p25 = pa + r*(n);\n\tvec3 p26 = pa - r*(n);\n\tvec3 p27 = pb + r*(n);\n\tvec3 p28 = pb - r*(n);\n\t\n\tvec3 p29 = pa + r*(u);\n\tvec3 p30 = pa - r*(u);\n\tvec3 p31 = pb + r*(u);\n\tvec3 p32 = pb - r*(u);\n\t\n\tvec3 p33 = pa + r*(n+u);\n\tvec3 p34 = pa - r*(n+u);\n\tvec3 p35 = pb + r*(n+u);\n\tvec3 p36 = pb - r*(n+u);\n\t\n\tvec3 p37 = pa + r*(n-u);\n\tvec3 p38 = pa - r*(n", " \n    vec3 ab = pb - pa;\n    float t = dot( ab, rd ) / dot( ab, ab );\n    vec3 p = ro + rd * t;\n    vec3 q = p - pa;\n    float d = dot( q, ab );\n    float h = sqrt( ra * ra - d * d );\n    vec3 n = normalize( cross( ab, q ) );\n    if( d < 0.0 ) n = -n;\n    if( h < 0.0 ) h = 0.0;\n    return vec4( t, n, h );\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, \n              in vec3 pos, float rad )\n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec4( -1.0, vec3( 0.0 ), 0.0 );\n    h = sqrt( h );\n    float t = -b - h;\n    if( t < 0.001 ) t = -b + h;\n    return vec4( t, normalize( oc + rd * t ), 0.0 );\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, \n             in vec3 n, float d )\n{\n    float t = -dot( n, ro + d * n ) / dot( n, rd );\n    return vec4( t, n, 0.0 );\n}\n\n// ray-triangle intersection (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, \n                in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 e0 = b - a;\n    vec3 e1 = c - a;\n    vec3 e2 = ro - a;\n    vec3 p = cross( rd, e2 );\n    float det = dot( e0, p );\n    if( det > -0.00001 && det < 0.00001 ) return vec4( -1.0, vec3( 0.0 ), 0.0 );\n    float inv_det =", " \n    vec3 oc = ro - cen;\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad.x*rad.x;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return vec2( -1.0, -1.0 );\n    h = sqrt( h );\n    float t0 = (-b-h)/(2.0*a);\n    float t1 = (-b+h)/(2.0*a);\n    if( t0 > t1 ) { float t = t0; t0 = t1; t1 = t; }\n    if( t0<0.0 ) t0 = t1;\n    if( t0<0.0 ) return vec2( -1.0, -1.0 );\n    return vec2( t0, t1 );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 pos, float rad ) \n{ \n    vec3 oc = ro - pos;\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return vec2( -1.0, -1.0 );\n    h = sqrt( h );\n    float t0 = (-b-h)/(2.0*a);\n    float t1 = (-b+h)/(2.0*a);\n    if( t0 > t1 ) { float t = t0; t0 = t1; t1 = t; }\n    if( t0<0.0 ) t0 = t1;\n    if( t0<0.0 ) return vec2( -1.0, -1.0 );\n    return vec2( t0, t1 );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 pos, vec3 nor ) \n{ \n    float denom = dot( rd, nor );\n    if( abs( denom ) < 0.0001 ) return vec2( -1.0, -1.0 );\n    float t = dot", "\t\n\tvec3 o = ro - pa;\n\tvec3 d = rd;\n\tfloat a = dot( d, d );\n\tfloat b = dot( d, o );\n\tfloat c = dot( o, o ) - r*r;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\th = sqrt( h );\n\treturn -b - h;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 pos, in float rad )\n{\n\tvec3 oc = ro - pos;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\th = sqrt( h );\n\treturn -b - h;\n}\n\n// intersect plane : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat planeIntersect( in vec3 ro, in vec3 rd, in vec3 n, in float d )\n{\n\tfloat ndotrd = dot( n, rd );\n\tif( ndotrd == 0.0 ) return -1.0;\n\tfloat ndotro = dot( n, ro );\n\tfloat t = -ndotro / ndotrd;\n\treturn t;\n}\n\n// intersect box : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 min, in vec3 max )\n{\n\tvec3 t0 = ( min - ro ) / rd;\n\tvec3 t1 = ( max - ro ) / rd;\n\tvec3 tmin = min( t0, t1 );\n\tvec3 tmax = max( t0, t1 );\n\tfloat t = max( tmin.x, max( tmin.y, tmin.z ) );\n\tt = min( t, min( tmax.x, min( tmax.y, tmax.z ) ) );\n\tif( t<0.0 ) return -1.0;\n\treturn t;\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triIntersect( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec", "\t\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\t\n\tfloat abLen = length(ab);\n\tfloat acLen = length(ac);\n\tfloat bcLen = length(bc);\n\t\n\tfloat abDot = dot(ab, ac);\n\tfloat bcDot = dot(bc, ac);\n\t\n\tfloat abDot2 = abDot * abDot;\n\tfloat bcDot2 = bcDot * bcDot;\n\t\n\tfloat abDot3 = abDot2 * abDot;\n\tfloat bcDot3 = bcDot2 * bcDot;\n\t\n\tfloat abDot4 = abDot3 * abDot;\n\tfloat bcDot4 = bcDot3 * bcDot;\n\t\n\tfloat abDot5 = abDot4 * abDot;\n\tfloat bcDot5 = bcDot4 * bcDot;\n\t\n\tfloat abDot6 = abDot5 * abDot;\n\tfloat bcDot6 = bcDot5 * bcDot;\n\t\n\tfloat abDot7 = abDot6 * abDot;\n\tfloat bcDot7 = bcDot6 * bcDot;\n\t\n\tfloat abDot8 = abDot7 * abDot;\n\tfloat bcDot8 = bcDot7 * bcDot;\n\t\n\tfloat abDot9 = abDot8 * abDot;\n\tfloat bcDot9 = bcDot8 * bcDot;\n\t\n\tfloat abDot10 = abDot9 * abDot;\n\tfloat bcDot10 = bcDot9 * bcDot;\n\t\n\tfloat abDot11 = abDot10 * abDot;\n\tfloat bcDot11 = bcDot10 * bcDot;\n\t\n\tfloat abDot12 = abDot11 * abDot;\n\tfloat bcDot12 = bcDot11 * bcDot;\n\t\n\tfloat abDot13 = abDot12 * abDot;\n\tfloat bcDot13 = bcDot12 * bcDot;\n\t\n\tfloat abDot14 = abDot13 * abDot;\n\tfloat bcDot14 = bcDot13 * bcDot;\n\t\n\tfloat abDot15 = abDot14 * abDot;\n\tfloat bcDot15 = bcDot14 * bcDot;\n\t\n\tfloat abDot16 = abDot15 * abDot;\n\tfloat bcDot16 = bcDot15 * bcDot;\n\t\n\tfloat abDot17 = abDot16 * abDot;\n\tfloat bcDot17 = bcDot16 * bcDot;\n\t\n\tfloat abDot18 = abDot17 * abDot;\n\tfloat bcDot18 = bcDot17 * bcDot;\n\t\n\tfloat abDot19 = abDot18 * abDot;\n\tfloat bcDot19 = bcDot18 * bc", " \n    vec3 invrd = 1.0 / rd;\n    vec3 tbot = invrd * ( rad - ro );\n    vec3 ttop = invrd * ( -rad - ro );\n    vec2 t = min( vec2( ttop.x, tbot.x ), min( vec2( ttop.y, tbot.y ), vec2( ttop.z, tbot.z ) ) );\n    return t;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{ \n    vec3 invrd = 1.0 / rd;\n    vec3 tbot = invrd * ( rad - ro );\n    vec3 ttop = invrd * ( -rad - ro );\n    vec2 t = min( vec2( ttop.x, tbot.x ), min( vec2( ttop.y, tbot.y ), vec2( ttop.z, tbot.z ) ) );\n    return t;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{ \n    vec3 invrd = 1.0 / rd;\n    vec3 tbot = invrd * ( rad - ro );\n    vec3 ttop = invrd * ( -rad - ro );\n    vec2 t = min( vec2( ttop.x, tbot.x ), min( vec2( ttop.y, tbot.y ), vec2( ttop.z, tbot.z ) ) );\n    return t;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{ \n    vec3 invrd = 1.0 / rd;\n    vec3 tbot = invrd * ( rad - ro );\n    vec3 ttop = invrd * ( -rad - ro );\n    vec2 t = min( vec2( ttop.x, tbot.x ), min( vec2( ttop.y, tbot.y ), vec2( ttop.z, tbot.z ) ) );\n    return t;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{ \n    vec3 invrd = 1.0 / rd;\n    vec3 tbot = invrd * (", "\t\n\tfloat t = 0.0;\n\tfloat d = 1.0;\n\tfor( int i = 0; i < 128; i++ )\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\td = distance( p, vec3( 0.0, 0.0, 0.0 ) );\n\t\tif( d < 0.001 )\n\t\t\tbreak;\n\t\tt += d;\n\t}\n\treturn vec4( p, 1.0 );\n}\n\n// main\nvoid main()\n{\n\tvec3 ro = vec3( 0.0, 0.0, 0.0 );\n\tvec3 rd = normalize( vec3( 0.0, 0.0, 1.0 ) );\n\tvec4 col = vec4( 0.0 );\n\t\n\tvec4 res = interesect( ro, rd );\n\t\n\tcol = vec4( 1.0, 0.0, 0.0, 1.0 );\n\t\n\tgl_FragColor = col;\n}", " \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) ); \n} \n\nvec3 forwardSF( float i, float n, float radius) \n{ \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) ) * radius; \n} \n\nvec3 forwardSF( float i, float n, float radius, float offset) \n{ \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) ) * radius + offset; \n} \n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale) \n{ \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) ) * radius * scale + offset; \n} \n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation) \n{ \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) ) * radius * scale + offset * rotation; \n} \n\nvec3 forwardSF( float i, float n, float radius, float offset, float scale, float rotation, float rotation2) \n{ \n    float phi = 2.0 * PI * i / n; \n    float theta = 2.0 * PI * (i + 0.5) / n; \n    return vec3( sin(theta", "\t\n\tvec3 p = ro;\n\tfloat t = 0.0;\n\tfloat d = 1.0;\n\tfloat tmax = 100.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.01;\n\t\n\tfor( int i = 0; i < 100; i++ )\n\t{\n\t\tvec3 n = vec3( 0.0 );\n\t\tvec3 c = vec3( 0.0 );\n\t\tvec3 s = vec3( 0.0 );\n\t\tvec3 d = vec3( 0.0 );\n\t\tvec3 l = vec3( 0.0 );\n\t\tvec3 h = vec3( 0.0 );\n\t\tvec3 r = vec3( 0.0 );\n\t\tvec3 v = vec3( 0.0 );\n\t\tvec3 f = vec3( 0.0 );\n\t\tvec3 g = vec3( 0.0 );\n\t\tvec3 b = vec3( 0.0 );\n\t\tvec3 m = vec3( 0.0 );\n\t\tvec3 k = vec3( 0.0 );\n\t\tvec3 q = vec3( 0.0 );\n\t\tvec3 w = vec3( 0.0 );\n\t\tvec3 x = vec3( 0.0 );\n\t\tvec3 y = vec3( 0.0 );\n\t\tvec3 z = vec3( 0.0 );\n\t\tvec3 u = vec3( 0.0 );\n\t\tvec3 o = vec3( 0.0 );\n\t\tvec3 i = vec3( 0.0 );\n\t\tvec3 j = vec3( 0.0 );\n\t\tvec3 a = vec3( 0.0 );\n\t\tvec3 e = vec3( 0.0 );\n\t\tvec3 r = vec3( 0.0 );\n\t\tvec3 t = vec3( 0.0 );\n\t\tvec3 s = vec3( 0.0 );\n\t\tvec3 d = vec3( 0.0 );\n\t\tvec3 f = vec3( 0.0 );\n\t\tvec3 g = vec3( 0.0 );\n\t\tvec3 h = vec3( 0.0 );\n\t\tvec3 b = vec3( 0.0 );\n\t\tvec3 m = vec3( 0.0 );\n\t\tvec3 k = vec3( 0.0 );\n\t", "\t\n\tvec3 n = vec3( 0.0 );\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tvec2  ip = floor( p + vec2( i & 1, i & 2 ) );\n\t\tvec2  fp = fract( p + vec2( i & 1, i & 2 ) );\n\t\tfloat w = mix( cos( fp.x ), cos( fp.y ), cos( ip.x ) );\n\t\tn += w * w * w;\n\t\tf += w;\n\t}\n\t\n\treturn n / f;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\t\n\tvec3 n = vec3( 0.0 );\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tvec3  ip = floor( p + vec3( i & 1, i & 2, i & 4 ) );\n\t\tvec3  fp = fract( p + vec3( i & 1, i & 2, i & 4 ) );\n\t\tfloat w = mix( cos( fp.x ), cos( fp.y ), cos( ip.x ) );\n\t\tn += w * w * w;\n\t\tf += w;\n\t}\n\t\n\treturn n / f;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec4 p )\n{\t\n\tvec3 n = vec3( 0.0 );\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tvec4  ip = floor( p + vec4( i & 1, i & 2, i & 4, i & 8 ) );\n\t\tvec4  fp = fract( p + vec4( i & 1, i & 2, i & 4, i & 8 ) );\n\t\tfloat w = mix( cos( fp.x ), cos( fp.y ), cos( ip.x ) );\n\t\tn += w * w * w;\n\t\tf += w;\n\t}\n\t\n\treturn n / f;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p, float scale )\n", " \n    vec2 d = abs(p) - size;\n    return length(max(d,0.0)) - radius;\n}\n\nfloat smoothMerge(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smoothMerge(float a, float b, float k, float t)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h) + t;\n}\n\nfloat smoothMerge(float a, float b, float k, float t, float s)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h) + t + s*h*(1.0-h);\n}\n\nfloat smoothMerge(float a, float b, float k, float t, float s, float r)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h) + t + s*h*(1.0-h) + r*h*h*(1.0-h);\n}\n\nfloat smoothMerge(float a, float b, float k, float t, float s, float r, float q)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h) + t + s*h*(1.0-h) + r*h*h*(1.0-h) + q*h*h*h*(1.0-h);\n}\n\nfloat smoothMerge(float a, float b, float k, float t, float s, float r, float q, float u)\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h) + t +", "\t\n\tvec2 uv2 = uv - orient;\n\tfloat d = length(uv2);\n\tfloat a = atan(uv2.y, uv2.x);\n\tfloat b = atan(uv2.y, uv2.x) + 3.1415926;\n\tfloat c = atan(uv2.y, uv2.x) - 3.1415926;\n\tfloat d1 = abs(a);\n\tfloat d2 = abs(b);\n\tfloat d3 = abs(c);\n\tfloat d4 = abs(d);\n\tfloat d5 = abs(d1 - d2);\n\tfloat d6 = abs(d1 - d3);\n\tfloat d7 = abs(d2 - d3);\n\tfloat d8 = abs(d4 - d5);\n\tfloat d9 = abs(d4 - d6);\n\tfloat d10 = abs(d5 - d7);\n\tfloat d11 = abs(d6 - d7);\n\tfloat d12 = abs(d8 - d9);\n\tfloat d13 = abs(d8 - d10);\n\tfloat d14 = abs(d9 - d10);\n\tfloat d15 = abs(d12 - d13);\n\tfloat d16 = abs(d12 - d14);\n\tfloat d17 = abs(d13 - d14);\n\tfloat d18 = abs(d15 - d16);\n\tfloat d19 = abs(d15 - d17);\n\tfloat d20 = abs(d16 - d17);\n\tfloat d21 = abs(d18 - d19);\n\tfloat d22 = abs(d18 - d20);\n\tfloat d23 = abs(d19 - d20);\n\tfloat d24 = abs(d21 - d22);\n\tfloat d25 = abs(d21 - d23);\n\tfloat d26 = abs(d22 - d23);\n\tfloat d27 = abs(d24 - d25);\n\tfloat d28 = abs(d24 - d26);\n\tfloat d29 = abs(d25 - d26);\n\tfloat d30 = abs(d27 - d28);\n\tfloat d31 = abs(d27 - d29);\n\tfloat d32 = abs(d28 - d29);\n\tfloat d33 = abs(d30 - d31);\n\tfloat d34 = abs(d30 - d32);\n\tfloat d35 = abs(d31 - d32);\n\tfloat d36 = abs(d33 - d34);\n\tfloat d37 = abs(d33 - d35);\n\tfloat d38 = abs(d34 - d35);\n\tfloat d39 = abs(d36 - d37);\n\tfloat d40 = abs(d36 - d38);\n\tfloat d41 = abs(d37 - d38);\n\tfloat d42 =", "\t\n\tvec2 uv2 = uv - orient;\n\tfloat d = length(uv2);\n\tfloat a = atan(uv2.y, uv2.x);\n\tfloat b = atan(uv2.y, uv2.x) + 3.1415926;\n\tfloat c = atan(uv2.y, uv2.x) - 3.1415926;\n\tfloat d1 = abs(a);\n\tfloat d2 = abs(b);\n\tfloat d3 = abs(c);\n\tfloat d4 = abs(d);\n\tfloat d5 = abs(d1 - d2);\n\tfloat d6 = abs(d1 - d3);\n\tfloat d7 = abs(d2 - d3);\n\tfloat d8 = abs(d4 - d5);\n\tfloat d9 = abs(d4 - d6);\n\tfloat d10 = abs(d4 - d7);\n\tfloat d11 = abs(d5 - d6);\n\tfloat d12 = abs(d5 - d7);\n\tfloat d13 = abs(d6 - d7);\n\tfloat d14 = abs(d8 - d9);\n\tfloat d15 = abs(d8 - d10);\n\tfloat d16 = abs(d9 - d10);\n\tfloat d17 = abs(d11 - d12);\n\tfloat d18 = abs(d11 - d13);\n\tfloat d19 = abs(d12 - d13);\n\tfloat d20 = abs(d14 - d15);\n\tfloat d21 = abs(d14 - d16);\n\tfloat d22 = abs(d15 - d16);\n\tfloat d23 = abs(d17 - d18);\n\tfloat d24 = abs(d17 - d19);\n\tfloat d25 = abs(d18 - d19);\n\tfloat d26 = abs(d20 - d21);\n\tfloat d27 = abs(d20 - d22);\n\tfloat d28 = abs(d21 - d22);\n\tfloat d29 = abs(d23 - d24);\n\tfloat d30 = abs(d23 - d25);\n\tfloat d31 = abs(d24 - d25);\n\tfloat d32 = abs(d26 - d27);\n\tfloat d33 = abs(d26 - d28);\n\tfloat d34 = abs(d27 - d28);\n\tfloat d35 = abs(d29 - d30);\n\tfloat d36 = abs(d29 - d31);\n\tfloat d37 = abs(d30 - d31);\n\tfloat d38 = abs(d32 - d33);\n\tfloat d39 = abs(d32 - d34);\n\tfloat d40 = abs(d33 - d34);\n\tfloat d41 = abs(d35 - d36);\n\tfloat d42 =", "\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy );\n\t\n\treturn d;\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy );\n\t\n\treturn d;\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy );\n\t\n\treturn d;\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy );\n\t\n\treturn d;\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy );\n\t\n\treturn d;\n}\n\n// grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\t\n\tfloat x = fract( p.x );\n\tfloat y = fract( p.y );\n\t\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\t\n\tfloat d = 0.0;\n\t\n\td += abs( x - dx );\n\td += abs( y - dy", "\t\n\tvec3 d = vec3( 0.0 );\n\t\n\td.x = 0.5 * ( 1.0 - cos( 2.0 * PI * p.x ) );\n\td.y = 0.5 * ( 1.0 - cos( 2.0 * PI * p.y ) );\n\td.z = 0.5 * ( 1.0 - cos( 2.0 * PI * p.z ) );\n\t\n\treturn d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 dP )\n{\t\n\tvec3 d = vec3( 0.0 );\n\t\n\td.x = 0.5 * ( 1.0 - cos( 2.0 * PI * p.x ) ) * dP.x;\n\td.y = 0.5 * ( 1.0 - cos( 2.0 * PI * p.y ) ) * dP.y;\n\td.z = 0.5 * ( 1.0 - cos( 2.0 * PI * p.z ) ) * dP.z;\n\t\n\treturn d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 dP, in vec3 dP2 )\n{\t\n\tvec3 d = vec3( 0.0 );\n\t\n\td.x = 0.5 * ( 1.0 - cos( 2.0 * PI * p.x ) ) * dP.x;\n\td.y = 0.5 * ( 1.0 - cos( 2.0 * PI * p.y ) ) * dP.y;\n\td.z = 0.5 * ( 1.0 - cos( 2.0 * PI * p.z ) ) * dP.z;\n\t\n\treturn d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 dP, in vec3 dP2, in vec3 dP3 )\n{\t\n\tvec3 d = vec3( 0.0 );\n\t\n\td.x = 0.5 * ( 1.0 - cos( 2.0 * PI * p.x ) ) * dP.x;\n\td.y = 0.5 * ( 1.0 - cos( 2.0 * PI * p.y ) ) *", "a.x=b.x;a.y=b.z;a.z=b.y;b.x=a.x;b.y=a.z;b.z=a.y;}\n\n//and this is the function that will be called by the raymarcher:\nfloat raymarch(inout v33 ray,inout v33 cam,inout v33 dir,inout v33 pos,inout v33 normal,inout v33 color,inout v33 light,inout v33 light2,inout v33 light3,inout v33 light4,inout v33 light5,inout v33 light6,inout v33 light7,inout v33 light8,inout v33 light9,inout v33 light10,inout v33 light11,inout v33 light12,inout v33 light13,inout v33 light14,inout v33 light15,inout v33 light16,inout v33 light17,inout v33 light18,inout v33 light19,inout v33 light20,inout v33 light21,inout v33 light22,inout v33 light23,inout v33 light24,inout v33 light25,inout v33 light26,inout v33 light27,inout v33 light28,inout v33 light29,inout v33 light30,inout v33 light31,inout v33 light32,inout v33 light33,inout v33 light34,inout v33 light35,inout v33 light36,inout v33 light37,inout v33 light38,inout v33 light39,inout v33 light40,inout v33 light41,inout v33 light42,inout v33 light43,inout v33 light44,inout v33 light45,inout v33 light46,inout v33 light47,inout v33 light48,inout v33 light49,inout v33 light50,inout v33 light51,inout v33 light52,inout v33 light53,inout v33 light54,inout v33 light55,inout v33 light56,inout v33 light57,inout v33 light58,inout v33 light59,inout v33 light60,inout v33 light61,inout v33 light62,inout v33 light63,inout v33 light64,inout v33 light65,inout v33 light66,inout v33 light67,inout v33 light68,inout v33 light69,inout v33 light70,inout v33 light71,inout v33 light72,inout v33 light", "return v33(a.x-b.x,a.y-b.y,a.z-b.z);}\nv33 add(v33 a,vec3 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 mul(v33 a,float b){return v33(a.x*b,a.y*b,a.z*b);}\nv33 div(v33 a,float b){return v33(a.x/b,a.y/b,a.z/b);}\nv33 cross(v33 a,vec3 b){return v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);}\nv33 dot(v33 a,vec3 b){return a.x*b.x+a.y*b.y+a.z*b.z;}\nv33 normalize(v33 a){return div(a,length(a));}\nv33 reflect(v33 a,vec3 b){return sub(a,mul(b,2*dot(a,b)));}\n\nv33 v33::operator+(vec3 b){return add(*this,b);}\nv33 v33::operator-(vec3 b){return sub(*this,b);}\nv33 v33::operator*(float b){return mul(*this,b);}\nv33 v33::operator/(float b){return div(*this,b);}\nv33 v33::operator*(v33 b){return cross(*this,b);}\nv33 v33::operator/(v33 b){return cross(*this,b);}\nfloat v33::operator*(vec3 b){return dot(*this,b);}\nfloat v33::operator*(v33 b){return dot(*this,b);}\nv33 v33::operator-(){return v33(-x,-y,-z);}\nv33 v33::operator!(){return v33(-x,y,-z);}\nv33 v33::operator~(){return v33(x,-y,-z);}\nv33 v33::operator^(v33 b){return cross(*this,b);}\nv33 v33::operator^(vec3 b){return cross(*this,b);}\nv33 v33::operator|(v33 b){return cross(*this,b);}\nv33 v33::operator|(vec3 b){return cross(*this,b);}\nv33 v33::operator&(v33 b){return cross(*this,b);}\nv33 v33::operator&(vec3 b){return cross(*this,b);}\nv33 v33::operator%(v33 b){return cross(*this,b);}\nv33 v33::operator%(vec3 b){return cross(*this,b);}\nv33", "v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component wise ray substraction\nv33 sub(v33  a,v33 b){v33 c;for(int i=0;i<3;i++)c[i]=a[i]-b[i];return c;}\n//component", "return vec2(a.x-b.x,a.y-b.y);}\nvec2 d2t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d3t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d4t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d5t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d6t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d7t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d8t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d9t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d10t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d11t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d12t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d13t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d14t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d15t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d16t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d17t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d18t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d19t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d20t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d21t(v33 a,v33 b){return vec2(a.x-b.x,a.y-b.y);}\nvec2 d22t(v33 a,v33 b){return vec2(a.x-b.x,a", "return vec2(dot(a.xy,b.xy),dot(a.zw,b.zw));}\nvec2 dtp(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi2(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi3(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi4(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi5(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi6(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi7(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi8(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi9(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi10(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi11(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi12(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi13(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi14(v33 a,vec3 b){return vec2(dot(a.xy,b.zw),dot(a.zw,b.xy));}\nvec2 dtpi15(v33 a,vec3 b){return vec2", "return vec3(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 mul(v33 a,vec3 b){return vec3(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 mul(v33 a,vec4 b){return vec3(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 mul(v33 a,mat2 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat3 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat4 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat2x3 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat2x4 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat3x2 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat3x3 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat3x4 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat4x2 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat4x3 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat4x4 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat2x2 b){return vec3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nv33 mul(v33 a,mat3x2 b){return vec3(a.x*b[0],a.y*b[1],", "return fract(p.x*w.x+p.y*w.y+p.z*w.z);}\nfloat checkerF(vec3 p,vec3 w){return fract(p.x*w.x+p.y*w.y+p.z*w.z);}\nfloat checkerF(vec3 p,vec3 w,float s){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s;}\nfloat checkerF(vec3 p,vec3 w,float s,float t){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1,float w2){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1/w2;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1,float w2,float w3){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1/w2/w3;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1,float w2,float w3,float w4){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1/w2/w3/w4;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1,float w2,float w3,float w4,float w5){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1/w2/w3/w4/w5;}\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u,float v,float w1,float w2,float w3,float w4,float w5,float w6){return fract(p.x*w.x+p.y*w.y+p.z*w.z)/s/t/u/v/w1/w2/w3/w", "float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d;}//3xTap\nfloat checkerF4(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d;}//4xTap\nfloat checkerF5(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d;}//5xTap\nfloat checkerF6(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d;}//6xTap\nfloat checkerF7(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d;}//7xTap\nfloat checkerF8(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d;}//8xTap\nfloat checkerF9(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d;}//9xTap\nfloat checkerF10(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d*d;}//10xTap\nfloat checkerF11(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d*d*d;}//11xTap\nfloat checkerF12(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d*d*d*d;}//12xTap\nfloat checkerF13(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d*d*d*d*d;}//13xTap\nfloat checkerF14(vec3 p,vec3 w){float d=abs(p.x)+abs(p.y)+abs(p.z);return d*d*d*d*d*d*d*d*d*d*d*d*d*d;}//14xTap\nfloat checkerF15(vec3 p,vec3 w){float d", "vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/2.0:0.0;}\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec4 d=r-s;float l=length(d);return l<1.0?1.0-(l*l*l)/", "return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3 n,vec4 s){return 1.0-step(0.0,abs(dot(u,n)-s.x)-s.y);}\nfloat occSphere(vec3 u,vec3", "\t\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\t\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = b - c;\n\t\n\tvec2 abx = ab.x;\n\tvec2 aby = ab.y;\n\tvec2 acx = ac.x;\n\tvec2 acy = ac.y;\n\tvec2 bcx = bc.x;\n\tvec2 bcy = bc.y;\n\t\n\tvec2 ab2 = ab * ab;\n\tvec2 ac2 = ac * ac;\n\tvec2 bc2 = bc * bc;\n\t\n\tvec2 abac = ab * ac;\n\tvec2 abbc = ab * bc;\n\tvec2 acbc = ac * bc;\n\t\n\tvec2 abacx = abac.x;\n\tvec2 abacy = abac.y;\n\tvec2 abbcx = abbc.x;\n\tvec2 abbcy = abbc.y;\n\tvec2 acbcx = acbc.x;\n\tvec2 acbcy = acbc.y;\n\t\n\tvec2 abac2 = abac * abac;\n\tvec2 abbc2 = abbc * abbc;\n\tvec2 acbc2 = acbc * acbc;\n\t\n\tvec2 abacbc = abac * bc;\n\tvec2 abacac = abac * ac;\n\t\n\tvec2 abacbcx = abacbc.x;\n\tvec2 abacbcy = abacbc.y;\n\tvec2 abacacx = abacac.x;\n\tvec2 abacacy = abacac.y;\n\t\n\tvec2 abacbc2 = abacbc * abacbc;\n\tvec2 abacac2 = abacac * abacac;\n\t\n\tvec2 abacacbc = abacac * bc;\n\tvec2 abacacac = abacac * ac;\n\t\n\tvec2 abacacbcx = abacacbc.x;\n\tvec2 abacacbcy = abacacbc.y;\n\tvec2 abacacacx = abacacac.x;\n\tvec2 abacacacy = abacacac.y;\n\t\n\tvec2 abacacbc2 = abacacbc * abacacbc;\n\tvec2 abacacac2 = abacacac * abacacac;\n\t\n\tvec2 abacacacbc = abacacac * bc;\n\tvec2 abacacacac = abacacac * ac;\n\t\n\tvec2 abacacacbcx = ab", "\t\n\tvec2 p01 = p1 - p0;\n\tvec2 p02 = p2 - p0;\n\tvec2 p12 = p2 - p1;\n\t\n\tfloat a = p01.x * p12.y - p01.y * p12.x;\n\tfloat b = p02.x * p01.y - p02.y * p01.x;\n\tfloat c = p02.x * p12.y - p02.y * p12.x;\n\t\n\tfloat d = a * a - 3.0 * b * c;\n\tfloat e = b * b - 3.0 * a * c;\n\tfloat f = c * c - 3.0 * b * a;\n\t\n\tfloat t = 0.0;\n\tif (d > 0.0) {\n\t\tt = 0.5 * (b * c - a * sqrt(d)) / (a * a - b * b);\n\t} else if (e > 0.0) {\n\t\tt = 0.5 * (c * a - b * sqrt(e)) / (b * b - c * c);\n\t} else if (f > 0.0) {\n\t\tt = 0.5 * (a * b - c * sqrt(f)) / (c * c - a * a);\n\t}\n\t\n\tvec2 p = p0 + t * p01 + (1.0 - t) * p02;\n\t\n\treturn vec4(p, 0.0, 0.0);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\t\n\tvec2 p01 = p1 - p0;\n\tvec2 p02 = p2 - p0;\n\tvec2 p12 = p2 - p1;\n\t\n\tfloat a = p01.x * p12.y - p01.y * p12.x;\n\tfloat b = p02.x * p01.y - p02.y * p01.x;\n\tfloat c = p02.x * p12.y - p02.y * p12.x;\n\t\n\tfloat d = a * a - 3.0 * b * c;\n\tfloat e = b * b - 3.0 * a * c;\n\tfloat f = c * c - 3.0 * b * a;\n\t\n\tfloat t = 0.0;\n\tif (d > 0.0) {\n\t\tt = 0.", " \n    vec3 a = p0 - p1;\n    vec3 b = p1 - p2;\n    vec3 c = p2 - p3;\n    vec3 d = p0 - p3;\n    vec3 e = a + b + c + d;\n    vec3 f = a + b - c - d;\n    vec3 g = a - b + c - d;\n    vec3 h = a - b - c + d;\n    vec3 i = a + b + c - d;\n    vec3 j = a + b - c + d;\n    vec3 k = a - b + c + d;\n    vec3 l = a - b - c - d;\n    vec3 m = p0 + p1 + p2 + p3;\n    vec3 n = p0 + p1 - p2 - p3;\n    vec3 o = p0 - p1 + p2 - p3;\n    vec3 p = p0 - p1 - p2 + p3;\n    vec3 q = p0 + p2 - p1 - p3;\n    vec3 r = p0 - p2 + p1 - p3;\n    vec3 s = p0 - p2 - p1 + p3;\n    vec3 t = p0 + p1 + p2 - p3;\n    vec3 u = p0 + p1 - p2 + p3;\n    vec3 v = p0 - p1 + p2 + p3;\n    vec3 w = p0 - p1 - p2 - p3;\n    vec3 x = p0 + p1 + p2 + p3;\n    vec3 y = p0 + p1 - p2 - p3;\n    vec3 z = p0 - p1 + p2 - p3;\n    vec3 aa = p0 - p1 - p2 + p3;\n    vec3 ab = p0 + p2 - p1 - p3;\n    vec3 ac = p0 - p2 + p1 - p3;\n    vec3 ad = p0 - p2 - p1 + p3;\n    vec3 ae = p0 + p1 + p2 - p3;\n    vec3 af = p0 + p1 - p2 + p3;\n    vec3 ag = p0 - p1 + p2 + p3;\n    vec3 ah = p", "\t\n\tvec2 a = p1 - p0;\n\tvec2 b = p2 - p1;\n\tvec2 c = p3 - p2;\n\t\n\tvec2 ab = a + b;\n\tvec2 bc = b + c;\n\tvec2 ca = c + a;\n\t\n\tvec2 ab2 = ab + ab;\n\tvec2 bc2 = bc + bc;\n\tvec2 ca2 = ca + ca;\n\t\n\tvec2 ab3 = ab2 + ab;\n\tvec2 bc3 = bc2 + bc;\n\tvec2 ca3 = ca2 + ca;\n\t\n\tvec2 ab4 = ab3 + ab;\n\tvec2 bc4 = bc3 + bc;\n\tvec2 ca4 = ca3 + ca;\n\t\n\tvec2 ab5 = ab4 + ab;\n\tvec2 bc5 = bc4 + bc;\n\tvec2 ca5 = ca4 + ca;\n\t\n\tvec2 ab6 = ab5 + ab;\n\tvec2 bc6 = bc5 + bc;\n\tvec2 ca6 = ca5 + ca;\n\t\n\tvec2 ab7 = ab6 + ab;\n\tvec2 bc7 = bc6 + bc;\n\tvec2 ca7 = ca6 + ca;\n\t\n\tvec2 ab8 = ab7 + ab;\n\tvec2 bc8 = bc7 + bc;\n\tvec2 ca8 = ca7 + ca;\n\t\n\tvec2 ab9 = ab8 + ab;\n\tvec2 bc9 = bc8 + bc;\n\tvec2 ca9 = ca8 + ca;\n\t\n\tvec2 ab10 = ab9 + ab;\n\tvec2 bc10 = bc9 + bc;\n\tvec2 ca10 = ca9 + ca;\n\t\n\tvec2 ab11 = ab10 + ab;\n\tvec2 bc11 = bc10 + bc;\n\tvec2 ca11 = ca10 + ca;\n\t\n\tvec2 ab12 = ab11 + ab;\n\tvec2 bc12 = bc11 + bc;\n\tvec2 ca12 = ca11 + ca;\n\t\n\tvec2 ab13 = ab12 + ab;\n\tvec2 bc13 = bc12 + bc;\n\tvec2 ca13 = ca12 + ca;\n\t\n\tvec2 ab14 = ab13 + ab;\n\tvec2 bc14 = bc13 + bc;\n\tvec2 ca14 = ca13 + ca;\n\t\n\tvec2 ab15 = ab14 + ab;\n\tvec2 bc15 = bc14 + bc;\n\tvec2 ca15 = ca14 + ca;\n\t\n\tvec2 ab16 = ab15 + ab;\n\tvec2 bc16 = bc15 + bc;\n\tvec2 ca16", "\t\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\tvec2 d = p3;\n\t\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 ad = d - a;\n\t\n\tvec2 abac = ab * ac;\n\tvec2 abad = ab * ad;\n\tvec2 acad = ac * ad;\n\t\n\tvec2 abacac = abac * ac;\n\tvec2 abadad = abad * ad;\n\t\n\tvec2 abacacac = abacac * ac;\n\tvec2 abadadad = abadad * ad;\n\t\n\tvec2 abacacacac = abacacac * ac;\n\tvec2 abadadadad = abadadad * ad;\n\t\n\tvec2 abacacacacac = abacacacac * ac;\n\tvec2 abadadadadad = abadadadad * ad;\n\t\n\tvec2 abacacacacacac = abacacacacac * ac;\n\tvec2 abadadadadadad = abadadadadad * ad;\n\t\n\tvec2 abacacacacacacac = abacacacacacac * ac;\n\tvec2 abadadadadadadad = abadadadadadad * ad;\n\t\n\tvec2 abacacacacacacacac = abacacacacacacac * ac;\n\tvec2 abadadadadadadadad = abadadadadadadad * ad;\n\t\n\tvec2 abacacacacacacacacac = abacacacacacacacac * ac;\n\tvec2 abadadadadadadadadad = abadadadadadadadad * ad;\n\t\n\tvec2 abacacacacacacacacacac = abacacacacacacacacac * ac;\n\tvec2 abadadadadadadadadadad = abadadadadadadadadad * ad;\n\t\n\tvec2 abacacacacacacacacacacac = abacacacacacacacacacac * ac;\n\tvec2 abadadadadadadadadadadad = abadadadadadadadadadad * ad;\n\t\n\tvec2 abacacacacacacacacacacacac = abacac", "\t\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\t\n\tvec3 p = cross( rd, e2 );\n\tfloat det = dot( e1, p );\n\t\n\tif( det > -0.0001 && det < 0.0001 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\t\n\tfloat inv_det = 1.0 / det;\n\tvec3 t = ro - v0;\n\t\n\tvec3 u = t.cross( e2 );\n\tfloat r = dot( e1, u );\n\t\n\tif( r < 0.0 || r > det )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\t\n\tvec3 v = t.cross( e1 );\n\tfloat s = dot( rd, v );\n\t\n\tif( s < 0.0 || r + s > det )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\t\n\tfloat t = dot( e2, v );\n\t\n\treturn vec3( t, r, s ) * inv_det;\n}\n\n// Triangle normal\nvec3 triNormal( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\t\n\treturn normalize( cross( e1, e2 ) );\n}\n\n// Triangle area\nfloat triArea( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\t\n\treturn length( cross( e1, e2 ) ) * 0.5;\n}\n\n// Triangle barycentric coordinates\nvec3 triBarycentric( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\t\n\tvec3 s = cross( p - v0, e2 );\n\tfloat d = dot( e1, s );\n\t\n\tif( d < 0.0001 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\t\n\tfloat inv_d = 1.0 / d;\n\t\n\tvec3 t = cross", "\t\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 h = cross( nor, e0 );\n\tfloat a = dot( e1, h );\n\tif( a < 0.0 ) return 0.0;\n\tfloat b = dot( nor, e1 );\n\tif( b < 0.0 ) return 0.0;\n\tfloat c = dot( nor, v0 );\n\tfloat denom = a + b + c;\n\tif( denom < 0.0 ) return 0.0;\n\treturn 1.0 / denom;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\t\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 e2 = v3 - v0;\n\tvec3 h = cross( nor, e0 );\n\tfloat a = dot( e1, h );\n\tif( a < 0.0 ) return 0.0;\n\tfloat b = dot( nor, e1 );\n\tif( b < 0.0 ) return 0.0;\n\tfloat c = dot( nor, v0 );\n\tfloat denom = a + b + c;\n\tif( denom < 0.0 ) return 0.0;\n\treturn 1.0 / denom;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4 )\n{\t\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 e2 = v3 - v0;\n\tvec3 e3 = v4 - v0;\n\tvec3 h = cross( nor, e0 );\n\tfloat a = dot( e1, h );\n\tif( a < 0.0 ) return 0.0;\n\tfloat b = dot( nor, e1 );\n\tif( b < 0.0 ) return 0.0;\n\tfloat c = dot( nor, v0 );\n\tfloat denom = a + b + c;\n\tif( denom < 0.0 ) return 0.0;\n\treturn", "\t\n\tvec2 pa = pos - A;\n\tvec2 ba = B - A;\n\tvec2 ca = C - A;\n\t\n\tvec2 ba_ca = ba - ca;\n\t\n\tfloat ba_ca_dot = dot( ba_ca, ba_ca );\n\tfloat ba_ca_dot_2 = ba_ca_dot * 0.5;\n\t\n\tfloat ba_ca_dot_3 = ba_ca_dot_2 * 0.5;\n\t\n\tfloat ba_ca_dot_4 = ba_ca_dot_2 * ba_ca_dot_2;\n\t\n\tfloat ba_ca_dot_5 = ba_ca_dot_4 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_6 = ba_ca_dot_5 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_7 = ba_ca_dot_6 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_8 = ba_ca_dot_7 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_9 = ba_ca_dot_8 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_10 = ba_ca_dot_9 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_11 = ba_ca_dot_10 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_12 = ba_ca_dot_11 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_13 = ba_ca_dot_12 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_14 = ba_ca_dot_13 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_15 = ba_ca_dot_14 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_16 = ba_ca_dot_15 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_17 = ba_ca_dot_16 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_18 = ba_ca_dot_17 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_19 = ba_ca_dot_18 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_20 = ba_ca_dot_19 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_21 = ba_ca_dot_20 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_22 = ba_ca_dot_21 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_23 = ba_ca_dot_22 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_24 = ba_ca_dot_23 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_25 = ba_ca_dot_24 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_26 = ba_ca_dot_25 * ba_ca_dot;\n\t\n\tfloat ba_ca_dot_27 = ba_ca_dot_", "\t\n\tfloat h = he * 0.5;\n\tfloat d = length( p );\n\t\n\tif( d < h )\n\t{\n\t\tfloat t = sqrt( h*h - d*d );\n\t\treturn abs( p.y ) - t;\n\t}\n\t\n\tfloat t = sqrt( h*h - d*d );\n\tfloat h2 = h - t;\n\t\n\tfloat d1 = length( p - vec2( 0.0, h2 ) );\n\tfloat d2 = length( p - vec2( 0.0, -h2 ) );\n\t\n\treturn min( d1, d2 );\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he, float y )\n{\n\tfloat h = he * 0.5;\n\tfloat d = length( p );\n\t\n\tif( d < h )\n\t{\n\t\tfloat t = sqrt( h*h - d*d );\n\t\treturn abs( p.y - y ) - t;\n\t}\n\t\n\tfloat t = sqrt( h*h - d*d );\n\tfloat h2 = h - t;\n\t\n\tfloat d1 = length( p - vec2( 0.0, h2 ) );\n\tfloat d2 = length( p - vec2( 0.0, -h2 ) );\n\t\n\treturn min( d1, d2 );\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he, float y, float z )\n{\n\tfloat h = he * 0.5;\n\tfloat d = length( p );\n\t\n\tif( d < h )\n\t{\n\t\tfloat t = sqrt( h*h - d*d );\n\t\treturn abs( p.y - y ) - t;\n\t}\n\t\n\tfloat t = sqrt( h*h - d*d );\n\tfloat h2 = h - t;\n\t\n\tfloat d1 = length( p - vec2( 0.0, h2 ) );\n\tfloat d2 = length( p - vec2( 0.0, -h2 ) );\n\t\n\treturn min( d1, d2 );\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he, float y, float z, float w )\n{\n\tfloat h = he * 0.5;\n\tfloat d = length( p );\n\t\n\tif( d < h )\n\t{\n\t\tfloat t = sqrt( h*h - d*d );\n\t\treturn abs( p.y -", "\t\n\tvec2 q = abs(p - a) - vec2(ra,rb);\n\tvec2 r = abs(p - b) - vec2(ra,rb);\n\treturn min(max(dot(q, q), dot(r, r)), max(dot(q, r), 0.0));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float rc )\n{\t\n\tvec2 q = abs(p - a) - vec2(ra,rc);\n\tvec2 r = abs(p - b) - vec2(rb,rc);\n\treturn min(max(dot(q, q), dot(r, r)), max(dot(q, r), 0.0));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float rc, float rd )\n{\t\n\tvec2 q = abs(p - a) - vec2(ra,rd);\n\tvec2 r = abs(p - b) - vec2(rb,rd);\n\treturn min(max(dot(q, q), dot(r, r)), max(dot(q, r), 0.0));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float rc, float rd, float re )\n{\t\n\tvec2 q = abs(p - a) - vec2(ra,re);\n\tvec2 r = abs(p - b) - vec2(rb,re);\n\treturn min(max(dot(q, q), dot(r, r)), max(dot(q, r), 0.0));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb, float rc, float rd, float re, float rf )\n{\t\n\tvec2 q = abs(p - a) - vec2(ra,rf);\n\tvec2 r = abs(p - b) - vec2(rb,rf);\n\treturn min(max(dot(q, q), dot(r, r)), max(dot(q, r), 0.0));\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb,", "\t\n\tvec2 e = vec2( 1.0, -1.0 );\n\tvec3 n = normalize( e.xyy * texture( iChannel0, pos.xy + e.xyy * iTime ).xyz\n\t\t\t\t\t  - e.yyy * texture( iChannel0, pos.xy + e.yyy * iTime ).xyz\n\t\t\t\t\t  + 2.0 * pos.xyz );\n\treturn n;\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\t\n\tvec2 e = vec2( 1.0, -1.0 );\n\tvec3 n = normalize( e.xyy * texture( iChannel0, pos.xy + e.xyy * time ).xyz\n\t\t\t\t\t  - e.yyy * texture( iChannel0, pos.xy + e.yyy * time ).xyz\n\t\t\t\t\t  + 2.0 * pos.xyz );\n\treturn n;\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in float scale )\n{\t\n\tvec2 e = vec2( 1.0, -1.0 );\n\tvec3 n = normalize( e.xyy * texture( iChannel0, pos.xy + e.xyy * time * scale ).xyz\n\t\t\t\t\t  - e.yyy * texture( iChannel0, pos.xy + e.yyy * time * scale ).xyz\n\t\t\t\t\t  + 2.0 * pos.xyz );\n\treturn n;\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in float scale, in float offset )\n{\t\n\tvec2 e = vec2( 1.0, -1.0 );\n\tvec3 n = normalize( e.xyy * texture( iChannel0, pos.xy + e.xyy * time * scale + offset ).xyz\n\t\t\t\t\t  - e.yyy * texture( iChannel0, pos.xy + e.yyy * time * scale + offset ).xyz\n\t\t\t\t\t  + 2.0 * pos.xyz );\n\treturn n;\n}\n\nvec3 calcNormal( in vec3 pos, in float time, in float scale, in float offset, in float bias )\n{\t\n\tvec2 e = vec2( 1.0, -1.0 );\n\tvec3 n = normalize( e.xyy * texture( iChannel0, pos.xy + e.xyy * time * scale + offset ).xyz\n\t\t\t\t\t  - e.yyy * texture( iChannel0, pos.xy + e.yyy * time * scale + offset ).xyz\n\t\t\t\t\t  + 2.0 * pos.xyz +", "\t\n\tfloat t = tmin;\n\tfloat h = 1.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th = texture( shadowMap, ro + rd*t ).r;\n\t\tt += k*h*(1.0-h);\n\t\tif( t>tmax ) break;\n\t}\n\t\n\treturn t;\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat calcDist( in vec2 p, in vec2 c, float r )\n{\n\treturn length( p-c ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions3D/distfunctions3D.htm\nfloat calcDist( in vec3 p, in vec3 c, float s, float r )\n{\n\treturn length( p-c ) - s - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions3D/distfunctions3D.htm\nfloat calcDist( in vec3 p, in vec3 c, float s, float r, float h )\n{\n\treturn length( p-c ) - s - r - h*max( 0.0, dot( p-c, vec3(0.0,0.0,1.0) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions3D/distfunctions3D.htm\nfloat calcDist( in vec3 p, in vec3 c, float s, float r, float h, float b )\n{\n\treturn length( p-c ) - s - r - h*max( 0.0, dot( p-c, vec3(0.0,0.0,1.0) ) ) - b*max( 0.0, dot( p-c, vec3(0.0,1.0,0.0) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions3D/distfunctions3D.htm\nfloat calcDist( in vec3 p, in vec3 c, float s, float r, float h, float b, float d )\n{\n\treturn length( p-c ) - s - r - h*max( 0.0, dot( p-c, vec3(0.0,0.0,1.0) ) ) - b*max( 0.0, dot( p-c, vec3(0.0,1.0,0.0) ) ) - d*max", "\t\n    return fract(sin(dot(q.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash with range\nfloat hash( in ivec2 q, in float r )\n{\n    return fract(sin(dot(q.xy,vec2(12.9898,78.233))) * 43758.5453) * r;\n}\n\n// random hash with range and offset\nfloat hash( in ivec2 q, in float r, in float o )\n{\n    return fract(sin(dot(q.xy + o,vec2(12.9898,78.233))) * 43758.5453) * r;\n}\n\n// random hash with range and offset and scale\nfloat hash( in ivec2 q, in float r, in float o, in float s )\n{\n    return fract(sin(dot(q.xy + o,vec2(12.9898,78.233))) * 43758.5453) * r * s;\n}\n\n// random hash with range and offset and scale and bias\nfloat hash( in ivec2 q, in float r, in float o, in float s, in float b )\n{\n    return fract(sin(dot(q.xy + o,vec2(12.9898,78.233))) * 43758.5453) * r * s + b;\n}\n\n// random hash with range and offset and scale and bias and wrap\nfloat hash( in ivec2 q, in float r, in float o, in float s, in float b, in float w )\n{\n    return fract(sin(dot(q.xy + o,vec2(12.9898,78.233))) * 43758.5453) * r * s + b + w;\n}\n\n// random hash with range and offset and scale and bias and wrap and clamp\nfloat hash( in ivec2 q, in float r, in float o, in float s, in float b, in float w, in float c )\n{\n    return clamp( fract(sin(dot(q.xy + o,vec2(12.9898,78.233))) * 43758.5453) * r * s + b + w, 0.0, c );\n}\n\n// random hash with range and offset and scale and bias and wrap and clamp and smoothstep\nfloat hash( in ivec2 q, in float r, in float o, in float s, in float b", "\t\n\treturn fract( sin( dot( x, vec2( 12.9898, 78.233 ) ) ) * 43758.5453123 );\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 x, in int p )\n{\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\t\n\tfloat a = noise( i, p );\n\tfloat b = noise( i + vec2( 1, 0 ), p );\n\tfloat c = noise( i + vec2( 0, 1 ), p );\n\tfloat d = noise( i + vec2( 1, 1 ), p );\n\t\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;\n}\n\n// 3D simplex noise\nfloat snoise( in vec3 x, in int p )\n{\n\tvec3 i = floor( x );\n\tvec3 f = fract( x );\n\t\n\tfloat a = noise( i, p );\n\tfloat b = noise( i + vec3( 1, 0, 0 ), p );\n\tfloat c = noise( i + vec3( 0, 1, 0 ), p );\n\tfloat d = noise( i + vec3( 1, 1, 0 ), p );\n\tfloat e = noise( i + vec3( 0, 0, 1 ), p );\n\tfloat f0 = noise( i + vec3( 1, 1, 1 ), p );\n\t\n\tvec3 u = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y + \n\t\t( e - a ) * u.z * ( 1.0 - u.y ) + ( f0 - b - c + a ) * u.x * u.y * u.z;\n}\n\n// 4D simplex noise\nfloat snoise( in vec4 x, in int p )\n{\n\tvec4 i = floor( x );\n\tvec4 f = fract( x );\n\t\n\tfloat a = noise( i, p );\n\tfloat", "\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float f )\n{\t\n\tfloat f2 = 0.0;\n\tfloat a = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf2 += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f2 * f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float f, in float g )\n{\t\n\tfloat f2 = 0.0;\n\tfloat a = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf2 += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f2 * f + g;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float f, in float g, in float h )\n{\t\n\tfloat f2 = 0.0;\n\tfloat a = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf2 += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f2 * f + g + h;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float f, in float g, in float h, in float i )\n{\t\n\tfloat f2 = 0.0;\n\tfloat a = 0.5;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf2 += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f2 * f + g + h + i;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float f, in float g, in float h, in float i, in float j )\n{", " \n    return length( p / r ) - 1.0; \n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4djSRW\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length", " \n    vec3 q = abs(p); \n    return min(q.z/r.y, min(q.x/r.x, q.y/r.y)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZ( in vec3 p, in vec2 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.x/r.x, min(q.z/r.y, q.y/r.y)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXY( in vec3 p, in vec2 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.x/r.x, min(q.y/r.y, q.z/r.z)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.x/r.x, min(q.y/r.y, q.z/r.z)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZY( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.x/r.x, min(q.z/r.z, q.y/r.y)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYZX( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.y/r.y, min(q.z/r.z, q.x/r.x)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZYX( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.z/r.z, min(q.y/r.y, q.x/r.x)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYXZ( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.y/r.y, min(q.x/r.x, q.z/r.z)); \n} \n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYZX( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs(p); \n    return min(q.y/r.y, min(q.z/r.z, q.x/r.x)); \n} \n\n//", " \n    return length( p / r ) - 1.0; \n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x );\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float s ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x ) * s;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float s, in float t ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x ) * s + t;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float s, in float t, in float u ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x ) * s + t + u;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float s, in float t, in float u, in float v ) \n{ \n    vec3 q = abs( p ) - r;\n    return length( max( q, 0.0 )) + min( length( min( q, 0.0 )), r.x ) * s + t + u +", " \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a ) \n{ \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - a;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a, in float b ) \n{ \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - a - b;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a, in float b, in float c ) \n{ \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - a - b - c;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a, in float b, in float c, in float d ) \n{ \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - a - b - c - d;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a, in float b, in float c, in float d, in float e ) \n{ \n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - a - b - c - d - e;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a, in float b, in float c, in float d, in float e, in float f ) \n{ \n    vec", "\t\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\t\n\tvec2 u = f.x+f.y;\n\t\n\tfloat k = 0.5;\n\t\n\tfloat a = step(k, u.x);\n\tfloat b = step(k, u.y);\n\t\n\tfloat c = step(k, 1.0-u.x);\n\tfloat d = step(k, 1.0-u.y);\n\t\n\tfloat e = step(k, 1.0-u.x-u.y);\n\tfloat f = step(k, u.x+u.y);\n\t\n\tfloat g = step(k, u.x-u.y);\n\tfloat h = step(k, 1.0-u.x+u.y);\n\t\n\tfloat i = step(k, 1.0-u.x+u.y);\n\tfloat j = step(k, u.x-u.y);\n\t\n\tfloat k = step(k, 1.0-u.x-u.y);\n\tfloat l = step(k, u.x+u.y);\n\t\n\tfloat m = step(k, 1.0-u.x+u.y);\n\tfloat n = step(k, u.x-u.y);\n\t\n\tfloat o = step(k, 1.0-u.x-u.y);\n\tfloat p = step(k, u.x+u.y);\n\t\n\tfloat q = step(k, 1.0-u.x+u.y);\n\tfloat r = step(k, u.x-u.y);\n\t\n\tfloat s = step(k, 1.0-u.x-u.y);\n\tfloat t = step(k, u.x+u.y);\n\t\n\tfloat u = step(k, 1.0-u.x+u.y);\n\tfloat v = step(k, u.x-u.y);\n\t\n\tfloat w = step(k, 1.0-u.x-u.y);\n\tfloat x = step(k, u.x+u.y);\n\t\n\tfloat y = step(k, 1.0-u.x+u.y);\n\tfloat z = step(k, u.x-u.y);\n\t\n\tfloat aa = step(k, 1.0-u.x-u.y);\n\tfloat ab = step(k, u.x+u.y);\n\t\n\tfloat ac = step(k, 1.0-u.x+u.y);\n\tfloat ad = step(k, u.x-u.y);\n\t\n\tfloat ae = step(k, 1.0-u.x-u.y);\n\tfloat af = step(k, u.x+u.y);\n\t\n\tfloat ag = step(k, 1.0-u.x+u.y);\n\tfloat ah = step(k, u.x-u.y);\n\t\n\tfloat ai = step(k, 1.0-u", " return a * ( 1.0 - x ) / ( a * ( 1.0 - x ) + x ); }\n\n// Schlick approximation of Fresnel reflectance, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float x )\n{ return a * ( 1.0 - x ) * ( 1.0 - x ) / ( ( 1.0 - a ) * ( 1.0 - x ) + a * x ); }\n\n// Schlick approximation of Fresnel transmittance, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_trans( float a, float x )\n{ return ( 1.0 - a ) * ( 1.0 - x ) * ( 1.0 - x ) / ( ( 1.0 - a ) * ( 1.0 - x ) + a * x ); }\n\n// Schlick approximation of Fresnel transmittance, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_trans( float a, float x )\n{ return ( 1.0 - a ) * ( 1.0 - x ) * ( 1.0 - x ) / ( ( 1.0 - a ) * ( 1.0 - x ) + a * x ); }\n\n// Schlick approximation of Fresnel transmittance, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_trans( float a, float x )\n{ return ( 1.0 - a ) * ( 1.0 - x ) * ( 1.0 - x ) / ( ( 1.0 - a ) * ( 1.0 - x ) + a * x ); }\n\n// Schlick approximation of Fresnel transmittance, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel_trans( float a, float x )\n{ return ( 1.0 - a ) * ( 1.0 - x ) * ( 1.0 - x ) / ( ( 1.0 - a ) * ( 1.0 - x ) + a * x ); }\n\n// Schlick approximation", " \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if ( t < 0.0 ) y = -1.0;\n  else if ( t > 1.0 ) y = 1.0;\n  else y = t;\n  return y;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{ \n  float y = 0.0;\n  float t = x + p;\n  if", " \n    vec3 c = vec3( 0.0 );\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h2*h2;\n    float h5 = h4*h;\n    float h6 = h4*h2;\n    float h7 = h6*h;\n    float h8 = h6*h2;\n    float h9 = h8*h;\n    float h10 = h8*h2;\n    float h11 = h10*h;\n    float h12 = h10*h2;\n    float h13 = h12*h;\n    float h14 = h12*h2;\n    float h15 = h14*h;\n    float h16 = h14*h2;\n    float h17 = h16*h;\n    float h18 = h16*h2;\n    float h19 = h18*h;\n    float h20 = h18*h2;\n    float h21 = h20*h;\n    float h22 = h20*h2;\n    float h23 = h22*h;\n    float h24 = h22*h2;\n    float h25 = h24*h;\n    float h26 = h24*h2;\n    float h27 = h26*h;\n    float h28 = h26*h2;\n    float h29 = h28*h;\n    float h30 = h28*h2;\n    float h31 = h30*h;\n    float h32 = h30*h2;\n    float h33 = h32*h;\n    float h34 = h32*h2;\n    float h35 = h34*h;\n    float h36 = h34*h2;\n    float h37 = h36*h;\n    float h38 = h36*h2;\n    float h39 = h38*h;\n    float h40 = h38*h2;\n    float h41 = h40*h;\n    float h42 = h40*h2;\n    float h43 = h42*h;\n    float h44 = h42*h2;\n    float h45 = h44*h;\n    float h46 = h44*h2;\n    float h47 = h46*h;\n    float h48 = h46*h2;\n    float h49 = h48*h;\n    float h50 = h48*h2;\n    float h51 = h50*h;\n    float h52 = h50*h2;\n    float h53 = h52*h;\n    float h54 = h", "\t\n\tvec3 o = ro - pa;\n\tfloat a = dot( o, rd );\n\tfloat b = dot( o, o ) - r*r;\n\tfloat c = dot( rd, rd );\n\tfloat d = b*b - a*c;\n\tif( d < 0.0 ) return -1.0;\n\td = sqrt( d );\n\treturn -a + d;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 pos, in float r )\n{\n\tvec3 oc = ro - pos;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\th = sqrt( h );\n\treturn -b - h;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float d )\n{\n\tfloat ndotrd = dot( n, rd );\n\tif( ndotrd > -0.0001 ) return -1.0;\n\tfloat ndotro = dot( n, ro );\n\tfloat t = ndotro / ndotrd;\n\tif( t > 0.0 ) return t;\n\treturn -1.0;\n}\n\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 min, in vec3 max )\n{\n\tvec3 k = 1.0 / max( abs( rd ), vec3( 0.0001 ) );\n\tvec3 t1 = -ro;\n\tvec3 t2 = ( max - ro ) * k;\n\tvec3 t = min( t1, t2 );\n\tt1 = ( min - ro ) * k;\n\tt2 = ( max - ro ) * k;\n\tt = max( t, min( t1, t2 ) );\n\tt1 = -max * k;\n\tt2 = -min * k;\n\tt = max( t, min( t1, t2 ) );\n\treturn any( lessThan( t, 0.0 ) )? -1.0 : max( t ).x;\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n\tvec3 o = ro - pa;\n\tfloat a = dot( o, rd );\n\tfloat b = dot( o, o ) - r*r;\n\tfloat c = dot( rd, rd );\n\tfloat d = b*b", " \n    vec3 q = p - a;\n    float h = dot(q, b);\n    float r = length(q - h * b);\n    return length(max(vec3(r - ra, h - rb, 0.0), 0.0)) - min(max(r - rb, 0.0), ra);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float ha)\n{\n    vec3 q = p - a;\n    float h = dot(q, b);\n    float r = length(q - h * b);\n    return length(max(vec3(r - ra, h - rb, 0.0), 0.0)) - min(max(r - rb, 0.0), ra) - ha;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float ha, float h)\n{\n    vec3 q = p - a;\n    float r = length(q - h * b);\n    return length(max(vec3(r - ra, h - rb, 0.0), 0.0)) - min(max(r - rb, 0.0), ra) - ha;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float ha, float h, float r)\n{\n    vec3 q = p - a;\n    float r2 = length(q - h * b);\n    return length(max(vec3(r2 - ra, h - rb, 0.0), 0.0)) - min(max(r2 - rb, 0.0), ra) - ha;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float ha, float h, float r, float r2)\n{\n    vec3 q = p - a;\n    float r3 = length(q - h * b);\n    return length(max(vec3(r3 - ra, h - rb, 0.0), 0.0)) - min(max(r3 - rb, 0.0), ra) - ha;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float ha, float h, float r, float r2, float r3)\n{\n    vec3 q = p - a;\n    float r4 = length(q -", "\t\n\tfloat d = length( a - b );\n\tfloat h = max( 0.0, dot( normalize( a - b ), normalize( ro - b ) ) );\n\tfloat s = 1.0 - h * h;\n\tfloat p = pow( s, k );\n\tfloat d2 = d * d;\n\tfloat d2r2 = d2 - r * r;\n\tfloat d2r2p = d2r2 * p;\n\tfloat d2r2p2 = d2r2p * p;\n\tfloat d2r2p3 = d2r2p2 * p;\n\tfloat d2r2p4 = d2r2p3 * p;\n\tfloat d2r2p5 = d2r2p4 * p;\n\tfloat d2r2p6 = d2r2p5 * p;\n\tfloat d2r2p7 = d2r2p6 * p;\n\tfloat d2r2p8 = d2r2p7 * p;\n\tfloat d2r2p9 = d2r2p8 * p;\n\tfloat d2r2p10 = d2r2p9 * p;\n\tfloat d2r2p11 = d2r2p10 * p;\n\tfloat d2r2p12 = d2r2p11 * p;\n\tfloat d2r2p13 = d2r2p12 * p;\n\tfloat d2r2p14 = d2r2p13 * p;\n\tfloat d2r2p15 = d2r2p14 * p;\n\tfloat d2r2p16 = d2r2p15 * p;\n\tfloat d2r2p17 = d2r2p16 * p;\n\tfloat d2r2p18 = d2r2p17 * p;\n\tfloat d2r2p19 = d2r2p18 * p;\n\tfloat d2r2p20 = d2r2p19 * p;\n\tfloat d2r2p21 = d2r2p20 * p;\n\tfloat d2r2p22 = d2r2p21 * p;\n\tfloat d2r2p23 = d2r2p22 * p;\n\tfloat d2r2p24 = d2r2p23 * p;\n\tfloat d2r2p25 = d2r2p24 * p;\n\tfloat d2r2p26 = d2r2p", "\t\n\tvec2 p = uv;\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\t\n\tfloat t = 0.0;\n\tif (r < rad1)\n\t\tt = 1.0;\n\telse if (r < rad2)\n\t\tt = (r - rad1) / (rad2 - rad1);\n\telse\n\t\tt = 0.0;\n\t\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\tvec2 q = vec2(c, s);\n\t\n\treturn p + th * t * q;\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\t\n\tvec2 p = uv;\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\t\n\tfloat t = 0.0;\n\tif (r < rad1)\n\t\tt = 1.0;\n\telse if (r < rad2)\n\t\tt = (r - rad1) / (rad2 - rad1);\n\telse\n\t\tt = 0.0;\n\t\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\tvec2 q = vec2(c, s);\n\t\n\treturn p + th * t * q;\n}", "\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d, in float e )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d, in float e, in float f )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d, in float e, in float f, in float g )\n{\t\n\tfloat d = length(p-c);\n\treturn d-r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d, in", " \n    vec3 df = vec3( pos.x*pos.x*pos.x*pos.x, pos.y*pos.y*pos.y*pos.y, pos.z*pos.z*pos.z*pos.z );\n    return df - vec3( 1.0, 1.0, 1.0 );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra )\n{ \n    vec3 df = vec3( pos.x*pos.x*pos.x*pos.x, pos.y*pos.y*pos.y*pos.y, pos.z*pos.z*pos.z*pos.z );\n    return df - vec3( ra*ra, ra*ra, ra*ra );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2 )\n{ \n    vec3 df = vec3( pos.x*pos.x*pos.x*pos.x, pos.y*pos.y*pos.y*pos.y, pos.z*pos.z*pos.z*pos.z );\n    return df - vec3( ra2, ra2, ra2 );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2, in float ra3 )\n{ \n    vec3 df = vec3( pos.x*pos.x*pos.x*pos.x, pos.y*pos.y*pos.y*pos.y, pos.z*pos.z*pos.z*pos.z );\n    return df - vec3( ra3, ra3, ra3 );\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2, in float ra3, in float ra4 )\n{ \n    vec3 df = vec3( pos.x*pos.x*pos.x*pos.x,", "\t\n\tvec2 q = p - sca.xy;\n\tfloat a = atan(q.x, q.y) + scb.x * 3.141592653589793;\n\tfloat r = length(q) - scb.y;\n\treturn r - ra + rb;\n}\n\nfloat sdArc( in vec2 p, in float ra, in float rb )\n{\n\treturn sdArc( p, vec2(0.0, 0.0), vec2(0.0, 0.0), ra, rb );\n}\n\nfloat sdArc( in vec2 p, in float ra )\n{\n\treturn sdArc( p, ra, 0.0 );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in float ra )\n{\n\treturn sdArc( p, sca, vec2(0.0, 0.0), ra, 0.0 );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb )\n{\n\treturn sdArc( p, sca, scb, 0.0, 0.0 );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in float ra, in float rb )\n{\n\treturn sdArc( p, sca, vec2(0.0, 0.0), ra, rb );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in float ra )\n{\n\treturn sdArc( p, sca, vec2(0.0, 0.0), ra, 0.0 );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra )\n{\n\treturn sdArc( p, sca, scb, ra, 0.0 );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n\treturn sdArc( p, sca, scb, ra, rb );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in float ra, in float rb, in float r )\n{\n\treturn sdArc( p, sca, vec2(0.0, 0.0), ra, rb, r );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r )\n{\n\treturn sdArc( p, sca, scb, ra, rb, r );\n", "\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th += 0.5*exp( -t*t/0.0025 );\n\t\tt += 0.1;\n\t\tif( t>tmax ) break;\n\t}\n\t\n\treturn h;\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length( p ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs( p ) - b;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat sdHexagon( in vec2 p, in float r )\n{\n\tvec2 q = vec2( abs( p.x ), abs( p.y ) );\n\tvec2 d = length( q-vec2(clamp( q.x, 0.0, r ), r) ) - r;\n\treturn length( max( vec2(0.0), q-vec2(clamp( q.x, 0.0, r ), r) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat sdStar( in vec2 p, in float r )\n{\n\tvec2 q = vec2( abs( p.x ), abs( p.y ) );\n\tvec2 d = length( q-vec2(clamp( q.x, 0.0, r ), r) ) - r;\n\treturn length( max( vec2(0.0), q-vec2(clamp( q.x, 0.0, r ), r) ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2D/distfunctions2D.htm\nfloat sdStar2( in vec2 p, in float r )\n{\n\tvec2 q = vec2( abs( p.x ), abs( p.y ) );\n\tvec2 d = length( q-vec2(clamp( q.x, 0.0, r ), r) ) - r;\n\treturn length( max( vec", "\t\n\tvec3 n = vec3( 0.0 );\n\t\n\tfloat d = 0.0;\n\t\n\tfor( int i = 0; i < 5; i++ )\n\t{\n\t\tvec3 p = pos + vec3( 0.0, 0.0, 0.0 );\n\t\tfloat d = distance( p, pos );\n\t\tn += ( p - pos ) / d;\n\t}\n\t\n\treturn normalize( n );\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\t\n\tvec3 n = vec3( 0.0 );\n\t\n\tfloat d = 0.0;\n\t\n\tfor( int i = 0; i < 5; i++ )\n\t{\n\t\tvec3 p = pos + vec3( 0.0, 0.0, 0.0 );\n\t\tfloat d = distance( p, pos );\n\t\tn += ( p - pos ) / d;\n\t}\n\t\n\treturn normalize( n );\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\t\n\tvec3 n = vec3( 0.0 );\n\t\n\tfloat d = 0.0;\n\t\n\tfor( int i = 0; i < 5; i++ )\n\t{\n\t\tvec3 p = pos + vec3( 0.0, 0.0, 0.0 );\n\t\tfloat d = distance( p, pos );\n\t\tn += ( p - pos ) / d;\n\t}\n\t\n\treturn normalize( n );\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\t\n\tvec3 n = vec3( 0.0 );\n\t\n\tfloat d = 0.0;\n\t\n\tfor( int i = 0; i < 5; i++ )\n\t{\n\t\tvec3 p = pos + vec3( 0.0, 0.0, 0.0 );\n\t\tfloat d = distance( p, pos );\n\t\tn += ( p - pos ) / d;\n\t}\n\t\n\treturn normalize( n );\n}\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\t\n\tvec3 n = vec3( 0.0 );\n\t\n\tfloat d = 0.0;\n\t\n\tfor( int i = 0; i < 5; i++ )\n\t{\n\t\tvec3 p = pos + vec3( 0.0, 0.0, 0.0 );\n\t\tfloat", "\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, h );\n\t\tt += h*0.25;\n\t\tif( t>tmax ) break;\n\t}\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, h );\n\t\tt += h*0.25;\n\t\tif( t>tmax ) break;\n\t}\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, h );\n\t\tt += h*0.25;\n\t\tif( t>tmax ) break;\n\t}\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\th = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, h );\n\t\tt += h*0.25", "\t\n\tvec2  ip = floor( p );\n\tvec2  fp = fract( p );\n\tvec2  dp = dpdx * fp.x + dpdy * fp.y;\n\t\n\tfloat c = 0.0;\n\t\n\tif( dot( dp, dp ) < 0.0001 )\n\t{\n\t\tc = 1.0;\n\t}\n\telse\n\t{\n\t\tvec2  ip1 = ip + vec2( 1.0 );\n\t\tvec2  ip2 = ip + vec2( 2.0 );\n\t\tvec2  ip3 = ip + vec2( 3.0 );\n\t\t\n\t\tvec2  dp1 = dpdx * ip1.x + dpdy * ip1.y;\n\t\tvec2  dp2 = dpdx * ip2.x + dpdy * ip2.y;\n\t\tvec2  dp3 = dpdx * ip3.x + dpdy * ip3.y;\n\t\t\n\t\tfloat d1 = dot( dp, dp1 );\n\t\tfloat d2 = dot( dp, dp2 );\n\t\tfloat d3 = dot( dp, dp3 );\n\t\t\n\t\tfloat d = min( min( d1, d2 ), d3 );\n\t\t\n\t\tc = 1.0 - smoothstep( 0.0, 0.0001, d );\n\t}\n\t\n\treturn c;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float size )\n{\t\n\tvec2  ip = floor( p / size );\n\tvec2  fp = fract( p / size );\n\tvec2  dp = dpdx * fp.x + dpdy * fp.y;\n\t\n\tfloat c = 0.0;\n\t\n\tif( dot( dp, dp ) < 0.0001 )\n\t{\n\t\tc = 1.0;\n\t}\n\telse\n\t{\n\t\tvec2  ip1 = ip + vec2( 1.0 );\n\t\tvec2  ip2 = ip + vec2( 2.0 );\n\t\tvec2  ip3 = ip + vec2( 3.0 );\n\t\t\n\t\tvec2  dp1 = dpdx * ip1.x + dpdy * ip1.y;\n\t\tvec2  dp2 = dpdx * ip2.x + dpdy * ip2.y;\n\t\tvec2  dp3 = dpdx * ip3.x + dpdy * ip3.y;\n\t\t\n\t\tfloat d1 = dot( dp", " return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.0) : (x*2.0+1.0); }\n\n// The function y=f(x) is a staircase function with parameter k.\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{ return (k>1.0)? (x*2.", " \n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 sample_dir = normalize(sample_pos - surface_normal);\n    float light_intensity = dot(light_dir_norm, sample_dir);\n    return background_col * light_intensity;\n}\n\n/*\nThe main function that renders the planet\n*/\nvoid main() {\n    // Get the surface normal\n    vec3 surface_normal = normalize(normal);\n    // Get the light direction\n    vec3 light_dir = normalize(light);\n    // Get the background color\n    vec3 background_col = vec3(0.5, 0.5, 0.5);\n    // Get the sample position\n    vec3 sample_pos = vec3(0.0, 0.0, 0.0);\n    // Get the sample direction\n    vec3 sample_dir = vec3(0.0, 0.0, 0.0);\n    // Get the sample color\n    vec3 sample_col = vec3(0.0, 0.0, 0.0);\n    // Get the sample depth\n    float sample_depth = 0.0;\n    // Get the sample radius\n    float sample_radius = 0.0;\n    // Get the sample height\n    float sample_height = 0.0;\n    // Get the sample width\n    float sample_width = 0.0;\n    // Get the sample length\n    float sample_length = 0.0;\n    // Get the sample area\n    float sample_area = 0.0;\n    // Get the sample volume\n    float sample_volume = 0.0;\n    // Get the sample density\n    float sample_density = 0.0;\n    // Get the sample pressure\n    float sample_pressure = 0.0;\n    // Get the sample temperature\n    float sample_temperature = 0.0;\n    // Get the sample viscosity\n    float sample_viscosity = 0.0;\n    // Get the sample thermal conductivity\n    float sample_thermal_conductivity = 0.0;\n    // Get the sample specific heat capacity\n    float sample_specific_heat_capacity = 0.0;\n    // Get the sample adiabatic index\n    float sample_adiabatic_index = 0.0;\n    // Get the sample sound speed\n    float sample_sound_speed = 0.0;\n    // Get the sample refractive index\n    float sample_refractive_index = 0.0;\n   ", " \n    vec3 color = vec3(0.0, 1.0, 0.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the atmosphere\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_atmosphere(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the sky\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_sky(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the sun\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_sun(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(1.0, 1.0, 0.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the moon\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_moon(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0, 0.0, 1.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the stars\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_stars(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    return vec4(color, dist);\n}\n\n/*\nThe following function returns the color of the planet\nthe color is in.xyz, the distance in.w\n*/\nvec4 render_planet(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 color = vec3", " //resolution is the resolution of the image\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (coord.x / resolution.x) * 2.0 - 1.0;\n    camera_vector.y = (coord.y / resolution.y) * 2.0 - 1.0;\n    camera_vector.z = 1.0;\n    return camera_vector;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_position, float focal_length) {\n    vec3 ray_direction = vec3(0.0);\n    ray_direction = normalize(camera_vector * focal_length + camera_position);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray origin\nthis function calculates it\n*/\nvec3 get_ray_origin(vec3 camera_position, float focal_length) {\n    vec3 ray_origin = vec3(0.0);\n    ray_origin = camera_position - camera_position * focal_length;\n    return ray_origin;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_position, float focal_length) {\n    vec3 ray_direction = vec3(0.0);\n    ray_direction = normalize(camera_vector * focal_length + camera_position);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_position, float focal_length) {\n    vec3 ray_direction = vec3(0.0);\n    ray_direction = normalize(camera_vector * focal_length + camera_position);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_position, float focal_length) {\n    vec3 ray_direction = vec3(0.0);\n    ray_direction = normalize(camera_vector * focal_length + camera_position);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_position, float focal_length) {\n    vec3 ray_direction = vec3(0.0);\n    ray_direction = normalize(camera_vector * focal_length + camera_position);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray direction\nthis function calculates it\n*/\nvec3 get_ray", "\t\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\treturn d;\n}\n\nfloat sdCone(vec3 p, vec2 c, float ra)\n{\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\treturn d;\n}\n\nfloat sdCone(vec3 p, vec2 c, float ra, float ha)\n{\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\tfloat h = r * cos(a * c.x) - ha;\n\treturn max(d, h);\n}\n\nfloat sdCone(vec3 p, vec2 c, float ra, float ha, float ra2)\n{\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\tfloat h = r * cos(a * c.x) - ha;\n\tfloat d2 = r * sin(a * c.y) - ra2;\n\treturn max(max(d, h), d2);\n}\n\nfloat sdCone(vec3 p, vec2 c, float ra, float ha, float ra2, float ha2)\n{\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\tfloat h = r * cos(a * c.x) - ha;\n\tfloat d2 = r * sin(a * c.y) - ra2;\n\tfloat h2 = r * cos(a * c.y) - ha2;\n\treturn max(max(d, h), max(d2, h2));\n}\n\nfloat sdCone(vec3 p, vec2 c, float ra, float ha, float ra2, float ha2, float ra3)\n{\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat d = r * sin(a * c.x) - ra;\n\tfloat h = r * cos(a * c.x) - ha;\n\tfloat d2 = r * sin(a * c.y) - ra2;\n\tfloat h2 = r * cos(a * c.y) - ha2;\n\tfloat d3 = r * sin(a * c.z) - ra3;\n\treturn max(max(max(d, h), max(d2, h2)), d3);\n}\n\nfloat sdC", " \n  if (material == 0) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 1) {\n    return vec3(1.0, 0.0, 0.0);\n  } else if (material == 2) {\n    return vec3(0.0, 1.0, 0.0);\n  } else if (material == 3) {\n    return vec3(0.0, 0.0, 1.0);\n  } else if (material == 4) {\n    return vec3(1.0, 1.0, 0.0);\n  } else if (material == 5) {\n    return vec3(1.0, 0.0, 1.0);\n  } else if (material == 6) {\n    return vec3(0.0, 1.0, 1.0);\n  } else if (material == 7) {\n    return vec3(0.5, 0.5, 0.5);\n  } else if (material == 8) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 9) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 10) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 11) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 12) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 13) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 14) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 15) {\n    return vec3(0.0, 0.0, 0.0);\n  } else if (material == 16) {\n    return vec3(0.0, 0.0, 0.0);\n  } else", " return 0.0; }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, float time) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal, float time) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal, vec3 view_direction) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal, vec3 view_direction, float time) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal, vec3 view_direction, vec3 light_direction) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, vec3 position, vec3 normal, vec3 view_direction, vec3", " \n  if (material == 0) return 1.0; // air\n  if (material == 1) return 1.33; // water\n  if (material == 2) return 1.5; // glass\n  if (material == 3) return 1.7; // diamond\n  if (material == 4) return 1.8; // ruby\n  if (material == 5) return 1.9; // sapphire\n  if (material == 6) return 2.0; // quartz\n  if (material == 7) return 2.1; // topaz\n  if (material == 8) return 2.2; // amethyst\n  if (material == 9) return 2.3; // fluorite\n  if (material == 10) return 2.4; // calcite\n  if (material == 11) return 2.5; // apatite\n  if (material == 12) return 2.6; // beryl\n  if (material == 13) return 2.7; // tourmaline\n  if (material == 14) return 2.8; // zircon\n  if (material == 15) return 2.9; // spinel\n  if (material == 16) return 3.0; // garnet\n  if (material == 17) return 3.1; // peridot\n  if (material == 18) return 3.2; // chrysoberyl\n  if (material == 19) return 3.3; // corundum\n  if (material == 20) return 3.4; // rutile\n  if (material == 21) return 3.5; // ilmenite\n  if (material == 22) return 3.6; // magnetite\n  if (material == 23) return 3.7; // hematite\n  if (material == 24) return 3.8; // pyrite\n  if (material == 25) return 3.9; // galena\n  if (material == 26) return 4.0; // cassiterite\n  if (material == 27) return 4.1; // wolframite\n  if (material", " return 0.0; }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w, float x) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w, float x, float y) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w, float x, float y, float z) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w, float x, float y, float z, float a) { return vec3(0.0); }\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec3 get_material_color(int material, float time, float u, float v, float w, float x, float y, float z, float a, float b) { return vec3(0.0", " \n    vec3 ab = line_b - line_a;\n    vec3 ac = tri_b - tri_a;\n    vec3 ad = tri_c - tri_a;\n    vec3 p = cross(ab, ac);\n    float det = dot(p, ad);\n    if (det == 0.0) return vec3(0.0, 0.0, 0.0);\n    float inv_det = 1.0 / det;\n    vec3 s = cross(ad, ac);\n    float u = dot(s, ab) * inv_det;\n    if (u < 0.0 || u > 1.0) return vec3(0.0, 0.0, 0.0);\n    vec3 q = cross(ad, ab);\n    float v = dot(q, ac) * inv_det;\n    if (v < 0.0 || u + v > 1.0) return vec3(0.0, 0.0, 0.0);\n    return vec3(1.0, u, v);\n}", " \n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 normal = cross(ab, ac);\n    return normalize(normal);\n}\n", " \n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_up, camera_forward));\n    vec3 camera_up = normalize(cross(camera_forward, camera_right));\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) { \n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_up, camera_forward));\n    vec3 camera_up = normalize(cross(camera_forward, camera_right));\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) { \n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_up, camera_forward));\n    vec3 camera_up = normalize(cross(camera_forward, camera_right));\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) { \n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_forward = normalize(camera_target - camera_position);\n    vec3 camera_right = normalize(cross(camera_up, camera_forward));\n    vec3 camera_up = normalize(cross(camera_forward, camera_right));\n    return mat3(camera_right, camera_up, camera_forward);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position", " \n    cast_ray_result result;\n    result.intersected = false;\n    result.distance = 0.0;\n    result.normal = vec3(0.0, 0.0, 0.0);\n    result.color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < triangles.size(); i++) {\n        triangle t = triangles[i];\n        vec3 v0 = t.v0;\n        vec3 v1 = t.v1;\n        vec3 v2 = t.v2;\n        vec3 e1 = v1 - v0;\n        vec3 e2 = v2 - v0;\n        vec3 p = cross(ray_target - ray_origin, e2);\n        float det = dot(e1, p);\n        if (det > -0.00001 && det < 0.00001) continue;\n        float inv_det = 1.0 / det;\n        vec3 tvec = ray_origin - v0;\n        float u = dot(tvec, p) * inv_det;\n        if (u < 0.0 || u > 1.0) continue;\n        vec3 q = cross(tvec, e1);\n        float v = dot(ray_target - v0, q) * inv_det;\n        if (v < 0.0 || u + v > 1.0) continue;\n        float t = dot(e2, q) * inv_det;\n        if (t > 0.00001) {\n            result.intersected = true;\n            result.distance = t;\n            result.normal = normalize(cross(e1, e2));\n            result.color = t.color;\n        }\n    }\n    return result;\n}\n", " \n    float shadow = 1.0;\n    vec3 light_dir = normalize(directional_light.position - ray_origin);\n    float light_dist = length(directional_light.position - ray_origin);\n    float light_dist2 = light_dist * light_dist;\n    float light_dist3 = light_dist2 * light_dist;\n    float light_dist4 = light_dist3 * light_dist;\n    float light_dist5 = light_dist4 * light_dist;\n    float light_dist6 = light_dist5 * light_dist;\n    float light_dist7 = light_dist6 * light_dist;\n    float light_dist8 = light_dist7 * light_dist;\n    float light_dist9 = light_dist8 * light_dist;\n    float light_dist10 = light_dist9 * light_dist;\n    float light_dist11 = light_dist10 * light_dist;\n    float light_dist12 = light_dist11 * light_dist;\n    float light_dist13 = light_dist12 * light_dist;\n    float light_dist14 = light_dist13 * light_dist;\n    float light_dist15 = light_dist14 * light_dist;\n    float light_dist16 = light_dist15 * light_dist;\n    float light_dist17 = light_dist16 * light_dist;\n    float light_dist18 = light_dist17 * light_dist;\n    float light_dist19 = light_dist18 * light_dist;\n    float light_dist20 = light_dist19 * light_dist;\n    float light_dist21 = light_dist20 * light_dist;\n    float light_dist22 = light_dist21 * light_dist;\n    float light_dist23 = light_dist22 * light_dist;\n    float light_dist24 = light_dist23 * light_dist;\n    float light_dist25 = light_dist24 * light_dist;\n    float light_dist26 = light_dist25 * light_dist;\n    float light_dist27 = light_dist26 * light_dist;\n    float light_dist28 = light_dist27 * light_dist;\n    float light_dist29 = light_dist28 * light_dist;\n    float light_dist30 = light_dist29 * light_dist;\n    float light_dist31 = light_dist30 * light_dist;\n    float light_dist32 = light_dist31 * light_dist;\n    float light_dist33 = light_dist32 * light_dist;\n    float light_dist34 = light_dist33 * light_dist;\n    float light_dist35 = light_dist34 * light_dist;\n    float light_dist36 = light_dist35 * light_dist;\n    float light_dist37 = light_dist36 * light_dist;\n    float light_dist38 =", "\t\n\treturn fract( sin( x ) * 43758.5453123 );\n}\n\n// 2D noise\nfloat bnoise( in vec2 p )\n{\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tfloat a = bnoise( i );\n\tfloat b = bnoise( i + vec2( 1.0, 0.0 ) );\n\tfloat c = bnoise( i + vec2( 0.0, 1.0 ) );\n\tfloat d = bnoise( i + vec2( 1.0, 1.0 ) );\n\t\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;\n}\n\n// 3D noise\nfloat bnoise( in vec3 p )\n{\n\tvec3 i = floor( p );\n\tvec3 f = fract( p );\n\t\n\tfloat a = bnoise( i );\n\tfloat b = bnoise( i + vec3( 1.0, 0.0, 0.0 ) );\n\tfloat c = bnoise( i + vec3( 0.0, 1.0, 0.0 ) );\n\tfloat d = bnoise( i + vec3( 1.0, 1.0, 0.0 ) );\n\tfloat e = bnoise( i + vec3( 0.0, 0.0, 1.0 ) );\n\tfloat f_ = bnoise( i + vec3( 1.0, 0.0, 1.0 ) );\n\tfloat g = bnoise( i + vec3( 0.0, 1.0, 1.0 ) );\n\tfloat h = bnoise( i + vec3( 1.0, 1.0, 1.0 ) );\n\t\n\tvec3 u = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y + ( e - a ) * u.z * ( 1.0 - u.x ) + ( f_ - b )", "\t\n\treturn fract( sin( p * 1.0 ) * 43758.5453123 );\n}\n\n// Perlin noise\nfloat pnoise( in float p )\n{\n\treturn fract( sin( p * 1.0 ) * 43758.5453123 );\n}\n\n// Perlin noise with 2D coordinates\nfloat pnoise( in vec2 p )\n{\n\treturn fract( sin( dot( p, vec2( 1.0, 7.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 3D coordinates\nfloat pnoise( in vec3 p )\n{\n\treturn fract( sin( dot( p, vec3( 1.0, 7.0, 11.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 4D coordinates\nfloat pnoise( in vec4 p )\n{\n\treturn fract( sin( dot( p, vec4( 1.0, 7.0, 11.0, 23.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 5D coordinates\nfloat pnoise( in vec5 p )\n{\n\treturn fract( sin( dot( p, vec5( 1.0, 7.0, 11.0, 23.0, 41.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 6D coordinates\nfloat pnoise( in vec6 p )\n{\n\treturn fract( sin( dot( p, vec6( 1.0, 7.0, 11.0, 23.0, 41.0, 59.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 7D coordinates\nfloat pnoise( in vec7 p )\n{\n\treturn fract( sin( dot( p, vec7( 1.0, 7.0, 11.0, 23.0, 41.0, 59.0, 71.0 ) ) ) * 43758.5453123 );\n}\n\n// Perlin noise with 8D coordinates\nfloat pnoise( in vec8 p )\n{\n\treturn fract( sin( dot( p, vec8( 1.0, 7.0, 11.0, 23.0, 41", " \n  return fract( sin( n * 12.9898 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i, int j ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 + j * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i, int j, int k ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 + j * 4.1414 + k * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i, int j, int k, int l ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 + j * 4.1414 + k * 4.1414 + l * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i, int j, int k, int l, int m ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 + j * 4.1414 + k * 4.1414 + l * 4.1414 + m * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash( int n, int i, int j, int k, int l, int m, int o ) \n{ \n  return fract( sin( n * 12.9898 + i * 4.1414 + j * 4.1414 + k * 4.1414 + l * 4.1414 + m * 4.1414 + o * 4.1414 ) * 43758.5453 ); \n}\n\n// integer hash copied from Hugo Elias\nfloat hash", "\t\n\tfloat n = 0.0;\n\tfloat s = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tfloat f = fract( p * 0.00390625 * i );\n\t\tfloat d = 0.5 - abs( f - 0.5 );\n\t\tn += d * d;\n\t\ts += d;\n\t}\n\t\n\treturn n / s;\n}\n\n// gradient noise\nfloat gnoise( in vec2 p )\n{\t\n\tfloat n = 0.0;\n\tfloat s = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tfloat f = fract( p * 0.00390625 * i );\n\t\tfloat d = 0.5 - abs( f - 0.5 );\n\t\tn += d * d;\n\t\ts += d;\n\t}\n\t\n\treturn n / s;\n}\n\n// gradient noise\nfloat gnoise( in vec3 p )\n{\t\n\tfloat n = 0.0;\n\tfloat s = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tfloat f = fract( p * 0.00390625 * i );\n\t\tfloat d = 0.5 - abs( f - 0.5 );\n\t\tn += d * d;\n\t\ts += d;\n\t}\n\t\n\treturn n / s;\n}\n\n// gradient noise\nfloat gnoise( in vec4 p )\n{\t\n\tfloat n = 0.0;\n\tfloat s = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tfloat f = fract( p * 0.00390625 * i );\n\t\tfloat d = 0.5 - abs( f - 0.5 );\n\t\tn += d * d;\n\t\ts += d;\n\t}\n\t\n\treturn n / s;\n}\n\n// gradient noise\nfloat gnoise( in vec2 p, float scale )\n{\t\n\tfloat n = 0.0;\n\tfloat s = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tfloat f = fract( p * scale * 0.00390625 * i );\n\t\tfloat d = 0.5 - abs( f - 0.5 );\n\t\tn += d * d;\n\t\ts += d;\n", "\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm2\nfloat fbm2( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm3\nfloat fbm3( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm4\nfloat fbm4( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm5\nfloat fbm5( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm6\nfloat fbm6( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n}\n\n// fbm7\nfloat fbm7( in float x, in float G )\n{\t\n\tfloat f = 0.0;\n\t\n\tfor( int i = 0; i < 8; i++ )\n\t{\n\t\tf += abs( sin( x + i * G ) );\n\t\tG *= 2.0;\n\t}\n\t\n\treturn f;\n", "\t\n\t// The quadratic polynomial\n\tfloat a = 1.0;\n\tfloat b = 2.0 * dot( p, p );\n\tfloat c = dot( p, p );\n\t\n\t// The discriminant\n\tfloat d = b * b - 4.0 * a * c;\n\t\n\t// The solutions\n\tfloat s1 = (-b + sqrt( d )) / (2.0 * a);\n\tfloat s2 = (-b - sqrt( d )) / (2.0 * a);\n\t\n\t// The color\n\tvec3 color = vec3( 0.0 );\n\t\n\t// If the solutions are real\n\tif( d >= 0.0 )\n\t{\n\t\t// If the solutions are equal\n\t\tif( s1 == s2 )\n\t\t{\n\t\t\t// The color is red\n\t\t\tcolor = vec3( 1.0, 0.0, 0.0 );\n\t\t}\n\t\t// If the solutions are different\n\t\telse\n\t\t{\n\t\t\t// The color is green\n\t\t\tcolor = vec3( 0.0, 1.0, 0.0 );\n\t\t}\n\t}\n\t// If the solutions are complex\n\telse\n\t{\n\t\t// The color is blue\n\t\tcolor = vec3( 0.0, 0.0, 1.0 );\n\t}\n\t\n\treturn color;\n}\n", "\t\n\tvec3 p = pb * 2.0 - 1.0; // p is in 0..2\n\tvec3 q = p * p; // q is in 0..4\n\tvec3 r = q * p; // r is in 0..8\n\tvec3 s = r * p; // s is in 0..16\n\tvec3 t = s * p; // t is in 0..32\n\tvec3 u = t * p; // u is in 0..64\n\tvec3 v = u * p; // v is in 0..128\n\tvec3 w = v * p; // w is in 0..256\n\tvec3 x = w * p; // x is in 0..512\n\tvec3 y = x * p; // y is in 0..1024\n\tvec3 z = y * p; // z is in 0..2048\n\tvec3 a = z * p; // a is in 0..4096\n\tvec3 b = a * p; // b is in 0..8192\n\tvec3 c = b * p; // c is in 0..16384\n\tvec3 d = c * p; // d is in 0..32768\n\tvec3 e = d * p; // e is in 0..65536\n\tvec3 f = e * p; // f is in 0..131072\n\tvec3 g = f * p; // g is in 0..262144\n\tvec3 h = g * p; // h is in 0..524288\n\tvec3 i = h * p; // i is in 0..1048576\n\tvec3 j = i * p; // j is in 0..2097152\n\tvec3 k = j * p; // k is in 0..4194304\n\tvec3 l = k * p; // l is in 0..8388608\n\tvec3 m = l * p; // m is in 0..16777216\n\tvec3 n = m * p; // n is in 0..33554432\n\tvec3 o = n * p; // o is in 0..67108864\n\tvec3 p1 = o * p; // p1 is in 0..134217728\n\tvec3 p2 = p1 * p; // p2 is in ", " \n    vec3 p = ro - cen;\n    vec3 q = p / rd;\n    vec3 t = -p;\n    vec3 k = abs(q) - rad;\n    vec3 s = clamp( k, 0.0, k.yzx * k.zxy );\n    k.y = max( k.x, k.z );\n    t += s * (q - sign(q) * (k - s));\n    return vec4( t.x, t.y, t.z, max( k.x, max( k.y, k.z ) ) );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{ \n    vec3 p = ro - cen;\n    vec3 q = p / rd;\n    vec3 t = -p;\n    vec3 k = abs(q) - rad;\n    vec3 s = clamp( k, 0.0, k.yzx * k.zxy );\n    k.y = max( k.x, k.z );\n    t += s * (q - sign(q) * (k - s));\n    return vec4( t.x, t.y, t.z, max( k.x, max( k.y, k.z ) ) );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{ \n    vec3 p = ro - cen;\n    vec3 q = p / rd;\n    vec3 t = -p;\n    vec3 k = abs(q) - rad;\n    vec3 s = clamp( k, 0.0, k.yzx * k.zxy );\n    k.y = max( k.x, k.z );\n    t += s * (q - sign(q) * (k - s));\n    return vec4( t.x, t.y, t.z, max( k.x, max( k.y, k.z ) ) );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{ \n    vec3 p = ro - cen;\n    vec3 q = p /", " \n    float t = 0.0;\n    float res = 1e32;\n    for( int i=0; i<3; i++ ) \n    { \n        float d = dot( rd, vec3( i&1, (i+1)&1, 1-(i+1)&1 ) );\n        float k = cen[i] - ro[i] - d;\n        if( k<0.0 ) continue;\n        float r = rad[i];\n        if( k<r ) \n        { \n            t = (k-r)/d;\n            res = min( res, t );\n        }\n        else\n        {\n            t = (k+r)/d;\n            res = min( res, t );\n        }\n    }\n    return res;\n}", "\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\th += 1.0;\n\t\tfloat d = textureLod(sampler2DShadow(shadowMap, 0), ro + rd * t, h).r;\n\t\tres = min(res, d);\n\t\tt += d * w;\n\t\tif (t > tmax) break;\n\t}\n\t\n\treturn res;\n}\n\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float bias)\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\th += 1.0;\n\t\tfloat d = textureLod(sampler2DShadow(shadowMap, 0), ro + rd * t, h).r;\n\t\tres = min(res, d);\n\t\tt += d * w;\n\t\tif (t > tmax) break;\n\t}\n\t\n\treturn res - bias;\n}\n\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float bias, float k)\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\th += 1.0;\n\t\tfloat d = textureLod(sampler2DShadow(shadowMap, 0), ro + rd * t, h).r;\n\t\tres = min(res, d);\n\t\tt += d * w;\n\t\tif (t > tmax) break;\n\t}\n\t\n\treturn res - bias * k;\n}\n\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float bias, float k, float s)\n{\t\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat res = 1.0;\n\t\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\th += 1.0;\n\t\tfloat d = textureLod(sampler2DShadow(shadowMap, 0), ro + rd * t, h).r;\n\t\tres = min(res, d);\n\t\tt += d", " return fract(sin(seed++) * 43758.5453123); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat rand(vec3 co) { return fract(sin(dot(co.xyz, vec3(12.9898, 4.1414, 4.1414))) * 43758.5453); }\nfloat rand(vec4 co) { return fract(sin(dot(co.xyzw, vec4(12.9898, 4.1414, 4.1414, 4.1414))) * 43758.5453); }\n\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\nfloat hash(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat hash(vec3 n) { return fract(sin(dot(n, vec3(12.9898, 4.1414, 4.1414))) * 43758.5453); }\nfloat hash(vec4 n) { return fract(sin(dot(n, vec4(12.9898, 4.1414, 4.1414, 4.1414))) * 43758.5453); }\n\nfloat noise(float p) { return fract(sin(p) * 43758.5453); }\nfloat noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noise(vec3 p) { return fract(sin(dot(p, vec3(12.9898, 4.1414, 4.1414))) * 43758.5453); }\nfloat noise(vec4 p) { return fract(sin(dot(p, vec4(12.9898, 4.1414, 4.1414, 4.1414))) * 43758.5453); }\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float a = 0.5;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    for (int i = 0; i < 8; i++) {\n        f += a * noise(p);\n        p *= lac", " \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{ \n    return a + b*cos( 6.28318*(c*t+d) ); \n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in", " \n    vec3 q = abs(p);\n    float d = max(q.x - la, q.y - lb);\n    d = max(d, q.z - h);\n    d = max(d, q.x - q.y + ra);\n    d = max(d, q.y - q.x + ra);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float ra2)\n{ \n    vec3 q = abs(p);\n    float d = max(q.x - la, q.y - lb);\n    d = max(d, q.z - h);\n    d = max(d, q.x - q.y + ra);\n    d = max(d, q.y - q.x + ra);\n    d = max(d, q.x - q.y + ra2);\n    d = max(d, q.y - q.x + ra2);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float ra2, float ra3)\n{ \n    vec3 q = abs(p);\n    float d = max(q.x - la, q.y - lb);\n    d = max(d, q.z - h);\n    d = max(d, q.x - q.y + ra);\n    d = max(d, q.y - q.x + ra);\n    d = max(d, q.x - q.y + ra2);\n    d = max(d, q.y - q.x + ra2);\n    d = max(d, q.x - q.y + ra3);\n    d = max(d, q.y - q.x + ra3);\n    return d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float ra2, float ra3, float ra4)\n{ \n    vec3 q = abs(p);\n    float d = max(q.x - la, q.y - lb);\n    d = max(d, q.z - h);\n    d = max(d, q.x - q.y + ra);\n    d = max(d, q.y - q.x + ra);\n    d = max(d, q.x - q.y + ra2);\n    d", " \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 a1 = a + h*ba;\n    vec2 v = normalize(ba);\n    float d = dot( pa, v );\n    float w = band - r;\n    float x = max( 0.0, w - abs(d) );\n    float y = max( 0.0, w - length(pa) );\n    float z = max( 0.0, w - length(ba) );\n    return vec4( x, y, z, d );\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float w ) \n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 a1 = a + h*ba;\n    vec2 v = normalize(ba);\n    float d = dot( pa, v );\n    float x = max( 0.0, w - abs(d) );\n    float y = max( 0.0, w - length(pa) );\n    float z = max( 0.0, w - length(ba) );\n    return vec4( x, y, z, d );\n}\n\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float w, float h ) \n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 a1 = a + h*ba;\n    vec2 v = normalize(ba);\n    float d = dot( pa, v );\n    float x = max( 0.0, w - abs(d) );\n    float y = max( 0.0, w - length(pa) );\n    float z = max( 0.0, w - length(ba) );\n    return vec4( x, y, z, d );\n}\n\nvec4 paSegment( in vec2 p, vec2 a,", "    \n    vec2 q = abs(p) - b + r;\n    float t = dot(q, q);\n    float d = length(p) - r;\n    float h = max(0.0, s - t);\n    return vec4(d, h, t, s);\n}\n\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t )\n{    \n    vec2 q = abs(p) - b + r;\n    float d = length(p) - r;\n    float h = max(0.0, s - dot(q, q));\n    return vec4(d, h, t, s);\n}\n\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u )\n{    \n    vec2 q = abs(p) - b + r;\n    float d = length(p) - r;\n    float h = max(0.0, s - dot(q, q));\n    return vec4(d, h, t, u);\n}\n\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v )\n{    \n    vec2 q = abs(p) - b + r;\n    float d = length(p) - r;\n    float h = max(0.0, s - dot(q, q));\n    return vec4(d, h, t, v);\n}\n\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v, in float w )\n{    \n    vec2 q = abs(p) - b + r;\n    float d = length(p) - r;\n    float h = max(0.0, s - dot(q, q));\n    return vec4(d, h, t, w);\n}\n\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v, in float w, in float x )\n{    \n    vec2 q = abs(p) - b + r;\n    float d = length(p) - r;\n    float h = max(0.0, s -", " \n    vec2 d = abs(p) - b;\n    vec2 s = sign(p);\n    return vec3(dot(d,s), max(dot(d,s),0.0));\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b )\n{ \n    vec3 d = abs(p) - b;\n    return vec3(max(max(d.x,d.y),d.z), length(max(d,0.0)));\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c )\n{ \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - c.z + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec3 d )\n{ \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - c.z + min(max(q.x,max(q.y,q.z)),0.0) - d.z;\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec3 d, in vec3 e )\n{ \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - c.z + min(max(q.x,max(q.y,q.z)),0.0) - d.z - e.z;\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f )\n{ \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - c.z + min(max(q.x,max(q.y,q.z)),0.0) - d.z - e.z - f.z;\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec3 g )\n{ \n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - c.z + min(max(q.x,max(q.y,q.z)),0.0) - d.z - e.z - f.z - g.z;\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b, in vec3 c, in vec", " \n    vec2 q = vec2( length(p), atan(p.y, p.x) );\n    float a = mod(q.x - r, 2.0 * r) - r;\n    float b = mod(q.x + r, 2.0 * r) - r;\n    float c = mod(q.x + 2.0 * r, 2.0 * r) - r;\n    float d = mod(q.x - 2.0 * r, 2.0 * r) - r;\n    float e = mod(q.x + 3.0 * r, 2.0 * r) - r;\n    float f = mod(q.x - 3.0 * r, 2.0 * r) - r;\n    float g = mod(q.x + 4.0 * r, 2.0 * r) - r;\n    float h = mod(q.x - 4.0 * r, 2.0 * r) - r;\n    float i = mod(q.x + 5.0 * r, 2.0 * r) - r;\n    float j = mod(q.x - 5.0 * r, 2.0 * r) - r;\n    float k = mod(q.x + 6.0 * r, 2.0 * r) - r;\n    float l = mod(q.x - 6.0 * r, 2.0 * r) - r;\n    float m = mod(q.x + 7.0 * r, 2.0 * r) - r;\n    float n = mod(q.x - 7.0 * r, 2.0 * r) - r;\n    float o = mod(q.x + 8.0 * r, 2.0 * r) - r;\n    float p = mod(q.x - 8.0 * r, 2.0 * r) - r;\n    float q = mod(q.x + 9.0 * r, 2.0 * r) - r;\n    float r = mod(q.x - 9.0 * r, 2.0 * r) - r;\n    float s = mod(q.x + 10.0 * r, 2.0 * r) - r;\n    float t = mod(q.x - 10.0 * r, 2.0 * r) - r;\n    float", " \n    float d = 1e10;\n    for( int i = 0; i < 5; i++ ) \n    { \n        float a = atan( p.x - verts[i].x, p.y - verts[i].y );\n        float d2 = distance( p, vec2( cos(a)*r, sin(a)*r ) + verts[i] );\n        d = min( d, d2 );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, in float r ) \n{ \n    return sdPoly( p, vec2( 0.0, 0.0 ), r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a ) \n{ \n    return sdPoly( p, vec2( cos(a)*r, sin(a)*r ), r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a, in float b ) \n{ \n    return sdPoly( p, vec2( cos(a)*r, sin(a)*r ), vec2( cos(b)*r, sin(b)*r ), r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a, in float b, in float c ) \n{ \n    return sdPoly( p, vec2( cos(a)*r, sin(a)*r ), vec2( cos(b)*r, sin(b)*r ), vec2( cos(c)*r, sin(c)*r ), r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a, in float b, in float c, in float d ) \n{ \n    return sdPoly( p, vec2( cos(a)*r, sin(a)*r ), vec2( cos(b)*r, sin(b)*r ), vec2( cos(c)*r, sin(c)*r ), vec2( cos(d)*r, sin(d)*r ), r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a, in float b, in float c, in float d, in float e ) \n{ \n    return sdPoly( p, vec2( cos(a)*r, sin(a)*r ), vec2( cos(b)*r, sin(b)*r ), vec2( cos(c)*r, sin(c)*r ), vec2( cos(d)*r, sin(d)*r ), vec2( cos(e)*r", " \n    vec2 d = p - verts[0];\n    float a = atan(d.y, d.x) + 3.1415926;\n    float r2 = length(d);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, s, -s, c);\n    d = abs(m * d);\n    float x = d.x - r;\n    float y = d.y - r;\n    float z = length(d) - r;\n    float w = 0.0;\n    if (z < r) \n    {\n        w = 1.0;\n    }\n    else if (z < r + band) \n    {\n        w = 1.0 - (z - r) / band;\n    }\n    return vec4(x, y, z, w);\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{ \n    vec2 d = p - verts[0];\n    float a = atan(d.y, d.x) + 3.1415926;\n    float r2 = length(d);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, s, -s, c);\n    d = abs(m * d);\n    float x = d.x - r;\n    float y = d.y - r;\n    float z = length(d) - r;\n    float w = 0.0;\n    if (z < r) \n    {\n        w = 1.0;\n    }\n    else if (z < r + band) \n    {\n        w = 1.0 - (z - r) / band;\n    }\n    return vec4(x, y, z, w);\n}\n\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{ \n    vec2 d = p - verts[0];\n    float a = atan(d.y, d.x) + 3.1415926;\n    float r2 = length(d);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, s, -s, c);\n    d = abs(m * d);\n    float x = d.x - r;\n    float y = d.y - r;\n    float z = length(d) - r;\n    float w", "\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn a + ba*h;\n}\n\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 sdgPlane( in vec3 p, in vec3 n )\n{\n\treturn dot(p,n);\n}\n\nvec3 sdgSphere( in vec3 p, in float s )\n{\n\treturn length(p)-s;\n}\n\nvec3 sdgCylinder( in vec3 p, in vec2 h, in float r )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 sdgTorus( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus2( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus3( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus4( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus5( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus6( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus7( in vec3 p, in vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec3 sdgTorus8( in vec", " \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y);\n}\n\nvec3 sdgHexagon( in vec2 p, in float r, in float a ) \n{ \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y) - vec2(0.0,r*sin(a));\n}\n\nvec3 sdgHexagon( in vec2 p, in float r, in float a, in float b ) \n{ \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y) - vec2(0.0,r*sin(a)) - vec2(0.0,r*sin(b));\n}\n\nvec3 sdgHexagon( in vec2 p, in float r, in float a, in float b, in float c ) \n{ \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y) - vec2(0.0,r*sin(a)) - vec2(0.0,r*sin(b)) - vec2(0.0,r*sin(c));\n}\n\nvec3 sdgHexagon( in vec2 p, in float r, in float a, in float b, in float c, in float d ) \n{ \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y) - vec2(0.0,r*sin(a)) - vec2(0.0,r*sin(b)) - vec2(0.0,r*sin(c)) - vec2(0.0,r*sin(d));\n}\n\nvec3 sdgHexagon( in vec2 p, in float r, in float a, in float b, in float c, in float d, in float e ) \n{ \n    vec2 q = abs(p) - vec2(r,r);\n    return sign(p)*min(vec2(dot(q,q),q.x),q.y) - vec2(0.0,r*sin(a)) - vec2(0.0,r*sin(b)) - vec2(0.0,r*sin(c)) - vec2(0.0,r*sin(d)) - vec2(0", " \n    vec3 n = normalize(cross(X[0], X[1]));\n    vec3 v = normalize(cross(n, X[2]));\n    vec3 w = normalize(cross(v, n));\n    vec3 q = p - X[3];\n    float d = dot(q, n);\n    float e = dot(q, v);\n    float f = dot(q, w);\n    float g = dot(X[0], n);\n    float h = dot(X[0], v);\n    float i = dot(X[0], w);\n    float j = dot(X[1], n);\n    float k = dot(X[1], v);\n    float l = dot(X[1], w);\n    float m = dot(X[2], n);\n    float n = dot(X[2], v);\n    float o = dot(X[2], w);\n    float p = dot(X[3], n);\n    float q = dot(X[3], v);\n    float r = dot(X[3], w);\n    float s = dot(X[0], X[1]);\n    float t = dot(X[0], X[2]);\n    float u = dot(X[1], X[2]);\n    float v = dot(X[0], X[3]);\n    float w = dot(X[1], X[3]);\n    float x = dot(X[2], X[3]);\n    float y = dot(X[3], X[3]);\n    float a = g * h * i + j * k * l + m * n * o;\n    float b = g * h * j + j * k * m + m * n * g;\n    float c = g * h * m + j * k * o + m * n * l;\n    float d = g * h * o + j * k * l + m * n * i;\n    float e = g * i * j + k * l * m + n * o * g;\n    float f = g * i * m + k * l * o + n * o * j;\n    float g = g * i * o + k * l * m + n * o * j;\n    float h = g * i * o + k * l * m + n * o * j;\n    float i = g * j * m + k * l * o + n * o * i;\n    float j = g * j * o +", " return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, float b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec2 b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec4 b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, mat2 b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, mat3 b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, mat4 b) { return a / (b + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, sampler2D b) { return a / (texture2D(b, vec2(0.0)).rgb + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, samplerCube b) { return a / (textureCube(b, vec3(0.0)).rgb + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, sampler2DShadow b) { return a / (texture2DShadow(b, vec3(0.0)).rgb + 0.0001); }\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, samplerCubeShadow b) { return a /", "\t\n\treturn vec3(\n\t\tp.x * cos(a) + p.z * sin(a),\n\t\tp.y,\n\t\t-p.x * sin(a) + p.z * cos(a)\n\t);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\t\n\treturn vec3(\n\t\tp.x,\n\t\tp.y * cos(a) + p.z * sin(a),\n\t\t-p.y * sin(a) + p.z * cos(a)\n\t);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\t\n\treturn vec3(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a),\n\t\tp.z\n\t);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c)\n{\n\treturn RotateZ(RotateY(RotateX(p, a), b), c);\n}\n\nvec3 Rotate(vec3 p, float a)\n{\n\treturn Rotate(p, a, a, a);\n}\n\nvec3 Rotate(vec3 p, float a, float b)\n{\n\treturn Rotate(p, a, b, a);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p, d);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d, float e)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p, d, e);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d, float e, float f)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p, d, e, f);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d, float e, float f, float g)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p, d, e, f, g);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d, float e, float f, float g, float h)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p, d, e, f, g, h);\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c, float d, float e, float f, float g, float h, float i)\n{\n\treturn Rotate(p, a, b, c) * Rotate(p,", "\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\t\n\treturn 1.0 - pow(x/R, 3.0);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x,", "\t\n\treturn 1.0f / (1.0f + e * R);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// x: point\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float3 x)\n{\n\treturn 1.0f / (1.0f + e * R * (1.0f - dot(x, x)));\n}\n\n// Computes the global lipschitz bound of the falloff", "\t\n\treturn (a - b) / (R * e);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t)\n{\t\n\treturn (a - b) / (R * e * t);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t, float s)\n{\t\n\treturn (a - b) / (R * e * t * s);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t, float s, float u)\n{\t\n\treturn (a - b) / (R * e * t * s * u);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t, float s, float u, float v)\n{\t\n\treturn (a - b) / (R * e * t * s * u * v);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t, float s, float u, float v, float w)\n{\t\n\treturn (a - b) / (R * e * t * s * u * v * w);\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float t, float s, float u, float v,", " \n    return length(p - c) - R - e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Point(vec3 p, vec3 c, float R, float e)\n{ \n    return length(p - c) - R - e;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{ \n    return length(p - c) - R - e;\n}\n\n// Plane primitive field function\n// p: world point\n// n: normal\n// d: distance\n// e: energy\nfloat Plane(vec3 p, vec3 n, float d, float e)\n{ \n    return dot(p, n) - d - e;\n}\n\n// Box primitive field function\n// p: world point\n// b: box\n// e: energy\nfloat Box(vec3 p, vec3 b, float e)\n{ \n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - e;\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// h: height\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float h, float e)\n{ \n    vec2 d = abs(vec2(length(p.xz) - R, p.y)) - vec2(h, e);\n    return max(d.x, d.y);\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// h: height\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float h, float e)\n{ \n    vec2 d = abs(vec2(length(p.xz) - R, p.y)) - vec2(h, e);\n    return max(d.x, d.y) - d.x;\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// r: ring radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float r, float e)\n{ \n    vec2 q = vec2", "\t\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tfloat d = dot(v, normalize(c - a));\n\tfloat t = d / l;\n\tvec3 p = a + t * v;\n\tfloat r = length(p - c);\n\tfloat k = e / (R * r);\n\treturn k;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t)\n{\t\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tfloat d = dot(v, normalize(c - a));\n\tfloat t = d / l;\n\tvec3 p = a + t * v;\n\tfloat r = length(p - c);\n\tfloat k = e / (R * r);\n\treturn k;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t, float t2)\n{\t\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tfloat d = dot(v, normalize(c - a));\n\tfloat t = d / l;\n\tvec3 p = a + t * v;\n\tfloat r = length(p - c);\n\tfloat k = e / (R * r);\n\treturn k;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, float t, float t2, float t3)\n{\t\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tfloat d = dot(v, normalize(c - a));\n\tfloat t = d / l;\n\tvec3 p = a + t * v;\n\tfloat r = length(p - c);\n\tfloat k = e / (R * r);\n\treturn k;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a", "\t\n\tfloat d = 0.0;\n\t\n\t// Sphere\n\td = length(p) - 1.0;\n\t\n\t// Cube\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\t\n\t// Torus\n\td = length(p - vec3(0.0, 0.0, 0.5)) - 0.5;\n\td = min(d, length(p - vec3(0.0, 0.0, -0.5)) - 0.5);\n\t\n\t// Cylinder\n\td = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n\td = min(d, length(p - vec3(0.0, 0.0, -0.5)) - 0.5);\n\t\n\t// Cone\n\td = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n\td = min(d, length(p - vec3(0.0, 0.0, -0.5)) - 0.5);\n\t\n\t// Plane\n\td = dot(p, vec3(0.0, 1.0, 0.0));\n\t\n\t// Sphere\n\td = min(d, length(p - vec3(0.0, 0.0, 0.0)) - 0.5);\n\t\n\t// Cube\n\td = min(d, abs(p.x) - 0.5);\n\td = min(d, abs(p.y) - 0.5);\n\td = min(d, abs(p.z) - 0.5);\n\t\n\t// Torus\n\td = min(d, length(p - vec3(0.0, 0.0, 0.5)) - 0.5);\n\td = min(d, length(p - vec3(0.0, 0.0, -0.5)) - 0.5);\n\t\n\t// Cylinder\n\td = min(d, length(p - vec3(0.0, 0.0, 0.0)) - 0.5);\n\td = min(d, length(p - vec3(0.0, 0.0, -0.5)) - ", "\t\n\tvec3 ab = b - a;\n\tfloat k = dot(ab, ab);\n\treturn k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\t\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tfloat k = dot(ab, ab) - 2.0 * dot(ab, ac) + dot(ac, ac);\n\treturn k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\t\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ad = d - a;\n\tfloat k = dot(ab, ab) - 2.0 * dot(ab, ac) + dot(ac, ac) - 2.0 * dot(ab, ad) + dot(ad, ad);\n\treturn k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\t\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ad = d - a;\n\tvec3 ae = e - a;\n\tfloat k = dot(ab, ab) - 2.0 * dot(ab, ac) + dot(ac, ac) - 2.0 * dot(ab, ad) + dot(ad, ad) - 2.0 * dot(ab, ae) + dot(ae, ae);\n\treturn k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\t\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ad = d - a;\n\tvec3 ae = e - a;\n\tvec3 af = f - a;\n\tfloat k = dot(ab, ab) - 2.0 * dot(ab, ac) + dot(ac, ac) - 2.0 * dot(ab, ad) + dot(ad, ad) - 2.0 * dot(ab, ae) + dot(ae, ae) - 2.0 * dot(ab, af) + dot(af, af);\n\treturn k;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g)\n{\t\n\tvec3 ab = b - a;\n\tvec3 ac = c", " \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 e3 = vec3(0.0, 0.0, 1.0);\n    vec3 n;\n    n = normalize(cross(dFdx(p), dFdy(p)));\n    return n;\n}\n\n// Tangent evaluation\nvec3 ObjectTangent(in vec3 p )\n{ \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 e3 = vec3(0.0, 0.0, 1.0);\n    vec3 t;\n    t = normalize(cross(dFdy(p), dFdx(p)));\n    return t;\n}\n\n// Bitangent evaluation\nvec3 ObjectBitangent(in vec3 p )\n{ \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 e3 = vec3(0.0, 0.0, 1.0);\n    vec3 b;\n    b = normalize(cross(dFdx(p), dFdy(p)));\n    return b;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in vec3 t, in vec3 b )\n{ \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 e3 = vec3(0.0, 0.0, 1.0);\n    vec3 n;\n    n = normalize(cross(dFdx(p), dFdy(p)));\n    return n;\n}\n\n// Tangent evaluation\nvec3 ObjectTangent(in vec3 p, in vec3 n, in vec3 t, in vec3 b )\n{ \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0", "\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tfloat d = length(p);\n\t\tif (d < 0.1)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn -1.0;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tfloat d = length(p);\n\t\tif (d < 0.1)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn -1.0;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tfloat d = length(p);\n\t\tif (d < 0.1)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn -1.0;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tfloat d = length(p);\n\t\tif (d", "\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\t\n\tvec3 p = o;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + u * t;\n\t\td = Distance(p);\n\t\tt += d;\n\t\ts++;\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\treturn t;\n\t\t}\n\t}\n\t\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\t\n\tvec3 p = o;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + u * t;\n\t\td = Distance(p);\n\t\tt += d;\n\t\ts++;\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\treturn t;\n\t\t}\n\t}\n\t\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\t\n\tvec3 p = o;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + u * t;\n\t\td = Distance(p);\n\t\tt += d;\n\t\ts++;\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\treturn t;\n\t\t}\n\t}\n\t\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\t\n\th = false;\n\ts = 0;\n\t\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\t\n\tvec3 p = o;\n\t\n", "\t\n\tvec3 color = vec3(0.0);\n\t\n\t// Background\n\tcolor = vec3(0.0, 0.0, 0.0);\n\t\n\treturn color;\n}\n\nvec3 Diffuse(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Diffuse\n\tcolor = lightColor * lightIntensity * max(dot(normal, lightDir), 0.0);\n\t\n\treturn color;\n}\n\nvec3 Specular(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity, float shininess)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Specular\n\tvec3 reflectDir = reflect(-lightDir, normal);\n\tcolor = lightColor * lightIntensity * pow(max(dot(reflectDir, rd), 0.0), shininess);\n\t\n\treturn color;\n}\n\nvec3 Ambient(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Ambient\n\tcolor = lightColor * lightIntensity;\n\t\n\treturn color;\n}\n\nvec3 Shadow(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity, float shadowIntensity)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Shadow\n\tcolor = lightColor * lightIntensity * (1.0 - shadowIntensity);\n\t\n\treturn color;\n}\n\nvec3 Reflection(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Reflection\n\tvec3 reflectDir = reflect(-rd, normal);\n\tcolor = lightColor * lightIntensity * max(dot(reflectDir, lightDir), 0.0);\n\t\n\treturn color;\n}\n\nvec3 Refraction(vec3 rd, vec3 pos, vec3 normal, vec3 lightDir, vec3 lightColor, float lightIntensity)\n{\n\tvec3 color = vec3(0.0);\n\t\n\t// Refraction\n\tvec3 refractDir = refract(-rd, normal, 1.0 / 1.5);\n\tcolor = lightColor * lightIntensity * max(dot(refractDir, lightDir), 0", " \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h)\n{ \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h2 ) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float s)\n{ \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h2 ) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float s, float t)\n{ \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h2 ) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float s, float t, float u)\n{ \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h2 ) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float s, float t, float u, float v)\n{ \n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1", " \n    vec3 r = abs( ro - rd * rad ) - rad;\n    vec3 p = abs( ro + rd * rad ) - rad;\n    vec2 m = min( dot( r, r ), dot( p, p ) );\n    return m;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{ \n    vec3 r = abs( ro - rd * rad ) - rad;\n    vec3 p = abs( ro + rd * rad ) - rad;\n    return min( dot( r, r ), dot( p, p ) );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 n ) \n{ \n    vec3 r = abs( ro - rd * rad ) - rad;\n    vec3 p = abs( ro + rd * rad ) - rad;\n    vec3 m = min( dot( r, r ), dot( p, p ) );\n    n = step( m, 0.0 ) * ( -sign( ro ) * rd );\n    return m;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 n ) \n{ \n    vec3 r = abs( ro - rd * rad ) - rad;\n    vec3 p = abs( ro + rd * rad ) - rad;\n    float m = min( dot( r, r ), dot( p, p ) );\n    n = step( m, 0.0 ) * ( -sign( ro ) * rd );\n    return m;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 n, out vec3 p ) \n{ \n    vec3 r = abs( ro - rd * rad ) - rad;\n    vec3 p = abs( ro + rd * rad ) - rad;\n    vec3 m = min( dot( r, r ), dot( p, p ) );\n    n = step( m, 0.0 ) *", " return coord * 2.0 - 1.0; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord) { return coord * 2.0 - 1.0; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height) { return coord * 2.0 / vec2(width, height) - 1.0; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y) { return (coord - vec2(x, y)) * 2.0 / vec2(width, height) - 1.0; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y, float w, float h) { return (coord - vec2(x, y)) * 2.0 / vec2(w, h) - 1.0; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y, float w, float h, float u, float v) { return (coord - vec2(x, y)) * 2.0 / vec2(w, h) - vec2(u, v); }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y, float w, float h, float u, float v, float s) { return (coord - vec2(x, y)) * 2.0 / vec2(w, h) - vec2(u, v) * s; }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y, float w, float h, float u, float v, float s, float t) { return (coord - vec2(x, y)) * 2.0 / vec2(w, h) - vec2(u, v) * vec2(s, t); }\n\n// normalized texture coordinate\nvec2 tex_coord(vec2 coord, float width, float height, float x, float y, float w, float h, float u, float v, float s, float t, float r) { return (coord - vec2(x, y)) * 2.0 / vec2(w, h) - vec2(u, v) * vec2(s, t) * r; }\n\n// normalized texture", "\t\n\tvec2 a = p - q;\n\tvec2 b = p - q.yx;\n\tvec2 c = p - q.yx;\n\t\n\tfloat d = length( a );\n\tfloat e = length( b );\n\tfloat f = length( c );\n\t\n\tfloat g = ( d + e + f ) / 2.0;\n\t\n\tfloat h = sqrt( g * ( g - d ) * ( g - e ) * ( g - f ) );\n\t\n\treturn vec3( h, a.x * h, b.x * h );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r )\n{\t\n\tvec2 a = p - q;\n\tvec2 b = p - r;\n\tvec2 c = p - r.yx;\n\t\n\tfloat d = length( a );\n\tfloat e = length( b );\n\tfloat f = length( c );\n\t\n\tfloat g = ( d + e + f ) / 2.0;\n\t\n\tfloat h = sqrt( g * ( g - d ) * ( g - e ) * ( g - f ) );\n\t\n\treturn vec3( h, a.x * h, b.x * h );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s )\n{\t\n\tvec2 a = p - q;\n\tvec2 b = p - r;\n\tvec2 c = p - s;\n\t\n\tfloat d = length( a );\n\tfloat e = length( b );\n\tfloat f = length( c );\n\t\n\tfloat g = ( d + e + f ) / 2.0;\n\t\n\tfloat h = sqrt( g * ( g - d ) * ( g - e ) * ( g - f ) );\n\t\n\treturn vec3( h, a.x * h, b.x * h );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s, in vec2 t )\n{\t\n\tvec2 a = p - q;\n\tvec2 b = p - r;\n\tvec2 c = p - s;\n\tvec2 d = p - t;\n\t\n\tfloat d = length( a );\n\tfloat e = length( b );\n\tfloat f = length( c );\n\tfloat g = length( d );\n\t\n\tfloat h = ( d + e + f + g ) / 2.0;\n\t\n\tfloat i = sqrt( h *", "\t\n\tfloat a = 0.5 * (1.0 + sqrt(5.0));\n\tfloat b = 0.5 * (1.0 - sqrt(5.0));\n\tvec2 q = p;\n\tq.x = (a * p.x + b * p.y) / (a + b);\n\tq.y = (a * p.y + b * p.x) / (a + b);\n\tfloat d1 = length(q - vec2(0.0, 0.0));\n\tfloat d2 = length(q - vec2(1.0, 0.0));\n\tfloat d3 = length(q - vec2(0.5, 0.5 * sqrt(3.0)));\n\tfloat d4 = length(q - vec2(0.5, -0.5 * sqrt(3.0)));\n\tfloat d5 = length(q - vec2(0.5 * sqrt(3.0), 0.5));\n\tfloat d6 = length(q - vec2(0.5 * sqrt(3.0), -0.5));\n\tfloat d7 = length(q - vec2(0.5 * sqrt(3.0) * 2.0, 0.0));\n\tfloat d8 = length(q - vec2(0.5 * sqrt(3.0) * 2.0, 0.5 * sqrt(3.0)));\n\tfloat d9 = length(q - vec2(0.5 * sqrt(3.0) * 2.0, -0.5 * sqrt(3.0)));\n\tfloat d10 = length(q - vec2(0.5 * sqrt(3.0) * 3.0, 0.0));\n\tfloat d11 = length(q - vec2(0.5 * sqrt(3.0) * 3.0, 0.5 * sqrt(3.0)));\n\tfloat d12 = length(q - vec2(0.5 * sqrt(3.0) * 3.0, -0.5 * sqrt(3.0)));\n\tfloat d13 = length(q - vec2(0.5 * sqrt(3.0) * 4.0, 0.0));\n\tfloat d14 = length(q - vec2(0.5 * sqrt(3.0) * 4.0, 0.5 * sqrt(3.0)));\n\tfloat d15 = length(q - vec2(0", "\t\n\tvec2 q = p - c;\n\tfloat d = length(q);\n\tfloat h = clamp( (r - d) / length(c), 0.0, 1.0 );\n\treturn normalize( q ) * h + c * (1.0 - h);\n}\n\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a )\n{\n\tvec2 q = p - c;\n\tfloat d = length(q);\n\tfloat h = clamp( (r - d) / length(c), 0.0, 1.0 );\n\treturn normalize( q ) * h + c * (1.0 - h) + vec2( sin(a), cos(a) ) * (1.0 - h);\n}\n\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a, in float b )\n{\n\tvec2 q = p - c;\n\tfloat d = length(q);\n\tfloat h = clamp( (r - d) / length(c), 0.0, 1.0 );\n\treturn normalize( q ) * h + c * (1.0 - h) + vec2( sin(a), cos(a) ) * (1.0 - h) + vec2( sin(b), cos(b) ) * (1.0 - h);\n}\n\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c )\n{\n\tvec2 q = p - c;\n\tfloat d = length(q);\n\tfloat h = clamp( (r - d) / length(c), 0.0, 1.0 );\n\treturn normalize( q ) * h + c * (1.0 - h) + vec2( sin(a), cos(a) ) * (1.0 - h) + vec2( sin(b), cos(b) ) * (1.0 - h) + vec2( sin(c), cos(c) ) * (1.0 - h);\n}\n\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d )\n{\n\tvec2 q = p - c;\n\tfloat d = length(q);\n\tfloat h = clamp( (r - d) / length(c), 0.0, 1.0 );\n\treturn normalize( q ) * h + c * (", "\t\n\tvec2 d = v[2] - v[0];\n\tfloat a = cross( v[1] - v[0], d ) / length( d );\n\tfloat b = cross( p - v[0], d ) / length( d );\n\tfloat c = 1.0 - a - b;\n\treturn vec3( a, b, c );\n}\n\nvec3 sdgTriangle( in vec2 p, in vec3 v[3] )\n{\t\n\tvec3 d = v[2] - v[0];\n\tfloat a = cross( v[1] - v[0], d ) / length( d );\n\tfloat b = cross( p - v[0], d ) / length( d );\n\tfloat c = 1.0 - a - b;\n\treturn vec3( a, b, c );\n}\n\nvec3 sdgTriangle( in vec3 p, in vec3 v[3] )\n{\t\n\tvec3 d = v[2] - v[0];\n\tfloat a = cross( v[1] - v[0], d ) / length( d );\n\tfloat b = cross( p - v[0], d ) / length( d );\n\tfloat c = 1.0 - a - b;\n\treturn vec3( a, b, c );\n}\n\nvec3 sdgTriangle( in vec4 p, in vec4 v[3] )\n{\t\n\tvec4 d = v[2] - v[0];\n\tfloat a = cross( v[1] - v[0], d ) / length( d );\n\tfloat b = cross( p - v[0], d ) / length( d );\n\tfloat c = 1.0 - a - b;\n\treturn vec3( a, b, c );\n}\n\nvec3 sdgTriangle( in vec3 p, in vec3 v[3], in vec3 n )\n{\t\n\tvec3 d = v[2] - v[0];\n\tfloat a = cross( v[1] - v[0], d ) / length( d );\n\tfloat b = cross( p - v[0], d ) / length( d );\n\tfloat c = 1.0 - a - b;\n\treturn vec3( a, b, c ) * n;\n}\n\nvec3 sdgTriangle( in vec4 p, in vec4 v[3], in vec4 n )\n{\t\n\tvec4 d = v[2] - v[0];\n\tfloat a = cross( v[", "\t\n\tvec2 q = p - ra * sca;\n\tfloat d = length(q);\n\tfloat a = atan(q.y, q.x) - scb.x * PI;\n\tfloat b = atan(q.y, q.x) + scb.x * PI;\n\tfloat c = atan(q.y, q.x) - scb.y * PI;\n\tfloat d1 = (a < b)? a : b;\n\tfloat d2 = (c < b)? c : b;\n\tfloat d3 = (d1 < d2)? d1 : d2;\n\treturn vec3(d, d3, d2);\n}\n\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r )\n{\n\tvec2 q = p - ra * sca;\n\tfloat d = length(q);\n\tfloat a = atan(q.y, q.x) - scb.x * PI;\n\tfloat b = atan(q.y, q.x) + scb.x * PI;\n\tfloat c = atan(q.y, q.x) - scb.y * PI;\n\tfloat d1 = (a < b)? a : b;\n\tfloat d2 = (c < b)? c : b;\n\tfloat d3 = (d1 < d2)? d1 : d2;\n\treturn vec3(d, d3, d2);\n}\n\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r, in float ra2, in float rb2 )\n{\n\tvec2 q = p - ra * sca;\n\tfloat d = length(q);\n\tfloat a = atan(q.y, q.x) - scb.x * PI;\n\tfloat b = atan(q.y, q.x) + scb.x * PI;\n\tfloat c = atan(q.y, q.x) - scb.y * PI;\n\tfloat d1 = (a < b)? a : b;\n\tfloat d2 = (c < b)? c : b;\n\tfloat d3 = (d1 < d2)? d1 : d2;\n\treturn vec3(d, d3, d2);\n}\n\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r, in float ra2, in float rb2, in float ra3, in float rb3 )\n{\n\tvec", " return atan( b.y, b.x ) - atan( a.y, a.x ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c ) { return cro( b, c ) - cro( a, b ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d ) { return cro( b, c, d ) - cro( a, b, c ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e ) { return cro( b, c, d, e ) - cro( a, b, c, d ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f ) { return cro( b, c, d, e, f ) - cro( a, b, c, d, e ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g ) { return cro( b, c, d, e, f, g ) - cro( a, b, c, d, e, f ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h ) { return cro( b, c, d, e, f, g, h ) - cro( a, b, c, d, e, f, g ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i ) { return cro( b, c, d, e, f, g, h, i ) - cro( a, b, c, d, e, f, g, h ); }\nfloat cro( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i, in vec2 j ) { return cro( b, c, d, e, f", "\t\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0));\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0)) + a;\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a, in float b )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0)) + a + b;\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a, in float b, in float c )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0)) + a + b + c;\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a, in float b, in float c, in float d )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0)) + a + b + c + d;\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a, in float b, in float c, in float d, in float e )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.0 );\n\treturn ab.x*q.x + ab.y*sqrt(1.0-pow(q.y,2.0)) + a + b + c + d + e;\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float a, in float b, in float c, in float d, in float e, in float f )\n{\n\tvec2 q = vec2( dot(p,ab), dot(p,p) - 1.", " \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus2( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus3( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus4( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus5( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus6( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus7( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus8( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus9( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus10( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus11( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus12( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return length(q)-rb;\n}\n\nvec4 sdgTorus13( vec3 p, float ra,", "\t\n\tvec3 ab = b - a;\n\tfloat t = dot( p - a, ab ) / dot( ab, ab );\n\tt = clamp( t, 0.0, 1.0 );\n\treturn vec4( a + ab * t, r );\n}\n\nvec4 sdgBox( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs( p ) - b;\n\treturn vec4( length( max( q, 0.0 ) ) - r, dot( q, vec3( 1.0 ) ) );\n}\n\nvec4 sdgCylinder( vec3 p, vec3 b, float r )\n{\n\tvec3 q = abs( p ) - b;\n\treturn vec4( length( max( q, 0.0 ) ) - r, dot( q, vec3( 1.0 ) ) );\n}\n\nvec4 sdgSphere( vec3 p, vec3 b, float r )\n{\n\treturn vec4( length( p - b ) - r, dot( p, p ) - r * r );\n}\n\nvec4 sdgTorus( vec3 p, vec3 b, float r, float R )\n{\n\tvec2 q = vec2( length( p.xz ) - R, p.y );\n\treturn vec4( length( q ) - r, dot( q, q ) - r * r );\n}\n\nvec4 sdgCone( vec3 p, vec3 b, float r, float h )\n{\n\tvec3 q = abs( p ) - b;\n\tfloat d = length( max( q, 0.0 ) ) - r;\n\tfloat h2 = h * h;\n\tfloat qz = q.z;\n\tfloat qy = q.y;\n\tfloat qy2 = qy * qy;\n\tfloat qz2 = qz * qz;\n\tfloat qy2z2 = qy2 + qz2;\n\tfloat qy2z2h2 = qy2z2 - h2;\n\tfloat qy2z2h2s = sqrt( qy2z2h2 );\n\tfloat qy2z2h2s2 = qy2z2h2s * qy2z2h2s;\n\tfloat qy2z2h2s2h2 = qy2z2h2s2 - h2;\n\tfloat qy2z2h2s2h2s = sqrt( qy2z", "\t\n\tvec2 q = p - vec2( wi, he ) * vec2( 0.5, 0.5 );\n\tfloat d = length( q );\n\tfloat a = atan( q.y, q.x );\n\tfloat b = atan( q.y, q.x - sk );\n\tfloat c = atan( q.y, q.x + sk );\n\tfloat d1 = abs( a - b );\n\tfloat d2 = abs( a - c );\n\tfloat d3 = abs( b - c );\n\tfloat d4 = abs( a - 0.5 * PI );\n\tfloat d5 = abs( b - 0.5 * PI );\n\tfloat d6 = abs( c - 0.5 * PI );\n\tfloat d7 = abs( d1 - 0.5 * PI );\n\tfloat d8 = abs( d2 - 0.5 * PI );\n\tfloat d9 = abs( d3 - 0.5 * PI );\n\tfloat d10 = abs( d4 - 0.5 * PI );\n\tfloat d11 = abs( d5 - 0.5 * PI );\n\tfloat d12 = abs( d6 - 0.5 * PI );\n\tfloat d13 = abs( d7 - 0.5 * PI );\n\tfloat d14 = abs( d8 - 0.5 * PI );\n\tfloat d15 = abs( d9 - 0.5 * PI );\n\tfloat d16 = abs( d10 - 0.5 * PI );\n\tfloat d17 = abs( d11 - 0.5 * PI );\n\tfloat d18 = abs( d12 - 0.5 * PI );\n\tfloat d19 = abs( d13 - 0.5 * PI );\n\tfloat d20 = abs( d14 - 0.5 * PI );\n\tfloat d21 = abs( d15 - 0.5 * PI );\n\tfloat d22 = abs( d16 - 0.5 * PI );\n\tfloat d23 = abs( d17 - 0.5 * PI );\n\tfloat d24 = abs( d18 - 0.5 * PI );\n\tfloat d25 = abs( d19 - 0.5 * PI );\n\tfloat d26 = abs( d20 - 0.5 * PI );\n\tfloat d27 = abs( d21 - 0.5 * PI );\n\tfloat d28 = abs( d22 - 0.5 * PI );\n\tfloat d29 = abs( d23 - 0.5", "\t\n\tvec2 p1 = vec2( 0.0, 0.0 );\n\tvec2 p2 = vec2( wi, 0.0 );\n\tvec2 p3 = vec2( wi, he );\n\tvec2 p4 = vec2( 0.0, he );\n\t\n\tvec2 a = p - p1;\n\tvec2 b = p2 - p1;\n\tvec2 c = p3 - p1;\n\tvec2 d = p4 - p1;\n\t\n\tvec2 ab = b - a;\n\tvec2 cd = d - c;\n\t\n\tvec2 abcd = ab + cd;\n\t\n\tvec2 abcd_norm = normalize( abcd );\n\t\n\tvec2 abcd_sk = abcd_norm * sk;\n\t\n\tvec2 abcd_sk_norm = normalize( abcd_sk );\n\t\n\tvec2 abcd_sk_norm_ab = abcd_sk_norm - ab;\n\t\n\tvec2 abcd_sk_norm_cd = abcd_sk_norm - cd;\n\t\n\tfloat abcd_sk_norm_ab_dot_ab = dot( abcd_sk_norm_ab, ab );\n\tfloat abcd_sk_norm_cd_dot_cd = dot( abcd_sk_norm_cd, cd );\n\t\n\tfloat abcd_sk_norm_ab_dot_cd = dot( abcd_sk_norm_ab, cd );\n\tfloat abcd_sk_norm_cd_dot_ab = dot( abcd_sk_norm_cd, ab );\n\t\n\tfloat abcd_sk_norm_ab_dot_ab_cd = abcd_sk_norm_ab_dot_ab + abcd_sk_norm_ab_dot_cd;\n\tfloat abcd_sk_norm_cd_dot_ab_cd = abcd_sk_norm_cd_dot_ab + abcd_sk_norm_cd_dot_cd;\n\t\n\tfloat abcd_sk_norm_ab_dot_ab_cd_sign = sign( abcd_sk_norm_ab_dot_ab_cd );\n\tfloat abcd_sk_norm_cd_dot_ab_cd_sign = sign( abcd_sk_norm_cd_dot_ab_cd );\n\t\n\tfloat abcd_sk_norm_ab_dot_ab_cd_abs = abs( abcd_sk_norm_ab_dot_ab_cd );\n\tfloat abcd_sk_norm_cd_dot_ab_cd_abs = abs( abcd_sk_norm_cd_dot_ab_cd );\n\t\n\tfloat abcd_sk_norm_ab_dot_ab_cd_abs_sign = sign( abcd_sk_norm_ab_dot_ab_cd_abs );\n\tfloat abcd_sk_norm_cd_dot_ab_cd_abs_sign = sign( abcd_sk_norm_cd_dot_ab_cd_abs );\n\t\n\tfloat abcd_sk_norm_ab_dot_ab_cd_abs_sign_abcd_sk_norm_ab_dot_ab_cd = abcd_sk_norm_ab_dot_ab_cd_abs_sign * abcd_sk_norm_ab_dot_ab_cd;\n\tfloat ab", " return p * c; }\nfloat opRep2D( float p, float c )\n\t{ return p * c; }\nfloat opRep3D( float p, float c )\n\t{ return p * c; }\nfloat opRep4D( float p, float c )\n\t{ return p * c; }\nfloat opRep5D( float p, float c )\n\t{ return p * c; }\nfloat opRep6D( float p, float c )\n\t{ return p * c; }\nfloat opRep7D( float p, float c )\n\t{ return p * c; }\nfloat opRep8D( float p, float c )\n\t{ return p * c; }\nfloat opRep9D( float p, float c )\n\t{ return p * c; }\nfloat opRep10D( float p, float c )\n\t{ return p * c; }\nfloat opRep11D( float p, float c )\n\t{ return p * c; }\nfloat opRep12D( float p, float c )\n\t{ return p * c; }\nfloat opRep13D( float p, float c )\n\t{ return p * c; }\nfloat opRep14D( float p, float c )\n\t{ return p * c; }\nfloat opRep15D( float p, float c )\n\t{ return p * c; }\nfloat opRep16D( float p, float c )\n\t{ return p * c; }\nfloat opRep17D( float p, float c )\n\t{ return p * c; }\nfloat opRep18D( float p, float c )\n\t{ return p * c; }\nfloat opRep19D( float p, float c )\n\t{ return p * c; }\nfloat opRep20D( float p, float c )\n\t{ return p * c; }\nfloat opRep21D( float p, float c )\n\t{ return p * c; }\nfloat opRep22D( float p, float c )\n\t{ return p * c; }\nfloat opRep23D( float p, float c )\n\t{ return p * c; }\nfloat opRep24D( float p, float c )\n\t{ return p * c; }\nfloat opRep25D( float p, float c )\n\t{ return p * c; }\nfloat opRep26D( float p, float c )\n\t{ return p * c; }\nfloat opRep27D(", " return (a < b)? a : b; }\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) { return (a > b)? a : b; }\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) { return pmin(pmax(a, b, k), 1.0, k); }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k, 0.0, k), 0.0, k) * k + b; }\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) { return pmax(pmin((a - b) / k", " return p - floor(p / size) * size; }\nvec2 mod2(inout vec2 p, float size) { return mod2(p, vec2(size)); }\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset) { return mod2(p - offset, size); }\nvec2 mod2(inout vec2 p, float size, vec2 offset) { return mod2(p - offset, size); }\n\nfloat sdBox( in vec2 p, in vec2 b ) { return length(max(abs(p)-b,0.0)); }\nfloat sdBox( in vec2 p, in vec2 b, in vec2 o ) { return length(max(abs(p-o)-b,0.0)); }\nfloat sdBox( in vec2 p, in vec2 b, in vec2 o, in vec2 s ) { return length(max(abs(p-o)-b,0.0))/s; }\n\nfloat sdBox( in vec3 p, in vec3 b ) { return length(max(abs(p)-b,0.0)); }\nfloat sdBox( in vec3 p, in vec3 b, in vec3 o ) { return length(max(abs(p-o)-b,0.0)); }\nfloat sdBox( in vec3 p, in vec3 b, in vec3 o, in vec3 s ) { return length(max(abs(p-o)-b,0.0))/s; }\n\nfloat sdBox( in vec4 p, in vec4 b ) { return length(max(abs(p)-b,0.0)); }\nfloat sdBox( in vec4 p, in vec4 b, in vec4 o ) { return length(max(abs(p-o)-b,0.0)); }\nfloat sdBox( in vec4 p, in vec4 b, in vec4 o, in vec4 s ) { return length(max(abs(p-o)-b,0.0))/s; }\n\nfloat sdBox( in vec2 p, in vec2 b, in float r ) { return length(max(abs(p)-b,0.0)) - r; }\nfloat sdBox( in vec2 p, in vec2 b, in float r, in vec2 o ) { return length(max(abs(p-o)-b,0.0)) - r; }\nfloat sdBox( in vec2 p, in vec2 b, in float r, in vec2 o, in float s ) { return length(max(abs(p-o", " \n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n   ", " // ro: ray origin, rd: ray direction, s: sphere position and radius\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0, -1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 p) { // ro: ray origin, rd: ray direction, p: plane position and normal\n    vec3 oc = ro - p.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, p.xyz) - p.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0, -1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 a, vec3 b, vec3 c) { // ro: ray origin, rd: ray direction, a, b, c: triangle vertices\n    vec3 e1 = b - a;\n    vec3 e2 = c - a;\n    vec3 h = cross(rd, e2);\n    float a2 = dot(e1, h);\n    if (a2 > -0.00001 && a2 < 0.00001) return vec2(-1.0, -1.0);\n    float f = 1.0 / a2;\n    vec3 s = ro - a;\n    float c1 = dot(s, h);\n    float r = f * c1;\n    vec3 q = s - r * e1;\n    float c2 = dot(q, e2);\n    if (c2 < 0.0 || r < 0.0 || r > 1.0) return vec2(-1.0, -1.0);\n    float b1 = dot(e1, q);\n    float t = f * b1;\n    if (t < 0.0 || t > 1.0 || c2 - t * b > 0.00001) return", " // ro = ray origin, rd = ray direction, boxSize = half size of box\n    vec3 tbot = (-ro - boxSize) / rd;\n    vec3 ttop = (-ro + boxSize) / rd;\n    vec3 t = min(ttop, tbot);\n    float tmin = max(max(t.x, t.y), t.z);\n    if (tmin < 0.0) return vec2(-1.0, -1.0);\n    t = max(ttop, tbot);\n    float tmax = min(min(t.x, t.y), t.z);\n    if (tmax < tmin) return vec2(-1.0, -1.0);\n    vec3 p = ro + rd * tmin;\n    outNormal = abs(p) < boxSize? normalize(p) : vec3(0.0, 0.0, 0.0);\n    return vec2(tmin, tmax);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, float radius, out vec3 outNormal )  { // ro = ray origin, rd = ray direction, radius = sphere radius\n    vec3 oc = ro;\n    float b = dot(rd, oc);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0, -1.0);\n    float t = -b - sqrt(h);\n    if (t < 0.0) return vec2(-1.0, -1.0);\n    vec3 p = ro + rd * t;\n    outNormal = normalize(p);\n    return vec2(t, t);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec3 planeNormal, float planeDistance, out vec3 outNormal )  { // ro = ray origin, rd = ray direction, planeNormal = plane normal, planeDistance = distance from origin to plane\n    vec3 oc = ro;\n    float b = dot(rd, planeNormal);\n    float c = dot(oc, planeNormal) - planeDistance;\n    float t = -c / b;\n    if (t < 0.0) return vec2(-1.0, -1.0);\n    vec3 p = ro + rd * t;\n   ", " //d = (w, h)\n    vec2 a = vec2(-d.y, d.x);\n    vec2 b = vec2(d.y, d.x);\n    vec2 c = vec2(d.y, -d.x);\n    vec2 d1 = p + a;\n    vec2 d2 = p + b;\n    vec2 d3 = p + c;\n    vec2 d4 = p - a;\n    vec2 d5 = p - b;\n    vec2 d6 = p - c;\n    vec2 d7 = p + a;\n    vec2 d8 = p + b;\n    vec2 d9 = p + c;\n    vec2 d10 = p - a;\n    vec2 d11 = p - b;\n    vec2 d12 = p - c;\n    vec2 d13 = p + a;\n    vec2 d14 = p + b;\n    vec2 d15 = p + c;\n    vec2 d16 = p - a;\n    vec2 d17 = p - b;\n    vec2 d18 = p - c;\n    vec2 d19 = p + a;\n    vec2 d20 = p + b;\n    vec2 d21 = p + c;\n    vec2 d22 = p - a;\n    vec2 d23 = p - b;\n    vec2 d24 = p - c;\n    vec2 d25 = p + a;\n    vec2 d26 = p + b;\n    vec2 d27 = p + c;\n    vec2 d28 = p - a;\n    vec2 d29 = p - b;\n    vec2 d30 = p - c;\n    vec2 d31 = p + a;\n    vec2 d32 = p + b;\n    vec2 d33 = p + c;\n    vec2 d34 = p - a;\n    vec2 d35 = p - b;\n    vec2 d36 = p - c;\n    vec2 d37 = p + a;\n    vec2 d38 = p + b;\n    vec2 d39 = p + c;\n    vec2 d40 = p - a;\n    vec2 d41 = p - b;\n    vec2 d42 = p - c;\n    vec2 d43 = p + a;\n    vec2 d44 = p + b;\n    vec2 d45 = p + c;\n    vec2 d46 = p - a;\n    vec2", " //distance from point p to line segment ab\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b) { //distance from point p to line segment ab\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c) { //distance from point p to triangle abc\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float d1 = dot(pa,ba);\n    float d2 = dot(pa,ca);\n    float d3 = dot(ba,ca);\n    float denom = d3*d3 - d2*d2;\n    float t = (d1*d3 - d2*d1) / denom;\n    float u = (d1 + t*d2) / d3;\n    return length(pa - ba*t);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) { //distance from point p to quadrilateral abcd\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 da = d - a;\n    float d1 = dot(pa,ba);\n    float d2 = dot(pa,ca);\n    float d3 = dot(pa,da);\n    float d4 = dot(ba,ca);\n    float d5 = dot(ba,da);\n    float d6 = dot(ca,da);\n    float denom = d4*d6 - d5*d5;\n    float t = (d1*d6 - d2*d5) / denom;\n    float u = (d1 + t*d5) / d4;\n    return length(pa - ba*t);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) { //distance from point p to pentagon abcde", "\t\n\tvec2 dir = normalize( b - a );\n\tvec2 p1 = a + dir * w1;\n\tvec2 p2 = a - dir * w1;\n\tvec2 p3 = b + dir * w2;\n\tvec2 p4 = b - dir * w2;\n\t\n\tfloat d = distance( p, p1 ) + distance( p, p2 ) + distance( p, p3 ) + distance( p, p4 );\n\treturn d;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\t\n\tvec2 dir = normalize( b - a );\n\tvec2 p1 = a + dir * w1;\n\tvec2 p2 = a - dir * w1;\n\tvec2 p3 = b + dir * w2;\n\tvec2 p4 = b - dir * w2;\n\t\n\tfloat d = distance( p, p1 ) + distance( p, p2 ) + distance( p, p3 ) + distance( p, p4 );\n\treturn d;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\t\n\tvec2 dir = normalize( b - a );\n\tvec2 p1 = a + dir * w1;\n\tvec2 p2 = a - dir * w1;\n\tvec2 p3 = b + dir * w2;\n\tvec2 p4 = b - dir * w2;\n\t\n\tfloat d = distance( p, p1 ) + distance( p, p2 ) + distance( p, p3 ) + distance( p, p4 );\n\treturn d;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\t\n\tvec2 dir = normalize( b - a );\n\tvec2 p1 = a + dir * w1;\n\tvec2 p2 = a - dir * w1;\n\tvec2 p3 = b + dir * w2;\n\tvec2 p4 = b - dir * w2;\n", " // tor = (r, q)\n    float b = dot(rd, ro);\n    float c = dot(ro, ro) - tor.x * tor.x;\n    float h = b * b - c;\n    if (h < 0.) return -1.;\n    h = sqrt(h);\n    return b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayBox(vec3 ro, vec3 rd, vec3 b) {\n    vec3 r = abs(ro) - b;\n    float t1 = -min(max(r.x, max(r.y, r.z)), 0.0) / rd.x;\n    float t2 = min(min(-r.x, -r.y), -r.z) / max(max(rd.x, rd.y), rd.z);\n    return max(t1, t2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(rd, ro);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h < 0.) return -1.;\n    h = sqrt(h);\n    return b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n) {\n    float ndotrd = dot(n, rd);\n    if (abs(ndotrd) < 0.0001) return -1.;\n    float ndotro = dot(n, ro);\n    return -ndotro / ndotrd;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCylinder(vec3 ro, vec3 rd, vec2 c) {\n    float b = dot(rd, ro);\n    float c2 = dot(ro, ro) - c.x * c.x;\n    float h = b * b - c2;\n    if (h < 0.) return -1.;\n    h = sqrt(h", " // torus normal\n    vec2 p = pos.xy - tor.xy;\n    float r = length(p);\n    float d = tor.z - r;\n    return normalize(cross(vec3(0, 0, 1), vec3(p, d)));\n}\n\nvec3 sphereNormal(vec3 pos, vec3 sphere) { // sphere normal\n    return normalize(pos - sphere);\n}\n\nvec3 boxNormal(vec3 pos, vec3 box) { // box normal\n    vec3 n = abs(pos) - box;\n    return sign(pos) * (length(n) - 1.0);\n}\n\nvec3 planeNormal(vec3 pos, vec3 plane) { // plane normal\n    return normalize(pos - plane);\n}\n\nvec3 cylinderNormal(vec3 pos, vec3 cyl) { // cylinder normal\n    vec3 p = pos - cyl.xy;\n    float r = cyl.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3 coneNormal(vec3 pos, vec3 cone) { // cone normal\n    vec3 p = pos - cone.xy;\n    float r = cone.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3 capsuleNormal(vec3 pos, vec3 cap) { // capsule normal\n    vec3 p = pos - cap.xy;\n    float r = cap.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3 capsuleNormal(vec3 pos, vec3 cap) { // capsule normal\n    vec3 p = pos - cap.xy;\n    float r = cap.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3 capsuleNormal(vec3 pos, vec3 cap) { // capsule normal\n    vec3 p = pos - cap.xy;\n    float r = cap.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3 capsuleNormal(vec3 pos, vec3 cap) { // capsule normal\n    vec3 p = pos - cap.xy;\n    float r = cap.z - length(p);\n    return normalize(cross(vec3(0, 0, 1), vec3(p, r)));\n}\n\nvec3", " return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) { return 1.0f - 2.0f / (1.0f + exp(2.0f * x)); }\n\n// License: Unknown, author: Unknown, found: don't remember\n", " // post processing\n    float t = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0);\n    float b = 0.5 + 0.5 * sin(q.y * 3.1415926 * 2.0);\n    float r = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 + q.y * 3.1415926 * 2.0);\n    float g = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 - q.y * 3.1415926 * 2.0);\n    float a = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 + q.y * 3.1415926 * 2.0 + 0.5);\n    float c = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 - q.y * 3.1415926 * 2.0 + 0.5);\n    float d = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 + q.y * 3.1415926 * 2.0 + 1.0);\n    float e = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 - q.y * 3.1415926 * 2.0 + 1.0);\n    float f = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 + q.y * 3.1415926 * 2.0 + 1.5);\n    float h = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 - q.y * 3.1415926 * 2.0 + 1.5);\n    float i = 0.5 + 0.5 * sin(q.x * 3.1415926 * 2.0 + q.y * 3.1415926 * 2.0 + 2.0);\n    float j = 0.5", " return p - floor(p / size) * size; }\nvec2 mod2(inout vec2 p, float size) { return mod2(p, vec2(size)); }\nvec2 mod2(inout vec2 p, vec2 size, vec2 offset) { return mod2(p - offset, size); }\nvec2 mod2(inout vec2 p, float size, vec2 offset) { return mod2(p - offset, size); }\n\nfloat sdBox( in vec2 p, in vec2 b ) { return length(max(abs(p)-b,0.0)); }\nfloat sdBox( in vec2 p, in vec2 b, in vec2 o ) { return length(max(abs(p-o)-b,0.0)); }\nfloat sdBox( in vec3 p, in vec3 b ) { return length(max(abs(p)-b,0.0)); }\nfloat sdBox( in vec3 p, in vec3 b, in vec3 o ) { return length(max(abs(p-o)-b,0.0)); }\n\nfloat sdSphere( in vec3 p, float s ) { return length(p)-s; }\nfloat sdSphere( in vec3 p, float s, float r ) { return length(p)-r; }\nfloat sdSphere( in vec3 p, float s, float r, float o ) { return length(p-o)-r; }\n\nfloat sdCylinder( in vec3 p, float h, float r ) { return length(max(abs(p.zz)-vec2(h),0.0)) - r; }\nfloat sdCylinder( in vec3 p, float h, float r, float o ) { return length(max(abs(p.zz-o)-vec2(h),0.0)) - r; }\n\nfloat sdCappedCylinder( in vec3 p, float h, float r1, float r2 ) { float q = length(p.xz)-r2; return length(max(vec2(q,h),0.0)) - max(-q,0.0); }\nfloat sdCappedCylinder( in vec3 p, float h, float r1, float r2, float o ) { float q = length(p.xz-o)-r2; return length(max(vec2(q,h),0.0)) - max(-q,0.0); }\n\nfloat sdTorus( in vec3 p, float r, float R ) { vec2 q = vec2(length(p.xz)-R,p.y);", " return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat hash(vec3 uv) { return fract(sin(dot(uv, vec3(12.9898, 4.1414, 1.0))) * 43758.5453); }\n\nfloat noise(vec2 uv) { return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(vec3 uv) { return fract(sin(dot(uv, vec3(12.9898, 4.1414, 1.0))) * 43758.5453); }\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0; i < 4; i++) {\n        n = 0.5 * noise(uv);\n        f += a * n;\n        uv *= 2.0;\n        a *= b;\n    }\n    return f;\n}\n\nfloat fbm(vec3 uv) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0; i < 4; i++) {\n        n = 0.5 * noise(uv);\n        f += a * n;\n        uv *= 2.0;\n        a *= b;\n    }\n    return f;\n}\n\nfloat fbm(vec2 uv, float scale) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0; i < 4; i++) {\n        n = 0.5 * noise(uv);\n        f += a * n;\n        uv *= 2.0;\n        a *= b;\n    }\n    return f * scale;\n}\n\nfloat fbm(vec3 uv, float scale) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0;", "\t\n    return length(p-c)-r;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\t\n    return length(p-c)-r;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 pa = p - a, ba = b - a, ca = c - a;\n    vec3 pa2 = p - b, ba2 = a - b, ca2 = c - b;\n    vec3 pa3 = p - c, ba3 = a - c, ca3 = b - c;\n    vec3 n = cross(ba, ca) + cross(ca2, pa2) + cross(pa3, ba3);\n    float d = -dot(n, pa) / dot(n, ba);\n    return d < 0.0? length(pa) : length(pa - d * ba);\n}\n\n// signed distance to a sphere\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance to a plane\nfloat sdPlane( in vec3 p, in vec3 n )\n{\n    return dot(p, n);\n}\n\n// signed distance to a box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a cylinder\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// signed distance to a capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, ", "\t\n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\t\n\tfloat t = dot( ap, ab ) / dot( ab, ab );\n\t\n\tif( t < 0.0 ) return length( ap );\n\tif( t > 1.0 ) return length( ab - ap );\n\t\n\treturn length( ap - ab * t );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in vec2 center, in float radius )\n{\n\treturn length( p - center ) - radius;\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 v0 = b - a, v1 = c - a, v2 = p - a;\n\tfloat dot00 = dot( v0, v0 );\n\tfloat dot01 = dot( v0, v1 );\n\tfloat dot02 = dot( v0, v2 );\n\tfloat dot11 = dot( v1, v1 );\n\tfloat dot12 = dot( v1, v2 );\n\t\n\tfloat invDenom = 1.0 / ( dot00 * dot11 - dot01 * dot01 );\n\tfloat u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\tfloat v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\tif( u < 0.0 ) u = 0.0;\n\telse if( u > 1.0 ) u = 1.0;\n\tif( v < 0.0 ) v = 0.0;\n\telse if( v > 1.0 ) v = 1.0;\n\t\n\tfloat t = dot( v0, v2 ) + u * dot( v1, v2 ) + v * dot( v0, v1 );\n\tif( t < 0.0 ) t = 0.0;\n\tfloat dist = length( p - a - u * v0 - v * v1 ) - t;\n\t\n\treturn dist;\n}\n\n// distance to a square\nfloat sdSquare( in vec2 p, in vec2 center, in float size )\n{\n\tvec2 d = abs( p - center ) - size;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// distance to a rectangle\nfloat sd", " return a.x*b.y - a.y*b.x; }\nfloat ccw(in vec2 a, in vec2 b, in vec2 c ) { return cro(b-a,c-a); }\nfloat signedTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c ) {\n    float d = ccw(a,b,c);\n    if (d > 0.0) return length(p-a);\n    d += ccw(p,b,c);\n    if (d < 0.0) return length(p-a);\n    d += ccw(a,p,b);\n    if (d > 0.0) return length(p-a);\n    return length(p-a);\n}\n\n// signed distance to a 2D quad\nfloat signedQuad(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d ) {\n    float d1 = signedTriangle(p,a,b,c);\n    float d2 = signedTriangle(p,b,c,d);\n    return min(d1,d2);\n}\n\n// signed distance to a 2D circle\nfloat signedCircle(in vec2 p, in vec2 c, in float r ) {\n    return length(p-c)-r;\n}\n\n// signed distance to a 2D sphere\nfloat signedSphere(in vec3 p, in vec3 c, in float r ) {\n    return length(p-c)-r;\n}\n\n// signed distance to a 2D torus\nfloat signedTorus(in vec2 p, in vec2 c, in float r, in float R ) {\n    vec2 q = p-c;\n    float d = length(q)-R;\n    if (d < 0.0) return length(q)-r;\n    return d;\n}\n\n// signed distance to a 2D cylinder\nfloat signedCylinder(in vec2 p, in vec2 c, in float r, in float h ) {\n    vec2 q = p-c;\n    float d = length(q)-r;\n    if (d < 0.0) return abs(q.y)-h/2.0;\n    return d;\n}\n\n// signed distance to a 2D cone\nfloat signedCone(in vec2 p, in vec2 c, in float r, in float h ) {\n    vec2 q = p-c;\n    float d = length(q)-r;\n    if (d < 0.0) return abs(q.y)-h/2.0;\n    return d;\n", " \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r; \n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{ \n    vec2 q = abs(p", " \n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 filmic_tonemap(vec3 x)\n{\n    vec3 a = s_curve(x);\n    vec3 b = s_curve(a);\n    return (a * (6.2 * a - 0.5)) / (b + 0.1);\n}\n\nvec3 filmic_tonemap(vec3 x, float exposure)\n{\n    return filmic_tonemap(x * exposure);\n}\n\nvec3 filmic_tonemap(vec3 x, float exposure, float gamma)\n{\n    return pow(filmic_tonemap(x * exposure), vec3(1.0 / gamma));\n}\n\nvec3 filmic_tonemap(vec3 x, float exposure, float gamma, float white)\n{\n    return pow(filmic_tonemap(x * exposure), vec3(1.0 / gamma)) * white;\n}", "\t\n\tvec3 dx = d_s_curve_dx(x);\n\tvec3 dy = d_s_curve_dy(x);\n\tvec3 dz = d_s_curve_dz(x);\n\treturn vec3(dx, dy, dz);\n}\n\n// derivative of s-curve in x\nvec3 d_s_curve_dx(vec3 x)\n{\n\tvec3 dx = vec3(0.0);\n\tdx.x = 1.0 - 2.0 * x.x * (1.0 - x.x);\n\treturn dx;\n}\n\n// derivative of s-curve in y\nvec3 d_s_curve_dy(vec3 x)\n{\n\tvec3 dy = vec3(0.0);\n\tdy.y = 1.0 - 2.0 * x.y * (1.0 - x.y);\n\treturn dy;\n}\n\n// derivative of s-curve in z\nvec3 d_s_curve_dz(vec3 x)\n{\n\tvec3 dz = vec3(0.0);\n\tdz.z = 1.0 - 2.0 * x.z * (1.0 - x.z);\n\treturn dz;\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\tvec3 s = vec3(0.0);\n\ts.x = 1.0 - 2.0 * x.x * (1.0 - x.x);\n\ts.y = 1.0 - 2.0 * x.y * (1.0 - x.y);\n\ts.z = 1.0 - 2.0 * x.z * (1.0 - x.z);\n\treturn s;\n}\n\n// s-curve in x\nvec3 s_curve_x(vec3 x)\n{\n\tvec3 s = vec3(0.0);\n\ts.x = 1.0 - 2.0 * x.x * (1.0 - x.x);\n\treturn s;\n}\n\n// s-curve in y\nvec3 s_curve_y(vec3 x)\n{\n\tvec3 s = vec3(0.0);\n\ts.y = 1.0 - 2.0 * x.y * (1.0 - x.y);\n\treturn s;\n}\n\n// s-curve in z\nvec3 s_curve_z(vec3 x)\n{\n\tvec3 s = vec3(0.0);\n\ts.z = 1.0 - 2.0 * x.z * (1.0 - x.z);\n\treturn s;\n}\n\n// s-curve in x\nvec3 s_curve_x(vec3 x)\n{\n\tvec3 s =", "\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k )\n{\t\n\tfloat a = atan(p.x, p.y);\n\tfloat r = length(p);\n\t\n\tfloat ang = a + k * 3.1415926;\n\t\n\tfloat d = r - w * cos(ang);\n\t\n\treturn d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2", "\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c, float d)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c, float d, float e)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c, float d, float e, float f)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c, float d, float e, float f, float g)\n{\t\n\tvec3 transmittance = exp(-opticalDepth);\n\treturn transmittance;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float a, float b, float c, float d, float e, float f, float g, float h)\n", "\t\n\tvec3 transmittanceAccum = vec3(1.0);\n\tvec3 scatteringAccum = vec3(0.0);\n\t\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 pos = rayStart + t * rayDir;\n\t\tvec3 normal = GetNormal(pos);\n\t\tvec3 lightDirToPos = lightDir - pos;\n\t\tfloat lightDirToPosLength = length(lightDirToPos);\n\t\tlightDirToPos = normalize(lightDirToPos);\n\t\tfloat lightDirToPosDotNormal = dot(lightDirToPos, normal);\n\t\tfloat lightDirToPosDotNormalAbs = abs(lightDirToPosDotNormal);\n\t\tfloat lightDirToPosDotNormalAbsSquared = lightDirToPosDotNormalAbs * lightDirToPosDotNormalAbs;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOne = lightDirToPosDotNormalAbsSquared - 1.0;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquared = lightDirToPosDotNormalAbsSquaredMinusOne * lightDirToPosDotNormalAbsSquaredMinusOne;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwo = lightDirToPosDotNormalAbsSquaredMinusOneSquared - 2.0;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquared = lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwo * lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwo;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThree = lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquared - 3.0;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThreeSquared = lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThree * lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThree;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThreeSquaredMinusFour = lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThreeSquared - 4.0;\n\t\tfloat lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThreeSquaredMinusFourSquared = lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinusTwoSquaredMinusThreeSquaredMinusFour * lightDirToPosDotNormalAbsSquaredMinusOneSquaredMinus", "\t\n\tfloat r = length(p2);\n\tfloat d2 = d*d;\n\tfloat r2 = r*r;\n\tfloat r2mrb2 = r2 - rb*rb;\n\tfloat r2mrd2 = r2 - d2;\n\tfloat r2mrd2mrb2 = r2 - d2 - rb*rb;\n\tfloat r2mrd2mrb2mra2 = r2 - d2 - rb*rb - ra*ra;\n\t\n\tfloat a = r2mrd2mrb2mra2;\n\tfloat b = 2.0*(r2mrd2mrb2 + d2*rb*rb + ra*ra*r2mrd2);\n\tfloat c = r2mrd2mrb2mrb2 + d2*r2mrd2 + ra*ra*r2mrb2;\n\t\n\tfloat q = b*b - 4.0*a*c;\n\tfloat t = 0.0;\n\tif( q > 0.0 )\n\t{\n\t\tfloat s = -0.5*(b + sqrt(q));\n\t\tt = max(0.0, min(1.0, s/a));\n\t}\n\telse if( q == 0.0 )\n\t{\n\t\tfloat s = -0.5*b;\n\t\tt = max(0.0, min(1.0, s/a));\n\t}\n\t\n\tfloat h = sqrt(r2mrb2);\n\tfloat k = sqrt(r2mrd2);\n\tfloat l = sqrt(r2mrd2mrb2);\n\tfloat m = sqrt(r2mrd2mrb2mra2);\n\t\n\tfloat s = 0.0;\n\tif( t > 0.0 )\n\t{\n\t\ts = sqrt(1.0 - t*t);\n\t}\n\t\n\tfloat d1 = h + s*k;\n\tfloat d2 = h - s*k;\n\tfloat d3 = l + s*m;\n\tfloat d4 = l - s*m;\n\t\n\tfloat dmin = min(d1, d2);\n\tdmin = min(dmin, d3);\n\tdmin = min(dmin, d4);\n\t\n\treturn dmin;\n}\n\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d )\n{\n\treturn sdDeathStar( p, ra, rb, d ) - ra;\n}\n\nfloat sdDeathStar( in vec3 p, in float ra, float rb )\n{\n\treturn sdDeathStar( p, ra, rb", "\t\n\tfloat d = length(p) - r;\n\t\n\tif( d < t )\n\t{\n\t\tfloat h2 = h - t;\n\t\tfloat h3 = h + t;\n\t\t\n\t\tfloat d2 = length(p - vec3(0.0, h2, 0.0)) - r;\n\t\tfloat d3 = length(p - vec3(0.0, h3, 0.0)) - r;\n\t\t\n\t\treturn min(d2, d3);\n\t}\n\t\n\treturn d;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\t\n\tfloat d = length(p.xz) - r;\n\t\n\tif( d < t )\n\t{\n\t\tfloat h2 = h - t;\n\t\tfloat h3 = h + t;\n\t\t\n\t\tfloat d2 = length(p.xz - vec2(0.0, h2)) - r;\n\t\tfloat d3 = length(p.xz - vec2(0.0, h3)) - r;\n\t\t\n\t\treturn min(d2, d3);\n\t}\n\t\n\treturn d;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\t\n\tfloat d = length(p.xz) - r;\n\t\n\tif( d < t )\n\t{\n\t\tfloat h2 = h - t;\n\t\tfloat h3 = h + t;\n\t\t\n\t\tfloat d2 = length(p.xz - vec2(0.0, h2)) - r;\n\t\tfloat d3 = length(p.xz - vec2(0.0, h3)) - r;\n\t\t\n\t\treturn min(d2, d3);\n\t}\n\t\n\treturn d;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\t\n\tfloat d = length(p.xz) - r;\n\t\n\tif( d < t )\n\t{\n\t\tfloat h2 = h - t;\n\t\tfloat h3 = h + t;\n\t\t\n\t\tfloat d2 = length(p.xz - vec2(0.0, h2)) - r;\n\t\tfloat d3 = length(p.xz - vec2(0.0", "\t\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.05 );\n\t\tif( res<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, h/t );\n\t\tt += h*0.25;\n\t\tif( res<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.05 );\n\t\tif( res<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const float bias )\n{\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.05 );\n\t\tif( res<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const float bias, const", "\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r + max(0.0, h - abs(p.y));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\t\n\treturn length(p.xz) - r", "\t\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3( 0.0, 0.0, 0.0 );\n\t\n\tnor.x = sdf( pos + eps.xyy ) - sdf( pos - eps.xyy );\n\tnor.y = sdf( pos + eps.yxy ) - sdf( pos - eps.yxy );\n\tnor.z = sdf( pos + eps.yyx ) - sdf( pos - eps.yyx );\n\t\n\treturn normalize( nor );\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 nor )\n{\t\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor2 = vec3( 0.0, 0.0, 0.0 );\n\t\n\tnor2.x = sdf( pos + eps.xyy, nor ) - sdf( pos - eps.xyy, nor );\n\tnor2.y = sdf( pos + eps.yxy, nor ) - sdf( pos - eps.yxy, nor );\n\tnor2.z = sdf( pos + eps.yyx, nor ) - sdf( pos - eps.yyx, nor );\n\t\n\treturn normalize( nor2 );\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 nor, in vec3 nor2 )\n{\t\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor3 = vec3( 0.0, 0.0, 0.0 );\n\t\n\tnor3.x = sdf( pos + eps.xyy, nor, nor2 ) - sdf( pos - eps.xyy, nor, nor2 );\n\tnor3.y = sdf( pos + eps.yxy, nor, nor2 ) - sdf( pos - eps.yxy, nor, nor2 );\n\tnor3.z = sdf( pos + eps.yyx, nor, nor2 ) - sdf( pos - eps.yyx, nor, nor2 );\n\t\n\treturn normalize( nor3 );\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 nor, in vec3 nor2, in vec3 nor3 )\n{\t\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor4 = vec3( 0.0, 0.0, 0.0 );\n", "\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.0))) ) return length(max(q,0.0))-h;\n\treturn -length(min(q,vec2(h))) ;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\t\n\tvec2 q = abs(p)-vec2(r,r);\n\tif( any(lessThan(q,vec2(0.", "\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( dot( grad3(  1, n ), f - vec3(0.0,0.0,1.0) ), \n                         dot( grad3(-1, n+1), f - vec3(0.0,0.0,0.0) ), f.x),\n                   mix( dot( grad3(  1, n+1), f - vec3(1.0,0.0,0.0) ), \n                        dot( grad3(-1, n+2), f - vec3(1.0,0.0,1.0) ), f.x), f.y),\n              mix( dot( grad3(  1, n+2), f - vec3(1.0,1.0,0.0) ), \n                   dot( grad3(-1, n+3), f - vec3(1.0,1.0,1.0) ), f.x), f.z);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( dot( grad3(  1, n ), f - vec3(0.0,0.0,1.0) ), \n                         dot( grad3(-1, n+1), f - vec3(0.0,0.0,0.0) ), f.x),\n                   mix( dot( grad3(  1, n+1), f - vec3(1.0,0.0,0.0) ), \n                        dot( grad3(-1, n+2), f - vec3(1.0,0.0,1.0) ), f.x), f.y),\n              mix( dot( grad3(  1, n+2), f - vec3(1.0,1.0,0.0) ),", "\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot )\n{\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot, float scale )\n{\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot, float scale, float offset )\n{\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot, float scale, float offset, float freq )\n{\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 0.5;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2", " \n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash31(vec2 p2)\n{ \n    p2 = fract(p2 * vec2(.1031,.1030));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.x + p2.y) * p2.y);\n}\n\n//value noise hash\nfloat hash31(vec4 p4)\n{ \n    p4 = fract(p4 * vec4(.1031,.1030,.0973,.1099));\n    p4 += dot(p4, p4.yzxw + 19.19);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\n//value noise hash\nfloat hash31(vec3 p3, float t)\n{ \n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z + t);\n}\n\n//value noise hash\nfloat hash31(vec2 p2, float t)\n{ \n    p2 = fract(p2 * vec2(.1031,.1030));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.x + p2.y) * p2.y + t);\n}\n\n//value noise hash\nfloat hash31(vec4 p4, float t)\n{ \n    p4 = fract(p4 * vec4(.1031,.1030,.0973,.1099));\n    p4 += dot(p4, p4.yzxw + 19.19);\n    return fract((p4.x + p4.y) * p4.z + t);\n}\n\n//value noise hash\nfloat hash31(vec3 p3, float t, float s)\n{ \n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3", "\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 uv3 = vec2(0.0, 0.0);\n\t\n\tvec2 uv4 = vec2(0.0, 0.0);\n\t\n\tvec2 uv5 = vec2(0.0, 0.0);\n\t\n\tvec2 uv6 = vec2(0.0, 0.0);\n\t\n\tvec2 uv7 = vec2(0.0, 0.0);\n\t\n\tvec2 uv8 = vec2(0.0, 0.0);\n\t\n\tvec2 uv9 = vec2(0.0, 0.0);\n\t\n\tvec2 uv10 = vec2(0.0, 0.0);\n\t\n\tvec2 uv11 = vec2(0.0, 0.0);\n\t\n\tvec2 uv12 = vec2(0.0, 0.0);\n\t\n\tvec2 uv13 = vec2(0.0, 0.0);\n\t\n\tvec2 uv14 = vec2(0.0, 0.0);\n\t\n\tvec2 uv15 = vec2(0.0, 0.0);\n\t\n\tvec2 uv16 = vec2(0.0, 0.0);\n\t\n\tvec2 uv17 = vec2(0.0, 0.0);\n\t\n\tvec2 uv18 = vec2(0.0, 0.0);\n\t\n\tvec2 uv19 = vec2(0.0, 0.0);\n\t\n\tvec2 uv20 = vec2(0.0, 0.0);\n\t\n\tvec2 uv21 = vec2(0.0, 0.0);\n\t\n\tvec2 uv22 = vec2(0.0, 0.0);\n\t\n\tvec2 uv23 = vec2(0.0, 0.0);\n\t\n\tvec2 uv24 = vec2(0.0, 0.0);\n\t\n\tvec2 uv25 = vec2(0.0, 0.0);\n\t\n\tvec2 uv26 = vec2(0.0, 0.0);\n\t\n\tvec2 uv27 = vec2(0.0, 0.0);\n\t\n\tvec2 uv28 = vec2(0.0, 0.0);\n\t\n\tvec2 uv29 = vec2(0.0, 0.0);\n", " // Assumes c is in [0, 1] range\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c", " return p - floor(p / size) * size; }\nfloat mod2(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod3(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod4(inout float p, float size) { return p - floor(p / size) * size; }\nfloat mod5(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod6(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod7(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod8(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod9(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod10(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod11(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod12(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod13(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod14(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod15(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod16(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod17(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod18(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod19(inout float p, float size) { return p - floor(p / size) * size + size; }\nfloat mod20(inout float p, float size) { return p - floor(p / size) * size - size; }\nfloat mod21(inout float p,", " return fract(sin(co) * 43758.5453123); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += a * noise(p);\n        p *= b;\n        a *= 0.5;\n        b *= 0.5;\n    }\n    return f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += a * noise(p);\n        p *= b;\n        a *= 0.5;\n        b *= 0.5;\n    }\n    return f * scale;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale, float octaves) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for (int i = 0; i < octaves; i++) {\n        f += a * noise(p", " return t <= 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4); }\nfloat sRGBInv(float t) { return t <= 0.0031308? t * 12.92 : 1.055 * pow(t, 1.0 / 2.4) - 0.055; }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float3 t) { return float3(sRGB(t.r), sRGB(t.g), sRGB(t.b)); }\nfloat3 sRGBInv(float3 t) { return float3(sRGBInv(t.r), sRGBInv(t.g), sRGBInv(t.b)); }\n\nfloat3 sRGB(float", " return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) + 0.06); }\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return c * c * (c * (c * 0.25 + 0.3) +", " return (a < b - k)? a : b - k; }\nfloat pmax(float a, float b, float k) { return (a > b + k)? a : b + k; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b) { return (a < b)? a : b; }\nfloat pmax(float a, float b) { return (a > b)? a : b; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c) { return (a < b && a < c)? a : (b < c)? b : c; }\nfloat pmax(float a, float b, float c) { return (a > b && a > c)? a : (b > c)? b : c; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c, float d) { return (a < b && a < c && a < d)? a : (b < c && b < d)? b : (c < d)? c : d; }\nfloat pmax(float a, float b, float c, float d) { return (a > b && a > c && a > d)? a : (b > c && b > d)? b : (c > d)? c : d; }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c, float d, float e) { return (a < b && a < c && a < d && a < e)? a : (b < c && b < d && b < e)? b : (c < d && c < e)? c : (d < e)? d : e; }\nfloat pmax(float a, float b, float c, float d, float e) { return (a > b && a > c && a > d && a > e)? a : (b > c && b > d && b > e)?", " // sph = sphere, dbuffer = distance buffer\n    float d = length(sph.xyz) - sph.w;\n    float h = max(d, dbuffer);\n    vec3 p = ro + rd * h;\n    float dd = length(p - sph.xyz);\n    return max(d, dd);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float t) { // sph = sphere, dbuffer = distance buffer\n    float d = length(sph.xyz) - sph.w;\n    float h = max(d, dbuffer);\n    vec3 p = ro + rd * h;\n    float dd = length(p - sph.xyz);\n    return max(d, dd) - t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float t, float t2) { // sph = sphere, dbuffer = distance buffer\n    float d = length(sph.xyz) - sph.w;\n    float h = max(d, dbuffer);\n    vec3 p = ro + rd * h;\n    float dd = length(p - sph.xyz);\n    return max(d, dd) - t - t2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float t, float t2, float t3) { // sph = sphere, dbuffer = distance buffer\n    float d = length(sph.xyz) - sph.w;\n    float h = max(d, dbuffer);\n    vec3 p = ro + rd * h;\n    float dd = length(p - sph.xyz);\n    return max(d, dd) - t - t2 - t3;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float t, float t2, float t3, float t4) { // sph = sphere, dbuffer = distance buffer\n    float d = length(sph", " // p = (x,y,z,w)\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;\n    float bd = 0.", "\t\n\tvec3 q = abs(p) - r;\n\tvec3 t = max(q, 0.0);\n\tvec3 s = max(q, 0.0);\n\tfloat a = dot(p, p);\n\tfloat b = dot(t, t);\n\tfloat c = dot(s, s);\n\tfloat d = b - c;\n\tfloat e = a - c - 1.0;\n\tfloat f = a - b - 1.0;\n\tfloat g = sqrt( max(0.0, d*d + e*e) );\n\tfloat h = sqrt( max(0.0, d*d + f*f) );\n\tfloat k = (e*h - f*g)/(g*g - h*h);\n\tfloat l = 0.5 * (h + g + k);\n\tfloat m = 0.5 * (h - g + k);\n\tfloat n = 0.5 * (h + g - k);\n\tfloat o = 0.5 * (h - g - k);\n\tfloat p = 0.5 * (h - g + k);\n\tfloat q = 0.5 * (h + g - k);\n\tfloat r = 0.5 * (h - g - k);\n\tfloat s = 0.5 * (h + g + k);\n\tfloat t = 0.5 * (h - g - k);\n\tfloat u = 0.5 * (h + g - k);\n\tfloat v = 0.5 * (h - g + k);\n\tfloat w = 0.5 * (h + g + k);\n\tfloat x = 0.5 * (h - g - k);\n\tfloat y = 0.5 * (h + g - k);\n\tfloat z = 0.5 * (h - g + k);\n\tfloat aa = 0.5 * (h + g + k);\n\tfloat ab = 0.5 * (h - g - k);\n\tfloat ac = 0.5 * (h + g - k);\n\tfloat ad = 0.5 * (h - g + k);\n\tfloat ae = 0.5 * (h + g + k);\n\tfloat af = 0.5 * (h - g - k);\n\tfloat ag = 0.5 * (h + g - k);\n\tfloat ah = 0.5 * (h - g + k);\n\tfloat ai = 0.5 * (h + g + k);\n\tfloat aj = 0.5 * (h", " // alpha blending\n    vec4 result = back;\n    result.a = back.a + front.a * (1.0 - back.a);\n    if (result.a < 0.001) {\n        result = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    return result;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) { // alpha blending\n    vec4 result = back;\n    result.a = back.a + alpha * (1.0 - back.a);\n    if (result.a < 0.001) {\n        result = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    return result;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float blend) { // alpha blending\n    vec4 result = back;\n    result.a = back.a + alpha * (1.0 - back.a) * blend;\n    if (result.a < 0.001) {\n        result = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    return result;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float blend, float alpha2) { // alpha blending\n    vec4 result = back;\n    result.a = back.a + alpha * (1.0 - back.a) * blend + alpha2 * (1.0 - back.a) * (1.0 - blend);\n    if (result.a < 0.001) {\n        result = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    return result;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float blend, float alpha2, float alpha3) { // alpha blending\n    vec4 result = back;\n    result.a = back.a + alpha * (1.0 - back.a) * blend + alpha2 * (1.0 - back.a) * (1.0 - blend) + alpha3 * (1.0 - back.a) * (1.0 - blend) * (1.0 - blend);\n    if (result.a < 0.001) {\n        result = vec4(0.0, 0.0, 0.0, 0.", " // alpha blending\n    return mix(back, front.rgb, front.a);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front) { // alpha blending\n    return mix(back, front, 1.0);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) { // alpha blending\n    return mix(back, front, alpha);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha) { // alpha blending\n    return mix(back, front, alpha);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend) { // alpha blending\n    return mix(back, front, alpha, blend);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color) { // alpha blending\n    return mix(back, front, alpha, blend, color);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color, vec3 color2) { // alpha blending\n    return mix(back, front, alpha, blend, color, color2);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color, vec3 color2, vec3 color3) { // alpha blending\n    return mix(back, front, alpha, blend, color, color2, color3);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color, vec3 color2, vec3 color3, vec3 color4) { // alpha blending\n    return mix(back, front, alpha, blend, color, color2, color3, color4);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color, vec3 color2, vec3 color3, vec3 color4, vec3 color5) { // alpha blending\n    return mix(back, front, alpha, blend, color, color2, color3, color4, color5);\n}\n\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 blend, vec3 color, vec3 color2, vec3 color3, vec3 color4, vec3 color5, vec3 color6) { // alpha blending\n    return mix(back, front, alpha, blend, color, color2, color3,", " return length(p) - r; }\nfloat hex(vec2 p, float r, float a ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g, float h ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g, float h, float i ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k ) { return length(p*cos(a)-p.y*sin(a)) - r; }\nfloat hex(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g, float", " return v / (v + vec3(1.0)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_tonemap(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_tonemap(vec3 v, float exposure) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_tonemap(vec3 v, float exposure, float gamma) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) /", " return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453123); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += a * noise(p);\n        p *= b;\n        a *= 0.5;\n        b *= 0.5;\n    }\n    return f;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale) {\n    return fbm(p * scale);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale, float offset) {\n    return fbm(p * scale + offset);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale, float offset, float strength) {\n    return fbm(p * scale + offset) * strength;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p, float scale, float offset, float strength, float bias) {\n    return fbm(p * scale + offset)", " // blackbody spectrum\n    float x = 1.4426950408889634e-4 * Temp;\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float x4 = x2 * x2;\n    float x5 = x3 * x2;\n    float x6 = x4 * x2;\n    float x7 = x5 * x2;\n    float x8 = x6 * x2;\n    float x9 = x7 * x2;\n    float x10 = x8 * x2;\n    float x11 = x9 * x2;\n    float x12 = x10 * x2;\n    float x13 = x11 * x2;\n    float x14 = x12 * x2;\n    float x15 = x13 * x2;\n    float x16 = x14 * x2;\n    float x17 = x15 * x2;\n    float x18 = x16 * x2;\n    float x19 = x17 * x2;\n    float x20 = x18 * x2;\n    float x21 = x19 * x2;\n    float x22 = x20 * x2;\n    float x23 = x21 * x2;\n    float x24 = x22 * x2;\n    float x25 = x23 * x2;\n    float x26 = x24 * x2;\n    float x27 = x25 * x2;\n    float x28 = x26 * x2;\n    float x29 = x27 * x2;\n    float x30 = x28 * x2;\n    float x31 = x29 * x2;\n    float x32 = x30 * x2;\n    float x33 = x31 * x2;\n    float x34 = x32 * x2;\n    float x35 = x33 * x2;\n    float x36 = x34 * x2;\n    float x37 = x35 * x2;\n    float x38 = x36 * x2;\n    float x39 = x37 * x2;\n    float x40 = x38 * x2;\n    float x41 = x39 * x2;\n    float x42 = x40 * x2;\n    float x43 = x41 * x2;\n    float x44 = x42 * x2;\n    float x45 = x43 * x2;\n    float x46 = x44", " // 1D noise\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p) { // 2D noise\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x), mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\nfloat noise(vec3 p) { // 3D noise\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(noise(i), noise(i + vec3(1.0, 0.0, 0.0)), f.x), mix(noise(i + vec3(0.0, 1.0, 0.0)), noise(i + vec3(1.0, 1.0, 0.0)), f.x), f.y), mix(mix(noise(i + vec3(0.0, 0.0, 1.0)), noise(i + vec3(1.0, 0.0, 1.0)), f.x), mix(noise(i + vec3(0.0, 1.0, 1.0)), noise(i + vec3(1.0, 1.0, 1.0)), f.x), f.y), f.z);\n}\n\nfloat fbm(vec2 p) { // 2D fbm\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for (int i = 0; i < 5; i++) {\n        f += a * noise(p);\n        p *= b;\n        a *= 0.5;\n        b *= 0.5;\n    }\n    return f;\n}\n\nfloat fbm(vec3 p) { // 3D fbm\n    float f = 0.0;\n    float a = 0.5;\n    float b = ", " // ray-sphere intersection\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.) return vec2(-1., -sqrt(-h) - b);\n    return vec2(1., -b - sqrt(h));\n}\n\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 pl) { // ray-plane intersection\n    vec3 oc = ro - pl.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - pl.w * pl.w;\n    float h = b * b - c;\n    if (h < 0.) return vec2(-1., -sqrt(-h) - b);\n    return vec2(1., -b - sqrt(h));\n}\n\nvec2 rayBox(vec3 ro, vec3 rd, vec3 b) { // ray-box intersection\n    vec3 t = abs(ro - b) - length(rd);\n    float tmin = max(max(t.x, t.y), t.z);\n    float tmax = min(min(min(t.x, t.y), t.z), 0.);\n    if (tmin > tmax) return vec2(-1., -1.);\n    return vec2(1., tmin / tmax);\n}\n\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 a, vec3 b, vec3 c) { // ray-triangle intersection\n    vec3 e0 = b - a, e1 = c - a, e2 = ro - a;\n    vec3 p = cross(e0, e1);\n    float det = dot(rd, p);\n    if (abs(det) < 0.0001) return vec2(-1., -1.);\n    float invDet = 1. / det;\n    vec3 t = e2 - (e0 * dot(e2, p) * invDet);\n    if (t.x < 0. || t.y < 0. || t.z < 0.) return vec2(-1., -1.);\n    float d = dot(t, rd) * invDet;\n    if (d < 0.) return vec2(-1., -1.);\n    return vec2(1., d);\n}\n\nvec2 rayCylinder(vec3 ro, vec3", "\t\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat r = length(p);\n\tfloat a = 1.0 / (1.0 + n);\n\tfloat b = 1.0 / (1.0 - n);\n\tfloat c = 1.0 / (1.0 - n * n);\n\tfloat d = 1.0 / (1.0 + n * n);\n\tfloat e = 1.0 / (1.0 - n * n * n);\n\tfloat f = 1.0 / (1.0 + n * n * n);\n\tfloat g = 1.0 / (1.0 - n * n * n * n);\n\tfloat h = 1.0 / (1.0 + n * n * n * n);\n\tfloat i = 1.0 / (1.0 - n * n * n * n * n);\n\tfloat j = 1.0 / (1.0 + n * n * n * n * n);\n\tfloat k = 1.0 / (1.0 - n * n * n * n * n * n);\n\tfloat l = 1.0 / (1.0 + n * n * n * n * n * n);\n\tfloat m = 1.0 / (1.0 - n * n * n * n * n * n * n);\n\tfloat n = 1.0 / (1.0 + n * n * n * n * n * n * n);\n\tfloat o = 1.0 / (1.0 - n * n * n * n * n * n * n * n);\n\tfloat p = 1.0 / (1.0 + n * n * n * n * n * n * n * n);\n\tfloat q = 1.0 / (1.0 - n * n * n * n * n * n * n * n * n);\n\tfloat r = 1.0 / (1.0 + n * n * n * n * n * n * n * n * n);\n\tfloat s = 1.0 / (1.0 - n * n * n * n * n * n * n * n * n * n);\n\tfloat t = 1.0 / (1.0 + n * n * n * n * n * n * n * n * n * n);\n\tfloat u = 1.0 / (1.0 -", " \n  float y = 0;\n  int n = 0;\n  while( x > 0.5 )\n  {\n    x = x - 0.5;\n    y = y + 0.5;\n    n = n + 1;\n  }\n  return y + t * pow( 0.5, n );\n}\n\nfloat cantor( float x, float t, float a, float b )\n{\n  float y = 0;\n  int n = 0;\n  while( x > 0.5 )\n  {\n    x = x - 0.5;\n    y = y + 0.5;\n    n = n + 1;\n  }\n  return y + t * pow( 0.5, n ) * ( b - a ) + a;\n}\n\nfloat cantor( float x, float t, float a, float b, float c, float d )\n{\n  float y = 0;\n  int n = 0;\n  while( x > 0.5 )\n  {\n    x = x - 0.5;\n    y = y + 0.5;\n    n = n + 1;\n  }\n  return y + t * pow( 0.5, n ) * ( d - c ) + c;\n}\n\nfloat cantor( float x, float t, float a, float b, float c, float d, float e, float f )\n{\n  float y = 0;\n  int n = 0;\n  while( x > 0.5 )\n  {\n    x = x - 0.5;\n    y = y + 0.5;\n    n = n + 1;\n  }\n  return y + t * pow( 0.5, n ) * ( f - e ) + e;\n}\n\nfloat cantor( float x, float t, float a, float b, float c, float d, float e, float f, float g, float h )\n{\n  float y = 0;\n  int n = 0;\n  while( x > 0.5 )\n  {\n    x = x - 0.5;\n    y = y + 0.5;\n    n = n + 1;\n  }\n  return y + t * pow( 0.5, n ) * ( h - g ) + g;\n}\n\nfloat cantor( float x, float t, float", " \n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float s )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r, in float e )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r, in float e, in float f )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot", " \n    float t = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0", " return y / (x + sqrt(x * x + y * y)); }\n\nfloat atan2_approx(float y, float x) {\n    float a = atan_approx(y, x);\n    return x < 0.0? a + 3.1415926535897932384626433832795 : a;\n}\n\nfloat atan2(float y, float x) {\n    return atan2_approx(y, x);\n}\n\nfloat atan(float x) {\n    return atan_approx(0.0, x);\n}\n\nfloat acos(float x) {\n    return 1.5707963267948966192313216916398 - atan_approx(1.0, x);\n}\n\nfloat asin(float x) {\n    return atan_approx(x, 1.0);\n}\n\nfloat cos(float x) {\n    return 1.0 / sqrt(1.0 + pow(sin(x), 2.0));\n}\n\nfloat sin(float x) {\n    return pow(cos(x), 2.0) - 1.0;\n}\n\nfloat tan(float x) {\n    return sin(x) / cos(x);\n}\n\nfloat pow(float x, float y) {\n    return exp(y * log(x));\n}\n\nfloat exp(float x) {\n    return 1.0 + x + 0.5 * x * x + 0.16666666666666666666666666666667 * x * x * x;\n}\n\nfloat log(float x) {\n    return 0.69314718055994530941723212145818 * x;\n}\n\nfloat sqrt(float x) {\n    return 1.0 / cos(atan_approx(1.0, x));\n}\n\nfloat abs(float x) {\n    return x < 0.0? -x : x;\n}\n\nfloat floor(float x) {\n    return x < 0.0? x - 1.0 : x;\n}\n\nfloat ceil(float x) {\n    return x < 0.0? x + 1.0 : x;\n}\n\nfloat fract(float x) {\n    return x - floor(x);\n}\n\nfloat mod(float x, float y) {\n    return x - y * floor(x / y);\n}\n\nfloat min(float x, float y) {\n    return x < y? x : y;\n}\n\nfloat max(float x, float y) {\n    return x > y? x : y;\n}\n\nfloat length(float x, float y) {\n    return sqrt(x * x + y * y);\n}\n\nfloat length(float x,", " return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2((z.x*w.x + z.y*w.y)/(w.x*w.x + w.y*w.y), (z.y*w.x - z.x*w.y)/(w.x*w.x + w.y*w.y)); }\nvec2 cadd(vec2 z, vec2 w) { return vec2(z.x + w.x, z.y + w.y); }\nvec2 csub(vec2 z, vec2 w) { return vec2(z.x - w.x, z.y - w.y); }\nvec2 cabs(vec2 z) { return vec2(length(z)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(length(z)), atan(z.y, z.x)); }\nvec2 clog2(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog3(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog4(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog5(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog6(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog7(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog8(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog9(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog10(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog11(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog12(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2 clog13(vec2 z) { return vec2(log(z.x), atan(z.y, z.x)); }\nvec2", " \n  return log(z + vec2(1.0, 1.0)) / vec2(1.0, -1.0); \n} \n\n// Inverse hyperbolic cotangent \nvec2 catanh(vec2 z) { \n  return log(z - vec2(1.0, 1.0)) / vec2(1.0, 1.0); \n} \n\n// Inverse hyperbolic secant \nvec2 catanh(vec2 z) { \n  return log(z + vec2(1.0, -1.0)) / vec2(1.0, 1.0); \n} \n\n// Inverse hyperbolic cosecant \nvec2 catanh(vec2 z) { \n  return log(z - vec2(1.0, -1.0)) / vec2(1.0, -1.0); \n} \n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z) { \n  return log(z + vec3(1.0, 1.0, 1.0)) / vec3(1.0, -1.0, -1.0); \n} \n\n// Inverse hyperbolic cotangent \nvec3 catanh(vec3 z) { \n  return log(z - vec3(1.0, 1.0, 1.0)) / vec3(1.0, 1.0, 1.0); \n} \n\n// Inverse hyperbolic secant \nvec3 catanh(vec3 z) { \n  return log(z + vec3(1.0, -1.0, -1.0)) / vec3(1.0, 1.0, 1.0); \n} \n\n// Inverse hyperbolic cosecant \nvec3 catanh(vec3 z) { \n  return log(z - vec3(1.0, -1.0, -1.0)) / vec3(1.0, -1.0, -1.0); \n} \n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z) { \n  return log(z + vec4(1.0, 1.0, 1.0, 1.0)) / vec4(1.0, -1.0, -1.0, -1.0); \n} \n\n// Inverse hyper", " return vec2(cos(z.x), sin(z.x)); }\nvec2 clog(vec2 z) { return vec2(atan(z.y, z.x)); }\nvec2 ctanh(vec2 z) { return clog(cexp(z) - 1.0) / cexp(z); }\n\n// The actual shader\nvec4 effect(vec4 color, Image texture, vec2 texture_coords, vec2 pixel_coords) {\n    vec2 uv = texture_coords;\n    vec2 z = uv;\n    vec2 c = vec2(0.0, 0.0);\n    float i = 0.0;\n    float max_iterations = 100.0;\n    float escape_radius = 4.0;\n    float escape_radius_squared = escape_radius * escape_radius;\n    float escape_radius_squared_inv = 1.0 / escape_radius_squared;\n    float escape_radius_inv = 1.0 / escape_radius;\n    float escape_radius_inv_squared = escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_cubed = escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_fourth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_fifth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_sixth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_seventh = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_eighth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_ninth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_tenth = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv;\n    float escape_radius_inv_eleventh = escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape_radius_inv * escape", " return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2((z.x*w.x + z.y*w.y)/(w.x*w.x + w.y*w.y), (z.y*w.x - z.x*w.y)/(w.x*w.x + w.y*w.y)); }\nvec2 cadd(vec2 z, vec2 w) { return vec2(z.x + w.x, z.y + w.y); }\nvec2 csub(vec2 z, vec2 w) { return vec2(z.x - w.x, z.y - w.y); }\nvec2 cabs(vec2 z) { return vec2(length(z)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(length(z)), atan(z.y, z.x)); }\nvec2 cconj(vec2 z) { return vec2(z.x, -z.y); }\nvec2 csin(vec2 z) { return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y)); }\nvec2 ccos(vec2 z) { return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y)); }\nvec2 ctan(vec2 z) { return csin(z)/ccos(z); }\nvec2 catan(vec2 z) { return cdiv(cmul(z, cconj(z)), csub(cmul(z, z), vec2(1.0))); }\nvec2 csec(vec2 z) { return cdiv(vec2(1.0), ccos(z)); }\nvec2 csech(vec2 z) { return cdiv(vec2(1.0), csin(z)); }\nvec2 ccsch(vec2 z) { return cdiv(vec2(1.0), csch(z)); }\nvec2 ccsch(vec2 z) { return cdiv(vec2(1.0), csch(z)); }\nvec2 ccsch(vec2 z) { return cdiv(vec2(1.0), csch(z)); }\nvec2 ccsch(vec2 z) { return cdiv(vec2(1.0), csch(z)); }\nvec2 ccsch(vec2 z) { return cdiv(vec2", " return vec2(cos(z.x), sin(z.x)); }\nvec2 clog(vec2 z) { return vec2(atan(z.y, z.x)); }\nvec2 clog(vec2 z, float a) { return vec2(atan(z.y, z.x) + a); }\nvec2 clog(vec2 z, float a, float b) { return vec2(atan(z.y, z.x) + a, b); }\nvec2 clog(vec2 z, float a, float b, float c) { return vec2(atan(z.y, z.x) + a, b, c); }\nvec2 clog(vec2 z, float a, float b, float c, float d) { return vec2(atan(z.y, z.x) + a, b, c, d); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e) { return vec2(atan(z.y, z.x) + a, b, c, d, e); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e, float f) { return vec2(atan(z.y, z.x) + a, b, c, d, e, f); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e, float f, float g) { return vec2(atan(z.y, z.x) + a, b, c, d, e, f, g); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e, float f, float g, float h) { return vec2(atan(z.y, z.x) + a, b, c, d, e, f, g, h); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e, float f, float g, float h, float i) { return vec2(atan(z.y, z.x) + a, b, c, d, e, f, g, h, i); }\nvec2 clog(vec2 z, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j) { return vec2(atan(z.y, z.x) + a, b, c", " \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 3 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 4 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 5 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 6 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 7 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 8 value example (https://www.desmos.com/calculator/5jxjxjxjxj)\nvec4 smoothContrast(vec4 alpha, float contrast) { \n    return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum", " //p is the point\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44 = 0.0;\n    float d45 = 0.0;\n    float d46 = 0.0;\n    float d47 = 0.0;\n", " //uvw is in the range [0,1]\n    vec3 u = uvw.x*uvw.x - uvw.y*uvw.y - uvw.z*uvw.z;\n    vec3 v = 2.0*uvw.x*uvw.y;\n    vec3 w = 2.0*uvw.x*uvw.z;\n    return tilingVal3D(u,v,w);\n}\n\nvec3 rohmTileNormal(vec3 uvw) { //uvw is in the range [0,1]\n    vec3 u = uvw.x*uvw.x - uvw.y*uvw.y - uvw.z*uvw.z;\n    vec3 v = 2.0*uvw.x*uvw.y;\n    vec3 w = 2.0*uvw.x*uvw.z;\n    return normalize(u*v + v*w + w*u);\n}\n\nvec3 rohmTileNormal(vec3 uvw, vec3 n) { //uvw is in the range [0,1]\n    vec3 u = uvw.x*uvw.x - uvw.y*uvw.y - uvw.z*uvw.z;\n    vec3 v = 2.0*uvw.x*uvw.y;\n    vec3 w = 2.0*uvw.x*uvw.z;\n    return normalize(u*v + v*w + w*u + n);\n}\n\nvec3 rohmTileNormal(vec3 uvw, vec3 n, vec3 t) { //uvw is in the range [0,1]\n    vec3 u = uvw.x*uvw.x - uvw.y*uvw.y - uvw.z*uvw.z;\n    vec3 v = 2.0*uvw.x*uvw.y;\n    vec3 w = 2.0*uvw.x*uvw.z;\n    return normalize(u*v + v*w + w*u + n + t);\n}\n\nvec3 rohmTileNormal(vec3 uvw, vec3 n, vec3 t, vec3 b) { //uvw is in the range [0,1]\n    vec3 u = uvw.x*uvw.x - uvw.y*uvw.y - uvw.z*uvw.z;\n    vec3 v = 2.0*uvw.x*uvw.y;\n    vec3 w = 2.0*uvw.x*uvw.z;\n    return normalize(u*v + v*w + w*u + n + t + b);\n}\n\nvec3 rohmTileNormal(vec3 uvw, vec3 n", " // offset is in the range [0,1]\n    vec3 uvw2 = uvw * gridRes;\n    vec3 uvw3 = uvw2 * 2.0;\n    vec3 uvw4 = uvw3 * 2.0;\n    vec3 uvw5 = uvw4 * 2.0;\n    vec3 uvw6 = uvw5 * 2.0;\n    vec3 uvw7 = uvw6 * 2.0;\n    vec3 uvw8 = uvw7 * 2.0;\n    vec3 uvw9 = uvw8 * 2.0;\n    vec3 uvw10 = uvw9 * 2.0;\n    vec3 uvw11 = uvw10 * 2.0;\n    vec3 uvw12 = uvw11 * 2.0;\n    vec3 uvw13 = uvw12 * 2.0;\n    vec3 uvw14 = uvw13 * 2.0;\n    vec3 uvw15 = uvw14 * 2.0;\n    vec3 uvw16 = uvw15 * 2.0;\n    vec3 uvw17 = uvw16 * 2.0;\n    vec3 uvw18 = uvw17 * 2.0;\n    vec3 uvw19 = uvw18 * 2.0;\n    vec3 uvw20 = uvw19 * 2.0;\n    vec3 uvw21 = uvw20 * 2.0;\n    vec3 uvw22 = uvw21 * 2.0;\n    vec3 uvw23 = uvw22 * 2.0;\n    vec3 uvw24 = uvw23 * 2.0;\n    vec3 uvw25 = uvw24 * 2.0;\n    vec3 uvw26 = uvw25 * 2.0;\n    vec3 uvw27 = uvw26 * 2.0;\n    vec3 uvw28 = uvw27 * 2.0;\n    vec3 uvw29 = uvw28 * 2.0;\n    vec3 uvw30 = uvw29 * 2.0;\n    vec3 uvw31 = uvw30 * 2.0;\n    vec3 uvw32 = uvw31 * 2.0;\n    vec3 uvw33 = uv", " // 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\n    uvw = uvw * 2.0 - 1.0;\n    uvw = uvw * gridRes;\n    uvw = abs(uvw);\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uvw * uvw;\n    uvw = uv", " //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        float a = dot(p, v[i]);\n        float b = length(p - v[i]);\n        d = max(d, a - b);\n    }\n    return d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) { //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        float a = dot(p, v[i]);\n        float b = length(p - v[i]);\n        d = max(d, a - b);\n    }\n    return d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) { //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        float a = dot(p, v[i]);\n        float b = length(p - v[i]);\n        d = max(d, a - b);\n    }\n    return d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) { //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        float a = dot(p, v[i]);\n        float b = length(p - v[i]);\n        d = max(d, a - b);\n    }\n    return d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) { //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i++) {\n        float a = dot(p, v[i]);\n        float b = length(p - v[i]);\n        d = max(d, a - b);\n    }\n    return d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) { //p is a point on the icosahedron\n    float d = 0.0;\n    for (int i = 0; i < 12; i", " \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) { \n  return vec3(1.0, 1.0 - t, 1.0 - t*t);\n}\n\n// makes", "\t\n    float c = cos(a.x);\n    float s = sin(a.x);\n    float ac = 1.0 - c;\n    float b = c * a.y + s * a.z;\n    float d = s * a.y + c * a.z;\n    float e = c * a.y - s * a.z;\n    float f = -s * a.y + c * a.z;\n    float g = c * a.x;\n    float h = s * a.x;\n    float i = -s * a.x;\n    float j = c * a.x;\n    return vec3(\n        ac * v.x + b * v.y + d * v.z,\n        e * v.x + f * v.y + g * v.z,\n        h * v.x + i * v.y + j * v.z\n    );\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\t\n    float c = cos(a.x);\n    float s = sin(a.x);\n    float ac = 1.0 - c;\n    float b = c * a.y + s * a.z;\n    float d = s * a.y + c * a.z;\n    float e = c * a.y - s * a.z;\n    float f = -s * a.y + c * a.z;\n    float g = c * a.x;\n    float h = s * a.x;\n    float i = -s * a.x;\n    float j = c * a.x;\n    return vec3(\n        ac * v.x + b * v.y + d * v.z,\n        e * v.x + f * v.y + g * v.z,\n        h * v.x + i * v.y + j * v.z\n    );\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\t\n    float c = cos(a.x);\n    float s = sin(a.x);\n    float ac = 1.0 - c;\n    float b = c * a.y + s * a.z;\n    float d = s * a.y + c * a.z;\n    float e = c * a.y - s * a.z;\n    float f = -s * a.y +", " return fract(sin(dot(co.xy, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 co) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 7; i++) {\n        v += a * noise(co);\n        co = rot * co * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm2(vec2 co) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 7; i++) {\n        v += a * noise(co);\n        co = rot * co * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm3(vec2 co", " return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p) { return length(p); }\n\n// Hexagonal Distance from the ", " // uv is in [0,1]x[0,1]\n    vec2 p = uv * 2.0 - 1.0; // [-1,1]x[-1,1]\n    float r = length(p); // radius\n    float a = atan(p.y, p.x); // angle\n    float s = 1.0 / 6.0; // side length\n    float t = 1.0 / 3.0; // triangle height\n    float h = 1.0 / 2.0; // hexagon height\n    float d = 1.0 / 2.0; // distance from center to vertex\n    float c = 1.0 / 2.0; // center of hexagon\n    float b = 1.0 / 2.0; // bottom of hexagon\n    float e = 1.0 / 2.0; // top of hexagon\n    float f = 1.0 / 2.0; // top of triangle\n    float g = 1.0 / 2.0; // bottom of triangle\n    float i = 1.0 / 2.0; // bottom of hexagon\n    float j = 1.0 / 2.0; // top of hexagon\n    float k = 1.0 / 2.0; // top of triangle\n    float l = 1.0 / 2.0; // bottom of triangle\n    float m = 1.0 / 2.0; // bottom of hexagon\n    float n = 1.0 / 2.0; // top of hexagon\n    float o = 1.0 / 2.0; // top of triangle\n    float p = 1.0 / 2.0; // bottom of triangle\n    float q = 1.0 / 2.0; // bottom of hexagon\n    float r = 1.0 / 2.0; // top of hexagon\n    float s = 1.0 / 2.0; // top of triangle\n    float t = 1.0 / 2.0; // bottom of triangle\n    float u = 1.0 / 2.0; // bottom of hexagon\n    float v = 1.0 / 2.0; // top", " \n    t = clamp(t, 0.0, 1.0);\n    t = 1.0 - t;\n    t = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) { \n    t = clamp(t, 0.0, 1.0);\n    t = 1.0 - t;\n    t = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) { \n    t = clamp(t, 0.0, 1.0);\n    t = 1.0 - t;\n    t = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) { \n    t = clamp(t, 0.0, 1.0);\n    t = 1.0 - t;\n    t = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.sh", " return (x + 1) / 2; }\n\n//shifts value range from 0-1 to -1-1\nfloat make-1to1(float x) { return (x * 2) - 1; }\n\n//shifts value range from 0-1 to 0-255\nfloat make0to255(float x) { return x * 255; }\n\n//shifts value range from 0-255 to 0-1\nfloat make255to1(float x) { return x / 255; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255(float x) { return x; }\n\n//shifts value range from 0-255 to 0-255\nfloat make255to255", " \n    float x = uv.x + offset.x;\n    float y = uv.y + offset.y;\n    float x2 = x * gridRes;\n    float y2 = y * gridRes;\n    float x3 = x2 * 0.5;\n    float y3 = y2 * 0.5;\n    float x4 = x3 * 0.5;\n    float y4 = y3 * 0.5;\n    float x5 = x4 * 0.5;\n    float y5 = y4 * 0.5;\n    float x6 = x5 * 0.5;\n    float y6 = y5 * 0.5;\n    float x7 = x6 * 0.5;\n    float y7 = y6 * 0.5;\n    float x8 = x7 * 0.5;\n    float y8 = y7 * 0.5;\n    float x9 = x8 * 0.5;\n    float y9 = y8 * 0.5;\n    float x10 = x9 * 0.5;\n    float y10 = y9 * 0.5;\n    float x11 = x10 * 0.5;\n    float y11 = y10 * 0.5;\n    float x12 = x11 * 0.5;\n    float y12 = y11 * 0.5;\n    float x13 = x12 * 0.5;\n    float y13 = y12 * 0.5;\n    float x14 = x13 * 0.5;\n    float y14 = y13 * 0.5;\n    float x15 = x14 * 0.5;\n    float y15 = y14 * 0.5;\n    float x16 = x15 * 0.5;\n    float y16 = y15 * 0.5;\n    float x17 = x16 * 0.5;\n    float y17 = y16 * 0.5;\n    float x18 = x17 * 0.5;\n    float y18 = y17 * 0.5;\n    float x19 = x18 * 0.5;\n    float y19 = y18 * 0.5;\n    float x20 = x19 * 0.5;\n    float y20 = y19 * 0.5;\n    float x", " // 3 hex pixaled flowing sin thier edges get hidden by each other\n    float x = sin(uv.x * gridRes + time) * len;\n    float y = sin(uv.y * gridRes + time) * len;\n    float z = sin(uv.x * gridRes + time) * len;\n    return x + y + z;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) { // 3 hex pixaled flowing sin thier edges get hidden by each other\n    float x = sin(uv.x * gridRes + time) * len;\n    float y = sin(uv.y * gridRes + time) * len;\n    float z = sin(uv.x * gridRes + time) * len;\n    return x + y + z;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) { // 3 hex pixaled flowing sin thier edges get hidden by each other\n    float x = sin(uv.x * gridRes + time) * len;\n    float y = sin(uv.y * gridRes + time) * len;\n    float z = sin(uv.x * gridRes + time) * len;\n    return x + y + z;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) { // 3 hex pixaled flowing sin thier edges get hidden by each other\n    float x = sin(uv.x * gridRes + time) * len;\n    float y = sin(uv.y * gridRes + time) * len;\n    float z = sin(uv.x * gridRes + time) * len;\n    return x + y + z;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) { // 3 hex pixaled flowing sin thier edges get hidden by each other\n    float x = sin(uv.x * gridRes + time) * len;\n    float y = sin(uv.y * gridRes + time) * len;\n    float z = sin", " \n  float angle = atan(point.y, point.x);\n  float distance = length(point);\n  float speed = 0.5;\n  float strength = 0.5;\n  float timeFactor = 0.5;\n  float flow = strength * sin(angle * speed + time * timeFactor) * (1.0 - distance / radius);\n  return vec2(flow, 0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) { \n  float angle = atan(point.y, point.x);\n  float distance = length(point);\n  float speed = 0.5;\n  float strength = 0.5;\n  float timeFactor = 0.5;\n  float flow = strength * sin(angle * speed + time * timeFactor) * (1.0 - distance / radius);\n  return vec2(flow, 0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) { \n  float angle = atan(point.y, point.x);\n  float distance = length(point);\n  float speed = 0.5;\n  float strength = 0.5;\n  float timeFactor = 0.5;\n  float flow = strength * sin(angle * speed + time * timeFactor) * (1.0 - distance / radius);\n  return vec2(flow, 0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) { \n  float angle = atan(point.y, point.x);\n  float distance = length(point);\n  float speed = 0.5;\n  float strength = 0.5;\n  float timeFactor = 0.5;\n  float flow = strength * sin(angle * speed + time * timeFactor) * (1.0 - distance / radius);\n  return vec2(flow, 0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) { \n  float angle = atan(point.y, point.x);\n  float distance = length(point);\n  float speed = 0.5;\n  float strength = 0.5;\n  float timeFactor = 0.5;\n  float flow = strength * sin(angle * speed + time * timeFactor) *", " return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2(0.5, 0.5); }\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) { return pos - vec2", " \n    vec2 v = p2 - p1;\n    vec2 w = p - p1;\n    float c1 = dot(w, v);\n    float c2 = dot(v, v);\n    float b = c1 / c2;\n    vec2 pb = p1 + b * v;\n    return length(pb - p);\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) { \n    return length(p - c) - r;\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) { \n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return length(v2 - u * v0 - v * v1);\n}\n\n// Computes the signed distance from a square\nfloat square(vec2 p, vec2 c, float s) { \n    return length(p - c) - s;\n}\n\n// Computes the signed distance from a rectangle\nfloat rectangle(vec2 p, vec2 c, vec2 s) { \n    return max(abs(p.x - c.x) - s.x, abs(p.y - c.y) - s.y);\n}\n\n// Computes the signed distance from a polygon\nfloat polygon(vec2 p, vec2[] v, int n) { \n    float d = 0.0;\n    for (int i = 0; i < n; i++) {\n        vec2 e1 = v[i] - p;\n        vec2 e2 = v[(i+1) % n] - p;\n        float c = cross(e1, e2);\n        if (c < 0.0) d = max(d, -dot(e1, vec2(0.0, 1.", " \n  float d = length(p - v);\n  return d - 0.5;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len) { \n  float d = length(p - v);\n  return d - len;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len, float width) { \n  float d = length(p - v);\n  return d - len + width;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len, float width, float height) { \n  float d = length(p - v);\n  return d - len + width + height;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len, float width, float height, float depth) { \n  float d = length(p - v);\n  return d - len + width + height + depth;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len, float width, float height, float depth, float radius) { \n  float d = length(p - v);\n  return d - len + width + height + depth + radius;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float len, float width, float height, float depth, float radius, float thickness) { \n  float d = length(p - v);\n  return d - len + width + height + depth + radius + thickness;\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\n", " return (x + vec2(1.0)) / 2.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 make-1to1(vec2 x) { return (x * 2.0) - vec2(1.0); }\n\n//shifts value range from 0-1 to 0-1\nvec2 make0to0(vec2 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec2 make-1to-1(vec2 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nvec2 make0to0(vec3 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec2 make-1to-1(vec3 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nvec2 make0to0(vec4 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec2 make-1to-1(vec4 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nvec3 make0to0(vec3 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec3 make-1to-1(vec3 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nvec3 make0to0(vec4 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec3 make-1to-1(vec4 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nvec4 make0to0(vec4 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nvec4 make-1to-1(vec4 x) { return x; }\n\n//shifts value range from 0-1 to 0-1\nmat2 make0to0(mat2 x) { return x; }\n\n//shifts value range from -1-1 to -1-1\nmat2 make-1to-1(mat2 x) { return x; }\n\n", "\t\n\tfloat angle = atan(point.y, point.x);\n\tfloat radius = length(point);\n\t\n\tfloat angleOffset = angle + offset;\n\t\n\tfloat radiusOffset = radius + spread;\n\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius)\n{\t\n\tfloat angle = atan(point.y, point.x);\n\tfloat radius = length(point);\n\t\n\tfloat angleOffset = angle + offset;\n\t\n\tfloat radiusOffset = radius + spread;\n\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle)\n{\t\n\tfloat angleOffset = angle + offset;\n\t\n\tfloat radiusOffset = radius + spread;\n\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleOffset)\n{\t\n\tfloat radiusOffset = radius + spread;\n\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleOffset, float radiusOffset)\n{\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleOffset, float radiusOffset, float x)\n{\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleOffset, float radiusOffset, float x, float y)\n{\t\n\treturn vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n", " \n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( in vec4 p, in vec4 b ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0);\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r - s;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s, in float t ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r - s - t;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s, in float t, in float u ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r - s - t - u;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s, in float t, in float u, in float v ) \n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r - s - t", "\t\n\t// the base shape\n\tfloat sd = sdStar( p, id, sp );\n\t\n\t// the base shape with a twist\n\tfloat sd2 = sdStar( p, id, sp, time );\n\t\n\t// the base shape with a twist and a twist\n\tfloat sd3 = sdStar( p, id, sp, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist\n\tfloat sd4 = sdStar( p, id, sp, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist\n\tfloat sd5 = sdStar( p, id, sp, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist\n\tfloat sd6 = sdStar( p, id, sp, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist and a twist\n\tfloat sd7 = sdStar( p, id, sp, time, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist and a twist and a twist\n\tfloat sd8 = sdStar( p, id, sp, time, time, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist\n\tfloat sd9 = sdStar( p, id, sp, time, time, time, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist\n\tfloat sd10 = sdStar( p, id, sp, time, time, time, time, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist and a twist\n\tfloat sd11 = sdStar( p, id, sp, time, time, time, time, time, time, time, time, time, time );\n\t\n\t// the base shape with a twist and a twist and a twist and a twist", "\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\t\n\tfloat a = atan(p.x, p.y) + time;\n\tfloat r = length(p) * sp;\n\treturn r - ra * cos(a);\n}\n\n", " return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) { return length(uvw); }\n\n", " // uvw is in [-1,1]^3\n    vec3 uv = uvw * 0.5 + 0.5;\n    vec3 w = abs(uv - 0.5) - 0.5;\n    vec3 x = step(w.z, 0.0) - step(w.x, 0.0);\n    vec3 y = step(w.x, 0.0) - step(w.y, 0.0);\n    vec3 z = step(w.y, 0.0) - step(w.z, 0.0);\n    return vec4(x, y, z, 1.0);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) { // uvw is in [-1,1]^3\n    vec3 uv = uvw * 0.5 + 0.5;\n    vec3 w = abs(uv - 0.5) - 0.5;\n    vec3 x = step(w.z, 0.0) - step(w.x, 0.0);\n    vec3 y = step(w.x, 0.0) - step(w.y, 0.0);\n    vec3 z = step(w.y, 0.0) - step(w.z, 0.0);\n    return vec4(x, y, z, 1.0);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) { // uvw is in [-1,1]^3\n    vec3 uv = uvw * 0.5 + 0.5;\n    vec3 w = abs(uv - 0.5) - 0.5;\n    vec3 x = step(w.z, 0.0) - step(w.x, 0.0);\n    vec3 y = step(w.x, 0.0) - step(w.y, 0.0);\n    vec3 z = step(w.y, 0.0) - step(w.z, 0.0);\n    return vec4(x, y, z, 1.0);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) { // uvw is in [-1,1]^3\n    vec3 uv = uvw * 0.5 + 0.5;\n    vec3 w = abs(uv - 0.5) - 0.5;\n    vec3", " // uvw is in [-1,1]\n    vec3 cell = uvw * gridRes + offset;\n    vec3 cellFloor = floor(cell);\n    vec3 cellFract = fract(cell);\n    vec3 cellOffset = cellFloor * gridRes;\n    vec3 cellOffsetFract = cellOffset + cellFract;\n    vec3 cellOffsetFloor = floor(cellOffsetFract);\n    vec3 cellOffsetFract2 = cellOffsetFract - cellOffsetFloor;\n    vec3 cellOffsetFloor2 = cellOffsetFloor - cellOffset;\n    vec3 cellOffsetFract3 = cellOffsetFract2 - cellOffsetFloor2;\n    vec3 cellOffsetFloor3 = cellOffsetFloor2 - cellOffsetFloor;\n    vec3 cellOffsetFract4 = cellOffsetFract3 - cellOffsetFloor3;\n    vec3 cellOffsetFloor4 = cellOffsetFloor3 - cellOffsetFloor;\n    vec3 cellOffsetFract5 = cellOffsetFract4 - cellOffsetFloor4;\n    vec3 cellOffsetFloor5 = cellOffsetFloor4 - cellOffsetFloor;\n    vec3 cellOffsetFract6 = cellOffsetFract5 - cellOffsetFloor5;\n    vec3 cellOffsetFloor6 = cellOffsetFloor5 - cellOffsetFloor;\n    vec3 cellOffsetFract7 = cellOffsetFract6 - cellOffsetFloor6;\n    vec3 cellOffsetFloor7 = cellOffsetFloor6 - cellOffsetFloor;\n    vec3 cellOffsetFract8 = cellOffsetFract7 - cellOffsetFloor7;\n    vec3 cellOffsetFloor8 = cellOffsetFloor7 - cellOffsetFloor;\n    vec3 cellOffsetFract9 = cellOffsetFract8 - cellOffsetFloor8;\n    vec3 cellOffsetFloor9 = cellOffsetFloor8 - cellOffsetFloor;\n    vec3 cellOffsetFract10 = cellOffsetFract9 - cellOffsetFloor9;\n    vec3 cellOffsetFloor10 = cellOffsetFloor9 - cellOffsetFloor;\n    vec3 cellOffsetFract11 = cellOffsetFract10 - cellOffsetFloor10;\n    vec3 cellOffsetFloor11 = cellOffsetFloor10 - cellOffsetFloor;\n    vec3 cellOffsetFract12 = cellOffsetFract11 - cellOffsetFloor11;\n    vec3 cellOffsetFloor12 = cellOffsetFloor11 - cellOffsetFloor;\n    vec3 cellOffsetFract13 = cellOffsetFract12 - cellOffsetFloor12;\n    vec3 cellOffsetFloor13", " \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, 0.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) { \n    return vec3(0.0, 0.0, ", " //p is the point\n    float d = 0.0;\n    d = max(d, abs(p.x));\n    d = max(d, abs(p.y));\n    d = max(d, abs(p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) { //p is the point\n    float d = 0.0;\n    d = max(d, abs(p.x));\n    d = max(d, abs(p.y));\n    d = max(d, abs(p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    d = max(d, abs(p.x + p.y + p.z));\n    d = max(d, abs(p.x - p.y + p.z));\n    d = max(d, abs(p.x + p.y - p.z));\n    d = max(d, abs(p.x - p.y - p.z));\n    return d;\n}\n\n//Distance from the Edge of D", " \n    return vec3(0.0, 0.0, 1.0) * pow(1.0 - t, 6.0);\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) { \n    return vec3(1.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) { \n    return vec3(1.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) { \n    return vec3(1.0, 0.0, 0.0) * pow(1.0 - t, 6.0);\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) { \n    return vec3(1.0, 0.0, 0.0) * pow(1.0 - t, 6.0) + vec3(0.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) { \n    return vec3(1.0, 0.0, 0.0) * pow(1.0 - t, 6.0) + vec3(0.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) { \n    return vec3(1.0, 0.0, 0.0) * pow(1.0 - t, 6.0) + vec3(0.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) { \n    return vec3(1.0, 0.0, 0.0) * pow(1.0 - t, 6.0) + vec3(0.0, 1.0, 0.0) * pow(t, 6.0);\n}\n\n// makes rainbow colormap with polynimal", " return vec3(uv, 0.0); }\n\n// simple diamond Tiling\nvec3 diamondTile(vec2 uv) { return vec3(uv, sqrt(3.0)); }\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) / 2.0); }\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) { return vec3(uv, sqrt(3.0) /", " //uv is in [0,1] range\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = 1.0 - d;\n    return vec3(r * cos(a), r * sin(a), 1.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size) { //uv is in [0,1] range\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = size - d;\n    return vec3(r * cos(a), r * sin(a), 1.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset) { //uv is in [0,1] range\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = size - d + offset;\n    return vec3(r * cos(a), r * sin(a), 1.0);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale) { //uv is in [0,1] range\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = size - d + offset;\n    return vec3(r * cos(a), r * sin(a), scale);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale, float rotation) { //uv is in [0,1] range\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = size - d + offset;\n    return vec3(r * cos(a + rotation), r * sin(a + rotation), scale);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float size, float offset, float scale, float rotation", " \n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 frac = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if (frac.x < 0.5) {\n        if (frac.y < 0.5) {\n            color = vec3(1.0);\n        } else {\n            color = vec3(0.0);\n        }\n    } else {\n        if (frac.y < 0.5) {\n            color = vec3(0.0);\n        } else {\n            color = vec3(1.0);\n        }\n    }\n    return color;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes) { \n    return squarePixelizor(uv, gridRes, vec2(0.0));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset) { \n    return squarePixelizor(uv, gridRes, vec2(offset, offset));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float offset2) { \n    return squarePixelizor(uv, gridRes, vec2(offset, offset2));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float offset2, float offset3) { \n    return squarePixelizor(uv, gridRes, vec2(offset, offset2, offset3));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float offset2, float offset3, float offset4) { \n    return squarePixelizor(uv, gridRes, vec2(offset, offset2, offset3, offset4));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float offset2, float offset3, float offset4, float offset5) { \n    return squarePixelizor(uv, gridRes, vec2(offset, offset2, offset3, offset4, offset5));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, float offset, float offset2, float", " // uv is in range [0,1]\n    vec2 grid = floor(uv * gridRes);\n    vec2 offset = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if (offset.x < 0.5) {\n        color = vec3(1.0);\n    } else {\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) { // uv is in range [0,1]\n    vec2 grid = floor(uv * gridRes);\n    vec2 offset = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if (offset.x < 0.5) {\n        color = vec3(1.0);\n    } else {\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) { // uv is in range [0,1]\n    vec2 grid = floor(uv * gridRes);\n    vec2 offset = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if (offset.x < 0.5) {\n        color = vec3(1.0);\n    } else {\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) { // uv is in range [0,1]\n    vec2 grid = floor(uv * gridRes);\n    vec2 offset = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if (offset.x < 0.5) {\n        color = vec3(1.0);\n    } else {\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) { // uv is in range [0,1]\n    vec2 grid = floor(uv * gridRes);\n    vec2 offset = fract(uv * gridRes);\n    vec3 color = vec3(0.0);\n    if", " \n    float x = uv.x + offset.x;\n    float y = uv.y + offset.y;\n    float x2 = x * gridRes;\n    float y2 = y * gridRes;\n    float x3 = x2 * 3.0;\n    float y3 = y2 * 3.0;\n    float x4 = x3 * 3.0;\n    float y4 = y3 * 3.0;\n    float x5 = x4 * 3.0;\n    float y5 = y4 * 3.0;\n    float x6 = x5 * 3.0;\n    float y6 = y5 * 3.0;\n    float x7 = x6 * 3.0;\n    float y7 = y6 * 3.0;\n    float x8 = x7 * 3.0;\n    float y8 = y7 * 3.0;\n    float x9 = x8 * 3.0;\n    float y9 = y8 * 3.0;\n    float x10 = x9 * 3.0;\n    float y10 = y9 * 3.0;\n    float x11 = x10 * 3.0;\n    float y11 = y10 * 3.0;\n    float x12 = x11 * 3.0;\n    float y12 = y11 * 3.0;\n    float x13 = x12 * 3.0;\n    float y13 = y12 * 3.0;\n    float x14 = x13 * 3.0;\n    float y14 = y13 * 3.0;\n    float x15 = x14 * 3.0;\n    float y15 = y14 * 3.0;\n    float x16 = x15 * 3.0;\n    float y16 = y15 * 3.0;\n    float x17 = x16 * 3.0;\n    float y17 = y16 * 3.0;\n    float x18 = x17 * 3.0;\n    float y18 = y17 * 3.0;\n    float x19 = x18 * 3.0;\n    float y19 = y18 * 3.0;\n    float x20 = x19 * 3.0;\n    float y20 = y19 * 3.0;\n    float x", " // 0.0 to 1.0\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float x6 = x5 * x;\n    float y6 = y5 * y;\n    float x7 = x6 * x;\n    float y7 = y6 * y;\n    float x8 = x7 * x;\n    float y8 = y7 * y;\n    float x9 = x8 * x;\n    float y9 = y8 * y;\n    float x10 = x9 * x;\n    float y10 = y9 * y;\n    float x11 = x10 * x;\n    float y11 = y10 * y;\n    float x12 = x11 * x;\n    float y12 = y11 * y;\n    float x13 = x12 * x;\n    float y13 = y12 * y;\n    float x14 = x13 * x;\n    float y14 = y13 * y;\n    float x15 = x14 * x;\n    float y15 = y14 * y;\n    float x16 = x15 * x;\n    float y16 = y15 * y;\n    float x17 = x16 * x;\n    float y17 = y16 * y;\n    float x18 = x17 * x;\n    float y18 = y17 * y;\n    float x19 = x18 * x;\n    float y19 = y18 * y;\n    float x20 = x19 * x;\n    float y20 = y19 * y;\n    float x21 = x20 * x;\n    float y21 = y20 * y;\n    float x22 = x21 * x;\n    float y22 = y21 * y;\n    float x23 = x22 * x;\n    float y23 = y22 * y;\n    float x24 = x23 * x;\n    float y24 = y23 * y;\n    float x25 = x24 * x;\n    float y25 = y24 * y;\n    float x", "\t\n\tvec2  ip = floor( p );\n\tvec2  fp = fract( p );\n\tvec2  id = floor( ddx );\n\tvec2  fd = fract( ddx );\n\tvec2  jd = floor( ddy );\n\tvec2  jd2 = floor( ddy * 0.5 );\n\tvec2  jd3 = floor( ddy * 0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", " // hexagon\n    float d = length(p);\n    float a = atan(p.y, p.x) + PI;\n    float h = 0.5 + 0.5 * cos(a * 6.0);\n    return d - r * h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon2(vec2 p, float r) { // hexagon\n    float d = length(p);\n    float a = atan(p.y, p.x) + PI;\n    float h = 0.5 + 0.5 * cos(a * 6.0);\n    return d - r * h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon3(vec2 p, float r) { // hexagon\n    float d = length(p);\n    float a = atan(p.y, p.x) + PI;\n    float h = 0.5 + 0.5 * cos(a * 6.0);\n    return d - r * h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon4(vec2 p, float r) { // hexagon\n    float d = length(p);\n    float a = atan(p.y, p.x) + PI;\n    float h = 0.5 + 0.5 * cos(a * 6.0);\n    return d - r * h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon5(vec2 p, float r) { // hexagon\n    float d = length(p);\n    float a = atan(p.y, p.x) + PI;\n    float h = 0.5 + 0.5 * cos(a * 6.0);\n    return d - r * h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon6(vec2 p, float r) { // hex", " // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * 0.5) * 2.0 - 1.0;\n    p = abs(p);\n    p = fract(p * 0.5) * 2.0 - 1.0;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p, float scale) { // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * scale) * 2.0 - 1.0;\n    p = abs(p);\n    p = fract(p * scale) * 2.0 - 1.0;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p, float scale, float offset) { // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    p = abs(p);\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p, float scale, float offset, float offset2) { // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * scale + offset) * 2.0 - 1.0;\n    p = abs(p);\n    p = fract(p * scale + offset2) * 2.0 - 1.0;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p, float scale, float offset, float offset2, float offset3) { // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * scale + offset) * ", " return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec2 x )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec3 x )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec4 x )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec2 x, in float t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec3 x, in float t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec4 x, in float t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec2 x, in vec2 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec3 x, in vec2 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec4 x, in vec2 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec2 x, in vec3 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec3 x, in vec3 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec4 x, in vec3 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec2 x, in vec4 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec3 x, in vec4 t )\n{ return 1.0 - 2.0 * abs( x - 0.5 ); }\n\nfloat fun( in vec4 x, in vec4 t )\n{ return 1.0", " return t * t * (3.0 - 2.0 * t); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec3 t) { return t * t * (3.0 - 2.0 * t); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1.0); }\nvec3 sRGB(vec2 t) { return vec3(t.x, t.y, 1.0); }\nvec3 sRGB(vec4 t) { return vec3(t.xy, 1", " return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df1(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df2(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df3(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df4(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df5(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df6(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df7(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df8(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df9(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df10(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df11(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df12(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df13(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat df", " return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df2(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df3(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df4(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df5(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df6(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df7(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df8(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df9(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df10(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df11(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df12(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df13(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df14(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df15(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df16(vec2 p) { return sin(p.y*3.0+sin(p.x*3.0)*2.0); }\nfloat df17(vec2 p) { return sin(p.x*3.0+sin(p.y*3.0)*2.0); }\nfloat df18(vec2 p) { return sin", "\t\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\t\n\tvec2 p1p0 = p - p0;\n\tvec2 p2p1 = p - p1;\n\tvec2 p0p2 = p - p2;\n\t\n\tfloat D = 1.0 / (e0.x * e2.y - e0.y * e2.x);\n\tfloat s = D * (e2.x * p1p0.y - e2.y * p1p0.x);\n\tfloat t = D * (e0.y * p2p1.x - e0.x * p2p1.y);\n\t\n\tif( (s < 0.0) || (t < 0.0) || (s + t > 1.0) )\n\t\treturn length(p - p0);\n\t\n\treturn length(p - p0) - 1.0;\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in float radius )\n{\t\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\t\n\tvec2 p1p0 = p - p0;\n\tvec2 p2p1 = p - p1;\n\tvec2 p0p2 = p - p2;\n\t\n\tfloat D = 1.0 / (e0.x * e2.y - e0.y * e2.x);\n\tfloat s = D * (e2.x * p1p0.y - e2.y * p1p0.x);\n\tfloat t = D * (e0.y * p2p1.x - e0.x * p2p1.y);\n\t\n\tif( (s < 0.0) || (t < 0.0) || (s + t > 1.0) )\n\t\treturn length(p - p0) - radius;\n\t\n\treturn length(p - p0) - radius;\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in float radius, in float radius2 )\n{\t\n\tvec2 e0 = p1 - p0;\n\tvec2 e", " // sph = sphere, dbuffer = distance buffer\n    float b = dot(sph.xyz, rd);\n    float c = dot(sph.xyz, sph.xyz) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return dbuffer;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 < 0.0) t1 = t2;\n    if (t1 < 0.0) return dbuffer;\n    return t1;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, vec3(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder(vec3 p, vec2 h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0))) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p", " return abs(p.x) < r? sign(p.x) * sqrt(r*r - p.x*p.x) : p.x - sign(p.x) * w; }\nfloat roundedY(vec2 p, float w, float r) { return abs(p.y) < r? sign(p.y) * sqrt(r*r - p.y*p.y) : p.y - sign(p.y) * w; }\nfloat rounded(vec2 p, float w, float r) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)); }\nfloat rounded(vec2 p, float w, float r, float a) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a); }\nfloat rounded(vec2 p, float w, float r, float a, float b) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a) + b; }\nfloat rounded(vec2 p, float w, float r, float a, float b, float c) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a) + b * sin(a) + c; }\nfloat rounded(vec2 p, float w, float r, float a, float b, float c, float d) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a) + b * sin(a) + c * cos(a) + d * sin(a); }\nfloat rounded(vec2 p, float w, float r, float a, float b, float c, float d, float e) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a) + b * sin(a) + c * cos(a) + d * sin(a) + e; }\nfloat rounded(vec2 p, float w, float r, float a, float b, float c, float d, float e, float f) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos(a) + b * sin(a) + c * cos(a) + d * sin(a) + e * cos(a) + f * sin(a); }\nfloat rounded(vec2 p, float w, float r, float a, float b, float c, float d, float e, float f, float g) { return sqrt(r*r - min(p.x*p.x, p.y*p.y)) * cos", "\t\n\tfloat a = 1.0 / (1.0 - k);\n\tfloat b = 1.0 / (1.0 + k);\n\t\n\tfloat d = length( p );\n\t\n\treturn (a * d - b) / (a * d + b);\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\t\n\tfloat a = 1.0 / (1.0 - k);\n\tfloat b = 1.0 / (1.0 + k);\n\t\n\tfloat d = length( p );\n\t\n\treturn (a * d - b) / (a * d + b);\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\t\n\tfloat a = 1.0 / (1.0 - k);\n\tfloat b = 1.0 / (1.0 + k);\n\t\n\tfloat d = length( p );\n\t\n\treturn (a * d - b) / (a * d + b);\n}", "\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d - a;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a, in float b )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d - a - b;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a, in float b, in float c )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d - a - b - c;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a, in float b, in float c, in float d )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d - a - b - c - d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a, in float b, in float c, in float d, in float e )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0, 0.0 ) );\n\treturn d - a - b - c - d - e;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float a, in float b, in float c, in float d, in float e, in float f )\n{\t\n\tvec2 q = vec2( p.x, p.y * p.x );\n\tfloat d = length( q - vec2( 1.0,", " return (a < b - k)? a : b - k; }\nfloat pmax(float a, float b, float k) { return (a > b + k)? a : b + k; }\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) { return 0.5 * (k + pmin(a, b, k)); }\nfloat smax(float a, float b, float k) { return 0.5 * (k + pmax(a, b, k)); }\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) { return 0.5 * (k + pmin(a, b, k)); }\nfloat smax(float a, float b, float k) { return 0.5 * (k + pmax(a, b, k)); }\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) { return 0.5 * (k + pmin(a, b, k)); }\nfloat smax(float a, float b, float k) { return 0.5 * (k + pmax(a, b, k)); }\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) { return 0.5 * (k + pmin(a, b, k)); }\nfloat smax(float a, float b, float k) { return 0.5 * (k + pmax(a, b, k)); }\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) { return 0.5 * (k + pmin(a, b, k)); }\nfloat smax(float a, float b, float k) { return 0.5 * (k + pmax(a, b,", " return abs(a) < k? a : sign(a) * k; }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmin(float a, float b, float k) { return min(a, b) < k? a : min(a, b); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) { return max(a, b) < k? a : max(a, b); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pstep(float a, float b, float k) { return a < b? a : pmin(a, b, k); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp(float a, float b, float k) { return a < b? a : pmax(a, b, k); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float a, float b, float k) { return pstep(a, b, k) - pstep(a - k, b, k); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float a, float b, float k, float t) { return psmoothstep(pmin(a, b, k), pmax(a, b, k), k, t); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float a, float b, float k, float t, float m) { return psmoothstep(pmin(a, b, k), pmax(a, b, k), k, t, m); }\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float a, float b, float k, float t, float m, float n) { return psmoothstep(pmin(a", " // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart2(vec2 p) { // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart3(vec2 p) { // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart4(vec2 p) { // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart5(vec2 p) { // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart6(vec2 p) { // heart\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = cos(r*3.5-a*2.3)*r*.5;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions", " return fract(sin(p.x * 123.456 + p.y * 789.012) * 123.456); }\nfloat hash12(vec3 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456) * 123.456); }\nfloat hash12(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash13(vec3 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456) * 123.456); }\nfloat hash13(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash14(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash15(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash16(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash17(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash18(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash19(vec4 p) { return fract(sin(p.x * 123.456 + p.y * 789.012 + p.z * 321.456 + p.w * 456.789) * 123.456); }\n\nfloat hash", "\t\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\t\n\tvec2 pa = b - a;\n\tvec2 pb = c - b;\n\tvec2 pc = a - c;\n\t\n\tvec2 q = cross( pb, pc );\n\tfloat o = 1.0 / dot( pa, q );\n\t\n\tvec2 r1 = o * cross( pa, pb );\n\tvec2 r2 = o * cross( pa, pc );\n\t\n\tvec2 ra = r1 + r2;\n\tvec2 rb = r2 + q;\n\t\n\tvec2 ca = dot( p - a, ra );\n\tvec2 cb = dot( p - b, rb );\n\t\n\tfloat h = clamp( (ca * cb - 1.0) * SIGN( cb ), 0.0, 1.0 );\n\t\n\treturn vec3( mix( mix( a, b, ca ), mix( b, c, cb ), h ), h );\n}\n\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\t\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 d = D;\n\t\n\tvec2 pa = b - a;\n\tvec2 pb = c - b;\n\tvec2 pc = d - c;\n\tvec2 pd = a - d;\n\t\n\tvec2 q = cross( pb, pc );\n\tfloat o = 1.0 / dot( pa, q );\n\t\n\tvec2 r1 = o * cross( pa, pb );\n\tvec2 r2 = o * cross( pa, pc );\n\tvec2 r3 = o * cross( pa, pd );\n\t\n\tvec2 ra = r1 + r2 + r3;\n\tvec2 rb = r2 + r3 + q;\n\tvec2 rc = r3 + q + cross( pb, pc );\n\t\n\tvec2 ca = dot( p - a, ra );\n\tvec2 cb = dot( p - b, rb );\n\tvec2 cc = dot( p - c, rc );\n\t\n\tfloat h = clamp( (ca * cb * cc - 1.0) * SIGN( cb * cc ), 0.0, 1.0 );\n\t\n\treturn vec3( mix( mix( mix( a, b, ca ), mix( b, c, cb ), cc ), mix( mix( b,", "\t\n\tvec2 p = pos / vec2(wi, he);\n\t\n\tfloat x = p.x;\n\tfloat y = p.y;\n\t\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\t\n\tfloat x3 = x2 * x;\n\tfloat y3 = y2 * y;\n\t\n\tfloat x4 = x2 * x2;\n\tfloat y4 = y2 * y2;\n\t\n\tfloat x5 = x4 * x;\n\tfloat y5 = y4 * y;\n\t\n\tfloat x6 = x4 * x2;\n\tfloat y6 = y4 * y2;\n\t\n\tfloat x7 = x6 * x;\n\tfloat y7 = y6 * y;\n\t\n\tfloat x8 = x6 * x2;\n\tfloat y8 = y6 * y2;\n\t\n\tfloat x9 = x8 * x;\n\tfloat y9 = y8 * y;\n\t\n\tfloat x10 = x8 * x2;\n\tfloat y10 = y8 * y2;\n\t\n\tfloat x11 = x10 * x;\n\tfloat y11 = y10 * y;\n\t\n\tfloat x12 = x10 * x2;\n\tfloat y12 = y10 * y2;\n\t\n\tfloat x13 = x12 * x;\n\tfloat y13 = y12 * y;\n\t\n\tfloat x14 = x12 * x2;\n\tfloat y14 = y12 * y2;\n\t\n\tfloat x15 = x14 * x;\n\tfloat y15 = y14 * y;\n\t\n\tfloat x16 = x14 * x2;\n\tfloat y16 = y14 * y2;\n\t\n\tfloat x17 = x16 * x;\n\tfloat y17 = y16 * y;\n\t\n\tfloat x18 = x16 * x2;\n\tfloat y18 = y16 * y2;\n\t\n\tfloat x19 = x18 * x;\n\tfloat y19 = y18 * y;\n\t\n\tfloat x20 = x18 * x2;\n\tfloat y20 = y18 * y2;\n\t\n\tfloat x21 = x20 * x;\n\tfloat y21 = y20 * y;\n\t\n\tfloat x22 = x20 * x2;\n\tfloat y22 = y20 * y2;\n\t\n\tfloat x23 = x22 * x;\n\tfloat y23 = y22 * y;\n\t\n\tfloat x24 = x22 * x2;\n\tfloat y24 = y22 * y2;\n\t\n\tfloat x25 = x24 * x;\n\tfloat y25 = y24 * y;\n\t\n\tfloat x26 = x24 * x", "\t\n\treturn vec3( pos.x, pos.y, k * ( pos.x * pos.x + pos.y * pos.y ) );\n}\n\nvec3 sdParabola( in vec2 pos, in float k, in vec2 p )\n{\t\n\treturn vec3( pos.x - p.x, pos.y - p.y, k * ( ( pos.x - p.x ) * ( pos.x - p.x ) + ( pos.y - p.y ) * ( pos.y - p.y ) ) );\n}\n\nvec3 sdParabola( in vec2 pos, in float k, in vec2 p, in vec2 n )\n{\t\n\treturn vec3( pos.x - p.x, pos.y - p.y, k * ( ( pos.x - p.x ) * ( pos.x - p.x ) + ( pos.y - p.y ) * ( pos.y - p.y ) ) - dot( n, pos - p ) );\n}\n\nvec3 sdParabola( in vec2 pos, in float k, in vec2 p, in vec2 n, in float r )\n{\t\n\treturn vec3( pos.x - p.x, pos.y - p.y, k * ( ( pos.x - p.x ) * ( pos.x - p.x ) + ( pos.y - p.y ) * ( pos.y - p.y ) ) - dot( n, pos - p ) - r );\n}\n\nvec3 sdParabola( in vec2 pos, in float k, in vec2 p, in vec2 n, in float r, in float h )\n{\t\n\treturn vec3( pos.x - p.x, pos.y - p.y, k * ( ( pos.x - p.x ) * ( pos.x - p.x ) + ( pos.y - p.y ) * ( pos.y - p.y ) ) - dot( n, pos - p ) - r - h );\n}\n\nvec3 sdParabola( in vec2 pos, in float k, in vec2 p, in vec2 n, in float r, in float h, in float s )\n{\t\n\treturn vec3( pos.x - p.x, pos.y - p.y, k * ( ( pos.x - p.x ) * ( pos.x - p.x ) + ( pos.y - p.y ) * ( pos.y - p.y ) ) - dot( n, pos - p ) - r - h - s );\n}\n\nvec3 sdParabola( in vec2 pos,", " \n    vec2 q = p;\n    float r = ra;\n    float s = rb;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d2 = d*d;\n    float r2 = r*r;\n    float s2 = s*s;\n    float p2 = p.x*p.x;\n    float q2 = p.y*p.y;\n    float pq = p.x*p.y;\n    float r2s2 = r2+s2;\n    float r2s2p2 = r2+s2+p2;\n    float r2s2q2 = r2+s2+q2;\n    float r2s2pq = r2+s2+pq;\n    float r2s2p2q2 = r2s2p2+q2;\n    float r2s2p2q2p2 = r2s2p2p2+q2;\n    float r2s2p2q2q2 = r2s2p2+q2*q2;\n    float r2s2p2q2pq = r2s2p2pq+q2;\n    float r2s2p2q2p2q2 = r2s2p2q2+q2*q2;\n    float r2s2p2q2p2q2p2 = r2s2p2q2p2+q2;\n    float r2s2p2q2p2q2q2 = r2s2p2q2+q2*q2;\n    float r2s2p2q2p2q2pq = r2s2p2q2pq+q2;\n    float r2s2p2q2p2q2p2q2 = r2s2p2q2p2+q2;\n    float r2s2p2q2p2q2q2q2 = r2s2p2q2+q2*q2;\n    float r2s2p2q2p2q2q2pq = r2s2p2q2pq+q2;\n    float r2s2p2q2p2q2q2p2q2 = r2s2p2q2p2+q2;\n    float r2s2", " \n    v.x = v.x ^ (v.x << 13);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 5);\n    v.y = v.y ^ (v.y << 13);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 5);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg4(ivec2 v)\n{ \n    v.x = v.x ^ (v.x << 13);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 5);\n    v.y = v.y ^ (v.y << 13);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 5);\n    v.x = v.x + v.y;\n    v.y = v.x + v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg8(ivec2 v)\n{ \n    v.x = v.x ^ (v.x << 13);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 5);\n    v.y = v.y ^ (v.y << 13);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 5);\n    v.x = v.x + v.y;\n    v.y = v.x + v.y;\n    v.x = v.x ^ (v.x << 13);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 5);\n    v.y = v.y ^ (v.y << 13);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 5);\n    v.x = v.x + v.y;\n    v.y = v.x + v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzyn", " \n    v.x = v.x ^ (v.x << 23);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 26);\n    v.y = v.y ^ (v.y << 23);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 26);\n    v.z = v.z ^ (v.z << 23);\n    v.z = v.z ^ (v.z >> 17);\n    v.z = v.z ^ (v.z << 26);\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 s)\n{ \n    v.x = v.x ^ (v.x << 23);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 26);\n    v.y = v.y ^ (v.y << 23);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 26);\n    v.z = v.z ^ (v.z << 23);\n    v.z = v.z ^ (v.z >> 17);\n    v.z = v.z ^ (v.z << 26);\n    v.x = v.x + s.x;\n    v.y = v.y + s.y;\n    v.z = v.z + s.z;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, ivec3 s, ivec3 c)\n{ \n    v.x = v.x ^ (v.x << 23);\n    v.x = v.x ^ (v.x >> 17);\n    v.x = v.x ^ (v.x << 26);\n    v.y = v.y ^ (v.y << 23);\n    v.y = v.y ^ (v.y >> 17);\n    v.y = v.y ^ (v.y << 26);\n    v.z = v.z ^ (v.z << 23);\n    v.z = v.z ^ (v.z >> 17);\n    v.z = v.z ^ (v.z << 26);\n    v.x = v.x + s.x;\n    v.y = v.y + s.y;\n    v.z = v.z + s.z;\n    v.x = v.x + c.x;\n    v.y = v.y + c.y;\n    v.z =", " \n    vec2 pa = pos - A;\n    vec2 ba = B - A;\n    vec2 ca = C - A;\n    vec2 cb = B - C;\n    vec2 ac = A - C;\n    vec2 q = 1.0 / (ba.x * cb.y - ba.y * cb.x);\n    vec2 d = (ca.x * cb.y - ca.y * cb.x) * q;\n    vec2 e = (pa.x * cb.y - pa.y * cb.x) * q;\n    vec2 f = (pa.x * ba.y - pa.y * ba.x) * q;\n    vec2 s = e - d;\n    vec2 r = f + d;\n    float D = r.x * r.x + r.y * r.y + s.x * s.x + s.y * s.y - 2.0 * r.x * s.x;\n    if (D < 0.0) {\n        return length(pa);\n    }\n    float h = r.y * s.x - r.x * s.y;\n    float sgnh = sign(h);\n    if (abs(h) < 0.499999) {\n        float k = 0.5 / (r.x + sgnh * sqrt(D));\n        vec2 a = r * k;\n        vec2 b = s * k;\n        vec2 p = a + b;\n        vec2 q = a - b;\n        float t = clamp(dot(pa, q) / (dot(p, q) + 0.00001), 0.0, 1.0);\n        return length(p - t * q);\n    }\n    float k = 0.25 / (h + 0.5 * sgnh * sqrt(D));\n    vec2 a = r * k;\n    vec2 b = s * k;\n    vec2 p = a + b;\n    vec2 q = a - b;\n    float t = clamp(dot(pa, q) / (dot(p, q) + 0.00001), 0.0, 1.0);\n    return length(p - t * q);\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in float t) { \n    vec2 pa = pos - A;\n    vec2 ba = B - A;\n    vec2 ca = C", " \n    vec2 c = vec2(0.0, 0.0);\n    vec2 v = b - a;\n    vec2 w = p - a;\n    float det = v.x * w.y - v.y * w.x;\n    if (det < 0.0) c.y = 1.0;\n    return c.y;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c) { \n    float w = winding_sign(p, a, b);\n    float w2 = winding_sign(p, b, c);\n    float w3 = winding_sign(p, c, a);\n    return w + w2 + w3;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) { \n    float w = winding_number(p, a, b, c);\n    float w2 = winding_number(p, b, c, d);\n    return w + w2;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) { \n    float w = winding_number(p, a, b, c, d);\n    float w2 = winding_number(p, c, d, e);\n    return w + w2;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) { \n    float w = winding_number(p, a, b, c, d, e);\n    float w2 = winding_number(p, e, f, a);\n    return w + w2;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) { \n    float w = winding_number(p, a, b, c, d, e, f);\n    float w2 = winding_number(p, f, g, a);\n    return w + w2;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h) { \n    float", " \n    vec4 res = vec4( 1.0, 0.0, 0.0, 0.0 );\n    float t = ( s.x - abs( ro.x ) ) / dot( rd, vec3( 1.0, 0.0, 0.0 ) );\n    if( t > 0.0 )\n    {\n        res.x = t;\n        res.yzw = normalize( vec3( 1.0, 0.0, 0.0 ) );\n    }\n    t = ( s.y - abs( ro.y ) ) / dot( rd, vec3( 0.0, 1.0, 0.0 ) );\n    if( t > 0.0 && t < res.x )\n    {\n        res.x = t;\n        res.yzw = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    }\n    t = ( s.z - abs( ro.z ) ) / dot( rd, vec3( 0.0, 0.0, 1.0 ) );\n    if( t > 0.0 && t < res.x )\n    {\n        res.x = t;\n        res.yzw = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    }\n    return res;\n}", " // a*b+x\n    float f = a * b + x;\n    int i = int(f);\n    ret_n = i;\n    return f - i;\n}\n", " \n    vec3 c = abs(a-b);\n    vec3 d = clamp( (b-a)/k, -1.0, 1.0 );\n    return c - log( 1.0 + dot(c,d) ) * k * d;\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{ \n    vec3 c = max( a, b );\n    vec3 d = min( a, b );\n    return c + log( 1.0 + exp( -abs(d)/k ) ) * k;\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b )\n{ \n    return sdgSMin( a, b, 1.0 );\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b )\n{ \n    return sdgSMax( a, b, 1.0 );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{ \n    return sdgSMin( a, b, k );\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{ \n    return sdgSMax( a, b, k );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMin( a, b, k.x );\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMax( a, b, k.x );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMin( a, b, k.x );\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMax( a, b, k.x );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMin( a, b, k.x );\n}\n\nvec3 sdgSMax( in vec3 a, in vec3 b, in vec3 k )\n{ \n    return sdgSMax( a, b, k.x );\n}\n\nvec3 sdgSMin( in", " //ab is the center of the hyperbola\n    float a = length(ab);\n    float b = length(ab);\n    float c = length(p - ab);\n    float d = length(p + ab);\n    float e = length(p - ab);\n    float f = length(p + ab);\n    float g = length(p - ab);\n    float h = length(p + ab);\n    float i = length(p - ab);\n    float j = length(p + ab);\n    float k = length(p - ab);\n    float l = length(p + ab);\n    float m = length(p - ab);\n    float n = length(p + ab);\n    float o = length(p - ab);\n    float p = length(p + ab);\n    float q = length(p - ab);\n    float r = length(p + ab);\n    float s = length(p - ab);\n    float t = length(p + ab);\n    float u = length(p - ab);\n    float v = length(p + ab);\n    float w = length(p - ab);\n    float x = length(p + ab);\n    float y = length(p - ab);\n    float z = length(p + ab);\n    float aa = length(p - ab);\n    float ab = length(p + ab);\n    float ac = length(p - ab);\n    float ad = length(p + ab);\n    float ae = length(p - ab);\n    float af = length(p + ab);\n    float ag = length(p - ab);\n    float ah = length(p + ab);\n    float ai = length(p - ab);\n    float aj = length(p + ab);\n    float ak = length(p - ab);\n    float al = length(p + ab);\n    float am = length(p - ab);\n    float an = length(p + ab);\n    float ao = length(p - ab);\n    float ap = length(p + ab);\n    float aq = length(p - ab);\n    float ar = length(p + ab);\n    float as = length(p - ab);\n    float at = length(p + ab);\n    float au = length(p - ab);\n    float av = length(p + ab);\n    float aw = length(p - ab);\n    float ax = length(p + ab);\n    float ay = length(p - ab);\n    float az = length(p + ab);\n    float ba = length(p - ab);\n    float bb = length(p + ab);\n    float bc = length(p - ab);\n    float bd = length(p + ab);\n", "return a+b;}\nfloat sub_ploss(in float a, in float b){return a-b;}\nfloat mul_ploss(in float a, in float b){return a*b;}\nfloat div_ploss(in float a, in float b){return a/b;}\nfloat min_ploss(in float a, in float b){return min(a,b);}\nfloat max_ploss(in float a, in float b){return max(a,b);}\nfloat abs_ploss(in float a){return abs(a);}\nfloat clamp_ploss(in float a, in float b, in float c){return clamp(a,b,c);}\nfloat step_ploss(in float a, in float b){return step(a,b);}\nfloat smoothstep_ploss(in float a, in float b, in float c){return smoothstep(a,b,c);}\nfloat mix_ploss(in float a, in float b, in float c){return mix(a,b,c);}\nfloat pow_ploss(in float a, in float b){return pow(a,b);}\nfloat sqrt_ploss(in float a){return sqrt(a);}\nfloat rsqrt_ploss(in float a){return rsqrt(a);}\nfloat sin_ploss(in float a){return sin(a);}\nfloat cos_ploss(in float a){return cos(a);}\nfloat tan_ploss(in float a){return tan(a);}\nfloat asin_ploss(in float a){return asin(a);}\nfloat acos_ploss(in float a){return acos(a);}\nfloat atan_ploss(in float a){return atan(a);}\nfloat atan2_ploss(in float a, in float b){return atan2(a,b);}\nfloat exp_ploss(in float a){return exp(a);}\nfloat log_ploss(in float a){return log(a);}\nfloat log2_ploss(in float a){return log2(a);}\nfloat log10_ploss(in float a){return log10(a);}\nfloat exp2_ploss(in float a){return exp2(a);}\nfloat fract_ploss(in float a){return fract(a);}\nfloat mod_ploss(in float a, in float b){return mod(a,b);}\nfloat modf_ploss(in float a, out float b){return modf(a,b);}\nfloat fma_ploss(in float a, in float b, in float c){return fma(a,b,c);}\nfloat frexp_ploss(in float a, out int b){return frexp(a,b);}\nfloat ldexp_ploss(in float a, in int b){return ldexp(a,b);}\nfloat rint_ploss(in float a){return rint(a);}\nfloat ceil_p", "\t\n\tvec2 a = ab.x;\n\tvec2 b = ab.y;\n\t\n\tvec2 c = p - a;\n\tvec2 d = b - a;\n\t\n\tfloat e = dot( c, d );\n\tfloat f = dot( c, c ) - s1;\n\tfloat g = dot( d, d ) - s2;\n\t\n\tfloat h = e*e - f*g;\n\t\n\tvec2 sols;\n\t\n\tif( h > 0.0 )\n\t{\n\t\tfloat i = sqrt( h );\n\t\tfloat j = e + i;\n\t\tfloat k = e - i;\n\t\t\n\t\tsols.x = ( j / g ) * d.x + ( f / g ) * c.x;\n\t\tsols.y = ( j / g ) * d.y + ( f / g ) * c.y;\n\t\t\n\t\tsols.x = ( k / g ) * d.x + ( f / g ) * c.x;\n\t\tsols.y = ( k / g ) * d.y + ( f / g ) * c.y;\n\t}\n\telse if( h == 0.0 )\n\t{\n\t\tfloat i = sqrt( -h );\n\t\tfloat j = e + i;\n\t\t\n\t\tsols.x = ( j / g ) * d.x + ( f / g ) * c.x;\n\t\tsols.y = ( j / g ) * d.y + ( f / g ) * c.y;\n\t}\n\t\n\treturn sols;\n}\n\nvec2 pHyperbola( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n\tvec2 a = ab.x;\n\tvec2 b = ab.y;\n\t\n\tvec2 c = p - a;\n\tvec2 d = b - a;\n\t\n\tfloat e = dot( c, d );\n\tfloat f = dot( c, c ) - s1;\n\tfloat g = dot( d, d ) - s2;\n\t\n\tfloat h = e*e - f*g;\n\t\n\tvec2 sols;\n\t\n\tif( h > 0.0 )\n\t{\n\t\tfloat i = sqrt( h );\n\t\tfloat j = e + i;\n\t\tfloat k = e - i;\n\t\t\n\t\tsols.x = ( j / g ) * d.x + ( f / g ) * c.x;\n\t\tsols.y = ( j / g ) * d.y + ( f / g ) * c.y;\n\t\t\n\t\tsols.x = ( k / g ) * d.x + ( f / g", "\t\n\tvec3 ab = b - a;\n\tfloat l = length(ab);\n\tvec3 n = normalize(cross(ab, p - a));\n\tvec3 v = normalize(p - a);\n\tfloat d = dot(v, n);\n\tfloat h = dot(v, ab);\n\tfloat x = l * d / (l - h);\n\tvec3 q = a + x * n;\n\tfloat r = length(q - p);\n\tif (r < ra)\n\t\treturn vec4(q, r);\n\tif (r < rb)\n\t\treturn vec4(p, r);\n\treturn vec4(0.0);\n}\n\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float r)\n{\t\n\tvec3 ab = b - a;\n\tfloat l = length(ab);\n\tvec3 n = normalize(cross(ab, p - a));\n\tvec3 v = normalize(p - a);\n\tfloat d = dot(v, n);\n\tfloat h = dot(v, ab);\n\tfloat x = l * d / (l - h);\n\tvec3 q = a + x * n;\n\tfloat r1 = length(q - p);\n\tif (r1 < ra)\n\t\treturn vec4(q, r1);\n\tif (r1 < rb)\n\t\treturn vec4(p, r1);\n\treturn vec4(0.0);\n}\n\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float r, float r1)\n{\t\n\tvec3 ab = b - a;\n\tfloat l = length(ab);\n\tvec3 n = normalize(cross(ab, p - a));\n\tvec3 v = normalize(p - a);\n\tfloat d = dot(v, n);\n\tfloat h = dot(v, ab);\n\tfloat x = l * d / (l - h);\n\tvec3 q = a + x * n;\n\tfloat r1 = length(q - p);\n\tif (r1 < ra)\n\t\treturn vec4(q, r1);\n\tif (r1 < rb)\n\t\treturn vec4(p, r1);\n\treturn vec4(0.0);\n}\n\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float r, float r1, float r2)\n{\t\n\tvec3 ab = b - a;\n\tfloat l = length(ab);\n\tvec3 n = normalize(cross(ab, p - a));\n\tvec3 v = normalize(p - a);\n\tfloat d =", " \n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y - t;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t, float s )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y - t - s;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t, float s, float u )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y - t - s - u;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t, float s, float u, float v )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y - t - s - u - v;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t, float s, float u, float v, float w )\n{\n    return sdCapsule( p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h.x), r ) - h.y - t - s - u - v - w;\n}\n\nfloat sdCapsule( vec3 p, vec2 h, float r, float t, float s", " \n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 c, float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q)-h;\n    float a = atan(q.x,q.z);\n    float b = atan(q.y,d);\n    float k = h/length(c);\n    float e = abs(a-b)/k;\n    return d + e;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n )\n{\n    return dot(p,n);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return pow(length(p/r),r.z/r.x)+pow(length(p/r),r.z/r.y)-2.0;\n}\n\nfloat sdCone( vec3 p, vec3 c, float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q)-h;\n    float a = atan(q.x,q.z);\n    float b = atan(q.y,d);\n    float k = h/length(c);\n    float e = abs(a-b)/k;\n    return d + e;\n}\n\nfloat sdCone( vec3 p, vec3 c, float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q)-h;\n    float a = atan(q.x,q.z);\n", "\t\n\tvec3 normal = vec3( 0.0 );\n\t\n\t// Calculate the normal using the gradient of the SDF\n\tnormal += samplePoint.x - pos.x;\n\tnormal += samplePoint.y - pos.y;\n\tnormal += samplePoint.z - pos.z;\n\t\n\tnormal = normalize( normal );\n\t\n\t// If the surface is not visible, use the normal from the previous frame\n\tif(!showSurface )\n\t\tnormal = normalFromPrevFrame;\n\t\n\treturn normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint, in float stepSize )\n{\t\n\tvec3 normal = vec3( 0.0 );\n\t\n\t// Calculate the normal using the gradient of the SDF\n\tnormal += samplePoint.x - pos.x;\n\tnormal += samplePoint.y - pos.y;\n\tnormal += samplePoint.z - pos.z;\n\t\n\tnormal = normalize( normal );\n\t\n\t// If the surface is not visible, use the normal from the previous frame\n\tif(!showSurface )\n\t\tnormal = normalFromPrevFrame;\n\t\n\treturn normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint, in float stepSize, in float stepSize2 )\n{\t\n\tvec3 normal = vec3( 0.0 );\n\t\n\t// Calculate the normal using the gradient of the SDF\n\tnormal += samplePoint.x - pos.x;\n\tnormal += samplePoint.y - pos.y;\n\tnormal += samplePoint.z - pos.z;\n\t\n\tnormal = normalize( normal );\n\t\n\t// If the surface is not visible, use the normal from the previous frame\n\tif(!showSurface )\n\t\tnormal = normalFromPrevFrame;\n\t\n\treturn normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, vec3 samplePoint, in float stepSize, in float stepSize2, in float stepSize3 )\n{\t\n\tvec3 normal = vec3( 0.0 );\n\t\n\t// Calculate the normal using the gradient of the SDF\n\tnormal += samplePoint.x - pos.x;\n\tnormal += samplePoint.y - pos.y;\n\tnormal += samplePoint.z - pos.z;\n\t\n\tnormal = normalize", "\t\n\tvec3 p = ro + rd * samplePoint;\n\t\n\tfloat d = length( p - samplePoint );\n\t\n\tfloat shadow = 1.0;\n\t\n\tif( d < 0.01 )\n\t{\n\t\tshadow = 0.0;\n\t}\n\telse\n\t{\n\t\tvec3 n = normalize( samplePoint - p );\n\t\tfloat d2 = length( samplePoint - p );\n\t\tfloat d3 = length( samplePoint - p - n * d2 );\n\t\t\n\t\tfloat d4 = length( samplePoint - p - n * d2 - n * d3 );\n\t\t\n\t\tfloat d5 = length( samplePoint - p - n * d2 - n * d3 - n * d4 );\n\t\t\n\t\tfloat d6 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 );\n\t\t\n\t\tfloat d7 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 );\n\t\t\n\t\tfloat d8 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 - n * d7 );\n\t\t\n\t\tfloat d9 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 - n * d7 - n * d8 );\n\t\t\n\t\tfloat d10 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 - n * d7 - n * d8 - n * d9 );\n\t\t\n\t\tfloat d11 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 - n * d7 - n * d8 - n * d9 - n * d10 );\n\t\t\n\t\tfloat d12 = length( samplePoint - p - n * d2 - n * d3 - n * d4 - n * d5 - n * d6 - n * d7 - n * d8 - n * d9 - n * d10 - n * d11 );\n\t\t\n\t\tfloat d13 = length( samplePoint - p - n * d2 - n * d3 - n *", "\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d.x,d.y),he - max(d.x,d.y),1.0);\n}\n\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl )\n{\t\n\tvec2 d = abs(p) - vec2(ra,rb);\n\tocl = sign(p)*max(d.x,d.y);\n\treturn vec3(max(d", " \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus2( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus3( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus4( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus5( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus6( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus7( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus8( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus9( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus10( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus11( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus12( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2(length(p.xz),p.y);\n    return length(q)-ra;\n}\n\nvec4 sdgTorus13( vec3 p, float ra, float rb )\n{ \n    vec2 q = vec2", " \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s )\n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - s;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s, in float t )\n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - s - t;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s, in float t, in float u )\n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - s - t - u;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s, in float t, in float u, in float v )\n{ \n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return", " return dot(v, v); }\nfloat capsule(in vec3 p, in vec3 a, in vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot2(ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// Rounded sphere https://iquilezles.org/articles/distfunctions/\nfloat sphere(in vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat box(in vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// Rounded torus https://iquilezles.org/articles/distfunctions/\nfloat torus(in vec3 p, vec2 t, float r) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y - r;\n}\n\n// Rounded cylinder https://iquilezles.org/articles/distfunctions/\nfloat cylinder(in vec3 p, vec2 h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// Rounded cone https://iquilezles.org/articles/distfunctions/\nfloat cone(in vec3 p, vec3 c, float r) {\n    vec3 q = abs(p) - c;\n    return length(max(q, 0.0)) - min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// Rounded pyramid https://iquilezles.org/articles/distfunctions/\nfloat pyramid(in vec3 p, vec3 c, float r) {\n    vec3 q = abs(p) - c;\n    return length(max(q, 0.0)) - min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// Rounded plane https://iquilezles.org/articles/distfunctions/\nfloat plane(in vec3 p, vec4 n, float r) {\n    return dot(p, n.xyz) - n.w", " \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ); \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{ \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ); \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius ) \n{ \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ) - radius * radius; \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius, in float radius2 ) \n{ \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ) - radius2; \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius, in float radius2, in float radius3 ) \n{ \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ) - radius3; \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius, in float radius2, in float radius3, in float radius4 ) \n{ \n    vec2 d = abs( p - minCorner ) - abs( p - maxCorner ); \n    return dot( d, d ) - radius4; \n} \n\n// Returns 0 if inside, 1 if outside, 2 if on the edge\nfloat aabb( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in", "\t\n\tvec3 color = vec3(0.0);\n\t\n\t// Calculate the height of the water\n\tfloat height = sin(uv.y * 10.0) * 0.5 + 0.5;\n\t\n\t// Calculate the normal of the water\n\tvec3 normal = vec3(0.0);\n\tnormal.x = cos(uv.x * 10.0) * 0.5 + 0.5;\n\tnormal.y = height;\n\tnormal.z = sin(uv.y * 10.0) * 0.5 + 0.5;\n\t\n\t// Calculate the reflection vector\n\tvec3 reflection = normalize(reflect(cdir, normal));\n\t\n\t// Calculate the refraction vector\n\tvec3 refraction = normalize(refract(cdir, normal, 1.0));\n\t\n\t// Calculate the fresnel term\n\tfloat fresnel = pow(1.0 - dot(cdir, normal), 5.0);\n\t\n\t// Calculate the reflection color\n\tvec3 reflectionColor = texture2D(uSampler, uv + reflection.xy * 0.01).rgb;\n\t\n\t// Calculate the refraction color\n\tvec3 refractionColor = texture2D(uSampler, uv + refraction.xy * 0.01).rgb;\n\t\n\t// Calculate the final color\n\tcolor = mix(reflectionColor, refractionColor, fresnel);\n\t\n\treturn color;\n}", "\t\n\tvec3 ray = vec3(0.0);\n\t\n\t// Camera position\n\tvec3 cam = vec3(0.0, 0.0, 0.0);\n\t\n\t// Camera rotation\n\tvec3 rot = vec3(0.0, 0.0, 0.0);\n\t\n\t// Camera zoom\n\tfloat zoom = 1.0;\n\t\n\t// Camera aspect ratio\n\tfloat aspect = 1.0;\n\t\n\t// Camera field of view\n\tfloat fov = 45.0;\n\t\n\t// Camera near plane\n\tfloat near = 0.1;\n\t\n\t// Camera far plane\n\tfloat far = 100.0;\n\t\n\t// Camera projection matrix\n\tmat4 proj = mat4(0.0);\n\t\n\t// Camera view matrix\n\tmat4 view = mat4(0.0);\n\t\n\t// Camera model matrix\n\tmat4 model = mat4(0.0);\n\t\n\t// Camera inverse model matrix\n\tmat4 inv_model = mat4(0.0);\n\t\n\t// Camera inverse view matrix\n\tmat4 inv_view = mat4(0.0);\n\t\n\t// Camera inverse projection matrix\n\tmat4 inv_proj = mat4(0.0);\n\t\n\t// Camera inverse view projection matrix\n\tmat4 inv_view_proj = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose_inv = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose_inv_transpose = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose_inv_transpose_inv = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose_inv_transpose_inv_transpose = mat4(0.0);\n\t\n\t// Camera inverse view projection model matrix\n\tmat4 inv_view_proj_model_inv_transpose_inv_transpose_inv_transpose_inv = mat4(0.0);\n\t\n\t//", "\t\n\treturn v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q) + dot(q, v) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\t\n\treturn v.xyz + 2.0 * cross(cross(v.xyz, q) + dot(q, v.xyz) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q) + dot(q, v) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\t\n\treturn v.xyz + 2.0 * cross(cross(v.xyz, q) + dot(q, v.xyz) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q) + dot(q, v) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\t\n\treturn v.xyz + 2.0 * cross(cross(v.xyz, q) + dot(q, v.xyz) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\t\n\treturn v + 2.0 * cross(cross(v, q) + dot(q, v) * q, q);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\t\n", " \n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float h, in float r )\n{\n    vec2 q = vec2(length(p-c),atan(p.y,p.x)-atan(c.y,c.x));\n    float d = length(q)-r;\n    float h2 = h*h;\n    float q2 = q.x*q.x+q.y*q.y;\n    float s = sign(q.y);\n    return max(d,abs(q.x)-s*sqrt(h2-q2));\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float h, in float r, in float t )\n{\n    vec2 q = vec2(length(p-c),atan(p.y,p.x)-atan(c.y,c.x));\n    float d = length(q)-r;\n    float h2 = h*h;\n    float q2 = q.x*q.x+q.y*q.y;\n    float s = sign(q.y);\n    return max(d,abs(q.x)-s*sqrt(h2-q2));\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float h, in float r, in float t, in float s )\n{\n    vec2 q = vec2(length(p-c),atan(p.y,p.x)-atan(c.y,c.x));\n    float d = length(q)-r;\n    float h2 = h*h;\n    float q2 = q.x*q.x+q.y*q.y;\n    float s = sign(q.y);\n    return max(d,abs(q.x)-s*sqrt(h2-q2));\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float h, in float r, in float t, in float s, in float a )\n{\n    vec2 q = vec2(length(p-c),atan(p.y,p.x)-atan(c.y,c.x));\n    float d = length(q)-r;\n    float h2 = h*h;\n    float q2 = q.x*q.x+q.y*q.y;\n    float s = sign(q.y);\n    return max(d,abs(q.x)-s*sqrt(h2-q2));\n}\n\nfloat sd", " \n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( in vec3 p, in float h, in float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( in vec3 p, in vec3 n )\n{\n    return dot(p,n);\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return sqrt( dot(p,p)/dot(r,r) );\n}\n\nfloat sdCone( in vec3 p, in vec3 c, in float h, in float r )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q)-r;\n    float h0 = -atan(q.x,q.y)+c.z;\n    float h1 =  atan(q.x,q.y)+c.z;\n    return sign(h0)*length(max(vec2(0.0,h0),vec2(d,h1)))-h;\n}\n\nfloat sdCone( in vec3 p, in vec3 c, in float h, in float r )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = length(q)-r;\n    float", " \n    return m + vec2( sin( a ) * d, cos( a ) * d );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a )\n{ \n    return m + vec2( sin( a ) * d.x, cos( a ) * d.y );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a, float b )\n{ \n    return m + vec2( sin( a ) * d.x + cos( a ) * d.y, sin( b ) * d.x - cos( b ) * d.y );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a, float b, float c )\n{ \n    return m + vec2( sin( a ) * d.x + cos( a ) * d.y, sin( b ) * d.x - cos( b ) * d.y, sin( c ) * d.x - cos( c ) * d.y );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a, float b, float c, float d )\n{ \n    return m + vec2( sin( a ) * d.x + cos( a ) * d.y, sin( b ) * d.x - cos( b ) * d.y, sin( c ) * d.x - cos( c ) * d.y, sin( d ) * d.x - cos( d ) * d.y );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a, float b, float c, float d, float e )\n{ \n    return m + vec2( sin( a ) * d.x + cos( a ) * d.y, sin( b ) * d.x - cos( b ) * d.y, sin( c ) * d.x - cos( c ) * d.y, sin( d ) * d.x - cos( d ) * d.y, sin( e ) * d.x - cos( e ) * d.y );\n}\n\nvec2 opUnion( vec2 m, vec2 d, float a, float b, float c, float d, float e, float f )\n{ \n    return m + vec2( sin( a ) * d.x + cos( a ) * d.y, sin( b ) * d.x - cos( b ) * d.y, sin( c ) * d.x - cos( c ) * d.y, sin", "\t\n\tvec2 o = ro - rd.xy;\n\tfloat b = dot( o, o ) - rad*rad;\n\tfloat det = dot( rd.xy, rd.xy ) - b;\n\tif( det < 0.0 )\n\t{\n\t\tp1 = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\tp2 = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\treturn;\n\t}\n\tfloat det_sqrt = sqrt( det );\n\tp1 = vec4( o.x + rd.x*det_sqrt, o.y + rd.y*det_sqrt, 0.0, 0.0 );\n\tp2 = vec4( o.x - rd.x*det_sqrt, o.y - rd.y*det_sqrt, 0.0, 0.0 );\n}\n\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2, out float t )\n{\t\n\tvec2 o = ro - rd.xy;\n\tfloat b = dot( o, o ) - rad*rad;\n\tfloat det = dot( rd.xy, rd.xy ) - b;\n\tif( det < 0.0 )\n\t{\n\t\tp1 = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\tp2 = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\treturn;\n\t}\n\tfloat det_sqrt = sqrt( det );\n\tp1 = vec4( o.x + rd.x*det_sqrt, o.y + rd.y*det_sqrt, 0.0, 0.0 );\n\tp2 = vec4( o.x - rd.x*det_sqrt, o.y - rd.y*det_sqrt, 0.0, 0.0 );\n\tt = -dot( o, rd.xy ) / det_sqrt;\n}\n\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2, out float t, out float t2 )\n{\t\n\tvec2 o = ro - rd.xy;\n\tfloat b = dot( o, o ) - rad*rad;\n\tfloat det = dot( rd.xy, rd.xy ) - b;\n\tif( det < 0.0 )\n\t{\n\t\tp1 = vec4", " \n    vec2 q = p-c;\n    return vec3(length(q), atan(q.y, q.x), 1.0);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, float r ) \n{ \n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0)), mix(sign(d.x), 1.0, smoothstep(0.0, r, d.x)), mix(sign(d.y), 1.0, smoothstep(0.0, r, d.y)));\n}\n\nvec3 sdgCone( in vec2 p, in vec2 c, float r ) \n{ \n    vec2 q = p-c;\n    float d = length(q);\n    float h = r*d;\n    float a = atan(q.y, q.x);\n    float s = smoothstep(0.0, r, h);\n    return vec3(d, a, s);\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 c, float r ) \n{ \n    vec2 q = p-c;\n    float d = length(q);\n    float h = r*d;\n    float a = atan(q.y, q.x);\n    float s = smoothstep(0.0, r, h);\n    return vec3(d, a, s);\n}\n\nvec3 sdgCylinder2( in vec2 p, in vec2 c, float r ) \n{ \n    vec2 q = p-c;\n    float d = length(q);\n    float h = r*d;\n    float a = atan(q.y, q.x);\n    float s = smoothstep(0.0, r, h);\n    return vec3(d, a, s);\n}\n\nvec3 sdgCylinder3( in vec2 p, in vec2 c, float r ) \n{ \n    vec2 q = p-c;\n    float d = length(q);\n    float h = r*d;\n    float a = atan(q.y, q.x);\n    float s = smoothstep(0.0, r, h);\n    return vec3(d, a, s);\n}\n\nvec3 sdgCylinder4( in vec2 p, in vec2 c, float r ) \n{ \n    vec2 q = p-c;\n    float d = length(q);\n    float h = r*d;\n    float a = atan(q.y, q.x);\n    float s = smoothstep(", " \n    vec2 d = abs(p)-b;\n    vec2 s = sign(p);\n    return vec3(dot(d,s), - (dot(d,s)+length(s*(d-s))) );\n}\n\nvec3 sdSphere( in vec2 p, in float r )\n{\n    return vec3(length(p)-r, p.x, p.y);\n}\n\nvec3 sdPlane( in vec2 p, in vec2 n )\n{\n    return vec3(dot(p,n), p.x, p.y);\n}\n\nvec3 sdCylinder( in vec2 p, in float r, in float h )\n{\n    vec2 d = abs(p)-vec2(r,h);\n    vec2 s = sign(p);\n    return vec3(min(dot(d,s),length(s*(d-s))), p.x, p.y);\n}\n\nvec3 sdCone( in vec2 p, in float r, in float h )\n{\n    vec2 d = abs(p)-vec2(r,h);\n    vec2 s = sign(p);\n    return vec3(min(dot(d,s),length(s*(d-s))), p.x, p.y);\n}\n\nvec3 sdTorus( in vec2 p, in float r, in float R )\n{\n    vec2 q = vec2(length(p)-R,p.x/R);\n    return vec3(length(q)-r, p.x, p.y);\n}\n\nvec3 sdTorusKnot( in vec2 p, in float r, in float R, in float n, in float m, in float a, in float b )\n{\n    vec2 q = vec2(length(p)-R,p.x/R);\n    float t = atan(q.y,q.x)+a*n;\n    float c = cos(t);\n    float s = sin(t);\n    float d = length(q)-r;\n    float e = dot(q,vec2(c,s));\n    float f = dot(q,vec2(-s,c));\n    return vec3(max(d,e), p.x, p.y);\n}\n\nvec3 sdTorusKnot2( in vec2 p, in float r, in float R, in float n, in float m, in float a, in float b )\n{\n    vec2 q = vec2(length(p)-R,p.x/R);\n    float t = atan(q.y,q.x)+a*n;\n    float c = cos(t);\n    float s = sin(t);\n    float d = length(q)-r;\n    float e = dot(q,vec2(c,s));\n   ", "\t\n\tvec2 q = p;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat c = 0.5;\n\tfloat d = 0.5;\n\tfloat e = 0.5;\n\tfloat f = 0.5;\n\tfloat g = 0.5;\n\tfloat h = 0.5;\n\tfloat i = 0.5;\n\tfloat j = 0.5;\n\tfloat k = 0.5;\n\tfloat l = 0.5;\n\tfloat m = 0.5;\n\tfloat n = 0.5;\n\tfloat o = 0.5;\n\tfloat p = 0.5;\n\tfloat q = 0.5;\n\tfloat r = 0.5;\n\tfloat s = 0.5;\n\tfloat t = 0.5;\n\tfloat u = 0.5;\n\tfloat v = 0.5;\n\tfloat w = 0.5;\n\tfloat x = 0.5;\n\tfloat y = 0.5;\n\tfloat z = 0.5;\n\tfloat aa = 0.5;\n\tfloat ab = 0.5;\n\tfloat ac = 0.5;\n\tfloat ad = 0.5;\n\tfloat ae = 0.5;\n\tfloat af = 0.5;\n\tfloat ag = 0.5;\n\tfloat ah = 0.5;\n\tfloat ai = 0.5;\n\tfloat aj = 0.5;\n\tfloat ak = 0.5;\n\tfloat al = 0.5;\n\tfloat am = 0.5;\n\tfloat an = 0.5;\n\tfloat ao = 0.5;\n\tfloat ap = 0.5;\n\tfloat aq = 0.5;\n\tfloat ar = 0.5;\n\tfloat as = 0.5;\n\tfloat at = 0.5;\n\tfloat au = 0.5;\n\tfloat av = 0.5;\n\tfloat aw = 0.5;\n\tfloat ax = 0.5;\n\tfloat ay = 0.5;\n\tfloat az = 0.5;\n\tfloat ba = 0.5;\n\tfloat bb = 0.5;\n\tfloat bc = 0.5;\n\tfloat bd = 0.5;\n\tfloat be = 0.5;\n\tfloat bf = 0.5;\n\tfloat bg = 0.5;\n\tfloat bh = 0.5;\n\tfloat bi = 0.5;\n\tfloat bj = 0.5;\n\tfloat bk = 0.5;\n", " return a1 * x + b1; }\nfloat f(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat h(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat i(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat j(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat k(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat l(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat m(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat n(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat o(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat p(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat q(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat r(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat s(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat t(float a1, float b1, float a2, float b2, float x) { return a1 * x + b1; }\nfloat u(float a1, float b1, float a2, float b2, float x) { return a2 * x + b2; }\nfloat v(float a1, float b1, float a2, float b2, float x) {", " return pow(abs(x), n) + a * pow(sin(b * x), 2); }\nfloat h(float a, float b, float n, float x, float y) { return pow(abs(x), n) + a * pow(sin(b * x), 2) + a * pow(sin(b * y), 2); }\nfloat h(float a, float b, float n, float x, float y, float z) { return pow(abs(x), n) + a * pow(sin(b * x), 2) + a * pow(sin(b * y), 2) + a * pow(sin(b * z), 2); }\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) { return pow(abs(x), n) + a * pow(sin(b * x), 2); }\nfloat h(float a, float b, float n, float x, float y) { return pow(abs(x), n) + a * pow(sin(b * x), 2) + a * pow(sin(b * y), 2); }\nfloat h(float a, float b, float n, float x, float y, float z) { return pow(abs(x), n) + a * pow(sin(b * x), 2) + a * pow(sin(b * y), 2) + a * pow(sin(b * z), 2); }\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/1jxjxjxjxj\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) { return pow(abs(x), n) + a * pow(sin(b * x), 2); }\nfloat h(float a, float b, float n, float x, float y) { return pow(abs(x), n) + a * pow(sin(b * x), 2) + a * pow(sin", " // paper noise\n                float t = 0.0;\n                float a = 0.0;\n                float b = 0.0;\n                float c = 0.0;\n                float d = 0.0;\n                float e = 0.0;\n                float f = 0.0;\n                float g = 0.0;\n                float h = 0.0;\n                float i = 0.0;\n                float j = 0.0;\n                float k = 0.0;\n                float l = 0.0;\n                float m = 0.0;\n                float n = 0.0;\n                float o = 0.0;\n                float p = 0.0;\n                float q = 0.0;\n                float r = 0.0;\n                float s = 0.0;\n                float t = 0.0;\n                float u = 0.0;\n                float v = 0.0;\n                float w = 0.0;\n                float x = 0.0;\n                float y = 0.0;\n                float z = 0.0;\n                float aa = 0.0;\n                float ab = 0.0;\n                float ac = 0.0;\n                float ad = 0.0;\n                float ae = 0.0;\n                float af = 0.0;\n                float ag = 0.0;\n                float ah = 0.0;\n                float ai = 0.0;\n                float aj = 0.0;\n                float ak = 0.0;\n                float al = 0.0;\n                float am = 0.0;\n                float an = 0.0;\n                float ao = 0.0;\n                float ap = 0.0;\n                float aq = 0.0;\n                float ar = 0.0;\n                float as = 0.0;\n                float at = 0.0;\n                float au = 0.0;\n                float av = 0.0;\n                float aw = 0.0;\n                float ax = 0.0;\n                float ay = 0.0;\n                float az = 0.0;\n                float ba = 0.0;\n                float bb = 0.0;\n                float bc = 0.0;\n                float bd", "\t\n\tvec3 color = vec3(0.0);\n\t\n\t// Compute the color of the pixel\n\tcolor = texture2D( texture, vec2( x, y ) ).rgb;\n\t\n\treturn color;\n}\n", " \n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max(q.x,q.y*u.y),0.0);\n}\n\nfloat sdStar( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max(q.x,q.y*u.y),0.0);\n}\n\nfloat sdStar2( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max(q.x,q.y*u.y),0.0);\n}\n\nfloat sdStar3( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max(q.x,q.y*u.y),0.0);\n}\n\nfloat sdStar4( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max(q.x,q.y*u.y),0.0);\n}\n\nfloat sdStar5( in vec2 p, in float r )\n{\n    const vec2 u = vec2(0.8660254037844386,0.5);\n    vec2 q = abs(p)-vec2(r,r*u.x);\n    return length(max(q,0.0)) + min(max", " \n    vec2 q = abs(p-c) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdBox2( in vec2 p, in vec2 b ) \n{ \n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox3( in vec3 p, in vec3 b ) \n{ \n    vec3 q = abs(p)-b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{ \n    vec3 q = abs(p)-b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat sdBox( in vec4 p, in vec4 b ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0));\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0)) - r - s;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s, in float t ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0)) - r - s - t;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float s, in float t, in float u ) \n{ \n    vec4 q = abs(p)-b;\n    return min(max(q.x,max(q.y,max(q.z", "\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t, in float s )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r, in float e )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r, in float e, in float f )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa - ba*h;\n}\n\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float t, in float s, in float r, in float e, in float f, in float g )\n{\n\tvec2 pa = p - a, ba = b - a", "\t\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat d2 = dot(pa,pa);\n\tfloat d2b = dot(ba,ba);\n\tfloat d2ab = dot(pa,ba);\n\tfloat d2c = d2b - 2.0*d2ab + d2;\n\tfloat d2min2 = d2min*d2min;\n\tfloat d2max = d2c + h2;\n\tfloat d2min3 = d2min2*d2min;\n\tfloat d2max3 = d2max*d2max*d2max;\n\tfloat d2min4 = d2min2*d2min2;\n\tfloat d2max4 = d2max3*d2max;\n\tfloat d2min5 = d2min4*d2min;\n\tfloat d2max5 = d2max4*d2max;\n\tfloat d2min6 = d2min5*d2min;\n\tfloat d2max6 = d2max5*d2max;\n\tfloat d2min7 = d2min6*d2min;\n\tfloat d2max7 = d2max6*d2max;\n\tfloat d2min8 = d2min7*d2min;\n\tfloat d2max8 = d2max7*d2max;\n\tfloat d2min9 = d2min8*d2min;\n\tfloat d2max9 = d2max8*d2max;\n\tfloat d2min10 = d2min9*d2min;\n\tfloat d2max10 = d2max9*d2max;\n\tfloat d2min11 = d2min10*d2min;\n\tfloat d2max11 = d2max10*d2max;\n\tfloat d2min12 = d2min11*d2min;\n\tfloat d2max12 = d2max11*d2max;\n\tfloat d2min13 = d2min12*d2min;\n\tfloat d2max13 = d2max12*d2max;\n\tfloat d2min14 = d2min13*d2min;\n\tfloat d2max14 = d2max13*d2max;\n\tfloat d2min15 = d2min14*d2min;\n\tfloat d2max15 = d2max14*d2max;\n\tfloat d2min16 = d2min15*d2min;\n\tfloat d2max16 = d2max15*d2max;\n\tfloat d2min17 = d2min16*d2min;\n\tfloat d2max", "\t\n\tfloat k = 0.0;\n\t\n\t// Line segments\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 0 )\n\t\t{\n\t\t\tvec2 a = kPath[i*2];\n\t\t\tvec2 b = kPath[i*2+1];\n\t\t\t\n\t\t\tfloat d = distance( p, a );\n\t\t\tfloat e = distance( p, b );\n\t\t\t\n\t\t\tfloat f = dot( normalize( a - b ), normalize( p - a ) );\n\t\t\tfloat g = dot( normalize( a - b ), normalize( p - b ) );\n\t\t\t\n\t\t\tif( f < 0.0 )\n\t\t\t{\n\t\t\t\tk = min( k, d );\n\t\t\t}\n\t\t\telse if( g < 0.0 )\n\t\t\t{\n\t\t\t\tk = min( k, e );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk = min( k, distance( p, a ) );\n\t\t\t\tk = min( k, distance( p, b ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Arc segments\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 1 )\n\t\t{\n\t\t\tvec2 a = kPath[i*2];\n\t\t\tvec2 b = kPath[i*2+1];\n\t\t\t\n\t\t\tfloat d = distance( p, a );\n\t\t\tfloat e = distance( p, b );\n\t\t\t\n\t\t\tfloat f = dot( normalize( a - b ), normalize( p - a ) );\n\t\t\tfloat g = dot( normalize( a - b ), normalize( p - b ) );\n\t\t\t\n\t\t\tif( f < 0.0 )\n\t\t\t{\n\t\t\t\tk = min( k, d );\n\t\t\t}\n\t\t\telse if( g < 0.0 )\n\t\t\t{\n\t\t\t\tk = min( k, e );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk = min( k, distance( p, a ) );\n\t\t\t\tk = min( k, distance( p, b ) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn k;\n}", " \n    return length( p - vec2( 0.0, 0.0 ) ) - 0.5;\n}\n\nfloat sdB( in vec2 p )\n{ \n    return length( p - vec2( 0.0, 1.0 ) ) - 0.5;\n}\n\nfloat sdC( in vec2 p )\n{ \n    return length( p - vec2( 1.0, 1.0 ) ) - 0.5;\n}\n\nfloat sdD( in vec2 p )\n{ \n    return length( p - vec2( 1.0, 0.0 ) ) - 0.5;\n}\n\nfloat sdE( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdF( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdG( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdH( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdI( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdJ( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdK( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdL( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdM( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.5 ) ) - 0.5;\n}\n\nfloat sdN( in vec2 p )\n{ \n    return length( p - vec2( 0.5, 0.", "\t\n\treturn length( p ) - 0.5;\n}\n\nfloat sdC( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdD( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdE( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdF( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdG( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdH( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdI( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdJ( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdK( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdL( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdM( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdN( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdO( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdP( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdQ( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdR( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdS( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdT( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdU( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdV( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdW( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdX( in vec2 p )\n{\n\treturn length( p ) - 0.5;\n}\n\nfloat sdY( in vec2 p )\n{\n\treturn length( p )", "\t\n\tvec3 color = vec3( 0.0 );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x );\n\t\n\t// Calculate the distance from the center of the pattern.\n\tfloat dist = length( uv - vec2( 0.5 ) );\n\t\n\t// Calculate the angle of the point.\n\tfloat angle = atan( uv.y, uv.x", "\t\n\tvec2 ab = b - a;\n\tfloat h = clamp( dot( p - a, ab ) / dot( ab, ab ), 0.0, 1.0 );\n\treturn a + ab * h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th )\n{\n\tvec2 d = p - c;\n\tfloat l = length( d );\n\treturn l < r? p : c + d * ( r / l );\n}\n\n// Closest point on ellipse\nvec2 cloEllipse( in vec2 p, in vec2 c, in vec2 a, in float th )\n{\n\tvec2 d = p - c;\n\tfloat l = length( d );\n\treturn l < a.x? p : c + d * ( a.x / l );\n}\n\n// Closest point on parabola\nvec2 cloParabola( in vec2 p, in vec2 c, in vec2 a, in float th )\n{\n\tvec2 d = p - c;\n\tfloat l = length( d );\n\treturn l < a.x? p : c + d * ( a.x / l );\n}\n\n// Closest point on hyperbola\nvec2 cloHyperbola( in vec2 p, in vec2 c, in vec2 a, in float th )\n{\n\tvec2 d = p - c;\n\tfloat l = length( d );\n\treturn l < a.x? p : c + d * ( a.x / l );\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n\tvec2 ab = b - a;\n\tfloat h = clamp( dot( p - a, ab ) / dot( ab, ab ), 0.0, 1.0 );\n\treturn a + ab * h;\n}\n\n// Closest point on line segment\nvec2 cloLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n\tvec2 ab = b - a;\n\tfloat h = clamp( dot( p - a, ab ) / dot( ab, ab ), 0.0, 1.0 );\n\treturn a + ab * h;\n}\n\n// Closest point on line segment\nvec2 cloLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n\tvec2 ab =", "\t\n\tvec2 ab = b - a;\n\tfloat h = dot( p - a, ab ) / dot( ab, ab );\n\tif( h < 0.0 ) return length( p - a );\n\tif( h > 1.0 ) return length( p - b );\n\treturn length( p - ( a + h * ab ) );\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 v0 = b - a, v1 = c - a, v2 = p - a;\n\tfloat dot00 = dot( v0, v0 );\n\tfloat dot01 = dot( v0, v1 );\n\tfloat dot02 = dot( v0, v2 );\n\tfloat dot11 = dot( v1, v1 );\n\tfloat dot12 = dot( v1, v2 );\n\tfloat invDenom = 1.0 / ( dot00 * dot11 - dot01 * dot01 );\n\tfloat u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\tfloat v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\treturn length( v2 - u * v0 - v * v1 );\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 a, in float th )\n{\n\tvec2 q = p - c;\n\tfloat a2 = dot( a, a );\n\tfloat b2 = dot( a, a );\n\tfloat c2 = dot( q, q );\n\tfloat d = a2 * c2 - b2 * b2;\n\tif( d < 0.0 ) return length( q );\n\td = sqrt( d );\n\treturn length( q - vec2( d, 0.0 ) ) * th;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 a, in float th )\n{\n\tvec2 q = p - c;\n\tfloat a2 = dot( a, a );\n\tfloat b2 = dot( a, a );\n\tfloat c2 = dot( q, q );\n\tfloat d = a2 * c2 - b2 * b2;\n\tif( d < ", "\t\n\tvec2 q = abs(p) - b;\n\tif( any( q < 0.0 ) ) return p;\n\tvec2 d = length( max( vec2(0.0), q ) ) - r;\n\treturn p + clamp( q, 0.0, r ) * sign( d );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float s )\n{\t\n\tvec2 q = abs(p) - b;\n\tif( any( q < 0.0 ) ) return p;\n\tvec2 d = length( max( vec2(0.0), q ) ) - r;\n\treturn p + clamp( q, 0.0, r ) * sign( d ) * s;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float s, float t )\n{\t\n\tvec2 q = abs(p) - b;\n\tif( any( q < 0.0 ) ) return p;\n\tvec2 d = length( max( vec2(0.0), q ) ) - r;\n\treturn p + clamp( q, 0.0, r ) * sign( d ) * s + t;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float s, float t, float u )\n{\t\n\tvec2 q = abs(p) - b;\n\tif( any( q < 0.0 ) ) return p;\n\tvec2 d = length( max( vec2(0.0), q ) ) - r;\n\treturn p + clamp( q, 0.0, r ) * sign( d ) * s + t + u;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float s, float t, float u, float v )\n{\t\n\tvec2 q = abs(p) - b;\n\tif( any( q < 0.0 ) ) return p;\n\tvec2 d = length( max( vec2(0.0), q ) ) - r;\n\treturn p + clamp( q, 0.0, r ) * sign( d ) * s + t + u + v;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec", "\t\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\t\n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y,q.z),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\t\n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y,q.z,q.w),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r, float h )\n{\t\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float h )\n{\t\n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y,q.z),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r, float h )\n{\t\n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y,q.z,q.w),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r, float h, float s )\n{\t\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r, float h, float s )\n{\t\n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y,q.z),0.0) - r;\n}\n\n// distance to rounded box\n", " \n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to box\nfloat sdBox( in vec3 p, in vec3 b )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// distance to box\nfloat sdBox( in vec4 p, in vec4 b )\n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0);\n}\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{ \n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to box\nfloat sdBox( in vec3 p, in vec3 b, in float r )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// distance to box\nfloat sdBox( in vec4 p, in vec4 b, in float r )\n{ \n    vec4 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r;\n}\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float h )\n{ \n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - h;\n}\n\n// distance to box\nfloat sdBox( in vec3 p, in vec3 b, in float r, in float h )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r - h;\n}\n\n// distance to box\nfloat sdBox( in vec4 p, in vec4 b, in float r, in float h )\n{ \n    vec4", " return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }\nfloat hash12(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 314.7))) * 43758.5453); }\nfloat hash12(vec4 p){ return fract(sin(dot(p, vec4(127.1, 311.7, 314.7, 280.3))) * 43758.5453); }\nfloat hash12(vec2 p, float s){ return fract(sin(dot(p, vec2(s, s))) * 43758.5453); }\nfloat hash12(vec3 p, float s){ return fract(sin(dot(p, vec3(s, s, s))) * 43758.5453); }\nfloat hash12(vec4 p, float s){ return fract(sin(dot(p, vec4(s, s, s, s))) * 43758.5453); }\nfloat hash12(vec2 p, float s, float t){ return fract(sin(dot(p, vec2(s, t))) * 43758.5453); }\nfloat hash12(vec3 p, float s, float t, float u){ return fract(sin(dot(p, vec3(s, t, u))) * 43758.5453); }\nfloat hash12(vec4 p, float s, float t, float u, float v){ return fract(sin(dot(p, vec4(s, t, u, v))) * 43758.5453); }\nfloat hash12(vec2 p, float s, float t, float u, float v, float w){ return fract(sin(dot(p, vec2(s, t, u, v, w))) * 43758.5453); }\nfloat hash12(vec3 p, float s, float t, float u, float v, float w, float x){ return fract(sin(dot(p, vec3(s, t, u, v, w, x))) * 43758.5453); }\nfloat hash12(vec4 p, float s, float t, float u, float v, float w, float x, float y){ return fract(sin(dot(p, vec4(s, t, u, v, w, x, y))) * 43758.5453); }\nfloat hash12(vec2 p, float s, float t, float u, float v, float w, float x", " \n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the noise function\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(random(i), random(i+vec2(1.0,0.0)), f.x), \n               mix(random(i+vec2(0.0,1.0)), random(i+vec2(1.0,1.0)), f.x), f.y);\n}\n\n// My take on the perlin noise function\nfloat perlin(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    return mix(mix(random(p), random(p+vec2(1.0,0.0)), u.x), \n               mix(random(p+vec2(0.0,1.0)), random(p+vec2(1.0,1.0)), u.x), u.y);\n}\n\n// My take on the simplex noise function\nfloat simplex(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 i = vec2(0.0,0.0);\n    vec2 j = vec2(1.0,0.0);\n    vec2 k = vec2(1.0,1.0);\n    vec2 t = vec2(0.0,0.0);\n    vec2 s = vec2(0.0,0.0);\n    vec2 r = vec2(0.0,0.0);\n    vec2 a = vec2(0.0,0.0);\n    vec2 b = vec2(0.0,0.0);\n    vec2 c = vec2(0.0,0.0);\n    vec2 d = vec2(0.0,0.0);\n    vec2", " \n    return fract(sin(vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3))))*43758.5453123);\n}\n\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(rand(i),rand(i+vec2(1.0,0.0)),u.x),mix(rand(i+vec2(0.0,1.0)),rand(i+vec2(1.0,1.0)),u.x),u.y);\n}\n\nfloat fbm(vec2 st){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for (int i = 0; i < 7; i++) {\n        v += a * noise(st);\n        st = rot*st*2.0+shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 st = uv;\n    vec3 color = vec3(0.0);\n    float t = fbm(st*0.5);\n    color = vec3(t);\n    fragColor = vec4(color,1.0);\n}", "\t\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tfloat a = dot(p, vec2(1.0, 57.0));\n\tfloat b = dot(p, vec2(57.0, 1.0));\n\t\n\tfloat r0 = mix(triNoise(vec2(a)), triNoise(vec2(b)), f.x);\n\tfloat r1 = mix(triNoise(vec2(a + vec2(1.0, 0.0))), triNoise(vec2(b + vec2(1.0, 0.0))), f.x);\n\t\n\treturn mix(r0, r1, f.y);\n}\n\nfloat triNoise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tfloat a = dot(p, vec2(1.0, 57.0));\n\tfloat b = dot(p, vec2(57.0, 1.0));\n\t\n\tfloat r0 = mix(triValueNoise(vec2(a)), triValueNoise(vec2(b)), f.x);\n\tfloat r1 = mix(triValueNoise(vec2(a + vec2(1.0, 0.0))), triValueNoise(vec2(b + vec2(1.0, 0.0))), f.x);\n\t\n\treturn mix(r0, r1, f.y);\n}\n\nfloat triNoise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tfloat a = dot(p, vec2(1.0, 57.0));\n\tfloat b = dot(p, vec2(57.0, 1.0));\n\t\n\tfloat r0 = mix(triValueNoise(vec2(a)), triValueNoise(vec2(b)), f.x);\n\tfloat r1 = mix(triValueNoise(vec2(a + vec2(1.0, 0.0))), triValueNoise(vec2(b + vec2(1.0, 0.0))), f.x);\n\t\n\treturn mix(r0, r1, f.y);\n}\n\nfloat triNoise(vec4 x)\n{\n\tvec4 p = floor(x);\n\tvec4 f = fract(x);\n\t\n\tfloat a = dot(p, vec2(1.0, 57.0));\n\tfloat b = dot(p, vec2(57.0, 1.0));\n\t\n\tfloat r0 = mix(triValueNoise(vec2(a)), triValueNoise(vec2(b)), f.x);\n\tfloat r1 = mix(triValueNoise(vec2", "\t\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat lacunarity = 2.0;\n\tfloat gain = 0.5;\n\t\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tf += noise(x) * a;\n\t\tx *= lacunarity;\n\t\ta *= gain;\n\t}\n\t\n\treturn f;\n}\n\n// Single octave noise function\nfloat noise(vec2 x)\n{\n\treturn fbm(x);\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale)\n{\n\treturn fbm(x * scale);\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset)\n{\n\treturn fbm(x * scale) + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves, float persistence)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves, float persistence, float seed)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves, float persistence, float seed, float noiseType)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves, float persistence, float seed, float noiseType, float noiseScale)\n{\n\treturn fbm(x * scale) * gain + offset;\n}\n\n// Single octave noise function\nfloat noise(vec2 x, float scale, float offset, float gain, float lacunarity, float octaves,", "\t\n\tvec2 p = x;\n\tfloat a = 0.0;\n\t\n\tp.x = abs(p.x);\n\tp.y = abs(p.y);\n\t\n\tfloat d = length(p);\n\t\n\tp.x = abs(p.x - 0.5);\n\tp.y = abs(p.y - 0.5);\n\t\n\ta = 1.0 - smoothstep(0.0, 0.5, d);\n\t\n\treturn a;\n}\n\nvec3 pattern(vec2 x, vec2 p)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x + p);\n\tc.g = pattern(x - p);\n\tc.b = pattern(x + p + vec2(0.5));\n\t\n\treturn c;\n}\n\nvec3 pattern(vec2 x)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x, vec2(0.0));\n\tc.g = pattern(x, vec2(0.5));\n\tc.b = pattern(x, vec2(1.0));\n\t\n\treturn c;\n}\n\nvec3 pattern(vec2 x, float t)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x, vec2(0.0, t));\n\tc.g = pattern(x, vec2(0.5, t));\n\tc.b = pattern(x, vec2(1.0, t));\n\t\n\treturn c;\n}\n\nvec3 pattern(vec2 x, float t, float s)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x, vec2(0.0, t));\n\tc.g = pattern(x, vec2(0.5, t));\n\tc.b = pattern(x, vec2(1.0, t));\n\t\n\treturn c;\n}\n\nvec3 pattern(vec2 x, float t, float s, float a)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x, vec2(0.0, t), s);\n\tc.g = pattern(x, vec2(0.5, t), s);\n\tc.b = pattern(x, vec2(1.0, t), s);\n\t\n\treturn c;\n}\n\nvec3 pattern(vec2 x, float t, float s, float a, float b)\n{\n\tvec3 c = vec3(0.0);\n\t\n\tc.r = pattern(x, vec2(0.0, t), s, a);\n\tc.g = pattern(x, vec2(0.5, t", "\t\n\tfloat a = 1.0 - x;\n\tfloat b = 1.0 - y;\n\treturn 4.0 * a * b;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n\tfloat a = 1.0 - x;\n\tfloat b = 1.0 - y;\n\treturn 4.0 * a * b / (a + b);\n}\n", " // by Inigo Quilez\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec2 p2) { // by Inigo Quilez\n    vec3 p3 = fract(p2.xyxy * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec4 p4) { // by Inigo Quilez\n    vec3 p3 = fract(p4.xyxy * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec2 p2, float seed) { // by Inigo Quilez\n    vec3 p3 = fract(p2.xyxy * vec3(.1031,.1030,.0973) + seed);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec3 p3, float seed) { // by Inigo Quilez\n    p3 = fract(p3 * vec3(.1031,.1030,.0973) + seed);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec4 p4, float seed) { // by Inigo Quilez\n    vec3 p3 = fract(p4.xyxy * vec3(.1031,.1030,.0973) + seed);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec2 p2, float seed, float scale) { // by Inigo", " // 3D simplex noise\n    vec3 p3 = floor(p);\n    vec3 f3 = fract(p);\n    f3 = f3*f3*(3.0-2.0*f3);\n    vec2 u = (f3.yz*fract(6.0*p3.x))-f3.zy;\n    return dot(u,u);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec3 u = dot(i, vec3(1, 57, 21));\n    return mix(mix(mix(simplex3d(u + vec3(0, 0, 0)), simplex3d(u + vec3(1, 0, 0)), f.x),\n                   mix(simplex3d(u + vec3(0, 1, 0)), simplex3d(u + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(simplex3d(u + vec3(0, 0, 1)), simplex3d(u + vec3(1, 0, 1)), f.x),\n                   mix(simplex3d(u + vec3(0, 1, 1)), simplex3d(u + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n", " \n    return fract(sin(x*vec2(12.9898,78.233))*vec2(43758.5453, 22578.1453)); \n}\n\nfloat hash( in float x )   \n{ \n    return fract(sin(x*12.9898)*43758.5453); \n}\n\nfloat hash( in vec3 x )   \n{ \n    return fract(sin(dot(x,vec3(12.9898,78.233, 43758.5453)))*43758.5453); \n}\n\nfloat noise( in vec3 x ) \n{ \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat fbm( in vec3 x ) \n{ \n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0; i < 5; i++) \n    { \n        n += a * noise(x);\n        x *= b;\n        a *= 0.5;\n        b *= 0.5;\n    } \n    return n;\n}\n\nfloat fbm( in vec2 x ) \n{ \n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for (int i = 0; i < 5; i++) \n    { \n        n += a * noise(x);\n        x *= b;\n        a *= 0.5;\n        b *= 0.5;\n    } \n    return n;\n}\n\nfloat fbm( in float x ) \n{ \n    float f = 0.0;\n    float a =", "\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h )\n{\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h, in float w )\n{\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h, in float w, in float h2 )\n{\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h, in float w, in float h2, in float h3 )\n{\t\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h, in float w, in float h", " \n    vec2 q = abs(p)-r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - b.x;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ \n    return length(max(p-b,0.0)) - min(max(p.x,p.y),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(max(q.y,q.z),0.0) + min(max(q.x,q.z),0.0) - 1.0;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float r )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(max(q.y,q.z),0.0) + min(max(q.x,q.z),0.0) - r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float r, in float h )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(max(q.y,q.z),0.0) + min(max(q.x,q.z),0.0) - r - h;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float r, in float h, in float s )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(max(q.y,q.z),0.0) + min(max(q.x,q.z),0.0) - r - h - s;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float r, in float h, in float s, in float t )\n{ \n    vec3 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(max(q.y,q.z),0.0) + min(max(q.x,q.z),0.0) - r - h - s - t;\n", "    \n    // https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    float a = radius;\n    float b = radius;\n    float c = dot(center, normal);\n    float d = dot(center, center) - c * c;\n    float e = dot(normal, normal);\n    float f = dot(center, normal) * 2.0;\n    float g = dot(center, center) - c * c - a * a * e;\n    float h = dot(center, normal) * 2.0;\n    float i = dot(center, center) - c * c - b * b * e;\n    float j = dot(center, normal) * 2.0;\n    float k = dot(center, center) - c * c - a * a * e;\n    float l = dot(center, normal) * 2.0;\n    float m = dot(center, center) - c * c - b * b * e;\n    float n = dot(center, normal) * 2.0;\n    float o = dot(center, center) - c * c - a * a * e;\n    float p = dot(center, normal) * 2.0;\n    float q = dot(center, center) - c * c - b * b * e;\n    float r = dot(center, normal) * 2.0;\n    float s = dot(center, center) - c * c - a * a * e;\n    float t = dot(center, normal) * 2.0;\n    float u = dot(center, center) - c * c - b * b * e;\n    float v = dot(center, center) - c * c - a * a * e;\n    float w = dot(center, normal) * 2.0;\n    float x = dot(center, center) - c * c - b * b * e;\n    float y = dot(center, normal) * 2.0;\n    float z = dot(center, center) - c * c - a * a * e;\n    float A = dot(center, normal) * 2.0;\n    float B = dot(center, center) - c * c - b * b * e", " \n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat Hash13(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash14(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash15(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash16(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash17(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash18(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash19(vec3 p)\n{\n    p = fract(p*vec3(0.1031,0.11369,0.13787));\n    p = p.x + p.yx*0.5 + p.zw*2.2;\n    return fract(p*1e4);\n}\n\nfloat Hash20(vec3 p)\n{\n    p = fract(p*", "\t\n\tvec2 q = p - acs;\n\tfloat d = length(q);\n\tfloat a = atan(q.y, q.x);\n\tfloat b = atan(q.y, q.x - an);\n\tfloat c = atan(q.y, q.x + an);\n\tfloat d1 = abs(a - b);\n\tfloat d2 = abs(a - c);\n\tfloat d3 = abs(b - c);\n\tfloat d4 = abs(b - an);\n\tfloat d5 = abs(c - an);\n\tfloat d6 = abs(d1 - an);\n\tfloat d7 = abs(d2 - an);\n\tfloat d8 = abs(d3 - an);\n\tfloat d9 = abs(d4 - an);\n\tfloat d10 = abs(d5 - an);\n\tfloat d11 = abs(d6 - an);\n\tfloat d12 = abs(d7 - an);\n\tfloat d13 = abs(d8 - an);\n\tfloat d14 = abs(d9 - an);\n\tfloat d15 = abs(d10 - an);\n\tfloat d16 = abs(d11 - an);\n\tfloat d17 = abs(d12 - an);\n\tfloat d18 = abs(d13 - an);\n\tfloat d19 = abs(d14 - an);\n\tfloat d20 = abs(d15 - an);\n\tfloat d21 = abs(d16 - an);\n\tfloat d22 = abs(d17 - an);\n\tfloat d23 = abs(d18 - an);\n\tfloat d24 = abs(d19 - an);\n\tfloat d25 = abs(d20 - an);\n\tfloat d26 = abs(d21 - an);\n\tfloat d27 = abs(d22 - an);\n\tfloat d28 = abs(d23 - an);\n\tfloat d29 = abs(d24 - an);\n\tfloat d30 = abs(d25 - an);\n\tfloat d31 = abs(d26 - an);\n\tfloat d32 = abs(d27 - an);\n\tfloat d33 = abs(d28 - an);\n\tfloat d34 = abs(d29 - an);\n\tfloat d35 = abs(d30 - an);\n\tfloat d36 = abs(d31 - an);\n\tfloat d37 = abs(d32 - an);\n\tfloat d38 = abs(d33 - an);\n\tfloat d39 = abs(d34 - an);\n\tfloat d40 = abs(d35 - an);\n\tfloat d41 = abs(d36 - an);\n\tfloat d42 = abs(d37 - an);\n\tfloat d43 = abs(d38 - an);\n\tfloat d44 = abs(d39 - an);\n\tfloat d45 = abs(d40 - an);\n\tfloat d46 = abs(d41 - an);\n\tfloat d47 = abs(d42", " \n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 e3 = vec3(0.0, 0.0, 1.0);\n    vec3 q = p + e1;\n    vec3 r = p + e2;\n    vec3 s = p + e3;\n    vec3 t = p + e1 + e2;\n    vec3 u = p + e1 + e3;\n    vec3 v = p + e2 + e3;\n    vec3 w = p + e1 + e2 + e3;\n    float d1 = distance(p, q);\n    float d2 = distance(p, r);\n    float d3 = distance(p, s);\n    float d4 = distance(p, t);\n    float d5 = distance(p, u);\n    float d6 = distance(p, v);\n    float d7 = distance(p, w);\n    float d8 = distance(p, p);\n    float d9 = distance(p, p + e1 + e2 + e3);\n    float d10 = distance(p, p + e1 + e2);\n    float d11 = distance(p, p + e1 + e3);\n    float d12 = distance(p, p + e2 + e3);\n    float d13 = distance(p, p + e1);\n    float d14 = distance(p, p + e2);\n    float d15 = distance(p, p + e3);\n    float d16 = distance(p, p + e1 + e2 + e3);\n    float d17 = distance(p, p + e1 + e2);\n    float d18 = distance(p, p + e1 + e3);\n    float d19 = distance(p, p + e2 + e3);\n    float d20 = distance(p, p + e1);\n    float d21 = distance(p, p + e2);\n    float d22 = distance(p, p + e3);\n    float d23 = distance(p, p + e1 + e2 + e3);\n    float d24 = distance(p, p + e1 + e2);\n    float d25 = distance(p, p + e1 + e3);\n    float d26 = distance(p, p + e2 + e", "\t\n\tfloat t = t0;\n\tfloat res = 1.0;\n\tfor (int i = 0; i < 128; i++)\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = distance(p, sphere);\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\tres = 0.0;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif (t > t1)\n\t\t{\n\t\t\tres = 0.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 e = vec3(1.0, 0.0, 0.0);\n\treturn normalize(cross(dFdx(p), dFdy(p)));\n}\n\nvec3 getLightDir(vec3 p)\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 1.0);\n\treturn normalize(lightPos - p);\n}\n\nvec3 getLightColor(vec3 p)\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 1.0);\n\tvec3 lightDir = normalize(lightPos - p);\n\tvec3 n = getNormal(p);\n\tfloat diff = max(dot(n, lightDir), 0.0);\n\treturn vec3(1.0, 1.0, 1.0) * diff;\n}\n\nvec3 getAmbientColor(vec3 p)\n{\n\treturn vec3(0.1, 0.1, 0.1);\n}\n\nvec3 getSpecularColor(vec3 p)\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 1.0);\n\tvec3 lightDir = normalize(lightPos - p);\n\tvec3 n = getNormal(p);\n\tvec3 v = normalize(vec3(0.0, 0.0, 1.0) - p);\n\tfloat spec = pow(max(dot(n, reflect(-lightDir, n)), 0.0), 32.0);\n\treturn vec3(1.0, 1.0, 1.0) * spec;\n}\n\nvec3 getDiffuseColor(vec3 p)\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 1.0);\n\tvec3 lightDir = normalize(lightPos - p);\n\tvec3 n = getNormal(p);\n\tfloat diff = max(dot(n, lightDir), 0.0);\n\treturn vec3(1", "\t\n\tfloat ao = 0.0;\n\tfloat dist = 0.0;\n\tfloat step = 0.0;\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat h = 0.0;\n\tfloat r = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\tfloat Z = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0", " \n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.x * axis.z - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixXAngle(float angle) { \n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixYAngle(float angle) { \n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZAngle(float angle) { \n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) { \n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle)", " \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - iResolution.xy * 0.5);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - mouse);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float fov) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - mouse);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float fov, float aspect) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - mouse);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float fov, float aspect, float near, float far) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - mouse);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float fov, float aspect, float near, float far, float time) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray - mouse);\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float fov, float aspect, float near, float far, float time, float width, float height) { \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv, 0.0);\n    ray = normalize(ray", "return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);}\n\n// 2d noise with time\nfloat rand2d(vec2 co, float time){return fract(sin(dot(co.xy,vec2(time,12.9898))) * 43758.5453);}\n\n// 3d noise with time\nfloat rand3d(vec3 co, float time){return fract(sin(dot(co.xyz,vec3(time,12.9898,78.233))) * 43758.5453);}\n\n// 4d noise with time\nfloat rand4d(vec4 co, float time){return fract(sin(dot(co.xyzw,vec4(time,12.9898,78.233,123.456))) * 43758.5453);}\n\n// 2d noise with time\nfloat rand2d(vec2 co, float time){return fract(sin(dot(co.xy,vec2(time,12.9898))) * 43758.5453);}\n\n// 3d noise with time\nfloat rand3d(vec3 co, float time){return fract(sin(dot(co.xyz,vec3(time,12.9898,78.233))) * 43758.5453);}\n\n// 4d noise with time\nfloat rand4d(vec4 co, float time){return fract(sin(dot(co.xyzw,vec4(time,12.9898,78.233,123.456))) * 43758.5453);}\n\n// 2d noise with time\nfloat rand2d(vec2 co, float time){return fract(sin(dot(co.xy,vec2(time,12.9898))) * 43758.5453);}\n\n// 3d noise with time\nfloat rand3d(vec3 co, float time){return fract(sin(dot(co.xyz,vec3(time,12.9898,78.233))) * 43758.5453);}\n\n// 4d noise with time\nfloat rand4d(vec4 co, float time){return fract(sin(dot(co.xyzw,vec4(time,12.9898,78.233,123.456))) * 43758.5453);}\n\n// 2d noise with time\nfloat rand2d(vec2 co, float time){return fract(sin(dot(co.xy,vec2(time,12.9898))) * 43758.5453);}\n\n// 3d noise with time\nfloat rand3d(vec3 co,", " return fract(sin(dot(p, vec3(12.9898, 78.233, 57.345)))* 43758.5453); }\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 78.233)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(float p){ return fract(sin(p*12.9898)* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 78.233)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p){ return fract(sin(dot(p, vec3(12.9898, 78.233, 57.345)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec4 p){ return fract(sin(dot(p, vec4(12.9898, 78.233, 57.345, 23.345)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p, float seed){ return fract(sin(dot(p, vec2(seed, 78.233)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p, float seed){ return fract(sin(dot(p, vec3(seed, 78.233, 57.345)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec4 p, float seed){ return fract(sin(dot(p, vec4(seed, 78.233, 57.345, 23.345)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p, float seed1, float seed2){ return fract(sin(dot(p, vec2(seed1, seed2)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p, float seed1, float seed2, float seed3){ return fract(sin(dot(p, vec3(seed1, seed2, seed3)))* 43758.5453); }\n\n// Hash for 1d vectors\nfloat rand", " // 3D value noise\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( dot(vec3(0.0, 0.0, 0.0), f-vec3(0.0, 0.0, 0.0)), dot(vec3(1.0, 1.0, 0.0), f-vec3(1.0, 0.0, 0.0)), f.x), mix(dot(vec3(1.0, 0.0, 0.0), f-vec3(1.0, 0.0, 0.0)), dot(vec3(1.0, 1.0, 1.0), f-vec3(1.0, 1.0, 1.0)), f.y), f.z), mix(mix(dot(vec3(0.0, 1.0, 0.0), f-vec3(0.0, 1.0, 0.0)), dot(vec3(1.0, 1.0, 0.0), f-vec3(1.0, 1.0, 0.0)), f.x), mix(dot(vec3(1.0, 1.0, 1.0), f-vec3(1.0, 1.0, 1.0)), dot(vec3(1.0, 0.0, 0.0), f-vec3(1.0, 0.0, 0.0)), f.y), f.z), f.z);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x, float scale){ // 3D value noise\n    vec3 p = floor(x/scale);\n    vec3 f = fract(x/scale);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( dot(vec3(0.0, 0.0, 0.0), f-vec3(0.0, 0.0, ", " // 3D simplex noise\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, i);\n    float g = (n*(n*n*181.0+n*-280.0+n*60.0)+n*-13.0+n*1.0)/140.0;\n    float a = dot(f, f);\n    float b = a*a*a*(10.0+a*-15.0);\n    return mix(mix(mix(noise3d(i+vec3(0,0,0)), noise3d(i+vec3(1,0,0)), f.x), mix(noise3d(i+vec3(0,1,0)), noise3d(i+vec3(1,1,0)), f.x), f.y), mix(mix(noise3d(i+vec3(0,0,1)), noise3d(i+vec3(1,0,1)), f.x), mix(noise3d(i+vec3(0,1,1)), noise3d(i+vec3(1,1,1)), f.x), f.y), f.z);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){ // 3D simplex noise\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, i);\n    float g = (n*(n*n*181.0+n*-280.0+n*60.0)+n*-13.0+n*1.0)/140.0;\n    float a = dot(f, f);\n    float b = a*a*a*(10.0+a*-15.0);\n    return mix(mix(mix(noise3d(i+vec3(0,0,0)), noise3d(i+vec3(1,0,0)), f.x), mix(noise3d(i+vec3(0,1,0)), noise3d(i+vec3(1,1,0)), f.x), f.y), mix(mix(noise3d(i+vec3(0,0,1)), noise3d(i+vec3(1,0,1)), f.x), mix(noise3d(i+vec", " // 3D FBM\n    float f = 0.0;\n    float g = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n", " // pos = (x,y,z)\n    vec2 res = vec2(0.0,0.0);\n    float dist = length(pos);\n    float dist2 = dist * dist;\n    float dist3 = dist2 * dist;\n    float dist4 = dist3 * dist;\n    float dist5 = dist4 * dist;\n    float dist6 = dist5 * dist;\n    float dist7 = dist6 * dist;\n    float dist8 = dist7 * dist;\n    float dist9 = dist8 * dist;\n    float dist10 = dist9 * dist;\n    float dist11 = dist10 * dist;\n    float dist12 = dist11 * dist;\n    float dist13 = dist12 * dist;\n    float dist14 = dist13 * dist;\n    float dist15 = dist14 * dist;\n    float dist16 = dist15 * dist;\n    float dist17 = dist16 * dist;\n    float dist18 = dist17 * dist;\n    float dist19 = dist18 * dist;\n    float dist20 = dist19 * dist;\n    float dist21 = dist20 * dist;\n    float dist22 = dist21 * dist;\n    float dist23 = dist22 * dist;\n    float dist24 = dist23 * dist;\n    float dist25 = dist24 * dist;\n    float dist26 = dist25 * dist;\n    float dist27 = dist26 * dist;\n    float dist28 = dist27 * dist;\n    float dist29 = dist28 * dist;\n    float dist30 = dist29 * dist;\n    float dist31 = dist30 * dist;\n    float dist32 = dist31 * dist;\n    float dist33 = dist32 * dist;\n    float dist34 = dist33 * dist;\n    float dist35 = dist34 * dist;\n    float dist36 = dist35 * dist;\n    float dist37 = dist36 * dist;\n    float dist38 = dist37 * dist;\n    float dist39 = dist38 * dist;\n    float dist40 = dist39 * dist;\n    float dist41 = dist40 * dist;\n    float dist42 = dist41 * dist;\n    float dist43 = dist42 * dist;\n    float dist44 = dist43 * dist;\n    float dist45 = dist44 * dist;\n    float dist46 = dist45 * dist;\n    float dist47 = dist46 * dist;\n    float dist48 = dist47 * dist;\n    float dist49 = dist48 * dist;\n    float", " // random is the random seed for the ground\n    vec3 color = vec3(0.0);\n    float coverage = 0.0;\n    float cloudHeight = 0.0;\n    float cloudCoverage = 0.0;\n    float cloudCoverage2 = 0.0;\n    float cloudCoverage3 = 0.0;\n    float cloudCoverage4 = 0.0;\n    float cloudCoverage5 = 0.0;\n    float cloudCoverage6 = 0.0;\n    float cloudCoverage7 = 0.0;\n    float cloudCoverage8 = 0.0;\n    float cloudCoverage9 = 0.0;\n    float cloudCoverage10 = 0.0;\n    float cloudCoverage11 = 0.0;\n    float cloudCoverage12 = 0.0;\n    float cloudCoverage13 = 0.0;\n    float cloudCoverage14 = 0.0;\n    float cloudCoverage15 = 0.0;\n    float cloudCoverage16 = 0.0;\n    float cloudCoverage17 = 0.0;\n    float cloudCoverage18 = 0.0;\n    float cloudCoverage19 = 0.0;\n    float cloudCoverage20 = 0.0;\n    float cloudCoverage21 = 0.0;\n    float cloudCoverage22 = 0.0;\n    float cloudCoverage23 = 0.0;\n    float cloudCoverage24 = 0.0;\n    float cloudCoverage25 = 0.0;\n    float cloudCoverage26 = 0.0;\n    float cloudCoverage27 = 0.0;\n    float cloudCoverage28 = 0.0;\n    float cloudCoverage29 = 0.0;\n    float cloudCoverage30 = 0.0;\n    float cloudCoverage31 = 0.0;\n    float cloudCoverage32 = 0.0;\n    float cloudCoverage33 = 0.0;\n    float cloudCoverage34 = 0.0;\n    float cloudCoverage35 = 0.0;\n    float cloudCoverage36 = 0.0;\n    float cloudCoverage37 = 0.0;\n    float cloudCoverage38 = 0.0;\n    float cloudCoverage39 = 0.0;\n    float cloudCoverage40 = 0.0;\n    float cloudCoverage41 = 0.0;\n    float cloudCoverage42 = 0.0;\n    float cloudCoverage43 = 0.0", " // pointStart, pointEnd, background, distance, random\n    vec3 color = vec3(0.0);\n    float fog = 1.0;\n    float fogDist = 0.0;\n    float fogDist2 = 0.0;\n    float fogDist3 = 0.0;\n    float fogDist4 = 0.0;\n    float fogDist5 = 0.0;\n    float fogDist6 = 0.0;\n    float fogDist7 = 0.0;\n    float fogDist8 = 0.0;\n    float fogDist9 = 0.0;\n    float fogDist10 = 0.0;\n    float fogDist11 = 0.0;\n    float fogDist12 = 0.0;\n    float fogDist13 = 0.0;\n    float fogDist14 = 0.0;\n    float fogDist15 = 0.0;\n    float fogDist16 = 0.0;\n    float fogDist17 = 0.0;\n    float fogDist18 = 0.0;\n    float fogDist19 = 0.0;\n    float fogDist20 = 0.0;\n    float fogDist21 = 0.0;\n    float fogDist22 = 0.0;\n    float fogDist23 = 0.0;\n    float fogDist24 = 0.0;\n    float fogDist25 = 0.0;\n    float fogDist26 = 0.0;\n    float fogDist27 = 0.0;\n    float fogDist28 = 0.0;\n    float fogDist29 = 0.0;\n    float fogDist30 = 0.0;\n    float fogDist31 = 0.0;\n    float fogDist32 = 0.0;\n    float fogDist33 = 0.0;\n    float fogDist34 = 0.0;\n    float fogDist35 = 0.0;\n    float fogDist36 = 0.0;\n    float fogDist37 = 0.0;\n    float fogDist38 = 0.0;\n    float fogDist39 = 0.0;\n    float fogDist40 = 0.0;\n    float fogDist41 = 0.0;\n    float fogDist42 = 0.0;\n    float fogDist43 = 0.0;\n    float fogDist44 =", " \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) { \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) { \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) { \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) { \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) { \n    color = color * (color * (color * 0.15 + 0.1) + 0.05);\n    return color / (color * 0.055 + 0.055) + 0.12;\n}\n\n// Great tonemapping"]}