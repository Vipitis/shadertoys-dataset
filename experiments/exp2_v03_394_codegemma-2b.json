{"generations": ["\n    return s.x;\n}\nfloat SH_0_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_0_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_1_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_1_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_1_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_2_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_2_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_2_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_3_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_3_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_3_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_4_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_4_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_4_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_5_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_5_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_5_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_6_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_6_1( in vec3 s ) {\n    return s.y;\n}\nfloat SH_6_2( in vec3 s ) {\n    return s.z;\n}\nfloat SH_7_0( in vec3 s ) {\n    return s.x;\n}\nfloat SH_7_1( in vec3 s ) {\n    return s.y", "\n    return abs( cross( b-a, p-a ) ) / length( b-a );\n}\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    return max( 0.0, min( 1.0, line( a, b, p ) ) );\n}\n// distance to a circle\nfloat circle( in vec2 p, in vec2 c, in float r )\n{\n    return length( p-c ) - r;\n}\n// distance to a circle segment\nfloat circleSegment( in vec2 p, in vec2 c, in float r )\n{\n    return max( 0.0, min( 1.0, circle( p, c, r ) ) );\n}\n// distance to a triangle\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    vec2 ab = b-a, ac = c-a, ap = p-a;\n    float d1 = cross( ab, ap ) / length( ab );\n    float d2 = cross( ac, ap ) / length( ac );\n    return min( min( d1, d2 ), max( d1, d2 ) );\n}\n// distance to a triangle segment\nfloat triangleSegment( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    vec2 ab = b-a, ac = c-a, ap = p-a;\n    float d1 = max( 0.0, min( 1.0, cross( ab, ap ) / length( ab ) ) );\n    float d2 = max( 0.0, min( 1.0, cross( ac, ap ) / length( ac ) ) );\n    return min( min( d1, d2 ), max( d1, d2 ) );\n}\n// distance to a polygon\nfloat polygon( in vec2 p, in vec2<|file_separator|>", "\n    return ( dot( v, r ) < 0.0 )? -v : v;\n}\n<|file_separator|>", "\n    vec2 n = normalize( cross( r, v ) );\n    return v - 2.0 * dot( n, v ) * n;\n}<|file_separator|>// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    vec2 n = normalize( cross( r, v ) );\n    return v - 2.0 * dot( n, v ) * n;\n}<|file_separator|>// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    vec2 n = normalize( cross( r, v ) );\n    return v - 2.0 * dot( n, v ) * n;\n}<|file_separator|>// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    vec2 n = normalize( cross( r, v ) );\n    return v - 2.0 * dot( n, v ) * n;\n}<|file_separator|>", "\n    vec2 w = v - r;\n    return w.x * w.x + w.y * w.y < r.x * r.x + r.y * r.y? w : v;\n}\n<|file_separator|>// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    vec2 w = v - r;\n    return w.x * w.x + w.y * w.y > r.x * r.x + r.y * r.y? w : v;\n}\n<|file_separator|>", "\n    vec2 d = abs(p) - vec2(a.x, b.y);\n    float h = max(abs(d.x), abs(d.y));\n    return min(h, max(w1, w2));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n    vec2 d = abs(p) - vec2(a.x, b.y);\n    float h = max(abs(d.x), abs(d.y));\n    return min(h, max(min(w1, w2), w3));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4 )\n{\n    vec2 d = abs(p) - vec2(a.x, b.y);\n    float h = max(abs(d.x), abs(d.y));\n    return min(h, max(min(min(w1, w2), w3), w4));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4, float w5 )\n{\n    vec2 d = abs(p) - vec2(a.x, b.y);\n    float h = max(abs(d.x), abs(d.y));\n    return min(h, max(min(min(min(w1, w2), w3), w4), w5));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4, float w5, float w6 )\n{\n    vec2 d = abs(p) - vec2(a.x, b.y);\n    float h = max(abs(d.x), abs(d.y));\n    return min(h, max(min(min(min(min(w1, w2), w3), w4), w5), w6));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w", "\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle, 1.0);\n    }\n    return sunColor * sunIntensity;\n}\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle, 1.0);\n    }\n    return sunColor * sunIntensity;\n}\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle, 1.0);\n    }\n    return sunColor * sunIntensity;\n}\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle, 1.0);\n    }\n    return sunColor * sunIntensity;\n}\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle,", "\n    vec4 a = p1;\n    vec4 b = p2 - p0;\n    vec4 c = p0 - 2.0 * p1 + p2;\n    vec4 d = p1 - p0;\n    return 0.5 * (a + b * t + c * t * t + d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = p1;\n    vec4 b = p2 - p0;\n    vec4 c = p0 - 2.0 * p1 + p2;\n    vec4 d = p1 - p0;\n    return 0.5 * (a + b * t + c * t * t + d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = p1;\n    vec4 b = p2 - p0;\n    vec4 c = p0 - 2.0 * p1 + p2;\n    vec4 d = p1 - p0;\n    return 0.5 * (a + b * t + c * t * t + d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 a = p1;\n    vec4 b = p2 - p0;\n    vec4 c = p0 - 2.0 * p1 + p2;\n    vec4 d = p1 - p0;\n    return 0.5 * (a + b * t + c * t * t + d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{", "\n\tvec3 q = p;\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.x);\n\tq.z += nudge * sin(q.y);\n\tq.x += nudge * sin(q.x);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);", "\n    vec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p1 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(2.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(3.0, 0.0, 0.0, 1.0);\n    vec4 p4 = vec4(4.0, 0.0, 0.0, 1.0);\n    vec4 p5 = vec4(5.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(6.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(7.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(8.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(9.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(10.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(11.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(12.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(13.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(14.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(15.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(16.0, 0.0, 0.0, 1.0);\n    vec4 p", "\n    return fract(sin(u) * 43758.5453123);\n}\n\nfloat Hash2d(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 p)\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.67))) * 43758.5453);\n}\n\nfloat Noise1d(float p)\n{\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(Hash1d(fl), Hash1d(fl + 1.0), fc);\n}\n\nfloat Noise2d(vec2 p)\n{\n    vec2 fl = floor(p);\n    vec2 fc = fract(p);\n    vec2 u = fc * fc * (3.0 - 2.0 * fc);\n    return mix(mix(Hash2d(fl + vec2(0.0, 0.0)), Hash2d(fl + vec2(1.0, 0.0)), u.x), mix(Hash2d(fl + vec2(0.0, 1.0)), Hash2d(fl + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat Noise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fc = fract(p);\n    vec3 u = fc * fc * (3.0 - 2.0 * fc);\n    return mix(mix(Hash3d(fl + vec3(0.0, 0.0, 0.0)), Hash3d(fl + vec3(1.0, 0.0, 0.0)), u.x), mix(mix(Hash3d(fl + vec3(0.0, 1.0, 0.0)), Hash3d(fl + vec3(1.0, 1.0, 0.0", "\n\tvec3 q = p;\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.x);\n\tq.z += nudge * sin(q.y);\n\tq.x += nudge * sin(q.x);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);\n\tq.x += nudge * sin(q.y);\n\tq.y += nudge * sin(q.z);\n\tq.z += nudge * sin(q.x);", "\n    vec3 d = p - cameraPosition;\n    return length(d);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);\n    float s = sin(t);\n    float c = cos(t);\n    return vec3(s, 0.0, c);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction2(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);\n    float s = sin(t);\n    float c = cos(t);\n    return vec3(s, 0.0, c);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction3(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);\n    float s = sin(t);\n    float c = cos(t);\n    return vec3(s, 0.0, c);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction4(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);\n    float s = sin(t);\n    float c = cos(t);\n    return vec3(s, 0.0, c);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction5(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);\n    float s = sin(t);\n    float c = cos(t);\n    return vec3(s, 0.0, c);\n}\n\n// This is the crazy function that makes the crazy fractally shape\nvec3 crazyFunction6(vec3 p)\n{\n    vec3 d = p - cameraPosition;\n    float t = atan(d.z, d.x);", "\n    vec3 envColor = vec3(0.0);\n    vec3 envColor2 = vec3(0.0);\n    vec3 envColor3 = vec3(0.0);\n    vec3 envColor4 = vec3(0.0);\n    vec3 envColor5 = vec3(0.0);\n    vec3 envColor6 = vec3(0.0);\n    vec3 envColor7 = vec3(0.0);\n    vec3 envColor8 = vec3(0.0);\n    vec3 envColor9 = vec3(0.0);\n    vec3 envColor10 = vec3(0.0);\n    vec3 envColor11 = vec3(0.0);\n    vec3 envColor12 = vec3(0.0);\n    vec3 envColor13 = vec3(0.0);\n    vec3 envColor14 = vec3(0.0);\n    vec3 envColor15 = vec3(0.0);\n    vec3 envColor16 = vec3(0.0);\n    vec3 envColor17 = vec3(0.0);\n    vec3 envColor18 = vec3(0.0);\n    vec3 envColor19 = vec3(0.0);\n    vec3 envColor20 = vec3(0.0);\n    vec3 envColor21 = vec3(0.0);\n    vec3 envColor22 = vec3(0.0);\n    vec3 envColor23 = vec3(0.0);\n    vec3 envColor24 = vec3(0.0);\n    vec3 envColor25 = vec3(0.0);\n    vec3 envColor26 = vec3(0.0);\n    vec3 envColor27 = vec3(0.0);\n    vec3 envColor28 = vec3(0.0);\n    vec3 envColor29 = vec3(0.0);\n    vec3 envColor30 = vec3(0.0);\n    vec3 envColor31 = vec3(0.0);\n    vec3 envColor32 = vec3(0.0);\n    vec3 envColor33 = vec", "\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( 0.0, 1.0 - ( a - b ) / k );\n    return a - h * h * ( a - 2.0 * b + b );\n}\n\n//", "\n    float a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n    float b = 2.0 * dot(dirVecPLZNormalizeMeFirst, pos - spherePos);\n    float c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        return -1.0;\n    }\n    else\n    {\n        return (-b - sqrt(discriminant)) / (2.0 * a);\n    }\n}\n\nvec3 GetNormal(vec3 pos, vec3 spherePos, float rad)\n{\n    return normalize(pos - spherePos);\n}\n\nvec3 GetColor(vec3 pos, vec3 spherePos, float rad)\n{\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 GetColor(vec3 pos, vec3 spherePos, float rad, vec3 lightPos, vec3 lightColor)\n{\n    vec3 normal = GetNormal(pos, spherePos, rad);\n    vec3 lightDir = normalize(lightPos - pos);\n    float lightDist = length(lightPos - pos);\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n    return diffuseColor;\n}\n\nvec3 GetColor(vec3 pos, vec3 spherePos, float rad, vec3 lightPos, vec3 lightColor, vec3 lightPos2, vec3 lightColor2)\n{\n    vec3 normal = GetNormal(pos, spherePos, rad);\n    vec3 lightDir = normalize(lightPos - pos);\n    float lightDist = length(lightPos - pos);\n    vec3 lightDir2 = normalize(lightPos2 - pos);\n    float lightDist2 = length(lightPos2 - pos);\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    float diffuse2 = max(dot(normal, lightDir2), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n    vec3 diffuseColor2 = diffuse2 * lightColor2", "\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p1 = p + d;\n        vec3 p2 = p - d;\n        vec3 p3 = p + vec3(d.x, d.y, 0.0);\n        vec3 p4 = p - vec3(d.x, d.y, 0.0);\n        vec3 p5 = p + vec3(d.x, 0.0, d.y);\n        vec3 p6 = p - vec3(d.x, 0.0, d.y);\n        vec3 p7 = p + vec3(0.0, d.y, d.x);\n        vec3 p8 = p - vec3(0.0, d.y, d.x);\n        vec3 p9 = p + vec3(d.y, d.x, 0.0);\n        vec3 p10 = p - vec3(d.y, d.x, 0.0);\n        vec3 p11 = p + vec3(d.y, 0.0, d.x);\n        vec3 p12 = p - vec3(d.y, 0.0, d.x);\n        vec3 p13 = p + vec3(0.0, d.x, d.y);\n        vec3 p14 = p - vec3(0.0, d.x, d.y);\n        vec3 p15 = p + vec3(d.x, d.y, d.z);\n        vec3 p16 = p - vec3(d.x, d.y, d.z);\n        vec3 p17 = p + vec3(d.x, d.z, d.y);\n        vec3 p18 = p - vec3(d.x, d.z, d.y);\n        vec3 p19 = p + vec3(d.z, d.y, d.x);\n        vec3 p20 = p - vec3(d.z, d.y, d.x);\n        vec3", "\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t),\n        cos(t)\n    );\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(\n        cos(t),\n        sin(t", "\n    return vec3(\n        t * t * t,\n        3 * t * t - 2 * t,\n        -3 * t * t + 2 * t\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD2(float t)\n{\n    return vec3(\n        3 * t * t,\n        6 * t - 2,\n        -6 * t + 2\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD3(float t)\n{\n    return vec3(\n        6 * t,\n        12 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD4(float t)\n{\n    return vec3(\n        12 * t,\n        24 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD5(float t)\n{\n    return vec3(\n        24 * t,\n        48 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD6(float t)\n{\n    return vec3(\n        48 * t,\n        96 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD7(float t)\n{\n    return vec3(\n        96 * t,\n        192 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD8(float t)\n{\n    return vec3(\n        192 * t,\n        384 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD9(float t)\n{\n    return vec3(\n        384 * t,\n        768 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD10(float t)\n{\n    return vec3(\n        768 * t,\n        1536 * t,\n        0\n    );\n}\n\n// curve derivative (velocity)\nvec3 mapD11(float t)\n{\n    return vec3(\n", "\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.0 - t),\n        3.0 * (1.0 - t) * (1.0 - t) * t,\n        3.0 * (1.0 - t) * t * t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.0 - t),\n        3.0 * (1.0 - t) * (1.0 - t) * t,\n        3.0 * (1.0 - t) * t * t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.0 - t),\n        3.0 * (1.0 - t) * (1.0 - t) * t,\n        3.0 * (1.0 - t) * t * t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.0 - t),\n        3.0 * (1.0 - t) * (1.0 - t) * t,\n        3.0 * (1.0 - t) * t * t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.0 - t),\n        3.0 * (1.0 - t) * (1.0 - t) * t,\n        3.0 * (1.0 - t) * t * t\n    );\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(\n        (1.0 - t) * (1.0 - t) * (1.", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    if( t < 0.0 )\n    {\n        return p - a;\n    }\n    if( t > 1.0 )\n    {\n        return p - b;\n    }\n    return a + t * ab;\n}\n<|file_separator|>// signed squared distance between point and segment\nfloat ssqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    if( t < 0.0 )\n    {\n        return dot( ap, ap ) - dot( ab, ab );\n    }\n    if( t > 1.0 )\n    {\n        return dot( ap, ap ) - dot( ab, ab );\n    }\n    return dot( ap, ap ) - dot( ab, ab ) * t * t;\n}\n<|file_separator|>// signed squared distance between point and line\nfloat ssqdPointLine( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    if( t < 0.0 )\n    {\n        return dot( ap, ap ) - dot( ab, ab );\n    }\n    if( t > 1.0 )\n    {\n        return dot( ap, ap ) - dot( ab, ab );\n    }\n    return dot( ap, ap ) - dot( ab, ab ) * t * t;\n}\n<|file_separator|>// signed squared distance between point and triangle\nfloat ssqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    vec3 ab2 = ab * ab;\n    vec3 ao2 = ao * ao;\n    vec3 abao = ab * ao;\n    float t = dot( abao, ab ) / dot( ab, ab );\n    vec3 p = a + ab * t;\n    vec3 q = p - ao;\n    float q2 = dot( q, q );\n    float t2 = dot( q, ab );\n    float t3 = t2 * t2;\n    float t4 = t3 * t2;\n    float t5 = t4 * t2;\n    float t6 = t5 * t2;\n    float t7 = t6 * t2;\n    float t8 = t7 * t2;\n    float t9 = t8 * t2;\n    float t10 = t9 * t2;\n    float t11 = t10 * t2;\n    float t12 = t11 * t2;\n    float t13 = t12 * t2;\n    float t14 = t13 * t2;\n    float t15 = t14 * t2;\n    float t16 = t15 * t2;\n    float t17 = t16 * t2;\n    float t18 = t17 * t2;\n    float t19 = t18 * t2;\n    float t20 = t19 * t2;\n    float t21 = t20 * t2;\n    float t22 = t21 * t2;\n    float t23 = t22 * t2;\n    float t24 = t23 * t2;\n    float t25 = t24 * t2;\n    float t26 = t25 * t2;\n    float t27 = t26 * t2;\n    float t28 = t27 * t2;\n    float t29 = t28 * t2;\n    float t30 = t29 * t2;\n    float t31 = t30 * t2;\n    float", "\n    vec2 q = abs(p) - b;\n    vec2 a = vec2(max(q.x, q.y), max(-q.x, -q.y));\n    vec2 d = vec2(min(q.x, q.y), min(-q.x, -q.y));\n    vec2 s = vec2(max(a.x, a.y), max(-a.x, -a.y));\n    vec2 t = vec2(min(a.x, a.y), min(-a.x, -a.y));\n    vec2 n = vec2(max(t.x, t.y), max(-t.x, -t.y));\n    vec2 o = vec2(min(t.x, t.y), min(-t.x, -t.y));\n    vec2 u = vec2(max(s.x, s.y), max(-s.x, -s.y));\n    vec2 v = vec2(min(s.x, s.y), min(-s.x, -s.y));\n    vec2 w = vec2(max(o.x, o.y), max(-o.x, -o.y));\n    vec2 x = vec2(min(o.x, o.y), min(-o.x, -o.y));\n    vec2 y = vec2(max(u.x, u.y), max(-u.x, -u.y));\n    vec2 z = vec2(min(u.x, u.y), min(-u.x, -u.y));\n    vec2 A = vec2(max(v.x, v.y), max(-v.x, -v.y));\n    vec2 B = vec2(min(v.x, v.y), min(-v.x, -v.y));\n    vec2 C = vec2(max(w.x, w.y), max(-w.x, -w.y));\n    vec2 D = vec2(min(w.x, w.y), min(-w.x, -w.y));\n    vec2 E = vec2(max(x.x, x.y),", "\n    vec3 sunColor = sunCol;\n    float sunIntensity = 1.0;\n    float sunAngle = dot(sunDir, rayDir);\n    if (sunAngle > 0.0)\n    {\n        sunIntensity = pow(sunAngle, 1.0);\n    }\n    return sunColor * sunIntensity;\n}\n// This function basically is a procedural environment map that makes the moon\nvec3 moonCol = vec3(255.0, 255.0, 255.0) / 255.0;\nvec3 GetMoonColorReflection(vec3 rayDir, vec3 moonDir)\n{\n    vec3 moonColor = moonCol;\n    float moonIntensity = 1.0;\n    float moonAngle = dot(moonDir, rayDir);\n    if (moonAngle > 0.0)\n    {\n        moonIntensity = pow(moonAngle, 1.0);\n    }\n    return moonColor * moonIntensity;\n}\n// This function basically is a procedural environment map that makes the earth\nvec3 earthCol = vec3(100.0, 100.0, 255.0) / 255.0;\nvec3 GetEarthColorReflection(vec3 rayDir, vec3 earthDir)\n{\n    vec3 earthColor = earthCol;\n    float earthIntensity = 1.0;\n    float earthAngle = dot(earthDir, rayDir);\n    if (earthAngle > 0.0)\n    {\n        earthIntensity = pow(earthAngle, 1.0);\n    }\n    return earthColor * earthIntensity;\n}\n// This function basically is a procedural environment map that makes the water\nvec3 waterCol = vec3(100.0, 100.0, 255.0) / 255.0;\nvec3 GetWaterColorReflection(vec3 rayDir, vec3 waterDir)\n{\n    vec3 waterColor = waterCol;\n    float waterIntensity = 1.0;\n    float waterAngle = dot(waterDir, rayDir);\n    if (waterAngle > 0.0)\n    {\n        waterIntensity = pow(waterAngle, 1", "\n    // First we need to calculate the direction of the ray\n    // We do this by calculating the vector from the origin to the target\n    // and then normalizing it.\n    vec3 dir = normalize( ta - ro );\n    \n    // Now we need to calculate the rotation matrix\n    // We do this by first calculating the rotation matrix for the roll\n    // and then the rotation matrix for the pitch\n    // We do this by first calculating the rotation matrix for the roll\n    // and then the rotation matrix for the pitch\n    mat3 rotRoll = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos( roll ), -sin( roll ),\n        0.0, sin( roll ), cos( roll )\n    );\n    \n    // Now we need to calculate the rotation matrix for the pitch\n    // We do this by first calculating the rotation matrix for the roll\n    // and then the rotation matrix for the pitch\n    mat3 rotPitch = mat3(\n        cos( pitch ), 0.0, sin( pitch ),\n        0.0, 1.0, 0.0,\n        -sin( pitch ), 0.0, cos( pitch )\n    );\n    \n    // Now we need to calculate the rotation matrix for the yaw\n    // We do this by first calculating the rotation matrix for the roll\n    // and then the rotation matrix for the pitch\n    mat3 rotYaw = mat3(\n        cos( yaw ), -sin( yaw ), 0.0,\n        sin( yaw ), cos( yaw ), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Now we need to calculate the rotation matrix for the roll\n    // We do this by first calculating the rotation matrix for the roll\n    // and then the rotation matrix for the pitch\n    mat3 rotRoll = mat3(\n        cos( roll ), -sin( roll ), 0.0,\n        sin( roll ), cos( roll ), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Now we need to calculate the rotation matrix for the pitch\n    // We do this by first calculating the rotation matrix for the roll\n    // and", "\n    vec3 rayDirection = normalize( currentRayPosition.xyz );\n    vec3 rayPosition = currentRayPosition.xyz;\n    vec3 rayOrigin = rayPosition;\n    vec3 rayDirection2 = rayDirection;\n    vec3 rayPosition2 = rayPosition;\n    vec3 rayOrigin2 = rayPosition;\n    vec3 rayDirection3 = rayDirection;\n    vec3 rayPosition3 = rayPosition;\n    vec3 rayOrigin3 = rayPosition;\n    vec3 rayDirection4 = rayDirection;\n    vec3 rayPosition4 = rayPosition;\n    vec3 rayOrigin4 = rayPosition;\n    vec3 rayDirection5 = rayDirection;\n    vec3 rayPosition5 = rayPosition;\n    vec3 rayOrigin5 = rayPosition;\n    vec3 rayDirection6 = rayDirection;\n    vec3 rayPosition6 = rayPosition;\n    vec3 rayOrigin6 = rayPosition;\n    vec3 rayDirection7 = rayDirection;\n    vec3 rayPosition7 = rayPosition;\n    vec3 rayOrigin7 = rayPosition;\n    vec3 rayDirection8 = rayDirection;\n    vec3 rayPosition8 = rayPosition;\n    vec3 rayOrigin8 = rayPosition;\n    vec3 rayDirection9 = rayDirection;\n    vec3 rayPosition9 = rayPosition;\n    vec3 rayOrigin9 = rayPosition;\n    vec3 rayDirection10 = rayDirection;\n    vec3 rayPosition10 = rayPosition;\n    vec3 rayOrigin10 = rayPosition;\n    vec3 rayDirection11 = rayDirection;\n    vec3 rayPosition11 = rayPosition;\n    vec3 rayOrigin11 = rayPosition;\n    vec3 rayDirection12 = rayDirection;\n    vec3 rayPosition12 = rayPosition;\n    vec3 rayOrigin12 = rayPosition;\n    vec3 rayDirection13 = rayDirection;\n    vec3 rayPosition13 = rayPosition;\n    vec3 rayOrigin13 = rayPosition;\n    vec3 rayDirection14 = rayDirection;\n    vec3 rayPosition14 = rayPosition;\n    vec3 rayOrigin14 = rayPosition;\n    vec3 rayDirection15 = rayDirection;\n    vec3 rayPosition15 = rayPosition;\n    vec3 rayOrigin", "\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the second thing\n    float distanceToThing2 = distance( thing2, vec2( 0.0, 0.0 ) );\n    \n    // This is the distance to the first thing\n    float distanceToThing1 = distance( thing1, vec2( 0.", "\n    vec2 closestThing = vec2( 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // The SDF is a sphere, so we can just use the\n    // same code as the sphere.\n    float radius = 0.1;\n    float sdf = sphereSDF( positionOfHit, radius );\n    \n    // The normal is the same as the direction of the\n    // ray, but we have to make sure that the normal\n    // is always pointing in the same direction.\n    vec3 normal = normalize( positionOfHit );\n    \n    // The normal is the same as the direction of the\n    // ray, but we have to make sure that the normal\n    // is always pointing in the same direction.\n    return normal;\n}<|file_separator|>// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    // The SDF is a sphere, so we can just use the\n    // same code as the sphere.\n    float radius = 0.1;\n    float sdf = sphereSDF( positionOfHit, radius );\n    \n    // The normal is the same as the direction of the\n    // ray, but we have to make sure that the normal\n    // is always pointing in the same direction.\n    vec3 normal = normalize( positionOfHit );\n    \n    // The normal is the same as the direction of the\n    // ray, but we have to make sure that the normal\n    // is always pointing in the same direction.\n    return normal;\n}<|file_separator|>// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    // The SDF is a sphere, so we can just use", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the main function that will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be called by the main function\n// it will be", "\n    vec3 color = vec3(0.0);\n    float distance = 0.0;\n    float maxDistance = 1.0;\n    float boxSize = 0.5;\n    float boxHeight = 1.0;\n    vec3 boxPosition = vec3(0.0, boxHeight/2.0, 0.0);\n    vec3 boxNormal = vec3(0.0, 1.0, 0.0);\n    vec3 boxColor = vec3(1.0, 0.0, 0.0);\n    \n    // Check if the hit is inside the box\n    if (abs(positionOfHit.x - boxPosition.x) < boxSize &&\n        abs(positionOfHit.y - boxPosition.y) < boxSize &&\n        abs(positionOfHit.z - boxPosition.z) < boxSize) {\n        \n        // Calculate the distance from the hit to the box\n        distance = length(positionOfHit - boxPosition);\n        \n        // Normalize the normal of the surface\n        normalOfSurface = normalize(normalOfSurface);\n        \n        // Calculate the dot product of the normal of the surface and the normal of the box\n        float dotProduct = dot(normalOfSurface, boxNormal);\n        \n        // Calculate the color of the box\n        color = boxColor * dotProduct;\n    }\n    \n    // Return the color of the box\n    return color;\n}\n<|file_separator|>", "\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n    vec3 normal = vec3( 0.0, 0.0, 0.0 );\n    vec3 hitPoint = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflection = vec3( 0.0, 0.0, 0.0 );\n    vec3 refraction = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay2 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay3 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay4 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay5 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay6 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay7 = vec3( 0.0, 0.0, 0.0 );\n    vec3 reflectedRay7 = vec3( 0.0, 0.0, 0.0 );\n    vec3 refractedRay8 = vec3( 0.0, 0.0,", "\n  return (1.0 - b) * x + b;\n}\n<|file_separator|>// bias x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n  return (1.0 - b) * x + b;\n}\n<|file_separator|>", "\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))", "\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range -1..1\nfloat rand_range(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453)-0.5;\n}\n\n// creates white noise in the range -1..1 including 0\nfloat rand_range_inclusive(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453)-0.5;\n}\n\n// creates white noise in the range -1..1 excluding 1\nfloat rand_range_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453)-0.5;\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_range_inclusive_exclusive(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_range_inclusive_inclusive(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 1\nfloat rand_range_exclusive_exclusive(vec2 p){\n    return fract(", "\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n// ~~~~~~~\n<|file_separator|>// ~~~~~~~ signed distance function for sphere\n// input p --> sphere center\n// input r --> sphere radius\n// \n// think of the sphere as a circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p.xz) - r;\n}\n// ~~~~~~~\n<|file_separator|>// ~~~~~~~ signed distance function for cylinder\n// input p --> cylinder center\n// input h --> cylinder height\n// input r --> cylinder radius\n// \n// think of the cylinder as a circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder radius which is flat on the y axis\n// then simply subtract the cylinder radius from that \nfloat sdCylinder(vec3 p, float h, float r)\n{\n\tvec2 q = vec2(length(p.xz) - r, p.y);\n\treturn length(q) - h;\n}\n// ~~~~~~~\n<|file_separator|>// ~~~~~~~ signed distance function for plane\n// input p --> plane center\n// input n --> plane normal\n// \n// think of the plane as a line\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the plane normal which is flat on the y axis\n// then simply subtract the plane normal from that \nfloat sdPlane(vec3 p, vec3 n)\n{\n\treturn dot(p.xz, n);\n}\n// ~~~~~~~\n<|file_separator|>// ~~~~~~~ signed distance function for box\n// input p --> box center\n// input h --> box half size\n// \n// think of the box as a cube\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the box half size which is flat on the y axis\n// then simply subtract the box half size from that \nfloat sdBox(vec3 p, vec3 h)\n{\n\t", "\n    float t = 0.5;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;", "\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n    return b;\n}\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n    return b;\n}\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n    return b;\n}\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n    return b;\n}\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n    return b;\n}\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2)\n{\n    float d = d1 - d2;\n    float b = 1.0 - (d / 100.0);\n", "\n    vec3 q = p;\n    vec3 r = p;\n    vec3 s = p;\n    vec3 t = p;\n    vec3 u = p;\n    vec3 v = p;\n    vec3 w = p;\n    vec3 x = p;\n    vec3 y = p;\n    vec3 z = p;\n    vec3 a = p;\n    vec3 b = p;\n    vec3 c = p;\n    vec3 d = p;\n    vec3 e = p;\n    vec3 f = p;\n    vec3 g = p;\n    vec3 h = p;\n    vec3 i = p;\n    vec3 j = p;\n    vec3 k = p;\n    vec3 l = p;\n    vec3 m = p;\n    vec3 n = p;\n    vec3 o = p;\n    vec3 p = p;\n    vec3 q = p;\n    vec3 r = p;\n    vec3 s = p;\n    vec3 t = p;\n    vec3 u = p;\n    vec3 v = p;\n    vec3 w = p;\n    vec3 x = p;\n    vec3 y = p;\n    vec3 z = p;\n    vec3 a = p;\n    vec3 b = p;\n    vec3 c = p;\n    vec3 d = p;\n    vec3 e = p;\n    vec3 f = p;\n    vec3 g = p;\n    vec3 h = p;\n    vec3 i = p;\n    vec3 j = p;\n    vec3 k = p;\n    vec3 l = p;\n    vec3 m = p;\n    vec3 n = p;\n    vec3 o = p;\n    vec3 p = p;\n    vec3 q = p;\n    vec3 r = p;\n    vec3 s = p;\n    vec3 t = p;\n    vec3 u = p;\n    vec3 v = p;\n    vec3 w = p;\n    vec3 x = p;\n    vec3 y = p;\n    vec3 z = p;\n    vec3 a = p;\n    vec3 b = p;", "\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o2;\n}\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o2;\n}\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o2;\n}\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o2;\n}\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o2;\n}\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if (o1.y < o2.y)\n        return o1;\n    else\n        return o", "\n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n    vec3 p4 = p;\n    vec3 p5 = p;\n    vec3 p6 = p;\n    vec3 p7 = p;\n    vec3 p8 = p;\n    vec3 p9 = p;\n    vec3 p10 = p;\n    vec3 p11 = p;\n    vec3 p12 = p;\n    vec3 p13 = p;\n    vec3 p14 = p;\n    vec3 p15 = p;\n    vec3 p16 = p;\n    vec3 p17 = p;\n    vec3 p18 = p;\n    vec3 p19 = p;\n    vec3 p20 = p;\n    vec3 p21 = p;\n    vec3 p22 = p;\n    vec3 p23 = p;\n    vec3 p24 = p;\n    vec3 p25 = p;\n    vec3 p26 = p;\n    vec3 p27 = p;\n    vec3 p28 = p;\n    vec3 p29 = p;\n    vec3 p30 = p;\n    vec3 p31 = p;\n    vec3 p32 = p;\n    vec3 p33 = p;\n    vec3 p34 = p;\n    vec3 p35 = p;\n    vec3 p36 = p;\n    vec3 p37 = p;\n    vec3 p38 = p;\n    vec3 p39 = p;\n    vec3 p40 = p;\n    vec3 p41 = p;\n    vec3 p42 = p;\n    vec3 p43 = p;\n    vec3 p44 = p;\n    vec3 p45 = p;\n    vec3 p46 = p;\n    vec3 p47 = p;\n    vec3 p48 = p;\n    vec3 p49 = p;\n    vec3 p50 = p;\n    vec3 p51 = p;\n    vec3 p52 = p;\n", "\n\t// ray origin\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\t// ray direction\n\tvec3 rd = vec3(1.0, 0.0, 0.0);\n\t// ray distance\n\tfloat t = 0.0;\n\t// ray hit object ID\n\tint id = 0;\n\t// ray hit distance\n\tfloat hitDistance = 1000000.0;\n\t// ray hit normal\n\tvec3 hitNormal = vec3(0.0, 0.0, 0.0);\n\t// ray hit position\n\tvec3 hitPosition = vec3(0.0, 0.0, 0.0);\n\t// ray hit material\n\tint hitMaterial = 0;\n\t// ray hit color\n\tvec3 hitColor = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture\n\tvec2 hitTexture = vec2(0.0, 0.0);\n\t// ray hit texture color\n\tvec3 hitTextureColor = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture normal\n\tvec3 hitTextureNormal = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture tangent\n\tvec3 hitTextureTangent = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture bitangent\n\tvec3 hitTextureBitangent = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture uv\n\tvec2 hitTextureUV = vec2(0.0, 0.0);\n\t// ray hit texture uv normal\n\tvec3 hitTextureUVNormal = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture uv tangent\n\tvec3 hitTextureUVTangent = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture uv bitangent\n\tvec3 hitTextureUVBitangent = vec3(0.0, 0.0, 0.0);\n\t// ray hit texture uv uv", "\n    // find closest surface\n    float t = 1e9;\n    int id = -1;\n    for (int i = 0; i < spheres.size(); i++)\n    {\n        float t0 = 1e9;\n        if (spheres[i].intersect(ro, rd, t0))\n        {\n            if (t0 < t)\n            {\n                t = t0;\n                id = i;\n            }\n        }\n    }\n    if (id == -1)\n        return vec3(0);\n    // apply color\n    return spheres[id].color;\n}\n<|file_separator|>// ~~~~~~~ main.cpp\n<|fim_prefix|><|fim_suffix|>\n    for (int i = 0; i < spheres.size(); i++)\n    {\n        spheres[i].color = vec3(1);\n    }\n    spheres.push_back(Sphere(vec3(0, 0, -1), 0.5, vec3(1, 0, 0)));\n    spheres.push_back(Sphere(vec3(0, -100.5, -1), 100, vec3(0, 1, 0)));\n    spheres.push_back(Sphere(vec3(1, 0, -1), 0.5, vec3(0, 0, 1)));\n    spheres.push_back(Sphere(vec3(-1, 0, -1), 0.5, vec3(1, 1, 0)));\n    spheres.push_back(Sphere(vec3(0, 1, -1), 0.5, vec3(1, 1, 1)));\n    spheres.push_back(Sphere(vec3(0, -1, -1), 0.5, vec3(1, 0, 1)));\n    spheres.push_back(Sphere(vec3(0, -1, -1), -0.45, vec3(1, 1, 1)));\n    spheres.push_back(Sphere(vec3(0, -1, -1), -0.45, vec3(1, 1, 1)));\n    spheres.push_back(Sphere(vec3(0, -1, -", "\n    // get the direction of the camera\n    vec3 camDir = normalize( targetPos - camPos );\n    \n    // get the right vector of the camera\n    vec3 camRight = normalize( cross( camDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    \n    // get the up vector of the camera\n    vec3 camUp = normalize( cross( camRight, camDir ) );\n    \n    // get the rotation matrix\n    mat3 camRot = mat3( camRight, camUp, camDir );\n    \n    // get the translation matrix\n    mat3 camTrans = mat3( 1.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0,\n                          0.0, 0.0, 1.0 );\n    \n    // get the rotation matrix\n    mat3 camRot = mat3( camRight, camUp, camDir );\n    \n    // get the translation matrix\n    mat3 camTrans = mat3( 1.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0,\n                          0.0, 0.0, 1.0 );\n    \n    // get the rotation matrix\n    mat3 camRot = mat3( camRight, camUp, camDir );\n    \n    // get the translation matrix\n    mat3 camTrans = mat3( 1.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0,\n                          0.0, 0.0, 1.0 );\n    \n    // get the rotation matrix\n    mat3 camRot = mat3( camRight, camUp, camDir );\n    \n    // get the translation matrix\n    mat3 camTrans = mat3( 1.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0,\n                          0.0, 0.0, 1.0 );\n    \n    // get the rotation matrix\n    mat3 camRot = mat3( camRight, camUp, camDir );\n    \n    // get the translation", "\n    vec3 color;\n    if (id < 1000)\n    {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    else if (id < 2000)\n    {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n    else if (id < 3000)\n    {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    else if (id < 4000)\n    {\n        color = vec3(1.0, 1.0, 0.0);\n    }\n    else if (id < 5000)\n    {\n        color = vec3(1.0, 0.0, 1.0);\n    }\n    else if (id < 6000)\n    {\n        color = vec3(0.0, 1.0, 1.0);\n    }\n    else if (id < 7000)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if (id < 8000)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 9000)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 10000)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 11000)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 12000)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 13000)\n    {\n        color = vec3(", "\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n// ~~~~~~~ signed distance function for torus<|file_separator|>// ~~~~~~~ signed distance function for sphere\n// input p --> sphere center\n// input r --> sphere radius\n// \n// this is a simple sphere\n// \nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// ~~~~~~~ signed distance function for sphere<|file_separator|>// ~~~~~~~ signed distance function for plane\n// input p --> plane point\n// input n --> plane normal\n// \n// this is a simple plane\n// \nfloat sdPlane(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n// ~~~~~~~ signed distance function for plane<|file_separator|>// ~~~~~~~ signed distance function for cylinder\n// input p --> cylinder center\n// input h --> cylinder height\n// input r --> cylinder radius\n// \n// this is a simple cylinder\n// \nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 q = vec2(length(p.xz) - r, p.y);\n    return length(q) - h;\n}\n// ~~~~~~~ signed distance function for cylinder<|file_separator|>// ~~~~~~~ signed distance function for cone\n// input p --> cone center\n// input h --> cone height\n// input r --> cone radius\n// \n// this is a simple cone\n// \nfloat sdCone(vec3 p, float h, float r)\n{\n    vec2 q = vec2(length(p.xz) - r, p.y);\n    return length(q) - h;\n}\n// ~~~~~~~ signed distance function for cone<|file_separator|>// ~~~~~~~ signed distance function for box\n// input p --> box center\n// input h --> box half size\n// \n// this is a simple box\n// \nfloat sdBox(vec3 p, vec3 h)\n{\n    vec3 q = abs(p) - h;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n// ~~~~~~~ signed distance function for box<|file_separator|>// ", "\n    return dot(p, ps.normal) + ps.d;\n}\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// sphere extends indefinately in x and z, \n// so just return distance from center (y)\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// cylinder extends indefinately in x and z, \n// so just return distance from center (y)\nfloat sdCylinder(vec3 p)\n{\n    vec2 d = vec2(length(p.xz) - ps.x, p.y);\n    return length(d) - ps.y;\n}\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// cone extends indefinately in x and z, \n// so just return distance from center (y)\nfloat sdCone(vec3 p)\n{\n    vec2 d = vec2(length(p.xz) - ps.x, p.y);\n    return length(d) - ps.y;\n}\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> size x\n//        ps.z --> size z\n// torus extends indefinately in x and z, \n// so just return distance from center (y)\nfloat sdTorus(vec3 p)\n{\n    vec2 d = vec2(length(p.xz) - ps.x, p.y);\n    return length(d) - ps.y;\n}\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n// box extends indefinately in x", "\n    return smoothstep(k, k*k, d1) * smoothstep(k, k*k, d2);\n}\n<|file_separator|>", "\n    vec4 blended = mix( o1, o2, bf);\n    return blended;\n}\n\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 blended = mix( o1, o2, bf);\n    return blended;\n}\n\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 blended = mix( o1, o2, bf);\n    return blended;\n}\n\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 blended = mix( o1, o2, bf);\n    return blended;\n}\n\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 blended = mix( o1, o2, bf);\n    return blended;\n}\n\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4", "\n  float d3;\n  d3=d1-d2;\n  return d3;\n}\n<|file_separator|>// ~~~~~~~ do shape subtract, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n  float d3;\n  d3=d2-d1;\n  return d3;\n}\n<|file_separator|>// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n  float d3;\n  d3=d1-d2;\n  return d3;\n}\n<|file_separator|>// ~~~~~~~ do shape subtract, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n  float d3;\n  d3=d2-d1;\n  return d3;\n}\n<|file_separator|>", "\n    // generate random point light position\n    vec3 lightPos = vec3(\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0)\n    );\n\n    // check if point light is in shadow\n    if (isPointInShadow(lightPos))\n    {\n        // if point light is in shadow, generate new point light position\n        return generateLightPos();\n    }\n\n    // if point light is not in shadow, return point light position\n    return lightPos;\n}\n<|file_separator|>// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    // generate random point light position\n    vec3 lightPos = vec3(\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0)\n    );\n\n    // check if point light is in shadow\n    if (isPointInShadow(lightPos))\n    {\n        // if point light is in shadow, generate new point light position\n        return generateLightPos();\n    }\n\n    // if point light is not in shadow, return point light position\n    return lightPos;\n}\n<|file_separator|>// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    // generate random point light position\n    vec3 lightPos = vec3(\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0),\n        randFloat(-10.0, 10.0)\n    );\n\n    // check if point light is in shadow\n    if (isPointInShadow(lightPos))\n    {\n        // if point light is in shadow, generate new point light position\n        return generateLightPos();\n    }\n\n    // if point light is not in shadow, return point light position\n    return lightPos;\n}\n<|file_separator|>// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLight", "\n    vec3 p1 = vec3(1.0, 1.0, 1.0);\n    vec3 p2 = vec3(1.0, 1.0, 1.0);\n    vec3 p3 = vec3(1.0, 1.0, 1.0);\n    vec3 p4 = vec3(1.0, 1.0, 1.0);\n    vec3 p5 = vec3(1.0, 1.0, 1.0);\n    vec3 p6 = vec3(1.0, 1.0, 1.0);\n    vec3 p7 = vec3(1.0, 1.0, 1.0);\n    vec3 p8 = vec3(1.0, 1.0, 1.0);\n    vec3 p9 = vec3(1.0, 1.0, 1.0);\n    vec3 p10 = vec3(1.0, 1.0, 1.0);\n    vec3 p11 = vec3(1.0, 1.0, 1.0);\n    vec3 p12 = vec3(1.0, 1.0, 1.0);\n    vec3 p13 = vec3(1.0, 1.0, 1.0);\n    vec3 p14 = vec3(1.0, 1.0, 1.0);\n    vec3 p15 = vec3(1.0, 1.0, 1.0);\n    vec3 p16 = vec3(1.0, 1.0, 1.0);\n    vec3 p17 = vec3(1.0, 1.0, 1.0);\n    vec3 p18 = vec3(1.0, 1.0, 1.0);\n    vec3 p19 = vec3(1.0, 1.0, 1.0);\n    vec3 p20 = vec3(1.0, 1.0, 1.0);\n    vec3 p21 = vec3(1.0, 1.0, ", "\n    vec3 color = vec3(0.0);\n    vec3 hitPoint = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    int hitID = -1;\n    float hitDist = 100000000.0;\n    float hitDistSq = 100000000.0;\n    float hitDistSq2 = 100000000.0;\n    float hitDistSq3 = 100000000.0;\n    float hitDistSq4 = 100000000.0;\n    float hitDistSq5 = 100000000.0;\n    float hitDistSq6 = 100000000.0;\n    float hitDistSq7 = 100000000.0;\n    float hitDistSq8 = 100000000.0;\n    float hitDistSq9 = 100000000.0;\n    float hitDistSq10 = 100000000.0;\n    float hitDistSq11 = 100000000.0;\n    float hitDistSq12 = 100000000.0;\n    float hitDistSq13 = 100000000.0;\n    float hitDistSq14 = 100000000.0;\n    float hitDistSq15 = 100000000.0;\n    float hitDistSq16 = 100000000.0;\n    float hitDistSq17 = 100000000.0;\n    float hitDistSq18 = 100000000.0;\n    float hitDistSq19 = 100000000.0;\n    float hitDistSq20 = 100000000.0;\n    float hitDistSq21 = 1000", "\n    // get the vector from the surface to the light\n    vec3 l = normalize(lp - sp);\n    \n    // get the vector from the surface to the camera\n    vec3 c = normalize(sp);\n    \n    // get the vector from the surface to the light\n    vec3 s = normalize(sp);\n    \n    // get the vector from the surface to the camera\n    vec3 r = normalize(c);\n    \n    // get the vector from the surface to the light\n    vec3 v = normalize(l);\n    \n    // get the vector from the surface to the camera\n    vec3 u = normalize(r);\n    \n    // get the vector from the surface to the light\n    vec3 w = normalize(v);\n    \n    // get the vector from the surface to the camera\n    vec3 n = normalize(s);\n    \n    // get the vector from the surface to the light\n    vec3 p = normalize(u);\n    \n    // get the vector from the surface to the camera\n    vec3 q = normalize(w);\n    \n    // get the vector from the surface to the light\n    vec3 o = normalize(p);\n    \n    // get the vector from the surface to the camera\n    vec3 m = normalize(q);\n    \n    // get the vector from the surface to the light\n    vec3 k = normalize(o);\n    \n    // get the vector from the surface to the camera\n    vec3 j = normalize(m);\n    \n    // get the vector from the surface to the light\n    vec3 i = normalize(k);\n    \n    // get the vector from the surface to the camera\n    vec3 h = normalize(j);\n    \n    // get the vector from the surface to the light\n    vec3 g = normalize(i);\n    \n    // get the vector from the surface to the camera\n    vec3 f = normalize(h);\n    \n    // get the vector from the surface to the light\n    vec3 e = normalize(g);\n    \n    // get the vector from the surface to the camera\n    vec3 d = normalize(f);\n    \n    // get the vector from the surface to the light\n    vec3 c<|file_separator|>", "\n    float ao = 0.0;\n    float d = 0.0;\n    float t = 0.0;\n    float r = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39", "\n    vec3 n = oN;\n    vec3 n1 = oN;\n    vec3 n2 = oN;\n    vec3 n3 = oN;\n    vec3 n4 = oN;\n    vec3 n5 = oN;\n    vec3 n6 = oN;\n    vec3 n7 = oN;\n    vec3 n8 = oN;\n    vec3 n9 = oN;\n    vec3 n10 = oN;\n    vec3 n11 = oN;\n    vec3 n12 = oN;\n    vec3 n13 = oN;\n    vec3 n14 = oN;\n    vec3 n15 = oN;\n    vec3 n16 = oN;\n    vec3 n17 = oN;\n    vec3 n18 = oN;\n    vec3 n19 = oN;\n    vec3 n20 = oN;\n    vec3 n21 = oN;\n    vec3 n22 = oN;\n    vec3 n23 = oN;\n    vec3 n24 = oN;\n    vec3 n25 = oN;\n    vec3 n26 = oN;\n    vec3 n27 = oN;\n    vec3 n28 = oN;\n    vec3 n29 = oN;\n    vec3 n30 = oN;\n    vec3 n31 = oN;\n    vec3 n32 = oN;\n    vec3 n33 = oN;\n    vec3 n34 = oN;\n    vec3 n35 = oN;\n    vec3 n36 = oN;\n    vec3 n37 = oN;\n    vec3 n38 = oN;\n    vec3 n39 = oN;\n    vec3 n40 = oN;\n    vec3 n41 = oN;\n    vec3 n42 = oN;\n    vec3 n43 = oN;\n    vec3 n44 = oN;\n    vec3 n45 = oN;\n    vec3 n46 = oN;\n    vec3 n4", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n<|file_separator|>// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0 / 2.2));\n}\n<|file_separator|>// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(1.0 / 2.2));\n}\n<|file_separator|>", "\n    // calculate fog color\n    vec3 fogColor = mix(fc1,fc2,smoothstep(0.0,fs.x,d));\n    // calculate fog density\n    float fogDensity = smoothstep(0.0,fs.x,d);\n    // calculate fog color\n    fogColor = mix(fogColor,c,fogDensity);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix(fogColor,fogColor*(1.0-fogDensity),fs.y);\n    // calculate fog color\n    fogColor = mix", "\n    float attn = 1.0;\n    if (d > 0.0)\n    {\n        attn = cF + lF * d + qF * d * d;\n    }\n    return attn;\n}\n<|file_separator|>// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float attn = 1.0;\n    if (d > 0.0)\n    {\n        attn = cF + lF * d + qF * d * d;\n    }\n    return attn;\n}\n<|file_separator|>// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float attn = 1.0;\n    if (d > 0.0)\n    {\n        attn = cF + lF * d + qF * d * d;\n    }\n    return attn;\n}\n<|file_separator|>", "\n    vec3 rayDir = vec3(0.0);\n    rayDir.x = cMatrix[0][0] * fCoord.x + cMatrix[0][1] * fCoord.y + cMatrix[0][2];\n    rayDir.y = cMatrix[1][0] * fCoord.x + cMatrix[1][1] * fCoord.y + cMatrix[1][2];\n    rayDir.z = cMatrix[2][0] * fCoord.x + cMatrix[2][1] * fCoord.y + cMatrix[2][2];\n    return rayDir;\n}<|file_separator|>// ~~~~~~~ generate camera ray direction, different for each frag/main.cpp\n<|fim_prefix|><|fim_suffix|>\n    for (int i = 0; i < 1000; i++)\n    {\n        // generate random number\n        float r1 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float r2 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float x = sqrt(1.0 - r1 * r1) * cos(2.0 * PI * r2);\n        float y = sqrt(1.0 - r1 * r1) * sin(2.0 * PI * r2);\n        float z = r1;\n        // generate random number\n        float r11 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float r22 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float x1 = sqrt(1.0 - r11 * r11) * cos(2.0 * PI * r22);\n        float y1 = sqrt(1.0 - r11 * r11) * sin(2.0 * PI * r22);\n        float z1 = r11;\n        // generate random number\n        float r111 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float r222 = 2.0 * rand() / (float)RAND_MAX - 1.0;\n        float x2", "\n    vec2 c = fCoord;\n    vec3 cCol = vec3(0.0);\n    vec3 cCol2 = vec3(0.0);\n    vec3 cCol3 = vec3(0.0);\n    vec3 cCol4 = vec3(0.0);\n    vec3 cCol5 = vec3(0.0);\n    vec3 cCol6 = vec3(0.0);\n    vec3 cCol7 = vec3(0.0);\n    vec3 cCol8 = vec3(0.0);\n    vec3 cCol9 = vec3(0.0);\n    vec3 cCol10 = vec3(0.0);\n    vec3 cCol11 = vec3(0.0);\n    vec3 cCol12 = vec3(0.0);\n    vec3 cCol13 = vec3(0.0);\n    vec3 cCol14 = vec3(0.0);\n    vec3 cCol15 = vec3(0.0);\n    vec3 cCol16 = vec3(0.0);\n    vec3 cCol17 = vec3(0.0);\n    vec3 cCol18 = vec3(0.0);\n    vec3 cCol19 = vec3(0.0);\n    vec3 cCol20 = vec3(0.0);\n    vec3 cCol21 = vec3(0.0);\n    vec3 cCol22 = vec3(0.0);\n    vec3 cCol23 = vec3(0.0);\n    vec3 cCol24 = vec3(0.0);\n    vec3 cCol25 = vec3(0.0);\n    vec3 cCol26 = vec3(0.0);\n    vec3 cCol27 = vec3(0.0);\n    vec3 cCol28 = vec3(0.0);\n    vec3 cCol29 = vec3(0.0);\n    vec3 cCol30 = vec3(0.0);\n    vec3 cCol31 = vec3(0.0);\n    vec3 cCol32 = vec3(0.0);\n", "\n    vec2 uv = fragCoord.xy / vec2(1080, 1920);\n    vec2 c = uv - vec2(0.5);\n    vec2 z = vec2(0.0);\n    float i = 0.0;\n    \n    for( i = 0.0; i < 100.0; i++ )\n    {\n        z = vec2(\n            z.x * z.x - z.y * z.y + c.x,\n            2.0 * z.x * z.y + c.y\n        );\n        \n        if( length(z) > 2.0 )\n        {\n            break;\n        }\n    }\n    \n    fragColor = vec4(\n        i / 100.0,\n        i / 100.0,\n        i / 100.0,\n        1.0\n    );\n}\n<|file_separator|>", "\n    vec3 d = abs(p) - radius;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n// sphere distance field\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    vec2 d = vec2(length(p.xz) - r.x, p.y);\n    return length(d) - r.y;\n}\n// cone distance field\nfloat sdCone(vec3 p, vec2 r)\n{\n    vec2 d = vec2(length(p.xz) - r.x, p.y);\n    return length(d) - r.y;\n}\n// torus distance field\nfloat sdTorus(vec3 p, vec2 r)\n{\n    vec2 q = vec2(length(p.xz) - r.x, p.y);\n    return length(q) - r.y;\n}\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n// sphere-plane distance field\nfloat sdSpherePlane(vec3 p, vec3 n, float r)\n{\n    return length(p - n * r);\n}\n// sphere-cylinder distance field\nfloat sdSphereCylinder(vec3 p, vec2 r)\n{\n    vec2 q = vec2(length(p.xz) - r.x, p.y);\n    return length(q) - r.y;\n}\n// sphere-cone distance field\nfloat sdSphereCone(vec3 p, vec2 r)\n{\n    vec2 q = vec2(length(p.xz) - r.x, p.y);\n    return length(q) - r.y;\n}\n// sphere-torus distance field\nfloat sdSphereTorus(vec3 p, vec2 r)\n{\n    vec2 q = vec2(length(p.xz) - r.x, p.y);\n    return length(q) - r.y;", "\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    vec2 q = p - vec2(0.0, 0.0);\n    return length(q) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    ", "\n    vec2 d = vec2(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return c * c * c * c * c;\n}<|file_separator|>", "\n    vec2 coord2 = coord * morphConstant;\n    vec2 coord3 = coord2 * morphConstant;\n    vec2 coord4 = coord3 * morphConstant;\n    vec2 coord5 = coord4 * morphConstant;\n    vec2 coord6 = coord5 * morphConstant;\n    vec2 coord7 = coord6 * morphConstant;\n    vec2 coord8 = coord7 * morphConstant;\n    vec2 coord9 = coord8 * morphConstant;\n    vec2 coord10 = coord9 * morphConstant;\n    vec2 coord11 = coord10 * morphConstant;\n    vec2 coord12 = coord11 * morphConstant;\n    vec2 coord13 = coord12 * morphConstant;\n    vec2 coord14 = coord13 * morphConstant;\n    vec2 coord15 = coord14 * morphConstant;\n    vec2 coord16 = coord15 * morphConstant;\n    vec2 coord17 = coord16 * morphConstant;\n    vec2 coord18 = coord17 * morphConstant;\n    vec2 coord19 = coord18 * morphConstant;\n    vec2 coord20 = coord19 * morphConstant;\n    vec2 coord21 = coord20 * morphConstant;\n    vec2 coord22 = coord21 * morphConstant;\n    vec2 coord23 = coord22 * morphConstant;\n    vec2 coord24 = coord23 * morphConstant;\n    vec2 coord25 = coord24 * morphConstant;\n    vec2 coord26 = coord25 * morphConstant;\n    vec2 coord27 = coord26 * morphConstant;\n    vec2 coord28 = coord27 * morphConstant;\n    vec2 coord29 = coord28 * morphConstant;\n    vec2 coord30 = coord29 * morphConstant;\n    vec2 coord31 = coord30 * morphConstant;\n    vec2 coord32 = coord31 * morphConstant;\n    vec2 coord33 = coord32 * morphConstant;\n    vec2 coord34 = coord33 * morphConstant;\n    vec2 coord35 = coord34 * morphConstant;\n    vec2 coord36 = coord35 * morphConstant;\n    vec2 coord", "\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec2 sample = vec2(uv.x + (i & 1) * 0.5, uv.y + (i & 2) * 0.5) * 0.25;\n        color += texture2D(biomorph, sample) * (1.0 / 4.0);\n    }\n    return color;\n}<|file_separator|>", "\n  return x - floor(x);\n}\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  float x = repeat(millis() / 1000.0);\n  float y = repeat(millis() / 1000.0 + 1.0);\n  float z = repeat(millis() / 1000.0 + 2.0);\n  float a = repeat(millis() / 1000.0 + 3.0);\n  float b = repeat(millis() / 1000.0 + 4.0);\n  float c = repeat(millis() / 1000.0 + 5.0);\n  float d = repeat(millis() / 1000.0 + 6.0);\n  float e = repeat(millis() / 1000.0 + 7.0);\n  float f = repeat(millis() / 1000.0 + 8.0);\n  float g = repeat(millis() / 1000.0 + 9.0);\n  float h = repeat(millis() / 1000.0 + 10.0);\n  float i = repeat(millis() / 1000.0 + 11.0);\n  float j = repeat(millis() / 1000.0 + 12.0);\n  float k = repeat(millis() / 1000.0 + 13.0);\n  float l = repeat(millis() / 1000.0 + 14.0);\n  float m = repeat(millis() / 1000.0 + 15.0);\n  float n = repeat(millis() / 1000.0 + 16.0);\n  float o = repeat(millis() / 1000.0 + 17.0);\n  float p = repeat(millis() / 1000.0 + 18.0);\n  float q = repeat(millis() / ", "\n\tvec2 d = pB - pA;\n\tvec2 n = normalize(d);\n\tvec2 p = pA + n * (thick.x * 0.5);\n\tvec2 q = pA + n * (thick.y * 0.5);\n\tvec2 r = pB - n * (thick.x * 0.5);\n\tvec2 s = pB - n * (thick.y * 0.5);\n\tvec2 t = pA + n * (thick.y * 0.5);\n\tvec2 u = pA + n * (thick.x * 0.5);\n\tvec2 v = pB - n * (thick.y * 0.5);\n\tvec2 w = pB - n * (thick.x * 0.5);\n\tvec2 x = pA + n * (thick.x * 0.5);\n\tvec2 y = pA + n * (thick.y * 0.5);\n\tvec2 z = pB - n * (thick.x * 0.5);\n\tvec2 A = pA + n * (thick.y * 0.5);\n\tvec2 B = pA + n * (thick.x * 0.5);\n\tvec2 C = pB - n * (thick.y * 0.5);\n\tvec2 D = pB - n * (thick.x * 0.5);\n\tvec2 E = pA + n * (thick.y * 0.5);\n\tvec2 F = pA + n * (thick.x * 0.5);\n\tvec2 G = pB - n * (thick.y * 0.5);\n\tvec2 H = pB - n * (thick.x * 0.5);\n\tvec2 I = pA + n * (thick.y * 0.5);\n\tvec2 J = pA + n * (thick.x * 0.5);\n\tvec2 K = pB - n * (thick.y * 0.5);\n\tvec2 L = pB - n * (thick.x * 0.5);\n\tvec2 M = p", "\n    vec2 p = uv;\n    vec2 d = pB - pA;\n    vec2 n = normalize(d);\n    vec2 p1 = pA + n * thick.x;\n    vec2 p2 = pA + n * thick.y;\n    vec2 p3 = pB - n * thick.x;\n    vec2 p4 = pB - n * thick.y;\n    vec2 p5 = pA + n * (thick.x + thick.y);\n    vec2 p6 = pB - n * (thick.x + thick.y);\n    vec2 p7 = pA + n * (thick.x - thick.y);\n    vec2 p8 = pB - n * (thick.x - thick.y);\n    vec2 p9 = pA + n * (thick.x + thick.y) + n * (thick.x - thick.y);\n    vec2 p10 = pB - n * (thick.x + thick.y) + n * (thick.x - thick.y);\n    vec2 p11 = pA + n * (thick.x - thick.y) + n * (thick.x + thick.y);\n    vec2 p12 = pB - n * (thick.x - thick.y) + n * (thick.x + thick.y);\n    vec2 p13 = pA + n * (thick.x - thick.y) - n * (thick.x + thick.y);\n    vec2 p14 = pB - n * (thick.x - thick.y) - n * (thick.x + thick.y);\n    vec2 p15 = pA + n * (thick.x + thick.y) - n * (thick.x - thick.y);\n    vec2 p16 = pB - n * (thick.x + thick.y) - n * (thick.x - thick.y);\n    vec2 p17 = pA + n * (thick.x - thick.y) - n * (thick.x - thick.y);\n    vec2 p18 = pB - n * (thick.x - thick.y) - n * (thick.x", "\n    vec2 p1 = pA + thick;\n    vec2 p2 = pB - thick;\n    vec2 p3 = p1 + thick;\n    vec2 p4 = p2 - thick;\n    vec2 p5 = p1 - thick;\n    vec2 p6 = p2 + thick;\n    vec2 p7 = p3 - thick;\n    vec2 p8 = p4 + thick;\n    vec2 p9 = p5 - thick;\n    vec2 p10 = p6 + thick;\n    vec2 p11 = p7 - thick;\n    vec2 p12 = p8 - thick;\n    vec2 p13 = p9 - thick;\n    vec2 p14 = p10 - thick;\n    vec2 p15 = p11 - thick;\n    vec2 p16 = p12 - thick;\n    vec2 p17 = p13 - thick;\n    vec2 p18 = p14 - thick;\n    vec2 p19 = p15 - thick;\n    vec2 p20 = p16 - thick;\n    vec2 p21 = p17 - thick;\n    vec2 p22 = p18 - thick;\n    vec2 p23 = p19 - thick;\n    vec2 p24 = p20 - thick;\n    vec2 p25 = p21 - thick;\n    vec2 p26 = p22 - thick;\n    vec2 p27 = p23 - thick;\n    vec2 p28 = p24 - thick;\n    vec2 p29 = p25 - thick;\n    vec2 p30 = p26 - thick;\n    vec2 p31 = p27 - thick;\n    vec2 p32 = p28 - thick;\n    vec2 p33 = p29 - thick;\n    vec2 p34 = p30 - thick;\n    vec2 p35 = p31 - thick;\n    vec2 p36 = p32 - thick;\n    vec2 p37 = p33 - thick;\n    vec2 p38 = p34 - thick;\n    ", "\n  vec2 d = pB - pA;\n  vec2 n = normalize(d);\n  vec2 p = pA + n * thick.x;\n  vec2 q = pA + n * thick.y;\n  vec2 r = pA + n * thick.z;\n  vec2 s = pA + n * thick.w;\n  vec2 t = pA + n * thick.x * 2.0;\n  vec2 u = pA + n * thick.y * 2.0;\n  vec2 v = pA + n * thick.z * 2.0;\n  vec2 w = pA + n * thick.w * 2.0;\n  vec2 x = pA + n * thick.x * 3.0;\n  vec2 y = pA + n * thick.y * 3.0;\n  vec2 z = pA + n * thick.z * 3.0;\n  vec2 aa = pA + n * thick.x * 4.0;\n  vec2 bb = pA + n * thick.y * 4.0;\n  vec2 cc = pA + n * thick.z * 4.0;\n  vec2 dd = pA + n * thick.w * 4.0;\n  vec2 ee = pA + n * thick.x * 5.0;\n  vec2 ff = pA + n * thick.y * 5.0;\n  vec2 gg = pA + n * thick.z * 5.0;\n  vec2 hh = pA + n * thick.w * 5.0;\n  vec2 ii = pA + n * thick.x * 6.0;\n  vec2 jj = pA + n * thick.y * 6.0;\n  vec2 kk = pA + n * thick.z * 6.0;\n  vec2 ll = pA + n * thick.w * 6.0;\n  vec2 mm = pA + n * thick.x * 7.0;\n  vec2 nn = pA + n * thick.y * 7.0;\n  vec2 oo = pA + n", "\n    vec2 dir = pB - pA;\n    vec2 dirNorm = normalize(dir);\n    vec2 dirNorm2 = dirNorm * dirNorm;\n    vec2 dirNorm2Inv = 1.0 / dirNorm2;\n    vec2 dirNorm2Inv2 = dirNorm2Inv * dirNorm2Inv;\n    vec2 dirNorm2Inv2Inv = 1.0 / dirNorm2Inv2;\n    vec2 dirNorm2Inv2Inv2 = dirNorm2Inv2Inv * dirNorm2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv = 1.0 / dirNorm2Inv2Inv2;\n    vec2 dirNorm2Inv2Inv2Inv2 = dirNorm2Inv2Inv2Inv * dirNorm2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv = 1.0 / dirNorm2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2 = dirNorm2Inv2Inv2Inv2Inv * dirNorm2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv = 1.0 / dirNorm2Inv2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv2 = dirNorm2Inv2Inv2Inv2Inv2Inv * dirNorm2Inv2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv2Inv = 1.0 / dirNorm2Inv2Inv2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv2Inv2 = dirNorm2Inv2Inv2Inv2Inv2Inv2Inv * dirNorm2Inv2Inv2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv2Inv2Inv = 1.0 / dirNorm2Inv2Inv2Inv2Inv2Inv2Inv2Inv;\n    vec2 dirNorm2Inv2Inv2Inv2Inv2Inv2Inv2Inv2 = dirNorm2Inv2Inv2Inv2Inv2Inv2Inv2Inv * dirNorm2Inv2Inv2Inv2Inv2Inv", "\n  float outline = 0.0;\n  float thickness = outlineThick;\n  float roundedness = rounded;\n  float thickness_half = thickness * 0.5;\n  float roundedness_half = roundedness * 0.5;\n  float thickness_rounded = thickness - thickness_half;\n  float roundedness_rounded = roundedness - roundedness_half;\n  vec2 pA_rounded = pA + (pA - pB) * roundedness_rounded;\n  vec2 pB_rounded = pB + (pA - pB) * roundedness_rounded;\n  vec2 pA_rounded_half = pA + (pA - pB) * roundedness_half;\n  vec2 pB_rounded_half = pB + (pA - pB) * roundedness_half;\n  vec2 pA_rounded_half_thick = pA + (pA - pB) * thickness_half;\n  vec2 pB_rounded_half_thick = pB + (pA - pB) * thickness_half;\n  vec2 pA_rounded_thick = pA + (pA - pB) * thickness_rounded;\n  vec2 pB_rounded_thick = pB + (pA - pB) * thickness_rounded;\n  vec2 pA_rounded_thick_half = pA + (pA - pB) * thickness_half;\n  vec2 pB_rounded_thick_half = pB + (pA - pB) * thickness_half;\n  vec2 pA_rounded_thick_half_thick = pA + (pA - pB) * thickness_rounded;\n  vec2 pB_rounded_thick_half_thick = pB + (pA - pB) * thickness_rounded;\n  vec2 pA_rounded_thick_half_thick_rounded = pA + (pA - pB) * thickness_half;\n  vec2 pB_rounded_thick_half_thick_rounded = pB + (pA - pB) * thickness_half;\n  vec2 pA_rounded_thick_half_thick_rounded_half = pA + (pA - pB) * thickness_rounded;\n  vec2 pB_rounded_thick_half_thick_rounded", "\n    vec2 uv2 = uv;\n    uv2.x = uv2.x * 2.0 - 1.0;\n    uv2.y = uv2.y * 2.0 - 1.0;\n    vec2 p2 = p;\n    p2.x = p2.x * 2.0 - 1.0;\n    p2.y = p2.y * 2.0 - 1.0;\n    vec2 d = p2 - uv2;\n    float dist = length(d);\n    if (dist < 0.001) {\n        col = vec3(1.0);\n    }\n}\n<|file_separator|>", "\n    // ray-disk intersection\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = (-b - h) / (2.0*a);\n    float t2 = (-b + h) / (2.0*a);\n    if (t1 > t2) swap(t1, t2);\n    if (t2 < 0.0) return -1.0;\n    return t1 > 0.0? t1 : t2;\n}\n<|file_separator|>// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd,               // ray: origin, direction\n               in vec3 cen, float rad )              // sphere: center, radius\n{\n    // ray-sphere intersection\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = (-b - h) / (2.0*a);\n    float t2 = (-b + h) / (2.0*a);\n    if (t1 > t2) swap(t1, t2);\n    if (t2 < 0.0) return -1.0;\n    return t1 > 0.0? t1 : t2;\n}\n<|file_separator|>// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 nor, float dist )             // plane: normal, distance\n{\n    // ray-plane intersection\n    float t = dot(nor, ro - dist*nor) / dot", "\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return vec2( -1.0 );\n    float t0 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t1 = (-b + sqrt(discriminant)) / (2.0*a);\n    if (t0 > t1) swap(t0, t1);\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return vec2( -1.0 );\n    return vec2( t0, t1 );\n}\n\n// ray-box intersection\nbool rayBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return false;\n    float t0 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t1 = (-b + sqrt(discriminant)) / (2.0*a);\n    if (t0 > t1) swap(t0, t1);\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return false;\n    return true;\n}<|file_separator|>// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc", "\n    vec3 a = pa;\n    vec3 b = pb;\n    vec3 c = a + b;\n    vec3 d = a - b;\n    vec3 e = a - c;\n    vec3 f = b - c;\n    vec3 g = a - d;\n    vec3 h = b - d;\n    vec3 i = a - e;\n    vec3 j = b - e;\n    vec3 k = a - f;\n    vec3 l = b - f;\n    vec3 m = a - g;\n    vec3 n = b - g;\n    vec3 o = a - h;\n    vec3 p = b - h;\n    vec3 q = a - i;\n    vec3 r = b - i;\n    vec3 s = a - j;\n    vec3 t = b - j;\n    vec3 u = a - k;\n    vec3 v = b - k;\n    vec3 w = a - l;\n    vec3 x = b - l;\n    vec3 y = a - m;\n    vec3 z = b - m;\n    vec3 aa = a - n;\n    vec3 bb = b - n;\n    vec3 cc = a - o;\n    vec3 dd = b - o;\n    vec3 ee = a - p;\n    vec3 ff = b - p;\n    vec3 gg = a - q;\n    vec3 hh = b - q;\n    vec3 ii = a - r;\n    vec3 jj = b - r;\n    vec3 kk = a - s;\n    vec3 ll = b - s;\n    vec3 mm = a - t;\n    vec3 nn = b - t;\n    vec3 oo = a - u;\n    vec3 pp = b - u;\n    vec3 qq = a - v;\n    vec3 rr = b - v;\n    vec3 ss = a - w;\n    vec3 tt = b - w;\n    vec3 uu = a - x;\n    vec3 vv = b - x;\n    vec3 ww = a - y;\n    vec3 xx = b - y;\n    vec3 yy = a - aa;\n    vec3 zz =", "\n    vec3 v = pb - pa;\n    vec3 w = ro - pa;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, w);\n    float c = dot(w, w) - ra * ra;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return vec4(0.0);\n    float t0 = (-b - sqrt(d)) / (2.0 * a);\n    float t1 = (-b + sqrt(d)) / (2.0 * a);\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return vec4(0.0);\n    vec3 p = ro + t0 * rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t0, n);\n}\n<|file_separator|>// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 p, in float r )\n{\n    vec3 v = p - ro;\n    float b = dot(v, rd);\n    float c = dot(v, v) - r * r;\n    float d = b * b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t0 = -b - sqrt(d);\n    float t1 = -b + sqrt(d);\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) t0 = t1;\n    if (t0 < 0.0) return vec4(0.0);\n    vec3 n = normalize(ro + t0 * rd - p);\n    return vec4(t0, n);\n}\n<|file_separator|>// ray-plane intersection (returns t and normal)\nvec4 iPlane(", "\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return vec2(-1.0, -1.0);\n    float t0 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t1 = (-b + sqrt(discriminant)) / (2.0*a);\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) t0 = t1;\n    if (t1 < 0.0) return vec2(-1.0, -1.0);\n    return vec2(t0, t1);\n}\n<|file_separator|>// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return vec2(-1.0, -1.0);\n    float t0 = (-b - sqrt(discriminant)) / (2.0*a);\n    float t1 = (-b + sqrt(discriminant)) / (2.0*a);\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) t0 = t1;\n    if (t1 < 0.0) return vec2(-1.0, -1.0);\n    return vec2(t0, t1);\n}\n<|file_separator|>// ray-plane intersection\nvec", "\n    // http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    // http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    // http://www.iquilezles.org/www/articles/distfunctions2/distfunctions2.htm\n    // http://www.iquilezles.org/www/articles/distfunctions3/distfunctions3.htm\n    // http://www.iquilezles.org/www/articles/distfunctions4/distfunctions4.htm\n    // http://www.iquilezles.org/www/articles/distfunctions5/distfunctions5.htm\n    // http://www.iquilezles.org/www/articles/distfunctions6/distfunctions6.htm\n    // http://www.iquilezles.org/www/articles/distfunctions7/distfunctions7.htm\n    // http://www.iquilezles.org/www/articles/distfunctions8/distfunctions8.htm\n    // http://www.iquilezles.org/www/articles/distfunctions9/distfunctions9.htm\n    // http://www.iquilezles.org/www/articles/distfunctions10/distfunctions10.htm\n    // http://www.iquilezles.org/www/articles/distfunctions11/distfunctions11.htm\n    // http://www.iquilezles.org/www/articles/distfunctions12/distfunctions12.htm\n    // http://www.iquilezles.org/www/articles/distfunctions13/distfunctions13.htm\n    // http://www.iquilezles.org/www/articles/distfunctions14/distfunctions14.htm\n    // http://www.iquilezles.org/www/articles/distfunctions15/distfunctions15.htm\n    // http://www.iquilezles.org/www/articles/distfunctions16/distfunctions16.htm\n    // http://www.iquilezles.org/www/articles/distfunctions17/distfunctions", "\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    float d = dot( ab, ap );\n    if ( d <= r )\n    {\n        return normalize( cross( ab, ap ) );\n    }\n    return normalize( cross( ap, ab ) );\n}\n<|file_separator|>", "\n    vec3 inv = 1.0 / rd;\n    vec3 t1 = ( ro - rad ) * inv;\n    vec3 t2 = ( rad + rad ) * inv;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    return vec2( max( tmin.x, max( tmin.y, tmin.z ) ), min( tmax.x, min( tmax.y, tmax.z ) ) );\n}<|file_separator|>// ray-box intersection in world space\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 inv = 1.0 / rd;\n    vec3 t1 = ( ro - rad ) * inv;\n    vec3 t2 = ( rad + rad ) * inv;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    return max( tmin, min( tmax, tmax - tmin ) );\n}<|file_separator|>// ray-box intersection in world space\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 inv = 1.0 / rd;\n    vec3 t1 = ( ro - rad ) * inv;\n    vec3 t2 = ( rad + rad ) * inv;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    return max( tmin, min( tmax, tmax - tmin ) );\n}<|file_separator|>", "\n    vec4 ret = vec4( 0.0, 0.0, 0.0, 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = 1000000.0;\n        for( int j = 0; j < 3; j++ )\n        {\n            if( j == 0 )\n            {\n                t = min( t, ( -ro.y - 1.0 ) / rd.y );\n            }\n            if( j == 1 )\n            {\n                t = min( t, ( -ro.x - 1.0 ) / rd.x );\n            }\n            if( j == 2 )\n            {\n                t = min( t, ( -ro.z - 1.0 ) / rd.z );\n            }\n        }\n        if( t < 1000000.0 )\n        {\n            ret = vec4( t, 0.0, 0.0, 0.0 );\n            break;\n        }\n    }\n    return ret;\n}\n\nvec3 normal( in vec3 ro, in vec3 rd )\n{\n    vec3 ret = vec3( 0.0, 0.0, 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = 1000000.0;\n        for( int j = 0; j < 3; j++ )\n        {\n            if( j == 0 )\n            {\n                t = min( t, ( -ro.y - 1.0 ) / rd.y );\n            }\n            if( j == 1 )\n            {\n                t = min( t, ( -ro.x - 1.0 ) / rd.x );\n            }\n            if( j == 2 )\n            {\n                t = min( t, ( -ro.z - 1.0 ) / rd.z );\n            }\n        }\n        if( t < 1000000.0 )\n        {\n            ret", "\n    float phi = 2.0 * M_PI * i / n;\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return vec3(cos_phi, sin_phi, 0.0);\n}\n\nvec3 backwardSF( vec3 v, float n) \n{\n    float phi = atan(v.y, v.x);\n    float i = phi / (2.0 * M_PI) * n;\n    return vec3(i, 0.0, 0.0);\n}\n\nvec3 forwardSF( float i, float n, float phi) \n{\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return vec3(cos_phi, sin_phi, 0.0);\n}\n\nvec3 backwardSF( vec3 v, float n, float phi) \n{\n    float i = atan(v.y, v.x) / (2.0 * M_PI) * n;\n    return vec3(i, 0.0, 0.0);\n}\n\nvec3 forwardSF( float i, float n, float phi, float theta) \n{\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    return vec3(cos_phi * cos_theta, cos_phi * sin_theta, sin_phi);\n}\n\nvec3 backwardSF( vec3 v, float n, float phi, float theta) \n{\n    float i = atan(v.y, v.x) / (2.0 * M_PI) * n;\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    return vec3(cos_phi * cos_theta, cos_phi * sin_theta, sin_phi);\n}\n\nvec3 forwardSF( float i, float n, float phi, float theta, float psi) \n{\n    float cos_phi = cos(phi);\n    float", "\n    resS = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n    \n    vec3 r = ro;\n    vec3 d = rd;\n    \n    float t = 0.0;\n    \n    for ( int i = 0; i < 100; i++ )\n    {\n        float t1 = 1e10;\n        float t2 = 1e10;\n        \n        if ( t1 < t2 )\n        {\n            t = t1;\n        }\n        else\n        {\n            t = t2;\n        }\n        \n        if ( t < 0.001 )\n        {\n            break;\n        }\n        \n        vec3 p = r + t * d;\n        \n        if ( p.x < -10 || p.x > 10 || p.y < -10 || p.y > 10 || p.z < -10 || p.z > 10 )\n        {\n            break;\n        }\n        \n        if ( t < t1 )\n        {\n            t1 = t;\n        }\n        \n        if ( t < t2 )\n        {\n            t2 = t;\n        }\n    }\n    \n    if ( t1 < 1e10 )\n    {\n        return vec4( t1, 1, 0, 0 );\n    }\n    \n    return vec4( 1e10, 0, 0, 0 );\n}\n\nvec3 getNormal( in vec3 p )\n{\n    return normalize( vec3(\n        intersect( p + vec3( 1e-5, 0, 0 ), vec3( 0, 0, 0 ) ).x - intersect( p - vec3( 1e-5, 0, 0 ), vec3( 0, 0, 0 ) ).x,\n        intersect( p + vec3( 0, 1e-5, 0 ), vec3( 0, 0, 0 ) ).x - intersect( p", "\n    vec2 q = p * 1.1;\n    vec2 r = p * 1.1;\n    vec2 s = p * 1.1;\n    vec2 t = p * 1.1;\n    vec2 u = p * 1.1;\n    vec2 v = p * 1.1;\n    vec2 w = p * 1.1;\n    vec2 x = p * 1.1;\n    vec2 y = p * 1.1;\n    vec2 z = p * 1.1;\n    vec2 a = p * 1.1;\n    vec2 b = p * 1.1;\n    vec2 c = p * 1.1;\n    vec2 d = p * 1.1;\n    vec2 e = p * 1.1;\n    vec2 f = p * 1.1;\n    vec2 g = p * 1.1;\n    vec2 h = p * 1.1;\n    vec2 i = p * 1.1;\n    vec2 j = p * 1.1;\n    vec2 k = p * 1.1;\n    vec2 l = p * 1.1;\n    vec2 m = p * 1.1;\n    vec2 n = p * 1.1;\n    vec2 o = p * 1.1;\n    vec2 p = p * 1.1;\n    vec2 q = p * 1.1;\n    vec2 r = p * 1.1;\n    vec2 s = p * 1.1;\n    vec2 t = p * 1.1;\n    vec2 u = p * 1.1;\n    vec2 v = p * 1.1;\n    vec2 w = p * 1.1;\n    vec2 x = p * 1.1;\n    vec2 y = p * 1.1;\n    vec2 z = p * 1.1;\n    vec2 a = p * 1.1;\n    vec2 b = p * 1.1;\n    vec2 c = p * 1.1;\n    vec2 d", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat smoothDist(vec2 p, vec2 size, float radius)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat smoothDist(vec2 p, vec2 size, float radius, float smooth)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius - smooth * smooth * (length(d) - radius);\n}\n\nfloat smoothDist(vec2 p, vec2 size, float radius, float smooth, float smooth2)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius - smooth * smooth * (length(d) - radius) - smooth2 * smooth2 * (length(d) - radius);\n}\n\nfloat smoothDist(vec2 p, vec2 size, float radius, float smooth, float smooth2, float smooth3)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius - smooth * smooth * (length(d) - radius) - smooth2 * smooth2 * (length(d) - radius) - smooth3 * smooth3 * (length(d) - radius);\n}\n\nfloat smoothDist(vec2 p, vec2 size, float radius, float smooth, float smooth2, float smooth3, float smooth4)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius - smooth * smooth * (length(", "\n    vec2 uv1 = uv * orient;\n    vec2 uv2 = uv * orient;\n    vec2 uv3 = uv * orient;\n    vec2 uv4 = uv * orient;\n    vec2 uv5 = uv * orient;\n    vec2 uv6 = uv * orient;\n    vec2 uv7 = uv * orient;\n    vec2 uv8 = uv * orient;\n    vec2 uv9 = uv * orient;\n    vec2 uv10 = uv * orient;\n    vec2 uv11 = uv * orient;\n    vec2 uv12 = uv * orient;\n    vec2 uv13 = uv * orient;\n    vec2 uv14 = uv * orient;\n    vec2 uv15 = uv * orient;\n    vec2 uv16 = uv * orient;\n    vec2 uv17 = uv * orient;\n    vec2 uv18 = uv * orient;\n    vec2 uv19 = uv * orient;\n    vec2 uv20 = uv * orient;\n    vec2 uv21 = uv * orient;\n    vec2 uv22 = uv * orient;\n    vec2 uv23 = uv * orient;\n    vec2 uv24 = uv * orient;\n    vec2 uv25 = uv * orient;\n    vec2 uv26 = uv * orient;\n    vec2 uv27 = uv * orient;\n    vec2 uv28 = uv * orient;\n    vec2 uv29 = uv * orient;\n    vec2 uv30 = uv * orient;\n    vec2 uv31 = uv * orient;\n    vec2 uv32 = uv * orient;\n    vec2 uv33 = uv * orient;\n    vec2 uv34 = uv * orient;\n    vec2 uv35 = uv * orient;\n    vec2 uv36 = uv * orient;\n    vec2 uv37 = uv * orient;\n    vec2 uv38 = uv * orient;\n    vec2 uv39 = uv * orient;\n    vec2 uv40 = uv * orient;\n    vec2 uv41 = uv * orient;\n    vec2 uv42 = uv * orient;\n    vec2 uv43 = uv * orient;\n    vec2 uv", "\n    vec2 uv1 = uv * orient;\n    vec2 uv2 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv3 = uv * orient + vec2(0.0, 1.0);\n    vec2 uv4 = uv * orient + vec2(1.0, 1.0);\n    vec2 uv5 = uv * orient + vec2(0.0, 0.0);\n    vec2 uv6 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv7 = uv * orient + vec2(0.0, 1.0);\n    vec2 uv8 = uv * orient + vec2(1.0, 1.0);\n    vec2 uv9 = uv * orient + vec2(0.0, 0.0);\n    vec2 uv10 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv11 = uv * orient + vec2(0.0, 1.0);\n    vec2 uv12 = uv * orient + vec2(1.0, 1.0);\n    vec2 uv13 = uv * orient + vec2(0.0, 0.0);\n    vec2 uv14 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv15 = uv * orient + vec2(0.0, 1.0);\n    vec2 uv16 = uv * orient + vec2(1.0, 1.0);\n    vec2 uv17 = uv * orient + vec2(0.0, 0.0);\n    vec2 uv18 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv19 = uv * orient + vec2(0.0, 1.0);\n    vec2 uv20 = uv * orient + vec2(1.0, 1.0);\n    vec2 uv21 = uv * orient + vec2(0.0, 0.0);\n    vec2 uv22 = uv * orient + vec2(1.0, 0.0);\n    vec2 uv", "\n    vec2 q = p * ddx;\n    vec2 r = p * ddy;\n    vec2 q1 = floor( q );\n    vec2 q2 = ceil( q );\n    vec2 r1 = floor( r );\n    vec2 r2 = ceil( r );\n    vec2 q1r1 = q1 + r1;\n    vec2 q1r2 = q1 + r2;\n    vec2 q2r1 = q2 + r1;\n    vec2 q2r2 = q2 + r2;\n    vec2 q1r1r1 = q1r1 + r1;\n    vec2 q1r1r2 = q1r1 + r2;\n    vec2 q1r2r1 = q1r2 + r1;\n    vec2 q1r2r2 = q1r2 + r2;\n    vec2 q2r1r1 = q2r1 + r1;\n    vec2 q2r1r2 = q2r1 + r2;\n    vec2 q2r2r1 = q2r2 + r1;\n    vec2 q2r2r2 = q2r2 + r2;\n    vec2 q1r1r1r1 = q1r1r1 + r1;\n    vec2 q1r1r1r2 = q1r1r1 + r2;\n    vec2 q1r1r2r1 = q1r1r2 + r1;\n    vec2 q1r1r2r2 = q1r1r2 + r2;\n    vec2 q1r2r1r1 = q1r2r1 + r1;\n    vec2 q1r2r1r2 = q1r2r1 + r2;\n    vec2 q1r2r2r1 = q1r2r2 + r1;\n    vec2 q1r2r2r2 = q1r2r2 + r2;\n    vec2 q2r1r1r1 = q2r1r1 + r1;\n    vec2 q2r1r1r2 = q2r1r1 + r2;\n    vec2", "\n    vec3 d = vec3( 0.0 );\n    \n    for( int i = 0; i < 3; i++ )\n    {\n        vec3 q = p;\n        q[i] += 0.0001;\n        d[i] = ( map( q ) - map( p ) ) / 0.0001;\n    }\n    \n    return d;\n}\n<|file_separator|>// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0 );\n    \n    for( int i = 0; i < 3; i++ )\n    {\n        vec3 q = p;\n        q[i] += 0.0001;\n        d[i] = ( map( q ) - map( p ) ) / 0.0001;\n    }\n    \n    return d;\n}\n<|file_separator|>// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0 );\n    \n    for( int i = 0; i < 3; i++ )\n    {\n        vec3 q = p;\n        q[i] += 0.0001;\n        d[i] = ( map( q ) - map( p ) ) / 0.0001;\n    }\n    \n    return d;\n}\n<|file_separator|>// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.0 );\n    \n    for( int i = 0; i < 3; i++ )\n    {\n        vec3 q = p;\n        q[i] += 0.0001;\n        d[i] = ( map( q ) - map( p ) ) / 0.0001;\n    }\n    \n    return d;\n}\n<|file_separator|>// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    vec3 d = vec3( 0.", "\n  v33 c = a;\n  a = b;\n  b = c;\n}\n<|file_separator|>", "\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n    return a-b;\n}\n//swap direction(.b)of [a] with origin(.a)of [b", "\n    return a-b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return a-b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return a+b;\n}<|file_separator|>//add b to all ray components\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling", "\n    return (a-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c){\n    return (a-b)/dt+(c-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt+(e-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt+(e-b)/dt+(f-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt+(e-b)/dt+(f-b)/dt+(g-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt+(e-b)/dt+(f-b)/dt+(g-b)/dt+(h-b)/dt;\n}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h,v33 i){\n    return (a-b)/dt+(c-b)/dt+(d-b)/dt+(e-b)/dt+(f-b)/dt+(g-b)/dt+(h-b)/dt+(i-b)/dt;\n}\nvec2", "\n    return vec2(a.x*b.x,a.y*b.y);\n}\nvec3 dt(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nvec4 dt(v33 a,vec3 b){\n    return vec4(a.x*b.x,a.y*b.y,a.z*b.z,1);\n}\nvec3 dt(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nvec2 dt(v33 a,vec2 b){\n    return vec2(a.x*b.x,a.y*b.y);\n}\nvec3 dt(v33 a,vec2 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z);\n}\nvec4 dt(v33 a,vec2 b){\n    return vec4(a.x*b.x,a.y*b.y,1,1);\n}\nvec2 dt(v33 a,vec4 b){\n    return vec2(a.x*b.x,a.y*b.y);\n}\nvec3 dt(v33 a,vec4 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nvec4 dt(v33 a,vec4 b){\n    return vec4(a.x*b.x,a.y*b.y,a.z*b.z,1);\n}\nvec2 dt(v33 a,vec3 b){\n    return vec2(a.x*b.x,a.y*b.y);\n}\nvec3 dt(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nvec4 dt(v33 a,", "\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.y);\n}\nv33 mul(v33 a,vec3 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,vec4 b){\n    return vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,mat3 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){\n    return vec3(a.x*b.x.x,a.y*b.y.x,a.z*b.z.x);\n}\nv33 mul(v33 a,mat4 b){", "\n  vec3 q=vec3(p.x,p.y,p.z);\n  vec3 q2=vec3(p.x,p.y,p.z);\n  vec3 q3=vec3(p.x,p.y,p.z);\n  vec3 q4=vec3(p.x,p.y,p.z);\n  vec3 q5=vec3(p.x,p.y,p.z);\n  vec3 q6=vec3(p.x,p.y,p.z);\n  vec3 q7=vec3(p.x,p.y,p.z);\n  vec3 q8=vec3(p.x,p.y,p.z);\n  vec3 q9=vec3(p.x,p.y,p.z);\n  vec3 q10=vec3(p.x,p.y,p.z);\n  vec3 q11=vec3(p.x,p.y,p.z);\n  vec3 q12=vec3(p.x,p.y,p.z);\n  vec3 q13=vec3(p.x,p.y,p.z);\n  vec3 q14=vec3(p.x,p.y,p.z);\n  vec3 q15=vec3(p.x,p.y,p.z);\n  vec3 q16=vec3(p.x,p.y,p.z);\n  vec3 q17=vec3(p.x,p.y,p.z);\n  vec3 q18=vec3(p.x,p.y,p.z);\n  vec3 q19=vec3(p.x,p.y,p.z);\n  vec3 q20=vec3(p.x,p.y,p.z);\n  vec3 q21=vec3(p.x,p.y,p.z);\n  vec3 q22=vec3(p.x,p.y,p.z);\n  vec3 q23=vec3(p.x,p", "\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(p/w);\n    vec3 r=p-q*w;\n    return (r.x+r.y+r.z)%2;\n}\nfloat tri(vec3 p,vec3 w){\n    vec3 q=floor(", "\n    float t = dot(r,s.xyz);\n    if(t<0.0) return 0.0;\n    float d2 = dot(s.xyz,s.xyz)-t*t;\n    if(d2>s.w) return 0.0;\n    return 1.0;\n}\n<|file_separator|>//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r,s.xyz);\n    if(t<0.0) return 0.0;\n    float d2 = dot(s.xyz,s.xyz)-t*t;\n    if(d2>s.w) return 0.0;\n    return 1.0;\n}\n<|file_separator|>//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r,s.xyz);\n    if(t<0.0) return 0.0;\n    float d2 = dot(s.xyz,s.xyz)-t*t;\n    if(d2>s.w) return 0.0;\n    return 1.0;\n}\n<|file_separator|>//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r,s.xyz);\n    if(t<0.0) return 0.0;\n    float d2 = dot(s.xyz,s.xyz)-t*t;\n    if(d2>s.w) return 0.0;\n    return 1.0;\n}\n<|file_separator|>//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    float t = dot(r,s.xyz);\n    if(t<0.0) return 0.0;\n    float d2 = dot(s.xyz,s.xyz)-t*t;\n    if(d2>s.w) return 0.0;\n    return 1.0;\n}\n<|file_separator|>//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n    ", "\n    vec3 p = u - s.xyz;\n    float d = dot(p,n);\n    float r = s.w;\n    return 1.0 - smoothstep(r-d,r+d,length(p));\n}\n<|file_separator|>//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    vec3 p = u - s.xyz;\n    float d = dot(p,n);\n    float r = s.w;\n    return 1.0 - smoothstep(r-d,r+d,length(p));\n}\n<|file_separator|>//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){\n    vec3 p = u - s.xyz;\n    float d = dot(p,n);\n    float r = s.w;\n    return 1.0 - smoothstep(r-d,r+d,length(p));\n}\n<|file_separator|>", "\n    vec2 d = p1 - p0;\n    vec2 e = p2 - p1;\n    vec2 f = p0 - p2;\n    vec2 g = p1 - p2;\n    vec2 h = p0 - p1;\n    vec2 i = p2 - p0;\n    vec2 j = p1 - p0;\n    vec2 k = p0 - p0;\n    vec2 l = p1 - p1;\n    vec2 m = p2 - p2;\n    vec2 n = p0 - p0;\n    vec2 o = p1 - p1;\n    vec2 p = p2 - p2;\n    vec2 q = p0 - p0;\n    vec2 r = p1 - p1;\n    vec2 s = p2 - p2;\n    vec2 t = p0 - p0;\n    vec2 u = p1 - p1;\n    vec2 v = p2 - p2;\n    vec2 w = p0 - p0;\n    vec2 x = p1 - p1;\n    vec2 y = p2 - p2;\n    vec2 z = p0 - p0;\n    vec2 aa = p1 - p1;\n    vec2 ab = p2 - p2;\n    vec2 ac = p0 - p0;\n    vec2 ad = p1 - p1;\n    vec2 ae = p2 - p2;\n    vec2 af = p0 - p0;\n    vec2 ag = p1 - p1;\n    vec2 ah = p2 - p2;\n    vec2 ai = p0 - p0;\n    vec2 aj = p1 - p1;\n    vec2 ak = p2 - p2;\n    vec2 al = p0 - p0;\n    vec2 am = p1 - p1;\n    vec2 an = p2 - p2;\n    vec2 ao = p0 - p0;\n    vec2 ap = p1 - p1;\n    vec2 aq = p2 - p2;\n    vec2 ar = p0 - p0;\n    vec2 as = p1 - p1;\n    vec2 at = p2", "\n    vec2 d = p1 - p0;\n    vec2 e = p2 - p1;\n    vec2 f = p0 - p2;\n    vec2 g = p1 - p2;\n    vec2 h = p0 - p1;\n    vec2 i = p2 - p0;\n    vec2 j = p1 - p0;\n    vec2 k = p0 - p0;\n    vec2 l = p1 - p1;\n    vec2 m = p2 - p2;\n    vec2 n = p0 - p0;\n    vec2 o = p1 - p1;\n    vec2 p = p2 - p2;\n    vec2 q = p0 - p0;\n    vec2 r = p1 - p1;\n    vec2 s = p2 - p2;\n    vec2 t = p0 - p0;\n    vec2 u = p1 - p1;\n    vec2 v = p2 - p2;\n    vec2 w = p0 - p0;\n    vec2 x = p1 - p1;\n    vec2 y = p2 - p2;\n    vec2 z = p0 - p0;\n    vec2 aa = p1 - p1;\n    vec2 ab = p2 - p2;\n    vec2 ac = p0 - p0;\n    vec2 ad = p1 - p1;\n    vec2 ae = p2 - p2;\n    vec2 af = p0 - p0;\n    vec2 ag = p1 - p1;\n    vec2 ah = p2 - p2;\n    vec2 ai = p0 - p0;\n    vec2 aj = p1 - p1;\n    vec2 ak = p2 - p2;\n    vec2 al = p0 - p0;\n    vec2 am = p1 - p1;\n    vec2 an = p2 - p2;\n    vec2 ao = p0 - p0;\n    vec2 ap = p1 - p1;\n    vec2 aq = p2 - p2;\n    vec2 ar = p0 - p0;\n    vec2 as = p1 - p1;\n    vec2 at = p2", "\n    vec3 a = min( min( p0, p1 ), min( p2, p3 ) );\n    vec3 b = max( max( p0, p1 ), max( p2, p3 ) );\n    return bound3( a, b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4 )\n{\n    vec3 a = min( min( min( p0, p1 ), min( p2, p3 ) ), p4 );\n    vec3 b = max( max( max( p0, p1 ), max( p2, p3 ) ), p4 );\n    return bound3( a, b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5 )\n{\n    vec3 a = min( min( min( min( p0, p1 ), min( p2, p3 ) ), p4 ), p5 );\n    vec3 b = max( max( max( max( p0, p1 ), max( p2, p3 ) ), max( p4, p5 ) ), p5 );\n    return bound3( a, b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6 )\n{\n    vec3 a = min( min( min( min(", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = p3;\n    \n    vec2 t = p;\n    vec2 u = q;\n    vec2 v = r;\n    vec2 w = s;\n    \n    vec2 a = t - u;\n    vec2 b = v - u;\n    vec2 c = w - u;\n    \n    vec2 d = t - 2.0 * u + v;\n    vec2 e = 2.0 * (u - v);\n    vec2 f = t - v;\n    \n    vec2 g = 2.0 * (u - t);\n    vec2 h = u - t;\n    \n    vec2 i = 2.0 * (u - t);\n    vec2 j = u - t;\n    \n    vec2 k = 2.0 * (u - t);\n    vec2 l = u - t;\n    \n    vec2 m = 2.0 * (u - t);\n    vec2 n = u - t;\n    \n    vec2 o = 2.0 * (u - t);\n    vec2 p = u - t;\n    \n    vec2 q = 2.0 * (u - t);\n    vec2 r = u - t;\n    \n    vec2 s = 2.0 * (u - t);\n    vec2 t = u - t;\n    \n    vec2 u = 2.0 * (u - t);\n    vec2 v = u - t;\n    \n    vec2 w = 2.0 * (u - t);\n    vec2 x = u - t;\n    \n    vec2 y = 2.0 * (u - t);\n    vec2 z = u - t;\n    \n    vec2 aa = 2.0 * (u - t);\n    vec2 bb = u - t;\n    \n    vec2 cc = 2.0 * (u - t);\n    vec2 dd = u - t;\n    \n    vec2 ee = 2.0 * (u - t);\n    vec2 ff = u - t;\n", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p2;\n    vec2 d = pos - p1;\n    vec2 e = cross(a, b);\n    vec2 f = cross(c, d);\n    float t = dot(e, f) / dot(e, e);\n    return p1 + t * (p2 - p1);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, in vec2 pos, in float t)\n{\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p2;\n    vec2 d = pos - p1;\n    vec2 e = cross(a, b);\n    vec2 f = cross(c, d);\n    return p1 + t * (p2 - p1);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, in vec2 pos, in float t, in float t2)\n{\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p2;\n    vec2 d = pos - p1;\n    vec2 e = cross(a, b);\n    vec2 f = cross(c, d);\n    return p1 + t * (p2 - p1);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, in vec2 pos, in float t, in float t2, in float t3)\n{\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p2;\n    vec2 d = pos - p1;\n    vec2 e = cross(a, b);\n    vec2 f = cross(c, d);\n    return p1 + t * (p2 - p1);\n}\n\nvec2 udBezier(vec2 p0, vec2", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    float a = dot( e1, p );\n    if ( a > -0.00001 && a < 0.00001 )\n        return vec3( -1, -1, -1 );\n    float f = 1.0 / a;\n    vec3 t = ro - v0;\n    float u = f * dot( t, p );\n    if ( u < 0.0 || u > 1.0 )\n        return vec3( -1, -1, -1 );\n    vec3 q = cross( t, e1 );\n    float v = f * dot( rd, q );\n    if ( v < 0.0 || u + v > 1.0 )\n        return vec3( -1, -1, -1 );\n    float t_ = f * dot( e2, q );\n    if ( t_ < 0.0 )\n        return vec3( -1, -1, -1 );\n    return vec3( t_, u, v );\n}<|file_separator|>// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    float a = dot( e1, p );\n    if ( a > -0.00001 && a < 0.00001 )\n        return vec3( -1, -1, -1 );\n    float f = 1.0 / a;\n    vec3 t = ro - v0;\n    float u = f * dot( t, p );\n    if ( u < 0.0 || u > 1.0 )\n        return vec3( -1, -1, -1 );\n    vec3 q = cross( t, e1 );\n    float v = f * dot( rd,", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 pvec = cross( nor, e2 );\n    float det = dot( e1, pvec );\n    if ( det < 1e-6 )\n        return 0.0;\n    vec3 tvec = pos - v0;\n    float u = dot( tvec, pvec ) / det;\n    if ( u < 0.0 || u > 1.0 )\n        return 0.0;\n    vec3 qvec = cross( tvec, e1 );\n    float v = dot( nor, qvec ) / det;\n    if ( v < 0.0 || u + v > 1.0 )\n        return 0.0;\n    return 1.0;\n}\n<|file_separator|>// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 pvec = cross( nor, e2 );\n    float det = dot( e1, pvec );\n    if ( det < 1e-6 )\n        return 0.0;\n    vec3 tvec = pos - v0;\n    float u = dot( tvec, pvec ) / det;\n    if ( u < 0.0 || u > 1.0 )\n        return 0.0;\n    vec3 qvec = cross( tvec, e1 );\n    float v = dot( nor, qvec ) / det;\n    if ( v < 0.0 || u + v > 1.0 )\n        return 0.0;\n    return 1.0;\n}\n<|file_separator|>", "\n    vec2 AB = B - A;\n    vec2 BC = C - B;\n    vec2 CA = A - C;\n    vec2 AP = pos - A;\n    vec2 BP = pos - B;\n    vec2 CP = pos - C;\n    \n    float a = dot(AB,AB);\n    float b = dot(AB,AP);\n    float c = dot(AB,BP);\n    float d = dot(BC,BC);\n    float e = dot(BC,BP);\n    float f = dot(BC,CP);\n    float g = dot(CA,CA);\n    float h = dot(CA,AP);\n    float i = dot(CA,BP);\n    \n    float t = clamp( (b*e - c*d)/(e*a - d*f), 0.0, 1.0 );\n    float u = clamp( (c*g - f*b)/(d*g - e*f), 0.0, 1.0 );\n    \n    vec2 q = A + AB*t + BC*u;\n    \n    return length(pos - q);\n}\n<|file_separator|>// signed distance to a circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n<|file_separator|>// signed distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h);\n}\n<|file_separator|>// signed distance to a plane\nfloat sdPlane( in vec2 p, in vec2 n, in float d )\n{\n    return length(p - n*d);\n}\n<|file_separator|>// signed distance to a sphere\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n<|file_separator|>// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a", "\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) + r1;\n}\n\n// capped cone\nfloat sdCone( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) + r1;\n}\n\n// specialized for Y alignment\nfloat sdConeY( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) + r1;\n}\n\n// specialized for Y alignment\nfloat sdConeY( in vec2 p, in float r1, float r2, float he, float y )\n{\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) + r1;\n}\n\n// specialized for Y alignment\nfloat sdConeY( in vec2 p, in float r1, float r2, float he, float y, float y2 )\n{\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) + r1;\n}\n\n// specialized for Y alignment\nfloat sdConeY( in vec2 p, in float r1, float r2, float he, float y, float y2, float y3 )\n{\n    vec2 q = abs(p) - vec2(r1, he);\n    return length(max(q, vec2(0.0))) + min(max(q.x,", "\n    vec2 d = abs(p - a) - vec2(ra);\n    float t = clamp(dot(d, d) / dot(b - a, b - a), 0.0, 1.0);\n    return length(d - t * (b - a)) - ra;\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = abs(p - c);\n    return length(d - r) - r;\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r, in float h )\n{\n    vec2 d = abs(p - c);\n    return length(d - r) - r + min(0.0, max(0.0, d.y - h));\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r, in float h, in float t )\n{\n    vec2 d = abs(p - c);\n    return length(d - r) - r + min(0.0, max(0.0, d.y - h)) - t * d.y;\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r, in float h, in float t, in float s )\n{\n    vec2 d = abs(p - c);\n    return length(d - r) - r + min(0.0, max(0.0, d.y - h)) - t * d.y + s * d.y * d.y;\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r, in float h, in float t, in float s, in float a )\n{\n    vec2 d = abs(p - c);\n    return length(d - r) - r + min(0.0, max(0.0, d.y - h)) - t * d.y + s * d.y * d.y - a * d.y * d.y * d.y;\n}\n\nfloat sdCappedCone( in vec2 p, in vec2 c, in float r, in float h, in float t,", "\n    vec3 n = vec3( 0.0 );\n    float h = 0.0001;\n    n.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    n.y = sdf( pos + vec3( 0.0, h, 0.0 ) ) - sdf( pos - vec3( 0.0, h, 0.0 ) );\n    n.z = sdf( pos + vec3( 0.0, 0.0, h ) ) - sdf( pos - vec3( 0.0, 0.0, h ) );\n    return normalize( n );\n}\n\nvec3 calcTangent( in vec3 pos )\n{\n    vec3 t = vec3( 0.0 );\n    float h = 0.0001;\n    t.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    t.y = sdf( pos + vec3( 0.0, h, 0.0 ) ) - sdf( pos - vec3( 0.0, h, 0.0 ) );\n    t.z = sdf( pos + vec3( 0.0, 0.0, h ) ) - sdf( pos - vec3( 0.0, 0.0, h ) );\n    return normalize( t );\n}\n\nvec3 calcBitangent( in vec3 pos )\n{\n    vec3 b = vec3( 0.0 );\n    float h = 0.0001;\n    b.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    b.y = sdf( pos + vec3( 0.0, h, 0.0 ) ) - sdf( pos - vec3( 0.0, h, 0.0 ) );\n    b.z = sdf( pos", "\n    float shadow = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 10; i++ )\n    {\n        float h = calcShadow( ro + t * rd, t );\n        shadow *= h;\n        t += h * k;\n        if( t > tmax )\n            break;\n    }\n    return shadow;\n}\n\nfloat calcShadow( in vec3 ro, in float t )\n{\n    float h = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float h = calcShadow( ro + t * rd, t );\n        h = max( h, 0.0 );\n        h = min( h, 1.0 );\n        h = pow( h, 1.0 / 2.2 );\n        return h;\n    }\n    return 1.0;\n}\n\nfloat calcShadow( in vec3 ro, in float t )\n{\n    vec3 rd = normalize( ro.xz );\n    vec3 ro0 = ro.yz;\n    vec3 ro1 = ro0 + rd * 0.001;\n    vec3 ro2 = ro0 + rd * 0.002;\n    vec3 ro3 = ro0 + rd * 0.003;\n    vec3 ro4 = ro0 + rd * 0.004;\n    vec3 ro5 = ro0 + rd * 0.005;\n    vec3 ro6 = ro0 + rd * 0.006;\n    vec3 ro7 = ro0 + rd * 0.007;\n    vec3 ro8 = ro0 + rd * 0.008;\n    vec3 ro9 = ro0 + rd * 0.009;\n    vec3 ro10 = ro0 + rd * 0.01;\n    vec3 ro11 = ro0 + rd * 0.011;\n    vec3 ro12 = ro0 + rd * 0.012;\n    vec3 ro13 = ro0 + rd * 0.013;\n    vec3", "\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    return fract(sin(dot(q,vec2(12.9898,78.233))) * 4", "\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453 + p);\n}\n\n// basic value noise\nfloat noise( in vec2 x )\n{\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec3 x )\n{\n    return fract(sin(dot(x,vec3(12.9898,78.233,34.3211)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec4 x )\n{\n    return fract(sin(dot(x,vec4(12.9898,78.233,34.3211,98.233)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in float p )\n{\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453 + p);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in float p )\n{\n    return fract(sin(dot(x,vec3(12.9898,78.233,34.3211)))*43758.5453 + p);\n}\n\n// basic value noise\nfloat noise( in vec4 x, in float p )\n{\n    return fract(sin(dot(x,vec4(12.9898,78.233,34.3211,98.233)))*43758.5453 + p);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in float p, in int q )\n{\n    return fract(sin(dot(x,vec2(12.9898,78.", "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 10000.0 );\n    for( int i = 0; i < p; ++i )\n    {\n        f += a * noise( x );\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x )\n{\n    float f = 0.0;\n    float a = 1.0;\n    vec2 shift = vec2( 10000.0 );\n    for( int i = 0; i < 8; ++i )\n    {\n        f += a * noise( x );\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 10000.0 );\n    for( int i = 0; i < p; ++i )\n    {\n        f += a * noise( x );\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x )\n{\n    float f = 0.0;\n    float a = 1.0;\n    vec2 shift = vec2( 10000.0 );\n    for( int i = 0; i < 8; ++i )\n    {\n        f += a * noise( x );\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 10000.0 );", "\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat distance(vec3 p, vec3 q)\n{\n    return length(p - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r)\n{\n    return length(p - q) + length(r - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s)\n{\n    return length(p - q) + length(r - q) + length(s - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t)\n{\n    return length(p - q) + length(r - q) + length(s - q) + length(t - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t, vec3 u)\n{\n    return length(p - q) + length(r - q) + length(s - q) + length(t - q) + length(u - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t, vec3 u, vec3 v)\n{\n    return length(p - q) + length(r - q) + length(s - q) + length(t - q) + length(u - q) + length(v - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t, vec3 u, vec3 v, vec3 w)\n{\n    return length(p - q) + length(r - q) + length(s - q) + length(t - q) + length(u - q) + length(v - q) + length(w - q);\n}\n\nfloat distance(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t, vec3 u, vec3 v, vec3 w, vec3 x)\n{\n    return length(p - q) + length", "\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    vec2 q = abs(p.xz) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ(", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z", "\n    vec2 q = floor( p );\n    vec2 r = fract( p );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p )\n{\n    vec2 q = floor( p );\n    vec2 r = fract( p );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s )\n{\n    vec2 q = floor( p / s );\n    vec2 r = fract( p / s );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s, in float t )\n{\n    vec2 q = floor( p / s );\n    vec2 r = fract( p / s );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s, in float t, in float u )\n{\n    vec2 q = floor( p / s );\n    vec2 r = fract( p / s );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s, in float t, in float u, in float v )\n{\n    vec2 q = floor( p / s );\n    vec2 r = fract( p / s );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s, in float t, in float u, in float v, in float w )\n{\n    vec2 q = floor( p / s );\n    vec2 r = fract( p / s );\n    return step( r.x, 0.5 ) * step( r.y, 0.5 );\n}\n\nfloat checkersGrad( in vec2 p, in float s, in float t, in float u, in float", "\n    return a * ( 1.0 - x ) + x;\n}\n<|file_separator|>", "\n    return ( x - p * floor( x / p ) );\n}\n<|file_separator|>", "\n    return vec3( 1.0 - smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf_smooth( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf_smooth_smooth( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf_smooth_smooth_smooth( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf_smooth_smooth_smooth_smooth( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n}\n\nvec3 dlmf_smooth_smooth_smooth_smooth_smooth( float h )\n{\n    return vec3( smoothstep( 0.0, 0.1, h ),\n                 smoothstep( 0.1, 0.2, h ),\n                 smoothstep( 0.2, 0.3, h ) );\n", "\n    vec3 v = pb - pa;\n    vec3 w = ro - pa;\n    float a = dot(rd, rd);\n    float b = dot(w, rd);\n    float c = dot(w, w) - r*r;\n    float D = b*b - a*c;\n    if (D < 0.0) return 1.0;\n    float t = (-b - sqrt(D)) / a;\n    if (t < 0.0) t = (-b + sqrt(D)) / a;\n    if (t < 0.0) return 1.0;\n    return t;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 p, in float r )\n{\n    vec3 v = p - ro;\n    return length(v) - r;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    return dot(p - ro, n) / dot(rd, n);\n}\n\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in vec3 n )\n{\n    vec3 v0 = pb - pa;\n    vec3 v1 = pc - pa;\n    vec3 v2 = ro - pa;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00*d11 - d01*d01;\n    float v = (d11*d20 - d01*d21) / denom;\n    float w = (d00*d21 - d01*d20) / denom;\n    float t = (d01*d20 - d00*d21) / denom;\n    if (t < 0.0) return 1.0;\n    vec3 p = ro + rd", "\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    float d = length(pa);\n    float e = length(pb);\n    float f = length(cross(pa, pb));\n    float g = length(cross(pa, a));\n    float h = length(cross(pb, b));\n    float i = length(cross(pa, b));\n    float j = length(cross(pb, a));\n    float k = length(cross(pa, a));\n    float l = length(cross(pb, b));\n    float m = length(cross(pa, b));\n    float n = length(cross(pb, a));\n    float o = length(cross(pa, a));\n    float p = length(cross(pb, b));\n    float q = length(cross(pa, b));\n    float r = length(cross(pb, a));\n    float s = length(cross(pa, a));\n    float t = length(cross(pb, b));\n    float u = length(cross(pa, b));\n    float v = length(cross(pb, a));\n    float w = length(cross(pa, a));\n    float x = length(cross(pb, b));\n    float y = length(cross(pa, b));\n    float z = length(cross(pb, a));\n    float A = length(cross(pa, a));\n    float B = length(cross(pb, b));\n    float C = length(cross(pa, b));\n    float D = length(cross(pb, a));\n    float E = length(cross(pa, a));\n    float F = length(cross(pb, b));\n    float G = length(cross(pa, b));\n    float H = length(cross(pb, a));\n    float I = length(cross(pa, a));\n    float J = length(cross(pb, b));\n    float K = length(cross(pa, b));\n    float L = length(cross(pb, a));\n    float M = length(cross(pa, a));\n    float N = length(cross(pb, b));\n    float O = length(cross(pa, b));\n    float P = length", "\n    vec3 n = normalize( b - a );\n    vec3 v = normalize( ro - a );\n    vec3 h = normalize( v + rd );\n    float d = dot( n, h );\n    float t = dot( n, v );\n    float u = dot( n, rd );\n    float v = dot( n, a - ro );\n    float s = dot( n, rd );\n    float t1 = t * t - d * d;\n    float t2 = t * s - u * d;\n    float t3 = s * s - u * u;\n    float t4 = t * v - v * d;\n    float t5 = v * v - v * v;\n    float t6 = v * s - u * v;\n    float t7 = s * s - u * u;\n    float t8 = v * v - v * v;\n    float t9 = v * s - u * v;\n    float t10 = s * s - u * u;\n    float t11 = v * v - v * v;\n    float t12 = v * s - u * v;\n    float t13 = s * s - u * u;\n    float t14 = v * v - v * v;\n    float t15 = v * s - u * v;\n    float t16 = s * s - u * u;\n    float t17 = v * v - v * v;\n    float t18 = v * s - u * v;\n    float t19 = s * s - u * u;\n    float t20 = v * v - v * v;\n    float t21 = v * s - u * v;\n    float t22 = s * s - u * u;\n    float t23 = v * v - v * v;\n    float t24 = v * s - u * v;\n    float t25 = s * s - u * u;\n    float t26 = v * v - v * v;\n    float t27 = v * s - u * v;\n    float t28 = s * s - u * u;\n    float t29 = v", "\n    vec2 p = uv;\n    p.x = (p.x - 0.5) * 2.0;\n    p.y = (p.y - 0.5) * 2.0;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float t = r * th;\n    float s = sin(a);\n    float c = cos(a);\n    float r1 = rad1 * r;\n    float r2 = rad2 * r;\n    float x = r1 * c + r2 * s;\n    float y = r1 * s - r2 * c;\n    return vec2(x, y);\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\n    vec2 p = uv;\n    p.x = (p.x - 0.5) * 2.0;\n    p.y = (p.y - 0.5) * 2.0;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float t = r * th;\n    float s = sin(a);\n    float c = cos(a);\n    float r1 = rad1 * r;\n    float r2 = rad2 * r;\n    float x = r1 * c + r2 * s;\n    float y = r1 * s - r2 * c;\n    return vec2(x, y);\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\n    vec2 p = uv;\n    p.x = (p.x - 0.5) * 2.0;\n    p.y = (p.y - 0.5) * 2.0;", "\n    vec2 d = p - c;\n    return length( d ) - r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 d = vec2( length( p.x, p.y ), length( p.x, -p.y ) );\n    return length( d ) - t.x;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot( p, n );\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdCone( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n", "\n    vec3 n = vec3( 0.0 );\n    float r = 1.0;\n    float d = 1.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    ", "\n    vec2 d = sca - scb;\n    vec2 q = p - sca;\n    float a = acos( dot( q, d ) / length( d ) );\n    float b = acos( dot( q, d ) / length( d ) );\n    return min( a, b ) - ra;\n}\n<|file_separator|>", "\n    float t = mint;\n    float shadow = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = tmax - t;\n        float p = ro.y + d * rd.y;\n        if( p < 0.0 )\n        {\n            break;\n        }\n        float q = ( p * p ) - ro.y * ro.y + tmax * tmax - t * t;\n        if( q < 0.0 )\n        {\n            break;\n        }\n        float h = sqrt( q );\n        float b = d - h;\n        if( b < 0.0 )\n        {\n            break;\n        }\n        t += b;\n        shadow = max( shadow, 1.0 - ( t / tmax ) );\n    }\n    return shadow;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nvec3 calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float shadow )\n{\n    vec3 color = vec3( 0.0 );\n    vec3 shadowColor = vec3( 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = tmax - mint;\n        float p = ro.y + d * rd.y;\n        if( p < 0.0 )\n        {\n            break;\n        }\n        float q = ( p * p ) - ro.y * ro.y + tmax * tmax - t * t;\n        if( q < 0.0 )\n        {\n            break;\n        }\n        float h = sqrt( q );\n        float b = d - h;\n        if( b < 0.0 )\n        {\n            break;\n        }\n        vec3 shadowColor = vec3( 0.0 );\n        if( i == 0 )\n        {\n            shadowColor = vec3( 0.0 );\n        }\n        else\n        {\n            shadowColor = vec3( 1.0 )", "\n    vec3 p = pos;\n    vec3 n = vec3(0.0);\n    float h = 0.0001;\n    n.x = ( sdf( p + vec3( h, 0.0, 0.0 ) ) - sdf( p - vec3( h, 0.0, 0.0 ) ) ) / h;\n    n.y = ( sdf( p + vec3( 0.0, h, 0.0 ) ) - sdf( p - vec3( 0.0, h, 0.0 ) ) ) / h;\n    n.z = ( sdf( p + vec3( 0.0, 0.0, h ) ) - sdf( p - vec3( 0.0, 0.0, h ) ) ) / h;\n    return normalize( n );\n}\n<|file_separator|>", "\n    float t = mint;\n    float shadow = 1.0;\n    float shadow_max = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = tmax - t;\n        float p = ro.y + t * rd.y;\n        float q = ro.z + t * rd.z;\n        float r = sqrt( p * p + q * q );\n        float s = r * time;\n        float m = max( 0.0, 1.0 - s * s );\n        shadow = m * shadow;\n        shadow_max = max( shadow_max, shadow );\n        t += d * shadow;\n    }\n    return shadow_max;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nvec3 calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float t = mint;\n    float shadow = 1.0;\n    float shadow_max = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = tmax - t;\n        float p = ro.y + t * rd.y;\n        float q = ro.z + t * rd.z;\n        float r = sqrt( p * p + q * q );\n        float s = r * time;\n        float m = max( 0.0, 1.0 - s * s );\n        shadow = m * shadow;\n        shadow_max = max( shadow_max, shadow );\n        t += d * shadow;\n    }\n    return vec3( shadow_max );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nvec3 calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time, in vec3 light_pos )\n{\n    float t = mint;\n    float shadow = 1.0;\n    float shadow_max = 0.0;\n    for( int i =", "\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float A = 1.0;\n    float B = 1.0;\n    float C = 1.0;\n    float D = 1.0;\n    float E = 1.0;\n    float F = 1.0;\n    float G = 1.0;\n    float H = 1.0;\n    float I = 1.0;\n    float J = 1.0;\n    float K = 1.0;\n    float L = 1.0;\n    float M = 1.0;\n    float N = 1.0;\n    float O = 1.0;\n    float P = 1.0;\n    float Q = 1.0;\n    float R = 1.0;\n    float S = 1.0;\n    float T = 1.0;\n    float U = 1.0;\n    float V = 1.0;\n    float W = 1.0;\n    float X = 1.0;\n    float Y = 1.0;\n    ", "\n  if( k < 1.0 )\n  {\n    return x;\n  }\n  else\n  {\n    return 1.0 / k;\n  }\n}\n<|file_separator|>// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n  if( k < 1.0 )\n  {\n    return x;\n  }\n  else\n  {\n    return 1.0 / k;\n  }\n}\n<|file_separator|>", "\n    vec3 sky_col = vec3(0.0);\n    vec3 sky_dir = normalize(vec3(0.0, 1.0, 0.0));\n    float sky_dist = length(sky_dir);\n    vec3 sky_sample = sample_pos + sky_dir * sky_dist;\n    vec3 sky_sample_col = texture(sky_map, sky_sample).rgb;\n    float sky_sample_dist = length(sky_sample - sample_pos);\n    float sky_sample_dist_ratio = sky_dist / sky_sample_dist;\n    sky_col = mix(sky_sample_col, background_col, sky_sample_dist_ratio);\n    return sky_col;\n}\n\n/*\nThe main function that renders the scene\n*/\nvoid main() {\n    vec3 background_col = vec3(0.0);\n    vec3 light_dir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 surface_normal = normalize(normal);\n    vec3 sky_col = skylight(surface_pos, surface_normal, light_dir, background_col);\n    vec3 final_col = sky_col + texture(diffuse_map, surface_pos).rgb;\n    gl_FragColor = vec4(final_col, 1.0);\n}<|file_separator|>", "\n    vec3 color = vec3(0.0);\n    float depth = 1.0;\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir = vec3(0.0);\n    vec3 light_color = vec3(1.", "\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (coord.x - resolution.x / 2.0) / resolution.x;\n    camera_vector.y = (coord.y - resolution.y / 2.0) / resolution.y;\n    camera_vector.z = 1.0;\n    return camera_vector;\n}\n\n/*\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (coord.x - resolution.x / 2.0) / resolution.x;\n    camera_vector.y = (coord.y - resolution.y / 2.0) / resolution.y;\n    camera_vector.z = 1.0;\n    return camera_vector;\n}\n\n/*\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (coord.x - resolution.x / 2.0) / resolution.x;\n    camera_vector.y = (coord.y - resolution.y / 2.0) / resolution.y;\n    camera_vector.z = 1.0;\n    return camera_vector;\n}\n\n/*\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (coord.x - resolution.x / 2.0) / resolution.x;\n    camera_vector.y = (coord.y - resolution.y / 2.0) / resolution.y;\n    camera_vector.z = 1.0;\n    return camera_vector;\n}\n\n", "\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float r)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra - r;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float r, float r2)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra - r - r2;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float r, float r2, float r3)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra - r - r2 - r3;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float r, float r2, float r3, float r4)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra - r - r2 - r3 - r4;\n}\n\n// c is the sin of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra, float r, float r2, float r3, float r4, float r5)\n{\n    vec2 q = abs(p.xz) - c;\n    return length(max(q, 0.0)) - ra - r - r2 - r3 - r4 - r5;\n}\n\n// c is the", "\n  vec3 color = vec3(0.0);\n  if (material == 0) {\n    color = vec3(1.0);\n  } else if (material == 1) {\n    color = vec3(0.0, 0.0, 1.0);\n  } else if (material == 2) {\n    color = vec3(1.0, 0.0, 0.0);\n  } else if (material == 3) {\n    color = vec3(0.0, 1.0, 0.0);\n  } else if (material == 4) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 5) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 6) {\n    color = vec3(0.0, 1.0, 1.0);\n  } else if (material == 7) {\n    color = vec3(1.0, 0.0, 1.0);\n  } else if (material == 8) {\n    color = vec3(1.0, 1.0, 0.0);\n  } else if (material == 9) {\n    color = vec3(0.0, 1.0, 1.0);\n  } else if (material == 10) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 11) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 12) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 13) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 14) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else if (material == 15", "\n    switch (material) {\n        case 0:\n            return 0.0;\n        case 1:\n            return 1.0;\n        case 2:\n            return 0.0;\n        case 3:\n            return 0.0;\n        case 4:\n            return 0.0;\n        case 5:\n            return 0.0;\n        case 6:\n            return 0.0;\n        case 7:\n            return 0.0;\n        case 8:\n            return 0.0;\n        case 9:\n            return 0.0;\n        case 10:\n            return 0.0;\n        case 11:\n            return 0.0;\n        case 12:\n            return 0.0;\n        case 13:\n            return 0.0;\n        case 14:\n            return 0.0;\n        case 15:\n            return 0.0;\n        case 16:\n            return 0.0;\n        case 17:\n            return 0.0;\n        case 18:\n            return 0.0;\n        case 19:\n            return 0.0;\n        case 20:\n            return 0.0;\n        case 21:\n            return 0.0;\n        case 22:\n            return 0.0;\n        case 23:\n            return 0.0;\n        case 24:\n            return 0.0;\n        case 25:\n            return 0.0;\n        case 26:\n            return 0.0;\n        case 27:\n            return 0.0;\n        case 28:\n            return 0.0;\n        case 29:\n            return 0.0;\n        case 30:\n            return 0.0;\n        case 31:\n            return 0.0;\n        case 32:\n            return 0.0;\n        case 33:\n            return 0.0;\n        case 3", "\n  switch (material) {\n    case 0:\n      return 1.0;\n    case 1:\n      return 1.5;\n    case 2:\n      return 1.0;\n    case 3:\n      return 1.5;\n    case 4:\n      return 1.0;\n    case 5:\n      return 1.5;\n    case 6:\n      return 1.0;\n    case 7:\n      return 1.5;\n    case 8:\n      return 1.0;\n    case 9:\n      return 1.5;\n    case 10:\n      return 1.0;\n    case 11:\n      return 1.5;\n    case 12:\n      return 1.0;\n    case 13:\n      return 1.5;\n    case 14:\n      return 1.0;\n    case 15:\n      return 1.5;\n    case 16:\n      return 1.0;\n    case 17:\n      return 1.5;\n    case 18:\n      return 1.0;\n    case 19:\n      return 1.5;\n    case 20:\n      return 1.0;\n    case 21:\n      return 1.5;\n    case 22:\n      return 1.0;\n    case 23:\n      return 1.5;\n    case 24:\n      return 1.0;\n    case 25:\n      return 1.5;\n    case 26:\n      return 1.0;\n    case 27:\n      return 1.5;\n    case 28:\n      return 1.0;\n    case 29:\n      return 1.5;\n    case 30:\n      return 1.0;\n    case 31:\n      return 1.5;\n    case 32:\n      return 1.0;\n    case 33:\n      return 1.5;\n    case 3", "\n    return material_properties[material].opacity;\n}<|file_separator|>", "\n  vec3 a = tri_a - line_a;\n  vec3 b = tri_b - line_a;\n  vec3 c = tri_c - line_a;\n  vec3 d = tri_a - tri_b;\n  vec3 e = tri_a - tri_c;\n  vec3 f = tri_b - tri_c;\n  vec3 g = tri_a - line_b;\n  vec3 h = tri_b - line_b;\n  vec3 i = tri_c - line_b;\n  vec3 j = tri_a - line_b;\n  vec3 k = tri_b - line_b;\n  vec3 l = tri_c - line_b;\n  vec3 m = tri_a - line_a;\n  vec3 n = tri_b - line_a;\n  vec3 o = tri_c - line_a;\n  vec3 p = tri_a - line_a;\n  vec3 q = tri_b - line_a;\n  vec3 r = tri_c - line_a;\n  vec3 s = tri_a - line_a;\n  vec3 t = tri_b - line_a;\n  vec3 u = tri_c - line_a;\n  vec3 v = tri_a - line_a;\n  vec3 w = tri_b - line_a;\n  vec3 x = tri_c - line_a;\n  vec3 y = tri_a - line_a;\n  vec3 z = tri_b - line_a;\n  vec3 aa = tri_a - line_a;\n  vec3 ab = tri_b - line_a;\n  vec3 ac = tri_c - line_a;\n  vec3 ad = tri_a - line_a;\n  vec3 ae = tri_b - line_a;\n  vec3 af = tri_c - line_a;\n  vec3 ag = tri_a - line_a;\n  vec3 ah = tri_b - line_a;\n  vec3 ai = tri_c - line_a;\n  vec3 aj = tri_a - line_a;\n  vec3 ak = tri_", "\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_c - tri_b;\n    return cross(a, b);\n}\n\n// Given a point and a triangle, compute the barycentric coordinates of the point\n// in the triangle.\nvec3 get_barycentric_coordinates(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_c - tri_b;\n    vec3 c = point - tri_b;\n    vec3 normal = cross(a, b);\n    float d = dot(normal, c);\n    return vec3(dot(normal, a) / d, dot(normal, b) / d, dot(normal, c) / d);\n}\n\n// Given a point and a triangle, compute the barycentric coordinates of the point\n// in the triangle.\nvec3 get_barycentric_coordinates(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_c - tri_b;\n    vec3 c = point - tri_b;\n    vec3 normal = cross(a, b);\n    float d = dot(normal, c);\n    return vec3(dot(normal, a) / d, dot(normal, b) / d, dot(normal, c) / d);\n}\n\n// Given a point and a triangle, compute the barycentric coordinates of the point\n// in the triangle.\nvec3 get_barycentric_coordinates(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 a = tri_a - tri_b;\n    vec3 b = tri_c - tri_b;\n    vec3 c = point - tri_b;\n    vec3 normal = cross(a, b);\n    float d = dot(normal, c);\n    return vec3(dot(normal, a) / d, dot(normal, b) / d, dot(normal, c) / d);\n}\n\n// Given a point and a triangle, compute the", "\n    vec3 camera_direction = normalize(camera_position - camera_target);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_direction));\n    vec3 camera_up = normalize(cross(camera_direction, camera_right));\n    mat3 camera_rotation = mat3(camera_right, camera_up, camera_direction);\n    return camera_rotation;\n}\n<|file_separator|>", "\n  // TODO: Implement this function.\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  // `ray_triangle_intersection` module to check if a ray intersects\n  // with a triangle.\n  //\n  // You can use the `ray_intersect_triangle` function from the\n  ", "\n    float shadow_ray_length = length(ray_target - ray_origin);\n    float shadow_ray_length_squared = shadow_ray_length * shadow_ray_length;\n    float shadow_ray_length_squared_over_4 = shadow_ray_length_squared / 4.0;\n    float shadow_ray_length_squared_over_2 = shadow_ray_length_squared / 2.0;\n    float shadow_ray_length_squared_over_1 = shadow_ray_length_squared / 1.0;\n    float shadow_ray_length_squared_over_0_5 = shadow_ray_length_squared / 0.5;\n    float shadow_ray_length_squared_over_0_25 = shadow_ray_length_squared / 0.25;\n    float shadow_ray_length_squared_over_0_125 = shadow_ray_length_squared / 0.125;\n    float shadow_ray_length_squared_over_0_0625 = shadow_ray_length_squared / 0.0625;\n    float shadow_ray_length_squared_over_0_03125 = shadow_ray_length_squared / 0.03125;\n    float shadow_ray_length_squared_over_0_015625 = shadow_ray_length_squared / 0.015625;\n    float shadow_ray_length_squared_over_0_0078125 = shadow_ray_length_squared / 0.0078125;\n    float shadow_ray_length_squared_over_0_00390625 = shadow_ray_length_squared / 0.00390625;\n    float shadow_ray_length_squared_over_0_001953125 = shadow_ray_length_squared / 0.001953125;\n    float shadow_ray_length_squared_over_0_0009765625 = shadow_ray_length_squared / 0.0009765", "\n    return 0.5 * ( 1.0 - cos( x * M_PI ) );\n}\n<|file_separator|>// Basic noise\nfloat bnoise( in float x )\n{\n    return 0.5 * ( 1.0 - cos( x * M_PI ) );\n}\n<|file_separator|>", "\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    return (float)rand() / (float)RAND_MAX;\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    ", "\n    return n * 0.618033988749895;\n}<|file_separator|>", "\n    return fract(sin(p)*43758.5453123);\n}\n<|file_separator|>// noise\nfloat noise( in float p )\n{\n    return fract(sin(p)*43758.5453123);\n}\n<|file_separator|>// noise 2d\nfloat noise2d( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453123);\n}\n<|file_separator|>// noise 3d\nfloat noise3d( in vec3 p )\n{\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.67)))*43758.5453123);\n}\n<|file_separator|>", "\n    float y = 0.0;\n    float a = G;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z = 0.0;\n    float z1 = 0.0;\n    float z2 = 0.0;\n    float z3 = 0.0;\n    float z4 = 0.0;\n    float z5 = 0.0;\n    float z6 = 0.0;\n    float z7 = 0.0;\n    float z8 = 0.0;\n    float z9 = 0.0;\n    float z10 = 0.0;\n    float z11 = 0.0;\n    float z12 = 0.0;\n    float z13 = 0.0;\n    float z14 = 0.0;\n    float z15 = 0.0;\n    float z16 = 0.0;\n    float z17 = 0.0;\n    float z18 = 0.0;\n    float z19 = 0.0;\n    float z20 = 0.0;\n    float z21 = 0.0;", "\n    // Quadratic polynomial coefficients\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    \n    // Solve the quadratic equation\n    float discriminant = b * b - 4.0 * a * c;\n    \n    // If the discriminant is negative, there are no real solutions\n    if ( discriminant < 0.0 )\n    {\n        return vec3( 0.0 );\n    }\n    \n    // If the discriminant is zero, there is one real solution\n    else if ( discriminant == 0.0 )\n    {\n        float t = -b / ( 2.0 * a );\n        return vec3( t );\n    }\n    \n    // If the discriminant is positive, there are two real solutions\n    else\n    {\n        float t1 = (-b + sqrt( discriminant )) / ( 2.0 * a );\n        float t2 = (-b - sqrt( discriminant )) / ( 2.0 * a );\n        return vec3( t1, t2 );\n    }\n}\n<|file_separator|>", "\n    vec3 p = pb;\n    vec3 c = vec3( 1.0, 1.0, 1.0 );\n    vec3 d = vec3( 1.0, 1.0, 1.0 );\n    vec3 a = vec3( 1.0, 1.0, 1.0 );\n    vec3 b = vec3( 1.0, 1.0, 1.0 );\n    \n    // a = ( 1 - p.x ) * ( 1 - p.y ) * ( 1 - p.z )\n    // b = ( 1 - p.x ) * ( 1 - p.y ) * p.z\n    // c = ( 1 - p.x ) * p.y * ( 1 - p.z )\n    // d = ( 1 - p.x ) * p.y * p.z\n    \n    // a = ( 1 - p.x ) * ( 1 - p.y ) * ( 1 - p.z )\n    a.x = 1.0 - p.x;\n    a.y = 1.0 - p.y;\n    a.z = 1.0 - p.z;\n    \n    // b = ( 1 - p.x ) * ( 1 - p.y ) * p.z\n    b.x = 1.0 - p.x;\n    b.y = 1.0 - p.y;\n    b.z = p.z;\n    \n    // c = ( 1 - p.x ) * p.y * ( 1 - p.z )\n    c.x = 1.0 - p.x;\n    c.y = p.y;\n    c.z = 1.0 - p.z;\n    \n    // d = ( 1 - p.x ) * p.y * p.z\n    d.x = 1.0 - p.x;\n    d.y = p.y;\n    d.z = p.z;\n    \n    // a = ( 1 - p.x ) * ( 1 - p.y ) * ( 1 - p", "\n    vec3 oc = ro - cen;\n    vec3 q = dot(rd, rd) * (dot(oc, oc) - dot(rad, rad));\n    vec3 t1 = -dot(rd, oc) + sqrt(dot(rd, rd) * (dot(oc, oc) - dot(rad, rad)));\n    vec3 t2 = -dot(rd, oc) - sqrt(dot(rd, rd) * (dot(oc, oc) - dot(rad, rad)));\n    return vec4(min(t1, t2), max(t1, t2));\n}\n\nvec3 boxNormal( in vec3 cen, in vec3 rad ) \n{\n    return normalize(vec3(1.0, 0.0, 0.0));\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n, in vec3 t ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n, in vec3 t, in vec3 b ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n, in vec3 t, in vec3 b, in vec3 s ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n, in vec3 t, in vec3 b, in vec3 s, in vec3 r ) \n{\n    return p - cen;\n}\n\nvec3 boxSample( in vec3 cen, in vec3 rad, in vec3 p, in vec3 n, in vec3 t, in vec3 b, in vec3 s, in vec3 r, in vec3 m ) \n{\n    return p -", "\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return 1.0;\n    float t = (-b - sqrt(discriminant)) / (2.0*a);\n    if (t < 0.0) t = (-b + sqrt(discriminant)) / (2.0*a);\n    return t;\n}\n\nfloat boxShadow2( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return 1.0;\n    float t = (-b - sqrt(discriminant)) / (2.0*a);\n    if (t < 0.0) t = (-b + sqrt(discriminant)) / (2.0*a);\n    return t;\n}\n\nfloat boxShadow3( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) return 1.0;\n    float t = (-b - sqrt(discriminant)) / (2.0*a);\n    if (t < 0.0) t = (-b + sqrt(discriminant)) / (2.0*a);\n    return t;\n}\n\nfloat boxShadow4( in vec3 ro, in vec3 rd,", "\n    float d = tmax;\n    for (int i = 0; i < 100; i++)\n    {\n        float t = d * 0.5;\n        vec3 p = ro + rd * t;\n        float h = 1.0;\n        float s = 1.0;\n        float m = 1.0;\n        float a = 1.0;\n        float b = 1.0;\n        float c = 1.0;\n        float d = 1.0;\n        float e = 1.0;\n        float f = 1.0;\n        float g = 1.0;\n        float h = 1.0;\n        float i = 1.0;\n        float j = 1.0;\n        float k = 1.0;\n        float l = 1.0;\n        float m = 1.0;\n        float n = 1.0;\n        float o = 1.0;\n        float p = 1.0;\n        float q = 1.0;\n        float r = 1.0;\n        float s = 1.0;\n        float t = 1.0;\n        float u = 1.0;\n        float v = 1.0;\n        float w = 1.0;\n        float x = 1.0;\n        float y = 1.0;\n        float z = 1.0;\n        float aa = 1.0;\n        float ab = 1.0;\n        float ac = 1.0;\n        float ad = 1.0;\n        float ae = 1.0;\n        float af = 1.0;\n        float ag = 1.0;\n        float ah = 1.0;\n        float ai = 1.0;\n        float aj = 1.0;\n        float ak = 1.0;\n        float al = 1.0;\n        float am = 1.0;\n        float an = 1.0;\n        float ao = 1.0;\n        float ap = 1.0;\n        float aq = 1.", " seed = (1103515245 * seed + 12345) % 2147483648; return seed * 2.3283064365386963e-10; }\nfloat rand(float x) { return rand() * x; }\nfloat rand(float x, float y) { return rand() * (y - x) + x; }\nfloat rand(float x, float y, float z) { return rand() * (y - x) + x; }\nfloat rand(float x, float y, float z, float w) { return rand() * (w - x) + x; }\nfloat rand(float x, float y, float z, float w, float v) { return rand() * (v - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u) { return rand() * (u - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t) { return rand() * (t - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t, float s) { return rand() * (s - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t, float s, float r) { return rand() * (r - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t, float s, float r, float q) { return rand() * (q - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t, float s, float r, float q, float p) { return rand() * (p - x) + x; }\nfloat rand(float x, float y, float z, float w, float v, float u, float t, float s, float r, float q, float p, float o) { return rand() * (o - x) + x; }\nfloat rand(", "\n    return mix( mix( mix( a, b, t ), mix( b, c, t ), t ), mix( c, d, t ), t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        t += 0.01;\n        col += pal(t, vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }\n    col /= 10.0;\n    fragColor = vec4(col, 1.0);\n}<|file_separator|>", "\n    vec2 q = abs(vec2(length(p.xz), p.y)) - vec2(la, lb);\n    float d = length(q);\n    float s = max(0.0, min(1.0, d / h));\n    float a = acos(clamp(q.x / d, -1.0, 1.0));\n    float b = acos(clamp(q.y / d, -1.0, 1.0));\n    float c = acos(clamp(q.x / d, -1.0, 1.0));\n    float d1 = min(a, b);\n    float d2 = min(b, c);\n    float d3 = min(a, c);\n    float d4 = min(d1, d2);\n    float d5 = min(d2, d3);\n    float d6 = min(d3, d4);\n    float d7 = min(d4, d5);\n    float d8 = min(d5, d6);\n    float d9 = min(d6, d7);\n    float d10 = min(d7, d8);\n    float d11 = min(d8, d9);\n    float d12 = min(d9, d10);\n    float d13 = min(d10, d11);\n    float d14 = min(d11, d12);\n    float d15 = min(d12, d13);\n    float d16 = min(d13, d14);\n    float d17 = min(d14, d15);\n    float d18 = min(d15, d16);\n    float d19 = min(d16, d17);\n    float d20 = min(d17, d18);\n    float d21 = min(d18, d19);\n    float d22 = min(d19, d20);\n    float d23 = min(d20, d21);\n    float d24 = min(d21, d22);\n    float d25 = min", "\n    vec2 d = b - a;\n    vec2 n = normalize( d );\n    vec2 s = a + n * r;\n    vec2 q = p - s;\n    float t = dot( q, n );\n    float d2 = dot( q, q );\n    float d3 = dot( d, d );\n    float d4 = dot( d, d ) * dot( d, d );\n    float d5 = dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d6 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d7 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d8 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d9 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d10 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d11 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d12 = dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d ) * dot( d, d );\n    float d13 = dot(", "\n    vec2 d = abs(p) - b;\n    return vec4(max(d.x, d.y) - r, \n                min(d.x, d.y) + r, \n                max(d.x, d.y), \n                s);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t )\n{\n    vec2 d = abs(p) - b;\n    return vec4(max(d.x, d.y) - r, \n                min(d.x, d.y) + r, \n                max(d.x, d.y), \n                s);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u )\n{\n    vec2 d = abs(p) - b;\n    return vec4(max(d.x, d.y) - r, \n                min(d.x, d.y) + r, \n                max(d.x, d.y), \n                s);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v )\n{\n    vec2 d = abs(p) - b;\n    return vec4(max(d.x, d.y) - r, \n                min(d.x, d.y) + r, \n                max(d.x, d.y), \n                s);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pa", "\n    vec2 q = abs( p / b ) - vec2( 0.5 );\n    return vec3( max( q.x, q.y ), min( max( q.x, q.y ), 1.0 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs( p / b ) - vec3( 0.5 );\n    return vec3( max( max( q.x, q.y ), q.z ), min( max( max( q.x, q.y ), q.z ), 1.0 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs( p / b ) - vec3( 0.5 );\n    return vec3( max( max( q.x, q.y ), q.z ), min( max( max( q.x, q.y ), q.z ), 1.0 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs( p / b ) - vec3( 0.5 );\n    return vec3( max( max( q.x, q.y ), q.z ), min( max( max( q.x, q.y ), q.z ), 1.0 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f", "\n    vec2 d = p - vec2(0.0);\n    float dist = length(d);\n    float dist2 = dist * dist;\n    float dist3 = dist2 * dist;\n    float dist4 = dist3 * dist;\n    float dist5 = dist4 * dist;\n    float dist6 = dist5 * dist;\n    float dist7 = dist6 * dist;\n    float dist8 = dist7 * dist;\n    float dist9 = dist8 * dist;\n    float dist10 = dist9 * dist;\n    float dist11 = dist10 * dist;\n    float dist12 = dist11 * dist;\n    float dist13 = dist12 * dist;\n    float dist14 = dist13 * dist;\n    float dist15 = dist14 * dist;\n    float dist16 = dist15 * dist;\n    float dist17 = dist16 * dist;\n    float dist18 = dist17 * dist;\n    float dist19 = dist18 * dist;\n    float dist20 = dist19 * dist;\n    float dist21 = dist20 * dist;\n    float dist22 = dist21 * dist;\n    float dist23 = dist22 * dist;\n    float dist24 = dist23 * dist;\n    float dist25 = dist24 * dist;\n    float dist26 = dist25 * dist;\n    float dist27 = dist26 * dist;\n    float dist28 = dist27 * dist;\n    float dist29 = dist28 * dist;\n    float dist30 = dist29 * dist;\n    float dist31 = dist30 * dist;\n    float dist32 = dist31 * dist;\n    float dist33 = dist32 * dist;\n    float dist34 = dist33 * dist;\n    float dist35 = dist34 * dist;\n    float dist36 = dist35 * dist;\n    float dist37 = dist36 * dist;\n    float dist38 = dist37 * dist;\n    float dist39 = dist38 * dist;\n    float dist40 = dist39 * dist", "\n    float d = 0.0;\n    for (int i = 0; i < 5; i++) \n    {\n        vec2 v = verts[i];\n        float d1 = length(p - v);\n        if (d1 < r) \n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t ) \n{\n    float d = 0.0;\n    for (int i = 0; i < 5; i++) \n    {\n        vec2 v = verts[i];\n        float d1 = length(p - v);\n        if (d1 < r) \n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s ) \n{\n    float d = 0.0;\n    for (int i = 0; i < 5; i++) \n    {\n        vec2 v = verts[i];\n        float d1 = length(p - v);\n        if (d1 < r) \n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s, in float u ) \n{\n    float d = 0.0;\n    for (int i = 0; i < 5; i++) \n    {\n        vec2 v = verts[i];\n        float d1 = length(p - v);\n        if (d1 < r) \n        {\n            d = d1;\n        }\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s, in float u, in float v ) \n{\n    float d = 0.0;\n    for (int i = 0; i < 5; i++) \n    {\n        vec2 v", "\n    vec2 v0 = verts[0];\n    vec2 v1 = verts[1];\n    vec2 v2 = verts[2];\n    vec2 v3 = verts[3];\n    vec2 v4 = verts[4];\n    \n    vec2 v01 = v1 - v0;\n    vec2 v02 = v2 - v0;\n    vec2 v03 = v3 - v0;\n    vec2 v04 = v4 - v0;\n    \n    vec2 v12 = v2 - v1;\n    vec2 v13 = v3 - v1;\n    vec2 v14 = v4 - v1;\n    \n    vec2 v23 = v3 - v2;\n    vec2 v24 = v4 - v2;\n    \n    vec2 v34 = v4 - v3;\n    \n    vec2 v012 = v12 + v01;\n    vec2 v013 = v13 + v01;\n    vec2 v014 = v14 + v01;\n    vec2 v023 = v23 + v02;\n    vec2 v024 = v24 + v02;\n    vec2 v034 = v34 + v03;\n    \n    vec2 v123 = v12 + v13;\n    vec2 v124 = v12 + v14;\n    vec2 v134 = v13 + v14;\n    vec2 v234 = v23 + v24;\n    \n    vec2 v0123 = v123 + v012;\n    vec2 v0124 = v124 + v012;\n    vec2 v0134 = v134 + v013;\n    vec2 v0234 = v234 + v023;\n    vec2 v034 = v34 + v034;\n    \n    vec2 v1234 = v124 + v134;\n    vec2 v234 = v234", "\n    vec2 d = b - a;\n    vec2 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d, d ), 0.0, 1.0 );\n    return a + t * d;\n}\n\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 d = b - a;\n    vec3 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d, d ), 0.0, 1.0 );\n    return a + t * d;\n}\n\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 d = b - a;\n    vec3 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d, d ), 0.0, 1.0 );\n    return a + t * d;\n}\n\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    vec3 d = b - a;\n    vec3 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d, d ), 0.0, 1.0 );\n    return a + t * d;\n}\n\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e )\n{\n    vec3 d = b - a;\n    vec3 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d, d ), 0.0, 1.0 );\n    return a + t * d;\n}\n\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f )\n{\n    vec3 d = b - a;\n    vec3 q = p - a;\n    float t = clamp( dot( q, d ) / dot( d", "\n    vec2 q = p - vec2( 0.0, r );\n    vec2 q1 = q - vec2( r, 0.0 );\n    vec2 q2 = q - vec2( 0.0, r );\n    vec2 q3 = q - vec2( r, 0.0 );\n    vec2 q4 = q - vec2( 0.0, r );\n    vec2 q5 = q - vec2( r, 0.0 );\n    return normalize( cross( q1, q2 ) + cross( q3, q4 ) + cross( q5, q1 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    vec2 q = p - vec2( 0.0, r );\n    vec2 q1 = q - vec2( r, 0.0 );\n    vec2 q2 = q - vec2( 0.0, r );\n    vec2 q3 = q - vec2( r, 0.0 );\n    vec2 q4 = q - vec2( 0.0, r );\n    vec2 q5 = q - vec2( r, 0.0 );\n    return normalize( cross( q1, q2 ) + cross( q3, q4 ) + cross( q5, q1 ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    vec2 q = p - vec2( 0.0, r );\n    vec2 q1 = q - vec2( r, 0.0 );\n    vec2 q2 = q - vec2( 0.0, r );\n    vec2 q3", "\n  vec3 p1 = X * p;\n  vec3 p2 = X * p + vec3(1, 0, 0);\n  vec3 p3 = X * p + vec3(0, 1, 0);\n  vec3 p4 = X * p + vec3(0, 0, 1);\n  vec3 p5 = X * p + vec3(1, 1, 0);\n  vec3 p6 = X * p + vec3(1, 0, 1);\n  vec3 p7 = X * p + vec3(0, 1, 1);\n  vec3 p8 = X * p + vec3(1, 1, 1);\n  vec3 p9 = X * p + vec3(2, 0, 0);\n  vec3 p10 = X * p + vec3(2, 1, 0);\n  vec3 p11 = X * p + vec3(2, 0, 1);\n  vec3 p12 = X * p + vec3(2, 1, 1);\n  vec3 p13 = X * p + vec3(1, 2, 0);\n  vec3 p14 = X * p + vec3(1, 1, 2);\n  vec3 p15 = X * p + vec3(0, 2, 1);\n  vec3 p16 = X * p + vec3(0, 1, 2);\n  vec3 p17 = X * p + vec3(1, 2, 1);\n  vec3 p18 = X * p + vec3(1, 1, 2);\n  vec3 p19 = X * p + vec3(2, 2, 0);\n  vec3 p20 = X * p + vec3(2, 1, 2);\n  vec3 p21 = X * p + vec3(1, 2, 2);\n  vec3 p22 = X * p + vec3(2, 2, 1);\n  vec3 p23 = X * p + vec3(2, 1, 1);\n  vec", "\n    if (b.x == 0.0) {\n        b.x = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 p2 = vec3(p.x, p.y * cos(a) - p.z * sin(a), p.y * sin(a) + p.z * cos(a));\n    return p2;\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    vec3 p2 = vec3(p.x * cos(a) - p.z * sin(a), p.y, p.x * sin(a) + p.z * cos(a));\n    return p2;\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    vec3 p2 = vec3(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a), p.z);\n    return p2;\n}\n\nvec3 Rotate(vec3 p, float a, float b, float c)\n{\n    vec3 p2 = vec3(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a), p.z);\n    p2 = vec3(p2.x * cos(b) - p2.z * sin(b), p2.y, p2.x * sin(b) + p2.z * cos(b));\n    p2 = vec3(p2.x * cos(c) - p2.y * sin(c), p2.x * sin(c) + p2.y * cos(c), p2.z);\n    return p2;\n}\n\nvec3 Rotate(vec3 p, vec3 a)\n{\n    vec3 p2 = vec3(p.x * cos(a.x) - p.y * sin(a.x), p.x * sin(a.x) + p.y * cos(a.x), p.z);\n    p2 = vec3(p2.x * cos(a.y) - p2.z * sin(a.y), p2.y, p2.x * sin(a.y) + p2.z * cos(a.y));\n    p2 = vec", "\n    return 1.0f - (x / R);\n}<|file_separator|>// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    return 1.0f - (x / R);\n}<|file_separator|>", "\n    float k = 0.0f;\n    float r = 0.0f;\n    float e_ = 0.0f;\n    float e_2 = 0.0f;\n    float e_3 = 0.0f;\n    float e_4 = 0.0f;\n    float e_5 = 0.0f;\n    float e_6 = 0.0f;\n    float e_7 = 0.0f;\n    float e_8 = 0.0f;\n    float e_9 = 0.0f;\n    float e_10 = 0.0f;\n    float e_11 = 0.0f;\n    float e_12 = 0.0f;\n    float e_13 = 0.0f;\n    float e_14 = 0.0f;\n    float e_15 = 0.0f;\n    float e_16 = 0.0f;\n    float e_17 = 0.0f;\n    float e_18 = 0.0f;\n    float e_19 = 0.0f;\n    float e_20 = 0.0f;\n    float e_21 = 0.0f;\n    float e_22 = 0.0f;\n    float e_23 = 0.0f;\n    float e_24 = 0.0f;\n    float e_25 = 0.0f;\n    float e_26 = 0.0f;\n    float e_27 = 0.0f;\n    float e_28 = 0.0f;\n    float e_29 = 0.0f;\n    float e_30 = 0.0f;\n    float e_31 = 0.0f;\n    float e_32 = 0.0f;\n    float e_33 = 0.0f;\n    float e_34 = 0.0f;\n    float e_35 = 0.0f;\n    float e_36 = 0", "\n    return (a - b) / (R * e);\n}\n<|file_separator|>// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    return (a - b) / (R * e);\n}\n<|file_separator|>", "\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n    vec3 d = p - c;\n    float r = length(d);\n    float a = 1.0 - r / R;\n    return a * e;\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e", "\n    vec3 d = b - a;\n    vec3 p = a + d * 0.5;\n    float d2 = dot(d, d);\n    float d3 = d2 * d2;\n    float d4 = d2 * d3;\n    float d5 = d2 * d4;\n    float d6 = d2 * d5;\n    float d7 = d2 * d6;\n    float d8 = d2 * d7;\n    float d9 = d2 * d8;\n    float d10 = d2 * d9;\n    float d11 = d2 * d10;\n    float d12 = d2 * d11;\n    float d13 = d2 * d12;\n    float d14 = d2 * d13;\n    float d15 = d2 * d14;\n    float d16 = d2 * d15;\n    float d17 = d2 * d16;\n    float d18 = d2 * d17;\n    float d19 = d2 * d18;\n    float d20 = d2 * d19;\n    float d21 = d2 * d20;\n    float d22 = d2 * d21;\n    float d23 = d2 * d22;\n    float d24 = d2 * d23;\n    float d25 = d2 * d24;\n    float d26 = d2 * d25;\n    float d27 = d2 * d26;\n    float d28 = d2 * d27;\n    float d29 = d2 * d28;\n    float d30 = d2 * d29;\n    float d31 = d2 * d30;\n    float d32 = d2 * d31;\n    float d33 = d2 * d32;\n    float d34 = d2 * d33;\n    float d35 = d2 * d34;\n    float d36 = d2 * d35;\n    float d37 = d2 * d36;", "\n    return p.y;\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n}\n\n// Tree root\nvec3 Object(vec3 p)\n{\n    return vec3(p.x, 0.0, p.z);\n", "\n    return dot(a, b) / dot(a, a);\n}\n\n// K root\nfloat KRoot(float a, float b, float c)\n{\n    float d = b * b - 4 * a * c;\n    if (d < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return (-b + sqrt(d)) / (2 * a);\n    }\n}\n\n// K root\nfloat KRoot(float a, float b, float c, float d)\n{\n    float e = b * b - 4 * a * c;\n    if (e < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return (-b + sqrt(e)) / (2 * a);\n    }\n}\n\n// K root\nfloat KRoot(float a, float b, float c, float d, float e)\n{\n    float f = b * b - 4 * a * c;\n    if (f < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return (-b + sqrt(f)) / (2 * a);\n    }\n}\n\n// K root\nfloat KRoot(float a, float b, float c, float d, float e, float f)\n{\n    float g = b * b - 4 * a * c;\n    if (g < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return (-b + sqrt(g)) / (2 * a);\n    }\n}\n\n// K root\nfloat KRoot(float a, float b, float c, float d, float e, float f, float g)\n{\n    float h = b * b - 4 * a * c;\n    if (h < 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return (-b + sqrt(h)) / (2 * a);\n    }\n}\n\n// K root\nfloat KRoot(float a, float b, float c, float d, float e, float f, float g, float h)\n{\n    float i = b * b -", "\n    vec3 n = vec3(0.0);\n    \n    // Front\n    if (p.x < 0.0 && p.y < 0.0 && p.z < 0.0)\n    {\n        n = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Back\n    if (p.x > 0.0 && p.y > 0.0 && p.z > 0.0)\n    {\n        n = vec3(-1.0, 0.0, 0.0);\n    }\n    \n    // Left\n    if (p.x < 0.0 && p.y < 0.0 && p.z > 0.0)\n    {\n        n = vec3(0.0, 1.0, 0.0);\n    }\n    \n    // Right\n    if (p.x > 0.0 && p.y > 0.0 && p.z < 0.0)\n    {\n        n = vec3(0.0, -1.0, 0.0);\n    }\n    \n    // Top\n    if (p.x < 0.0 && p.y > 0.0 && p.z < 0.0)\n    {\n        n = vec3(0.0, 0.0, 1.0);\n    }\n    \n    // Bottom\n    if (p.x > 0.0 && p.y < 0.0 && p.z > 0.0)\n    {\n        n = vec3(0.0, 0.0, -1.0);\n    }\n    \n    return n;\n}\n<|file_separator|>// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\n    vec3 n = vec3(0.0);\n    \n    // Front\n    if (p.x < 0.0 && p.y < 0.0 && p.z < 0.0)\n    {\n        n = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Back\n    if (p", "\n    // Sphere\n    vec3 c = vec3(0.0, 0.0, -1.0);\n    float r = 1.0;\n    \n    // Ray-Sphere intersection\n    float b = dot(o, u);\n    float c2 = dot(o, o) - r * r;\n    float d = b * b - c2;\n    if (d < 0.0)\n    {\n        h = false;\n        return 0.0;\n    }\n    float t = -b - sqrt(d);\n    if (t < 0.0)\n    {\n        h = false;\n        return 0.0;\n    }\n    h = true;\n    s = 1;\n    return t;\n}\n<|file_separator|>// Trace ray using ray tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    // Sphere\n    vec3 c = vec3(0.0, 0.0, -1.0);\n    float r = 1.0;\n    \n    // Ray-Sphere intersection\n    float b = dot(o, u);\n    float c2 = dot(o, o) - r * r;\n    float d = b * b - c2;\n    if (d < 0.0)\n    {\n        h = false;\n        return 0.0;\n    }\n    float t = -b - sqrt(d);\n    if (t < 0.0)\n    {\n        h = false;\n        return 0.0;\n    }\n    h = true;\n    s = 1;\n    return t;\n}\n<|file_separator|>// Trace ray using ray tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    // Sphere\n    vec3 c = vec3(0.0, 0.0, -1.0);\n    float r = 1.0;\n    \n    //", "\n    float t = 0.0;\n    for (int i = 0; i < s; i++)\n    {\n        vec3 p = o + t * u;\n        // Check if the ray hits the sphere\n        if (Sphere(p, 1.0))\n        {\n            h = true;\n            s = i;\n            return t;\n        }\n        t += 0.1;\n    }\n    h = false;\n    return t;\n}\n// Trace a ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nvec3 TraceRay(vec3 o, vec3 u, out bool h, out int s)\n{\n    vec3 color = vec3(0.0);\n    vec3 p = o;\n    for (int i = 0; i < s; i++)\n    {\n        vec3 p = o + t * u;\n        // Check if the ray hits the sphere\n        if (Sphere(p, 1.0))\n        {\n            h = true;\n            s = i;\n            return color;\n        }\n        t += 0.1;\n    }\n    h = false;\n    return color;\n}\n// Trace a ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nvec3 TraceRay(vec3 o, vec3 u, out bool h, out int s)\n{\n    vec3 color = vec3(0.0);\n    vec3 p = o;\n    for (int i = 0; i < s; i++)\n    {\n        vec3 p = o + t * u;\n        // Check if the ray hits the sphere\n        if (Sphere(p, 1.0))\n        {\n            h = true;\n            s = i;\n            return color;\n        }\n        t += 0.1;\n    }\n    h = false;\n    return color;\n}\n// Trace a ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nvec3 TraceRay(vec3 o,", "\n    return vec3(0.0);\n}\n\nvec3 Diffuse(vec3 rd, vec3 N)\n{\n    return vec3(0.0);\n}\n\nvec3 Specular(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 Refraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 Glass(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec3 rd, vec3 N, vec3 V, float alpha)\n{\n    return vec3(0.0);\n}\n\nvec3 GlassRefraction(vec", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    ", "\n    vec3 m = abs( ro / rd );\n    vec3 min = min( m, vec3( 1.0 ) );\n    vec3 max = max( m, vec3( 1.0 ) );\n    return vec2( min.x + min.y + min.z, max.x + max.y + max.z );\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v ) \n{\n    return n * dot( l, v ) * 0.5 + 0.5;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in vec3 f ) \n{\n    return brdf( n, l, v ) * f;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in vec3 f, in vec3 k ) \n{\n    return brdf( n, l, v, f ) + k * brdf( -n, l, v ) * 0.5;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in vec3 f, in vec3 k, in vec3 m ) \n{\n    return brdf( n, l, v, f, k ) + m * brdf( -n, l, v ) * 0.5;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in vec3 f, in vec3 k, in vec3 m, in vec3 p ) \n{\n    return brdf( n, l, v, f, k ) + p * brdf( -n, l, v ) * 0.5;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in vec3 f, in vec3 k, in vec3 m, in vec3 p, in vec3 q ) \n{\n    return brdf( n, l, v, f, k, m ) + q * brdf( -n, l, v ) * 0.5;\n}\n\nvec3 brdf( in vec3 n, in vec3 l, in vec3 v, in", "\n    return coord * 0.5 + 0.5;\n}<|file_separator|>", "\n    vec3 a = vec3( p.x, p.y, 0.0 );\n    vec3 b = vec3( q.x, q.y, 0.0 );\n    vec3 c = vec3( 0.0, 0.0, 0.0 );\n    return normalize( cross( b - a, c - a ) );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r )\n{\n    vec3 a = vec3( p.x, p.y, 0.0 );\n    vec3 b = vec3( q.x, q.y, 0.0 );\n    vec3 c = vec3( r.x, r.y, 0.0 );\n    return normalize( cross( b - a, c - a ) );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s )\n{\n    vec3 a = vec3( p.x, p.y, 0.0 );\n    vec3 b = vec3( q.x, q.y, 0.0 );\n    vec3 c = vec3( r.x, r.y, 0.0 );\n    vec3 d = vec3( s.x, s.y, 0.0 );\n    return normalize( cross( b - a, c - a ) );\n}\n\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s, in vec2 t )\n{\n    vec3 a = vec3( p.x, p.y, 0.0 );\n    vec3 b = vec3( q.x, q.y, 0.0 );\n    vec3 c = vec3( r.x, r.y, 0.0 );\n    vec3 d = vec3( s.x, s.y, 0.0 );\n    vec3 e = vec3( t.x, t.y, 0.0 );\n    return normalize( cross( b - a, c - a ) );\n}\n\nvec3 sdgTriangleIsosceles( in vec", "\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t, float t2)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t, float t2, float t3)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t, float t2, float t3, float t4)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t, float t2, float t3, float t4, float t5)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3(t, t * t, t * t * t);\n}\n\nvec3 sdgVesica(vec2 p, float r, float d, float t, float t2, float t3, float t4, float t5, float t6)\n{\n    vec2 q = p - vec2(0.5);\n    float t = length(q) - r;\n    return vec3", "\n    return vec3( sin(p.x)*cos(p.y), sin(p.y), cos(p.x)*cos(p.y) );\n}\n//.x = sin(p.x)\n//.y = sin(p.y)\n//.z = cos(p.x)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPie( in vec2 p )\n{\n    return vec3( sin(p.x), sin(p.y), cos(p.x) );\n}\n//.x = sin(p.x)\n//.y = cos(p.y)\n//.z = sin(p.y)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPie( in vec2 p )\n{\n    return vec3( sin(p.x), cos(p.y), sin(p.y) );\n}\n//.x = sin(p.x)\n//.y = sin(p.y)\n//.z = cos(p.y)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPie( in vec2 p )\n{\n    return vec3( sin(p.x), sin(p.y), cos(p.y) );\n}\n//.x = sin(p.x)\n//.y = cos(p.y)\n//.z = cos(p.y)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPie( in vec2 p )\n{\n    return vec3( sin(p.x), cos(p.y), cos(p.y) );\n}\n//.x = sin(p.x)\n//.y = cos(p.y)\n//.z = sin(p.y)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPie( in vec2 p )\n{\n    return vec3( sin(p.x), cos(p", "\n    vec3 d = vec3( 0.0 );\n    for( int i = 0; i < 3; i++ )\n    {\n        vec2 q = p - v[i];\n        d += q * q;\n    }\n    return d;\n}\n\nvec3 sdgTriangleGrad( in vec2 p, in vec2 v[3] )\n{\n    vec3 d = vec3( 0.0 );\n    for( int i = 0; i < 3; i++ )\n    {\n        vec2 q = p - v[i];\n        d += q * q * 2.0 * ( v[i] - p );\n    }\n    return d;\n}\n\nvec3 sdgTriangleGrad2( in vec2 p, in vec2 v[3] )\n{\n    vec3 d = vec3( 0.0 );\n    for( int i = 0; i < 3; i++ )\n    {\n        vec2 q = p - v[i];\n        d += q * q * 2.0 * ( v[i] - p );\n    }\n    return d;\n}\n\nvec3 sdgTriangleGrad3( in vec2 p, in vec2 v[3] )\n{\n    vec3 d = vec3( 0.0 );\n    for( int i = 0; i < 3; i++ )\n    {\n        vec2 q = p - v[i];\n        d += q * q * 2.0 * ( v[i] - p );\n    }\n    return d;\n}\n\nvec3 sdgTriangleGrad4( in vec2 p, in vec2 v[3] )\n{\n    vec3 d = vec3( 0.0 );\n    for( int i = 0; i < 3; i++ )\n    {\n        vec2 q = p - v[i];\n        d += q * q * 2.0 * ( v[i] - p );\n    }\n    return d;\n}\n\nvec3 sdgTriangleGrad5( in vec2 p, in vec2 v[3] )\n{\n    vec3 d = vec3( 0.0 );\n    ", "\n    vec2 q = p;\n    float a = atan( q.y, q.x );\n    float d = length( q );\n    float s = sin( a );\n    float c = cos( a );\n    float r = d * ( ra * c + rb * s );\n    float t = d * ( rb * c - ra * s );\n    return vec3( r * c, r * s, t );\n}\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rz )\n{\n    vec2 q = p;\n    float a = atan( q.y, q.x );\n    float d = length( q );\n    float s = sin( a );\n    float c = cos( a );\n    float r = d * ( ra * c + rb * s );\n    float t = d * ( rb * c - ra * s );\n    float u = d * ( rz * c + rb * s );\n    return vec3( r * c, r * s, t * c + u * s );\n}\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rz, in float rx )\n{\n    vec2 q = p;\n    float a = atan( q.y, q.x );\n    float d = length( q );\n    float s = sin( a );\n    float c = cos( a );\n    float r = d * ( ra * c + rb * s );\n    float t = d * ( rb * c - ra * s );\n    float u = d", "\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec3 a, in vec3 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec2 a, in vec3 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec2 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec3 a, in vec2 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec3 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec2 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec3 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec3 a, in vec3 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec3 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec3 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec4 a, in vec4 b ) {\n    return a.x * b.y - a.y * b.x;\n}\nfloat cro( in vec2 a, in vec2 b ) {\n    return a.x * b", "\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) );\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t);\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t, in float t2 )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t) * cos(t2);\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t, in float t2, in float t3 )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t) * cos(t2) * cos(t3);\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t, in float t2, in float t3, in float t4 )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t) * cos(t2) * cos(t3) * cos(t4);\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t, in float t2, in float t3, in float t4, in float t5 )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t) * cos(t2) * cos(t3) * cos(t4) * cos(t5);\n}\n\nvec3 sdgEllipse( vec2 p, in vec2 ab, in float t, in float t2, in float t3, in float t4, in float t5, in float t6 )\n{\n    vec2 q = p - ab;\n    return vec3( q.x, q.y, length(q) ) * cos(t)", "\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( q.x, q.y, length( p.xz ) - ra, length( p.yz ) - rb );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( length( p ), p.y, length( p ), length( p ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgPlane( vec3 p, vec3 n )\n{\n    return vec4( dot( p, n ), p.y, dot( p, n ), dot( p, n ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float r, float h )\n{\n    vec2 q = vec2( length( p.xz ) - r, p.y );\n    return vec4( q.x, q.y, length( p.xz ) - r, length( p.yz ) - h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 s", "\n    vec3 d = b - a;\n    vec3 n = normalize( d );\n    vec3 q = a + r * d;\n    vec3 s = p - q;\n    float t = dot( s, n );\n    return vec4( t, t * t, t * t * t, t * t * t * t );\n}\n\nvec3 sdgNormal( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 d1 = b - a;\n    vec3 d2 = c - a;\n    vec3 n = cross( d1, d2 );\n    return normalize( n );\n}\n\nvec3 sdgNormal( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 d1 = b - a;\n    vec3 d2 = c - a;\n    vec3 d3 = d - a;\n    vec3 n = cross( cross( d1, d2 ), d3 );\n    return normalize( n );\n}\n\nvec3 sdgNormal( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e )\n{\n    vec3 d1 = b - a;\n    vec3 d2 = c - a;\n    vec3 d3 = d - a;\n    vec3 d4 = e - a;\n    vec3 n = cross( cross( cross( d1, d2 ), d3 ), d4 );\n    return normalize( n );\n}\n\nvec3 sdgNormal( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f )\n{\n    vec3 d1 = b - a;\n    vec3 d2 = c - a;\n    vec3 d3 = d - a;\n    vec3 d4 = e - a;\n    vec3 d5 = f - a;\n    vec3 n = cross( cross( cross( cross( d1, d2 ), d3 ), d4 ), d5 );\n    return normalize( n );\n}\n\nvec3 sdgNormal( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e,", "\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    q.x = min(q.x, he);\n    q.y = min(q.y, wi);\n    q.x = max(q.x, -he);\n    q.y = max(q.y, -wi);\n    q.x = max(q.x, -sk);\n    q.y = max(q.y, -sk);\n    q.x = min(q.x, sk);\n    q.y = min(q.y, sk);\n    return length(q);\n}\n<|file_separator|>// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, float r )\n{\n    return length(p) - r;\n}\n<|file_separator|>// signed distance to a 2D line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n<|file_separator|>// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 pa_ba = pa - ba;\n    vec2 pa_ca = pa - ca;\n    vec2 ba_ca = ba - ca;\n    float h = clamp( dot(pa_ba,ba_ca)/dot(ba_ca,ba_ca), 0.0, 1.0 );\n    vec2 pa_ca_h = pa_ca - ba_ca*h;\n    return length( pa_ca_h );\n}\n<|file_separator|>// signed distance to a 2D sphere\nfloat sdSphere( in vec2 p, float r )\n{\n    return length(p) - r;\n}\n<|file_separator|>// signed distance to a 2D", "\n    vec2 q = p - vec2( wi, he );\n    return vec3( q.x, q.y, 1.0 );\n}\n\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.xy = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec3 p, float wi, float he, float sk )\n{\n    vec2 q = p - vec2( wi, he );\n    return vec3( q.x, q.y, 1.0 );\n}\n\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.xy = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec4 p, float wi, float he, float sk )\n{\n    vec2 q = p - vec2( wi, he );\n    return vec3( q.x, q.y, 1.0 );\n}\n\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.xy = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec3 p, float wi, float he, float sk )\n{\n    vec2 q = p - vec2( wi, he );\n    return vec3( q.x, q.y, 1.0 );\n}\n\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.xy = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec4 p, float wi, float he, float sk )\n{\n    vec2 q = p - vec2( wi, he );\n    return vec3", "\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1I( int p, int c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1S( string p, string c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1L( long p, long c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1F( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( double p, double c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( long double p, long double c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( long long p, long long c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( unsigned long long p, unsigned long long c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( unsigned long p, unsigned long c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( unsigned int p, unsigned int c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( unsigned short p, unsigned short c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1D( unsigned char p, unsigned char c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\t\nfloat opRep1", "\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k + b;\n  return c;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float c = a * k", "\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p -= q * size;\n    return p;\n}\nvec2 mod2(inout vec2 p, vec", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}<|file_separator|>", "\n    vec3 oc = ro - s.xyz;\n    float a = dot(rd, rd);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float discriminant = b * b - a * c;\n    if (discriminant > 0.0) {\n        float t = (-b - sqrt(discriminant)) / a;\n        if (t > 0.0) {\n            return vec2(t, 0.0);\n        }\n        t = (-b + sqrt(discriminant)) / a;\n        if (t > 0.0) {\n            return vec2(t, 1.0);\n        }\n    }\n    return vec2(-1.0, -1.0);\n}\n<|file_separator|>", "\n    vec3 min = -boxSize / 2.0;\n    vec3 max = boxSize / 2.0;\n    vec3 t1 = (min - ro) / rd;\n    vec3 t2 = (max - ro) / rd;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n    if (tNear > tFar || tFar < 0.0)\n        return vec2(0.0);\n    outNormal = normalize(ro + tNear * rd - boxSize / 2.0);\n    return vec2(tNear, tFar);\n}<|file_separator|>", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    vec2 p3 = p1 + d;\n    vec2 p4 = p1 - d;\n    vec2 p5 = p2 + d;\n    vec2 p6 = p2 - d;\n    vec2 p7 = p3 + d;\n    vec2 p8 = p3 - d;\n    vec2 p9 = p4 + d;\n    vec2 p10 = p4 - d;\n    vec2 p11 = p5 + d;\n    vec2 p12 = p5 - d;\n    vec2 p13 = p6 + d;\n    vec2 p14 = p6 - d;\n    vec2 p15 = p7 + d;\n    vec2 p16 = p7 - d;\n    vec2 p17 = p8 + d;\n    vec2 p18 = p8 - d;\n    vec2 p19 = p9 + d;\n    vec2 p20 = p9 - d;\n    vec2 p21 = p10 + d;\n    vec2 p22 = p10 - d;\n    vec2 p23 = p11 + d;\n    vec2 p24 = p11 - d;\n    vec2 p25 = p12 + d;\n    vec2 p26 = p12 - d;\n    vec2 p27 = p13 + d;\n    vec2 p28 = p13 - d;\n    vec2 p29 = p14 + d;\n    vec2 p30 = p14 - d;\n    vec2 p31 = p15 + d;\n    vec2 p32 = p15 - d;\n    vec2 p33 = p16 + d;\n    vec2 p34 = p16 - d;\n    vec2 p35 = p17 + d;\n    vec2 p36 = p17 - d;\n    vec2 p37 = p18 + d;\n    vec2 p38 = p18 - d;\n    vec2 p39 = p19", "\n  vec2 ap = p - a;\n  vec2 ab = b - a;\n  float proj = dot(ap, ab) / length(ab);\n  if (proj < 0.0) {\n    return length(ap);\n  }\n  if (proj > 1.0) {\n    return length(p - b);\n  }\n  return length(ap - ab * proj);\n}\n\nvoid setup() {\n  size(1000, 1000);\n  background(0);\n  stroke(255);\n  strokeWeight(2);\n}\n\nvoid draw() {\n  background(0);\n  stroke(255);\n  strokeWeight(2);\n  for (int i = 0; i < 1000; i++) {\n    for (int j = 0; j < 1000; j++) {\n      vec2 p = vec2(i, j);\n      vec2 a = vec2(0, 0);\n      vec2 b = vec2(1000, 0);\n      vec2 c = vec2(1000, 1000);\n      vec2 d = vec2(0, 1000);\n      float dist1 = linedist(p, a, b);\n      float dist2 = linedist(p, b, c);\n      float dist3 = linedist(p, c, d);\n      float dist4 = linedist(p, d, a);\n      float minDist = min(min(dist1, dist2), min(dist3, dist4));\n      if (minDist == dist1) {\n        fill(255, 0, 0);\n      } else if (minDist == dist2) {\n        fill(0, 255, 0);\n      } else if (minDist == dist3) {\n        fill(0, 0, 255);\n      } else {\n        fill(255, 255, 0);\n      }\n      rect(i, j, 1, 1);\n    }\n  }\n}\n<|file_separator|>", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float h = length( cross( ab, ap ) ) / length( ab );\n    return min( length( ap ), min( w1, w2 ) * h + smoothstep( 0.0, 1.0, h ) );\n}\n<|file_separator|>// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float h = length( cross( ab, ap ) ) / length( ab );\n    return min( length( ap ), min( w1, w2 ) * h + smoothstep( 0.0, 1.0, h ) );\n}\n<|file_separator|>", "\n  vec2 p = ro.xz / tor.y - ro.yz / tor.x;\n  vec2 q = ro.yz / tor.x - ro.xz / tor.y;\n  float a = length(p);\n  float b = length(q);\n  float c = length(ro.xz) - tor.x * cos(radians(ro.y));\n  float d = length(ro.yz) - tor.y * cos(radians(ro.x));\n  float t = (a * a - b * b + c * c) / (2.0 * a * c);\n  float u = (a * a - b * b + d * d) / (2.0 * a * d);\n  float t1 = t * (a + b);\n  float u1 = u * (a + d);\n  float t2 = t * (a - b);\n  float u2 = u * (a - d);\n  float t3 = t * (a + b);\n  float u3 = u * (a - d);\n  float t4 = t * (a - b);\n  float u4 = u * (a + d);\n  float t5 = t * (a + b);\n  float u5 = u * (a - d);\n  float t6 = t * (a - b);\n  float u6 = u * (a + d);\n  float t7 = t * (a + b);\n  float u7 = u * (a - d);\n  float t8 = t * (a - b);\n  float u8 = u * (a + d);\n  float t9 = t * (a + b);\n  float u9 = u * (a - d);\n  float t10 = t * (a - b);\n  float u10 = u * (a + d);\n  float t11 = t * (a - b);\n  float u11 = u * (a - d);\n  float t12 = t * (a - b);\n  float u12 = u * (a + d);\n  float t13 = t * (a - b);\n  float u13 = u * (a - d);", "\n  vec2 p = pos.xz;\n  float r = length(p);\n  float t = atan(p.y, p.x);\n  float s = r * cos(t);\n  return normalize(vec3(s, r, t));\n}\n\nvec3 torusInter(vec3 pos, vec2 tor) {\n  vec2 p = pos.xz;\n  float r = length(p);\n  float t = atan(p.y, p.x);\n  float s = r * cos(t);\n  return vec3(s, r, t);\n}\n\nvec3 sphereNormal(vec3 pos, vec2 tor) {\n  return normalize(pos);\n}\n\nvec3 sphereInter(vec3 pos, vec2 tor) {\n  return pos;\n}\n\nvec3 planeNormal(vec3 pos, vec2 tor) {\n  return vec3(0.0, 1.0, 0.0);\n}\n\nvec3 planeInter(vec3 pos, vec2 tor) {\n  return vec3(0.0, 1.0, 0.0);\n}\n\nvec3 cylinderNormal(vec3 pos, vec2 tor) {\n  vec2 p = pos.xz;\n  float r = length(p);\n  float t = atan(p.y, p.x);\n  float s = r * cos(t);\n  return normalize(vec3(s, r, t));\n}\n\nvec3 cylinderInter(vec3 pos, vec2 tor) {\n  vec2 p = pos.xz;\n  float r = length(p);\n  float t = atan(p.y, p.x);\n  float s = r * cos(t);\n  return vec3(s, r, t);\n}\n\nvec3 coneNormal(vec3 pos, vec2 tor) {\n  vec2 p = pos.xz;\n  float r = length(p);\n  float t = atan(p.y, p.x);\n  float s = r * cos(t);\n  return normalize(vec3(s, r, t));\n}\n\nvec3 coneInter(vec3 pos, vec2 tor) {\n  vec2 p = pos.xz;\n  float r = length", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative(float x) {\n    return 1 - tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative_derivative_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative_derivative_derivative_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_derivative_derivative_derivative_derivative_derivative_derivative_derivative(float x) {\n    return 1 - tanh(x) * tanh(x) * tanh(x) * tanh(x) * tanh(x) * tan", "\n    vec2 uv = q * vec2(1.0, -1.0);\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec3 c = col;\n    c += mix(vec3(0.0), c, u.x);\n    c += mix(vec3(0.0), c, u.y);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv * 2.0 - 1.0;\n    vec2 p = floor(uv * 1000.0);\n    vec2 f = fract(uv * 1000.0);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec3 col = vec3(0.0);\n    col += mix(vec3(0.0), col, u.x);\n    col += mix(vec3(0.0), col, u.y);\n    col = postProcess(col, q);\n    fragColor = vec4(col, 1.0);\n}\n<|file_separator|>", "\n    p.x = mod(p.x, size.x);\n    p.y = mod(p.y, size.y);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, float size) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size, int size2) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size2);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size, int size2, int size3) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size2);\n    p.z = mod(p.z, size3);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size, int size2, int size3, int size4) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size2);\n    p.z = mod(p.z, size3);\n    p.w = mod(p.w, size4);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size, int size2, int size3, int size4, int size5) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size2);\n    p.z = mod(p.z, size3);\n    p.w = mod(p.w, size4);\n    p.x = mod(p.x, size5);\n    return p;\n}\n\nvec2 mod2(inout vec2 p, int size, int size2, int size3, int size4, int size5, int size6) {\n    p.", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash2(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash3(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash4(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash5(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash6(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash7(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash8(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash9(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash10(vec2 uv) {\n    return fract(sin(", "\n    return length( p - c ) - r;\n}\n<|file_separator|>", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n<|file_separator|>", "\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat signedDistToTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    float d1 = cro(ab, ap);\n    float d2 = cro(ac, ap);\n    float d3 = cro(ab, bp);\n    float d4 = cro(ac, bp);\n    float d5 = cro(ab, cp);\n    float d6 = cro(ac, cp);\n    return abs(d1 * d2 - d3 * d4 + d5 * d6) / length(ab);\n}\n\n// signed distance to a 2D triangle\nfloat signedDistToTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    float d1 = cro(ab, ap);\n    float d2 = cro(ac, ap);\n    float d3 = cro(ab, bp);\n    float d4 = cro(ac, bp);\n    float d5 = cro(ab, cp);\n    float d6 = cro(ac, cp);\n    return abs(d1 * d2 - d3 * d4 + d5 * d6) / length(ab);\n}<|file_separator|>", "\n    vec2 q = abs(p) - vec2(s/2.0);\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) - r;\n}\n<|file_separator|>", "\n    return 0.5 * (1.0 + x);\n}\n\nvec3 s_curve_inv(vec3 x)\n{\n    return 0.5 * (1.0 - x);\n}\n\n// This is the curve that is used in the paper\nvec3 aces_filmic(vec3 x)\n{\n    return pow(x, vec3(1.0 / 2.2));\n}\n\n// This is the inverse of the curve that is used in the paper\nvec3 aces_filmic_inv(vec3 x)\n{\n    return pow(x, vec3(2.2));\n}\n\n// This is the curve that is used in the paper\nvec3 aces_filmic_tonemap(vec3 x)\n{\n    return s_curve(aces_filmic(x));\n}\n\n// This is the inverse of the curve that is used in the paper\nvec3 aces_filmic_tonemap_inv(vec3 x)\n{\n    return aces_filmic_inv(s_curve_inv(x));\n}<|file_separator|>", "\n    return 3.0 * x * (1.0 - x);\n}\n<|file_separator|>// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 3.0 * x * (1.0 - x);\n}\n<|file_separator|>// derivative of s-curve\nvec3 d_s_curve(vec3 x)\n{\n    return 3.0 * x * (1.0 - x);\n}\n<|file_separator|>", "\n    float a = atan( p.y, p.x );\n    float r = length( p );\n    float s = sin( a * k );\n    return r * s * w;\n}<|file_separator|>", "\n    vec3 absorption = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        absorption[i] = 1.0 - exp(-opticalDepth[i]);\n    }\n    return absorption;\n}\n\n// Calculate a transmittance value from optical depth\nvec3 Transmittance(vec3 opticalDepth)\n{\n    vec3 transmittance = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        transmittance[i] = exp(-opticalDepth[i]);\n    }\n    return transmittance;\n}\n\n// Calculate a reflectance value from optical depth\nvec3 Reflectance(vec3 opticalDepth)\n{\n    vec3 reflectance = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        reflectance[i] = 1.0 - exp(-2.0 * opticalDepth[i]);\n    }\n    return reflectance;\n}\n\n// Calculate a transmission value from optical depth\nvec3 Transmission(vec3 opticalDepth)\n{\n    vec3 transmission = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        transmission[i] = exp(-2.0 * opticalDepth[i]);\n    }\n    return transmission;\n}\n\n// Calculate a scattering value from optical depth\nvec3 Scattering(vec3 opticalDepth)\n{\n    vec3 scattering = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        scattering[i] = exp(-2.0 * opticalDepth[i]);\n    }\n    return scattering;\n}\n\n// Calculate a phase value from optical depth\nvec3 Phase(vec3 opticalDepth)\n{\n    vec3 phase = vec3(0.0);\n    for (int i = 0; i < 3; i++)\n    {\n        phase[i] = exp(-2.0 * opticalDepth[i]);\n    }\n    return phase;\n}\n\n// Calculate a phase value from optical depth\nvec3 Phase(vec3 opticalDepth)\n{\n    vec3 phase = vec3(0.", "\n    vec3 rayPos = rayStart;\n    vec3 rayDirNorm = normalize(rayDir);\n    vec3 lightPos = lightDir;\n    vec3 lightColorNorm = normalize(lightColor);\n    vec3 lightDirNorm = normalize(lightDir);\n    vec3 rayDirNormInv = vec3(1.0) / rayDirNorm;\n    vec3 rayDirNormInvSqr = rayDirNormInv * rayDirNormInv;\n    vec3 rayDirNormInvSqrInv = 1.0 / (rayDirNormInvSqr * rayDirNormInvSqr);\n    vec3 rayDirNormInvSqrInvInv = 1.0 / (rayDirNormInvSqrInv * rayDirNormInvSqrInv);\n    vec3 rayDirNormInvSqrInvInvSqr = rayDirNormInvSqrInvInv * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInv = rayDirNormInvSqrInvInvSqr * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInv = rayDirNormInvSqrInvInvSqrInv * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqr = rayDirNormInvSqrInvInvSqrInvInv * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqrInv = rayDirNormInvSqrInvInvSqrInvInvSqr * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqrInv = rayDirNormInvSqrInvInvSqrInvInvSqr * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqrInv = rayDirNormInvSqrInvInvSqrInvInvSqr * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqrInv = rayDirNormInvSqrInvInvSqrInvInvSqr * rayDirNormInvSqrInvInv;\n    vec3 rayDirNormInvSqrInvInvSqrInvInvSqrInv =", "\n    vec3 d = p2 - vec3(0.0, 0.0, 0.0);\n    float a = length(d);\n    float b = ra + rb;\n    float c = a - b;\n    float h = sqrt(c * c - a * a);\n    float t = a - h;\n    float s = t - d.y;\n    float r = sqrt(s * s + d.x * d.x);\n    float u = acos(s / r);\n    float v = acos(d.z / r);\n    float w = acos(d.x / r);\n    float x = min(min(u, v), w);\n    float y = max(max(u, v), w);\n    float z = max(u, v);\n    float A = 0.5 * (a + b + c);\n    float B = 0.5 * (a + b - c);\n    float C = 0.5 * (a - b + c);\n    float D = 0.5 * (a - b - c);\n    float E = 0.5 * (a + b - c);\n    float F = 0.5 * (a - b + c);\n    float G = 0.5 * (a - b - c);\n    float H = 0.5 * (a + b - c);\n    float I = 0.5 * (a + b + c);\n    float J = 0.5 * (a - b - c);\n    float K = 0.5 * (a + b + c);\n    float L = 0.5 * (a - b + c);\n    float M = 0.5 * (a - b - c);\n    float N = 0.5 * (a + b + c);\n    float O = 0.5 * (a - b + c);\n    float P = 0.5 * (a + b - c);\n    float Q = 0.5 * (a - b - c);\n    float R = 0.5 * (a + b - c);\n    float S = 0.5 * (a - b + c);\n    float T", "\n    vec3 q = abs(p) - vec3(r);\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d - h + t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSolidSphere( vec3 p, float r, float h, float t )\n{\n    vec3 q = abs(p) - vec3(r);\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d - h + t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\n    vec3 q = abs(p) - vec3(r);\n    float d = length(max(q,vec3(0.0))) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d - h + t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSolidCylinder( vec3 p, float r, float h, float t )\n{\n    vec3 q = abs(p) - vec3(r);\n    float d = length(max(q,vec3(0.0))) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d - h + t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\n    vec3 q = abs(p) - vec3(r);\n    float d = length(max(q,vec3(0.0))) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d -", "\n    float shadow = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = t + k;\n        if( d > tmax )\n            break;\n        t = d;\n        shadow += 1.0 / ( d * d );\n    }\n    return shadow;\n}\n\n// https://iquilezles.org/articles/rmshadows\nvec3 calcShadow( in vec3 ro, in vec3 rd, const float k )\n{\n    vec3 shadow = vec3( 0.0 );\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = tmin + k;\n        if( t > tmax )\n            break;\n        shadow += vec3( 1.0 ) / ( t * t );\n        tmin = t;\n    }\n    return shadow;\n}\n\n// https://iquilezles.org/articles/rmshadows\nvec3 calcShadow( in vec3 ro, in vec3 rd, const float k )\n{\n    vec3 shadow = vec3( 0.0 );\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = tmin + k;\n        if( t > tmax )\n            break;\n        shadow += vec3( 1.0 ) / ( t * t );\n        tmin = t;\n    }\n    return shadow;\n}\n\n// https://iquilezles.org/articles/rmshadows\nvec3 calcShadow( in vec3 ro, in vec3 rd, const float k )\n{\n    vec3 shadow = vec3( 0.0 );\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i = 0; i < 10; i++ )\n", "\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float", "\n    vec3 n = vec3( 0.0 );\n    float h = 0.0001;\n    n.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    n.y = sdf( pos + vec3( 0.0, h, 0.0 ) ) - sdf( pos - vec3( 0.0, h, 0.0 ) );\n    n.z = sdf( pos + vec3( 0.0, 0.0, h ) ) - sdf( pos - vec3( 0.0, 0.0, h ) );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3( 0.0 );\n    float h = 0.0001;\n    n.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    n.y = sdf( pos + vec3( 0.0, h, 0.0 ) ) - sdf( pos - vec3( 0.0, h, 0.0 ) );\n    n.z = sdf( pos + vec3( 0.0, 0.0, h ) ) - sdf( pos - vec3( 0.0, 0.0, h ) );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3( 0.0 );\n    float h = 0.0001;\n    n.x = sdf( pos + vec3( h, 0.0, 0.0 ) ) - sdf( pos - vec3( h, 0.0, 0.0 ) );\n    n.y = sdf( pos + vec3( 0.0, h, 0.0 ) )", "\n    vec2 q = abs(p) - vec2(r,h);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n<|file_separator|>", "\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix( mix( dot( p, vec3(1.0, 0.0, 0.0) ),\n                    dot( p+vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0) ), u.x),\n                mix( dot( p, vec3(0.0, 1.0, 0.0) ),\n                    dot( p+vec3(1.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0) ), u.x), u.y);\n}\n<|file_separator|>", "\n    float f = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3( 12.9898, 78.233, 114.37);\n    for( int i = 0; i < octaves; i++ )\n    {\n        f += a * abs( noise( p ) );\n        p = abs( rotate( p, rot ) ) * 2.0 * pnoise( shift * p, rot ) * 2.0;\n        a *= persistence;\n    }\n    return f;\n}<|file_separator|>// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3( 12.9898, 78.233, 114.37);\n    for( int i = 0; i < octaves; i++ )\n    {\n        f += a * abs( noise( p ) );\n        p = abs( rotate( p, rot ) ) * 2.0 * pnoise( shift * p, rot ) * 2.0;\n        a *= persistence;\n    }\n    return f;\n}<|file_separator|>", "\n    p3  = fract(p3 *.1031);\n    p3  = p3 * p3 * p3 * (p3 * (p3 * 6.0 - 15.0) + 10.0);\n    return p3.x + p3.y * 13.0 + 13.0 * p3.z;\n}\n\n//value noise hash\nfloat valueNoiseHash(vec3 p)\n{\n    vec3 p3  = fract(p *.1031);\n    p3  = p3 * p3 * p3 * (p3 * (p3 * 6.0 - 15.0) + 10.0);\n    return p3.x + p3.y * 13.0 + 13.0 * p3.z;\n}<|file_separator|>", "\n    vec2 uv = fragCoord.xy / vec2(1024, 1024);\n    vec3 color = vec3(uv.x, uv.y, 0.0);\n    fragColor = vec4(color, 1.0);\n}\n<|file_separator|>", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n<|file_separator|>", "\n    float q = p / size;\n    float r = p - q * size;\n    if (r < 0.0) {\n        r += size;\n    }\n    p = r;\n    return p;\n}\n<|file_separator|>", "\n    co = fract(co * 127.1 + 16.0);\n    return co * co * co * (co * (co * 6.0 - 15.0) + 10.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n    return fract(sin(dot(co, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co) {\n    return fract(sin(dot(co, vec3(127.1, 311.7, 75.3))) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co) {\n    return fract(sin(dot(co, vec4(127.1, 311.7, 75.3, 113.5))) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co, float seed) {\n    return fract(sin(dot(co, vec2(127.1, seed))) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co, float seed) {\n    return fract(sin(dot(co, vec3(127.1, seed, 311.7))) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co, float seed) {\n    return fract(sin(dot(co, vec4(127.1, seed, 311.7, 75.3))) * 43758.5453123);\n}\n\n// License", "\n    return t < 0.0031308? t * 12.92 : pow(t, 1.0 / 2.4) * 1.055 - 0.055;\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix(dot(i, vec3(1.0, 1.0, 1.0)),\n                      dot(i + vec3(1.0, 0.0, 0.0), vec3(1.0, 7.0, 1.0)), f.x),\n                  mix(dot(i + vec3(0.0, 1.0, 0.0), vec3(1.0, 7.0, 1.0)),\n                      dot(i + vec3(1.0, 1.0, 0.0), vec3(1.0, 7.0, 1.0)), f.x), f.y),\n              mix(mix(dot(i + vec3(0.0, 0.0, 1.0), vec3(1.0, 7.0, 1.0)),\n                      dot(i + vec3(1.0, 0.0, 1.0), vec3(1.0, 7.0, 1.0)), f.x),\n                  mix(dot(i + vec3(0.0, 1.0, 1.0), vec3(1.0, 7.0, 1.0)),\n                      dot(i + vec3(1.0, 1.0, 1.0), vec3(1.0, 7.0, 1.0)), f.x), f.y), f.z);\n}\n\nfloat turbulence(vec3 p, int depth) {\n    float t = 0.0;\n    float f = 1.0;\n    \n    for (int i = 0; i < depth; i++) {\n        t += f *", "\n    return c / (c + vec3(1.0));\n}\n\nvec3 sRGB(in vec3 c, in float gamma) {\n    return pow(c, vec3(gamma));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2) {\n    return pow(c, vec3(gamma, gamma2, gamma));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3) {\n    return pow(c, vec3(gamma, gamma2, gamma3));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4) {\n    return pow(c, vec3(gamma, gamma2, gamma3, gamma4));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4, in float gamma5) {\n    return pow(c, vec3(gamma, gamma2, gamma3, gamma4, gamma5));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4, in float gamma5, in float gamma6) {\n    return pow(c, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4, in float gamma5, in float gamma6, in float gamma7) {\n    return pow(c, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6, gamma7));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4, in float gamma5, in float gamma6, in float gamma7, in float gamma8) {\n    return pow(c, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6, gamma7, gamma8));\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float gamma2, in float gamma3, in float gamma4", "\n    return a < b? (a < k? a : k) : (b < k? b : k);\n}\nfloat pmax(float a, float b, float k) {\n    return a > b? (a > k? a : k) : (b > k? b : k);\n}\nfloat smin(float a, float b, float k) {\n    return a < b? (a > k? b : a) : (b > k? a : b);\n}\nfloat smax(float a, float b, float k) {\n    return a > b? (a < k? b : a) : (b < k? a : b);\n}\nfloat slerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float b, float t) {\n    return t * t * (3 - 2 * t);\n}\nfloat smoothstep(float a, float", "\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - sph.x * sph.x;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n    if (t1 < 0.0 && t2 < 0.0) {\n        return -1.0;\n    }\n    float t = max(t1, t2);\n    if (t < 0.0) {\n        return -1.0;\n    }\n    float d = length(ro + t * rd - sph.xy);\n    if (d < dbuffer) {\n        return t;\n    }\n    return -1.0;\n}\n<|file_separator|>", "\n  vec4 q = p * p * p;\n  return q * (q * (q * p + vec4(1.0)) + vec4(1.0)) + vec4(1.0);\n}\nvec2 formula2(vec2 p) {\n  vec2 q = p * p * p;\n  return q * (q * (q * p + vec2(1.0)) + vec2(1.0)) + vec2(1.0);\n}\nvec3 formula3(vec3 p) {\n  vec3 q = p * p * p;\n  return q * (q * (q * p + vec3(1.0)) + vec3(1.0)) + vec3(1.0);\n}\nvec4 formula4(vec4 p) {\n  vec4 q = p * p * p;\n  return q * (q * (q * p + vec4(1.0)) + vec4(1.0)) + vec4(1.0);\n}\nvec2 formula5(vec2 p) {\n  vec2 q = p * p * p;\n  return q * (q * (q * p + vec2(1.0)) + vec2(1.0)) + vec2(1.0);\n}\nvec3 formula6(vec3 p) {\n  vec3 q = p * p * p;\n  return q * (q * (q * p + vec3(1.0)) + vec3(1.0)) + vec3(1.0);\n}\nvec4 formula7(vec4 p) {\n  vec4 q = p * p * p;\n  return q * (q * (q * p + vec4(1.0)) + vec4(1.0)) + vec4(1.0);\n}\nvec2 formula8(vec2 p) {\n  vec2 q = p * p * p;\n  return q * (q * (q * p + vec2(1.0)) + vec2(1.0)) + vec2(1.0);\n}\nvec3 formula9(vec3 p) {\n  vec3 q = p * p * p;\n  return q * (q * (q * p", "\n    vec3 q = abs( p ) - r;\n    return vec4( dot( q, q ), dot( q, q ), dot( q, q ), dot( q, q ) );\n}\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoidGrad( vec3 p, vec3 r )\n{\n    vec3 q = abs( p ) - r;\n    return vec4( 2.0 * dot( q, p ), 2.0 * dot( q, p ), 2.0 * dot( q, p ), 2.0 * dot( q, p ) );\n}\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoidLaplacian( vec3 p, vec3 r )\n{\n    vec3 q = abs( p ) - r;\n    return vec4( 6.0 * dot( q, q ), 6.0 * dot( q, q ), 6.0 * dot( q, q ), 6.0 * dot( q, q ) );\n}\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoidGradient( vec3 p, vec3 r )\n{\n    vec3 q = abs( p ) - r;\n    return vec4( 2.0 * dot( q, p ), 2.0 * dot( q, p ), 2.0 * dot( q, p ), 2.0 * dot( q, p ) );\n}\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoidGradientLaplacian( vec3 p, vec3 r )\n{\n    vec3 q = abs( p ) - r;\n    return vec4( 6.0 * dot( q, q ), 6.0 * dot( q, q ), 6.0 * dot( q, q ), 6.0 * dot( q, q ) );\n}\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4", "\n    return mix(back, front, back.a);\n}\n<|file_separator|>", "\n    return back * (1.0 - front.w) + front.xyz * front.w;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return back * (1.0 - front.w) + front * front.w;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return back * (1.0 - alpha) + front * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha) {\n    return back * (1.0 - alpha.x) + front * alpha.x + (back * (1.0 - alpha.y) + front * alpha.y) * alpha.z;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 alpha2) {\n    return back * (1.0 - alpha.x) + front * alpha.x + (back * (1.0 - alpha.y) + front * alpha.y) * alpha.z + (back * (1.0 - alpha2.x) + front * alpha2.x) * alpha2.y * alpha2.z;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 alpha2, vec3 alpha3) {\n    return back * (1.0 - alpha.x) + front * alpha.x + (back * (1.0 - alpha.y) + front * alpha.y) * alpha.z + (back * (1.0 - alpha2.x) + front * alpha2.x) * alpha2.y * alpha2.z + (back * (1.0 - alpha3.x) + front * alpha3.x) * alpha3.y * alpha3.z * alpha3.w;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    return 1.0 - abs(sin(p.x * 10.0 + p.y * 10.0) * r);\n}\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    float res = mix(mix(mix( dot(u, vec2(1.0, 0.0)), dot(u, vec2(0.0, 1.0)), 0.5),\n        mix( dot(u, vec2(1.0, 0.0)), dot(u, vec2(0.0, 1.0)), 0.5), u.x),\n        mix(mix( dot(u, vec2(1.0, 0.0)), dot(u, vec2(0.0, 1.0)), 0.5),\n        mix( dot(u, vec2(1.0, 0.0)), dot(u, vec2(0.0, 1.0)), 0.5), u.x), u.y);\n    return res;\n}\nfloat noise(vec2 p, float r) {\n    return noise(p) * r;\n}\nfloat noise(vec2 p, float r, float t) {\n    return noise(p, r) * t;\n}\nfloat noise(vec2 p, float r, float t, float s) {\n    return noise(p, r, t) * s;\n}\nfloat noise(vec2 p, float r, float t, float s, float a) {\n    return noise(p, r, t, s) * a;\n}\nfloat noise(vec2 p, float r, float t, float s, float a, float b) {\n    return noise(p, r, t, s, a) * b;\n}\nfloat noise(vec2 p, float r, float t, float s, float a, float b, float c) {\n    return noise(p, r, t, s, a, b) * c;\n}\nfloat noise(vec2 p, float r, float t, float s,", "\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_inv(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_inv_gamma(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_gamma_inv(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(2.2));\n}\n\nvec3 aces_approx_gamma_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec3 v) {\n    return pow(v, vec3(1.0 / 2.2));\n}\n\nvec3 aces_approx_gamma_", "\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 hash2(vec2 p, float seed) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed);\n}\n\nvec2 hash2(vec2 p, float seed, float scale) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed * scale);\n}\n\nvec2 hash2(vec2 p, float seed, float scale, float scale2) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed * scale + scale2);\n}\n\nvec2 hash2(vec2 p, float seed, float scale, float scale2, float scale3) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed * scale + scale2 * scale3);\n}\n\nvec2 hash2(vec2 p, float seed, float scale, float scale2, float scale3, float scale4) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed * scale + scale2 * scale3 + scale4);\n}\n\nvec2 hash2(vec2 p, float seed, float scale, float scale2, float scale3, float scale4, float scale5) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453 + seed * scale + scale2 * scale3 + scale4 * scale5);\n}\n\nvec2 hash2(", "\n    return vec3(\n        exp(-0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = dot(i, vec2(1., 57.));\n    n = dot(vec2(floor(n), mod(n, 29.)), vec2(1., 57.));\n    \n    return mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(", "\n  vec3 oc = ro - sph.xyz;\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(oc, rd);\n  float c = dot(oc, oc) - sph.w * sph.w;\n  float discriminant = b * b - 4.0 * a * c;\n  if (discriminant < 0.0) return vec2(-1.0, -1.0);\n  float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n  float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n  if (t1 < 0.0) t1 = t2;\n  if (t1 < 0.0) return vec2(-1.0, -1.0);\n  return vec2(t1, t2);\n}\n\nvec3 sphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec2 t = raySphere(ro, rd, sph);\n  if (t.x < 0.0) return vec3(0.0, 0.0, 0.0);\n  return ro + t.x * rd;\n}\n\nvec3 sphereNormal(vec3 ro, vec3 rd, vec4 sph) {\n  vec2 t = raySphere(ro, rd, sph);\n  if (t.x < 0.0) return vec3(0.0, 0.0, 0.0);\n  return normalize(ro + t.x * rd - sph.xyz);\n}\n\nvec3 sphereColor(vec3 ro, vec3 rd, vec4 sph) {\n  vec2 t = raySphere(ro, rd, sph);\n  if (t.x < 0.0) return vec3(0.0, 0.0, 0.0);\n  return sph.xyz;\n}\n\nvec3 sphereColor(vec3 ro, vec3 rd, vec4 sph, vec3 light) {\n  vec2 t = raySphere(ro, rd, sph);\n  if (t.x < 0.0) return vec3(0.0, 0.0, 0.0);\n  vec3 p", "\n    vec2 q = p.xy;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    float a = min(q.x, q.y);\n    float b = max(q.x, q.y);\n    float c = (a * a + b * b - n * n) / (2.0 * a * b);\n    return vec3(a, b, c);\n}\n\nvec3 sdCircle(vec2 p, float n)\n{\n    vec2 q = p.xy;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    float a = min(q.x, q.y);\n    float b = max(q.x, q.y);\n    float c = (a * a + b * b - n * n) / (2.0 * a * b);\n    return vec3(a, b, c);\n}\n\nvec3 sdCircle(vec2 p, float n, float m)\n{\n    vec2 q = p.xy;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    float a = min(q.x, q.y);\n    float b = max(q.x, q.y);\n    float c = (a * a + b * b - n * n) / (2.0 * a * b);\n    return vec3(a, b, c);\n}\n\nvec3 sdCircle(vec2 p, float n, float m, float o)\n{\n    vec2 q = p.xy;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    float a = min(q.x, q.y);\n    float b = max(q.x, q.y);\n    float c = (a * a + b * b - n * n) / (2.0 * a * b);\n    return vec3(a, b, c);\n}\n\nvec3 sdCircle(vec2 p, float n, float m, float o, float p)\n{\n    vec2 q = p.xy;", "\n    return ( 1.0f - 2.0f * ( x + t ) );\n}\n\nfloat cantor_derivative( float x, float t )\n{\n    return ( -2.0f * t );\n}\n\nfloat cantor_integral( float x, float t )\n{\n    return ( 1.0f - 2.0f * t );\n}\n\nfloat cantor_integral_derivative( float x, float t )\n{\n    return ( -2.0f );\n}\n\nfloat cantor_integral_integral( float x, float t )\n{\n    return ( 1.0f );\n}\n\nfloat cantor_integral_integral_derivative( float x, float t )\n{\n    return ( -1.0f );\n}\n\nfloat cantor_integral_integral_integral( float x, float t )\n{\n    return ( 0.0f );\n}\n\nfloat cantor_integral_integral_integral_derivative( float x, float t )\n{\n    return ( 0.0f );\n}\n\nfloat cantor_integral_integral_integral_integral( float x, float t )\n{\n    return ( 1.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_derivative( float x, float t )\n{\n    return ( 1.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral( float x, float t )\n{\n    return ( 0.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral_derivative( float x, float t )\n{\n    return ( 0.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral_integral( float x, float t )\n{\n    return ( 1.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral_integral_derivative( float x, float t )\n{\n    return ( 1.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral_integral_integral( float x, float t )\n{\n    return ( 0.0f );\n}\n\nfloat cantor_integral_integral_integral_integral_integral_integral_integral_derivative( float x, float t )\n{\n    ", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = max( dot(pa,ba), 0.0 );\n    return length( pa - ba * h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.x, p.y ) - t.x, p.z );\n    return length( q ) - t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot( p, n );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdCone( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0", "\n  vec3 q = p;\n  for (int i = 0; i < 3; i++) {\n    q[i] = fract(q[i]);\n  }\n  return fract(sin(dot(q, vec3(12.9898, 78.233, 37.712))) * 43758.5453);\n}\n\n// main fractal func\nvec3 fractal(vec3 p, int idx) {\n  vec3 q = p;\n  for (int i = 0; i < 3; i++) {\n    q[i] = fract(q[i]);\n  }\n  return fract(sin(dot(q, vec3(12.9898, 78.233, 37.712))) * 43758.5453);\n}\n\n// main fractal func\nvec3 fractal(vec3 p, int idx) {\n  vec3 q = p;\n  for (int i = 0; i < 3; i++) {\n    q[i] = fract(q[i]);\n  }\n  return fract(sin(dot(q, vec3(12.9898, 78.233, 37.712))) * 43758.5453);\n}\n\n// main fractal func\nvec3 fractal(vec3 p, int idx) {\n  vec3 q = p;\n  for (int i = 0; i < 3; i++) {\n    q[i] = fract(q[i]);\n  }\n  return fract(sin(dot(q, vec3(12.9898, 78.233, 37.712))) * 43758.5453);\n}\n\n// main fractal func\nvec3 fractal(vec3 p, int idx) {\n  vec3 q = p;\n  for (int i = 0; i < 3; i++) {\n    q[i] = fract(q[i]);\n  }\n  return fract(sin(dot(q, vec3(12.9", "\n  float a = 1.0;\n  float b = 1.0;\n  float c = 1.0;\n  float d = 1.0;\n  float e = 1.0;\n  float f = 1.0;\n  float g = 1.0;\n  float h = 1.0;\n  float i = 1.0;\n  float j = 1.0;\n  float k = 1.0;\n  float l = 1.0;\n  float m = 1.0;\n  float n = 1.0;\n  float o = 1.0;\n  float p = 1.0;\n  float q = 1.0;\n  float r = 1.0;\n  float s = 1.0;\n  float t = 1.0;\n  float u = 1.0;\n  float v = 1.0;\n  float w = 1.0;\n  float x1 = 1.0;\n  float y1 = 1.0;\n  float z = 1.0;\n  float z1 = 1.0;\n  float z2 = 1.0;\n  float z3 = 1.0;\n  float z4 = 1.0;\n  float z5 = 1.0;\n  float z6 = 1.0;\n  float z7 = 1.0;\n  float z8 = 1.0;\n  float z9 = 1.0;\n  float z10 = 1.0;\n  float z11 = 1.0;\n  float z12 = 1.0;\n  float z13 = 1.0;\n  float z14 = 1.0;\n  float z15 = 1.0;\n  float z16 = 1.0;\n  float z17 = 1.0;\n  float z18 = 1.0;\n  float z19 = 1.0;\n  float z20 = 1.0;\n  float z21 = 1.0;\n  float z22 =", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y);\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return vec2(pow(z.x, w.x) * cos(w.y), pow(z.x, w.x) * sin(w.y));\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(z.x * z.x + z.y * z.y), atan(z.y, z.x));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x * z.x + z.y * z.y), atan(z.y, z.x));\n}\n\nvec2 catanh(vec2 z) {\n    return vec2(atanh(z.x), z.y);\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), z.y);\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x), z.y);\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x), z.y);\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), z.y);\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), z.y);\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x), z.y);", "\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n    return vec2(1.0, 1.0) / tanh(z);\n}<|file_separator|>// Inverse hyperbolic tangent \nvec2", "\n    return vec2(\n        cos(z.x) * exp(z.y),\n        sin(z.x) * exp(z.y)\n    );\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)),\n        (exp(z.y) - exp(-z.y)) / (exp(z.y) + exp(-z.y))\n    );\n}\n\nvec2 ctanh_prime(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (1 - (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x))),\n        (exp(z.y) - exp(-z.y)) / (exp(z.y) + exp(-z.y)) * (1 - (exp(z.y) + exp(-z.y)) / (exp(z.y) + exp(-z.y)) * (exp(z.y) + exp(-z.y)) / (exp(z.y) + exp(-z.y)))\n    );\n}\n\nvec2 ctanh_prime_prime(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (1 - (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x))) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)),", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y);\n}\nvec2 cpow(vec2 z, vec2 w) {\n    return vec2(pow(z.x, w.x) * cos(w.y), pow(z.x, w.x) * sin(w.y));\n}\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\nvec2 clog(vec2 z) {\n    return vec2(log(z.x * z.x + z.y * z.y), atan(z.y, z.x));\n}\nvec2 catanh(vec2 z) {\n    return vec2(atanh(z.x), z.y);\n}\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x), z.y / 2.0);\n}\nvec2 cpow(vec2 z, float w) {\n    return vec2(pow(z.x, w) * cos(w), pow(z.x, w) * sin(w));\n}\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\nvec2 clog(vec2 z) {\n    return vec2(log(z.x * z.x + z.y * z.y), atan(z.y, z.x));\n}\nvec2 catanh(vec2 z) {\n    return vec2(atanh(z.x), z.y);\n}\nvec2 csqrt(vec2 z) {\n    return vec", "\n    return vec2(\n        cos(z.x) * exp(z.y),\n        sin(z.x) * exp(z.y)\n    );\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)),\n        (exp(z.y) - exp(-z.y)) / (exp(z.y) + exp(-z.y))\n    );\n}\n\nvec2 ctanh_prime(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (1 - (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x))),\n        (exp(z.y) - exp(-z.y)) / (exp(z.y) + exp(-z.y)) * (1 - (exp(z.y) + exp(-z.y)) / (exp(z.y) + exp(-z.y)) * (exp(z.y) + exp(-z.y)) / (exp(z.y) + exp(-z.y)))\n    );\n}\n\nvec2 ctanh_prime_prime(vec2 z) {\n    return vec2(\n        (exp(z.x) - exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (1 - (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x))) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x)) * (exp(z.x) + exp(-z.x)) / (exp(z.x) + exp(-z.x))", "\n  float sum = alpha.r + alpha.g + alpha.b;\n  float alphaSum = alpha.r * sum + alpha.g * sum + alpha.b * sum;\n  float alphaSumSq = alphaSum * alphaSum;\n  float alphaSumSqSum = alphaSumSq * sum;\n  float alphaSumSqSumSq = alphaSumSqSum * sum;\n  float alphaSumSqSumSqSum = alphaSumSqSumSq * sum;\n  float alphaSumSqSumSqSumSq = alphaSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSum = alphaSumSqSumSqSumSq * sum;\n  float alphaSumSqSumSqSumSqSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSumSumSumSumSumSumSumSumSumSumSumSumSumSumSum = alphaSumSqSumSqSumSqSum * sum;\n  float alphaSumSqSumSqSumSqSum", "\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Dodecahedron\nfloat dodecaDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Dodecahedron\nfloat dodecaDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Tetrahedron\nfloat tetraDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Tetrahedron\nfloat tetraDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) - 0.5;\n  return length(max(d, 0.0));\n}\n<|file_separator|>//Distance from the Edge of a Tetrahedron\nfloat tetraDist(vec3 p) {\n  vec3 q = p - vec3(0.5, 0.5, 0.5);\n  vec3 d = abs(q) -", "\n    vec3 p = uvw.xyz;\n    vec3 q = uvw.xyz;\n    vec3 r = uvw.xyz;\n    vec3 s = uvw.xyz;\n    vec3 t = uvw.xyz;\n    vec3 u = uvw.xyz;\n    vec3 v = uvw.xyz;\n    vec3 w = uvw.xyz;\n    vec3 x = uvw.xyz;\n    vec3 y = uvw.xyz;\n    vec3 z = uvw.xyz;\n    vec3 a = uvw.xyz;\n    vec3 b = uvw.xyz;\n    vec3 c = uvw.xyz;\n    vec3 d = uvw.xyz;\n    vec3 e = uvw.xyz;\n    vec3 f = uvw.xyz;\n    vec3 g = uvw.xyz;\n    vec3 h = uvw.xyz;\n    vec3 i = uvw.xyz;\n    vec3 j = uvw.xyz;\n    vec3 k = uvw.xyz;\n    vec3 l = uvw.xyz;\n    vec3 m = uvw.xyz;\n    vec3 n = uvw.xyz;\n    vec3 o = uvw.xyz;\n    vec3 p1 = uvw.xyz;\n    vec3 q1 = uvw.xyz;\n    vec3 r1 = uvw.xyz;\n    vec3 s1 = uvw.xyz;\n    vec3 t1 = uvw.xyz;\n    vec3 u1 = uvw.xyz;\n    vec3 v1 = uvw.xyz;\n    vec3 w1 = uvw.xyz;\n    vec3 x1 = uvw.xyz;\n    vec3 y1 = uvw.xyz;\n    vec3 z1 = uvw.xyz;\n    vec3 a1 = uvw.xyz;\n    vec3 b1 = uvw.xyz;\n    vec3 c1 = uvw.xyz;\n    vec3 d1 = uvw.xyz;\n    vec3 e1 = uvw.xyz;\n    vec3 f1 = uvw.xyz;\n    vec3 g1 = uvw.xyz;\n    vec3 h1 = uvw.", "\n    vec3 p = uvw + offset;\n    vec3 q = p * gridRes;\n    vec3 r = q * gridRes;\n    vec3 s = r * gridRes;\n    vec3 t = s * gridRes;\n    vec3 u = t * gridRes;\n    vec3 v = u * gridRes;\n    vec3 w = v * gridRes;\n    vec3 x = w * gridRes;\n    vec3 y = x * gridRes;\n    vec3 z = y * gridRes;\n    vec3 a = z * gridRes;\n    vec3 b = a * gridRes;\n    vec3 c = b * gridRes;\n    vec3 d = c * gridRes;\n    vec3 e = d * gridRes;\n    vec3 f = e * gridRes;\n    vec3 g = f * gridRes;\n    vec3 h = g * gridRes;\n    vec3 i = h * gridRes;\n    vec3 j = i * gridRes;\n    vec3 k = j * gridRes;\n    vec3 l = k * gridRes;\n    vec3 m = l * gridRes;\n    vec3 n = m * gridRes;\n    vec3 o = n * gridRes;\n    vec3 p1 = o * gridRes;\n    vec3 q1 = p1 * gridRes;\n    vec3 r1 = q1 * gridRes;\n    vec3 s1 = r1 * gridRes;\n    vec3 t1 = s1 * gridRes;\n    vec3 u1 = t1 * gridRes;\n    vec3 v1 = u1 * gridRes;\n    vec3 w1 = v1 * gridRes;\n    vec3 x1 = w1 * gridRes;\n    vec3 y1 = x1 * gridRes;\n    vec3 z1 = y1 * gridRes;\n    vec3 a1 = z1 * gridRes;\n    vec3 b1 = a1 * gridRes;\n    vec3 c1 = b1 * gridRes;\n    vec3 d1 = c1 * gridRes;\n    vec3 e1 = d1 * gridRes;\n    vec3 f1 = e1 * gridRes;\n    vec3 g1", "\n    vec3 p = vec3(0.0);\n    float s = 1.0 / gridRes;\n    float t = 1.0 / gridRes;\n    float s2 = s * s;\n    float t2 = t * t;\n    float s3 = s * s * s;\n    float t3 = t * t * t;\n    float s4 = s * s * s * s;\n    float t4 = t * t * t * t;\n    float s5 = s * s * s * s * s;\n    float t5 = t * t * t * t * t;\n    float s6 = s * s * s * s * s * s;\n    float t6 = t * t * t * t * t * t;\n    float s7 = s * s * s * s * s * s * s;\n    float t7 = t * t * t * t * t * t * t;\n    float s8 = s * s * s * s * s * s * s * s;\n    float t8 = t * t * t * t * t * t * t * t;\n    float s9 = s * s * s * s * s * s * s * s * s;\n    float t9 = t * t * t * t * t * t * t * t * t;\n    float s10 = s * s * s * s * s * s * s * s * s * s;\n    float t10 = t * t * t * t * t * t * t * t * t * t;\n    float s11 = s * s * s * s * s * s * s * s * s * s * s;\n    float t11 = t * t * t * t * t * t * t * t * t * t * t;\n    float s12 = s * s * s * s * s * s * s * s * s * s * s * s;\n    float t12 = t * t * t * t * t * t * t * t * t * t * t * t;\n    float s13 = s * s * s * s * s * s * s * s * s * s *", "\n  vec3 q = p - vec3(0.0, 0.0, 0.0);\n  float a = length(q);\n  float b = length(q - vec3(1.0, 0.0, 0.0));\n  float c = length(q - vec3(0.0, 1.0, 0.0));\n  float d = length(q - vec3(0.0, 0.0, 1.0));\n  float e = length(q - vec3(1.0, 0.0, 1.0));\n  float f = length(q - vec3(1.0, 1.0, 0.0));\n  float g = length(q - vec3(0.0, 1.0, 1.0));\n  float h = length(q - vec3(1.0, 1.0, 1.0));\n  float i = length(q - vec3(0.0, 0.0, 0.0));\n  float j = length(q - vec3(0.0, 0.0, 1.0));\n  float k = length(q - vec3(1.0, 0.0, 0.0));\n  float l = length(q - vec3(0.0, 1.0, 0.0));\n  float m = length(q - vec3(0.0, 0.0, 1.0));\n  float n = length(q - vec3(1.0, 1.0, 0.0));\n  float o = length(q - vec3(1.0, 0.0, 1.0));\n  float p = length(q - vec3(0.0, 1.0, 1.0));\n  float q = length(q - vec3(1.0, 1.0, 1.0));\n  float r = length(q - vec3(0.0, 0.0, 0.0));\n  float s = length(q - vec3(0.0, 0.0, 1.0));\n  float t = length(q - vec", "\n    vec3 c;\n    c.r = 1.0 - abs(fract(t * 6.0 - 3.0) - 1.0);\n    c.g = 1.0 - abs(fract(t * 6.0 - 2.0) - 1.0);\n    c.b = 1.0 - abs(fract(t * 6.0 - 1.0) - 1.0);\n    return c;\n}<|file_separator|>", "\n    return normalize(cross(v, cross(v, a) + a));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, float t)\n{\n    return normalize(cross(v, cross(v, a) + a) * cos(t) + v * sin(t));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, float t, float s)\n{\n    return normalize(cross(v, cross(v, a) + a) * cos(t) + v * sin(t) * s);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, float t, float s, float r)\n{\n    return normalize(cross(v, cross(v, a) + a) * cos(t) + v * sin(t) * s + a * r);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, float t, float s, float r, float p)\n{\n    return normalize(cross(v, cross(v, a) + a) * cos(t) + v * sin(t) * s + a * r + cross(v, cross(v, a) + a) * p);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, float t, float s, float r, float p, float q)\n{\n    return normalize(cross(v, cross(v, a) + a) * cos(t) + v * sin(t) * s + a * r + cross(v, cross(v, a) + a) * p + cross(v, cross(v, a) + a) * q);\n}\n\n// rotates a vetor", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.0))) * 43758.5453);\n}\n\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.989", "\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n", "\n    vec2 uv = fract(uv * 100.0);\n    vec2 p = floor(uv * 100.0);\n    vec2 f = fract(uv * 100.0);\n    vec2 q = floor(f * 100.0);\n    vec2 r = fract(f * 100.0);\n    vec2 s = floor(r * 100.0);\n    vec2 t = fract(r * 100.0);\n    vec2 u = floor(t * 100.0);\n    vec2 v = fract(t * 100.0);\n    vec2 w = floor(v * 100.0);\n    vec2 x = fract(v * 100.0);\n    vec2 y = floor(x * 100.0);\n    vec2 z = fract(x * 100.0);\n    vec2 a = floor(z * 100.0);\n    vec2 b = fract(z * 100.0);\n    vec2 c = floor(b * 100.0);\n    vec2 d = fract(b * 100.0);\n    vec2 e = floor(d * 100.0);\n    vec2 f = fract(d * 100.0);\n    vec2 g = floor(f * 100.0);\n    vec2 h = fract(f * 100.0);\n    vec2 i = floor(h * 100.0);\n    vec2 j = fract(h * 100.0);\n    vec2 k = floor(j * 100.0);\n    vec2 l = fract(j * 100.0);\n    vec2 m = floor(l * 100.0);\n    vec2 n = fract(l * 100.0);\n    vec2 o = floor(n * 100.0);\n    vec2 p = fract(n * 100.0);\n    vec2 q = floor(p * 100.0);\n    ", "\n  vec3 c;\n  c.r = clamp(abs(fract(t * 6.0 - 3.0) * 6.0 - 3.0) - 1.0, 0.0, 1.0);\n  c.g = clamp(abs(fract(t * 6.0 - 2.0) * 6.0 - 2.0) - 1.0, 0.0, 1.0);\n  c.b = clamp(abs(fract(t * 6.0 - 1.0) * 6.0 - 1.0) - 1.0, 0.0, 1.0);\n  return c;\n}\n<|file_separator|>", "\n  return (x + 1.0) / 2.0;\n}\n<|file_separator|>", "\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float z = time * 0.001;\n  float a = atan(y, x);\n  float b = length(vec2(x, y));\n  float c = a * 0.5;\n  float d = b * 0.5;\n  float e = sin(c + z);\n  float f = sin(d + z);\n  float g = e * f;\n  float h = g * len;\n  return h;\n}\n\nfloat flowHexCell2(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float z = time * 0.001;\n  float a = atan(y, x);\n  float b = length(vec2(x, y));\n  float c = a * 0.5;\n  float d = b * 0.5;\n  float e = sin(c + z);\n  float f = sin(d + z);\n  float g = e * f;\n  float h = g * len;\n  return h;\n}\n\nfloat flowHexCell3(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float z = time * 0.001;\n  float a = atan(y, x);\n  float b = length(vec2(x, y));\n  float c = a * 0.5;\n  float d = b * 0.5;\n  float e = sin(c + z);\n  float f = sin(d + z);\n  float g = e * f;\n  float h = g * len;\n  return h;\n}\n\nfloat flowHexCell4(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float z = time * ", "\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float z = time * 0.001;\n  float s = sin(x + y + z);\n  float c = cos(x + y + z);\n  float t = s * c;\n  return t * len;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec2 uv2 = uv;\n  uv2.x += triDirectionalFlow(uv2, 100.0, time, 0.01);\n  vec2 uv3 = uv;\n  uv3.y += triDirectionalFlow(uv3, 100.0, time, 0.01);\n  vec2 uv4 = uv;\n  uv4.x += triDirectionalFlow(uv4, 100.0, time, 0.01);\n  vec2 uv5 = uv;\n  uv5.y += triDirectionalFlow(uv5, 100.0, time, 0.01);\n  vec2 uv6 = uv;\n  uv6.x += triDirectionalFlow(uv6, 100.0, time, 0.01);\n  vec2 uv7 = uv;\n  uv7.y += triDirectionalFlow(uv7, 100.0, time, 0.01);\n  vec2 uv8 = uv;\n  uv8.x += triDirectionalFlow(uv8, 100.0, time, 0.01);\n  vec2 uv9 = uv;\n  uv9.y += triDirectionalFlow(uv9, 100.0, time, 0.01);\n  vec2 uv10 = uv;\n  uv10.x += triDirectionalFlow(uv10, 100.0, time, 0.01);\n  vec2 uv11 = uv;\n  uv11.y += triDirectionalFlow(uv11, 100.0, time, 0.01);\n  vec2 uv12 = uv;\n  uv12.x += triDirectionalFlow(", "\n  vec2 flow = vec2(0.0);\n  vec2 pos = point;\n  float dist = 0.0;\n  float angle = 0.0;\n  float maxDist = 100.0;\n  float maxAngle = 1.0;\n  float maxDist2 = maxDist * maxDist;\n  float maxAngle2 = maxAngle * maxAngle;\n  float maxDist3 = maxDist2 * maxDist2;\n  float maxAngle3 = maxAngle2 * maxAngle2;\n  float maxDist4 = maxDist3 * maxDist3;\n  float maxAngle4 = maxAngle3 * maxAngle3;\n  float maxDist5 = maxDist4 * maxDist4;\n  float maxAngle5 = maxAngle4 * maxAngle4;\n  float maxDist6 = maxDist5 * maxDist5;\n  float maxAngle6 = maxAngle5 * maxAngle5;\n  float maxDist7 = maxDist6 * maxDist6;\n  float maxAngle7 = maxAngle6 * maxAngle6;\n  float maxDist8 = maxDist7 * maxDist7;\n  float maxAngle8 = maxAngle7 * maxAngle7;\n  float maxDist9 = maxDist8 * maxDist8;\n  float maxAngle9 = maxAngle8 * maxAngle8;\n  float maxDist10 = maxDist9 * maxDist9;\n  float maxAngle10 = maxAngle9 * maxAngle9;\n  float maxDist11 = maxDist10 * maxDist10;\n  float maxAngle11 = maxAngle10 * maxAngle10;\n  float maxDist12 = maxDist11 * maxDist11;\n  float maxAngle12 = maxAngle11 * maxAngle11;\n  float maxDist13 = maxDist12 * maxDist12;\n  float maxAngle13 = maxAngle12 * maxAngle12;\n  float maxDist14 = maxDist13 * maxDist13;\n  float maxAngle14 = maxAngle13 * maxAngle13;\n  float maxDist15 = maxDist14 * maxDist14;\n  float maxAngle15 = maxAngle14 * maxAngle14", "\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n    vec2 tilePos = pos / tileSize;\n    vec2 tileCenter = tilePos * tileSize + tileSize / 2.0;\n    return tileCenter;\n}\n\n//", "\n  vec2 v = p2 - p1;\n  vec2 w = p - p1;\n  return dot(v, w) / length(v);\n}\n\n// Computes the signed distance from a line segment to a point\nfloat lineSegment(vec2 p, vec2 p1, vec2 p2) {\n  return min(max(line(p, p1, p2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(max(line(p, l1, l2), 0.0), 1.0);\n}\n\n// Computes the signed distance from a line to a point\nfloat lineSegment(vec2 p, vec2 l1, vec2 l2) {\n  return min(", "\n  vec2 q = p - arrowTileCenterCoord(p);\n  float d = length(q);\n  float s = dot(q, v);\n  float t = dot(v, v);\n  float a = s / t;\n  if (a < 0.0 || a > 1.0) {\n    return d;\n  }\n  vec2 c = q - a * v;\n  return length(c);\n}\n<|file_separator|>", "\n  return (x + 1.0) / 2.0;\n}\n<|file_separator|>", "\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 + offset) * spread;\n    return p;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 + offset) * spread;\n    return p;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 + offset) * spread;\n    return p;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 + offset) * spread;\n    return p;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 + offset) * spread;\n    return p;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{\n    vec2 p = point;\n    p.x += sin(p.y * 0.1 + offset) * spread;\n    p.y += cos(p.x * 0.1 +", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.x,p.y)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n ) \n{\n    return dot(p,n);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r ) \n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-ba*h)-r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 a, in vec2 b, in float r ) \n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-ba*h)-r;\n}\n\nfloat sdCone( in vec2 p, in vec2 a, in vec2 b, in float r ) \n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-ba*h)-r;\n}\n\nfloat sdTorusKnot( in vec2 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.x,p.y)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat sdSphere( in vec3 p, in float r ) \n{\n", "\n    vec2 q = p - id;\n    vec2 r = vec2( 0.0, 0.0 );\n    float t = 0.0;\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float s = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float", "\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos(t);\n    float r = a * (s + c);\n    return r;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos(t);\n    float r = a * (s + c);\n    return r;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos(t);\n    float r = a * (s + c);\n    return r;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos(t);\n    float r = a * (s + c);\n    return r;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos(t);\n    float r = a * (s + c);\n    return r;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float d = length(p);\n    float t = time * sp;\n    float a = d / ra;\n    float s = sin(t);\n    float c = cos", "\n    return length(vec3(\n        abs(uvw.x - 0.5),\n        abs(uvw.y - 0.5),\n        abs(uvw.z - 0.5)\n    ));\n}\n<|file_separator|>", "\n    vec3 p = uvw * 2.0 - 1.0;\n    vec3 q = p.xyz * vec3(1.0, -1.0, -1.0);\n    vec3 r = abs(q) - 1.0;\n    vec3 s = sign(q);\n    vec3 t = s * min(r.x, min(r.y, r.z));\n    vec3 v = r - t;\n    return vec4(s * (vec3(t.x, t.y, t.z) + 0.6) + vec3(v.x, v.y, v.z) * 0.6, 1.0);\n}\n<|file_separator|>", "\n    vec3 cell = floor(uvw * gridRes);\n    vec3 cellOffset = uvw * gridRes - cell;\n    vec3 cellOffset2 = cellOffset * 2.0;\n    vec3 cellOffset3 = cellOffset2 * 2.0;\n    vec3 cellOffset4 = cellOffset3 * 2.0;\n    vec3 cellOffset5 = cellOffset4 * 2.0;\n    vec3 cellOffset6 = cellOffset5 * 2.0;\n    vec3 cellOffset7 = cellOffset6 * 2.0;\n    vec3 cellOffset8 = cellOffset7 * 2.0;\n    vec3 cellOffset9 = cellOffset8 * 2.0;\n    vec3 cellOffset10 = cellOffset9 * 2.0;\n    vec3 cellOffset11 = cellOffset10 * 2.0;\n    vec3 cellOffset12 = cellOffset11 * 2.0;\n    vec3 cellOffset13 = cellOffset12 * 2.0;\n    vec3 cellOffset14 = cellOffset13 * 2.0;\n    vec3 cellOffset15 = cellOffset14 * 2.0;\n    vec3 cellOffset16 = cellOffset15 * 2.0;\n    vec3 cellOffset17 = cellOffset16 * 2.0;\n    vec3 cellOffset18 = cellOffset17 * 2.0;\n    vec3 cellOffset19 = cellOffset18 * 2.0;\n    vec3 cellOffset20 = cellOffset19 * 2.0;\n    vec3 cellOffset21 = cellOffset20 * 2.0;\n    vec3 cellOffset22 = cellOffset21 * 2.0;\n    vec3 cellOffset23 = cellOffset22 * 2.0;\n    vec3 cellOffset24 = cellOffset23 * 2.0;\n    vec3 cellOffset25 = cellOffset24 * 2.0;\n    vec3 cellOffset26 = cellOffset25 * 2.0;\n    vec3 cellOffset27 = cellOffset26 * 2.0;\n    vec3 cellOffset28", "\n  vec3 a = vec3(0.0, 0.0, 1.0);\n  vec3 b = vec3(1.0, 0.0, 0.0);\n  vec3 c = vec3(1.0, 1.0, 0.0);\n  vec3 d = vec3(0.0, 1.0, 0.0);\n  vec3 e = vec3(0.0, 1.0, 1.0);\n  vec3 f = vec3(0.0, 0.0, 0.0);\n  vec3 g = vec3(1.0, 1.0, 1.0);\n  vec3 h = vec3(0.0, 0.0, 1.0);\n  vec3 i = vec3(1.0, 0.0, 1.0);\n  vec3 j = vec3(1.0, 1.0, 1.0);\n  vec3 k = vec3(0.0, 1.0, 1.0);\n  vec3 l = vec3(1.0, 0.0, 0.0);\n  vec3 m = vec3(1.0, 1.0, 0.0);\n  vec3 n = vec3(0.0, 1.0, 0.0);\n  vec3 o = vec3(0.0, 1.0, 1.0);\n  vec3 p = vec3(0.0, 0.0, 0.0);\n  vec3 q = vec3(1.0, 1.0, 1.0);\n  vec3 r = vec3(0.0, 0.0, 1.0);\n  vec3 s = vec3(1.0, 0.0, 1.0);\n  vec3 t = vec3(1.0, 1.0, 1.0);\n  vec3 u = vec3(0.0, 1.0, 1.0);\n  vec3 v = vec3(1.0, 0.0, 0.0);\n  vec3 w =", "\n  vec3 q = p;\n  vec3 r = p;\n  vec3 s = p;\n  vec3 t = p;\n  vec3 u = p;\n  vec3 v = p;\n  vec3 w = p;\n  vec3 x = p;\n  vec3 y = p;\n  vec3 z = p;\n  vec3 a = p;\n  vec3 b = p;\n  vec3 c = p;\n  vec3 d = p;\n  vec3 e = p;\n  vec3 f = p;\n  vec3 g = p;\n  vec3 h = p;\n  vec3 i = p;\n  vec3 j = p;\n  vec3 k = p;\n  vec3 l = p;\n  vec3 m = p;\n  vec3 n = p;\n  vec3 o = p;\n  vec3 p = p;\n  vec3 q = p;\n  vec3 r = p;\n  vec3 s = p;\n  vec3 t = p;\n  vec3 u = p;\n  vec3 v = p;\n  vec3 w = p;\n  vec3 x = p;\n  vec3 y = p;\n  vec3 z = p;\n  vec3 a = p;\n  vec3 b = p;\n  vec3 c = p;\n  vec3 d = p;\n  vec3 e = p;\n  vec3 f = p;\n  vec3 g = p;\n  vec3 h = p;\n  vec3 i = p;\n  vec3 j = p;\n  vec3 k = p;\n  vec3 l = p;\n  vec3 m = p;\n  vec3 n = p;\n  vec3 o = p;\n  vec3 p = p;\n  vec3 q = p;\n  vec3 r = p;\n  vec3 s = p;\n  vec3 t = p;\n  vec3 u = p;\n  vec3 v = p;\n  vec3 w = p;\n  vec3 x = p;\n  vec3 y = p;\n  vec3 z = p;\n  vec3 a = p;\n  vec3 b = p;", "\n    vec3 c;\n    c.r = 1.0;\n    c.g = 1.0;\n    c.b = 1.0;\n    return c;\n}\n<|file_separator|>// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    vec3 c;\n    c.r = 1.0;\n    c.g = 1.0;\n    c.b = 1.0;\n    return c;\n}\n<|file_separator|>", "\n    vec2 uv0 = uv * 2.0 - 1.0;\n    vec2 uv1 = uv * 2.0 - 1.0;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 uv3 = uv * 2.0 - 1.0;\n    vec2 uv4 = uv * 2.0 - 1.0;\n    vec2 uv5 = uv * 2.0 - 1.0;\n    vec2 uv6 = uv * 2.0 - 1.0;\n    vec2 uv7 = uv * 2.0 - 1.0;\n    vec2 uv8 = uv * 2.0 - 1.0;\n    vec2 uv9 = uv * 2.0 - 1.0;\n    vec2 uv10 = uv * 2.0 - 1.0;\n    vec2 uv11 = uv * 2.0 - 1.0;\n    vec2 uv12 = uv * 2.0 - 1.0;\n    vec2 uv13 = uv * 2.0 - 1.0;\n    vec2 uv14 = uv * 2.0 - 1.0;\n    vec2 uv15 = uv * 2.0 - 1.0;\n    vec2 uv16 = uv * 2.0 - 1.0;\n    vec2 uv17 = uv * 2.0 - 1.0;\n    vec2 uv18 = uv * 2.0 - 1.0;\n    vec2 uv19 = uv * 2.0 - 1.0;\n    vec2 uv20 = uv * 2.0 - 1.0;\n    vec2 uv21 = uv * 2.0 - 1.0;\n    vec2 uv22 = uv * 2.0 - 1.0;\n    vec2 uv23 = uv * 2.0 - 1.0;\n    vec2 uv24 = uv * 2.0 - 1.0;\n    vec2 uv25 = uv * 2.0 - 1.0;\n    ", "\n  vec2 p = uv * 2.0 - 1.0;\n  float a = abs(p.x) + abs(p.y);\n  float b = abs(p.x) - abs(p.y);\n  float c = abs(p.x) + abs(p.y) - 1.0;\n  float d = abs(p.x) - abs(p.y) - 1.0;\n  float e = abs(p.x) + abs(p.y) - 2.0;\n  float f = abs(p.x) - abs(p.y) + 2.0;\n  float g = abs(p.x) + abs(p.y) - 3.0;\n  float h = abs(p.x) - abs(p.y) + 3.0;\n  float i = abs(p.x) + abs(p.y) - 4.0;\n  float j = abs(p.x) - abs(p.y) + 4.0;\n  float k = abs(p.x) + abs(p.y) - 5.0;\n  float l = abs(p.x) - abs(p.y) + 5.0;\n  float m = abs(p.x) + abs(p.y) - 6.0;\n  float n = abs(p.x) - abs(p.y) + 6.0;\n  float o = abs(p.x) + abs(p.y) - 7.0;\n  float p = abs(p.x) - abs(p.y) + 7.0;\n  float q = abs(p.x) + abs(p.y) - 8.0;\n  float r = abs(p.x) - abs(p.y) + 8.0;\n  float s = abs(p.x) + abs(p.y) - 9.0;\n  float t = abs(p.x) - abs(p.y) + 9.0;\n  float u = abs(p.x) + abs(p.y) - 10.0;\n", "\n    vec2 uv0 = floor(uv * gridRes);\n    vec2 uv1 = floor(uv * gridRes + vec2(1.0, 0.0));\n    vec2 uv2 = floor(uv * gridRes + vec2(0.0, 1.0));\n    vec2 uv3 = floor(uv * gridRes + vec2(1.0, 1.0));\n\n    vec2 uv01 = fract(uv0 + offset);\n    vec2 uv10 = fract(uv1 + offset);\n    vec2 uv20 = fract(uv2 + offset);\n    vec2 uv30 = fract(uv3 + offset);\n\n    vec2 uv010 = mix(uv01, uv10, fract(uv0.x));\n    vec2 uv100 = mix(uv10, uv20, fract(uv1.x));\n    vec2 uv200 = mix(uv20, uv30, fract(uv2.x));\n    vec2 uv0100 = mix(uv010, uv100, fract(uv01.x));\n    vec2 uv1000 = mix(uv100, uv200, fract(uv10.x));\n    vec2 uv01000 = mix(uv0100, uv1000, fract(uv010.x));\n\n    return mix(uv01000, uv0100, fract(uv0.y));\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec2 uv0 = floor(uv * gridRes);\n    vec2 uv1 = floor(uv * gridRes + vec2(1.0, 0.0));\n    vec2 uv2 = floor(uv * gridRes + vec2(0.0, 1.0));\n    vec2 uv3 = floor(uv * gridRes + vec2(1.0, 1.0));\n\n    vec2 uv01 = fract(uv0 + offset);\n    vec2 uv10 = fract(uv1 + offset);\n    vec2 uv20", "\n  vec2 uv0 = uv;\n  vec2 uv1 = uv + vec2(1.0, 0.0);\n  vec2 uv2 = uv + vec2(0.0, 1.0);\n  vec2 uv3 = uv + vec2(1.0, 1.0);\n  vec2 uv4 = uv + vec2(0.0, -1.0);\n  vec2 uv5 = uv + vec2(1.0, -1.0);\n  vec2 uv6 = uv + vec2(-1.0, 0.0);\n  vec2 uv7 = uv + vec2(-1.0, 1.0);\n  vec2 uv8 = uv + vec2(-1.0, -1.0);\n  vec2 uv9 = uv + vec2(0.0, -2.0);\n  vec2 uv10 = uv + vec2(1.0, -2.0);\n  vec2 uv11 = uv + vec2(-1.0, -2.0);\n  vec2 uv12 = uv + vec2(0.0, 2.0);\n  vec2 uv13 = uv + vec2(1.0, 2.0);\n  vec2 uv14 = uv + vec2(-1.0, 2.0);\n  vec2 uv15 = uv + vec2(0.0, 0.0);\n  vec2 uv16 = uv + vec2(0.0, 1.0);\n  vec2 uv17 = uv + vec2(0.0, -1.0);\n  vec2 uv18 = uv + vec2(0.0, 0.0);\n  vec2 uv19 = uv + vec2(0.0, 1.0);\n  vec2 uv20 = uv + vec2(0.0, -1.0);\n  vec2 uv21 = uv + vec2(0.0, 0.0);\n  vec2 uv22 = uv + vec2(0.0, 1.0);\n  vec2 uv23 = uv + vec2(0.0, -1.0);\n  vec2 uv2", "\n    vec2 uv0 = uv - offset;\n    vec2 uv1 = uv + offset;\n    vec2 uv2 = uv - offset * 2.0;\n    vec2 uv3 = uv + offset * 2.0;\n    vec2 uv4 = uv - offset * 3.0;\n    vec2 uv5 = uv + offset * 3.0;\n    vec2 uv6 = uv - offset * 4.0;\n    vec2 uv7 = uv + offset * 4.0;\n    vec2 uv8 = uv - offset * 5.0;\n    vec2 uv9 = uv + offset * 5.0;\n    vec2 uv10 = uv - offset * 6.0;\n    vec2 uv11 = uv + offset * 6.0;\n    vec2 uv12 = uv - offset * 7.0;\n    vec2 uv13 = uv + offset * 7.0;\n    vec2 uv14 = uv - offset * 8.0;\n    vec2 uv15 = uv + offset * 8.0;\n    vec2 uv16 = uv - offset * 9.0;\n    vec2 uv17 = uv + offset * 9.0;\n    vec2 uv18 = uv - offset * 10.0;\n    vec2 uv19 = uv + offset * 10.0;\n    vec2 uv20 = uv - offset * 11.0;\n    vec2 uv21 = uv + offset * 11.0;\n    vec2 uv22 = uv - offset * 12.0;\n    vec2 uv23 = uv + offset * 12.0;\n    vec2 uv24 = uv - offset * 13.0;\n    vec2 uv25 = uv + offset * 13.0;\n    vec2 uv26 = uv - offset * 14.0;\n    vec2 uv27 = uv + offset * 14.0;\n    vec2 uv28 = uv - offset * 15.0;\n    vec2 uv29 = uv + offset * 15.0;\n    vec2 uv30 = uv -", "\n  float x = uv.x * gridRes;\n  float y = uv.y * gridRes;\n  float t = time * 0.001;\n  float a = 1.0;\n  float b = 1.0;\n  float c = 1.0;\n  float d = 1.0;\n  float e = 1.0;\n  float f = 1.0;\n  float g = 1.0;\n  float h = 1.0;\n  float i = 1.0;\n  float j = 1.0;\n  float k = 1.0;\n  float l = 1.0;\n  float m = 1.0;\n  float n = 1.0;\n  float o = 1.0;\n  float p = 1.0;\n  float q = 1.0;\n  float r = 1.0;\n  float s = 1.0;\n  float t = 1.0;\n  float u = 1.0;\n  float v = 1.0;\n  float w = 1.0;\n  float x = 1.0;\n  float y = 1.0;\n  float z = 1.0;\n  float a = 1.0;\n  float b = 1.0;\n  float c = 1.0;\n  float d = 1.0;\n  float e = 1.0;\n  float f = 1.0;\n  float g = 1.0;\n  float h = 1.0;\n  float i = 1.0;\n  float j = 1.0;\n  float k = 1.0;\n  float l = 1.0;\n  float m = 1.0;\n  float n = 1.0;\n  float o = 1.0;\n  float p = 1.0;\n  float q = 1.0;\n  float r = 1.0;\n  float s = 1.0;\n  float t = 1.0;\n  float u = 1.0;\n  float v", "\n    vec2 q = floor( p );\n    vec2 r = fract( p );\n    vec2 s = r * r * ( 3.0 - 2.0 * r );\n    return mix( mix( mix( texture2D( gridTex, q + ddx * s ).x,\n                          texture2D( gridTex, q + ddy * s ).x,\n                          s.x ),\n                     mix( texture2D( gridTex, q + ddx * ( s.y + 1.0 ) ).x,\n                          texture2D( gridTex, q + ddy * ( s.y + 1.0 ) ).x,\n                          s.x ),\n                     s.y ),\n                mix( mix( texture2D( gridTex, q + ddx * ( s.y + 1.0 ) ).x,\n                          texture2D( gridTex, q + ddy * ( s.y + 1.0 ) ).x,\n                          s.x ),\n                     mix( texture2D( gridTex, q + ddx * s ).x,\n                          texture2D( gridTex, q + ddy * s ).x,\n                          s.x ),\n                     s.y ),\n                s.y );\n}\n\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 q = floor( p );\n    vec2 r = fract( p );\n    vec2 s = r * r * ( 3.0 - 2.0 * r );\n    return mix( mix( mix( texture2D( gridTex, q + ddx * s ).x,\n                          texture2D( gridTex, q + ddy * s ).x,\n                          s.x ),\n                     mix( texture2D( gridTex, q + ddx * ( s.y + 1.0 ) ).x,\n                          texture2D( gridTex, q + ddy * ( s.y + 1.0 ) ).x,\n                          s.x ),\n                     s.y ),\n                mix( mix( texture2D( gridTex, q + ddx * ( s.y + 1.0 ) ).x,\n                          texture2D( gridTex, q + ddy *", "\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r;\n}\n\nfloat hexagon(vec2 p, float r, float a) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r - a;\n}\n\nfloat hexagon(vec2 p, float r, float a, float b) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r - a - b;\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r - a - b - c;\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r - a - b - c - d;\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d, float e) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(PI * 3.0 / 2.0)) / r - a - b - c - d - e;\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d, float e, float f) {\n    return 1.0 - abs(p.x * cos(PI * 3.0 / 2.0) + p.y * sin(", "\n    vec2 q = vec2(p.x * 1.5, p.y);\n    p.x = floor(q.x);\n    p.y = floor(q.y);\n    q.x -= p.y;\n    q.y -= p.x;\n    return q;\n}\n\nvec2 hextile_to_world(inout vec2 p) {\n    vec2 q = vec2(p.x * 1.5, p.y);\n    p.x = q.x + q.y;\n    p.y = q.y - q.x;\n    return p;\n}\n\nvec2 world_to_hextile(inout vec2 p) {\n    vec2 q = vec2(p.x - p.y, p.y + p.x);\n    p.x = q.x * 0.5;\n    p.y = q.y * 0.5;\n    return p;\n}\n\nvec2 hextile_to_pixel(inout vec2 p) {\n    vec2 q = vec2(p.x * 1.5, p.y);\n    p.x = q.x + q.y;\n    p.y = q.y - q.x;\n    return p;\n}\n\nvec2 pixel_to_hextile(inout vec2 p) {\n    vec2 q = vec2(p.x - p.y, p.y + p.x);\n    p.x = q.x * 0.5;\n    p.y = q.y * 0.5;\n    return p;\n}\n\nvec2 hextile_to_screen(inout vec2 p) {\n    vec2 q = vec2(p.x * 1.5, p.y);\n    p.x = q.x + q.y;\n    p.y = q.y - q.x;\n    return p;\n}\n\nvec2 screen_to_hextile(inout vec2 p) {\n    vec2 q = vec2(p.x - p.y, p.y + p.x);\n    p.x = q.x * 0.5;\n    p.y = q.", "\n    return 0.5 * ( 1.0 + sin( x * 3.1415926535897932384626433832795 ) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fun( i );\n    \n    return mix( mix( dot( f, f ), dot( f - vec2( 1.0 ), f ), u.x ),\n                mix( dot( f, f - vec2( 1.0 ) ), dot( f - vec2( 1.0 ), f - vec2( 1.0 ) ), u.x ), u.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    \n    vec3 u = fun( i );\n    \n    return mix( mix( dot( f, f ), dot( f - vec3( 1.0 ), f ), u.x ),\n                mix( dot( f, f - vec3( 1.0 ) ), dot( f - vec3( 1.0 ), f - vec3( 1.0 ) ), u.x ), u.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    \n    vec3 u = fun( i );\n    \n    return mix( mix( dot( f, f ), dot( f - vec3( 1.0 ), f ), u.x ),\n                mix( dot( f, f - vec3( 1.0 ) ), dot( f - vec3( 1.0 ), f - vec3( 1.0 ) ), u.x ), u.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    \n    vec3 u = fun( i );\n    \n    return mix( mix( dot( f, f ), dot( f - vec3( 1.0 ), f ),", "\n    return pow(t, vec3(2.2));\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return pow(t, vec3(gamma));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2) {\n    return pow(t, vec3(gamma, gamma2));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3) {\n    return pow(t, vec3(gamma, gamma2, gamma3));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4, float gamma5) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4, gamma5));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4, float gamma5, float gamma6) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4, float gamma5, float gamma6, float gamma7) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6, gamma7));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4, float gamma5, float gamma6, float gamma7, float gamma8) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6, gamma7, gamma8));\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2, float gamma3, float gamma4, float gamma5, float gamma6, float gamma7, float gamma8, float gamma9) {\n    return pow(t, vec3(gamma, gamma2, gamma3, gamma4, gamma5, gamma6, gamma7,", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df1(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df2(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df3(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df4(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df5(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df6(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df7(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df8(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df9(vec2 p) {\n    return fract(sin(dot(p, vec2(12.", "\n    return 1.0;\n}\n\nfloat df2(vec2 p) {\n    return 1.0;\n}\n\nfloat df3(vec2 p) {\n    return 1.0;\n}\n\nfloat df4(vec2 p) {\n    return 1.0;\n}\n\nfloat df5(vec2 p) {\n    return 1.0;\n}\n\nfloat df6(vec2 p) {\n    return 1.0;\n}\n\nfloat df7(vec2 p) {\n    return 1.0;\n}\n\nfloat df8(vec2 p) {\n    return 1.0;\n}\n\nfloat df9(vec2 p) {\n    return 1.0;\n}\n\nfloat df10(vec2 p) {\n    return 1.0;\n}\n\nfloat df11(vec2 p) {\n    return 1.0;\n}\n\nfloat df12(vec2 p) {\n    return 1.0;\n}\n\nfloat df13(vec2 p) {\n    return 1.0;\n}\n\nfloat df14(vec2 p) {\n    return 1.0;\n}\n\nfloat df15(vec2 p) {\n    return 1.0;\n}\n\nfloat df16(vec2 p) {\n    return 1.0;\n}\n\nfloat df17(vec2 p) {\n    return 1.0;\n}\n\nfloat df18(vec2 p) {\n    return 1.0;\n}\n\nfloat df19(vec2 p) {\n    return 1.0;\n}\n\nfloat df20(vec2 p) {\n    return 1.0;\n}\n\nfloat df21(vec2 p) {\n    return 1.0;\n}\n\nfloat df22(vec2 p) {\n    return 1.0;\n}\n\nfloat df23(vec2 p) {\n    return 1.0;\n}\n\nfloat df24(vec2 p) {\n    return 1.0;\n}\n\nfloat df25(vec2 p) {\n    return 1.0;\n}\n\nfloat df26(", "\n    vec2 e1 = p1 - p0;\n    vec2 e2 = p2 - p0;\n    vec2 n = cross( e2, e1 );\n    vec2 q = p - p0;\n    float a = dot( n, q );\n    float b = dot( n, e1 );\n    float c = dot( n, e2 );\n    float d = dot( e1, e1 );\n    float e = dot( e2, e2 );\n    float f = dot( e1, q );\n    float g = dot( e2, q );\n    float h = 1.0 / ( a * a + b * b );\n    float i = h * ( c * a + d * b );\n    float j = h * ( e * a + f * b );\n    float k = h * ( g * a + h * b );\n    float l = h * ( c * a + d * b );\n    float m = h * ( e * a + f * b );\n    float n1 = i * i + j * j + k * k;\n    float o = l * i + m * j + n * k;\n    float p1 = o * o;\n    float q1 = i * l + j * m + k * n;\n    float r = q1 * q1;\n    float s = p1 * q1;\n    float t = r * s;\n    float u = t * t;\n    float v = u * u;\n    float w = v * v;\n    float x = w * w;\n    float y = x * x;\n    float z = y * y;\n    float A = 1.0 / ( a * a + b * b + c * c );\n    float B = a * A;\n    float C = b * A;\n    float D = c * A;\n    float E = 1.0 / ( d * d + e * e + f * f );\n    float F = d * E;\n    float G = e * E;\n    float H = f * E;\n    float I = 1.0 / ( g * g + h * h + i * i );\n    float J = g", "\n  vec3 ro2 = ro - sph.xyz;\n  float a = dot(ro2, ro2);\n  float b = dot(ro2, rd);\n  float c = dot(rd, rd);\n  float d = b*b - a*c;\n  if (d < 0.0) return dbuffer;\n  float e = sqrt(d);\n  float t = (-b - e) / a;\n  if (t < 0.0) t = (-b + e) / a;\n  if (t < 0.0) return dbuffer;\n  return t;\n}\n<|file_separator|>", "\n    return mod(p.x, w) - r;\n}\n\nfloat roundedY(vec2 p, float h, float r) {\n    return mod(p.y, h) - r;\n}\n\nfloat dist(vec2 p, vec2 q) {\n    return length(p - q);\n}\n\nfloat dist(vec2 p, vec2 q, float r) {\n    return length(p - q) - r;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s) {\n    return length(p - q) - r - s;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t) {\n    return length(p - q) - r - s - t;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u) {\n    return length(p - q) - r - s - t - u;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u, float v) {\n    return length(p - q) - r - s - t - u - v;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u, float v, float w) {\n    return length(p - q) - r - s - t - u - v - w;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u, float v, float w, float x) {\n    return length(p - q) - r - s - t - u - v - w - x;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u, float v, float w, float x, float y) {\n    return length(p - q) - r - s - t - u - v - w - x - y;\n}\n\nfloat dist(vec2 p, vec2 q, float r, float s, float t, float u, float v, float w, float x, float y, float z) {\n    return length(p - q) - r - s - t - u - v -", "\n    return 1.0 - 1.0 / ( 1.0 + k * dot( p, p ) );\n}\n<|file_separator|>// k in (0,1) range\nfloat sdHyperbolic( in vec2 p, float k )\n{\n    return 1.0 - 1.0 / ( 1.0 + k * dot( p, p ) );\n}\n<|file_separator|>// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, float k )\n{\n    return 1.0 - 1.0 / ( 1.0 + k * dot( p, p ) );\n}\n<|file_separator|>", "\n    return length( p - vec2( 0.0, 1.0 ) );\n}\n<|file_separator|>", "\n    return a < b? (a < k? a : k) : (b < k? b : k);\n}\n\nfloat pmax(float a, float b, float k) {\n    return a > b? (a > k? a : k) : (b > k? b : k);\n}\n\nfloat smin(float a, float b, float k) {\n    return pmin(a, b, k);\n}\n\nfloat smax(float a, float b, float k) {\n    return pmax(a, b, k);\n}\n\nfloat slerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat slerp(float a, float b, float t, float k) {\n    return slerp(a, b, t);\n}\n\nfloat slerp(float a, float b, float t, float k, float m) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n, float o) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n, float o, float p) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n, float o, float p, float q) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n, float o, float p, float q, float r) {\n    return slerp(a, b, t, k);\n}\n\nfloat slerp(float a, float b, float t, float k, float m, float n, float o, float p, float q, float r, float s) {\n    return slerp(a, b, t, k);\n}", "\n  return a * (1.0 - k * a);\n}\nfloat pabs(float a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(vec2 a, float k) {\n  return pabs(a.x, k) * pabs(a.y, k);\n}\nfloat pabs(vec2 a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(vec3 a, float k) {\n  return pabs(a.x, k) * pabs(a.y, k) * pabs(a.z, k);\n}\nfloat pabs(vec3 a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(vec4 a, float k) {\n  return pabs(a.x, k) * pabs(a.y, k) * pabs(a.z, k) * pabs(a.w, k);\n}\nfloat pabs(vec4 a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(mat2 a, float k) {\n  return pabs(a.xx, k) * pabs(a.xy, k) * pabs(a.yx, k) * pabs(a.yy, k);\n}\nfloat pabs(mat2 a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(mat3 a, float k) {\n  return pabs(a.xx, k) * pabs(a.xy, k) * pabs(a.xz, k) * pabs(a.yx, k) * pabs(a.yy, k) * pabs(a.yz, k) * pabs(a.zx, k) * pabs(a.zy, k) * pabs(a.zz, k);\n}\nfloat pabs(mat3 a) {\n  return pabs(a, 0.5);\n}\nfloat pabs(mat4 a, float k) {\n  return pabs(a.xx, k) * pabs(a.xy, k) * pabs(a.xz", "\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart2(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart3(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart4(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart5(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart6(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart7(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart8(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart9(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart10(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart11(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart12(vec2 p) {\n  return 10.0 * (1.0 - p.x * p.x) * p.y * p.y;\n}\n\nfloat heart", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(mix(i.x, i.y, f.x), i.x+1.0, f.y), i.y+1.0, f.x), i.x+1.0, f.y);\n}\n\nfloat hash12(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(mix(i.x, i.y, f.x), i.x+1.0, f.y), i.y+1.0, f.x), i.x+1.0, f.y);\n}\n\nfloat hash12(vec4 p) {\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(mix(i.x, i.y, f.x), i.x+1.0, f.y), i.y+1.0, f.x), i.x+1.0, f.y);\n}\n\nfloat hash12(vec2 p, float seed) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(mix(i.x, i.y, f.x), i.x+1.0, f.y), i.y+1.0, f.x), i.x+1.0, f.y);\n}\n\nfloat hash12(vec3 p, float seed) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(mix(i.x, i.y, f.x), i.x+1", "\n    vec2 AB = B - A;\n    vec2 BC = C - B;\n    vec2 CA = A - C;\n    vec2 AP = pos - A;\n    vec2 BP = pos - B;\n    vec2 CP = pos - C;\n    vec2 AB2 = AB * AB;\n    vec2 BC2 = BC * BC;\n    vec2 CA2 = CA * CA;\n    vec2 AP2 = AP * AP;\n    vec2 BP2 = BP * BP;\n    vec2 CP2 = CP * CP;\n    vec2 AB2P2 = AB2 + AP2;\n    vec2 BC2P2 = BC2 + BP2;\n    vec2 CA2P2 = CA2 + CP2;\n    vec2 AB2P2BC2P2 = AB2P2 + BC2P2;\n    vec2 AB2P2BC2P2CA2P2 = AB2P2BC2P2 + CA2P2;\n    vec2 AB2P2BC2P2CA2P2AB2P2 = AB2P2BC2P2CA2P2 + AB2P2;\n    vec2 AB2P2BC2P2CA2P2AB2P2BC2P2 = AB2P2BC2P2CA2P2AB2P2 + BC2P2;\n    vec2 AB2P2BC2P2CA2P2AB2P2BC2P2CA2P2 = AB2P2BC2P2CA2P2AB2P2BC2P2 + CA2P2;\n    vec2 AB2P2BC2P2CA2P2AB2P2BC2P2CA2P2AB2P2 = AB2P2BC2P2CA2P2AB2P2BC2P2CA2P2 + AB2P2;\n    vec2 AB2P2BC2P2CA2P2AB2P2BC2P2CA2P2AB2P2BC2P2 = AB2P2BC2P2CA2P2AB2P2BC2P2CA2P2AB2P2 + BC2P2;\n    vec2 AB2P2BC2P2", "\n    vec2 p = pos;\n    vec2 q = vec2( wi, he );\n    vec2 r = vec2( 0.0, 0.0 );\n    vec2 s = vec2( 0.0, 0.0 );\n    vec2 t = vec2( 0.0, 0.0 );\n    vec2 u = vec2( 0.0, 0.0 );\n    vec2 v = vec2( 0.0, 0.0 );\n    vec2 w = vec2( 0.0, 0.0 );\n    vec2 x = vec2( 0.0, 0.0 );\n    vec2 y = vec2( 0.0, 0.0 );\n    vec2 z = vec2( 0.0, 0.0 );\n    vec2 aa = vec2( 0.0, 0.0 );\n    vec2 ab = vec2( 0.0, 0.0 );\n    vec2 ac = vec2( 0.0, 0.0 );\n    vec2 ad = vec2( 0.0, 0.0 );\n    vec2 ae = vec2( 0.0, 0.0 );\n    vec2 af = vec2( 0.0, 0.0 );\n    vec2 ag = vec2( 0.0, 0.0 );\n    vec2 ah = vec2( 0.0, 0.0 );\n    vec2 ai = vec2( 0.0, 0.0 );\n    vec2 aj = vec2( 0.0, 0.0 );\n    vec2 ak = vec2( 0.0, 0.0 );\n    vec2 al = vec2( 0.0, 0.0 );\n    vec2 am = vec2( 0.0, 0.0 );\n    vec2 an = vec2( 0.0, 0.0 );\n    vec2 ao = vec2( 0.0, 0.0 );\n    vec2 ap = vec2( 0.0, 0.0 );\n    vec2 aq = vec2( 0.0, 0", "\n    vec2 p = pos;\n    vec2 q = vec2( 0.0, 1.0 );\n    vec2 r = vec2( 0.0, -1.0 );\n    vec2 s = vec2( 1.0, 0.0 );\n    vec2 t = vec2( -1.0, 0.0 );\n    vec2 u = vec2( 0.0, 0.0 );\n    vec2 v = vec2( 0.0, 0.0 );\n    vec2 w = vec2( 0.0, 0.0 );\n    vec2 x = vec2( 0.0, 0.0 );\n    vec2 y = vec2( 0.0, 0.0 );\n    vec2 z = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 xy = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( 0.0, 0.0 );\n    vec2 yz = vec2( ", "\n    vec2 q = p - vec2(ra,rb);\n    vec2 r = vec2(length(q.x),length(q.y));\n    vec2 s = vec2(ra,rb);\n    vec2 t = vec2(length(r.x),length(r.y));\n    vec2 u = vec2(length(s.x),length(s.y));\n    vec2 v = vec2(length(t.x),length(t.y));\n    vec2 w = vec2(length(u.x),length(u.y));\n    vec2 x = vec2(length(v.x),length(v.y));\n    vec2 y = vec2(length(w.x),length(w.y));\n    vec2 z = vec2(length(x.x),length(x.y));\n    vec2 A = vec2(length(y.x),length(y.y));\n    vec2 B = vec2(length(z.x),length(z.y));\n    vec2 C = vec2(length(A.x),length(A.y));\n    vec2 D = vec2(length(B.x),length(B.y));\n    vec2 E = vec2(length(C.x),length(C.y));\n    vec2 F = vec2(length(D.x),length(D.y));\n    vec2 G = vec2(length(E.x),length(E.y));\n    vec2 H = vec2(length(F.x),length(F.y));\n    vec2 I = vec2(length(G.x),length(G.y));\n    vec2 J = vec2(length(H.x),length(H.y));\n    vec2 K = vec2(length(I.x),length(I.y));\n    vec2 L = vec2(length(J.x),length(J.y));\n    vec2 M = vec2(length(K.x),length(K.y));\n    vec2 N = vec2(length(L.x),length(L.y));\n    vec2 O = vec2(length(M.x),length(M.y));\n", "\n    v = v * 0x5DEECE66DULL + 0xB;\n    v = v & 0xFFFFFFFFFFFFULL;\n    return ivec2(v);\n}\n\nivec2 Pcg2(ivec2 v, uint seed)\n{\n    v = v * 0x5DEECE66DULL + 0xB + seed;\n    v = v & 0xFFFFFFFFFFFFULL;\n    return ivec2(v);\n}\n\nivec2 Pcg2(ivec2 v, uint seed, uint seed2)\n{\n    v = v * 0x5DEECE66DULL + 0xB + seed;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0xB + seed2;\n    v = v & 0xFFFFFFFFFFFFULL;\n    return ivec2(v);\n}\n\nivec2 Pcg2(ivec2 v, uint seed, uint seed2, uint seed3)\n{\n    v = v * 0x5DEECE66DULL + 0xB + seed;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0xB + seed2;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0xB + seed3;\n    v = v & 0xFFFFFFFFFFFFULL;\n    return ivec2(v);\n}\n\nivec2 Pcg2(ivec2 v, uint seed, uint seed2, uint seed3, uint seed4)\n{\n    v = v * 0x5DEECE66DULL + 0xB + seed;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0xB + seed2;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0xB + seed3;\n    v = v & 0xFFFFFFFFFFFFULL;\n    v = v * 0x5DEECE66DULL + 0", "\n    v = v * 0x5DEECE66D + 0xB;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed)\n{\n    v = v * 0x5DEECE66D + 0xB + seed;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2, int seed3)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2 + seed3;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2, int seed3, int seed4)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2 + seed3 + seed4;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2, int seed3, int seed4, int seed5)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2 + seed3 + seed4 + seed5;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2, int seed3, int seed4, int seed5, int seed6)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2 + seed3 + seed4 + seed5 + seed6;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed, int seed2, int seed3, int seed4, int seed5, int seed6, int seed7)\n{\n    v = v * 0x5DEECE66D + 0xB + seed + seed2 + seed3 + seed4 + seed5 + seed6 + seed7;\n    return v;\n}\n\nivec3 Pcg3(ive", "\n  vec2 AB = B - A;\n  vec2 BC = C - B;\n  vec2 CA = A - C;\n  vec2 AP = pos - A;\n  vec2 BP = pos - B;\n  vec2 CP = pos - C;\n  float d1 = dot(AP, AB) * dot(AP, AB) - dot(AP, AB) * dot(AP, AB) * dot(AB, AB);\n  float d2 = dot(BP, BC) * dot(BP, BC) - dot(BP, BC) * dot(BP, BC) * dot(BC, BC);\n  float d3 = dot(CP, CA) * dot(CP, CA) - dot(CP, CA) * dot(CP, CA) * dot(CA, CA);\n  return min(min(d1, d2), d3);\n}\n<|file_separator|>// signed distance to a circle\nfloat sdCircle(in vec2 p, in float r) {\n  return length(p) - r;\n}\n<|file_separator|>// signed distance to a line\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n<|file_separator|>// signed distance to a plane\nfloat sdPlane(in vec2 p, in vec2 n, in float d) {\n  return length(p - n * d);\n}\n<|file_separator|>// signed distance to a sphere\nfloat sdSphere(in vec2 p, in float r) {\n  return length(p) - r;\n}\n<|file_separator|>// signed distance to a triangle\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n  vec2 ab = b - a;\n  vec2 ac = c - a;\n  vec2 ap = p - a;\n  vec2 bp = p - b;\n  vec2 cp = p - c;\n  float h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1", "\n    return (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) * winding_sign(p, b, c);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) * winding_sign(p, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) * winding_sign(p, d, e);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) * winding_sign(p, e, f);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b, c, d, e, f) * winding_sign(p, f, g);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h) {\n    return winding_sign(p, a, b, c, d, e, f, g) * winding_sign(p, g, h);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    \n    // x\n    if( rd.x > 0.0 )\n    {\n        vec3 p = ro + rd * s.x;\n        float t = ( p.x - s.x ) / rd.x;\n        vec3 q = ro + rd * t;\n        \n        if( q.y > s.y && q.y < s.y + s.z )\n        {\n            n = vec3( 1.0, 0.0, 0.0 );\n            d = t;\n        }\n    }\n    \n    // y\n    if( rd.y > 0.0 )\n    {\n        vec3 p = ro + rd * s.y;\n        float t = ( p.y - s.y ) / rd.y;\n        vec3 q = ro + rd * t;\n        \n        if( q.x > s.x && q.x < s.x + s.z )\n        {\n            n = vec3( 0.0, 1.0, 0.0 );\n            d = t;\n        }\n    }\n    \n    // z\n    if( rd.z > 0.0 )\n    {\n        vec3 p = ro + rd * s.z;\n        float t = ( p.z - s.z ) / rd.z;\n        vec3 q = ro + rd * t;\n        \n        if( q.x > s.x && q.x < s.x + s.y )\n        {\n            n = vec3( 0.0, 0.0, 1.0 );\n            d = t;\n        }\n    }\n    \n    return vec4( d, n.x, n.y, n.z );\n}\n<|file_separator|>", "\n  float a_f = a;\n  float b_f = b;\n  float x_f = x;\n  float a_f_abs = abs(a_f);\n  float b_f_abs = abs(b_f);\n  float a_f_abs_b_f_abs = a_f_abs * b_f_abs;\n  float a_f_abs_b_f_abs_1_24 = a_f_abs_b_f_abs * (1 << 24);\n  float a_f_abs_b_f_abs_1_24_floor = floor(a_f_abs_b_f_abs_1_24);\n  float a_f_abs_b_f_abs_1_24_frac = a_f_abs_b_f_abs_1_24 - a_f_abs_b_f_abs_1_24_floor;\n  float a_f_abs_b_f_abs_1_24_frac_mad = a_f_abs_b_f_abs_1_24_frac * b_f_abs;\n  float a_f_abs_b_f_abs_1_24_frac_mad_x = a_f_abs_b_f_abs_1_24_frac_mad + x_f;\n  float a_f_abs_b_f_abs_1_24_frac_mad_x_floor = floor(a_f_abs_b_f_abs_1_24_frac_mad_x);\n  float a_f_abs_b_f_abs_1_24_frac_mad_x_floor_frac = a_f_abs_b_f_abs_1_24_frac_mad_x_floor - a_f_abs_b_f_abs_1_24_frac_mad_x;\n  float a_f_abs_b_f_abs_1_24_frac_mad_x_floor_frac_mad = a_f_abs_b_f_abs_1_24_frac_mad_x_floor_frac *", "\n    vec3 c = a - b;\n    return clamp( c, -k, k );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.x, k.x );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.y, k.y );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.z, k.z );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.x, k.x );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.y, k.y );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.z, k.z );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.x, k.x );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.y, k.y );\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n    vec3 c = a - b;\n    return clamp( c, -k.z, k.z );\n}\n\nvec3 sdgSMin( in vec3", "\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    return dot(p,p) - dot(ab,ab);\n}\n\n//using the", "\n    float c = a + b;\n    float d = a - b;\n    float e = a * b;\n    float f = a / b;\n    float g = a % b;\n    float h = a ^ b;\n    float i = a | b;\n    float j = a & b;\n    float k = a << b;\n    float l = a >> b;\n    float m = a + b + c + d + e + f + g + h + i + j + k + l;\n    return m;\n}\n<|file_separator|>", "\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 q = p - ab;\n    float t = dot( q, q ) / dot( ab, ab );\n    return p + ab * t;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float ab2 = dot(ab, ab);\n    float ap2 = dot(ap, ap);\n    float abap = dot(ab, ap);\n    float t = abap / ab2;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float h )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h3*h;\n    float h5 = h4*h;\n    float h6 = h5*h;\n    float h7 = h6*h;\n    float h8 = h7*h;\n    float h9 = h8*h;\n    float h10 = h9*h;\n    float h11 = h10*h;\n    float h12 = h11*h;\n    float h13 = h12*h;\n    float h14 = h13*h;\n    float h15 = h14*h;\n    float h16 = h15*h;\n    float h17 = h16*h;\n    float h18 = h17*h;\n    float h19 = h18*h;\n    float h20 = h19*h;\n    float h21 = h20*h;\n    float h22 = h21*h;\n    float h23 = h22*h;\n    float h24 = h23*h;\n    float h25 = h24*h;\n    float h26 = h25*h;\n    float h27 = h26*h;\n    float h28 = h27*h;\n    float h29 = h28*h;\n    float h30 = h29*h;\n    float h31 = h30*h;\n    float h32 = h31*h;\n    float h33 = h32*h;\n    float h", "\n    return length(p - cen) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n )\n{\n    return dot(p,n);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h) - r;\n}\n\nfloat sdTorusKnot( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorusKnot2( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q", "\n    const float sampleStep = 0.0001;\n    const float sampleStep2 = sampleStep * sampleStep;\n    const float sampleStep4 = sampleStep2 * sampleStep2;\n    const float sampleStep8 = sampleStep4 * sampleStep4;\n    const float sampleStep16 = sampleStep8 * sampleStep8;\n    const float sampleStep32 = sampleStep16 * sampleStep16;\n    const float sampleStep64 = sampleStep32 * sampleStep32;\n    const float sampleStep128 = sampleStep64 * sampleStep64;\n    const float sampleStep256 = sampleStep128 * sampleStep128;\n    const float sampleStep512 = sampleStep256 * sampleStep256;\n    const float sampleStep1024 = sampleStep512 * sampleStep512;\n    const float sampleStep2048 = sampleStep1024 * sampleStep1024;\n    const float sampleStep4096 = sampleStep2048 * sampleStep2048;\n    const float sampleStep8192 = sampleStep4096 * sampleStep4096;\n    const float sampleStep16384 = sampleStep8192 * sampleStep8192;\n    const float sampleStep32768 = sampleStep16384 * sampleStep16384;\n    const float sampleStep65536 = sampleStep32768 * sampleStep32768;\n    const float sampleStep131072 = sampleStep65536 * sampleStep65536;\n    const float sampleStep262144 = sampleStep131072 * sampleStep131072;\n    const float sampleStep524288 = sampleStep262144 * sampleStep262144;\n    const float sampleStep1048576 = sampleStep524288 * sampleStep524288;\n    const float sampleStep2097152 = sampleStep1048576 * sampleStep104", "\n    float shadow = 0.0;\n    float shadowFactor = 1.0;\n    float shadowFactorMax = 1.0;\n    float shadowFactorMin = 0.0;\n    float shadowFactorStep = 0.01;\n    float shadowFactorStepMax = 1.0;\n    float shadowFactorStepMin = 0.0;\n    float shadowFactorStepCount = 10.0;\n    float shadowFactorStepCountMax = 10.0;\n    float shadowFactorStepCountMin = 1.0;\n    float shadowFactorStepCountStep = 1.0;\n    float shadowFactorStepCountStepMax = 1.0;\n    float shadowFactorStepCountStepMin = 1.0;\n    float shadowFactorStepCountStepCount = 10.0;\n    float shadowFactorStepCountStepCountMax = 10.0;\n    float shadowFactorStepCountStepCountMin = 1.0;\n    float shadowFactorStepCountStepCountStep = 1.0;\n    float shadowFactorStepCountStepCountStepMax = 1.0;\n    float shadowFactorStepCountStepCountStepMin = 1.0;\n    float shadowFactorStepCountStepCountStepCount = 10.0;\n    float shadowFactorStepCountStepCountStepCountMax = 10.0;\n    float shadowFactorStepCountStepCountStepCountMin = 1.0;\n    float shadowFactorStepCountStepCountStepCountStep = 1.0;\n    float shadowFactorStepCountStepCountStepCountMax = 1.0;\n    float shadowFactorStepCountStepCountStepCountMin = 1.0;\n    float shadowFactorStepCountStepCountStepCountStep = 1.0;\n    float shadowFactorStepCountStepCountStepCountMax = 1.0;\n    float shadowFactorStepCountStepCountStepCountMin = 1.0;\n    float shadowFactorStepCountStepCountStepCountStep = 1.0;\n    float shadowFactorStepCountStepCountStepCountMax = 1.0;\n    float shadowFactorStepCountStepCountStepCountMin = 1.0;\n    float shadowFactorStepCountStepCountStepCountStep = 1.0;\n    float shadowFactorStepCount", "\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;", "\n    vec3 q = p;\n    q.y = -q.y;\n    float d = length( q );\n    float t = acos( ( d*d + ra*ra - rb*rb ) / ( 2.0*d*ra ) );\n    float s = atan( q.y, q.x );\n    return vec4( t, s, d, 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    vec3 q = p;\n    q.y = -q.y;\n    float d = length( q );\n    float t = acos( ( d*d + ra*ra - rb*rb ) / ( 2.0*d*ra ) );\n    float s = atan( q.y, q.x );\n    return vec4( t, s, d, 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    vec3 q = p;\n    q.y = -q.y;\n    float d = length( q );\n    float t = acos( ( d*d + ra*ra - rb*rb ) / ( 2.0*d*ra ) );\n    float s = atan( q.y, q.x );\n    return vec4( t, s, d, 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    vec3 q = p;\n    q.y = -q.y;\n    float d = length( q );\n    float t = acos( ( d*d + ra*ra - rb*rb ) / ( 2.0*d*ra ) );\n    float s = atan( q.y, q.x );\n    return vec4( t, s, d, 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    return length( p - a - t * ab );\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float t )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    return length( p - a - t * ab ) * ( 1.0 - t2 ) + t3 * dot( ab, ab ) * t2;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float t2 )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t3 = t2 * t;\n    return length( p - a - t * ab ) * ( 1.0 - t2 ) + t3 * dot( ab, ab ) * t2;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float t2, in float t3 )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t4 = t2 * t2;\n    return length( p - a - t * ab ) * ( 1.0 - t2 ) + t3 * dot( ab, ab ) * t2 + t4 * dot( ab, ab ) * t2 * t;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float t, in float t2, in float t3, in float t4 )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t5 = t2 * t2 * t;\n    return length( p - a - t * ab ) * ( 1.0 - t2 ) + t3 * dot( ab, ab ) * t2 + t4 * dot( ab, ab ) * t2 * t + t5 *", "\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfloat capsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    float d = dot(pa, pb);\n    float c = dot(pa, pa) - d * d;\n    float s = dot(pb, pb) - d * d;\n    float t = (c * c - s * s + r * r) / (2.0 * d);\n    if (t < 0.0) {\n        return 0.0;\n    }\n    vec3 q = a + t * pb;\n    return dot(pa - q, pa - q) + dot(pb - q, pb - q);\n}\n\nfloat capsule2(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    float d = dot(pa, pb);\n    float c = dot(pa, pa) - d * d;\n    float s = dot(pb, pb) - d * d;\n    float t = (c * c - s * s + r * r) / (2.0 * d);\n    if (t < 0.0) {\n        return 0.0;\n    }\n    vec3 q = a + t * pb;\n    return dot(pa - q, pa - q) + dot(pb - q, pb - q);\n}\n\nfloat capsule3(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    float d = dot(pa, pb);\n    float c = dot(pa, pa) - d * d;\n    float s = dot(pb, pb) - d * d;\n    float t = (c * c - s * s + r * r) / (2.0 * d);\n    if (t < 0.0) {\n        return 0.0;", "\n    vec2 d = max(p - minCorner, maxCorner - p);\n    return d.x * d.x + d.y * d.y;\n}\n\n// Squared distance to a line segment\nfloat sqLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float h = clamp( dot(ap, ab) / dot(ab, ab), 0.0, 1.0 );\n    return sqAABB( p, a + ab * h, a + ab * h + ab );\n}\n\n// Squared distance to a line\nfloat sqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    return sqLineSegment( p, a, b );\n}\n\n// Squared distance to a circle\nfloat sqCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    return dot(d, d) - r * r;\n}\n\n// Squared distance to a box\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner )\n{\n    vec2 d = max(p - minCorner, maxCorner - p);\n    return d.x * d.x + d.y * d.y;\n}\n\n// Squared distance to a sphere\nfloat sqSphere( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = p - c;\n    return dot(d, d) - r * r;\n}\n\n// Squared distance to a plane\nfloat sqPlane( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 n = cross(ab, ac);\n    float d = dot(n, ap);\n    return d * d;\n}\n\n// Squared distance to a triangle\nfloat sqTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 ac =", "\n    vec2 uv2 = uv * 1.0;\n    vec3 c = vec3(0.0);\n    vec2 uv3 = uv2;\n    vec2 uv4 = uv2;\n    vec2 uv5 = uv2;\n    vec2 uv6 = uv2;\n    vec2 uv7 = uv2;\n    vec2 uv8 = uv2;\n    vec2 uv9 = uv2;\n    vec2 uv10 = uv2;\n    vec2 uv11 = uv2;\n    vec2 uv12 = uv2;\n    vec2 uv13 = uv2;\n    vec2 uv14 = uv2;\n    vec2 uv15 = uv2;\n    vec2 uv16 = uv2;\n    vec2 uv17 = uv2;\n    vec2 uv18 = uv2;\n    vec2 uv19 = uv2;\n    vec2 uv20 = uv2;\n    vec2 uv21 = uv2;\n    vec2 uv22 = uv2;\n    vec2 uv23 = uv2;\n    vec2 uv24 = uv2;\n    vec2 uv25 = uv2;\n    vec2 uv26 = uv2;\n    vec2 uv27 = uv2;\n    vec2 uv28 = uv2;\n    vec2 uv29 = uv2;\n    vec2 uv30 = uv2;\n    vec2 uv31 = uv2;\n    vec2 uv32 = uv2;\n    vec2 uv33 = uv2;\n    vec2 uv34 = uv2;\n    vec2 uv35 = uv2;\n    vec2 uv36 = uv2;\n    vec2 uv37 = uv2;\n    vec2 uv38 = uv2;\n    vec2 uv39 = uv2;\n    vec2 uv40 = uv2;\n    vec2 uv41 = uv2;\n    vec2 uv42 = uv2;\n    vec2 uv43 = uv2;\n    vec2 uv44 = uv2;\n    vec2 uv45 = uv2;\n    vec2 uv46 = uv2;\n    vec2 uv47 =", "\n    vec3 p = vec3(uv.x, uv.y, 1.0);\n    p = p * 2.0 - 1.0;\n    p.y = -p.y;\n    return p;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 p = vec3(uv.x, uv.y, 1.0);\n    p = p * 2.0 - 1.0;\n    p.y = -p.y;\n    return p;\n}<|file_separator|>", "\n    vec3 res;\n    res.x = q.x * v.x + q.y * v.y + q.z * v.z + q.w * v.w;\n    res.y = q.y * v.x - q.x * v.y + q.w * v.z - q.z * v.w;\n    res.z = q.z * v.x + q.w * v.y - q.x * v.z - q.y * v.w;\n    return res;\n}\n<|file_separator|>", "\n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.x,p.y)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot(p,n);\n}\n\nfloat sdOctahedron( in vec2 p, in float r )\n{\n    vec2 q = abs(p)-vec2(r);\n    return length(max(q,0.0))-r;\n}\n\nfloat sdIcosphere( in vec2 p, in float r )\n{\n    vec2 q = abs(p)-vec2(r);\n    return length(max(q,0.0))-r;\n}\n\nfloat sdTorusKnot( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.x,p.y)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat sdEllipsoid( in vec2 p, in vec2 e )\n{\n    vec2 q = abs(p)-e;\n    return length(max(q,0.0))-e.x;\n}\n\nfloat sdCapsule( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = abs(p)-c;\n    return length(max(q,vec2(0.0))) - min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = abs(p)-c;\n    return length(max(q,vec2(0", "\n    return length( p - a ) + length( p - b );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return length( max( d, 0.0 ) ) + min( max( d.x, d.y ), 0.0 );\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.x, p.y ) - t.x, p.z );\n    return length( q ) - t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot( p, n );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdCone( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdTorus( in vec2", "\n    return m + ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opDifference( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opSymmetricDifference( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opMinimum( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opMaximum( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opMidpoint( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0.5 ) );\n}\n\nvec2 opMidpointRound( vec2 m, float d, float a )\n{\n    return m - ( 1.0 - smoothstep( d, d + a, length( m ) ) ) * ( m - vec2( 0", "\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( ro, rd );\n    float c = dot( ro, ro ) - rad * rad;\n    float d = b * b - 4.0 * a * c;\n    if ( d < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    float t = (-b - sqrt( d )) / ( 2.0 * a );\n    vec2 p = ro + t * rd;\n    p1 = vec4( p, 1.0 );\n    p2 = vec4( p, 1.0 );\n}\n\nvoid intersectPlane( in vec2 ro, in vec2 rd, in vec2 n, out vec4 p1, out vec4 p2 )\n{\n    float d = dot( n, ro );\n    float t = -d / dot( n, rd );\n    vec2 p = ro + t * rd;\n    p1 = vec4( p, 1.0 );\n    p2 = vec4( p, 1.0 );\n}\n\nvoid intersectSphere( in vec2 ro, in vec2 rd, in vec2 c, float rad, out vec4 p1, out vec4 p2 )\n{\n    vec2 oc = ro - c;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float d = b * b - c;\n    if ( d < 0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n        return;\n    }\n    float t = -b - sqrt( d );\n    vec2 p = ro + t * rd;\n    p1 = vec4( p, 1.0 );\n    p2 = vec4( p, 1.0 );\n}\n\nvoid intersectCylinder( in vec2 ro, in vec2 rd, in vec2 c, float h, float r, out vec4 p1, out vec4 p2 )\n{\n    vec2 oc = ro -", "\n    return vec3( length(p - c) - r, 0.0, 0.0 );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t ) \n{\n    return vec3( length(p - c) - r, 0.0, t );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u ) \n{\n    return vec3( length(p - c) - r, t, u );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u, in float v ) \n{\n    return vec3( length(p - c) - r, t, u, v );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u, in float v, in float w ) \n{\n    return vec3( length(p - c) - r, t, u, v, w );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u, in float v, in float w, in float x ) \n{\n    return vec3( length(p - c) - r, t, u, v, w, x );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u, in float v, in float w, in float x, in float y ) \n{\n    return vec3( length(p - c) - r, t, u, v, w, x, y );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t, in float u, in float v, in float w, in float x, in float y, in float z ) \n{\n    return vec3( length(p - c) - r, t, u, v, w, x, y, z );\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r, in float t,", "\n    vec2 q = abs(p) - b;\n    return vec3(max(q.x, q.y), 1.0 - max(q.x, q.y));\n}\n\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    return vec3(length(p) - r, 1.0 - length(p) / r);\n}\n\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.y);\n    return vec3(length(q) - t.y, 1.0 - length(q) / t.y);\n}\n\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus2( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.y);\n    return vec3(length(q) - t.y, 1.0 - length(q) / t.y);\n}\n\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus3( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.y);\n    return vec3(length(q) - t.y, 1.0 - length(q) / t.y);\n}\n\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus4( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.y", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = q * vec2(1.0, 0.5) - q * q;\n    return vec3(r.x, r.y, 1.0 - r.x * r.x - r.y * r.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart( in vec2 p )\n{\n    vec2 q = p - vec2(0.5);\n    vec2 r = q * vec2(1.0, 0.5) - q * q;\n    return vec3(r.x, r.y, 1.0 - r.x * r.x - r.y * r.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart( in vec2 p )\n{\n    vec2 q = p - vec2(0.5);\n    vec2 r = q * vec2(1.0, 0.5) - q * q;\n    return vec3(r.x, r.y, 1.0 - r.x * r.x - r.y * r.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart( in vec2 p )\n{\n    vec2 q = p - vec2(0.5);\n    vec2 r = q * vec2(1.0, 0.5) - q * q;\n    return vec3(r.x, r.y, 1.0 - r.x * r.", "\n  return a1 * x + b1 + a2 * x * x + b2;\n}\n\nfloat a1 = 1.0;\nfloat b1 = 0.0;\nfloat a2 = 1.0;\nfloat b2 = 0.0;\nfloat x = 0.0;\nfloat y = 0.0;\nfloat x1 = 0.0;\nfloat y1 = 0.0;\nfloat x2 = 0.0;\nfloat y2 = 0.0;\nfloat x3 = 0.0;\nfloat y3 = 0.0;\nfloat x4 = 0.0;\nfloat y4 = 0.0;\nfloat x5 = 0.0;\nfloat y5 = 0.0;\nfloat x6 = 0.0;\nfloat y6 = 0.0;\nfloat x7 = 0.0;\nfloat y7 = 0.0;\nfloat x8 = 0.0;\nfloat y8 = 0.0;\nfloat x9 = 0.0;\nfloat y9 = 0.0;\nfloat x10 = 0.0;\nfloat y10 = 0.0;\nfloat x11 = 0.0;\nfloat y11 = 0.0;\nfloat x12 = 0.0;\nfloat y12 = 0.0;\nfloat x13 = 0.0;\nfloat y13 = 0.0;\nfloat x14 = 0.0;\nfloat y14 = 0.0;\nfloat x15 = 0.0;\nfloat y15 = 0.0;\nfloat x16 = 0.0;\nfloat y16 = 0.0;\nfloat x17 = 0.0;\nfloat y17 = 0.0;\nfloat x18 = 0.0;\nfloat y18 = 0.0;\nfloat x19 = 0.0;\nfloat y19 = 0.0;\nfloat x20 = 0.0;\nfloat y20 = 0.0;\nfloat x21 = 0.", "\n  return a * (1 + b * sin(n * x));\n}\n\nvoid setup() {\n  size(1000, 1000);\n  background(0);\n  stroke(255);\n  strokeWeight(1);\n  noFill();\n}\n\nvoid draw() {\n  translate(width / 2, height / 2);\n  for (float x = -width / 2; x < width / 2; x += 0.01) {\n    float y = h(1, 1, 1, x);\n    line(x, y, x + 0.01, h(1, 1, 1, x + 0.01));\n  }\n}\n<|file_separator|>// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n  return a * (1 + b * sin(n * x));\n}\n\nvoid setup() {\n  size(1000, 1000);\n  background(0);\n  stroke(255);\n  strokeWeight(1);\n  noFill();\n}\n\nvoid draw() {\n  translate(width / 2, height / 2);\n  for (float x = -width / 2; x < width / 2; x += 0.01) {\n    float y = h(1, 1, 1, x);\n    line(x, y, x + 0.01, h(1, 1, 1, x + 0.01));\n  }\n}\n<|file_separator|>// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float", "\n                float noise = 0.0;\n                float scale = 1.0;\n                float freq = 1.0;\n                for (int i = 0; i < 4; i++) {\n                    noise += abs(noise3(uv * freq, 1.0)) * scale;\n                    scale *= 0.5;\n                    freq *= 2.0;\n                }\n                return noise;\n            }\n            \n            void mainImage( out vec4 fragColor, in vec2 fragCoord )\n            {\n                vec2 uv = fragCoord.xy / iResolution.xy;\n                uv.x *= iResolution.x / iResolution.y;\n                \n                vec2 uv2 = uv;\n                uv2.x += paperNoise(uv2);\n                uv2.y += paperNoise(uv2);\n                \n                vec3 col = vec3(0.0);\n                \n                col += texture2D(iChannel0, uv).rgb * 0.2;\n                col += texture2D(iChannel1, uv2).rgb * 0.2;\n                \n                col = pow(col, vec3(1.0 / 2.2));\n                \n                fragColor = vec4(col, 1.0);\n            }<|file_separator|>", "\n    vec3 color = vec3( 0.0 );\n    vec2 uv = vec2( x, y ) / vec2( width, height );\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length( p );\n    if ( d < 1.0 )\n    {\n        float t = atan( p.y, p.x ) / 3.14159265359;\n        float s = sin( t );\n        float c = cos( t );\n        float a = atan( s, c );\n        float b = atan( p.y, p.x );\n        float r = length( p );\n        float g = sin( a ) * cos( b );\n        float b = sin( a ) * sin( b );\n        float a = cos( a );\n        float r = r * 0.5 + 0.5;\n        float g = g * 0.5 + 0.5;\n        float b = b * 0.5 + 0.5;\n        color = vec3( r, g, b );\n    }\n    return color;\n}\n<|file_separator|>// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 color = vec3( 0.0 );\n    vec2 uv = vec2( x, y ) / vec2( width, height );\n    vec2 p = uv * 2.0 - 1.0;\n    float d = length( p );\n    if ( d < 1.0 )\n    {\n        float t = atan( p.y, p.x ) / 3.14159265359;\n        float s = sin( t );\n        float c = cos( t );\n        float a = atan( s, c );\n        float b = atan( p.y, p.x );\n        float r = length( p );\n        float g = sin( a ) * cos( b );\n        float b = sin( a ) * sin( b );\n        float a = cos( a );\n        float r = r * 0.5 + ", "\n    return length( p - c ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.x, p.y ) - t.x, p.y );\n    return length( q ) - t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot( p, n );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = abs( p ) - c;\n    return length( max( q, vec2( 0.0 ) ) ) - r;\n}\n\nfloat sdCone( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = abs( p ) - c;\n    return length( max( q, vec2( 0.0 ) ) ) - r;\n}\n\nfloat sdTorusKnot( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.x, p.y ) - t.x, p.y );\n    return length( q ) - t.y;\n}\n\nfloat sdEllipsoid( in vec2 p, in vec2 c )\n{\n    vec2 q = abs( p ) - c;\n    return length( max( q, vec2( 0.0 )", "\n    vec2 d = abs(p - c) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdSphere( in vec2 p, in vec2 c, in float r ) \n{\n    return length(p - c) - r;\n}\n\nfloat sdPlane( in vec2 p, in vec2 c, in vec2 n ) \n{\n    return dot(p - c, n);\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = abs(p - c) - vec2(r);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdCone( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = abs(p - c) - vec2(r);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTorus( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = abs(p - c) - vec2(r);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdDisc( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = abs(p - c) - vec2(r);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdEllipsoid( in vec2 p, in vec2 c, in vec2 r ) \n{\n    vec2 d = abs(p - c) - r;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdSphere( in vec2 p, in vec2 c, in float r ) \n", "\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    vec2 d = abs(pa) - abs(pb);\n    return min(dot(pa,pa),dot(pb,pb)) + length(max(d,0.0));\n}\n\nvec2 sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nvec2 sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdSphere( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nvec2 sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.x,p.y) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nvec2 sdPlane( in vec2 p, in vec2 n )\n{\n    return abs(p.yz) - n.xy;\n}\n\nvec2 sdParabola( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 q = p - a;\n    return length(q) - b.x * dot(q,q) + b.y * dot(q,q) * dot(q,q);\n}\n\nvec2 sdParabola( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 q = p - a;\n    return length(q) - b.x * dot(q,q) + c.y * dot(q,q) * dot(q,q);\n}\n\nvec2 sdParabola( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 q = p - a;\n    return length(q) - b.x * dot(q,q) + c.y * dot(q,q) * dot(q,q) - d", "\n    vec2 d = abs(p - a) - b;\n    float t = max(max(d.x, d.y), 0.0);\n    float r = sqrt(t);\n    float s = r - d.x + d.y;\n    float t2 = s * s + d2min;\n    float t3 = t2 * t2;\n    float t4 = t3 * t2;\n    float t5 = t4 * t2;\n    float t6 = t5 * t2;\n    float t7 = t6 * t2;\n    float t8 = t7 * t2;\n    float t9 = t8 * t2;\n    float t10 = t9 * t2;\n    float t11 = t10 * t2;\n    float t12 = t11 * t2;\n    float t13 = t12 * t2;\n    float t14 = t13 * t2;\n    float t15 = t14 * t2;\n    float t16 = t15 * t2;\n    float t17 = t16 * t2;\n    float t18 = t17 * t2;\n    float t19 = t18 * t2;\n    float t20 = t19 * t2;\n    float t21 = t20 * t2;\n    float t22 = t21 * t2;\n    float t23 = t22 * t2;\n    float t24 = t23 * t2;\n    float t25 = t24 * t2;\n    float t26 = t25 * t2;\n    float t27 = t26 * t2;\n    float t28 = t27 * t2;\n    float t29 = t28 * t2;\n    float t30 = t29 * t2;\n    float t31 = t30 * t2;\n    float t32 = t31 * t2;\n    float t33 = t32 * t2;\n    float t34 = t33 * t2;\n    float t", "\n    float d = 1000000.0;\n    float t = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    ", "\n    return length( p - vec2( 0.5 ) );\n}\n\nfloat sdB( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.25;\n}\n\nfloat sdC( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.125;\n}\n\nfloat sdD( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.0625;\n}\n\nfloat sdE( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.03125;\n}\n\nfloat sdF( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.015625;\n}\n\nfloat sdG( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.0078125;\n}\n\nfloat sdH( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.00390625;\n}\n\nfloat sdI( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.001953125;\n}\n\nfloat sdJ( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.0009765625;\n}\n\nfloat sdK( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.00048828125;\n}\n\nfloat sdL( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.000244140625;\n}\n\nfloat sdM( in vec2 p )\n{\n    return length( p - vec2( 0.5 ) ) - 0.", "\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q ), dot( r, r ) ), 1.0 );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    vec2 q = p - vec2( 0.5 );\n    vec2 r = abs( q ) - 0.5;\n    return min( max( dot( q, q", "\n    // Generate a pattern based on the given UV coordinates\n    // This pattern is a simple grid-like pattern\n    // The pattern is generated by adding the UV coordinates of the grid cells\n    // The pattern is then normalized to the range [0, 1]\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern is then multiplied by 255 to get the final color\n    // The pattern", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    float ab2 = dot( ab, ab );\n    float ap2 = dot( ap, ab );\n    float bp2 = dot( bp, ab );\n    float t = clamp( (ap2 + bp2) / ab2, 0.0, 1.0 );\n    return a + t * ab;\n}\n<|file_separator|>// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float ab2 = dot( ab, ab );\n    float ap2 = dot( ap, ab );\n    float t = clamp( ap2 / ab2, 0.0, 1.0 );\n    return a + t * ab;\n}\n<|file_separator|>// Closest point on line segment\nvec2 cloLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    float ab2 = dot( ab, ab );\n    float ap2 = dot( ap, ab );\n    float bp2 = dot( bp, ab );\n    float t = clamp( (ap2 + bp2) / ab2, 0.0, 1.0 );\n    return a + t * ab;\n}\n<|file_separator|>// Closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    float ab2 = dot( ab, ab );\n    float ac2 = dot( ac, ac );\n    float ap2 = dot( ap, ab );\n    float bp2 = dot( bp, ac );\n    float cp2 = dot( cp, ac );\n    float t = clamp( (ap2 + bp2)", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float c = dot( ab, ap );\n    if ( c <= 0.0 )\n        return length( ap );\n    vec2 ap2 = ap - ab * c;\n    float d = length( ap2 );\n    if ( d <= th )\n        return length( ap2 );\n    float t = c / length( ab );\n    vec2 ab2 = ab * t;\n    return length( ap - ab2 );\n}\n<|file_separator|>", "\n    vec2 d = p - b;\n    float d2 = dot(d,d);\n    float r2 = r*r;\n    if ( d2 > r2 )\n    {\n        return b + normalize(d) * r;\n    }\n    return p;\n}\n<|file_separator|>// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2 d = p - b;\n    float d2 = dot(d,d);\n    float r2 = r*r;\n    if ( d2 > r2 )\n    {\n        return b + normalize(d) * r;\n    }\n    return p;\n}\n<|file_separator|>", "\n    vec2 d = abs( p - b ) - r;\n    return length( max( d, 0.0 ) );\n}\n<|file_separator|>", "\n    return length( max(abs(p)-b, 0.0 ) );\n}\n<|file_separator|>", "\n    vec2 o = vec2(34.0, 13.0);\n    vec2 a = p.xy + o.xy;\n    vec2 b = p.xy + o.yx;\n    vec2 c = p.xy + o.xx;\n    vec2 d = p.xy + o.yy;\n    vec2 e = p.xy + o.xy + o.xy;\n    vec2 f = p.xy + o.yx + o.yx;\n    vec2 g = p.xy + o.xx + o.xx;\n    vec2 h = p.xy + o.yy + o.yy;\n    vec2 i = p.xy + o.xy + o.xy + o.xy;\n    vec2 j = p.xy + o.yx + o.yx + o.yx;\n    vec2 k = p.xy + o.xx + o.xx + o.xx;\n    vec2 l = p.xy + o.yy + o.yy + o.yy;\n    vec2 m = p.xy + o.xy + o.xy + o.xy + o.xy;\n    vec2 n = p.xy + o.yx + o.yx + o.yx + o.yx;\n    vec2 o = p.xy + o.xx + o.xx + o.xx + o.xx;\n    vec2 p = p.xy + o.yy + o.yy + o.yy + o.yy;\n    vec2 q = p.xy + o.xy + o.xy + o.xy + o.xy + o.xy;\n    vec2 r = p.xy + o.yx + o.yx + o.yx + o.yx + o.yx;\n    vec2 s = p.xy + o.xx + o.xx + o.xx + o.xx + o.xx;\n    vec2 t = p.xy + o.yy + o.yy + o.yy + o.yy + o.yy;\n    vec2 u = p.xy + o.xy + o.xy + o.xy + o.xy + o.xy + o.xy;\n    vec2 v = p.xy + o.yx + o.yx +", "\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// My take on", "\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nvec2 random2(vec2 st){\n    return fract(sin(dot(st.xy, vec2(12.9898,", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    // Four corners in 2D of a tile\n    float a = dot(i, vec2(1.0, 1.0));\n    float b = dot(i + vec2(1.0, 0.0), vec2(-1.0, 1.0));\n    float c = dot(i + vec2(0.0, 1.0), vec2(1.0, -1.0));\n    float d = dot(i + vec2(1.0, 1.0), vec2(-1.0, -1.0));\n    \n    // Smooth Interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    // Mix 4 corners\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n// A 2D noise implementation I came up with that requires one less call to the pseudo-random number generator and one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    // Four corners in 2D of a tile\n    float a = dot(i, vec2(1.0, 1.0));\n    float b = dot(i + vec2(1.0, 0.0), vec2(-1.0, 1.0));\n    float c = dot(i + vec2(0.0, 1.0), vec2(1.0, -1.0));\n    float d = dot(i + vec2(1.0, 1.0), vec2(-1.0, -1.0));\n    \n    // Smooth Interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    // Mix 4 corners\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n// A 2D noise implementation I came up with that requires one less call", "\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 0.5;\n    \n    for (int i = 0; i < octaves; i++)\n    {\n        total += snoise(x * frequency) * amplitude;\n        frequency *= lacunarity;\n        amplitude *= persistence;\n    }\n    \n    return total;\n}\n<|file_separator|>", "\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float w = 1.0;\n    ", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float z3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float z4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float z5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float z6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float z7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float z8 = 0.0;\n    float x9 = 0.0;\n    float y9 = ", "\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n    return p3;\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 34.0);\n    p3 = mod(p3, 289.0);\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 113.0)) + dot(f.yzx, vec3(\n        113.0, 66.0, 113.0));\n    return mix(mix(mix(dot(vec3(\n        1.0, 1.0, 1.0), vec3(\n        f.x, f.y, f.z)), vec3(\n        1.0, 1.0, 1.0)),\n        mix(dot(vec3(\n        f.x, f.y, f.z), vec3(\n        f.z, f.x, f.y)), vec3(\n        1.0, 1.0, 1.0)),\n        f.z);\n}\nfloat noise3d(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 113.0)) + dot(f.yzx, vec3(\n        113.0, 66.0, 113.0));\n    return mix(mix(mix(dot(vec3(\n        1.0, 1.0, 1.0), vec3(\n        f.x, f.y, f.z)), vec3(\n        1.0, 1.0, 1.0)),\n        mix(dot(vec3(\n        f.x, f.y, f.z), vec3(\n        f.z, f.x, f.y)), vec3(\n        1.0, 1.0, 1.0)),\n        f.z);\n}\nfloat noise3d(vec3 p, float freq, float amp) {\n    return amp*noise3d(p*freq);\n}\nfloat noise3d", "\n    return fract(sin(dot(x,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// this is the main hash function\n// it is a simple hash function that is used to generate a hash\n// for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for a given position\n// it is used to generate a hash for", "\n    return length( cross( b - a, p - a ) ) / length( b - a );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2( length( p.x, p.y ) - t.x, p.z );\n    return length( q ) - t.y;\n}\n\nfloat sdPlane( in vec2 p, in vec2 n )\n{\n    return dot( p, n );\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) - min( d.x, d.y );\n}\n\nfloat sdCone( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, 0.0 ) ) - min( d.x, d.y );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, vec2( 0.0 ) ) ) - min( d.x, d.y ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) - c;\n    return length( max( d, vec2( 0.0 ) ) ) - min( d.x, d.y ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs( p ) -", "\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p - b ) - r;\n    return min( max( d.x, d.y ), 0.0 ) + length(", "\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(i.x+i.y,i.x+i.y+1.0,f.x),\n                   mix(i.x+i.y+1.0,i.x+i.y+2.0,f.x),f.y),\n               mix(mix(i.x+i.y+2.0,i.x+i.y+3.0,f.x),\n                   mix(i.x+i.y+3.0,i.x+i.y+4.0,f.x),f.y),f.y);\n}\n\nfloat Noise12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(Hash12(i + vec2(0.0,0.0)),Hash12(i + vec2(1.0,0.0)),f.x),\n                   mix(Hash12(i + vec2(0.0,1.0)),Hash12(i + vec2(1.0,1.0)),f.x),f.y),\n               mix(mix(Hash12(i + vec2(0.0,0.0)),Hash12(i + vec2(1.0,0.0)),f.x),\n                   mix(Hash12(i + vec2(0.0,1.0)),Hash12(i + vec2(1.0,1.0)),f.x),f.y),f.y);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(Noise12(i + vec2(0.0,0.0)),Noise12(i + vec2(1.0,0", "\n    float a = an * m;\n    float b = bn * m;\n    float c = acs.x * m;\n    float d = acs.y * m;\n    float t = atan(d, c);\n    float s = sin(t);\n    float c = cos(t);\n    float x = p.x;\n    float y = p.y;\n    float r2 = r * r;\n    float d2 = x * x + y * y;\n    float d3 = d2 * d2;\n    float d4 = d2 * d3;\n    float d5 = d2 * d4;\n    float d6 = d2 * d5;\n    float d7 = d2 * d6;\n    float d8 = d2 * d7;\n    float d9 = d2 * d8;\n    float d10 = d2 * d9;\n    float d11 = d2 * d10;\n    float d12 = d2 * d11;\n    float d13 = d2 * d12;\n    float d14 = d2 * d13;\n    float d15 = d2 * d14;\n    float d16 = d2 * d15;\n    float d17 = d2 * d16;\n    float d18 = d2 * d17;\n    float d19 = d2 * d18;\n    float d20 = d2 * d19;\n    float d21 = d2 * d20;\n    float d22 = d2 * d21;\n    float d23 = d2 * d22;\n    float d24 = d2 * d23;\n    float d25 = d2 * d24;\n    float d26 = d2 * d25;\n    float d27 = d2 * d26;\n    float d28 = d2 * d27;\n    float d29 = d2 * d28;\n    float d30 = d2 * d29;\n    float d31 = d2 * d30;\n    float d32 = d", "\n    vec3 n = vec3( 0.0 );\n    float d = 1.0;\n    for( int i = 0; i < 3; i++ )\n    {\n        float t = p.x;\n        p.x = p.y;\n        p.y = t;\n        float t2 = p.z;\n        p.z = p.w;\n        p.w = t2;\n        n += d * ( p - vec3( 0.0 ) );\n        d *= 0.5;\n    }\n    return normalize( n );\n}\n<|file_separator|>", "\n    float t = max(t0, t1);\n    float bias = max(0.001 * (1.0 - dot(rd, rd)), 0.005);\n    for (int i = 0; i < 5; i++)\n    {\n        t = max(t, t1 + 0.05);\n        if (scene_intersect(ro, rd, t, t1, hit))\n        {\n            if (hit.mat->diffuse)\n            {\n                return 1.0;\n            }\n            else if (hit.mat->specular)\n            {\n                vec3 reflect_dir = reflect_ray(rd, hit.normal);\n                vec3 refract_dir = refract_ray(rd, hit.normal, hit.mat->refractive_index);\n                vec3 reflect_orig = reflect_dir.z > 0? ro - hit.normal * bias : ro + hit.normal * bias;\n                vec3 refract_orig = refract_dir.z > 0? ro - hit.normal * bias : ro + hit.normal * bias;\n                float diffuse_light_intensity = max(dot(hit.normal, -light_dir), 0.0);\n                float specular_light_intensity = pow(max(dot(view_dir, reflect_dir), 0.0), hit.mat->specular_exponent);\n                float reflect_intensity = shadow(reflect_orig, reflect_dir, t, t1);\n                float refract_intensity = shadow(refract_orig, refract_dir, t, t1);\n                return diffuse_light_intensity * hit.mat->diffuse_color * hit.mat->diffuse +\n                       specular_light_intensity * hit.mat->specular_color * hit.mat->specular +\n                       reflect_intensity * hit.mat->diffuse_color * hit.mat->diffuse +\n                       refract_intensity * hit.mat->diffuse_color * hit.mat->diffuse;\n            }\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n    return 0.0;\n}<|file_separator|>", "\n    float ao = 0.0;\n    float d = 0.001;\n    for (int i = 0; i < 10; i++)\n    {\n        float d2 = d * d;\n        float d3 = d2 * d;\n        float d4 = d2 * d2;\n        float d5 = d2 * d3;\n        float d6 = d2 * d4;\n        float d7 = d2 * d5;\n        float d8 = d2 * d6;\n        float d9 = d2 * d7;\n        float d10 = d2 * d8;\n        float d11 = d2 * d9;\n        float d12 = d2 * d10;\n        float d13 = d2 * d11;\n        float d14 = d2 * d12;\n        float d15 = d2 * d13;\n        float d16 = d2 * d14;\n        float d17 = d2 * d15;\n        float d18 = d2 * d16;\n        float d19 = d2 * d17;\n        float d20 = d2 * d18;\n        float d21 = d2 * d19;\n        float d22 = d2 * d20;\n        float d23 = d2 * d21;\n        float d24 = d2 * d22;\n        float d25 = d2 * d23;\n        float d26 = d2 * d24;\n        float d27 = d2 * d25;\n        float d28 = d2 * d26;\n        float d29 = d2 * d27;\n        float d30 = d2 * d28;\n        float d31 = d2 * d29;\n        float d32 = d2 * d30;\n        float d33 = d2 * d31;\n        float d34 = d2 * d32;\n        float d35 = d2 * d33;\n        float d36 = d2 * d34;", "\n    mat3 rotationMatrix = mat3(0.0);\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    float c = cos(halfAngle);\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    rotationMatrix[0][0] = t * x * x + c;\n    rotationMatrix[0][1] = t * x * y - s * z;\n    rotationMatrix[0][2] = t * x * z + s * y;\n    rotationMatrix[1][0] = t * x * y + s * z;\n    rotationMatrix[1][1] = t * y * y + c;\n    rotationMatrix[1][2] = t * y * z - s * x;\n    rotationMatrix[2][0] = t * x * z - s * y;\n    rotationMatrix[2][1] = t * y * z + s * x;\n    rotationMatrix[2][2] = t * z * z + c;\n    return rotationMatrix;\n}\n<|file_separator|>", "\n    // get the size of the image\n    vec2 resolution = vec2(imageSize.x, imageSize.y);\n    // get the aspect ratio\n    float aspectRatio = resolution.x / resolution.y;\n    // get the size of the viewport\n    vec2 viewportSize = vec2(1, 1) / resolution;\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewportSizePixels = vec2(viewportSize.x * imageSize.x, viewportSize.y * imageSize.y);\n    // get the size of the viewport in pixels\n    vec2 viewport", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise2d(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    // Four corners in 2D of a tile\n    float a = rand2d(i);\n    float b = rand2d(i + vec2(1.0, 0.0));\n    float c = rand2d(i + vec2(0.0, 1.0));\n    float d = rand2d(i + vec2(1.0, 1.0));\n    \n    // Smooth Interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    // Mix final noise value\n    return mix(a, b, u.x) + (c - a)*u.y * (1.0 - u.x) + (d - b)*u.x * u.y;\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.113))) * 43758.5453);\n}\n\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,45.113))) * 43758.5453);\n}\n\nfloat noise3d(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    // Four corners in 2D of a tile\n    float a = rand3d(i);\n    float b = rand3d(i + vec3", "\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.164))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec1 p){\n    return fract(sin(dot(p,vec1(12.9898))) * 43758.5453);\n}<|file_separator|>", "\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n  \n  float n = p.x + p.y*57.0 + 113.0*p.z;\n  float a = sin(n)*43758.5453123;\n  float b = sin(n+1.0)*43758.5453123;\n  float c = sin(n+2.0)*43758.5453123;\n  float d = sin(n+3.0)*43758.5453123;\n  \n  return mix(mix(mix(a,b,f.x),mix(c,d,f.x),f.y),mix(mix(a,b,1.0-f.x),mix(c,d,1.0-f.x),f.y),f.z);\n}\n<|file_separator|>// 3D value noise\nfloat noise3d(vec3 x){\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n  \n  float n = p.x + p.y*57.0 + 113.0*p.z;\n  float a = sin(n)*43758.5453123;\n  float b = sin(n+1.0)*43758.5453123;\n  float c = sin(n+2.0)*43758.5453123;\n  float d = sin(n+3.0)*43758.5453123;\n  \n  return mix(mix(mix(a,b,f.x),mix(c,d,f.x),f.y),mix(mix(a,b,1.0-f.x),mix(c,d,1.0-f.x),f.y),f.z);\n}\n<|file_separator|>", "\n  vec3 s = floor(p + dot(p, vec3(12.9898, 78.233, 123.645)));\n  vec3 t = s + vec3(1.0, 1.0, 1.0);\n  vec3 u = smoothstep(0.0, 1.0, fract(p + dot(p, vec3(12.9898, 78.233, 123.645))));\n  return mix(mix(mix(dot(floor(s), vec3(1.0, 1.0, 1.0)), dot(s - vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0)), u),\n                mix(dot(s + vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(s + vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0)), u), u),\n                mix(mix(dot(floor(t), vec3(1.0, 1.0, 1.0)), dot(t - vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0)), u),\n                mix(dot(t + vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)), dot(t + vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0)), u), u);\n}\n<|file_separator|>// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n  vec3 s = floor(p + dot(p, vec3(12.9898, 78.233, 123.645)));\n  vec3 t = s + vec3(1.0, ", "\n    float f = 0.0;\n    float a = 1.0;\n    float m = 1.0;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p = p * 2.0 + vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n        m *= 2.0;\n    }\n    return f / m;\n}\n\n// FBM with some precisely adjusted behavior\nfloat fbm(vec3 p){\n    float f = 0.0;\n    float a = 1.0;\n    float m = 1.0;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p = p * 2.0 + vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n        m *= 2.0;\n    }\n    return f / m;\n}\n\n// FBM with some precisely adjusted behavior\nfloat fbm(vec3 p, float a, float m){\n    float f = 0.0;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p = p * 2.0 + vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n        m *= 2.0;\n    }\n    return f / m;\n}\n\n// FBM with some precisely adjusted behavior\nfloat fbm(vec3 p, float a, float m, float c){\n    float f = 0.0;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p = p * 2.0 + vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n        m *= 2.0;\n    }\n    return f / m + c;\n}\n\n// FBM with some precisely adjusted behavior\nfloat fbm(vec3 p, float a,", "\n    vec3 pos_in_world = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_cloud = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_2 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_3 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_4 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_5 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_6 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_7 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_8 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_9 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_10 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_11 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_12 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_13 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_14 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_15 = vec3(pos.x, pos.y, pos.z);\n    vec3 pos_in_world_cloud_16 = vec3(pos.x, pos", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = normalize(vec3(0.0));\n\tvec3 lightDir = normalize(vec3(0.0));\n\tvec3 lightColor = vec3(0.0);\n\tvec3 lightPos = vec3(0.0);\n\tvec3 lightDir2 = normalize(vec3(0.0));\n\tvec3 lightColor2 = vec3(0.0);\n\tvec3 lightPos2 = vec3(0.0);\n\tvec3 lightDir3 = normalize(vec3(0.0));\n\tvec3 lightColor3 = vec3(0.0);\n\tvec3 lightPos3 = vec3(0.0);\n\tvec3 lightDir4 = normalize(vec3(0.0));\n\tvec3 lightColor4 = vec3(0.0);\n\tvec3 lightPos4 = vec3(0.0);\n\tvec3 lightDir5 = normalize(vec3(0.0));\n\tvec3 lightColor5 = vec3(0.0);\n\tvec3 lightPos5 = vec3(0.0);\n\tvec3 lightDir6 = normalize(vec3(0.0));\n\tvec3 lightColor6 = vec3(0.0);\n\tvec3 lightPos6 = vec3(0.0);\n\tvec3 lightDir7 = normalize(vec3(0.0));\n\tvec3 lightColor7 = vec3(0.0);\n\tvec3 lightPos7 = vec3(0.0);\n\tvec3 lightDir8 = normalize(vec3(0.0));\n\tvec3 lightColor8 = vec3(0.0);\n\tvec3 lightPos8 = vec3(0.0);\n\tvec3 lightDir9 = normalize(vec3(0.0));\n\tvec3 lightColor9 = vec3(0.0);\n\tvec3 lightPos9 = vec3(0.0);\n\tvec3 lightDir10 = normalize(vec3(0.0));\n\tvec3 lightColor10 = vec3(0.0);\n\tvec3 lightPos10 = vec3(0.0);\n\tvec3 lightDir11 = normalize(vec3(", "\n    vec3 color = background;\n    vec3 point = pointStart;\n    float distTo = 0.0;\n    float distToStart = 0.0;\n    float distToEnd = 0.0;\n    float distToStartEnd = 0.0;\n    float distToStartEndSqr = 0.0;\n    float distToStartEndSqr2 = 0.0;\n    float distToStartEndSqr3 = 0.0;\n    float distToStartEndSqr4 = 0.0;\n    float distToStartEndSqr5 = 0.0;\n    float distToStartEndSqr6 = 0.0;\n    float distToStartEndSqr7 = 0.0;\n    float distToStartEndSqr8 = 0.0;\n    float distToStartEndSqr9 = 0.0;\n    float distToStartEndSqr10 = 0.0;\n    float distToStartEndSqr11 = 0.0;\n    float distToStartEndSqr12 = 0.0;\n    float distToStartEndSqr13 = 0.0;\n    float distToStartEndSqr14 = 0.0;\n    float distToStartEndSqr15 = 0.0;\n    float distToStartEndSqr16 = 0.0;\n    float distToStartEndSqr17 = 0.0;\n    float distToStartEndSqr18 = 0.0;\n    float distToStartEndSqr19 = 0.0;\n    float distToStartEndSqr20 = 0.0;\n    float distToStartEndSqr21 = 0.0;\n    float distToStartEndSqr22 = 0.0;\n    float distToStartEndSqr23 = 0.0;\n    float distToStartEndSqr24 = 0.0;\n    float distToStartEndSqr25 = 0.0;\n    float distToStartEndSqr26 = 0.0;\n    float distToStartEndSqr27 = 0.0", "\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_inv(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_inv_gamma(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_gamma_inv(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma_inv_gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_inv(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_inv_gamma(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_gamma_inv(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_gamma_gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_gamma_gamma_inv(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 aces_tonemap_gamma_gamma_gamma_gamma_gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 aces_tone"]}