{"generations": [" return 0.282095; }\nfloat SH_1_0( in vec3 s ) { return 0.488603 * s.y; }\nfloat SH_1_1( in vec3 s ) { return 0.488603 * s.z; }\nfloat SH_2_0( in vec3 s ) { return 1.092548 * s.x; }\nfloat SH_2_1( in vec3 s ) { return 1.092548 * s.y * s.z; }\nfloat SH_2_2( in vec3 s ) { return 0.315392 * (3.0 * s.z * s.z - 1.0); }\nfloat SH_3_0( in vec3 s ) { return 0.546274 * s.x * s.x - 0.546274; }\nfloat SH_3_1( in vec3 s ) { return 1.092548 * s.x * s.y; }\nfloat SH_3_2( in vec3 s ) { return 0.546274 * s.x * s.z; }\nfloat SH_3_3( in vec3 s ) { return 0.590044 * (s.z * s.z - s.y * s.y); }\nfloat SH_4_0( in vec3 s ) { return 0.590044 * s.x * (s.x * s.x - 3.0 * s.y * s.y - 3.0 * s.z * s.z) + 0.373176; }\nfloat SH_4_1( in vec3 s ) { return 1.770131 * s.y * s.x * (s.x * s.x - s.z * s.z); }\nfloat SH_4_2( in vec3 s ) { return 0.799559 * s.x * (4.0 * s.z * s.z - s.y * s.y -", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a triangle\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a, ca = c-a;\n    vec2 bc = b-c;\n    float h = clamp( dot(pa,bc)/dot(bc,bc), 0.0, 1.0 );\n    return lineSegment( a+ba*h, b, p );\n}\n\n// distance to a rectangle\nfloat rectangle( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    vec2 bax = vec2(ba.x,0.0);\n    vec2 bay = vec2(0.0,ba.y);\n    float h = clamp( dot(pa,bax)/dot(bax,bax), 0.0, 1.0 );\n    float v = clamp( dot(pa,bay)/dot(bay,bay), 0.0, 1.0 );\n    return lineSegment( a+bax*h, a+bay*v, p );\n}\n\n// distance to a circle\nfloat circle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// distance to a ellipse\nfloat ellipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    return length( (p-c)/r ) - 1.0;\n}\n\n// distance to a regular polygon\nfloat polygon( in vec2 p,", "\n    return mix( v, -v, step(0.0, -dot(v, r)) );\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// a = pMod1( p, 5.0 );\n// Use like this to repeat only every other cell, starting at the y = 10.0 line:\n// a = pMod1( p - vec2(0.0, 10.0), vec2(5.0, 20.0) );\n// Use like this to repeat only every other cell, starting at the x = 15.0 line:\n// a = pMod1( p - vec2(15.0, 0.0), vec2(20.0, 5.0) );\n// Use like this to repeat every 45 degrees around the origin:\n// a = pModAngle( p, 45.0 );\n// Use like this to repeat only every other cell, starting at the y = 10.0 line and x = 15.0 line:\n// a = pMod2( p - vec2(15.0, 10.0), vec2(40.0, 20.0) );\n// Use like this to repeat only every other cell, starting at the x = 15.0 line and y = 25.0 line:\n// a = pMod2( p - vec2(15.0, 25.0), vec2(20.0, 40.0) );\n// Use like this to repeat every 45 degrees around the origin, but only every other one:\n// a = pModAngle( p, 90.0 );\n// Use like this to repeat only every other cell, starting at the y = 10.0 line and x = 15.0 line, but only every other one:\n// a = pMod2( p - vec2(15.0, 10.0), vec2(40.0, 20.0), vec2(90.0, 0.0) );\n// Use like this to repeat only every other cell, starting at the x = 15.0 line and y =", "\n    return dot(v,r) < 0.0? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return dot(v,r) < 0.0? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return dot(v,r) < 0.0? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float eps )\n{\n    return dot(v,r) < eps? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in float eps )\n{\n    return dot(v,r) < eps? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r, in float eps )\n{\n    return dot(v,r) < eps? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float eps, in float eps2 )\n{\n    return dot(v,r) < eps? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in float eps, in float eps2 )\n{\n    return dot(v,r) < eps? -v : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 refl", "\n    return mix( v, vec2(0.0), step(0.0, -dot(v, r)) );\n}\n\n// Return the intersection of two lines (if they intersect)\nvec2 intersectLines( in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 r = b - a;\n    vec2 s = d - c;\n    float u = - (r.x * (a.y - c.y) + r.y * (a.x - c.x)) / (s.x * r.y - s.y * r.x);\n    return a + r * u;\n}\n\n// Return the intersection of two line segments (if they intersect)\nvec2 intersectSegments( in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 i = intersectLines( a, b, c, d );\n    return mix( i, vec2(0.0), step(0.0, min(dot(i - a, b - a), dot(i - b, a - b))) + step(0.0, min(dot(i - c, d - c), dot(i - d, c - d))) );\n}\n\n// Return the intersection of a line and a circle (if they intersect)\nvec2 intersectLineCircle( in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n    vec2 i = intersectLines( a, b, c, c + vec2(r, 0.0) );\n    return mix( i, vec2(0.0), step(0.0, dot(i - c, i - c) - r * r) );\n}\n\n// Return the intersection of a line and a circle (if they intersect)\nvec2 intersectLineCircle( in vec2 a, in vec2 b, in vec2 c, in float r, in float t )\n{\n    vec2 i = intersectLines( a, b, c, c + vec2(r * cos(t), r * sin(t)) );\n    return mix( i, vec2(0.0), step(0.0, dot(i - c, i - c) - r * r) );\n}\n\n//", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(w1,w2,h);\n}\n\n// https://www.shadertoy.com/view/4l23Dh\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/4l23Dh\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://www.shadertoy.com/view/4l23Dh\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r1, float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\n// https://www.shadertoy.com/view/4l23Dh\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float r1, float r2, float r3, float r4 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(mix(r1,r2,h),mix(r3,r4,h),", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot4 = sunDot2 * sunDot2;\n\tfloat sunDot8 = sunDot4 * sunDot4;\n\tfloat sunDot16 = sunDot8 * sunDot8;\n\tfloat sunDot32 = sunDot16 * sunDot16;\n\tfloat sunDot64 = sunDot32 * sunDot32;\n\tfloat sunDot128 = sunDot64 * sunDot64;\n\tfloat sunDot256 = sunDot128 * sunDot128;\n\tfloat sunDot512 = sunDot256 * sunDot256;\n\tfloat sunDot1024 = sunDot512 * sunDot512;\n\tfloat sunDot2048 = sunDot1024 * sunDot1024;\n\tfloat sunDot4096 = sunDot2048 * sunDot2048;\n\tfloat sunDot8192 = sunDot4096 * sunDot4096;\n\tfloat sunDot16384 = sunDot8192 * sunDot8192;\n\tfloat sunDot32768 = sunDot16384 * sunDot16384;\n\tfloat sunDot65536 = sunDot32768 * sunDot32768;\n\tfloat sunDot131072 = sunDot65536 * sunDot65536;\n\tfloat sunDot262144 = sunDot131072 * sunDot131072;\n\tfloat sunDot524288 = sunDot262144 * sunDot262144;\n\tfloat sunDot1048576 = sunDot524288 * sunDot524288;\n\tfloat sunDot2097152 = sunDot1048576 * sunDot1048576;\n\tfloat sunDot4194304 = sunDot20", "\n\tvec4 a = p1;\n\tvec4 b = 0.5f * (p2 - p0);\n\tvec4 c = 0.5f * (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3);\n\tvec4 d = 0.5f * (-p0 + 3.0f * p1 - 3.0f * p2 + p3);\n\n\treturn a + b * t + c * t * t + d * t * t * t;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension, float bias)\n{\n\tvec4 a = p1;\n\tvec4 b = 0.5f * (p2 - p0) * tension;\n\tvec4 c = 0.5f * (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * tension;\n\tvec4 d = 0.5f * (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * tension;\n\n\treturn a + b * t + c * t * t + d * t * t * t;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension, float bias, float continuity)\n{\n\tvec4 a = p1;\n\tvec4 b = 0.5f * (p2 - p0) * tension;\n\tvec4 c = 0.5f * (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * tension;\n\tvec4 d = 0.5f * (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * tension;\n\n\treturn a + b * t +", "\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat w = 1.0;\n\tfloat f = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tf += sin(x + y*nudge) * w;\n\t\tscale *= 1.5;\n\t\tw *= 0.5;\n\t\tx *= scale;\n\t\ty *= scale;\n\t\tz += 0.05;\n\t}\n\treturn f * normalizer;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge2 = 0.739513;\t// size of perpendicular vector\nfloat normalizer2 = 1.0 / sqrt(1.0 + nudge2*nudge2);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC2(vec3 p)\n{\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat w = 1.0;\n\tfloat f = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tf += sin(x + y*nudge2) * w;\n\t\tscale *= 1.5;\n\t\tw *= 0.5;\n\t\tx *= scale;\n\t\ty *= scale;\n\t\tz += 0.05;\n\t}\n\treturn f * normalizer2;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float n", "\n\tfloat t0 = floor(t);\n\tfloat t1 = t0 + 1.0;\n\tfloat t2 = t0 + 2.0;\n\tfloat t3 = t0 + 3.0;\n\tfloat t12 = t1 - t;\n\tfloat t22 = t2 - t;\n\tfloat t32 = t3 - t;\n\tfloat t13 = t12 * t12;\n\tfloat t23 = t22 * t22;\n\tfloat t33 = t32 * t32;\n\tfloat t14 = t13 * t12;\n\tfloat t24 = t23 * t22;\n\tfloat t34 = t33 * t32;\n\tfloat t15 = t14 * t12;\n\tfloat t25 = t24 * t22;\n\tfloat t35 = t34 * t32;\n\tfloat t16 = t15 * t12;\n\tfloat t26 = t25 * t22;\n\tfloat t36 = t35 * t32;\n\tfloat t17 = t16 * t12;\n\tfloat t27 = t26 * t22;\n\tfloat t37 = t36 * t32;\n\tfloat t18 = t17 * t12;\n\tfloat t28 = t27 * t22;\n\tfloat t38 = t37 * t32;\n\tfloat t19 = t18 * t12;\n\tfloat t29 = t28 * t22;\n\tfloat t39 = t38 * t32;\n\tfloat t110 = t19 * t12;\n\tfloat t210 = t29 * t22;\n\tfloat t310 = t39 * t32;\n\tfloat t111 = t110 * t12;\n\tfloat t211 = t210 * t22;\n\tfloat t311 = t310 * t32;\n\tfloat t112 = t1", "\n\treturn frac(sin(u) * 43758.5453123);\n}\n\nfloat Hash2d(float2 u)\n{\n\treturn frac(sin(dot(u, float2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat Hash3d(float3 u)\n{\n\treturn frac(sin(dot(u, float3(12.9898, 78.233, 35.344))) * 43758.5453123);\n}\n\nfloat Noise1d(float u)\n{\n\tfloat i = floor(u);\n\tfloat f = frac(u);\n\tfloat2 t = f * f * (3.0 - 2.0 * f);\n\treturn lerp(Hash1d(i), Hash1d(i + 1.0), t.x);\n}\n\nfloat Noise2d(float2 u)\n{\n\tfloat2 i = floor(u);\n\tfloat2 f = frac(u);\n\tfloat2 t = f * f * (3.0 - 2.0 * f);\n\treturn lerp(lerp(Hash2d(i), Hash2d(i + float2(1.0, 0.0)), t.x),\n\t\tlerp(Hash2d(i + float2(0.0, 1.0)), Hash2d(i + float2(1.0, 1.0)), t.x),\n\t\tt.y);\n}\n\nfloat Noise3d(float3 u)\n{\n\tfloat3 i = floor(u);\n\tfloat3 f = frac(u);\n\tfloat3 t = f * f * (3.0 - 2.0 * f);\n\treturn lerp(lerp(lerp(Hash3d(i), Hash3d(i + float3(1.0, 0.0, 0.0)), t.x),\n\t\tlerp(Hash3d(i + float3(0.0, 1.0, 0.0)), Hash3d", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tn += sin(f * p.x + iGlobalTime) * sin(f * p.y + iGlobalTime) * sin(f * p.z + iGlobalTime) * f;\n\t\tf *= 1.9;\n\t}\n\treturn n;\n}\n\n// This is a 3D noise function that uses the spiral noise function above.\n// It's a bit slower than the 2D version, but it's still pretty fast.\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// This is a 3D noise function that uses the spiral noise function above.\n// It's a bit slower than the 2D version, but it's still pretty fast.\nfloat Noise3D(vec3 p, float scale)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z) * scale;\n}\n\n// This is a 3D noise function that uses the spiral noise function above.\n// It's a", "\n\tfloat d = 1000000.0;\n\tfloat d2 = 1000000.0;\n\tfloat d3 = 1000000.0;\n\tfloat d4 = 1000000.0;\n\tfloat d5 = 1000000.0;\n\tfloat d6 = 1000000.0;\n\tfloat d7 = 1000000.0;\n\tfloat d8 = 1000000.0;\n\tfloat d9 = 1000000.0;\n\tfloat d10 = 1000000.0;\n\tfloat d11 = 1000000.0;\n\tfloat d12 = 1000000.0;\n\tfloat d13 = 1000000.0;\n\tfloat d14 = 1000000.0;\n\tfloat d15 = 1000000.0;\n\tfloat d16 = 1000000.0;\n\tfloat d17 = 1000000.0;\n\tfloat d18 = 1000000.0;\n\tfloat d19 = 1000000.0;\n\tfloat d20 = 1000000.0;\n\tfloat d21 = 1000000.0;\n\tfloat d22 = 1000000.0;\n\tfloat d23 = 1000000.0;\n\tfloat d24 = 1000000.0;\n\tfloat d25 = 1000000.0;\n\tfloat d26 = 1000000.0;\n\tfloat d27 = 1000000.0;\n\tfloat d28 = 1000000.0;\n\tfloat d29 = 1000000.0;", "\n\tvec3 envColor = vec3(0.0);\n\tvec3 envDir = normalize(rayDir);\n\tfloat envDot = dot(envDir, sunDir);\n\tfloat envDot2 = envDot * envDot;\n\tfloat envDot4 = envDot2 * envDot2;\n\tfloat envDot8 = envDot4 * envDot4;\n\tfloat envDot16 = envDot8 * envDot8;\n\tfloat envDot32 = envDot16 * envDot16;\n\tfloat envDot64 = envDot32 * envDot32;\n\tfloat envDot128 = envDot64 * envDot64;\n\tfloat envDot256 = envDot128 * envDot128;\n\tfloat envDot512 = envDot256 * envDot256;\n\tfloat envDot1024 = envDot512 * envDot512;\n\tfloat envDot2048 = envDot1024 * envDot1024;\n\tfloat envDot4096 = envDot2048 * envDot2048;\n\tfloat envDot8192 = envDot4096 * envDot4096;\n\tfloat envDot16384 = envDot8192 * envDot8192;\n\tfloat envDot32768 = envDot16384 * envDot16384;\n\tfloat envDot65536 = envDot32768 * envDot32768;\n\tfloat envDot131072 = envDot65536 * envDot65536;\n\tfloat envDot262144 = envDot131072 * envDot131072;\n\tfloat envDot524288 = envDot262144 * envDot262144;\n\tfloat envDot1048576 = envDot524288 * envDot524288;\n\tfloat envDot2097152 = envDot1048576 * env", "\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin3( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax3( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin4( float a, float b, float k )\n{\n    float h", "\n\tvec3 L = spherePos - pos;\n\tfloat tca = dot(L, dirVecPLZNormalizeMeFirst);\n\tfloat d2 = dot(L, L) - tca * tca;\n\tif (d2 > rad * rad) return -1.0;\n\tfloat thc = sqrt(rad * rad - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif (t0 < 0.0 && t1 < 0.0) return -1.0;\n\tif (t0 > t1) return t1;\n\treturn t0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat PlaneIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos, vec3 planeNorm)\n{\n\tfloat denom = dot(planeNorm, dirVecPLZNormalizeMeFirst);\n\tif (denom > 1e-6)\n\t{\n\t\tvec3 planeToRay = pos - planePos;\n\t\tfloat t = dot(planeToRay, planeNorm) / denom;\n\t\treturn t;\n\t}\n\treturn -1.0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat BoxIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 boxPos, vec3 boxSize)\n{\n\tvec3 invDir = 1.0 / dirVecPLZNormalizeMeFirst;\n\tvec3 tbot = invDir * (boxPos - pos);\n\tvec3 ttop = invDir * (boxPos + boxSize - pos);\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\tvec2 t = max(tmin.xx, tmin.yz);\n\tfloat t0 = max(t.x, t.y);\n\tt = min(tmax.xx, tmax.yz);\n\tfloat t1 = min(t.x, t.y);\n\tfloat tNear = max(t0, 0.0);\n\tif (tNear > t1) return -1.0;\n\treturn tNear;\n}\n\n// dir", "\n\tvec2 d = vec2(1000.0, 0.0);\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3(0.0, 0.0, 0.0), 0.5), 1.0));\n\td = min(d, vec2(sdSphere(p - vec3", "\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// surface\nvec3 mapS0(float u, float v)\n{\n    return vec3(u, v, 0.0);\n}\n\nvec3 mapS1(float u, float v)\n{\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 mapS2(float u, float v)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvec3 mapS3(float u, float v)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// volume\nvec3 mapV0(float u, float v, float w)\n{\n    return vec3(u, v, w);\n}\n\nvec3 mapV1(float u, float v, float w)\n{\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 mapV2(float u, float v, float w)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvec3 mapV3(float u, float v, float w)\n{\n    return vec3(0.0, 0.0, 1.0);\n}\n\n//\n//\n//\n\nvoid main()\n{\n    vec3 p = vec3(0.0);\n    vec3 d1 = vec3(0.0);\n    vec3 d2 = vec3(0.0);\n    vec3 d3 = vec3(0.0);\n\n    if (type == 0)\n    {\n        p = mapD0(t);\n        d1 = mapD", "\n    return 2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 2.0 * (p2 - 2.0 * p1 + p0);\n}\n\n// unit normal vector\nvec3 mapN(float t)\n{\n    vec3 t1 = mapD1(t);\n    vec3 t2 = mapD2(t);\n    return normalize(cross(t1, t2));\n}\n\n// unit binormal vector\nvec3 mapB(float t)\n{\n    vec3 t1 = mapD1(t);\n    vec3 n = mapN(t);\n    return normalize(cross(n, t1));\n}\n\n// unit tangent vector\nvec3 mapT(float t)\n{\n    vec3 t1 = mapD1(t);\n    return normalize(t1);\n}\n\n// map a point on the curve\nvec3 map(float t)\n{\n    return ((2.0 * t * t * t - 3.0 * t * t + 1.0) * p0 +\n            (-2.0 * t * t * t + 3.0 * t * t) * p1 +\n            (t * t * t - 2.0 * t * t + t) * p2 +\n            (t * t * t - t * t) * p3);\n}\n\n// map a normal on the curve\nvec3 mapN(float t, float n)\n{\n    return mapN(t) * n;\n}\n\n// map a binormal on the curve\nvec3 mapB(float t, float b)\n{\n    return mapB(t) * b;\n}\n\n// map a tangent on the curve\nvec3 mapT(float t, float t_)\n{\n    return mapT(t) * t_;\n}\n\n// map a point on the curve\nvec3 map(float t, float n, float b, float t_)\n{\n    return map(t) + mapN(t, n) + mapB(t, b) + mapT(t, t_);\n}", "\n    return 2.0 * (1.0 - t) * (mapD1(t) - mapD1(0.0)) + 2.0 * t * (mapD1(1.0) - mapD1(t));\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD2(t) - mapD2(0.0)) + 2.0 * t * (mapD2(1.0) - mapD2(t));\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD3(t) - mapD3(0.0)) + 2.0 * t * (mapD3(1.0) - mapD3(t));\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD4(t) - mapD4(0.0)) + 2.0 * t * (mapD4(1.0) - mapD4(t));\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD5(t) - mapD5(0.0)) + 2.0 * t * (mapD5(1.0) - mapD5(t));\n}\n\n// curve seventh derivative (lock)\nvec3 mapD7(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD6(t) - mapD6(0.0)) + 2.0 * t * (mapD6(1.0) - mapD6(t));\n}\n\n// curve eighth derivative (wrench)\nvec3 mapD8(float t)\n{\n    return 2.0 * (1.0 - t) * (mapD7(t) - mapD7(0.0)) + 2.", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot( pa-ba*h, pa-ba*h ), h );\n}\n\n// signed distance to line segment\nfloat sdLineSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance to triangle\nfloat sdTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n    ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// signed distance to capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat ab2 = dot( ab, ab );\n\tfloat ao2 = dot( ao, ao );\n\tfloat ab_ao = dot( ab, ao );\n\tfloat t = clamp( ab_ao / ab2, 0.0, 1.0 );\n\tvec3 c = a + t * ab;\n\tvec3 oc = c - o;\n\tfloat oc2 = dot( oc, oc );\n\treturn vec2( oc2, t );\n}\n\n// unsigned squared distance between ray and triangle\nvec2 usqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ao = o - a;\n\tvec3 ab_ac = cross( ab, ac );\n\tvec3 ab_ao = cross( ab, ao );\n\tvec3 ac_ao = cross( ac, ao );\n\tfloat ab2 = dot( ab, ab );\n\tfloat ac2 = dot( ac, ac );\n\tfloat ab_ac2 = dot( ab_ac, ab_ac );\n\tfloat ab_ao2 = dot( ab_ao, ab_ao );\n\tfloat ac_ao2 = dot( ac_ao, ac_ao );\n\tfloat ab_ac_ao = dot( ab_ac, ab_ao );\n\tfloat t = clamp( ab_ac_ao / ab_ac2, 0.0, 1.0 );\n\tfloat u = clamp( ( ab_ac_ao - t * ab_ac2 ) / ab2, 0.0, 1.0 );\n\tfloat v = clamp( ( ab_ac_ao - t * ab_ac2 - u * ab2 ) / ac2, 0.0, 1.0 );\n\tvec3 c = a + u * ab + v * ac;\n\tvec3 oc = c - o;\n\tfloat oc2 = dot( oc, oc );\n\treturn vec2( oc2, t );\n}\n\n// unsigned squared distance between ray and quad\nvec2 usqdQuad( vec3 a, vec", "\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle2( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle3( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle4( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle5( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle6( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle7( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle8( in vec2 p, in float r )\n{\n  return length(p) - r;\n}\n\n// p.x = x\n// p.y = y\n// r = radius\nfloat sdCircle9( in vec2 p, in", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot4 = sunDot2 * sunDot2;\n\tfloat sunDot8 = sunDot4 * sunDot4;\n\tfloat sunDot16 = sunDot8 * sunDot8;\n\tfloat sunDot32 = sunDot16 * sunDot16;\n\tfloat sunDot64 = sunDot32 * sunDot32;\n\tfloat sunDot128 = sunDot64 * sunDot64;\n\tfloat sunDot256 = sunDot128 * sunDot128;\n\tfloat sunDot512 = sunDot256 * sunDot256;\n\tfloat sunDot1024 = sunDot512 * sunDot512;\n\tfloat sunDot2048 = sunDot1024 * sunDot1024;\n\tfloat sunDot4096 = sunDot2048 * sunDot2048;\n\tfloat sunDot8192 = sunDot4096 * sunDot4096;\n\tfloat sunDot16384 = sunDot8192 * sunDot8192;\n\tfloat sunDot32768 = sunDot16384 * sunDot16384;\n\tfloat sunDot65536 = sunDot32768 * sunDot32768;\n\tfloat sunDot131072 = sunDot65536 * sunDot65536;\n\tfloat sunDot262144 = sunDot131072 * sunDot131072;\n\tfloat sunDot524288 = sunDot262144 * sunDot262144;\n\tfloat sunDot1048576 = sunDot524288 * sunDot524288;\n\tfloat sunDot2097152 = sunDot1048576 * sunDot1048576;\n\tfloat sunDot4194304 = sunDot20", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This is the function that will be called for every pixel.\n// ro = ray origin\n// rd = ray direction\n// t = time\n// m = mouse\nvec3 render( in vec3 ro, in vec3 rd, in float t, in vec2 m )\n{\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 ) * rd;\n\n    // We need to transform the ray coming out of our eyes so that it goes through the window.\n    // We do this by using the matrix we calculated above.\n    rd = calculateEyeRayTransformationMatrix( ro, ta, 0.0 )", "\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n    vec3 balloonScale = vec3(1.0, 1.0, 1.0);\n    vec3 balloonRotation = vec3(0.0, 0.0, 0.0);\n    vec3 balloonColor = vec3(1.0, 1.0, 1.0);\n    float balloonRadius = 1.0;\n    float balloonThickness = 0.1;\n    float balloonSmoothness = 0.01;\n    float balloonSmoothness2 = 0.01;\n    float balloonSmoothness3 = 0.01;\n    float balloonSmoothness4 = 0.01;\n    float balloonSmoothness5 = 0.01;\n    float balloonSmoothness6 = 0.01;\n    float balloonSmoothness7 = 0.01;\n    float balloonSmoothness8 = 0.01;\n    float balloonSmoothness9 = 0.01;\n    float balloonSmoothness10 = 0.01;\n    float balloonSmoothness11 = 0.01;\n    float balloonSmoothness12 = 0.01;\n    float balloonSmoothness13 = 0.01;\n    float balloonSmoothness14 = 0.01;\n    float balloonSmoothness15 = 0.01;\n    float balloonSmoothness16 = 0.01;\n    float balloonSmoothness17 = 0.01;\n    float balloonSmoothness18 = 0.01;\n    float balloonSmoothness19 = 0.01;\n    float balloonSmoothness20 = 0.01;\n    float balloonSmoothness21 = 0.01;\n    float balloonSmoothness22 = 0.01;\n    float balloonSmoothness23 = 0.01;\n    float balloonSmoothness24 = 0.01;\n    float balloonSmoothness25 = 0.01;\n    float balloonSmoothness26 = 0.01;\n    float balloonSmoothness27 = 0.01", "\n\tfloat dist1 = distance(thing1,pos);\n\tfloat dist2 = distance(thing2,pos);\n\tif( dist1 < dist2 ){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3 ){\n\tfloat dist1 = distance(thing1,pos);\n\tfloat dist2 = distance(thing2,pos);\n\tfloat dist3 = distance(thing3,pos);\n\tif( dist1 < dist2 && dist1 < dist3 ){\n\t\treturn thing1;\n\t}else if( dist2 < dist1 && dist2 < dist3 ){\n\t\treturn thing2;\n\t}else{\n\t\treturn thing3;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3, vec2 thing4 ){\n\tfloat dist1 = distance(thing1,pos);\n\tfloat dist2 = distance(thing2,pos);\n\tfloat dist3 = distance(thing3,pos);\n\tfloat dist4 = distance(thing4,pos);\n\tif( dist1 < dist2 && dist1 < dist3 && dist1 < dist4 ){\n\t\treturn thing1;\n\t}else if( dist2 < dist1 && dist2 < dist3 && dist2 < dist4 ){\n\t\treturn thing2;\n\t}else if( dist3 < dist1 && dist3 < dist2 && dist3 < dist4 ){\n\t\treturn thing3;\n\t}else{\n\t\treturn thing4;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance", "\n    vec2 closestThing = vec2(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 smallStep = vec3(0.001,0.0,0.0);\n\tfloat x = getDistanceFromSurface(positionOfHit + smallStep.xyy);\n\tfloat y = getDistanceFromSurface(positionOfHit + smallStep.yxy);\n\tfloat z = getDistanceFromSurface(positionOfHit + smallStep.yyx);\n\treturn normalize(vec3(x,y,z) - getDistanceFromSurface(positionOfHit));\n}\n\n// This is the main function that is called to render the scene.\n// It is called for every pixel in the scene.\n// The function returns a vec4, which is the color of the pixel.\n// The vec4 is in the format of (Red, Green, Blue, Alpha)\n// Alpha is not used in this program, but is there if you want to do\n// some post processing effects.\nvec4 render( in vec2 fragCoord ){\n\t// This is the direction of the ray that is being cast.\n\t// It is a unit vector, meaning it is a vector with a length of 1.\n\t// This is important because it makes it easier to do math with it.\n\tvec3 directionOfRay = normalize(vec3(fragCoord, -1.0));\n\n\t// This is the position of the camera.\n\t// The camera is at the origin, and is looking down the negative z axis.\n\tvec3 positionOfCamera = vec3(0.0,0.0,0.0);\n\n\t// This is the position of the ray that is being cast.\n\t// It is the position of the camera, plus the direction of the ray.\n\t// This is the same as positionOfCamera + directionOfRay * 0.0\n\t// The 0.0 is the distance that the ray has traveled.\n\tvec3 positionOfRay = positionOfCamera;\n\n\t// This is the color of the pixel.\n\t// It is set to black, because we are going to add to it.\n\tvec4 colorOfPixel = vec4(0.0,0.0,0.0,1.0);\n\n\t// This is the distance that the ray has traveled.\n\t// It is set to 0.0, because we are going to add to it", "\n\treturn vec3(0.0);\n}\n\n// this is the main function that does the raymarching.\n// it's a bit of a mess, but it works.\n// the basic idea is that we step forward along the ray\n// and check to see if we've hit anything.\n// if we have, we return the color of that object.\n// if not, we return the background color.\nvec3 doRayMarching(vec3 ro, vec3 rd){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < MAX_STEPS; i++){\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = doDistance(p);\n\t\tif(d < EPSILON){\n\t\t\treturn doColor(p, rd);\n\t\t}\n\t\tt += d;\n\t\tif(t > MAX_DIST){\n\t\t\treturn doBackgroundColor();\n\t\t}\n\t}\n\treturn doBackgroundColor();\n}\n\n// this is the main function that does the actual rendering.\n// we just call doRayMarching() for each pixel.\nvoid main(){\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 4.0);\n\tvec3 rd = normalize(vec3(uv, -2.0));\n\tvec3 col = doRayMarching(ro, rd);\n\tgl_FragColor = vec4(col, 1.0);\n}\n/src/mod/pub/demo/gl-frag-shader-demo/res/fx-shaders/shadertoy/Spherical Harmonics.fsh\n// https://www.shadertoy.com/view/4d23D1\n// Spherical Harmonics\n// Created by  - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is a simple demo of spherical harmonics.\n//\n// The code is based on the following paper:\n//\n//\t\tSpherical Harmonic Lighting: The Gritty Details\n//\t\t,,, ", "\n\treturn normalOfSurface;\n}\n\n// This is the function that will be called for each pixel\n// on the screen.\n//\n// The \"fragCoord\" variable is the pixel's position on the screen.\n//\n// The \"fragColor\" variable is the color that will be displayed\n// on the screen.\n//\n// The \"iResolution\" variable is the resolution of the screen.\n//\n// The \"iTime\" variable is the time in seconds since the program\n// started.\n//\n// The \"iMouse\" variable is the position of the mouse.\n//\n// The \"iChannel0\" variable is the texture that is loaded in slot 0.\n//\n// The \"iChannel1\" variable is the texture that is loaded in slot 1.\n//\n// The \"iChannel2\" variable is the texture that is loaded in slot 2.\n//\n// The \"iChannel3\" variable is the texture that is loaded in slot 3.\n//\n// The \"iChannelResolution[0]\" variable is the resolution of the texture\n// that is loaded in slot 0.\n//\n// The \"iChannelResolution[1]\" variable is the resolution of the texture\n// that is loaded in slot 1.\n//\n// The \"iChannelResolution[2]\" variable is the resolution of the texture\n// that is loaded in slot 2.\n//\n// The \"iChannelResolution[3]\" variable is the resolution of the texture\n// that is loaded in slot 3.\n//\n// The \"iDate\" variable is the date in the format YYYY,MM,DD,TIME.\n//\n// The \"iSampleRate\" variable is the sample rate of the audio.\n//\n// The \"iChannelTime[0]\" variable is the time in seconds since the audio\n// was loaded in slot 0.\n//\n// The \"iChannelTime[1]\" variable is the time in seconds since the audio\n// was loaded in slot 1.\n//\n// The \"iChannelTime[2]\" variable is the time in seconds since the audio\n// was loaded in slot 2.\n//\n// The \"iChannelTime[3]\" variable is the time in seconds since the audio\n// was loaded in slot 3.\n//\n// The \"iChannelSampler[0]\" variable is the sampler state for", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = vec3(0.0);\n\tvec3 lightDirection = vec3(0.0);\n\tvec3 lightColor = vec3(0.0);\n\tvec3 lightPosition = vec3(0.0);\n\tvec3 lightAttenuation = vec3(0.0);\n\tvec3 lightIntensity = vec3(0.0);\n\tvec3 lightSpecular = vec3(0.0);\n\tvec3 lightDiffuse = vec3(0.0);\n\tvec3 lightAmbient = vec3(0.0);\n\tvec3 lightSpecularColor = vec3(0.0);\n\tvec3 lightDiffuseColor = vec3(0.0);\n\tvec3 lightAmbientColor = vec3(0.0);\n\tvec3 lightSpecularPower = vec3(0.0);\n\tvec3 lightDiffusePower = vec3(0.0);\n\tvec3 lightAmbientPower = vec3(0.0);\n\tvec3 lightSpecularIntensity = vec3(0.0);\n\tvec3 lightDiffuseIntensity = vec3(0.0);\n\tvec3 lightAmbientIntensity = vec3(0.0);\n\tvec3 lightSpecularAttenuation = vec3(0.0);\n\tvec3 lightDiffuseAttenuation = vec3(0.0);\n\tvec3 lightAmbientAttenuation = vec3(0.0);\n\tvec3 lightSpecularAttenuationFactor = vec3(0.0);\n\tvec3 lightDiffuseAttenuationFactor = vec3(0.0);\n\tvec3 lightAmbientAttenuationFactor = vec3(0.0);\n\tvec3 lightSpecularAttenuationDistance = vec3(0.0);\n\tvec3 lightDiffuseAttenuationDistance = vec3(0.0);\n\tvec3 lightAmbientAttenuationDistance = vec3(0.0);\n\tvec3 lightSpecularAttenuationDistanceFactor = vec3(0.0);\n\tvec3 lightDiffuseAttenuationDistanceFactor = vec3(0.0);\n\tvec3 lightAmbientAttenuationDistanceFactor = vec3(0.0);\n\tvec3 lightSpecularAttenuationDistanceSquared = vec3(0.0);\n\tvec3 lightDiffuseAttenuationDistanceSquared = vec3(0.", "\n    return x / ( ((1.0/b) - 2.0) * (1.0 - x) + 1.0);\n}\n\n// gain(x, g)\n// gains are like biases but with different curves\n// https://www.desmos.com/calculator/9o3239115t\n// if g is near 1.0 then the function is the identity\n// if g is near 0.0 then the function is similar to 1.0 - 2.0 * abs(x - 0.5)\n// if g is near 0.5 then the function is similar to bias(x, 0.5)\nfloat gain(float x, float g) {\n    if (x < 0.5) {\n        return bias(2.0 * x, g) / 2.0;\n    } else {\n        return 1.0 - bias(2.0 - 2.0 * x, 1.0 - g) / 2.0;\n    }\n}\n\n// smoothstep(x)\n// returns 0.0 if x <= 0.0 && x >= 1.0\n// else returns a smoothed value that starts at 0.0, passes through 0.5\n// and ends at 1.0\nfloat smoothstep(float x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// smoothstep(x, min, max)\n// returns 0.0 if x <= min && x >= max\n// else returns a smoothed value between min and max\nfloat smoothstep(float x, float min, float max) {\n    x = saturate((x - min) / (max - min));\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// smoothstep(x, min, max)\n// returns 0.0 if x <= min && x >= max\n// else returns a smoothed value between min and max\nfloat smoothstep(float x, float min, float max, float edge0, float edge1) {\n    x = saturate((x - min) / (max - min));\n    return smoothstep(x, edge0, edge", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 34.567))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 34.567, 12.123))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(int p){\n    return fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float t){\n    return fract(sin(dot(p, vec2(12.9898, 78.233)) + t) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float t){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 34.567)) + t) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p, float t){\n    return fr", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 0.999999;\n}\n\n// creates white noise in the range -1..1 including -1 including 1\nfloat rand_inclusive_signed(vec2 p){\n    return rand_inclusive(p) * 2.0 - 1.0;\n}\n\n// creates white noise in the range -1..1 excluding -1 excluding 1\nfloat rand_exclusive_signed(vec2 p){\n    return rand_exclusive(p) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 34.234))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 34.234))) * 43758.5453) * 0.999999;\n}\n\n// creates white noise in the range -1..1 including -1 including 1\nfloat rand_inclusive_signed(vec3 p){\n    return rand_inclusive(p) * 2.0 - 1.0;\n}\n\n// creates white noise in the range -1..1 excluding -1 excluding 1\nfloat rand_exclusive_signed(vec3 p){\n    return rand_exclusive(p) * 2.0 - 1.0;\n", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to radius of sphere\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input t --> is torus size\n// pretty simple, just compare point to radius of sphere\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input h --> is cylinder height\n// input r --> is cylinder radius\n// pretty simple, just compare point to radius of sphere\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input h --> is cone height\n// input r --> is cone radius\n// pretty simple, just compare point to radius of sphere\nfloat sdCone(vec3 p, float h, float r)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - h;\n    float d2 = max(dot(q, vec2(h, h)), q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input p --> is plane position\n// input n --> is plane normal\n// pretty simple, just compare point to radius of", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\n//  \n// think of the box as a cube with a hole in the middle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the box circumference/core/radius which is flat on the y axis\n// then simply subtract the box thickenss from that \nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\n//\ts.y = sphere center x\n//\ts.z = sphere center z\n//  \n// simply get the distance to the sphere center and subtract the sphere radius\nfloat sdSphere(vec3 p, vec3 s)\n{\n\treturn length(p - s) - s.x;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\n//  \n// simply get the distance to the cylinder center and subtract the cylinder radius\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\treturn length(p.xz) - c.x;\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input c --> cone specs where:\n// \tc.x = cone radius\n//\tc.y = cone height\n//  \n// simply get the distance to the cone center and subtract the cone radius\nfloat sdCone(vec3 p, vec2 c)\n{\n\t// c.x is the radius, c", "\n    float k = 0.01;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float n )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow(h,n) ) - k*pow(h,n)*(1.0-pow(h,n));\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float n, float m )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1", "\n    return min(d1,d2);\n}\n\n// ~~~~~~~ smooth union, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> blend factor\n// output --> blended object\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth intersection, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> blend factor\n// output --> blended object\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth subtraction, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> blend factor\n// output --> blended object\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth union, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> blend factor\n// output --> blended object\nfloat opSmoothBlend( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k,", "\n    float c = cos(t*p.y+yaw);\n    float s = sin(t*p.y+yaw);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ domain deformation, bends the shape\n// input p --> original ray position\n// input t --> bend scale factor\n// output --> bent ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opBend( vec3 p, float t, float yaw )\n{\n    float c = cos(t*p.x+yaw);\n    float s = sin(t*p.x+yaw);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n// ~~~~~~~ domain deformation, bends the shape\n// input p --> original ray position\n// input t --> bend scale factor\n// output --> bent ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opBend2( vec3 p, float t, float yaw )\n{\n    float c = cos(t*p.z+yaw);\n    float s = sin(t*p.z+yaw);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(p.x,m*p.yz);\n}\n\n// ~~~~~~~ domain deformation, bends the shape\n// input p --> original ray position\n// input t --> bend scale factor\n// output --> bent ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opBend3( vec3 p, float t, float yaw )\n{\n    float c = cos(t*p.y+yaw);\n    float s = sin(t*p.y+yaw);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ domain deformation, bends the shape\n//", "\n    if(o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Subtraction / remove 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n    if(o1.x > -o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Intersection / only show the overlapping part of 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o2;\n    else\n        return o1;\n}\n\n// ~~~~~~~ do Smooth Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opUS(vec2 o1, vec2 o2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (o2.x - o1.x) / k, 0.0, 1.0);\n    return vec2(mix(o2.x, o1.x, h) - k * h * (1.0 - h), o1.y);\n}\n\n// ~~~~~~~ do Smooth Subtraction / remove 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSS(vec2 o1, vec2 o2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (o2.x + o1.x) / k, 0.0, 1.0);\n    return vec2(mix(o2.x, -o1.x, h) +", "\n    // return vec2(sdSphere(p, 1.0), 1.0);\n    // return vec2(sdBox(p, vec3(1.0)), 1.0);\n    // return vec2(sdTorus(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdPlane(p, vec4(0, 1, 0, 0)), 1.0);\n    // return vec2(sdCappedCylinder(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCappedCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCappedCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdEllipsoid(p, vec3(1.0, 0.2, 0.5)), 1.0);\n    // return vec2(sdHexPrism(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdTriPrism(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCapsule(p, vec3(0, 0, 0), vec3(0, 1, 0), 0.2), 1.0);\n    // return vec2(sdCylinder(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2(sdCone(p, vec2(1.0, 0.2)), 1.0);\n    // return vec2", "\n\tfloat t = 0.0;\n\tfloat id = -1.0;\n\tfor( int i=0; i<MAX_STEPS; i++)\n\t{\n\t\tvec2 res = map( ro+rd*t );\n\t\tif( res.x<EPSILON || t>MAX_DIST ) break;\n\t\tt += res.x;\n\t\tid = res.y;\n\t}\n\treturn vec2( t, id );\n}\n\n// ~~~~~~~ calculate normal at a point\n// input p --> point\n// output is normal at point p\n//\nvec3 calcNormal( in vec3 p )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize( e.xyy*map( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ).x );\n}\n\n// ~~~~~~~ calculate soft shadows\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input t  --> distance travelled by ray\n// input k  --> softness factor\n// output is 1.0 if no shadow, 0.0 if in shadow\n//\nfloat softshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\n{\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t).x;\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// ~~~~~~~ calculate ambient occlusion\n// input p  --> point\n// input n  --> normal at point p\n// input k  --> soft", "\n    // ~~~~~~~ ray marching\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 h = vec3(0.0);\n    vec3 m = vec3(0.0);\n    vec3 e = vec3(0.0);\n    vec3 s = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 g = vec3(0.0);\n    vec3 f = vec3(0.0);\n    vec3 b = vec3(0.0);\n    vec3 o = vec3(0.0);\n    vec3 x = vec3(0.0);\n    vec3 y = vec3(0.0);\n    vec3 z = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 v = vec3(0.0);\n    vec3 u = vec3(0.0);\n    vec3 t2 = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    vec3 t4 = vec3(0.0);\n    vec3 t5 = vec3(0.0);\n    vec3 t6 = vec3(0.0);\n    vec3 t7 = vec3(0.0);\n    vec3 t8 = vec3(0.0);\n    vec3 t9 = vec3(0.0);\n    vec3 t10 = vec3(0.0);\n    vec3 t11 = vec3(0.0);\n    vec3 t12 = vec3(0.0);\n    vec3 t13 = vec3(0.0);\n    vec3 t14 = vec3(0.0);\n    vec3 t15 = vec3(0.0);\n    vec3 t16 = vec3(0.0);\n    vec3 t17 = vec3(0.0);\n    vec3 t18 = vec3(0.0);\n    vec3 t19 = vec3(0.0);\n    vec3 t20 = vec3(0.0", "\n    vec3 cw = normalize(targetPos-camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// ~~~~~~~ raymarching\n// input ro --> ray origin\n// input rd --> ray direction\n// input tmin --> ray start\n// input tmax --> ray end\n// output --> distance to surface\nfloat raymarch( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float t = tmin;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float h = map( ro + rd*t );\n        if( h<(EPSILON*t) || t>tmax ) break;\n        t += h;\n    }\n    return t;\n}\n\n// ~~~~~~~ normal\n// input p --> point on surface\n// output --> normal\nvec3 calcNormal( in vec3 p )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ) );\n}\n\n// ~~~~~~~ lighting\n// input p --> point on surface\n// input n --> normal\n// input rd --> ray direction\n// output --> color\nvec3 render( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    vec3 col = vec3(0.0);\n    vec3 sunDir = normalize( vec3(0.0,1.0,0.0) );\n    float sun = clamp( dot(n,sunDir), 0.0, 1.0 );\n    col = vec3(0.0,0.0,0.0);\n    col += 1.0*sun;\n    col += 0.5*pow(sun,8.0", "\n    if(id == 0.0)\n    {\n        return color0;\n    }\n    else if(id == 1.0)\n    {\n        return color1;\n    }\n    else if(id == 2.0)\n    {\n        return color2;\n    }\n    else if(id == 3.0)\n    {\n        return color3;\n    }\n    else if(id == 4.0)\n    {\n        return color4;\n    }\n    else if(id == 5.0)\n    {\n        return color5;\n    }\n    else if(id == 6.0)\n    {\n        return color6;\n    }\n    else if(id == 7.0)\n    {\n        return color7;\n    }\n    else if(id == 8.0)\n    {\n        return color8;\n    }\n    else if(id == 9.0)\n    {\n        return color9;\n    }\n    else if(id == 10.0)\n    {\n        return color10;\n    }\n    else if(id == 11.0)\n    {\n        return color11;\n    }\n    else if(id == 12.0)\n    {\n        return color12;\n    }\n    else if(id == 13.0)\n    {\n        return color13;\n    }\n    else if(id == 14.0)\n    {\n        return color14;\n    }\n    else if(id == 15.0)\n    {\n        return color15;\n    }\n    else if(id == 16.0)\n    {\n        return color16;\n    }\n    else if(id == 17.0)\n    {\n        return color17;\n    }\n    else if(id == 18.0)\n    {\n        return color18;\n    }\n    else if(id == 19.0)\n    {\n        return color19;\n    }\n    else if(id == 20.0)\n    {\n        return color20;\n    }\n    else if(id == 21.0)\n    {\n        return color21;\n    }\n    else if(id == 22.0)\n    {\n        return color22;\n    }\n    else if(id == 23.0)\n    {\n        return color23;\n    }\n    else if(id", "\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input b --> box specs where:\n//  b.x = box width\n//  b.y = box height\n//  b.z = box depth\n//  \nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input s --> sphere radius\n//  \nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\n//  \nfloat sdCylinder(vec3 p, vec2 c)\n{\n  return length(p.xz)-c.x;\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input c --> cone specs where:\n//  c.x = cone radius\n//  c.y = cone height\n//  \nfloat sdCone(vec3 p, vec2 c)\n{\n  // c.x is the radius\n  // c.y is the height\n  // p.y is the height\n  float q = length(p.xz);\n  return dot(c.xy,vec2(q,p.y));\n}\n\n// ~~~~~~~ signed distance function for a plane\n// input p --> plane specs where:\n//  p.x = plane width\n//  p.y = plane height\n//  p.z = plane depth\n//  \nfloat sdPlane(vec3 p, vec3 n)\n{\n  // n is the normal to the plane (not necessarily normalized)\n  return dot(p,n);\n}\n\n// ~~~~~~~ signed distance function for a triangle\n// input t --> triangle specs where:\n//  t.x = triangle width\n//  t.y", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> center x\n//        ps.z --> center z\n//        ps.w --> center y\nfloat sdSphere(vec3 p, vec4 ps)\n{\n    return length(p - ps.yzw) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size z\n//        ps.z --> center x\n//        ps.w --> center z\nfloat sdBox(vec3 p, vec4 ps)\n{\n    vec3 d = abs(p - ps.yzw) - ps.xy;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> center x\n//        ps.w --> center z\nfloat sdCylinder(vec3 p, vec4 ps)\n{\n    vec2 d = abs(vec2(length(p.xz - ps.yzw), p.y)) - vec2(ps.x, ps.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> thickness\n//        ps.z --> center x\n//        ps.w --> center z\nfloat sdTorus(vec3 p, vec4 ps)\n{\n    vec2 q = vec2(length(p.xz - ps.yzw) - ps.x, p.y);\n    return length(q) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin2( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax2( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, ", "\n    // blend distance\n    float d = mix(o1.x, o2.x, bf);\n    // blend color\n    vec3 c = mix(o1.yzw, o2.yzw, bf);\n    return vec4(d, c);\n}\n\n// ~~~~~~~ union, returns the closest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> closest dist, blended material color\nvec4 opU( vec4 o1, vec4 o2 )\n{\n    if( o1.x < o2.x )\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ intersection, returns the farthest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> farthest dist, blended material color\nvec4 opI( vec4 o1, vec4 o2 )\n{\n    if( o1.x > o2.x )\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ subtraction, returns the farthest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> farthest dist, blended material color\nvec4 opS( vec4 o1, vec4 o2 )\n{\n    if( o1.x > -o2.x )\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ smooth union, returns the closest distance\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input k --> blend factor\n// output --> closest dist, blended material color\nvec4 opSmoothU( vec4 o1, vec4 o2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(o2.x-o1.x)/k, 0.0, 1.0 );\n    float d = mix( o2.x, o1.x, h ) - k*", "\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opCut(float d1,float d2)\n{\n    return min(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opBlend(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opBlend2(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opBlend3(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tlightPos.x = cos(time) * 10.0;\n\tlightPos.y = 10.0;\n\tlightPos.z = sin(time) * 10.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos2()\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tlightPos.x = cos(time) * 10.0;\n\tlightPos.y = 10.0;\n\tlightPos.z = sin(time) * 10.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos3()\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tlightPos.x = cos(time) * 10.0;\n\tlightPos.y = 10.0;\n\tlightPos.z = sin(time) * 10.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos4()\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tlightPos.x = cos(time) * 10.0;\n\tlightPos.y = 10.0;\n\tlightPos.z = sin(time) * 10.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos5()\n{\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tlightPos.x = cos(time) * 10.0;\n\tlightPos.y = 10.0;\n\tlightPos.", "\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects", "\n    float t = 0.0;\n    float id = -1.0;\n    for( int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*t;\n        float d = map( p);\n        if( d<EPSILON)\n        {\n            id = mapID;\n            break;\n        }\n        t += d;\n        itterRatio += 1.0;\n    }\n    return vec4( t, id, itterRatio, 0.0);\n}\n\n// ~~~~~~~ calculate normal of a point on a surface\n// input p --> point on surface\n// output is normal of surface at point p\nvec3 calcNormal( in vec3 p)\n{\n    vec2 e = vec2( EPSILON, 0.0);\n    return normalize( vec3( map( p+e.xyy) - map( p-e.xyy),\n                            map( p+e.yxy) - map( p-e.yxy),\n                            map( p+e.yyx) - map( p-e.yyx)));\n}\n\n// ~~~~~~~ calculate lighting\n// input p --> point on surface\n// input n --> normal of surface at point p\n// input rd --> ray direction\n// input id --> object's ID\n// output is vec3 where\n// .x = ambient lighting\n// .y = diffuse lighting\n// .z = specular lighting\nvec3 calcLighting( in vec3 p, in vec3 n, in vec3 rd, in float id)\n{\n    vec3 lightPos = vec3( 0.0, 0.0, 0.0);\n    vec3 lightCol = vec3( 1.0, 1.0, 1.0);\n    vec3 lightDir = normalize( lightPos - p);\n    vec3 viewDir = normalize( -rd);\n    vec3 halfDir = normalize( lightDir + viewDir);\n    float diff = max( dot( n, lightDir), 0.0);\n    float spec = pow( max( dot( n, halfDir), 0.0), 16.0);\n    float ambi = 0.1;\n    return vec3( ambi, diff, spec);\n}\n\n// ~~~~~~~ calculate color of a point on", "\n    float shade = 1.0;\n    float dist = 0.0;\n    float end = max(0.0, length(lp - sp) - 0.01);\n    float step = 0.01;\n    for (int i = 0; i < 100; i++)\n    {\n        if (shade < 0.01 || dist > end) break;\n        dist += step;\n        float h = castRay_SDF(sp + lp * dist);\n        shade = min(shade, smoothstep(0.0, 1.0, 100.0 * h / dist));\n        step = 0.01 + 0.01 * h;\n    }\n    return clamp(shade, 0.0, 1.0);\n}\n\n// ~~~~~~~ castRay_AO, took pointers from iq's\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_AO(vec3 sp, vec3 lp)\n{\n    float ao = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = castRay_SDF(sp + h * lp);\n        ao += -(d - h) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 3.0 * ao, 0.0, 1.0);\n}\n\n// ~~~~~~~ castRay_Diffuse, took pointers from iq's\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output vec3 --> diffuse color\nvec3 castRay_Diffuse(vec3 sp, vec3 lp)\n{\n    vec3 norm = castRay_Normal(sp);\n    float dif = clamp(dot(norm, lp), 0.0, 1.0);\n    return vec3(dif);\n", "\n    float ao = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float h = map(sp + nor*0.05*float(i)).x;\n        ao += -(h-0.05*float(i))*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - 3.0*ao, 0.0, 1.0);\n}\n\n// ~~~~~~~ shadows\n// just cast from surface point in direction of light to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_Shadows(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for(int i=0; i<100; i++)\n    {\n        vec3 sp = ro + t*rd;\n        float h = map(sp).x;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.01, 0.1);\n        if(h<0.001) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ main\nvoid main()\n{\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n    {\n        vec3 sp = ro + t*rd;\n        vec", "\n\tvec3 n = vec3(0.0);\n\tfloat d = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d4", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyToneMapping(vec3 c)\n{\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    float toneMappedL = l / (1.0 + l);\n    return toneMappedL * c / l;\n}\n\n// ~~~~~~~ do exposure\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> exposure corrected output\nvec3 applyExposure(vec3 c)\n{\n    return 1.0 - exp(-c);\n}\n\n// ~~~~~~~ do color grading\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> color graded output\nvec3 applyColorGrading(vec3 c)\n{\n    return c * (6.2 * c + 0.5);\n}\n\n// ~~~~~~~ do vignette\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> vignette corrected output\nvec3 applyVignette(vec3 c)\n{\n    vec2 q = gl_FragCoord.xy / resolution.xy;\n    float vignette = smoothstep(0.8, 0.3, q.x * q.y * (1.0 - q.x) * (1.0 - q.y));\n    return c * vignette;\n}\n\n// ~~~~~~~ do bloom\n// from", "\n    float c1 = 0.0;\n    float c2 = 0.0;\n    float c3 = 0.0;\n    float c4 = 0.0;\n    float c5 = 0.0;\n    float c6 = 0.0;\n    float c7 = 0.0;\n    float c8 = 0.0;\n    float c9 = 0.0;\n    float c10 = 0.0;\n    float c11 = 0.0;\n    float c12 = 0.0;\n    float c13 = 0.0;\n    float c14 = 0.0;\n    float c15 = 0.0;\n    float c16 = 0.0;\n    float c17 = 0.0;\n    float c18 = 0.0;\n    float c19 = 0.0;\n    float c20 = 0.0;\n    float c21 = 0.0;\n    float c22 = 0.0;\n    float c23 = 0.0;\n    float c24 = 0.0;\n    float c25 = 0.0;\n    float c26 = 0.0;\n    float c27 = 0.0;\n    float c28 = 0.0;\n    float c29 = 0.0;\n    float c30 = 0.0;\n    float c31 = 0.0;\n    float c32 = 0.0;\n    float c33 = 0.0;\n    float c34 = 0.0;\n    float c35 = 0.0;\n    float c36 = 0.0;\n    float c37 = 0.0;\n    float c38 = 0.0;\n    float c39 = 0.0;\n    float c40 = 0.0;\n    float c41 = 0.0;\n    float c42 = 0.0;\n    float c43 = 0.0;\n    float c44 = 0.0;\n    float c45 = 0.0;\n    float c46 = 0.0;\n    float c47 = 0.0;\n    float c4", "\n\treturn 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates diffuse factor for light for a given normal and light direction\n// input lightDir --> normalized light direction\n// input normal --> normalized normal\n// input diffuseColor --> diffuse color of the object\n// input diffuseIntensity --> diffuse intensity of the object\nvec3 calculateDiffuse(vec3 lightDir, vec3 normal, vec3 diffuseColor, float diffuseIntensity)\n{\n\treturn diffuseIntensity * diffuseColor * max(0.0, dot(normal, lightDir));\n}\n\n// ~~~~~~~ calculates specular factor for light for a given normal, light direction, view direction and shininess\n// input lightDir --> normalized light direction\n// input normal --> normalized normal\n// input viewDir --> normalized view direction\n// input shininess --> shininess of the object\n// input specularColor --> specular color of the object\n// input specularIntensity --> specular intensity of the object\nvec3 calculateSpecular(vec3 lightDir, vec3 normal, vec3 viewDir, float shininess, vec3 specularColor, float specularIntensity)\n{\n\tvec3 halfwayDir = normalize(lightDir + viewDir);\n\treturn specularIntensity * specularColor * pow(max(0.0, dot(normal, halfwayDir)), shininess);\n}\n\n// ~~~~~~~ calculates the color of the object for a given light\n// input light --> light to calculate the color for\n// input normal --> normalized normal\n// input viewDir --> normalized view direction\n// input diffuseColor --> diffuse color of the object\n// input diffuseIntensity --> diffuse intensity of the object\n// input specularColor --> specular color of the object\n// input specularIntensity --> specular intensity of the object\n// input shininess --> shininess of the object\n// input attenuation --> attenuation factor of the light\nvec3 calculateLightColor(Light light, vec3 normal, vec3 viewDir, vec3 diffuseColor, float diffuseIntensity, vec3 specularColor, float specularIntensity, float shininess, float attenuation)\n{\n\tvec3 lightDir = normalize(light.position - v_position);\n\tvec3 diffuse = calculateDiffuse(lightDir, normal, diffuseColor, diffuseIntensity);\n\tvec3 specular = calculateSpecular(lightDir, normal, view", "\n    vec3 rayDir = vec3(fCoord.xy, -1.0);\n    rayDir = cMatrix * rayDir;\n    return normalize(rayDir);\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrg(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrg = vec3(fCoord.xy, 0.0);\n    rayOrg = cMatrix * rayOrg;\n    return rayOrg;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nRay calculateRay(vec2 fCoord, mat3 cMatrix)\n{\n    Ray ray;\n    ray.org = calculateRayOrg(fCoord, cMatrix);\n    ray.dir = calculateRayDir(fCoord, cMatrix);\n    return ray;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nRay calculateRay(vec2 fCoord, mat3 cMatrix, float z)\n{\n    Ray ray;\n    ray.org = calculateRayOrg(fCoord, cMatrix);\n    ray.dir = calculateRayDir(fCoord, cMatrix);\n    ray.org.z = z;\n    return ray;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nRay calculateRay(vec2 fCoord, mat3 cMatrix, vec3 org)\n{\n    Ray ray;\n    ray.org = org;\n    ray.dir = calculateRayDir(fCoord, cMatrix);\n    return ray;\n}\n\n// ~~~~~~~ generate camera ray, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray\nRay calculateRay(vec2 fCoord, mat3 cMatrix, vec3 org, float z)\n{\n    Ray ray;\n    ray.org = org;\n    ray.dir = calculateRayDir(fCoord, c", "\n    vec3 col = vec3(0.0);\n    float itt = 0.0;\n    float ittMax = 10.0;\n    float ittMax2 = ittMax*ittMax;\n    float ittMax3 = ittMax2*ittMax;\n    float ittMax4 = ittMax3*ittMax;\n    float ittMax5 = ittMax4*ittMax;\n    float ittMax6 = ittMax5*ittMax;\n    float ittMax7 = ittMax6*ittMax;\n    float ittMax8 = ittMax7*ittMax;\n    float ittMax9 = ittMax8*ittMax;\n    float ittMax10 = ittMax9*ittMax;\n    float ittMax11 = ittMax10*ittMax;\n    float ittMax12 = ittMax11*ittMax;\n    float ittMax13 = ittMax12*ittMax;\n    float ittMax14 = ittMax13*ittMax;\n    float ittMax15 = ittMax14*ittMax;\n    float ittMax16 = ittMax15*ittMax;\n    float ittMax17 = ittMax16*ittMax;\n    float ittMax18 = ittMax17*ittMax;\n    float ittMax19 = ittMax18*ittMax;\n    float ittMax20 = ittMax19*ittMax;\n    float ittMax21 = ittMax20*ittMax;\n    float ittMax22 = ittMax21*ittMax;\n    float ittMax23 = ittMax22*ittMax;\n    float ittMax24 = ittMax23*ittMax;\n    float ittMax25 = ittMax24*ittMax;\n    float ittMax26 = ittMax25*ittMax;\n    float ittMax27 = ittMax26*ittMax;\n    float ittMax28 = ittMax27*ittMax;\n    float ittMax29 = ittMax28*ittMax;\n    float ittMax30 = ittMax29*ittMax;\n    float it", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iGlobalTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}/src/main/java/com/sparkx120/shadertoy/ShaderToy.java\npackage com.sparkx120.shadertoy;\n\nimport com.sparkx120.shadertoy.shader.Shader;\nimport com.sparkx120.shadertoy.shader.ShaderException;\nimport com.sparkx120.shadertoy.shader.ShaderLoader;\nimport com.sparkx120.shadertoy.shader.ShaderProgram;\nimport com.sparkx120.shadertoy.shader.ShaderProgramException;\nimport com.sparkx120.shadertoy.shader.ShaderProgramLoader;\nimport com.sparkx120.shadertoy.shader.ShaderType;\nimport com.sparkx120.shadertoy.shader.ShaderUtil;\nimport com.sparkx120.shadertoy.shader.ShaderVersion;\nimport com.sparkx120.shadertoy.shader.ShaderVersionException;\nimport com.sparkx120.shadertoy.shader.ShaderVersionLoader;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil.ShaderVersionData;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil.ShaderVersionData.ShaderVersionDataBuilder;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil.ShaderVersionData.ShaderVersionDataBuilder.ShaderVersionDataBuilderImpl;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil.ShaderVersionData.ShaderVersionDataBuilder.ShaderVersionDataBuilderImpl.ShaderVersionDataBuilderImplImpl;\nimport com.sparkx120.shadertoy.shader.ShaderVersionUtil.ShaderVersionData.ShaderVersionDataBuilder.ShaderVersionDataBuilderImpl.ShaderVersionDataBuilderImplImpl", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 radius)\n{\n    return length(p.xz) - radius.x;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - radius.y;\n    float d2 = max(dot(q, radius.yx), q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n// ---- operations on distance fields ----\n// union of two distance fields\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n// subtraction of two distance fields\nfloat opS(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\n// intersection of two distance fields\nfloat opI(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n// ---- distance field operations on a single shape ----\n// repeat a distance field in a grid\nfloat opRep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return sdBox(q, vec3(0.1));", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// simple torus distance field\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// simple cone distance field\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\n// simple plane distance field\nfloat plane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\n// simple hexagonal prism distance field\nfloat hexPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\n// simple triangular prism distance field\nfloat triPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\n// simple capsule distance field\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0", "\n    vec2 d = vec2(1000000.0, 0.0);\n    d = min(d, DistanceToPlane(p, vec3(0.0, 1.0, 0.0), 0.0));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0)));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0)));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0)));\n    return d;\n}\n\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p, float t)\n{\n    vec2 d = vec2(1000000.0, 0.0);\n    d = min(d, DistanceToPlane(p, vec3(0.0, 1.0, 0.0), 0.0));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0)));\n    d = min(d, DistanceToBox(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)));\n    d = min(d, DistanceTo", "\n\tvec2 c2 = complexMultiply(c, c);\n\tvec2 c3 = complexMultiply(c2, c);\n\tvec2 c4 = complexMultiply(c3, c);\n\tvec2 c5 = complexMultiply(c4, c);\n\treturn c5;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n\tvec2 c2 = complexMultiply(c, c);\n\tvec2 c3 = complexMultiply(c2, c);\n\tvec2 c4 = complexMultiply(c3, c);\n\tvec2 c5 = complexMultiply(c4, c);\n\tvec2 c6 = complexMultiply(c5, c);\n\treturn c6;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n\tvec2 c2 = complexMultiply(c, c);\n\tvec2 c3 = complexMultiply(c2, c);\n\tvec2 c4 = complexMultiply(c3, c);\n\tvec2 c5 = complexMultiply(c4, c);\n\tvec2 c6 = complexMultiply(c5, c);\n\tvec2 c7 = complexMultiply(c6, c);\n\treturn c7;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n\tvec2 c2 = complexMultiply(c, c);\n\tvec2 c3 = complexMultiply(c2, c);\n\tvec2 c4 = complexMultiply(c3, c);\n\tvec2 c5 = complexMultiply(c4, c);\n\tvec2 c6 = complexMultiply(c5, c);\n\tvec2 c7 = complexMultiply(c6, c);\n\tvec2 c8 = complexMultiply(c7, c);\n\treturn c8;\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n\tvec2 c2 = complexMultiply(c, c);\n\tvec2 c3 = complexMultiply(c2, c);\n\tvec2 c4 = complexMultiply(c3, c);\n\t", "\n\tvec2 z = coord;\n\tvec2 c = morphConstant;\n\tvec2 z0 = z;\n\tvec2 z1 = z;\n\tvec2 z2 = z;\n\tvec2 z3 = z;\n\tvec2 z4 = z;\n\tvec2 z5 = z;\n\tvec2 z6 = z;\n\tvec2 z7 = z;\n\tvec2 z8 = z;\n\tvec2 z9 = z;\n\tvec2 z10 = z;\n\tvec2 z11 = z;\n\tvec2 z12 = z;\n\tvec2 z13 = z;\n\tvec2 z14 = z;\n\tvec2 z15 = z;\n\tvec2 z16 = z;\n\tvec2 z17 = z;\n\tvec2 z18 = z;\n\tvec2 z19 = z;\n\tvec2 z20 = z;\n\tvec2 z21 = z;\n\tvec2 z22 = z;\n\tvec2 z23 = z;\n\tvec2 z24 = z;\n\tvec2 z25 = z;\n\tvec2 z26 = z;\n\tvec2 z27 = z;\n\tvec2 z28 = z;\n\tvec2 z29 = z;\n\tvec2 z30 = z;\n\tvec2 z31 = z;\n\tvec2 z32 = z;\n\tvec2 z33 = z;\n\tvec2 z34 = z;\n\tvec2 z35 = z;\n\tvec2 z36 = z;\n\tvec2 z37 = z;\n\tvec2 z38 = z;\n\tvec2 z39 = z;\n\tvec2 z40 = z;\n\tvec2 z41 = z;\n\tvec2 z42 = z;\n\tvec2 z43 = z;\n\tvec2 z44 = z;\n\tvec2 z45 = z;\n\tvec2 z46 = z;\n\tvec2 z47 = z;\n\tvec2 z48 = z;\n\tvec2 z49 = z;\n\tvec2 z", "\n\tvec4 color = vec4(0.0);\n\tfloat totalWeight = 0.0;\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 offset = vec2(float(i%2), float(i/2)) * 0.25;\n\t\tvec2 sampleUV = uv + offset;\n\t\tvec4 sampleColor = biomorph(sampleUV, constant);\n\t\tfloat weight = 1.0 - length(offset);\n\t\tcolor += sampleColor * weight;\n\t\ttotalWeight += weight;\n\t}\n\treturn color / totalWeight;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec2 constant = vec2(0.0, 0.0);\n\tvec4 color = antiAliasedBiomorph(uv, constant);\n\tgl_FragColor = color;\n}/src/main/java/com/hypeirochus/scmc/gui/GuiHandler.java\npackage com.hypeirochus.scmc.gui;\n\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph2;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph3;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph4;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph5;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph6;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph7;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph8;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph9;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph10;\nimport com.hypeirochus.scmc.gui.container.ContainerBiomorph11;\nimport com.hypeiro", "\n    return x - floor(x);\n}\n\nfloat triangle(float x) {\n    return abs(repeat(x) - 0.5) * 2.0;\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * scale - 0.5 * scale;\n\n    float q = fbm(p - time * 0.1);\n\n    // Move\n    vec2 r = vec2(fbm(p + q + time * 0.7 - p.x - p.y),\n                  fbm(p + q - time * 0.3));\n\n    // Change scale\n    vec2 s = vec2(fbm(p + r), fbm(p - r));\n    s = mix(vec2(0), s, 0.75);\n\n   ", "\n\t// Get the distance from the line\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 relUV = uv - pA;\n\tfloat dist = abs(dot(relUV, perp));\n\t// Get the distance from the end points\n\tfloat distA = length(relUV);\n\tfloat distB = length(relUV - dir);\n\t// Get the distance from the line thickness\n\tfloat distThick = abs(dist - thick.y) - thick.x;\n\t// Get the distance from the rounded end points\n\tfloat distRound = min(distA, distB) - rounded;\n\t// Get the distance from the dashed line\n\tfloat distDash = abs(mod(distA, dashOn) - dashOn * 0.5);\n\t// Get the final distance\n\treturn min(min(distThick, distRound), distDash);\n}\n\n// This is the same as the above function, but it will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n\treturn LineDistField(uv, pA, pB, thick, rounded, 1.0);\n}\n\n// This is the same as the above function, but it will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed", "\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 m = mix(pA, pB, 0.5);\n\tfloat d = abs(dot(uv - m, perp));\n\tfloat r = length(pA - pB) * rounded;\n\treturn smoothstep(thick.x - r, thick.x + r, d) - smoothstep(thick.y - r, thick.y + r, d);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn FillLinePix(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick) {\n\treturn FillLinePix(uv, pA, pB, vec2(thick, thick), 0.0);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB) {\n\treturn FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float rounded2) {\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 m = mix(pA, pB, 0.5);\n\tfloat d = abs(dot(uv - m, perp));\n\tfloat r = length(pA - pB) *", "\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 pA_in = pA - perp * thick;\n\tvec2 pB_in = pB - perp * thick;\n\tvec2 pA_out = pA + perp * thick;\n\tvec2 pB_out = pB + perp * thick;\n\tfloat d = DrawLine(uv, pA_in, pB_in, rounded);\n\td = min(d, DrawLine(uv, pA_out, pB_out, rounded));\n\td = min(d, DrawLine(uv, pA_in, pA_out, rounded));\n\td = min(d, DrawLine(uv, pB_in, pB_out, rounded));\n\treturn d;\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n\treturn DrawOutlinePix(uv, pA, pB, vec2(thick), rounded, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float outlineThick) {\n\treturn DrawOutlinePix(uv, pA, pB, vec2(thick), 0.0, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float outlineThick) {\n\treturn DrawOutlinePix(uv, pA, pB, vec2(1.0), 0.0, outlineThick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 p", "\n\tvec2 dir = pB - pA;\n\tvec2 normal = vec2(-dir.y, dir.x);\n\tvec2 center = (pA + pB) * 0.5;\n\tvec2 d = uv - center;\n\tfloat dist = abs(dot(d, normal));\n\tfloat line = 1.0 - smoothstep(thick.x, thick.y, dist);\n\tfloat radius = 0.5 * length(pB - pA);\n\tfloat round = 1.0 - smoothstep(radius - rounded, radius + rounded, length(d));\n\treturn line * round;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat StrokeLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n\tvec2 dir = pB - pA;\n\tvec2 normal = vec2(-dir.y, dir.x);\n\tvec2 center = (pA + pB) * 0.5;\n\tvec2 d = uv - center;\n\tfloat dist = abs(dot(d, normal));\n\tfloat line = smoothstep(thick.x, thick.y, dist);\n\tfloat radius = 0.5 * length(pB - pA);\n\tfloat round = 1.0 - smoothstep(radius - rounded, radius + rounded, length(d));\n\treturn line * round;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn FillLine(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat StrokeLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn StrokeLine(uv, pA, pB, vec2(thick,", "\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = pA + dir * uv.x;\n\tfloat d = abs(dot(p - pA, perp));\n\tfloat t = abs(dot(p - pA, dir));\n\tfloat l = length(dir);\n\tfloat dash = 0.0;\n\tif (t < l) {\n\t\tdash = 1.0;\n\t}\n\treturn smoothstep(thick.x, thick.x + rounded, d) * (1.0 - smoothstep(thick.y, thick.y + rounded, d)) * dash;\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn FillLineDash(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick) {\n\treturn FillLineDash(uv, pA, pB, vec2(thick, thick), 0.0);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB) {\n\treturn FillLineDash(uv, pA, pB, 0.0);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dash) {\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n", "\n\tvec2 dir = pB - pA;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 pA_uv = pA / thick;\n\tvec2 pB_uv = pB / thick;\n\tvec2 pA_perp = pA_uv + perp;\n\tvec2 pB_perp = pB_uv + perp;\n\tvec2 pA_perp_rounded = pA_perp + rounded * perp;\n\tvec2 pB_perp_rounded = pB_perp + rounded * perp;\n\tvec2 pA_perp_rounded_thick = pA_perp_rounded + outlineThick * perp;\n\tvec2 pB_perp_rounded_thick = pB_perp_rounded + outlineThick * perp;\n\tfloat d = 1.0;\n\td = min(d, DrawLine(uv, pA_uv, pA_perp_rounded_thick));\n\td = min(d, DrawLine(uv, pA_perp_rounded_thick, pB_perp_rounded_thick));\n\td = min(d, DrawLine(uv, pB_perp_rounded_thick, pB_uv));\n\td = min(d, DrawLine(uv, pB_uv, pB_perp));\n\td = min(d, DrawLine(uv, pB_perp, pA_perp));\n\td = min(d, DrawLine(uv, pA_perp, pA_perp_rounded));\n\td = min(d, DrawLine(uv, pA_perp_rounded, pA_uv));\n\treturn d;\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float outlineThick) {\n\treturn DrawOutline(uv, pA, pB, thick, 0.0, outlineThick);\n}\n\n// This makes an outlined line in UV units. A 1.", "\n\tfloat d = length(uv - p);\n\tcol = mix(col, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.005, d));\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.0);\n\n\t// Draw the grid.\n\tfor (int x = 0; x < 10; x++) {\n\t\tfor (int y = 0; y < 10; y++) {\n\t\t\tvec2 p = vec2(float(x) / 10.0, float(y) / 10.0);\n\t\t\tDrawPoint(uv, p, col);\n\t\t}\n\t}\n\n\t// Draw the points.\n\tfor (int i = 0; i < 10; i++) {\n\t\tvec2 p = points[i];\n\t\tDrawPoint(uv, p, col);\n\t}\n\n\t// Draw the lines.\n\tfor (int i = 0; i < 9; i++) {\n\t\tvec2 p0 = points[i];\n\t\tvec2 p1 = points[i + 1];\n\t\tcol = mix(col, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(uv - p0)));\n\t\tcol = mix(col, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(uv - p1)));\n\t}\n\n\tgl_FragColor = vec4(col, 1.0);\n}\n/src/shaders/001.frag\n#version 150\n\nuniform vec2 iResolution;\nuniform float iTime;\n\nout vec4 fragColor;\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.0);\n\n\t// Draw a circle.\n\tvec2 center = vec2(0.5, ", "\n    float h = dot(rd,nor);\n    float d = dot(cen-ro,nor);\n    float t = d/h;\n    vec3 p = ro + t*rd;\n    float l = length(p-cen);\n    return (l<rad)? t : -1.0;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 nor )\n{\n    float h = dot(rd,nor);\n    float d = dot(nor,ro);\n    return (h<0.0)? -d/h : -1.0;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return (tN>tF || tF<0.0)? -1.0 : tN;\n}\n\n// ray-cylinder intersection\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad )\n{\n    vec3  d = ro - cen;\n    float b = dot(rd,d);\n    float c = dot(d,d) - dot(rad,rad);\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// ray-cone intersection\nfloat iCone( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad )\n{\n    vec3  d = ro - cen;\n    float b = dot(rd,d);\n    float c = dot(d,d) - dot(rad,rad);\n    float h = b*b - c;\n    if( h<0.", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in vec3 dir ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    if( dir.x > 0.0 ) tN = max( tN, 0.0 );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in vec3 dir, in vec3 dir2 ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2", "\n    vec3 d = pb - pa;\n    float r2 = ra*ra;\n    float a2 = dot(d,d);\n    float b2 = 2.0*dot(pa,d);\n    float c = dot(pa,pa) - r2;\n    float h2 = b2*b2 - 4.0*a2*c;\n    if( h2<0.0 ) return bound3( vec3(0.0), vec3(0.0) );\n    h2 = sqrt(h2);\n    float a = (-b2 - h2) / (2.0*a2);\n    float b = (-b2 + h2) / (2.0*a2);\n    if( a>b ) swap(a,b);\n    vec3 pa2 = pa + a*d;\n    vec3 pb2 = pa + b*d;\n    return bound3( vec3( min(pa2.x,pb2.x)-ra, min(pa2.y,pb2.y)-ra, min(pa2.z,pb2.z)-ra ),\n                   vec3( max(pa2.x,pb2.x)+ra, max(pa2.y,pb2.y)+ra, max(pa2.z,pb2.z)+ra ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a torus (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TorusAABB( in vec3 p, in float ra, in float rb )\n{\n    vec2 d = vec2( length(p.xz)-ra, p.y );\n    float b = length(d) - rb;\n    vec3 r = vec3( rb, length(p.xz)-ra, 0.0 );\n    return bound3( p - r, p + r );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 p, in vec3 b )\n{\n    return bound3( p-b, p+b );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p-vec3(r", "\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float r = ra*ra;\n    float d = (baba*rdoa - bard*baoa)*(baba*rdoa - bard*baoa) - r*(baba*(oaoa-r) - baoa*baoa);\n    if( d<0.0 ) return vec4(-1.0); // no intersection\n    d = sqrt(d);\n    float t1 = (baba*rdoa - bard*baoa - d) / (baba*baba);\n    float t2 = (baba*rdoa - bard*baoa + d) / (baba*baba);\n    if( t1>0.0 )\n    {\n        vec3 ip = ro + t1*rd;\n        vec3 n = normalize(ip - pa - ba*clamp( dot(ip-pa,ba)/baba, 0.0, 1.0 ));\n        return vec4(t1,n);\n    }\n    else if( t2>0.0 )\n    {\n        vec3 ip = ro + t2*rd;\n        vec3 n = normalize(ip - pa - ba*clamp( dot(ip-pa,ba)/baba, 0.0, 1.0 ));\n        return vec4(t2,n);\n    }\n    return vec4(-1.0);\n}\n\n// ray-plane intersection (returns t)\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float d )\n{\n    float t = -(dot(ro,n) + d) / dot(rd,n);\n    return t;\n}\n\n// ray-box intersection (returns t and normal)\nvec4 iBox( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - m*bmin;", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad ) \n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-cylinder intersection\nvec2 iCylinder( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 dir, float rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot( rd, dir );\n    float b = dot( oc, dir );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( (-b-h)/a, (-b+h)/a );\n}\n\n// ray-cone intersection\nvec2 iCone( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 dir, float rad ) \n{\n    vec3 oc = ro - cen;\n    float a = dot( rd, dir );\n    float b = dot( oc, dir );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - a*c;\n    if( h", "\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float b = dot( rd, ba );\n    float c = dot( ba, ba );\n    float ta = dot( oa, rd );\n    float tb = dot( oa, ba );\n    float d = ta*ta + b*b*c - tb*tb;\n    if( d<0.0 ) return -1.0;\n    d = sqrt( d );\n    float t = ( -b*tb + c*ta - d ) / ( b*b - c );\n    if( t<0.0 ) return -1.0;\n    return t;\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r, in float h )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float b = dot( rd, ba );\n    float c = dot( ba, ba );\n    float ta = dot( oa, rd );\n    float tb = dot( oa, ba );\n    float d = ta*ta + b*b*c - tb*tb;\n    if( d<0.0 ) return -1.0;\n    d = sqrt( d );\n    float t = ( -b*tb + c*ta - d ) / ( b*b - c );\n    if( t<0.0 ) return -1.0;\n    float y = (ta + t*b - tb) / c;\n    if( y<0.0 || y>h ) return -1.0;\n    return t;\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r, in float h, in float t )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float b = dot( rd, ba );\n    float c = dot( ba, ba );\n    float ta = dot(", "\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return normalize( pa - ba*h );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in vec3 c, in float r )\n{\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = clamp( dot(pa,ca)/dot(ca,ca), 0.0, 1.0 );\n    return normalize( pa - ba*h - ca*d );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float r )\n{\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 da = d - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d1 = clamp( dot(pa,ca)/dot(ca,ca), 0.0, 1.0 );\n    float d2 = clamp( dot(pa,da)/dot(da,da), 0.0, 1.0 );\n    return normalize( pa - ba*h - ca*d1 - da*d2 );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in float r )\n{\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 da = d - a;\n    vec3 ea = e - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d1 = clamp( dot(pa,ca", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 box ) \n{\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 box, in vec3 box2 ) \n{\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n", "\n    float h = 0.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        if( h<MIN_DIST || t>MAX_DIST ) break;\n        vec3 p = ro + t*rd;\n        h = map( p );\n        t += h;\n    }\n\n    if( t<MAX_DIST )\n    {\n        res = t;\n        id = 1.0;\n    }\n\n    return vec4( res, id, 0.0, 0.0 );\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// lighting\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr", "\n    float phi = 2.0 * PI * (i + 0.5) / n;\n    float cosTheta = 1.0 - (2.0 * i) / n;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 inverseSF(vec3 dir)\n{\n    float phi = atan(dir.y, dir.x);\n    if (phi < 0.0) phi += 2.0 * PI;\n    float cosTheta = dir.z;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float theta = acos(cosTheta);\n    float f = (2.0 * PI) / (2.0 * PI * sinTheta);\n    float i = floor(f * theta);\n    return vec3(i, phi, theta);\n}\n\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF(vec3 dir)\n{\n    vec3 inv = inverseSF(dir);\n    return forwardSF(inv.x, inv.z);\n}\n\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 inverseSF(float i, float n)\n{\n    vec3 dir = forwardSF(i, n);\n    return inverseSF(dir);\n}\n\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF(float i, float n, float phi)\n{\n    vec3 dir = forwardSF(i, n);\n    float theta = acos(dir.z);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\n// http://lgdv.cs.fa", "\n\tvec4 res = vec4(-1.0);\n\tfloat t = 0.0;\n\tfor( int i=0; i<128; i++ )\n\t{\n\t\tif( t>100.0 ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\tres = col;\n\t\tif( col.w>0.001 ) break;\n\t\tt += col.w;\n\t}\n\tif( t>100.0 ) res = vec4(-1.0);\n\treturn res;\n}\n\n// lighting\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).w;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n\tvec3 epsv = vec3(eps,0.0,0.0);\n\tvec3 nor = vec3(\n\t    map(pos+epsv.xyy).w - map(pos", "\n    // Permutation polynomial: (34x^2 + x) mod 289\n    vec3 x = fract(p.xyx * vec3(34.0, 34.0, 34.0));\n    x = 34.0 * x * x - 2.0 * x * x * x;\n    vec3 i = floor(x + dot(x, vec3(0.0, 1.0, 1.0)));\n    vec3 y = fract(i * vec3(1.0, 1.0, 1.0));\n    vec3 z = 1.0 - 2.0 * abs(y - 0.5);\n    vec3 w = z * z * z * (z * (z * 6.0 - 15.0) + 10.0);\n    vec3 i1 = min(i, vec3(1.0));\n    vec3 i2 = max(i, vec3(1.0));\n    vec3 i3 = min(i2, vec3(2.0));\n    vec3 i4 = max(i2, vec3(2.0));\n    vec3 i5 = min(i4, vec3(3.0));\n    vec3 i6 = max(i4, vec3(3.0));\n    vec3 i7 = min(i6, vec3(4.0));\n    vec3 i8 = max(i6, vec3(4.0));\n    vec3 i9 = min(i8, vec3(5.0));\n    vec3 i10 = max(i8, vec3(5.0));\n    vec3 i11 = min(i10, vec3(6.0));\n    vec3 i12 = max(i10, vec3(6.0));\n    vec3 i13 = min(i12, vec3(7.0));\n    vec3 i14 = max(i12, vec3(7.0));\n    vec3 i15 = min(i14, vec3(8.0));\n    vec3 i16 = max(i14, vec3(8.0));\n    vec3 i17 = min(i16, vec3(9.0));", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge2(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge3(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge4(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge5(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge6(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h", "\n    vec2 uv2 = uv;\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n    uv2 *= 2.0;\n    uv2 = mod(uv2, 1.0);\n    uv2 -= 0.5;\n    uv2 *= 2.0;\n    uv2 = abs(uv2);\n    uv2 = min(uv2, 1.0 - uv2);\n    uv2 = smoothstep(0.0, 0.5, uv2);\n    uv2 = 1.0 - uv2;\n    uv2 *= orient;\n    return uv2;\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n    uv2 *= 2.0;\n    uv2 = mod(uv2, 1.0);\n    uv2 -= 0.5;\n    uv2 *= 2.0;\n    uv2 = abs(uv2);\n    uv2 = min(uv2, 1.0 - uv2);\n    uv2 = smoothstep(0.0, 0.5, uv2);\n    uv2 = 1.0 - uv2;\n    uv2 *= orient;\n    return uv2;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n    uv2 *= 2.0;\n    uv2 = mod(uv2, 1.0);\n    uv2 -= 0.5;\n    uv2 *= 2.0;\n    uv2 = abs(uv2);\n    uv2 = min(uv2, 1.0 - uv2);\n    uv2 = smoothstep(0.0, 0.5, uv2);\n    uv2 = 1.0 - uv2;\n    uv2 *= orient;\n    return uv2;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x += 0.5;\n    uv2.", "\n    vec2 uv2 = uv;\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n    uv2 *= 2.0;\n    uv2 = mod(uv2, 1.0);\n    uv2 = abs(uv2 - 0.5);\n    uv2 = orient * uv2;\n    float d = length(uv2);\n    float a = atan(uv2.y, uv2.x);\n    float f = 0.0;\n    f += 0.5 * smoothstep(0.0, 0.01, d);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.05);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.1);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.15);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.2);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.25);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.3);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.35);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.4);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.45);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.5);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.55);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.6);\n    f += 0.5 * smoothstep(0.0, 0.01, d - 0.65);\n    f += 0.5 *", "\n    vec2 w = max(abs(ddx),abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b),1.0))*(0.5/w);\n    return i.x*i.y;\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx),abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b),1.0))*(0.5/w);\n    return i.x*i.y;\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p )\n{\n    vec2 w = vec2(0.5);\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b),1.0))*(0.5/w);\n    return i.x*i.y;\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p, in vec2 w )\n{\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b),1.0))*(0.5/w);\n    return i.x*i.y;\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p, in vec2 w, in vec2 ddx, in vec2 ddy )\n{\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b),1.0))*(0.5/w);\n    return i.x*i.y;\n}\n\n// grid ratio\nfloat gridTexture(", "\n    vec3 grad = vec3(0.0);\n    float h = 0.001;\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        grad += e*map( p + h*e );\n    }\n    return grad*(1.0/h);\n}\n\n// raymarch along a ray from origin with direction dir\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n    float h = 0.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        if( h<0.001 || t>10.0 ) break;\n        h = map(ro+rd*t);\n        t += h;\n    }\n    if( t>10.0 ) t=-1.0;\n    return t;\n}\n\n// normal at a point\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// lighting\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0", "\n\tv33 c=a;\n\ta.x=c.x;\n\ta.y=c.z;\n\ta.z=c.y;\n\tb.x=c.z;\n\tb.y=c.y;\n\tb.z=c.x;\n}\n\n//this is the main function that does the raytracing:\nvoid rayTrace(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e,inout v33 f,inout v33 g,inout v33 h,inout v33 i,inout v33 j,inout v33 k,inout v33 l,inout v33 m,inout v33 n,inout v33 o,inout v33 p,inout v33 q,inout v33 r,inout v33 s,inout v33 t,inout v33 u,inout v33 v,inout v33 w,inout v33 x,inout v33 y,inout v33 z,inout v33 A,inout v33 B,inout v33 C,inout v33 D,inout v33 E,inout v33 F,inout v33 G,inout v33 H,inout v33 I,inout v33 J,inout v33 K,inout v33 L,inout v33 M,inout v33 N,inout v33 O,inout v33 P,inout v33 Q,inout v33 R,inout v33 S,inout v33 T,inout v33 U,inout v33 V,inout v33 W,inout v33 X,inout v33 Y,inout v33 Z,inout v33 aa,inout v33 bb,inout v33 cc,inout v33 dd,inout v33 ee,inout v33 ff,inout v33 gg,inout v33 hh,inout v33 ii,inout v33 jj,inout v33 kk,inout v33 ll,inout v33 mm,inout v33 nn,inout v33 oo,inout v33 pp,inout v33 qq,inout v33 rr,inout", "return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\n//swap origin(.a)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c){\n\tv33 d;\n\td.x=a.x-b.x-c.x;\n\td.y=a.y-b.y-c.y;\n\td.z=a.z-b.z-c.z;\n\treturn d;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c,v33 d){\n\tv33 e;\n\te.x=a.x-b.x-c.x-d.x;\n\te.y=a.y-b.y-c.y-d.y;\n\te.z=a.z-b.z-c.z-d.z;\n\treturn e;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c,v33 d,v33 e){\n\tv33 f;\n\tf.x=a.x-b.x-c.x-d.x-e.x;\n\tf.y=a.y-b.y-c.y-d.y-e.y;\n\tf.z=a.z-b.z-c.z-d.z-e.z;\n\treturn f;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,", "return b.xy-a.xy;}\nvec2 dt(v33 a,v33 b,v33 c){return dt(a,b)+dt(b,c);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d){return dt(a,b,c)+dt(b,c,d);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){return dt(a,b,c,d)+dt(b,c,d,e);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){return dt(a,b,c,d,e)+dt(b,c,d,e,f);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){return dt(a,b,c,d,e,f)+dt(b,c,d,e,f,g);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){return dt(a,b,c,d,e,f,g)+dt(b,c,d,e,f,g,h);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h,v33 i){return dt(a,b,c,d,e,f,g,h)+dt(b,c,d,e,f,g,h,i);}\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h,v33 i,v33 j){return dt(a,b,c,d,e,f,g,h,i)+dt(b,c,d", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n\treturn vec2(dot(a.x,b.x,c.x),dot(a.y,b.y,c.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n\treturn vec2(dot(a.x,b.x,c.x,d.x),dot(a.y,b.y,c.y,d.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn vec2(dot(a.x,b.x,c.x,d.x,e.x),dot(a.y,b.y,c.y,d.y,e.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn vec2(dot(a.x,b.x,c.x,d.x,e.x,f.x),dot(a.y,b.y,c.y,d.y,e.y,f.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n\treturn vec2(dot(a.x,b.x,c.x,d.x,e", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual div\nv33 div(v33 a,vec2 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//dual add\nv33 add(v33 a,vec2 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//dual sub\nv33 sub(v33 a,vec2 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//dual add\nv33 add(v33 a,float b){\n\treturn v33(a.x+b,a.y+b,a.z+b);\n}\n\n//dual sub\nv33 sub(v33 a,float b){\n\treturn v33(a.x-b,a.y-b,a.z-b);\n}\n\n//dual mul\nv33 mul(v33 a,float b){\n\treturn v33(a.x*b,a.y*b,a.z*b);\n}\n\n//dual div\nv33 div(v33 a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\n\n//dual add\nv33 add(float a,v33 b){\n\treturn v33(a+b.x,a+b.y,a+b.z);\n}\n\n//dual sub\nv33 sub(float a,v33 b){\n\treturn v33(a-b.x,a-b.y,a-b.z);\n}\n\n//dual mul\nv33 mul(float a,v33 b){\n\treturn v33(a*b.x,a*b.y,a*b.z);", "\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF3(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF6(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF7(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF8(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF9(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF10(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF11(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF12(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF13(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF14(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF15(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF16(vec3 p,vec3 w){\n\tvec3 q=p+w;\n\treturn checker(q);\n}\n\nfloat checkerF17(vec3", "\n\tvec3 a=abs(p);\n\tfloat Fb=tri(a.x,w.x)+tri(a.y,w.y)+tri(a.z,w.z);\n\treturn Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 a=abs(p);\n\tfloat Fb=tri(a.x,w.x)+tri(a.y,w.y)+tri(a.z,w.z);\n\treturn Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 a=abs(p);\n\tfloat Fb=tri(a.x,w.x)+tri(a.y,w.y)+tri(a.z,w.z);\n\treturn Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w){\n\tvec3 a=abs(p);\n\tfloat Fb=tri(a.x,w.x)+tri(a.y,w.y)+tri(a.z,w.z);\n\treturn Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF7(vec3 p,vec3 w){\n\tvec3 a=abs(p);\n\tfloat Fb=tri(a.x,w.x)+tri(a.y,w.y)+tri(a.z,w.z);\n\treturn Fb;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\n", "\n\tfloat t=0,d=0;\n\tfor(int i=0;i<100;i++){\n\t\td=sdSphere(r.o+r.d*t,s);\n\t\tif(d<0.001)return 0;\n\t\tt+=d;\n\t}\n\treturn 1;\n}\n\n//raymarching\nfloat rm(v33 r){\n\tfloat t=0,d=0;\n\tfor(int i=0;i<100;i++){\n\t\td=sd(r.o+r.d*t);\n\t\tif(d<0.001)return t;\n\t\tt+=d;\n\t}\n\treturn 1000;\n}\n\n//normal\nv33 n(v33 p){\n\tfloat d=sd(p.o);\n\treturn v33(p.o,normalize(v3(\n\t\tsd(p.o+v3(0.001,0,0))-d,\n\t\tsd(p.o+v3(0,0.001,0))-d,\n\t\tsd(p.o+v3(0,0,0.001))-d\n\t)));\n}\n\n//lighting\nv33 l(v33 p,v33 l){\n\tv33 n=n(p);\n\tfloat d=length(l.o-p.o);\n\tfloat a=clamp(dot(n.d,normalize(l.o-p.o)),0,1);\n\tfloat s=pow(clamp(dot(reflect(normalize(l.o-p.o),n.d),-p.d),0,1),100);\n\treturn v33(p.o,a*l.d*l.s+s*l.d*l.s);\n}\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tv33 r=v33(v3(0,0,-10),normalize(v3(fragCoord.xy-iResolution.xy/2,10)));\n\tfloat t=rm(r);", "\n\tfloat occ=0.0;\n\tfloat sca=1.0;\n\tfor(int i=0;i<5;i++){\n\t\tfloat h=map(u+n*sca);\n\t\tocc+=max(0.0,h-s.w);\n\t\tsca*=0.5;\n\t}\n\treturn clamp(1.0-occ*s.w,0.0,1.0);\n}\n\n//soft shadows\nfloat softShadow(vec3 ro,vec3 rd,float mint,float tmax){\n\tfloat res=1.0;\n\tfloat t=mint;\n\tfor(int i=0;i<16;i++){\n\t\tfloat h=map(ro+rd*t);\n\t\tres=min(res,8.0*h/t);\n\t\tt+=clamp(h,0.02,0.10);\n\t\tif(h<0.001||t>tmax)break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\n//lighting\nvec3 shade(vec3 ro,vec3 rd,vec3 n,vec3 l,vec3 col,float d,float occ){\n\tvec3 h=normalize(l-rd);\n\tfloat dif=clamp(dot(n,l),0.0,1.0);\n\tfloat bac=clamp(dot(n,normalize(vec3(-l.x,l.y,l.z))),0.0,1.0)*clamp(1.0-d,0.0,1.0);\n\tfloat dom=smoothstep(-0.1,0.1,dot(n,h));\n\tfloat fre=pow(clamp(1.0+dot(n,rd),0.0,1.0),2.0);\n\tfloat spe=pow(clamp(dot(n,h),0.0,1.0),16.0);\n\tvec3 lin=vec3(0.0);\n\tlin+=1.30*dif*vec3(1.00,0.80,0.55);\n\tlin+=0.40*bac*vec3(0.40,0.60,1", "\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\treturn vec4(p0, p01, p012, p2);\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\treturn vec4(p0, p01, p012, p0123);\n}\n\n// Exact BBox to a quartic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p34 = mix(p3, p4, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p234 = mix(p23, p34, 0.5);\n\tvec2 p0123", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p0, p01, p012);\n}\n\n// Approximated BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p23 = (p2 + p3) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\tvec2 p123 = (p12 + p23) * 0.5;\n\tvec2 p0123 = (p012 + p123) * 0.5;\n\treturn vec4(p0, p012, p0123);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p23 = (p2 + p3) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\tvec2 p123 = (p12 + p23) * 0.5;\n\tvec2 p0123 = (p012 + p123) * 0.5;\n\treturn vec4(p0, p012, p0123);\n}\n\n// Approximated BBox to a cubic bezier\n", "\n    vec3 p01 = mix( p0, p1, 0.5 );\n    vec3 p12 = mix( p1, p2, 0.5 );\n    vec3 p23 = mix( p2, p3, 0.5 );\n    vec3 p012 = mix( p01, p12, 0.5 );\n    vec3 p123 = mix( p12, p23, 0.5 );\n    vec3 p0123 = mix( p012, p123, 0.5 );\n    return bound3( p0, p3, p0123 );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 p01 = mix( p0, p1, 0.5 );\n    vec3 p12 = mix( p1, p2, 0.5 );\n    vec3 p012 = mix( p01, p12, 0.5 );\n    return bound3( p0, p2, p012 );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1 )\n{\n    return bound3( p0, p1, mix( p0, p1, 0.5 ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0 )\n{\n    return bound3( p0, p0, p0 );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3", "\n\tvec2 min = vec2( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ), min( min( p0.y, p1.y ), min( p2.y, p3.y ) ) );\n\tvec2 max = vec2( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ), max( max( p0.y, p1.y ), max( p2.y, p3.y ) ) );\n\treturn vec4( min, max );\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 min = vec2( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ), min( min( p0.y, p1.y ), min( p2.y, p3.y ) ) );\n\tvec2 max = vec2( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ), max( max( p0.y, p1.y ), max( p2.y, p3.y ) ) );\n\n\tvec2 tvalues = vec2( 0.0 );\n\tvec2 a = 6.0 * p0 - 12.0 * p1 + 6.0 * p2;\n\tvec2 b = -3.0 * p0 + 9.0 * p1 - 9.0 * p2 + 3.0 * p3;\n\tvec2 c = 3.0 * p1 - 3.0 * p0;\n\n\tif( abs( a.x ) < 1e-6 )\n\t{\n\t\tif( abs( b.x ) < 1e-6 )\n\t\t{\n\t\t\t// p0 == p1 == p2 == p3\n\t\t\treturn vec4( min, max );\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttvalues.x = -c.x / b.x;\n\t", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return mix(mix(mix(udSegment(p0, p1), udSegment(p1, p2), 0.5),\n                  mix(udSegment(p2, p3), udSegment(p0123, p0123), 0.5), 0.5),\n              mix(udSegment(p012, p123), udSegment(p0123, p0123), 0.5), 0.5);\n}\n\n// 2D Bezier curve\n// p0, p1, p2, p3: control points\n// pos: position on the curve\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return mix(mix(mix(udSegment(p0, p1), udSegment(p1, p2), 0.5),\n                  mix(udSegment(p2, p3), udSegment(p0", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    float a = dot( e1, p );\n    vec3 s = ro - v0;\n    vec3 q = cross( s, e1 );\n    float f = 1.0 / a;\n    float u = f * dot( s, p );\n    float v = f * dot( rd, q );\n    float t = f * dot( e2, q );\n    return vec3( t, u, v );\n}\n\n// Ray-plane intersection. Returns { t, u, v }\nvec3 planeIntersect( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 n = normalize( cross( p1 - p0, p2 - p0 ) );\n    float d = dot( n, p0 );\n    float t = -( dot( n, ro ) + d ) / dot( n, rd );\n    return vec3( t, 0.0, 0.0 );\n}\n\n// Ray-box intersection. Returns { t, u, v }\nvec3 boxIntersect( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax )\n{\n    vec3 tmin = ( bmin - ro ) / rd;\n    vec3 tmax = ( bmax - ro ) / rd;\n    vec3 t1 = min( tmin, tmax );\n    vec3 t2 = max( tmin, tmax );\n    float t = max( max( t1.x, t1.y ), t1.z );\n    float t_ = min( min( t2.x, t2.y ), t2.z );\n    return vec3( t, t_, 0.0 );\n}\n\n// Ray-sphere intersection. Returns { t, u, v }\nvec3 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 sp, float sr )\n{\n    vec3 oc = ro - sp;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sr * sr;\n    float h = b * b - c;\n    if( h", "\n    vec3  r1 = v1 - v0;\n    vec3  r2 = v2 - v0;\n    vec3  s1 = cross(nor,r1);\n    float d1 = dot(s1,r2);\n    vec3  r0 = pos - v0;\n    float d0 = dot(r0,s1);\n    return clamp( -d0/d1, 0.0, 1.0 );\n}\n\n// Distance to a triangle\nfloat triDist( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  r1 = v1 - v0;\n    vec3  r2 = v2 - v0;\n    vec3  s1 = cross(nor,r1);\n    float d1 = dot(s1,r2);\n    vec3  r0 = pos - v0;\n    float d0 = dot(r0,s1);\n    return d0/d1;\n}\n\n// Distance to a plane\nfloat planeDist( in vec3 pos, in vec3 nor, in vec3 p0 )\n{\n    return dot( pos-p0, nor );\n}\n\n// Distance to a box\nfloat boxDist( in vec3 pos, in vec3 nor, in vec3 bmin, in vec3 bmax )\n{\n    vec3 d = max( bmin-pos, pos-bmax );\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// Distance to a sphere\nfloat sphereDist( in vec3 pos, in vec3 nor, in vec3 cen, float rad )\n{\n    return length( pos-cen ) - rad;\n}\n\n// Distance to a cylinder\nfloat cylinderDist( in vec3 pos, in vec3 nor, in vec3 cen, in vec3 dir, float rad )\n{\n    vec3  d = pos - cen;\n    float t = dot( d, dir );\n    vec3  q = d - t*dir;\n    return length( q ) - rad;\n}\n\n// Distance to a cone\nfloat coneDist", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x + uv.y + kx, 0.0, 1.0 );\n        res = length( a*t + b*t*t + c*t*t*t + d ) * sign( p );\n    }\n    else\n    {\n        h = sqrt(-h);\n        float r = sqrt(p);\n        vec2 x = (vec2(r,r) * cos(acos(-q/(2.0*p))/3.0)) - kx;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        vec2 ts = clamp( uv + uv*uv/r + kx, 0.0, 1.0 );\n\n        float t1 = ts.x;\n        float t2 = ts.y;\n\n        float d2 = length( a*t2 + b*t2*t2 + c*t2*t2*t2 + d );\n        res = -length( a*t1 + b*t1*t1 + c*t1*t1*t1 + d );\n\n        if( d2<res )", "\n    float da = 80.0*DEG2RAD;\n    float a = atan(p.x, -p.y) + da;\n    float l = length(p);\n    float w = (abs(a)+da<3.1415926535)? r1 : r2;\n    return l-w*he;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he )\n{\n    return sdTrapezoid(p.xz,r1,r2,he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec4 p, in float r1, float r2, float he )\n{\n    return sdTrapezoid(p.xzw,r1,r2,he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in vec2 r1, vec2 r2, float he )\n{\n    return sdTrapezoid(p,r1.x,r2.x,he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec3 p, in vec2 r1, vec2 r2, float he )\n{\n    return sdTrapezoid(p.xz,r1.x,r2.x,he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec4 p, in vec2 r1, vec2 r2, float he )\n{\n    return sdTrapezoid(p.xzw,r1.x,r2.x,he);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in vec3 r1, vec3 r2, float he )\n{\n    return sdTrapezoid(p,r1.x,r2.x,he);\n}\n\n// trapezoid / capped cone,", "\n    vec2 k1 = vec2(a.x-b.x,a.y-b.y);\n    vec2 k2 = vec2(b.x-p.x,b.y-p.y);\n    p.x -= clamp( dot(k1,k2)/dot(k1,k1), 0.0, 1.0 ) * (b.x-a.x);\n    p.y -= clamp( dot(k1,k2)/dot(k1,k1), 0.0, 1.0 ) * (b.y-a.y);\n    a.x = b.x-a.x;\n    a.y = b.y-a.y;\n    b.x = p.x-b.x;\n    b.y = p.y-b.y;\n    k1 = vec2(a.x-b.x,a.y-b.y);\n    k2 = vec2(a.x,a.y);\n    return sqrt(dot(k1,k1))*sign(dot(k2,k1))-rb;\n}\n\n// 2D rotation\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 2D rotation\nmat2 rot(float a, vec2 p) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c) * rot(a);\n}\n\n// 2D rotation\nmat2 rot(float a, vec2 p, vec2 o) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c) * rot(a, p - o);\n}\n\n// 2D rotation\nmat2 rot(float a, vec2 p, vec2 o, vec2 r) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c) * rot(a, p - o, r);\n}\n\n// 2D rotation\nmat2 rot(float a, vec2 p", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = 0.0;\n\tfloat m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 res = map(ro+rd*", "\n\treturn fract(sin(dot(q.xy,ivec2(123,321)))*43758.5453);\n}\n\n// 2D noise\nfloat noise( in ivec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    ivec2 f = ivec2(fract(x));\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix(hash(p+ivec2(0,0)),\n                   hash(p+ivec2(1,0)),f.x),\n               mix(hash(p+ivec2(0,1)),\n                   hash(p+ivec2(1,1)),f.x),f.y);\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix(hash(p+vec2(0,0)),\n                   hash(p+vec2(1,0)),f.x),\n               mix(hash(p+vec2(0,1)),\n                   hash(p+vec2(1,1)),f.x),f.y);\n}\n\n// 2D noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(p+vec3(0,0,0)),\n                        hash(p+vec3(1,0,0)),f.x),\n                    mix( hash(p+vec3(0,1,0)),\n                        hash(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash(p+vec3(0,0,1)),\n                        hash(p+vec", "\n    vec2 p0 = floor(x);\n    vec2 f0 = fract(x);\n    vec2 f1 = f0-1.0;\n    p0 = mod(p0, 289.0);\n    float n00 = dot(texture2D(iChannel0, (p0+vec2(0.0,0.0))/289.0, -100.0).xyz, vec3(1.0,1.0,1.0));\n    float n10 = dot(texture2D(iChannel0, (p0+vec2(1.0,0.0))/289.0, -100.0).xyz, vec3(1.0,1.0,1.0));\n    float n01 = dot(texture2D(iChannel0, (p0+vec2(0.0,1.0))/289.0, -100.0).xyz, vec3(1.0,1.0,1.0));\n    float n11 = dot(texture2D(iChannel0, (p0+vec2(1.0,1.0))/289.0, -100.0).xyz, vec3(1.0,1.0,1.0));\n    vec2 n0 = mix(vec2(n00,n01),vec2(n10,n11),f0.x);\n    float n = mix(n0.x,n0.y,f0.y);\n    return n;\n}\n\n// 2D value noise\nfloat noise( in vec2 x )\n{\n    return noise(x, 0);\n}\n\n// 3D value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( noise(p+vec3(0.0,0.0,0.0)),\n                             noise(p+vec3(1.0,0.", "\n    float z=1.0;\n    float rz = 0.0;\n    vec2 px = x;\n    for( int i=0; i<p; i++ )\n    {\n        rz+= z*noise(px);\n        z  *= 0.5;\n        px *= 2.01;\n    }\n    return rz;\n}\n\n// fractal noise\nfloat fbm( in vec3 x, in int p )\n{\n    float z=1.0;\n    float rz = 0.0;\n    vec3 px = x;\n    for( int i=0; i<p; i++ )\n    {\n        rz+= z*noise(px);\n        z  *= 0.5;\n        px *= 2.01;\n    }\n    return rz;\n}\n\n// fractal noise\nfloat fbm( in vec4 x, in int p )\n{\n    float z=1.0;\n    float rz = 0.0;\n    vec4 px = x;\n    for( int i=0; i<p; i++ )\n    {\n        rz+= z*noise(px);\n        z  *= 0.5;\n        px *= 2.01;\n    }\n    return rz;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float t )\n{\n    float z=1.0;\n    float rz = 0.0;\n    vec2 px = x;\n    for( int i=0; i<p; i++ )\n    {\n        rz+= z*noise(px, t);\n        z  *= 0.5;\n        px *= 2.01;\n    }\n    return rz;\n}\n\n// fractal noise\nfloat fbm( in vec3 x, in int p, in float t )\n{\n    float z=1.0;\n    float rz = 0.0;\n    vec3 px = x;\n    for( int i=0; i<p; i++ )\n    {\n        rz+= z*noise(px, t);\n        z  *= 0.5;\n        px *= 2.01;\n    }\n    return rz;\n}\n\n// fractal noise\nfloat fbm( in", "\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n   ", "\n    return (length(p.xz)-r.x)*p.y/abs(p.y) + length(p.xy)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZZ( in vec3 p, in vec2 r ) \n{\n    return (length(p.xz)-r.x)*p.y/abs(p.y) + length(p.xz)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZYY( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.zy)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZYZ( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.yz)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZZY( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.zy)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidZZZ( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.zy)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYZZ( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.yz)-r.y;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYYZ( in vec3 p, in vec2 r ) \n{\n    return (length(p.zy)-r.x)*p.x/abs(p.x) + length(p.yz", "\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - accurate but expensive distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p*(p/r) ) - 1.0) / min(min(r.x,r.y),r.z);\n}\n\n// distance to a cylinder\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// distance to a cone\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec3(q,p.z));\n}\n\n// distance to a torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// distance to a plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// distance to a hexagonal prism\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// distance to a triangular prism\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q =", "\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// generic ellipsoid - exact distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// generic torus - exact distance\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// generic cylinder - exact distance\nfloat sdCappedCylinder( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// generic cone - exact distance\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// generic cone - exact distance\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// generic pyramid - exact distance\nfloat sdPyramid( in vec3 p, in vec3 h )\n{\n    // h is the height of the pyramid\n    float m2 = h.y*h.y + 0.25;\n    \n    p.xz += 0.5*h.z*vec2(-1.0,1.0);\n    \n    vec3 q = abs(p);\n    return max(q.z", "\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox2( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox3( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox4( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract", "\n\treturn pow( x, log( a ) / log( 0.5 ) );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat gain( float a, float x )\n{\n\tfloat k = 0.5 * ( 1.0 - a );\n\treturn bias( 1.0 - k, 1.0 - 2.0 * k * ( 1.0 - x ) );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float b, float x )\n{\n\treturn a + ( 1.0 - a ) * pow( 1.0 - x, b );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float b, float c, float x )\n{\n\treturn a + ( 1.0 - a ) * pow( 1.0 - x, b ) * x + c * x;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float b, float c, float d, float x )\n{\n\treturn a + ( 1.0 - a ) * pow( 1.0 - x, b ) * x + c * x + d * x * x;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float a, float b, float c, float d, float e, float x )\n{\n\treturn a + ( 1.0 - a ) * pow( 1.0 - x, b ) * x + c * x + d * x * x + e * x * x * x;\n}\n\n// Schlick", "\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased pulse\nfloat my_pulse( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased noise\nfloat my_noise( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random2( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random3( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random4( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random5( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random6( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random7( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random8( float x, float p )\n{\n\treturn (x - p) / (1.0 - p);\n}\n\n// biased random\nfloat my_random9( float x, float p )\n{\n\treturn (x - p) / (", "\n    float h2 = h * h;\n    float h3 = h2 * h;\n    float h4 = h2 * h2;\n    float h5 = h4 * h;\n    float h6 = h4 * h2;\n    float h7 = h6 * h;\n    float h8 = h6 * h2;\n    float h9 = h8 * h;\n    float h10 = h8 * h2;\n    float h11 = h10 * h;\n    float h12 = h10 * h2;\n    float h13 = h12 * h;\n    float h14 = h12 * h2;\n    float h15 = h14 * h;\n    float h16 = h14 * h2;\n    float h17 = h16 * h;\n    float h18 = h16 * h2;\n    float h19 = h18 * h;\n    float h20 = h18 * h2;\n    float h21 = h20 * h;\n    float h22 = h20 * h2;\n    float h23 = h22 * h;\n    float h24 = h22 * h2;\n    float h25 = h24 * h;\n    float h26 = h24 * h2;\n    float h27 = h26 * h;\n    float h28 = h26 * h2;\n    float h29 = h28 * h;\n    float h30 = h28 * h2;\n    float h31 = h30 * h;\n    float h32 = h30 * h2;\n    float h33 = h32 * h;\n    float h34 = h32 * h2;\n    float h35 = h34 * h;\n    float h36 = h34 * h2;\n    float h37 = h36 * h;\n    float h38 = h36 * h2;\n    float h39 = h38 * h;\n    float h40 = h38 * h2;\n    float h41 = h40 * h;\n    float h42 = h40 * h2;\n    float h43 = h42 * h;\n    float h44 =", "\n    vec3  ba = pb - pa;\n    float baba = dot(ba,ba);\n    float papa = dot(pa,pa);\n    float paba = dot(pa,ba);\n    float raba = r*baba;\n    vec3  pwo = ro - pa;\n    float pwoaba = dot(pwo,ba);\n    float d = pwoaba*pwoaba - baba*(papa - raba);\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float a = ( -pwoaba - d ) / baba;\n    float b = ( -pwoaba + d ) / baba;\n    if( a<0.0 ) a = b;\n    if( a>1.0 ) return -1.0;\n    return a;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 c, in float r )\n{\n    vec3  oc = ro - c;\n    float b = dot( oc, rd );\n    float c2 = dot( oc, oc ) - r*r;\n    float h = b*b - c2;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt(h);\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float d )\n{\n    float denom = dot(n,rd);\n    if( abs(denom) < 0.0001 ) return -1.0;\n    return -(dot(n,ro)+d)/denom;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - m*bmin;\n    vec3 k = abs(m)*bmax;\n    vec3 t1 = -n -", "\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\tfloat baba = dot(ba, ba);\n\tfloat paba = dot(pa, ba);\n\tfloat x = length(pa * baba - ba * paba) - ra * baba;\n\tfloat y = abs(paba - baba * 0.5) - baba * 0.5;\n\tfloat x2 = x * x;\n\tfloat y2 = y * y * baba;\n\tfloat d = (baba < EPSILON)? x : sqrt(x2 + y2);\n\treturn sign(d) * d + rb - ra;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec3 c)\n{\n\treturn length(p.xz - c.xy) - c.z;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdPlane(vec3 p, vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w;\n}\n\n// http://iquilezles.org/www/articles/distfunctions", "\n    vec3  ab = b-a;\n    float t2 = dot(ab,ab);\n    float ap = dot(a-ro,ab);\n    float t1 = dot(ro-a,ab);\n    if( ap < 0.0 ) return 0.0;\n    if( t1 < 0.0 ) return 1.0;\n    t2 = sqrt( t2 - ap*ap );\n    float d = max( k*r - ap*t1/t2, 0.0 );\n    return min( 1.0, d/r );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    return capShadow( ro, rd, a, b, r, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n    return capShadow( ro, rd, a, b, 0.05, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float k )\n{\n    return capShadow( ro, rd, a, b, 0.05, k );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k, in float t )\n{\n    vec3  ab = b-a;\n    float t2 = dot(ab,ab);\n    float ap = dot(a-ro,ab);\n    float t1 = dot(ro-a,ab);\n    if( ap < 0.0 ) return 0.0;\n    if( t1 < 0.0 ) return 1.0;\n    t2 = sqrt( t2 - ap*ap );\n    float d = max( k*r - ap*t1/t2, 0.0 );\n    return min( 1.0, d/r );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sign(uv.y);\n    float d = abs(uv.y) - th;\n    float r2 = mix(rad2, rad1, smoothstep(-th, th, d));\n    float da = (r - r2) / r;\n    return vec2(r * cos(a + s * da), r * sin(a + s * da));\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake2(vec2 uv, float rad1, float rad2, float th)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sign(uv.y);\n    float d = abs(uv.y) - th;\n    float r2 = mix(rad2, rad1, smoothstep(-th, th, d));\n    float da = (r - r2) / r;\n    return vec2(r * cos(a + s * da), r * sin(a + s * da));\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake3(vec2 uv, float rad1, float rad2, float th)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sign(uv.y);\n    float d = abs(uv.y) - th;\n    float r2 = mix(rad2, rad1, smoothstep(-th, th, d));\n    float da = (r - r2) / r;\n    return vec2(r * cos(a + s * da), r * sin(a + s * da));\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake4(vec", "\n    vec2 q = vec2( length(p), atan(p.y,p.x) );\n    return max(q.x-r,abs(q.y-c.y)-c.x);\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat udPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( length(p), atan(p.y,p.x) );\n    return max(q.x-r,abs(q.y-c.y)-c.x);\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat fPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = vec2( length(p), atan(p.y,p.x) );\n    return max(q.x-r,abs(q.y-c.y)-c.x);\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat sdAnnulus( in vec2 p, in float r, in float w )\n{\n    float d = length(p) - r;\n    return abs(d) - w;\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat udAnnulus( in vec2 p, in float r, in float w )\n{\n    float d = length(p) - r;\n    return abs(d) - w;\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat fAnnulus( in vec2 p, in float r, in float w )\n{\n    float d = length(p) - r;\n    return abs(d) - w;\n}\n\n// p is the position of the center of the pie\n// c is the sin/cos of the angle. r is the radius\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return", "\n    vec3  eps = vec3(0.001,0.0,0.0);\n    float cx = sphere4(pos+eps.xyy) - sphere4(pos-eps.xyy);\n    float cy = sphere4(pos+eps.yxy) - sphere4(pos-eps.yxy);\n    float cz = sphere4(pos+eps.yyx) - sphere4(pos-eps.yyx);\n    return normalize( vec3(cx,cy,cz) );\n}\n\n// distance function for a torus\nfloat torus( vec3 pos, vec2 t )\n{\n    vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n    return length(q)-t.y;\n}\n\n// distance function for a torus\nfloat torus82( vec3 pos, vec2 t )\n{\n    vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n    return pow( pow(q.x,8.0) + pow(q.y,8.0), 1.0/8.0 ) - t.y;\n}\n\n// distance function for a torus\nfloat torus88( vec3 pos, vec2 t )\n{\n    vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n    return pow( pow(q.x,8.0) + pow(q.y,8.0), 1.0/8.0 ) - t.y;\n}\n\n// distance function for a torus\nfloat torus22( vec3 pos, vec2 t )\n{\n    vec2 q = vec2(length(pos.xz)-t.x,pos.y);\n    float d1 = pow( pow(q.x,2.0) + pow(q.y,2.0), 1.0/2.0 ) - t.y;\n    float d2 = (max(abs(q.x),abs(q.y))-t.y);\n    return min(d1,d2);\n}\n\n// distance function for a cylinder\nfloat cylinder( vec3 pos, vec3 c )\n{\n    return length(pos.xz-c.xy", "\n    p.x = abs(p.x);\n    p -= ra;\n    p = p*mat2(sca.x,-sca.y,sca.y,sca.x);\n    p += vec2(0.0,ra);\n    return length(p-vec2(0.0,rb)) - rb;\n}\n\n// p is the position\n// a is the center\n// b is the point on the circle\n// r is the radius\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// p is the position\n// a is the center\n// b is the point on the circle\n// r is the radius\nfloat sdSegment2( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// p is the position\n// a is the center\n// b is the point on the circle\n// r is the radius\nfloat sdSegment3( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// p is the position\n// a is the center\n// b is the point on the circle\n// r is the radius\nfloat sdSegment4( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(", "\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n\tif( m>-", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, time ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = 0.0;\n\tfloat m = -1.0;\n    for( int i=0; i<6", "\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, time ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = 0.0;\n\tfloat m = -1.0;\n    for(", "\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    b = (floor(b)+min(fract(a)*M_PI, (1.0-fract(a))*M_PI)) * 0.5;\n    a = (floor(a)+min(fract(b)*M_PI, (1.0-fract(b))*M_PI)) * 0.5;\n    return (1.0-fract(a.x))*(1.0-fract(a.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox2( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    b = (floor(b)+min(fract(a)*M_PI, (1.0-fract(a))*M_PI)) * 0.5;\n    a = (floor(a)+min(fract(b)*M_PI, (1.0-fract(b))*M_PI)) * 0.5;\n    return (1.0-fract(a.x))*(1.0-fract(a.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox3( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    b = (floor(b)+min(fract(a)*M_PI, (1.0-fract(a))*M_PI)) * 0.5;\n    a = (floor(a)+min(fract(b)*M_PI, (1.0-fract(b", "\n    return floor(x*k)/k;\n}\n\n//\n// 2D Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n//\n// 3D Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec3 staircase( in vec3 x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n//\n// 4D Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec4 staircase( in vec4 x, in float k )\n{\n    return floor(x*k)/k;\n}\n\n//\n// 1D Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in vec2 k )\n{\n    return floor(x*k.x)/k.x;\n}\n\n//\n// 2D Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 x,", "\n\tvec3 light_col = vec3(1.0);\n\tvec3 light_pos = sample_pos + surface_normal * 0.001;\n\tvec3 light_vec = normalize(light_pos - sample_pos);\n\tfloat light_dist = length(light_pos - sample_pos);\n\tfloat light_dist_sq = light_dist * light_dist;\n\tfloat light_dist_sq_inv = 1.0 / light_dist_sq;\n\tfloat light_dist_inv = 1.0 / light_dist;\n\tfloat light_dist_inv_sq = light_dist_inv * light_dist_inv;\n\tfloat light_dist_inv_sq_sq = light_dist_inv_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq = light_dist_inv_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq = light_dist_inv_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq_sq = light_dist_inv_sq_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq_sq_sq = light_dist_inv_sq_sq_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq_sq_sq_sq = light_dist_inv_sq_sq_sq_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq_sq_sq_sq_sq = light_dist_inv_sq_sq_sq_sq_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_sq_sq_sq_sq_sq_sq = light_dist_inv_sq_sq_sq_sq_sq_sq_sq_sq * light_dist_inv_sq;\n\tfloat light_dist_inv_sq_sq_sq_", "\n\tvec3 sphere_pos = vec3(0, 0, 0);\n\tfloat sphere_radius = 1.0;\n\tfloat sphere_dist = sphere_dist(pos, dir, sphere_pos, sphere_radius);\n\tvec3 sphere_color = vec3(0.0, 1.0, 0.0);\n\tvec3 sphere_normal = normalize(pos - sphere_pos);\n\tfloat sphere_light = max(0.0, dot(sphere_normal, light_dir));\n\tvec3 sphere_light_color = vec3(1.0, 1.0, 1.0);\n\tvec3 sphere_ambient_color = vec3(0.1, 0.1, 0.1);\n\tvec3 sphere_diffuse_color = sphere_color * sphere_light_color * sphere_light;\n\tvec3 sphere_final_color = sphere_diffuse_color + sphere_ambient_color;\n\treturn vec4(sphere_final_color, sphere_dist);\n}\n\n/*\nThe following function returns the color of the pixel\n\nin this case, the function renders the scene color and depth, and then adds the atmosphere\n*/\nvec3 render_pixel(vec3 pos, vec3 dir, vec3 light_dir) {\n\tvec4 scene_color_and_depth = render_scene(pos, dir, light_dir);\n\tvec3 scene_color = scene_color_and_depth.xyz;\n\tfloat scene_depth = scene_color_and_depth.w;\n\tvec3 atmosphere_color = render_atmosphere(pos, dir, light_dir, scene_depth);\n\treturn scene_color + atmosphere_color;\n}\n\n/*\nThe following function returns the color of the pixel\n\nin this case, the function renders the scene color and depth, and then adds the atmosphere\n*/\nvec3 render_pixel_with_sun(vec3 pos, vec3 dir, vec3 light_dir) {\n\tvec4 scene_color_and_depth = render_scene(pos, dir, light_dir);\n\tvec3 scene_color = scene_color_and_depth.xyz;\n\tfloat scene_depth = scene_color_and_depth.", "\n    vec2 xy = 2.0 * coord.xy / resolution.xy - 1.0;\n    float z2 = 1.0 - xy.x * xy.x - xy.y * xy.y;\n    if (z2 < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float z = sqrt(z2);\n    return vec3(xy, z);\n}\n\n/*\nthis function calculates the color of the current pixel\n*/\nvec3 get_color(vec3 camera_vector) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 ray_origin = vec3(0.0, 0.0, 0.0);\n    vec3 ray_direction = camera_vector;\n    vec3 ray_direction_normalized = normalize(ray_direction);\n    vec3 ray_direction_normalized_inverse = vec3(1.0 / ray_direction_normalized.x, 1.0 / ray_direction_normalized.y, 1.0 / ray_direction_normalized.z);\n    vec3 ray_direction_normalized_inverse_sign = sign(ray_direction_normalized_inverse);\n    vec3 ray_direction_normalized_inverse_sign_abs = abs(ray_direction_normalized_inverse_sign);\n    vec3 ray_direction_normalized_inverse_sign_abs_epsilon = ray_direction_normalized_inverse_sign_abs + vec3(0.0000001, 0.0000001, 0.0000001);\n    vec3 ray_direction_normalized_inverse_sign_abs_epsilon_inverse = vec3(1.0 / ray_direction_normalized_inverse_sign_abs_epsilon.x, 1.0 / ray_direction_normalized_inverse_sign_abs_epsilon.y, 1.0 / ray_direction_normalized_inverse_sign_abs_epsilon.z);\n    vec3 ray_direction_normalized_inverse_sign_abs_epsilon_inverse_sign = sign(ray_direction_normalized_inverse_sign_abs_epsilon_inverse);\n    vec3 ray_direction_normalized_inverse_sign_abs_epsilon_inverse_sign", "\n\t// cos(theta) = b/c\n\tfloat l = length(p);\n\tfloat m = length(p - c*ra);\n\treturn acos(clamp((l*l + ra*ra - m*m) / (2.0*l*ra), -1.0, 1.0));\n}\n\n// c is the sin/cos of the desired cone angle\nfloat udSolidAngle(vec3 p, vec2 c, float ra)\n{\n\treturn sdSolidAngle(p, c, ra) - ra;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCappedCone(vec3 p, vec3 c, float h, float r1, float r2)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 k1 = vec2(r2, h);\n\tvec2 k2 = vec2(r2-r1, 2.0*h);\n\tvec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)? r1:r2), abs(q.y)-h);\n\tvec2 cb = q - c.xy + k1 + k2*clamp(dot(k1-c.xy,k2)/dot(k2, k2), 0.0, 1.0);\n\tfloat s = (cb.x < 0.0 && ca.y < 0.0)? -1.0 : 1.0;\n\treturn s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n}\n\n// c is the sin/cos of the desired cone angle\nfloat udCappedCone(vec3 p, vec3 c, float h, float r1, float r2)\n{\n\treturn sdCappedCone(p, c, h, r1, r2) - r2;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCappedCylinder(vec3 p, vec3 c, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec", "\n    if (material == 0) {\n        return vec3(0.0);\n    }\n    if (material == 1) {\n        return vec3(1.0);\n    }\n    if (material == 2) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    if (material == 3) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    if (material == 4) {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    if (material == 5) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    if (material == 6) {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    if (material == 7) {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    if (material == 8) {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (material == 9) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 10) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 11) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 12) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 13) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 14) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 15) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 16) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    if (material == 17) {\n        return vec3(", "\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.9;\n        case MATERIAL_METAL:\n            return 0.9;\n        case MATERIAL_MIRROR:\n            return 1.0;\n        default:\n            return 0.0;\n    }\n}\n\n// Get refractive index of a material.\n// 1.0 is air.\nfloat get_material_refractive_index(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 1.5;\n        case MATERIAL_METAL:\n            return 1.0;\n        case MATERIAL_MIRROR:\n            return 1.0;\n        default:\n            return 1.0;\n    }\n}\n\n// Get color of a material.\nvec3 get_material_color(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return vec3(0.0, 0.0, 1.0);\n        case MATERIAL_METAL:\n            return vec3(1.0, 0.0, 0.0);\n        case MATERIAL_MIRROR:\n            return vec3(1.0, 1.0, 1.0);\n        default:\n            return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// Get emission of a material.\nvec3 get_material_emission(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return vec3(0.0, 0.0, 0.0);\n        case MATERIAL_METAL:\n            return vec3(0.0, 0.0, 0.0);\n        case MATERIAL_MIRROR:\n            return vec3(0.0, 0.0, 0.0);\n        default:\n            return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// Get the normal of a sphere.\nvec3 get_sphere_normal(vec3 sphere_center, float sphere_radius, vec3 point) {\n    return normalize(point - sphere_center);\n}\n\n// Get the normal of a plane.\nvec3 get_plane", "\n\treturn material_refraction[material];\n}\n\n// Get color of a material.\nvec3 get_material_color(int material) {\n\treturn material_color[material];\n}\n\n// Get emission of a material.\nvec3 get_material_emission(int material) {\n\treturn material_emission[material];\n}\n\n// Get texture of a material.\nint get_material_texture(int material) {\n\treturn material_texture[material];\n}\n\n// Get texture of a material.\nint get_material_texture_type(int material) {\n\treturn material_texture_type[material];\n}\n\n// Get texture of a material.\nint get_material_texture_size(int material) {\n\treturn material_texture_size[material];\n}\n\n// Get texture of a material.\nint get_material_texture_offset(int material) {\n\treturn material_texture_offset[material];\n}\n\n// Get texture of a material.\nint get_material_texture_scale(int material) {\n\treturn material_texture_scale[material];\n}\n\n// Get texture of a material.\nint get_material_texture_offset_x(int material) {\n\treturn material_texture_offset_x[material];\n}\n\n// Get texture of a material.\nint get_material_texture_offset_y(int material) {\n\treturn material_texture_offset_y[material];\n}\n\n// Get texture of a material.\nint get_material_texture_offset_z(int material) {\n\treturn material_texture_offset_z[material];\n}\n\n// Get texture of a material.\nint get_material_texture_scale_x(int material) {\n\treturn material_texture_scale_x[material];\n}\n\n// Get texture of a material.\nint get_material_texture_scale_y(int material) {\n\treturn material_texture_scale_y[material];\n}\n\n// Get texture of a material.\nint get_material_texture_scale_z(int material) {\n\treturn material_texture_scale_z[material];\n}\n\n// Get texture of a material.\nint get_material_texture", "\n    return material_opacity[material];\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return material_color[material];\n}\n\n// Get the reflectivity of a material.\n// 0.0 is no reflection.\n// 1.0 is perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return material_reflectivity[material];\n}\n\n// Get the refractivity of a material.\n// 0.0 is no refraction.\n// 1.0 is perfect refraction.\nfloat get_material_refractivity(int material) {\n    return material_refractivity[material];\n}\n\n// Get the refractive index of a material.\n// 1.0 is air.\nfloat get_material_refractive_index(int material) {\n    return material_refractive_index[material];\n}\n\n// Get the roughness of a material.\n// 0.0 is no roughness.\n// 1.0 is very rough.\nfloat get_material_roughness(int material) {\n    return material_roughness[material];\n}\n\n// Get the emissivity of a material.\n// 0.0 is no emissivity.\n// 1.0 is very emissive.\nfloat get_material_emissivity(int material) {\n    return material_emissivity[material];\n}\n\n// Get the emission color of a material.\nvec3 get_material_emission_color(int material) {\n    return material_emission_color[material];\n}\n\n// Get the texture of a material.\n// 0 is no texture.\nint get_material_texture(int material) {\n    return material_texture[material];\n}\n\n// Get the texture scale of a material.\nvec2 get_material_texture_scale(int material) {\n    return material_texture_scale[material];\n}\n\n// Get the texture offset of a material.\nvec2 get_material_texture_offset(int material) {\n    return material_texture_offset[material];\n}\n\n// Get the texture rotation of a material.\nfloat get_material_texture_rotation(int material) {\n    return material_texture_rotation", "\n    vec3 ab = line_b - line_a;\n    vec3 bc = tri_c - tri_b;\n    vec3 ca = tri_a - tri_c;\n    vec3 ac = tri_c - tri_a;\n    vec3 ba = tri_a - tri_b;\n    vec3 cb = tri_b - tri_c;\n    vec3 normal = cross(ab, ac);\n    float denom = dot(normal, normal);\n    vec3 ap = line_a - tri_a;\n    vec3 bp = line_a - tri_b;\n    vec3 cp = line_a - tri_c;\n    float u = dot(cross(ab, ap), normal) / denom;\n    float v = dot(cross(bc, bp), normal) / denom;\n    float w = dot(cross(ca, cp), normal) / denom;\n    return vec3(u >= 0.0 && v >= 0.0 && w >= 0.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_n) {\n    vec3 ab = line_b - line_a;\n    vec3 bc = tri_c - tri_b;\n    vec3 ca = tri_a - tri_c;\n    vec3 ac = tri_c - tri_a;\n    vec3 ba = tri_a - tri_b;\n    vec3 cb = tri_b - tri_c;\n    vec3 normal = cross(ab, ac);\n    float denom = dot(normal, normal);\n    vec3 ap = line_a - tri_a;\n    vec3 bp = line_a - tri_b;\n    vec3 cp = line_a - tri_c;\n    float u = dot(cross(ab, ap), normal) / denom;\n    float v = dot(cross(bc, bp), normal) / denom;\n    float w = dot(cross(ca, cp), normal) / denom;\n    return vec3(u >= 0.", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given a point and a triangle in clockwise order,\n// compute the barycentric coordinates of that point.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_barycentric_coords(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 ap = point - tri_a;\n    float d00 = dot(ab, ab);\n    float d01 = dot(ab, ac);\n    float d11 = dot(ac, ac);\n    float d20 = dot(ap, ab);\n    float d21 = dot(ap, ac);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0 - v - w;\n    return vec3(u, v, w);\n}\n\n// Given a point and a triangle in clockwise order,\n// compute the barycentric coordinates of that point.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_barycentric_coords(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 ad = tri_d - tri_a;\n    vec3 ap = point - tri_a;\n    float d00 = dot(ab, ab", "\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-projection-depth-space-post-processing\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(fov * 0.5);\n    return mat4(\n        vec4(f / aspect, 0.0, 0.0, 0.0),\n        vec4(0.0, f, 0.0, 0.0),\n        vec4(0.0, 0.0, (far + near) / (near - far), -1.0),\n        vec4(0.0, 0.0, (2.0 * far * near) / (near - far), 0.0)\n    );\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-projection-depth-space-post-processing\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    return mat4(\n        vec4(2.0 / (right - left), 0.0, 0.0, 0.0),\n        vec4(0.0, 2.0 / (top - bottom), 0.0, 0.0),\n        vec4(0.0, 0.0, -2.0 / (far - near), 0.0),\n        vec4(-(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1.0)\n    );\n}\n\n// Generate a view matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = 1000000.0;\n    result.normal = vec3(0.0, 0.0, 0.0);\n    result.color = vec3(0.0, 0.0, 0.0);\n    result.material = 0;\n\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n\n    for (int i = 0; i < num_triangles; i++) {\n        triangle tri = triangles[i];\n        vec3 v0 = vertices[tri.v0];\n        vec3 v1 = vertices[tri.v1];\n        vec3 v2 = vertices[tri.v2];\n\n        vec3 e1 = v1 - v0;\n        vec3 e2 = v2 - v0;\n        vec3 pvec = cross(ray_direction, e2);\n        float det = dot(e1, pvec);\n\n        if (det > -EPSILON && det < EPSILON) {\n            continue;\n        }\n\n        float inv_det = 1.0 / det;\n        vec3 tvec = ray_origin - v0;\n        float u = dot(tvec, pvec) * inv_det;\n        if (u < 0.0 || u > 1.0) {\n            continue;\n        }\n\n        vec3 qvec = cross(tvec, e1);\n        float v = dot(ray_direction, qvec) * inv_det;\n        if (v < 0.0 || u + v > 1.0) {\n            continue;\n        }\n\n        float t = dot(e2, qvec) * inv_det;\n        if (t > EPSILON && t < result.distance) {\n            result.hit = true;\n            result.distance = t;\n            result.normal = normalize(cross(e1, e2));\n            result.color = tri.color;\n            result.material = tri.material;\n        }\n    }\n\n    return result;\n}\n\n// Compute the color of a pixel.\nvec3 compute_pixel_color(vec3 ray_origin, vec3 ray_target) {\n    cast_ray_result result = cast_ray(ray_origin, ray_target);\n\n    if (!result.hit) {\n        return vec3", "\n    float shadow_factor = 1.0;\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float ray_length = length(ray_target - ray_origin);\n    float ray_step = 0.01;\n    float ray_distance = 0.0;\n    float ray_opacity = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 ray_position = ray_origin + ray_direction * ray_distance;\n        float ray_sample = sample_scene(ray_position);\n        if (ray_sample > 0.0) {\n            shadow_factor = 0.0;\n            break;\n        }\n        ray_distance += ray_step;\n        if (ray_distance > ray_length) {\n            break;\n        }\n    }\n    return shadow_factor;\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray_with_opacity(vec3 ray_origin, vec3 ray_target) {\n    float shadow_factor = 1.0;\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float ray_length = length(ray_target - ray_origin);\n    float ray_step = 0.01;\n    float ray_distance = 0.0;\n    float ray_opacity = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 ray_position = ray_origin + ray_direction * ray_distance;\n        float ray_sample = sample_scene(ray_position);\n        if (ray_sample > 0.0) {\n            shadow_factor = 0.0;\n            break;\n        }\n        ray_distance += ray_step;\n        if (ray_distance > ray_length) {\n            break;\n        }\n    }\n    return shadow_factor;\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray_with_opacity_and_refraction(", "\n    float i = floor(x);\n    float f = frac(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix( hash(i), hash(i + 1.0), u );\n}\n\nfloat bnoise( in vec2 x )\n{\n    vec2 i = floor(x);\n    vec2 f = frac(x);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n    //\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n    //\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Value Noise by  - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat vnoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = hash(p);\n    float b = hash(p + vec2(1.0, 0.0));\n    float c = hash(p + vec2(0.0, 1.0));\n    float d = hash(p + vec2(1.0, 1.0));\n    return mix(a, b, f.x) +\n           ", "\n\tfloat i = floor(p);\n\tfloat f = frac(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix( rand(i), rand(i + 1.0), u );\n}\n\n// Classic Perlin noise\nfloat cnoise(float2 P)\n{\n\tfloat4 Pi = floor(P.xyxy) + float4(0.0, 0.0, 1.0, 1.0);\n\tfloat4 Pf = frac(P.xyxy) - float4(0.0, 0.0, 1.0, 1.0);\n\tPi = Pi - floor(Pi * (1.0 / 65536.0)) * 65536.0;\n\tfloat4 ix = Pi.xzxz;\n\tfloat4 iy = Pi.yyww;\n\tfloat4 fx = Pf.xzxz;\n\tfloat4 fy = Pf.yyww;\n\tfloat4 i = permute(permute(ix) + iy);\n\tfloat4 gx = frac(i * (1.0 / 41.0)) * 2.0 - 1.0;\n\tfloat4 gy = abs(gx) - 0.5;\n\tfloat4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\tfloat2 g00 = float2(gx.x, gy.x);\n\tfloat2 g10 = float2(gx.y, gy.y);\n\tfloat2 g01 = float2(gx.z, gy.z);\n\tfloat2 g11 = float2(gx.w, gy.w);\n\tfloat4 norm = 1.79284291400159 - 0.85373472095314 *\n\t\tfloat4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.", "\n    return fract(sin(n)*43758.5453);\n}\n\n// 2D random\nfloat random (in vec2 st) \n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// 2D Noise based on  @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) \n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Value Noise by  - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec3 x) // 3D Noise\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.", "\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f*(3.0-2.0*f);\n    return mix( hash(i), hash(i+1.0), u );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float n = dot(i, vec3(1.0, 113.0, 113.0 * 113.0));\n    float res = mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                        mix( hash(n+113.0), hash(n+114.0),f.x),f.y),\n                    mix(mix( hash(n+113.0*113.0), hash(n+113.0*113.0+1.0),f.x),\n                        mix( hash(n+113.0*113.0+113.0), hash(n+113.0*113.0+114.0),f.x),f.y),f.z);\n    return res;\n}\n\n// value noise\nfloat vnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.0-2.0", "\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x*2.0 + G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x*2.0 + G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x*2.0 + G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec4 x, in float G )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x*2.0 + G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 x, in vec2 G )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x*2.0 + G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 x, in vec3 G )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float", "\n    // The polynomial is of the form\n    // a*x^2 + b*x*y + c*y^2 + d*x*z + e*y*z + f*z^2 + g*x + h*y + i*z + j = 0\n    // where the coefficients are given by\n    // a = 1\n    // b = 0\n    // c = 1\n    // d = 0\n    // e = 0\n    // f = 1\n    // g = 0\n    // h = 0\n    // i = 0\n    // j = -1\n    // The solutions are given by\n    // x = -g/2a +/- sqrt(g^2 - 4*a*(j - b*h/2a - c*i/2a - d*g/2a - e*h/2a - f*i/2a))/(2*a)\n    // y = -h/2b +/- sqrt(h^2 - 4*b*(j - a*g/2b - c*i/2b - d*g/2b - e*h/2b - f*i/2b))/(2*b)\n    // z = -i/2c +/- sqrt(i^2 - 4*c*(j - a*g/2c - b*h/2c - d*g/2c - e*h/2c - f*i/2c))/(2*c)\n    // The solutions are complex if the discriminant is negative\n    // The discriminant is given by\n    // D = g^2 - 4*a*(j - b*h/2a - c*i/2a - d*g/2a - e*h/2a - f*i/2a)\n    //   = h^2 - 4*b*(j - a*g/2b - c*i/2b - d*g/2b - e*h/2b - f*i/2b)\n    //   = i^2 - 4*c*(j - a*g/2c - b*h/2c - d*g/2c - e*h/2c - f*i/2c)\n    // The discriminant is zero if the polynomial", "\n    // convert to polar angles\n    float r = length(pb);\n    vec2 p = vec2(atan(pb.y,pb.x),asin(pb.z));\n    \n    // convert to 4D point\n    vec4 p4 = vec4(cos(p.x)*cos(p.y),sin(p.x)*cos(p.y),sin(p.y),r);\n    \n    // convert to cubic coefficients\n    vec4 c = p4*p4*(3.0*p4-4.0*p4*p4);\n    \n    // evaluate the cubic polynomial\n    float a = c.x;\n    float b = c.y;\n    float c = c.z;\n    float d = c.w;\n    float k = b*b-3.0*a*c;\n    float h = 2.0*b*b*b-9.0*a*b*c+27.0*a*a*d;\n    float i = h*h-4.0*k*k*k;\n    float j = pow( sqrt(i+0.0000001), 1.0/3.0 );\n    float l = (-h+j)/(2.0*sqrt(k));\n    float m = (-h-j)/(2.0*sqrt(k));\n    float n = (l+m)/3.0;\n    float p = (3.0*m-l)/3.0;\n    float q = (-2.0*l-m)/3.0;\n    float s = clamp(n,-1.0,1.0);\n    float t = clamp(p,-1.0,1.0);\n    float u = clamp(q,-1.0,1.0);\n    float v = (s+t+u)/3.0;\n    \n    // color based on the number of real roots\n    float w = 0.0;\n    if( v>0.0 ) w = 1.0;\n    if( u>0.0 ) w = 2.0;\n    if( t>0.0 ) w = 3.0;\n    if( s>0.0 ) w = 4.0;\n    return vec3(w/4.0,w/4.0,w/4.0);\n}\n\n", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - m*cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec4(-1.0);\n    return vec4(tN, tF);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdHexPrism( in vec3 p", "\n    vec3 d = abs(ro - cen) - rad;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sd", "\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, w*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated ambient occlusion, based on\n//\n// https://www.shadertoy.com/view/4sfGzS\n//\n// and further fixed and improved\n//\nfloat apprAmbientOcclusion(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++)\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(p + n*h).x;\n        ao += -(d-h)*sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 3.0*ao, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*t).x;\n        res = min(res, w*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp(res, 0.", " seed = fract(sin(seed)*43758.5453123); return seed; }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co) { return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 34.234))) * 43758.5453); }\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    for(float t=mint; t < maxt;) {\n        float h = map(ro + rd*t).x;\n        if(h < 0.001) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\n// raymarching\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i=0; i<64; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p).x;\n        if(d < 0.001) {\n            return vec3(t, p);\n        }\n        t += d;\n    }\n    return vec3(0.0);\n}\n\n// normal\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n}\n\n// lighting\nvec3 lighting(vec3 p, vec3 n, vec3 rd) {\n    vec3 l = normalize(vec3(0.5, 0.5,", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's 2D Noise Function\n//https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n//Inigo Quilez's 2D Noise Function\n//https://www.shadertoy.com/view/4sfGzS\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//Inigo Quilez's 2D Noise Function\n//https://www.shadertoy.com/view/4sfGzS\nfloat fbm2( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.02;\n    f += 0.03", "\n    vec3 q = abs(p);\n    h = clamp(h, -2.0*la, 2.0*la);\n    float d1 = q.z-h;\n    float d2 = max(q.x*la+q.y*lb,q.y*la+q.x*lb);\n    float d = (max(d1,d2)-ra);\n    return d;\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat udRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    return sdRhombus(p,la,lb,h,ra);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h)\n{\n    return sdRhombus(p,la,lb,h,0.0);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat udRhombus(vec3 p, float la, float lb, float h)\n{\n    return udRhombus(p,la,lb,h,0.0);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb)\n{\n    return sdRhombus(p,la,lb,1.0,0.0);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat udRhombus(vec3 p, float la, float lb)\n{\n    return udRhombus(p,la,lb,1.0,0.0);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p)\n{\n    return sdRhombus(p,1.0,1.0,1.0,0.0);\n}\n\n// p=point, la,lb=semi axis, h=height, ra=corner\nfloat udRhombus(vec3 p)\n{\n    return udRhom", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 perp = pa - ba*h;\n    float d = length(perp);\n    float t = h*length(ba);\n    float w = length(p-a);\n    float y = abs(d-r);\n    float x = abs(t-band);\n    return vec4( x, y, t, w );\n}\n\n// p = point\n// a = start\n// b = end\n// r = radius\n// band = width of the band\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec3 p, vec3 a, vec3 b, float r, float band ) \n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3 perp = pa - ba*h;\n    float d = length(perp);\n    float t = h*length(ba);\n    float w = length(p-a);\n    float y = abs(d-r);\n    float x = abs(t-band);\n    return vec4( x, y, t, w );\n}\n\n// p = point\n// a = start\n// b = end\n// r = radius\n// band = width of the band\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec4 p, vec4 a, vec4 b, float r, float band ) \n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec4 perp = pa - ba*h;\n    float d = length(perp);\n    float t = h*length(ba);\n    float w = length(p-a);\n    float y = abs(d-r);\n    float x =", "\n    vec2 d = abs(p) - b;\n    float inside = max(d.x,d.y);\n    float outside = length(max(d,0.0));\n    float x = inside + r;\n    float y = outside - r;\n    float z = length(max(d,0.0));\n    float w = length(p);\n    return vec4(x,y,z,w);\n}\n\n// p = point\n// b = box\n// r = radius\n// s = scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec3 p, \n            in vec3 b, in float r, \n            in float s )\n{\n    vec3 d = abs(p) - b;\n    float inside = max(d.x,max(d.y,d.z));\n    float outside = length(max(d,0.0));\n    float x = inside + r;\n    float y = outside - r;\n    float z = length(max(d,0.0));\n    float w = length(p);\n    return vec4(x,y,z,w);\n}\n\n// p = point\n// b = box\n// r = radius\n// s = scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec4 p, \n            in vec4 b, in float r, \n            in float s )\n{\n    vec4 d = abs(p) - b;\n    float inside = max(d.x,max(d.y,max(d.z,d.w)));\n    float outside = length(max(d,0.0));\n    float x = inside + r;\n    float y = outside - r;\n    float z = length(max(d,0.0));\n    float w = length(p);\n    return vec4(x,y,z,w);\n}\n\n// p = point\n// b = box\n// r = radius\n// s = scale\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4", "\n    vec2 d = abs(p)-b;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n                 sign(d.x)*step(d.y,d.x),\n                 sign(d.y)*step(d.x,d.y) );\n}\n\n// Signed distance function for a 2D box with rounded corners\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBoxRounded( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0))-r,\n                 sign(d.x)*step(d.y,d.x),\n                 sign(d.y)*step(d.x,d.y) );\n}\n\n// Signed distance function for a 2D circle\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    float d = length(p)-r;\n    return vec3( d, p/r );\n}\n\n// Signed distance function for a 2D ellipse\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 r )\n{\n    float d = length(p/r)-1.0;\n    return vec3( d, p/(r*r) );\n}\n\n//", "\n\tfloat d = length(p) - r;\n\tfloat per = length(p) - (r - band);\n\tfloat per2 = length(p) - (r + band);\n\treturn vec4( d, per, per2, d );\n}\n\n// p = point\n// c = center\n// r = radius\n// band = thickness\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, in vec2 c, float r, float band ) \n{\n\treturn paCircle( p - c, r, band );\n}\n\n// p = point\n// c = center\n// r = radius\n// band = thickness\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec3 p, in vec3 c, float r, float band ) \n{\n\treturn paCircle( p.xy - c.xy, r, band );\n}\n\n// p = point\n// c = center\n// r = radius\n// band = thickness\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec4 p, in vec4 c, float r, float band ) \n{\n\treturn paCircle( p.xy - c.xy, r, band );\n}\n\n// p = point\n// c = center\n// r = radius\n// band = thickness\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, in vec2 c, float r, float band, float scale ) \n{\n\treturn paCircle( p - c, r, band ) * scale;\n}\n\n// p = point\n// c = center\n// r = radius\n// band = thickness\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec3 p, in vec3", "\n    float d = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%5];\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = max( d, length( pa - ba*h ) - r );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/4s23zG\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.x = p.x * 2.0 + p.y * -k.x;\n    p.y = p.y * k.z;\n    vec2 a = p - 2.0*k.xy + k.yy;\n    vec2 b = p - k.yx;\n    vec2 c = p + k.yx;\n    vec2 d = p + 2.0*k.xy - k.yy;\n    vec2 e = p + 2.0*k.xy + k.yy;\n    vec2 f = p + k.yx + k.xx;\n    vec3 dab = vec3( length(a), length(b), length(c) );\n    vec3 dcd = vec3( length(d), length(e), length(f) );\n    vec3 dmin = min( dab, dcd );\n    float da = dmin.x;\n    float db = dmin.y;\n    float dc = dmin.z;\n    return min( da, min( db, dc ) ) - 1.5 * r;\n}\n\n// https://www.shadertoy.com/view/4s23zG\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809017, 0.587785, 0.72654", "\n\tvec4 res = vec4( 0.0 );\n\tfloat d = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( mix( a, b, h ), h );\n}\n\n// 2D line segment with distance to gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( mix( a, b, h ), h );\n}\n\n// 2D line segment with distance to gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float g )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( mix( a, b, h ), h );\n}\n\n// 2D line segment with distance to gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float g, in float t )\n{\n    vec2 pa = p-a, ba = b-a", "\n    vec3  q = vec3( p.x, p.y, 0.0 );\n    float d = 0.0;\n    float s = 0.0;\n    for( int i = 0; i < 6; i++ ) \n    {\n        q.yz = rot( q.yz, 60.0 );\n        q.xz = rot( q.xz, 60.0 );\n        q.xy = csgHexPrism( q.xy, r );\n        d = max( d, -q.y );\n        s = max( s, q.x );\n    }\n    return vec3( s, d, q.z );\n}\n\n// 2D Voronoi with distance to borders\n//.x = distance to borders\n//.y = distance to center\n//.z = index of the closest feature\nvec3 voronoi( in vec2 x, in vec2 n ) \n{\n    vec3 d = vec3( 100.0 );\n    for( int j = 0; j < 8; j++ ) \n    {\n        vec2  p = mod( x + n * float( j ), n ) - 0.5 * n;\n        float l = length( p );\n        d = min( d, vec3( l, dot( p, normalize( x ) ), float( j ) ) );\n    }\n    return d;\n}\n\n// 2D Voronoi with distance to borders\n//.x = distance to borders\n//.y = distance to center\n//.z = index of the closest feature\nvec3 voronoi( in vec2 x, in vec2 n, in float j ) \n{\n    vec3 d = vec3( 100.0 );\n    for( int i = 0; i < 8; i++ ) \n    {\n        vec2  p = mod( x + n * float( i ), n ) - 0.5 * n;\n        float l = length( p );\n        d = min( d, vec3( l, dot( p, normalize( x ) ), float( i ) ) );\n    }\n    return d;\n}\n\n// 2D Voronoi with distance to borders\n//.x = distance to borders\n//.y = distance to center\n//.z = index", "\n    vec3 n = normalize(p);\n    vec3 d = X * n;\n    float a = dot(d, d);\n    float b = dot(d, p);\n    float c = dot(p, p);\n    float discr = b * b - a * c;\n    if (discr < 0.0) return false;\n    float t = (-b - sqrt(discr)) / a;\n    tan1 = d + t * p;\n    tan2 = d - t * p;\n    return true;\n}\n\n// Compute the intersection of a line and a conic.\n// Return false if no intersection (eg. line is parallel to conic).\nbool intersect(vec3 p, vec3 d, mat3 X, out vec3 q) {\n    vec3 n = normalize(d);\n    vec3 m = X * n;\n    float a = dot(m, m);\n    float b = 2.0 * dot(m, p);\n    float c = dot(p, p) - 1.0;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0) return false;\n    float t = (-b - sqrt(discr)) / (2.0 * a);\n    q = p + t * d;\n    return true;\n}\n\n// Compute the intersection of a line and a conic.\n// Return false if no intersection (eg. line is parallel to conic).\nbool intersect(vec3 p, vec3 d, mat3 X, out vec3 q1, out vec3 q2) {\n    vec3 n = normalize(d);\n    vec3 m = X * n;\n    float a = dot(m, m);\n    float b = 2.0 * dot(m, p);\n    float c = dot(p, p) - 1.0;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0) return false;\n    float t = (-b - sqrt(discr)) / (2.0 * a);\n    q1 = p + t * d;\n    t = (-b + sqrt(discr)) / (2.0 * a);\n    q2 = p + t * d;\n    return true;\n}\n", "\n\treturn vec3(a.x / (b.x + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, float a, vec3 axis)\n{\n    vec3 axe = normalize(axis);\n    float s = sin(a);\n    float c = cos(a);\n    float r = 1.0 - c;\n    return vec3(\n        axe.x * axe.x * r + c,\n        axe.y * axe.x * r + axe.z * s,\n        axe.z * axe.x * r - axe.y * s,\n        0) *\n               p +\n           vec3(\n               axe.x * axe.y * r - axe.z * s,\n               axe.y * axe.y * r + c,\n               axe.z * axe.y * r + axe.x * s,\n               0) *\n                   p +\n           vec3(\n               axe.x * axe.z * r + axe.y * s,\n               axe.y * axe.z * r - axe.x * s,\n               axe.z * axe.z * r + c,\n               0) *\n                   p;\n}\n\n// Distance functions\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max", "\n\treturn 1.0 - x * x * x / (R * R * R);\n}\n\n// Quadratic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn 1.0 - x * x / (R * R);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn 1.0 - x / R;\n}\n\n// No falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn 1.0;\n}\n\n// Calculate the lighting contribution from a single light\n// N: surface normal\n// L: direction to light\n// V: direction to view\n// P: world position of pixel\n// attenuation: pre-calculated attenuation\nfloat3 CalculateLight(float3 N, float3 L, float3 V, float3 P, float attenuation)\n{\n\t// Calculate Rim lighting\n\tfloat rim = 1.0 - saturate(dot(N, V));\n\trim = smoothstep(RimThreshold, RimThreshold + RimFalloff, rim);\n\trim = pow(rim, RimPower);\n\n\t// Calculate shadow\n\tfloat shadow = 1.0;\n\tif (ShadowType > 0)\n\t{\n\t\tshadow = CalculateShadow(P);\n\t}\n\n\t// Calculate lighting\n\tfloat ndotl = saturate(dot(N, L));\n\tfloat3 light = LightColor.rgb * ndotl * attenuation * shadow;\n\n\t// Add rim lighting\n\tlight += RimColor.rgb * rim;\n\n\treturn light;\n}\n\n// Calculate the lighting contribution from a single point light\n// N: surface normal\n// V: direction to view\n// P: world position of pixel\n// attenuation: pre-calculated attenuation\nfloat3 CalculatePointLight(float3 N, float3 V, float3 P, float attenuation)\n{\n\t// Calculate light vector\n\tfloat3 L = LightPosition.xyz - P;\n\n\t// Calculate distance (used for attenuation)\n", "\n\treturn 1.0f / (e * e * R * R);\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R)\n{\n\treturn 1.0f / (e * e * R * R);\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k)\n{\n\treturn k / (e * e * R * R);\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float k2)\n{\n\treturn k / (e * e * R * R) + k2;\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float k2, float k3)\n{\n\treturn k / (e * e * R * R) + k2 + k3 * e;\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float k2, float k3, float k4)\n{\n\treturn k / (e * e * R * R) + k2 + k3 * e + k4 * e * e;\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float k2, float k3, float k4, float k5)\n{\n\treturn k / (e * e * R * R) + k2 + k3 * e + k4 * e * e + k5 * e * e * e;\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat Falloff(float e, float R, float k, float k2, float k3, float k4, float k5, float k6)\n{\n\treturn k / (e * e * R * R) + k2 + k3 * e + k4 * e * e + k5 * e * e", "\n\tfloat k = 0.0;\n\tif (a > b)\n\t{\n\t\tk = (a - b) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R)\n{\n\tfloat k = 0.0;\n\tif (a > b)\n\t{\n\t\tk = (a - b) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b)\n{\n\tfloat k = 0.0;\n\tif (a > b)\n\t{\n\t\tk = (a - b) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a)\n{\n\tfloat k = 0.0;\n\tif (a > b)\n\t{\n\t\tk = (a - b) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK()\n{\n\tfloat k = 0.0;", "\n\treturn length(p - c) - R;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n\treturn length(p - c) - R;\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Box(vec3 p, vec3 c, vec3 s, float e)\n{\n\treturn length(max(abs(p - c) - s, 0.0));\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// h: height\n// r: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float h, float r, float e)\n{\n\treturn max(length(p.xz - c.xz) - r, abs(p.y - c.y) - h);\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// r: radius\n// t: thickness\n// e: energy\nfloat Torus(vec3 p, vec3 c, float r, float t, float e)\n{\n\tvec2 q = vec2(length(p.xz - c.xz) - r, p.y - c.y);\n\treturn length(q) - t;\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// h: height\n// r1: bottom radius\n// r2: top radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float h, float r1, float r2, float e)\n{\n\tvec2 q = vec2(length(p.xz - c.xz), p.y - c.y);\n\tvec2 k1 = vec2(r2, h);\n\tvec2 k2 = vec2(r2 - r1, 2.0 * h);\n\tfloat a = length(q - k1) - k2.x;\n\tfloat b = length(q) - r1;\n\tfloat k =", "\n\tvec3 d = b - a;\n\tfloat l = length(d);\n\td /= l;\n\tvec3 n = normalize(cross(d, vec3(0, 0, 1)));\n\tvec3 p = c - a;\n\tfloat t = dot(p, d);\n\tfloat h = dot(p, n);\n\tfloat r = sqrt(R * R - h * h);\n\tfloat s = sqrt(r * r - t * t);\n\tfloat x = t - s;\n\tfloat y = t + s;\n\tfloat z = l;\n\tfloat e1 = e + x * x / R;\n\tfloat e2 = e + y * y / R;\n\tfloat e3 = e + z * z / R;\n\treturn max(max(e1, e2), e3);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b, out float t)\n{\n\tvec3 d = b - a;\n\tfloat l = length(d);\n\td /= l;\n\tvec3 n = normalize(cross(d, vec3(0, 0, 1)));\n\tvec3 p = c - a;\n\tt = dot(p, d);\n\tfloat h = dot(p, n);\n\tfloat r = sqrt(R * R - h * h);\n\tfloat s = sqrt(r * r - t * t);\n\tfloat x = t - s;\n\tfloat y = t + s;\n\tfloat z = l;\n\tfloat e1 = e + x * x / R;\n\tfloat e2 = e + y * y / R;\n\tfloat e3 = e + z * z / R;\n\treturn max(max(e1, e2), e3);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a", "\n\tfloat d = 0.0;\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d43 =", "\n\treturn length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n\treturn length(cross(a - b, a - c));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\treturn length(cross(a - b, a - c) + cross(a - c, a - d));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n\treturn length(cross(a - b, a - c) + cross(a - c, a - d) + cross(a - d, a - e));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\n\treturn length(cross(a - b, a - c) + cross(a - c, a - d) + cross(a - d, a - e) + cross(a - e, a - f));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g)\n{\n\treturn length(cross(a - b, a - c) + cross(a - c, a - d) + cross(a - d, a - e) + cross(a - e, a - f) + cross(a - f, a - g));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f, vec3 g, vec3 h)\n{\n\treturn length(cross(a - b, a - c) + cross(a - c, a - d) + cross(a - d, a - e) + cross(a - e, a - f) + cross(a - f, a - g) + cross(a - g, a - h));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e,", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Object(p+eps.xyy).x - Object(p-eps.xyy).x,\n        Object(p+eps.yxy).x - Object(p-eps.yxy).x,\n        Object(p+eps.yyx).x - Object(p-eps.yyx).x );\n    return normalize(nor);\n}\n\n// Normal evaluation with offset\nvec3 ObjectNormalOffset(in vec3 p, in float offset )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Object(p+eps.xyy).x - Object(p-eps.xyy).x,\n        Object(p+eps.yxy).x - Object(p-eps.yxy).x,\n        Object(p+eps.yyx).x - Object(p-eps.yyx).x );\n    return normalize(nor);\n}\n\n// Normal evaluation with offset\nvec3 ObjectNormalOffset(in vec3 p, in float offset, in float scale )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Object(p+eps.xyy).x - Object(p-eps.xyy).x,\n        Object(p+eps.yxy).x - Object(p-eps.yxy).x,\n        Object(p+eps.yyx).x - Object(p-eps.yyx).x );\n    return normalize(nor);\n}\n\n// Normal evaluation with offset\nvec3 ObjectNormalOffset(in vec3 p, in float offset, in float scale, in float time )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Object(p+eps.xyy).x - Object(p-eps.xyy).x,\n        Object(p+eps.yxy).x - Object(p-eps.yxy).x,\n        Object(p+eps.yyx).x - Object(p-", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor(int i = 0; i < 100; i++)\n\t{\n\t\ts = i;\n\t\tvec3 p = o + u * t;\n\t\tfloat d = Distance(p);\n\t\tif(d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t}\n\treturn t;\n}\n\n// Calculate normal using sphere tracing\n// o : ray origin\n// u : ray direction\n// t : ray length\nvec3 Normal(vec3 o, vec3 u, float t)\n{\n\tvec3 p = o + u * t;\n\tvec3 n = vec3(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec3 e = 0.5773 * (2.0 * vec3(i, i + 1.0, i + 2.0) - 1.0);\n\t\tn += e * Distance(p + 0.0005 * e);\n\t}\n\treturn normalize(n);\n}\n\n// Calculate lighting\n// o : ray origin\n// u : ray direction\n// t : ray length\n// n : normal\n// h : hit\nvec3 Lighting(vec3 o, vec3 u, float t, vec3 n, bool h)\n{\n\tvec3 c = vec3(0.0);\n\tif(h)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tvec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\t\tvec3 r = reflect(l, n);\n\t\tvec3 v = normalize(-u);\n\t\tfloat d = max(0.0, dot(n, l));\n\t\tfloat s = pow(max(0.0, dot(r, v)), 32.0);\n\t\tc = vec3(0.2, 0.2, 0.2) + d * vec3(0.8, 0.8, 0.8) + s * vec3(", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + u * t;\n\t\tfloat d = DistanceField(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + u * t;\n\t\tfloat d = DistanceField(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + u * t;\n\t\tfloat d = DistanceField(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\tn = Normal(p);\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s :", "\n\treturn vec3(0.0);\n}\n\nvec3 Shade(vec3 rd, vec3 ro, vec3 pos, vec3 normal, vec3 color, float dist)\n{\n\tvec3 light = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 lightColor = vec3(1.0);\n\tvec3 ambient = vec3(0.1);\n\tvec3 diffuse = max(dot(normal, light), 0.0) * lightColor;\n\tvec3 specular = pow(max(dot(reflect(light, normal), -rd), 0.0), 10.0) * lightColor;\n\tvec3 shade = (ambient + diffuse + specular) * color;\n\treturn shade;\n}\n\n// Raymarching\nvec3 Raymarch(vec3 ro, vec3 rd)\n{\n\tfloat dist = 0.0;\n\tvec3 pos = vec3(0.0);\n\tvec3 color = vec3(0.0);\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tpos = ro + rd * dist;\n\t\tfloat d = Map(pos);\n\t\tif (d < EPSILON)\n\t\t{\n\t\t\tcolor = Shade(rd, ro, pos, Normal(pos), vec3(1.0), dist);\n\t\t\tbreak;\n\t\t}\n\t\tdist += d;\n\t\tif (dist > MAX_DIST)\n\t\t{\n\t\t\tcolor = Background(rd);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\n// Camera\nvec3 Camera(vec2 uv)\n{\n\tvec3 ro = vec3(0.0, 0.0, 1.0);\n\tvec3 rd = normalize(vec3(uv, -1.0));\n\treturn Raymarch(ro, rd);\n}\n\nvoid main()\n{\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 color = Camera(uv);\n\tgl_FragColor = vec4(color, 1.0);\n}/src/chapter_00", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat baba = dot(ba,ba), paba = dot(pa,ba), dd = paba*paba - baba*dot(pa,pa);\n\tfloat s = sqrt(dd);\n\treturn (dd > 0.0)? ((s - r) / max(s, r)) : length(pa);\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat baba = dot(ba,ba), paba = dot(pa,ba), x = length(pa*baba-ba*paba) - (r1+r2)*sqrt(abs(baba - paba*paba/baba));\n\tfloat y = abs(paba - baba*0.5) - baba*0.5;\n\tfloat z = dot(pa,ba);\n\treturn max(max(x,y),z);\n}\n\n// arbitrary orientation\nfloat sdConeSection(vec3 p, vec3 a, vec3 b, float h, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat baba = dot(ba,ba), paba = dot(pa,ba), x = length(pa*baba-ba*paba) - (r1+r2)*sqrt(abs(baba - paba*paba/baba));\n\tfloat y = abs(paba - baba*h) - baba*h;\n\tfloat z = dot(pa,ba);\n\treturn max(max(x,y),z);\n}\n\n// arbitrary orientation\nfloat sdTorus(vec3 p, vec3 t, in vec2 r)\n{\n\tvec3 pt = p - t;\n\treturn length(vec2(length(pt.xz) - r.x, pt.y)) - r.y;\n}\n\n// arbitrary orientation\nfloat sdTorus82(vec3 p, vec3 t, in vec2 r)\n{\n\tvec3 pt =", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized", "\n    return coord / vec2(u_resolution.x, u_resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord() {\n    return gl_FragCoord.xy / vec2(u_resolution.x, u_resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord) {\n    return coord.xy / vec2(u_resolution.x, u_resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord, vec4 resolution) {\n    return coord.xy / vec2(resolution.x, resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord, vec2 resolution) {\n    return coord.xy / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution) {\n    return coord / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec4 resolution) {\n    return coord / vec2(resolution.x, resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec3 resolution) {\n    return coord / vec2(resolution.x, resolution.y);\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset) {\n    return (coord + offset) / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale) {\n    return (coord + offset) / resolution * scale;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 aspect) {\n    return (coord + offset) / resolution * scale * aspect;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 aspect, vec2 flip) {\n    return (coord + offset) / resolution * scale * aspect * flip;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 aspect, vec2 flip, vec2 rotate)", "\n    vec2 p1 = q-p;\n    vec2 p2 = vec2(p1.x, -p1.y);\n    float s = sign(p1.x*p1.x + p1.y*p1.y);\n    p1 *= s;\n    p2 *= s;\n\n    vec2 d = p - p1*clamp( dot(p,p1)/dot(p1,p1), 0.0, 1.0 );\n\n    float x = d.x - min(d.x, d.y);\n    float y = d.y - min(d.x, d.y);\n    float z = dot(d, normalize(p2 - p1));\n\n    return vec3(x, y, z);\n}\n\n//\n// 2D simplex noise\n//\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author :,.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0", "\n    float x = length(p) - r;\n    float y = length(p - vec2(r, 0.0)) - r;\n    float z = length(p - vec2(0.0, r)) - r;\n    float m = min(x, min(y, z));\n    float s = sign(m);\n    float a = s * x;\n    float b = s * y;\n    float c = s * z;\n    float e = max(max(a, b), c);\n    float f = min(min(a, b), c);\n    float g = max(a, max(b, c));\n    float h = min(b, min(c, a));\n    float i = max(c, max(a, b));\n    float j = min(a, min(b, c));\n    float k = max(a, max(b, c));\n    float l = min(b, min(c, a));\n    float n = max(c, max(a, b));\n    float o = min(a, min(b, c));\n    float q = max(a, max(b, c));\n    float t = min(b, min(c, a));\n    float u = max(c, max(a, b));\n    float v = min(a, min(b, c));\n    float w = max(a, max(b, c));\n    float yz = (e - f) * (g - h) * (i - j) * (k - l) * (n - o) * (q - t) * (u - v) * (w - e);\n    return vec3(m, yz, s);\n}\n\n// 2D Voronoi diagram\n//.x = distance to closest point\n//.y = closest point index\n//.z = closest point position\nvec3 sdgVoronoi(vec2 p, vec2 g, float n)\n{\n    vec2 i = floor(p / g);\n    vec2 f = fract(p / g);\n    float m = 8.0;\n    vec2 o;\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {", "\n    vec2 q = vec2( dot(p,c), p.x*c.y-p.y*c.x );\n    return vec3( q, abs(q.x)-r, q.y );\n}\n\n// p.x = distance to line\n// p.y = distance to line segment\n// p.z = sin/cos of the angle\n// p.w = radius\nvec4 sdgLine( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ), distance( p, mix( a, b, h ) ), dot( normalize(ba), pa ), r );\n}\n\n// p.x = distance to line\n// p.y = distance to line segment\n// p.z = sin/cos of the angle\n// p.w = radius\nvec4 sdgLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ), distance( p, mix( a, b, h ) ), dot( normalize(ba), pa ), r );\n}\n\n// p.x = distance to line\n// p.y = distance to line segment\n// p.z = sin/cos of the angle\n// p.w = radius\nvec4 sdgLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float t, in float e )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ), distance( p, mix( a, b, h ) ), dot( normalize(ba), pa ), r );\n}\n\n// p.", "\n    vec2 e0 = v[1] - v[0];\n    vec2 e1 = v[2] - v[1];\n    vec2 e2 = v[0] - v[2];\n\n    vec2 v0 = p - v[0];\n    vec2 v1 = p - v[1];\n    vec2 v2 = p - v[2];\n\n    vec2 pq0 = v0 - e0 * clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1 * clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2 * clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x) ) ),\n                  vec2( dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x) ) );\n\n    return vec3( sqrt(d.x), s*d.y, s );\n}\n\n// 2D signed distance to a line segment\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(", "\n    vec2 q = p*mat2(sca.x,-sca.y,sca.y,sca.x);\n    vec2 r = q*mat2(scb.x,-scb.y,scb.y,scb.x);\n    float d = length(r)-rb;\n    float f = length(q)-ra;\n    return vec3( d, f, d/f );\n}\n\n// signed distance function for a line segment\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length( pa - ba*h ), pa.x - ba.x*h, pa.y - ba.y*h );\n}\n\n// signed distance function for a line segment with rounded caps\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLineCaps( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length( pa - ba*h ) - r, pa.x - ba.x*h, pa.y - ba.y*h );\n}\n\n// signed distance function for a line segment with rounded caps\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with", " return a.x*b.y - a.y*b.x; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//\n// 2D simplex noise\n//\nfloat snoise( in vec2 v ) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute(", "\n    vec2 q = p/ab;\n    float f = dot(q,q) - 1.0;\n    vec2 df = 2.0*q;\n    return vec3( f, df );\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus( vec3 p, in vec2 ab )\n{\n    vec2 q = vec2(length(p.xz)-ab.x,p.y);\n    float f = length(q)-ab.y;\n    vec2 df = normalize(q);\n    return vec3( f, df.x*p.x/q.x, df.y );\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCylinder( vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float f = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    vec2 df = (d.x > d.y)? vec2(1.0,0.0) : vec2(0.0,1.0);\n    df = normalize(vec2(d.x*df.x,d.y*df.y));\n    return vec3( f, df.x*p.x/d.x, df.y*p.y/d.y );\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCone(", "\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4( length(q)-rb, normalize( vec3(q.x,0,q.y) ) );\n}\n\n// p.x = f(p)\n// p.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( length(p)-r, normalize(p) );\n}\n\n// p.x = f(p)\n// p.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec4( min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), normalize( -sign(d)*step(d.yzx,d.xyz)*step(d.zxy,d.xyz) ) );\n}\n\n// p.x = f(p)\n// p.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return vec4( min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r, normalize( -sign(d)*step(d.yzx,d.xyz)*step(d.zxy,d.xyz) ) );\n}\n\n// p.x = f(p)\n// p.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return vec4( dot(p,n.xyz) + n.w, n.xyz );\n}\n\n// p.x = f(p)\n// p.yzw = \u2207f(", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( mix( a, b, h ), h );\n}\n\n// Signed distance to a line segment with rounded caps.\n//\n// p = point\n// a = start of line segment\n// b = end of line segment\n// r = radius of the line segment\n// c = radius of the caps\nfloat sdSegmentRoundCaps( vec3 p, vec3 a, vec3 b, float r, float c )\n{\n    vec4 s = sdgSegment( p, a, b, r );\n    return mix( length(s.xyz-p) - r, length(s.xyz-a)-c, s.w );\n}\n\n// Signed distance to a line segment with rounded caps.\n//\n// p = point\n// a = start of line segment\n// b = end of line segment\n// r = radius of the line segment\n// c = radius of the caps\nfloat sdSegmentRoundCaps( vec3 p, vec3 a, vec3 b, float r, float c, out vec3 n )\n{\n    vec4 s = sdgSegment( p, a, b, r );\n    float d = mix( length(s.xyz-p) - r, length(s.xyz-a)-c, s.w );\n    n = normalize(s.xyz-p);\n    return d;\n}\n\n// Signed distance to a line segment with rounded caps.\n//\n// p = point\n// a = start of line segment\n// b = end of line segment\n// r = radius of the line segment\n// c = radius of the caps\nfloat sdSegmentRoundCaps( vec3 p, vec3 a, vec3 b, float r, float c, out vec3 n, out vec3 pa )\n{\n    vec4 s = sdgSegment( p, a, b, r );\n    float d = mix( length(s.xyz-p) - r, length(s.xyz-a)-c, s.w );\n    n = normalize(s.xyz-p);\n    pa = s.xyz-p;\n    return d;\n}\n\n// Signed distance to a line segment with", "\n    float sx = wi + sk;\n    float sy = he;\n    vec2 q = vec2( p.x*sx - p.y*sk, p.x*sk + p.y*sy );\n    vec2 d = abs(q) - vec2(wi,he);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    float sx = wi + sk;\n    float sy = he;\n    vec2 q = vec2( p.x*sx - p.y*sk, p.x*sk + p.y*sy );\n    vec2 d = abs(q) - vec2(wi,he);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    float sx = wi + sk;\n    float sy = he;\n    vec2 q = vec2( p.x*sx - p.y*sk, p.x*sk + p.y*sy );\n    vec2 d = abs(q) - vec2(wi,he);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    float sx = wi + sk;\n    float sy = he;\n    vec2 q = vec2( p.x*sx - p.y*sk, p.x*sk + p.y*sy );\n    vec2 d = abs(q) - vec2(wi,he);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));", "\n    vec2 q = vec2( p.x*wi, p.y*he );\n    vec2 a = p - q;\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c = vec2( 0.0, he );\n    float s = -dot(q,b)/dot(c,b);\n    vec2 d = a - s*c;\n    return vec3( dot(q,b), -dot(d,b), dot(d,c) );\n}\n\n// 2D simplex noise\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0", "\n\treturn p + c;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\treturn opRep1D( p.x, c.x ) + opRep1D( p.y, c.y );\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\treturn opRep1D( p.x, c.x ) + opRep1D( p.y, c.y ) + opRep1D( p.z, c.z );\n\t}\n\n//----------oPeraciones de Transformacion\nvec3 opTrans( vec3 p, vec3 t )\n\t{\n\treturn p - t;\n\t}\n\nvec3 opRot( vec3 p, vec3 a )\n\t{\n\tvec3 aCos = cos( a );\n\tvec3 aSin = sin( a );\n\tmat3 m = mat3( aCos.y * aCos.z, aSin.y * aCos.z, -aSin.z,\n\t               aSin.x * aSin.y * aCos.z - aCos.x * aSin.z, aCos.x * aCos.z + aSin.x * aSin.y * aSin.z, aSin.x * aCos.y,\n\t               aSin.x * aSin.z + aCos.x * aSin.y * aCos.z, aCos.x * aSin.y * aSin.z - aSin.x * aCos.z, aCos.x * aCos.y );\n\treturn m * p;\n\t}\n\nvec3 opScale( vec3 p, vec3 s )\n\t{\n\treturn p / s;\n\t}\n\n//----------oPeraciones de Union\nfloat opUnion( float d1, float d2 )\n\t{\n\treturn min( d1, d2 );\n\t}\n\nfloat opUnion( float d1, float d2, float d3 )\n\t{\n\treturn min( d1, min( d2, d3 ) );\n\t}\n\nfloat opUnion( float d1, float d2, float d3, float d4 )\n\t{\n\treturn min(", "\n\treturn (a < b)? a : b;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n\treturn (a > b)? a : b;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n\treturn pmin(pmax(a, b, k), 1.0, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n\treturn pclamp((a - b) / (1.0 - b), 0.0, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float k) {\n\treturn pclamp((a - b) / (c - b), 0.0, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float d, float k) {\n\treturn pclamp((a - b) / (c - b), d, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float d, float e, float k) {\n\treturn pclamp((a - b) / (c - b), d, e, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float d, float e, float f, float k) {\n\treturn pclamp((a - b) / (c - b), d, e, f, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float d, float e, float f, float g, float k) {\n\treturn pclamp((a - b) / (c - b), d, e, f, g, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float c, float d, float e, float f, float g, float h, float k) {\n\treturn p", "\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q =", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(v_color.x, 1.0, 1.0));\n    o_color = vec4(color, 1.0);\n}\n/src/main.rs\nuse std::time::Instant;\n\nuse glutin::event::{Event, WindowEvent};\nuse glutin::event_loop::{ControlFlow, EventLoop};\nuse glutin::window::WindowBuilder;\nuse glutin::ContextBuilder;\nuse glutin::PossiblyCurrent;\nuse glutin::WindowedContext;\n\nuse gl::types::*;\n\nuse gl;\n\nuse rand::Rng;\n\nuse std::ffi::CString;\n\nuse std::ptr;\nuse std::str;\n\nuse std::mem;\n\nuse std::os::raw::c_void;\n\nuse std::fs;\n\nuse std::io::Read;\n\nuse std::collections::HashMap;\n\nuse std::rc::Rc;\n\nuse std::cell::RefCell;\n\nuse std::sync::mpsc;\n\nuse std::thread;\n\nuse std::sync::Arc;\n\nuse std::sync::Mutex;\n\nuse std::sync::mpsc::Sender;\n\nuse std::sync::mpsc::Receiver;\n\nuse std::sync::mpsc::channel;\n\nuse std::sync::mpsc::TryRecvError;\n\nuse std::sync::mpsc::RecvTimeoutError;\n\nuse std::sync::mpsc::RecvError;\n\nuse std::sync::mpsc::SendError;\n\nuse std::sync::mpsc::TrySendError;\n\nuse std::sync::mpsc::RecvTimeoutError::Timeout;\n\nuse std::sync::mpsc::RecvTimeoutError", "\n\tvec3 oc = ro - s.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - s.w*s.w;\n\tfloat h = b*b - c;\n\tif (h < 0.0) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n\treturn -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 b) {\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*b;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\tif (tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2(tN, tF);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross(rd, e2);\n\tfloat a = dot(e1, p);\n\tvec3 s = ro - v0;\n\tvec3 q = cross(s, e1);\n\tvec2 tuv = vec2(dot(e2, q), dot(s, p)) / a;\n\tif (a > 0.0 && tuv.x >= 0.0 && tuv.x <= 1.0 && tuv.y >= 0.0 && tuv.y", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs(m) * boxSize;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\toutNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\treturn vec2( tN, tF );\n}\n\n// IQ's ray sphere intersection\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\th = sqrt(h);\n\treturn -b - h;\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 pla) {\n\tfloat t = -(dot(ro, pla.xyz) + pla.w) / dot(rd, pla.xyz);\n\treturn t;\n}\n\n// IQ's ray cylinder intersection\nfloat rayCylinder(vec3 ro, vec3 rd, vec4 cyl) {\n\tvec3 oc = ro - cyl.xyz;\n\tfloat a = dot(rd.xz, rd.xz);\n\tfloat b = dot(oc.xz, rd.xz);\n\tfloat c = dot(oc.xz, oc.xz) - cyl.w*cyl.w;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\th = sqrt(h);\n\tfloat t = (-", "\n    vec2 p1 = vec2(p.x - d.x, p.y - d.y);\n    vec2 p2 = vec2(p.x + d.x, p.y - d.y);\n    vec2 p3 = vec2(p.x + d.x, p.y + d.y);\n    vec2 p4 = vec2(p.x - d.x, p.y + d.y);\n    e1 = p1 - p;\n    e2 = p2 - p;\n    e3 = p3 - p;\n    e4 = p4 - p;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n    vec2 p1 = vec2(p.x - d.x, p.y - d.y);\n    vec2 p2 = vec2(p.x + d.x, p.y - d.y);\n    vec2 p3 = vec2(p.x + d.x, p.y + d.y);\n    vec2 p4 = vec2(p.x - d.x, p.y + d.y);\n    vec2 p5 = vec2(p.x - d.x, p.y);\n    vec2 p6 = vec2(p.x + d.x, p.y);\n    vec2 p7 = vec2(p.x, p.y - d.y);\n    vec2 p8 = vec2(p.x, p.y + d.y);\n    e1 = p1 - p;\n    e2 = p2 - p;\n    e3 = p3 - p;\n    e4 = p4 - p;\n    e5 = p5 - p;\n    e6 = p6 - p;\n    e7 = p7 - p;\n    e8 = p8 - p;\n}\n\n//returns the vectors pointing to each edge of the", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b) {\n    return linedist(p, a, b) - 0.005;\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return min(dist(p, a, b), dist(p, b, c));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return min(dist(p, a, b, c), dist(p, b, c, d));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n    return min(dist(p, a, b, c, d), dist(p, b, c, d, e));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n    return min(dist(p, a, b, c, d, e), dist(p, b, c, d, e, f));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g) {\n    return min(dist(p, a, b, c, d, e, f), dist(p, b, c, d, e, f, g));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h) {\n    return min(dist(p, a, b, c, d, e, f, g), dist(p, b, c, d, e, f, g, h));\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e,", "\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + h*ba;\n    vec2 pq = p - q;\n    float r = length(pq)*sign(pq.x*ba.y-pq.y*ba.x);\n    float d = abs(r)-w1;\n    float f = abs(r)-w2;\n    return min(d,f);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h1 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + h1*ba;\n    vec2 pq = p - q;\n    float r = length(pq)*sign(pq.x*ba.y-pq.y*ba.x);\n    float d = abs(r)-w1;\n    float f = abs(r)-w2;\n    return min(d,f);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float h, float t )\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h1 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + h1*ba;\n    vec2 pq = p - q;\n    float r = length(pq)*sign(pq.x*ba.y-pq.y*ba.x);\n    float d = abs(r)-w1;\n    float f = abs(r)-w2;\n    return min(d,f);\n}\n\n// The arrow goes from a to b. It's", "\n    vec2 r = vec2(tor.x, tor.y);\n    vec2 q = vec2(length(ro.xz) - r.x, ro.y);\n    float b = dot(rd.xz, q);\n    float c = dot(q, q) - r.y * r.y;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayBox(vec3 ro, vec3 rd, vec3 box) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * box;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec3 nor) {\n    float denom = dot(rd, nor);\n    if (abs(denom) < 0.0001) return", "\n    vec2 q = vec2(length(pos.xz)-tor.x,pos.y);\n    return normalize(vec3(-q.x,q.y,pos.z));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus82( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return pow(length(q)-t.y,8.0)-pow(t.y,8.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus88( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return pow(pow(length(q)-t.y,8.0)-pow(t.y,8.0),8.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdCone( in vec3 p,", "\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx2(float x) {\n    return x / (1.0 + abs(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx3(float x) {\n    return x / (1.0 + abs(x)) * 0.5 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx4(float x) {\n    return x / (1.0 + abs(x)) * 0.25 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx5(float x) {\n    return x / (1.0 + abs(x)) * 0.125 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx6(float x) {\n    return x / (1.0 + abs(x)) * 0.0625 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx7(float x) {\n    return x / (1.0 + abs(x)) * 0.03125 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx8(float x) {\n    return x / (1.0 + abs(x)) * 0.015625 + 0.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_approx9(float x) {\n    return x / (1.0 + abs(x)) * 0.0078125 + 0.5;\n", "\n    col = clamp(col * 0.5 + 0.5 * col * col * 1.2, 0.0, 1.0);\n    col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nfloat getAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aop = n * hr + p;\n        float dd = map(aop).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 getLight(vec3 p, vec3 n) {\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(vec3(0.9, 0.2, -0.4));\n    float dif = clamp(dot(n,", "\n\tvec2 c = floor((p + size * 0.5) / size);\n\tp = mod(p + size * 0.5, size) - size * 0.5;\n\treturn c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec4 p, vec4 b) {\n\tvec4 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, max(d.z, d.w))), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdEllipsoid(vec3 p, vec3 r) {\n\tfloat k0 = length(p / r);\n\tfloat k1 = length(p / (r * r));\n\treturn k0 * (k0 - ", "\n\tfloat f = uv.x + uv.y * 1e3;\n\treturn fract(sin(f) * 1e5);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat noise(vec2 uv) {\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\tf = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x), mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat fbm(vec2 uv) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(uv); uv *= 2.02;\n\tf += 0.2500 * noise(uv); uv *= 2.03;\n\tf += 0.1250 * noise(uv); uv *= 2.01;\n\tf += 0.0625 * noise(uv);\n\treturn f / 0.9375;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat pattern(vec2 uv) {\n\tfloat f = fbm(uv);\n\treturn f;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nvec3 pattern(vec2 uv, vec2 offset) {\n\tfloat f = pattern(uv + offset);\n\treturn vec3(f, f, f);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nvec3 pattern(vec2 uv, vec2 offset, float scale) {\n\tfloat f = pattern(uv * scale + offset);\n\treturn vec3(f, f, f);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nvec3 pattern(", "\n    return length(p-c) - r;\n}\n\n// signed distance to a plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n    ?\n     min( min(\n     dot(ba*clamp(dot(ba,pa)/dot(ba,ba),0.0,1.0)-pa,nor),\n     dot(cb*clamp(dot(cb,pb)/dot(cb,cb),0.0,1.0)-pb,nor) ),\n     dot(ac*clamp(dot(ac,pc)/dot(ac,ac),0.0,1.0)-pc,nor) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot(nor,nor) );\n}\n\n// signed distance to a box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a cylinder\nfloat sdCylinder( in vec3 p, in vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\n// signed distance to a cone\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c.xy,vec2(q,p.", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, in float r )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to a line segment\nfloat sd", " return a.x*b.y-a.y*b.x; }\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross( ba, ac );\n    return sqrt(\n    (sign(cro(ba,nor))*pa.x*pa.x + sign(cro(ba,nor))*pa.y*pa.y)/dot(ba,ba) +\n    (sign(cro(cb,nor))*pb.x*pb.x + sign(cro(cb,nor))*pb.y*pb.y)/dot(cb,cb) +\n    (sign(cro(ac,nor))*pc.x*pc.x + sign(cro(ac,nor))*pc.y*pc.y)/dot(ac,ac) ) * sign( nor.z );\n}\n\n// signed distance to a 2D rectangle\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance to a 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x, r.y), 0.0);\n}\n\n// signed distance to a 2D line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance to a 2", "\n    vec2 q = abs(p) - s;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in float r ) \n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in float s, in float r ) \n{\n    vec4 q = abs(p) - s;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in vec2 s, in float r ) \n{\n    vec2 q = abs(p) - s;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in vec3 s, in float r ) \n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in vec4 s, in float r ) \n{\n    vec4 q = abs(p) - s;\n    return min(max(q.x,max(q.y,max(q.z,q.w))),0.0) + length(max(q,0.0)) - r", "\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x * (a * x + b)) / (x * (c * x + d) + e));\n}\n\nvec3 Uncharted2Tonemap(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2Tonemap(vec3 x, float exposure)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2Tonemap(vec3 x, float exposure, float white_point)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2Tonemap(vec3 x, float exposure, float white", "\n\treturn 2.0 * x * (1.0 - x);\n}\n\n// 3D noise\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// 3D fractal brownian motion\nfloat fbm(vec3 p)\n{\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p = p * 2.02;\n\tf += 0.2500 * noise(p); p = p * 2.03;\n\tf += 0.1250 * noise(p); p = p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\n// distance function\nfloat map(vec3 p)\n{\n\tp.y -= 0.25;\n\tp.xz *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.xy *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.xz *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.yz *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.xy *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.xz *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.yz *= rot(0.2 + 0.1 * sin(iGlobalTime));\n\tp.xy *= rot(0.2 +", "\n    float l = length(p);\n    float a = atan(p.y,p.x);\n    float c = 1.0/k;\n    float r = c*sqrt(l);\n    float d = abs(r-a);\n    return d*d/c - l;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r, in vec2 c )\n{\n    return length(p-c) - r;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r, in vec2 c, in float t )\n{\n    return length(p-c) - r*t;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r, in vec2 c, in float t, in float s )\n{\n    return length(p-c) - r*t*s;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r, in vec2 c, in float t, in float s, in float a )\n{\n    return length(p-c) - r*t*s*a;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle( in vec2 p, in float r, in vec2 c, in float t, in float s, in float a, in float b )\n{\n    return length(p-c) - r*t*s*a*b;\n}\n\n// p is the position\n// c is the center\n// r is the radius\nfloat sdCircle", "\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float density)\n{\n\treturn exp(-opticalDepth * density);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float density)\n{\n\treturn exp(-opticalDepth * density);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 density)\n{\n\treturn exp(-opticalDepth * density);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, vec3 density)\n{\n\treturn exp(-opticalDepth * density);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float density, float densityOffset)\n{\n\treturn exp(-opticalDepth * (density + densityOffset));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float density, float densityOffset)\n{\n\treturn exp(-opticalDepth * (density + densityOffset));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 density, float densityOffset)\n{\n\treturn exp(-opticalDepth * (density + densityOffset));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, vec3 density, float densityOffset)\n{\n\treturn exp(-opticalDepth * (density + densityOffset));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 density, vec3 densityOffset)\n{\n\treturn exp(-opticalDepth * (density + densityOffset));\n}\n\n// Calculate a luminance transmittance value from optical depth.", "\n\t// Calculate the projected area of the atmosphere onto the ground.\n\tfloat cosTheta = dot(rayDir, up);\n\tfloat cosTheta2 = cosTheta * cosTheta;\n\tfloat rayHeight = rayStart.y;\n\tfloat rayHeight2 = rayHeight * rayHeight;\n\tfloat rayRadius2 = rayHeight2 + rayLength * rayLength;\n\tfloat rayAtmTopRadius2 = rayRadius2 + atmosphereRadius2;\n\tfloat rayAtmBottomRadius2 = rayRadius2 + atmosphereRadius2 * (1.0 - fAtmBottomOffset);\n\tfloat rayGroundDist = -rayHeight * rayLength / cosTheta;\n\tfloat rayStartAngle = atan(sqrt(rayHeight2 / rayRadius2));\n\tfloat rayStartAngleSin = sin(rayStartAngle);\n\tfloat rayStartAngleCos = cos(rayStartAngle);\n\tfloat rayEndAngleSin = rayLength == 0.0? 1.0 : sin(atan(sqrt(rayAtmBottomRadius2 / rayAtmTopRadius2)));\n\tfloat rayEndAngle = asin(rayEndAngleSin);\n\tfloat rayEndAngleCos = cos(rayEndAngle);\n\tfloat rayStartDepth = exp(-(rayStartAngleSin - rayStartAngleCos * rayStartAngleSin) / scaleDepth);\n\tfloat rayEndDepth = exp(-(rayEndAngleSin - rayEndAngleCos * rayEndAngleSin) / scaleDepth);\n\tfloat rayTotalDepth = rayStartDepth + rayEndDepth;\n\tfloat rayInvTotalDepth = 1.0 / rayTotalDepth;\n\tfloat rayStartOffset = rayStartDepth * rayInvTotalDepth;\n\tfloat rayEndOffset = rayEndDepth * rayInvTotalDepth;\n\n\t// Calculate the r, g, and b values for the ground.\n\tfloat cosGround = dot(lightDir, up);\n\tfloat cosGround2 = cosGround * cosGround;\n\tfloat cosX = dot(rayDir, lightDir);\n\tfloat cosX2 = cosX * cosX;\n\tfloat phaseR = 0.75 * (1.0 + cosX2);\n\tfloat phaseM = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cos", "\n    vec3 p = p2;\n    p.y -= 0.5*d;\n    float s = sdSphere( p, ra );\n    p.y += d;\n    s = min( s, sdSphere( p, rb ) );\n    return s;\n}\n\n// p = point\n// r = radius\n// h = height\nfloat sdCappedCylinder( in vec3 p, in float r, in float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// p = point\n// h = height\n// r1 = bottom radius\n// r2 = top radius\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-h;\n    float d2 = max( dot(q,vec2(r2,h)), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// p = point\n// h = height\n// r1 = bottom radius\n// r2 = top radius\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// p = point\n// h = height\n// r = radius\nfloat sdCylinder( in vec3 p, in float h, in float r )\n{\n    vec2 d = abs(vec2(length(p.", "\n    float d = sdSphere(p,r);\n    float d2 = sdPlane(p,vec4(0,1,0,h));\n    return max(d,d2) - t;\n}\n\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, float t2 )\n{\n    float d = sdSphere(p,r);\n    float d2 = sdPlane(p,vec4(0,1,0,h));\n    return max(d,d2) - t - t2;\n}\n\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, float t2, float t3 )\n{\n    float d = sdSphere(p,r);\n    float d2 = sdPlane(p,vec4(0,1,0,h));\n    return max(d,d2) - t - t2 - t3;\n}\n\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, float t2, float t3, float t4 )\n{\n    float d = sdSphere(p,r);\n    float d2 = sdPlane(p,vec4(0,1,0,h));\n    return max(d,d2) - t - t2 - t3 - t4;\n}\n\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, float t2, float t3, float t4, float t5 )\n{\n    float d = sdSphere(p,r);\n    float d2 = sdPlane(p,vec4(0,1,0,h));\n    return max(d,d2) - t - t2 - t3 - t4 - t5;\n}\n\n// p = point\n//", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4s23RG\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*t;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n}\n\n// https://www.shadertoy.com/view/4s23RG\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res", "\n    return max(sdSphere(p,r), -p.y-h);\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat udCutSphere( in vec3 p, in float r, in float h )\n{\n    return max(udSphere(p,r), -p.y-h);\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat sdRoundCone( in vec3 p, in float r1, in float r2, in float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat udRoundCone( in vec3 p, in float r1, in float r2, in float h )\n{\n    return length(p) - 2.0*h*r1/length(vec3(r1-r2,h));\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat udEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// p is the point, r is the sphere's radius, h is the plane's position\nfloat sdTorus", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\tvec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n\tfloat t = 0.0;\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat h = map(pos);\n\t\tif( h<0.001", "\n    float d = sdDisk(p,r);\n    return max(d,p.y-h);\n}\n\n// p=point, c=center, r=radius\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCircle( in vec3 p, in float r )\n{\n    return length(p) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCylinder( in vec3 p, in vec3 c, in float r )\n{\n    return length(p.xz-c.xz) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCylinder( in vec3 p, in float r )\n{\n    return length(p.xz) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCylinder( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCylinder( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// p=point, c=center, r=radius\nfloat sdCone( in vec3 p, in vec3 c, in float", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// 3d noise function\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = p.xy + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.y );\n}\n\n// 3d noise function\nfloat noise( in float x )\n{\n    vec2 p = floor(vec2(x,0.0));\n    vec2 f = fract(vec2(x,0.0));\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = p.xy + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.y );\n}\n\n// 3d noise function\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0, -100", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm2( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm3( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm4( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat noise31(vec3 p3)\n{\n\tvec3 i3 = floor(p3);\n\tvec3 f3 = fract(p3);\n\tf3 = f3 * f3 * (3.0 - 2.0 * f3);\n\n\treturn mix(mix(mix(hash31(i3 + vec3(0.0, 0.0, 0.0)), hash31(i3 + vec3(1.0, 0.0, 0.0)), f3.x),\n                   mix(hash31(i3 + vec3(0.0, 1.0, 0.0)), hash31(i3 + vec3(1.0, 1.0, 0.0)), f3.x), f3.y),\n               mix(mix(hash31(i3 + vec3(0.0, 0.0, 1.0)), hash31(i3 + vec3(1.0, 0.0, 1.0)), f3.x),\n                   mix(hash31(i3 + vec3(0.0, 1.0, 1.0)), hash31(i3 + vec3(1.0, 1.0, 1.0)), f3.x), f3.y), f3.z);\n}\n\n//value noise\nfloat noise32(vec3 p3)\n{\n\tvec3 i3 = floor(p3);\n\tvec3 f3 = fract(p3);\n\tf3 = f3 * f3 * (3.0 - 2.0 * f3);\n\n\treturn mix(mix(mix(hash32(i3 + vec3(0.0, 0.0, 0.0)), hash32(i3 + vec3(1.0, 0.0, 0", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    uv2.y *= iResolution.y / iResolution.x;\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv).rgb;\n    col += texture(iChannel1, uv2).rgb;\n    col /= 2.0;\n    fragColor = vec4(col, 1.0);\n}\n/src/main/java/com/jackakers/glsl/shader/Shader.java\npackage com.jackakers.glsl.shader;\n\nimport com.jackakers.glsl.shader.util.ShaderUtil;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.opengl.GL20;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Shader {\n\n    private final int program;\n    private final List<Integer> shaders = new ArrayList<>();\n\n    public Shader(Path vertexShader, Path fragmentShader) throws IOException {\n        this(ShaderUtil.loadShader(vertexShader), ShaderUtil.loadShader(fragmentShader));\n    }\n\n    public Shader(String vertexShader, String fragmentShader) {\n        this(ShaderUtil.compileShader(vertexShader, GL20.GL_VERTEX_SHADER), ShaderUtil.compileShader(fragmentShader, GL20.GL_FRAGMENT_SHADER));\n    }\n\n    public Shader(int vertexShader, int fragmentShader) {\n        program = GL20.glCreateProgram();\n        GL20.glAttachShader(program, vertexShader);\n        GL20.glAttachShader(program, fragmentShader);\n        GL20.glLinkProgram(program);\n        GL20.glValidateProgram(program);\n        shaders.add(vertexShader);\n        shaders.add(fragmentShader);\n    }\n\n    public void bind() {\n        GL20.glUseProgram(program);\n    }\n\n    public void unbind() {\n        GL20.glUseProgram(0);\n    }\n\n    public void delete() {\n        shaders.forEach(GL20::glDeleteShader);\n        GL20.glDeleteProgram(program);\n    }\n\n    public int", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(v_color, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n/src/shaders/vertex.glsl\nattribute vec2 a_position;\nattribute float a_color;\n\nvarying float v_color;\n\nvoid main() {\n    v_color = a_color;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n}\n/src/main.rs\nuse std::f32::consts::PI;\n\nuse glutin::event::{Event, WindowEvent};\nuse glutin::event_loop::{ControlFlow, EventLoop};\nuse glutin::window::WindowBuilder;\nuse glutin::ContextBuilder;\nuse glutin::PossiblyCurrent;\nuse glutin::WindowedContext;\nuse rand::Rng;\nuse rand::SeedableRng;\nuse rand_xorshift::XorShiftRng;\nuse web_sys::WebGlRenderingContext as GL;\n\nmod shader;\n\nconst WIDTH: u32 = 1024;\nconst HEIGHT: u32 = 768;\n\nconst NUM_PARTICLES: usize = 10000;\nconst PARTICLE_SIZE: f32 = 0.005;\n\nconst NUM_COLORS: usize = 10;\n\nfn main() {\n    let event_loop = EventLoop::new();\n    let wb = WindowBuilder::new()\n       .with_title(\"Particles\")\n       .with_inner_size(glutin::dpi::LogicalSize::new(WIDTH, HEIGHT));\n    let windowed_context = ContextBuilder::new()\n       .with_vsync(true)\n       .build_window", "\n\tfloat c = floor((p + size/2.0)/size);\n\tp = mod(p + size/2.0,size) - size/2.0;\n\treturn c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size/2.0)/size);\n\tp = mod(p + size/2.0,size) - size/2.0;\n\treturn c.x + c.y*100.0;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size/2.0)/size);\n\tp = mod(p + size/2.0,size) - size/2.0;\n\treturn c.x + c.y*100.0 + c.z*10000.0;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// License: MIT OR CC-", "\n    return fract(sin(co) * 1e4);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co) {\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 37.719, 91.135))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 st) {\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 st) {\n    return fract(sin(dot(st.xyzw, vec4(12.9898, 78.233, 37.719, 91.135))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found:", "\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec3 sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linear(float t) {\n    return t < 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nvec3 linear(vec3 t) {\n    return vec3(linear(t.r), linear(t.g), linear(t.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 hsv2rgb(vec3 c) {\n   ", "\n    return mix(pow(c, vec3(2.2)) * 1.055 - 0.055, 12.92 * c, vec3(lessThan(c, vec3(0.0031308))));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c) {\n    return mix(pow(c, 2.2) * 1.055 - 0.055, 12.92 * c, step(c, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c, in float gamma) {\n    return mix(pow(c, gamma) * 1.055 - 0.055, 12.92 * c, step(c, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c, in float gamma, in float a) {\n    return mix(pow(c, gamma) * 1.055 - 0.055, 12.92 * c, step(c, a));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c, in float gamma, in float a, in float b) {\n    return mix(pow(c, gamma) * b - a, c, step(c, a));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c, in float gamma, in float a, in float b, in float d) {\n    return mix(pow(c,", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph, float dbuffer) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - 1.0;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - 1.0;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat spher", "\n    vec4 z = p;\n    vec4 dz = vec4(1.0);\n    for (int i = 0; i < 10; i++) {\n        z = 2.0 * z * (1.0 - z) + p;\n        dz = 2.0 * dz * (1.0 - 2.0 * z);\n    }\n    return z / dz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec4 c = formula(vec4(p, 0.0, 0.0));\n    fragColor = vec4(c.xyz, 1.0);\n}\n/src/shaders/mandelbrot.frag\n// Mandelbrot set\n// https://www.shadertoy.com/view/4s23zG\n\n#define MAX_ITER 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 c = -1.0 + 2.0 * uv;\n    c.x *= iResolution.x / iResolution.y;\n    vec2 z = vec2(0.0);\n    for (int i = 0; i < MAX_ITER; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > 4.0) {\n            break;\n        }\n    }\n    float color = float(i) / float(MAX_ITER);\n    fragColor = vec4(color, color, color, 1.0);\n}\n/src/shaders/julia.frag\n// Julia set\n// https://www.shadertoy.com/view/4s23zG\n\n#define MAX_ITER 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution", "\n    vec3 q = p / r;\n    float f = dot(q, q);\n    return vec4(f, q * (2.0 / f));\n}\n\n// Signed distance function for a torus\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    float f = length(q) - t.y;\n    vec3  d = normalize(vec3(q, 0.0));\n    return vec4(f, d.x, d.y, d.z);\n}\n\n// Signed distance function for a cylinder\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    float f = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n    vec3  n = normalize(vec3(d.x, 0.0, d.y));\n    return vec4(f, n.x, n.y, n.z);\n}\n\n// Signed distance function for a cone\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return vec4(front.rgb * front.a + back.rgb * (1.0 - front.a), front.a + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float opacity) {\n    return vec4(front.rgb * front.a * opacity + back.rgb * (1.0 - front.a), front.a * opacity + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 opacity) {\n    return vec4(front.rgb * front.a * opacity.a + back.rgb * (1.0 - front.a), front.a * opacity.a + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec3 opacity) {\n    return vec4(front.rgb * front.a * opacity.r + back.rgb * (1.0 - front.a), front.a * opacity.r + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec2 opacity) {\n    return vec4(front.rgb * front.a * opacity.r + back.rgb * (1.0 - front.a), front.a * opacity.r + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float opacityR, float opacityG, float opacityB) {\n    return vec4(front.rgb * front.a * vec3(opacityR, opacityG, opacityB) + back.rgb * (1.0 - front.a), front.a * opacityR + back.a * (1.0 - front.a));\n}\n\n// License: Unknown, author: Unknown, found: don't remember", "\n    return back * (1.0 - front.a) + front.rgb * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n    return vec4(alphaBlend(back.rgb, front), back.a * (1.0 - front.a) + front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float opacity) {\n    return alphaBlend(back, vec4(front, opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front, float opacity) {\n    return alphaBlend(back, vec4(front, opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, float opacity) {\n    return alphaBlend(back, vec4(front.rgb, front.a * opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float opacity) {\n    return alphaBlend(back, vec4(front.rgb, front.a * opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 opacity) {\n    return alphaBlend(back, vec4(front, opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front, vec3 opacity) {\n    return alphaBlend(back, vec4(front, opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, vec3 opacity) {\n    return alphaBlend(back, vec4(front.rgb, front.a * opacity));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec3 opacity) {\n    return alphaBlend(back, vec4(front.rgb, front.a", "\n    vec4 h = vec4(0.0, 1.0, 2.0/3.0, 3.0/3.0);\n    p = abs(p);\n    p -= 2.0*min(dot(vec2(1.0,0.0), p), 0.0)*vec2(1.0,0.0);\n    p -= 2.0*min(dot(vec2(0.0,1.0), p), 0.0)*vec2(0.0,1.0);\n    p -= vec2(clamp(p.x+p.y,0.0,r*1.0), r);\n    return length(p)*sign(p.y-p.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float s ) {\n    vec4 h = vec4(0.0, 1.0, 2.0/3.0, 3.0/3.0);\n    p = abs(p);\n    p -= 2.0*min(dot(vec2(1.0,0.0), p), 0.0)*vec2(1.0,0.0);\n    p -= 2.0*min(dot(vec2(0.0,1.0), p), 0.0)*vec2(0.0,1.0);\n    p -= vec2(clamp(p.x+p.y,0.0,r*1.0), r);\n    return length(p)*sign(p.y-p.x)*s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float s, float t ) {\n    vec4 h = vec4(0.0, 1.0, 2.0/3.0, 3.0/3.0);\n    p = abs(p);\n    p -= 2.0*min(dot(vec2(1.0,0.0), p), 0.0", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// License: MIT, author:, found: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 aces_approx_2(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v * (a * v + b) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// License: MIT, author:, found: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 aces_approx_3(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(saturate(v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n// License: MIT, author:, found: https://github.com/TheRealMJP/B", "\n\tp = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor(p + (p.x + p.y) * K1);\n\n\tvec2 a = p - i + (i.x + i.y) * K2;\n\tvec2 o = (a.x > a.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0 * K2;\n\n\tvec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\tvec3 n = h * h * h * h * vec3(dot(a, hash2(i + 0.0)), dot(b, hash2(i + o)), dot(c, hash2(i + 1.0)));\n\n\treturn dot(n, vec3(70.0));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p *= 2.02;\n\tf += 0.2500 *", "\n    vec3 col = vec3(255.);\n    col.x = 561000.*pow(Temp,(-3. / 2.)) + 148.;\n    col.y = 100.04*log(Temp) - 623.6;\n    if (Temp > 6500.) col.y = 352000.*pow(Temp,(-3. / 2.)) + 184.;\n    col.z = 194.18*log(Temp) - 1448.6;\n    col = clamp(col, 0., 255.)/255.;\n    return col;\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float gamma) {\n    vec3 col = vec3(255.);\n    col.x = 561000.*pow(Temp,(-3. / 2.)) + 148.;\n    col.y = 100.04*log(Temp) - 623.6;\n    if (Temp > 6500.) col.y = 352000.*pow(Temp,(-3. / 2.)) + 184.;\n    col.z = 194.18*log(Temp) - 1448.6;\n    col = clamp(col, 0., 255.)/255.;\n    col = pow(col, vec3(gamma));\n    return col;\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp, float gamma, float exposure) {\n    vec3 col = vec3(255.);\n    col.x = 561000.*pow(Temp,(-3. / 2", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec2 p, int octaves) {\n    float f = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        f += pow(0.5, float(i)) * noise(p);\n        p *= 2.0;\n    }\n    return f;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec2 p, int octaves, float lacunarity, float gain) {\n    float f = 0.0;\n    float amp = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        f += amp * noise(p);\n        p *= lacunarity;\n        amp *= gain;\n    }\n    return f;\n}\n\n// License: MIT, author: In", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// https://www.shadertoy.com/view/4s23zG\n// License: MIT, author:, found: https://www.shadertoy.com/view/4s23zG\nvec3 rayPlane(vec3 ro, vec3 rd, vec4 pla) {\n    float t = -(dot(ro, pla.xyz) + pla.w) / dot(rd, pla.xyz);\n    return ro + t * rd;\n}\n\n// https://www.shadertoy.com/view/4s23zG\n// License: MIT, author:, found: https://www.shadertoy.com/view/4s23zG\nvec3 rayBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 tmin_tmp = (boxmin - ro) * inv_rd;\n    vec3 tmax_tmp = (boxmax - ro) * inv_rd;\n    vec3 tmin = min(tmin_tmp, tmax_tmp);\n    vec3 tmax = max(tmin_tmp, tmax_tmp);\n    float t0 = max(tmin.x, max(tmin.y, tmin.z));\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\n    return ro + rd * t0;\n}\n\n// https://www.shadertoy.com/view/4s23zG\n// License: MIT, author:, found: https://www.shadertoy.com/view/4s23zG\nvec3 rayCylinder(vec3 ro, vec3 rd, vec4 cyl) {\n    vec3 oc = ro - cyl.xyz;\n    float a", "\n    vec2 q = abs(p);\n    float d = pow(q.x, n) + pow(q.y, n);\n    d = pow(d, 1.0 / n);\n    return vec3(d, pow(q.x, n - 1.0), pow(q.y, n - 1.0));\n}\n\n// p: point\n// n: exponent\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec3 p, float n)\n{\n    vec3 q = abs(p);\n    float d = pow(q.x, n) + pow(q.y, n) + pow(q.z, n);\n    d = pow(d, 1.0 / n);\n    return vec3(d, pow(q.x, n - 1.0), pow(q.y, n - 1.0), pow(q.z, n - 1.0));\n}\n\n// p: point\n// n: exponent\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdSquircle(vec4 p, float n)\n{\n    vec4 q = abs(p);\n    float d = pow(q.x, n) + pow(q.y, n) + pow(q.z, n) + pow(q.w, n);\n    d = pow(d, 1.0 / n);\n    return vec4(d, pow(q.x, n - 1.0), pow(q.y, n - 1.0), pow(q.z, n - 1.0), pow(q.w, n - 1.0));\n}\n\n// p: point\n// n: exponent\n//.x", "\n    float f = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        f *= 3.0;\n        x *= 3.0;\n        float p = floor( x );\n        if( p == 1.0 )\n        {\n            x -= 1.0;\n        }\n        else if( p == 2.0 )\n        {\n            x = 2.0 - x;\n        }\n    }\n    return f * x;\n}\n\n// 1D version of the above\nfloat cantor1D( float x, float t )\n{\n    float f = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        f *= 3.0;\n        x *= 3.0;\n        float p = floor( x );\n        if( p == 1.0 )\n        {\n            x -= 1.0;\n        }\n        else if( p == 2.0 )\n        {\n            x = 2.0 - x;\n        }\n    }\n    return f * x;\n}\n\n// 2D version of the above\nfloat cantor2D( vec2 x, float t )\n{\n    float f = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        f *= 3.0;\n        x *= 3.0;\n        vec2 p = floor( x );\n        if( p.x == 1.0 )\n        {\n            x.x -= 1.0;\n        }\n        else if( p.x == 2.0 )\n        {\n            x.x = 2.0 - x.x;\n        }\n        if( p.y == 1.0 )\n        {\n            x.y -= 1.0;\n        }\n        else if( p.y == 2.0 )\n        {\n            x.y = 2.0 - x.y;\n        }\n    }\n    return f * x.x * x.y;\n}\n\n// 3D version of the above\nfloat cantor3D( vec3 x, float t )\n{\n    float f = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        f", "\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p)-b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n\tfloat s = sign( e0.x*e2.y - e0.y*e2.x );\n\tvec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n\t\t\t\t\t   vec2( dot(", "\n\tfloat d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float t0 = 1.0 / (1.0 + abs(x));\n    float t1 = t0 * t0;\n    float t2 = t1 * t1;\n    float t3 = t2 * t2;\n    float t4 = t3 * t3;\n    float t5 = t4 * t4;\n    float t6 = t5 * t5;\n    float t7 = t6 * t6;\n    float t8 = t7 * t7;\n    float t9 = t8 * t8;\n    float t10 = t9 * t9;\n    float t11 = t10 * t10;\n    float t12 = t11 * t11;\n    float t13 = t12 * t12;\n    float t14 = t13 * t13;\n    float t15 = t14 * t14;\n    float t16 = t15 * t15;\n    float t17 = t16 * t16;\n    float t18 = t17 * t17;\n    float t19 = t18 * t18;\n    float t20 = t19 * t19;\n    float t21 = t20 * t20;\n    float t22 = t21 * t21;\n    float t23 = t22 * t22;\n    float t24 = t23 * t23;\n    float t25 = t24 * t24;\n    float t26 = t25 * t25;\n    float t27 = t26 * t26;\n    float t28 = t27 * t27;\n    float t29 = t28 * t28;\n    float t30 = t29 * t29;\n    float t31 = t30 * t30;\n    float t32 = t31 * t31;\n    float t33 = t32 * t32;\n    float t34 = t33 * t33;\n    float t35 = t34 * t34;\n    float t36 = t35 * t35;\n    float t37 = t36 * t36;\n    float t3", "\n\treturn vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n\treturn cmul(z, vec2(w.x, -w.y)) / dot(w, w);\n}\n\nvec2 cpow(vec2 z, float p) {\n\tfloat r = length(z);\n\tfloat a = atan(z.y, z.x);\n\treturn pow(r, p) * vec2(cos(p * a), sin(p * a));\n}\n\nvec2 clog(vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cexp(vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n\treturn sqrt(length(z)) * vec2(cos(atan(z.y, z.x) / 2.0), sin(atan(z.y, z.x) / 2.0));\n}\n\nvec2 csin(vec2 z) {\n\treturn vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n\treturn vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n\treturn cdiv(csin(z), ccos(z));\n}\n\nvec2 ccot(vec2 z) {\n\treturn cdiv(ccos(z), csin(z));\n}\n\nvec2 csinh(vec2 z) {\n\treturn vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n\treturn vec", "\n\treturn vec2(0.5 * log((1.0 + z.x) / (1.0 - z.x)), z.y / (1.0 - z.x * z.x));\n}\n\n// Inverse hyperbolic cotangent \nvec2 cacoth(vec2 z) {\n\treturn vec2(0.5 * log((z.x + 1.0) / (z.x - 1.0)), -z.y / (z.x * z.x - 1.0));\n}\n\n// Inverse hyperbolic secant \nvec2 casech(vec2 z) {\n\treturn vec2(log((sqrt(-z.x * z.x + 1.0) + 1.0) / z.x), -z.y / (z.x * sqrt(-z.x * z.x + 1.0)));\n}\n\n// Inverse hyperbolic cosecant \nvec2 cacsch(vec2 z) {\n\treturn vec2(log((sqrt(z.x * z.x + 1.0) + 1.0) / z.x), z.y / (abs(z.x) * sqrt(z.x * z.x + 1.0)));\n}\n\n// Complex square root \nvec2 csqrt(vec2 z) {\n\tfloat r = sqrt(z.x * z.x + z.y * z.y);\n\treturn vec2(sqrt((r + z.x) / 2.0), z.y < 0.0? -sqrt((r - z.x) / 2.0) : sqrt((r - z.x) / 2.0));\n}\n\n// Complex cube root \nvec2 croot(vec2 z, int n) {\n\tfloat r = sqrt(z.x * z.x + z.y * z.y);\n\tfloat t = atan(z.y, z.x);\n\tfloat rn = pow(r, 1.0 / float(n));\n\tfloat tn = t / float(n);\n\treturn vec2(rn * cos(tn), rn * sin(tn));\n}\n\n// Complex", "\n\treturn vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n\treturn (cexp(z) - cexp(-z)) / (cexp(z) + cexp(-z));\n}\n\nvec2 clog(vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, float p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec3 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec4 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec2 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec3 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec4 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec2 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec3 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec4 q) {\n\treturn cexp(clog(z) * p", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z, vec2(w.x, -w.y)) / dot(w, w);\n}\n\nvec2 cpow(vec2 z, float p) {\n    float r = length(z);\n    float a = atan(z.y, z.x);\n    return pow(r, p) * vec2(cos(p * a), sin(p * a));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cexp(vec2 z) {\n    float r = exp(z.x);\n    return r * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float a = atan(z.y, z.x);\n    return sqrt(r) * vec2(cos(a / 2.), sin(a / 2.));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\n\nvec2 ccot(vec2 z) {\n    return cdiv(ccos(z), csin(z));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x) *", "\n\treturn vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n\treturn (cexp(z) - cexp(-z)) / (cexp(z) + cexp(-z));\n}\n\nvec2 clog(vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cpow(vec2 z, float p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec3 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec4 p) {\n\treturn cexp(clog(z) * p);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec2 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec3 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec2 p, vec4 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec2 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec3 q) {\n\treturn cexp(clog(z) * p) * cexp(clog(z) * q);\n}\n\nvec2 cpow(vec2 z, vec3 p, vec4 q) {\n\treturn cexp(clog(z) * p", "\n  return smoothstep(0.0, 1.0, alpha * contrast);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast) {\n  return smoothstep(0.0, 1.0, alpha * contrast);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast, vec4 contrastCenter) {\n  return smoothstep(0.0, 1.0, (alpha - contrastCenter) * contrast + contrastCenter);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast, float contrastCenter) {\n  return smoothstep(0.0, 1.0, (alpha - contrastCenter) * contrast + contrastCenter);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, vec4 contrastCenter) {\n  return smoothstep(0.0, 1.0, (alpha - contrastCenter) * contrast + contrastCenter);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float contrastCenter) {\n  return smoothstep(0.0, 1.0, (alpha - contrastCenter) * contrast + contrastCenter);\n}\n\n// Increases the steepness of Alpha while preserving", "\n\tvec3 q = abs(p);\n\treturn max(q.z - 1.0, max(q.x * sqrt(3.0) + q.y * sqrt(3.0), q.y * sqrt(3.0) - q.x * sqrt(3.0)) - sqrt(2.0));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.xz = abs(p.xz);\n\tp.yz = abs(p.yz);\n\tfloat da = max(p.x, max(p.y, p.z));\n\tfloat db = min(p.x, min(p.y, p.z));\n\tfloat dc = max(0.0, (p.x + p.y + p.z) - 1.0);\n\treturn (da - 0.25) + (0.25 - db) * 1.5 + dc;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodDist(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.xz = abs(p.xz);\n\tp.yz = abs(p.yz);\n\tfloat da = max(p.x, max(p.y, p.z));\n\tfloat db = min(p.x, min(p.y, p.z));\n\tfloat dc = max(0.0, (p.x + p.y + p.z) - 1.0);\n\treturn (da - 0.25) + (0.25 - db) * 1.5 + dc * 0.5;\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetDist(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.xz = abs(p.xz);\n\tp.yz = abs(p.yz);\n\tfloat da = max(p.x, max(p.y, p.z));\n\tfloat db = min(p.x, min(p.y, p.z));\n\tfloat dc = max(", "\n\tuvw = abs(uvw);\n\tuvw = min(uvw, vec3(1.0) - uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(2.0) * uvw);\n\treturn tilingVal3D(uvw, 1.0);\n}\n\n//Truncated Icosahedron Tiling\ntilingVal3D truncIcoTile(vec3 uvw) {\n\tuvw = abs(uvw);\n\tuvw = min(uvw, vec3(1.0) - uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(2.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(3.0) * uvw);\n\treturn tilingVal3D(uvw, 1.0);\n}\n\n//Truncated Tetrahedron Tiling\ntilingVal3D truncTetraTile(vec3 uvw) {\n\tuvw = abs(uvw);\n\tuvw = min(uvw, vec3(1.0) - uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(2.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(3.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(4.0) * uvw);\n\treturn tilingVal3D(uvw, 1.0);\n}\n\n//Truncated Octahedron Tiling\ntilingVal3D truncOctaTile(vec3 uvw) {\n\tuvw = abs(uvw);\n\tuvw = min(uvw, vec3(1.0) - uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(2.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(3.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(4.0) * uvw);\n\tuvw = min(uvw, vec3(1.0) - vec3(5.0) * uvw);\n", "\n    vec3 uvw2 = uvw;\n    uvw2.x = uvw.x + offset.x;\n    uvw2.y = uvw.y + offset.y;\n    uvw2.z = uvw.z + offset.z;\n    uvw2 = mod(uvw2, 1.0);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2 = uvw2 * 2.0 - 1.0;\n    uvw2 = abs(uvw2);\n    uvw2", "\n    vec3 uvw2 = uvw;\n    uvw2.x += 0.5;\n    uvw2.y += 0.5;\n    uvw2.z += 0.5;\n    vec3 uvw3 = uvw;\n    uvw3.x -= 0.5;\n    uvw3.y -= 0.5;\n    uvw3.z -= 0.5;\n    vec3 uvw4 = uvw;\n    uvw4.x += 0.5;\n    uvw4.y -= 0.5;\n    uvw4.z -= 0.5;\n    vec3 uvw5 = uvw;\n    uvw5.x -= 0.5;\n    uvw5.y += 0.5;\n    uvw5.z += 0.5;\n    vec3 uvw6 = uvw;\n    uvw6.x -= 0.5;\n    uvw6.y -= 0.5;\n    uvw6.z += 0.5;\n    vec3 uvw7 = uvw;\n    uvw7.x += 0.5;\n    uvw7.y += 0.5;\n    uvw7.z -= 0.5;\n    vec3 uvw8 = uvw;\n    uvw8.x += 0.5;\n    uvw8.y -= 0.5;\n    uvw8.z += 0.5;\n    vec3 uvw9 = uvw;\n    uvw9.x -= 0.5;\n    uvw9.y += 0.5;\n    uvw9.z -= 0.5;\n    vec3 uvw10 = uvw;\n    uvw10.x -= 0.5;\n    uvw10.y -= 0.5;\n    uvw10.z -= 0.5;\n    vec3 uvw11 = uvw;\n    uvw11.x += 0.5;\n    uvw11.y += 0.5;\n    uvw11.z += 0.5;\n    vec3 uvw12 = uvw;\n    uvw12.x += 0.5;\n    uvw12.y -= 0.5;\n    uvw12.z", "\n\tp = abs(p);\n\tfloat c = dot(p, vec3(0.816496580927726, 0.408248290463863, 0.408248290463863));\n\tp -= vec3(c, c, c);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\treturn length(p * vec3(1.0, 0.7071067811865475, 0.7071067811865475)) * 0.8660254037844386;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist2(vec3 p) {\n\tp = abs(p);\n\tfloat c = dot(p, vec3(0.816496580927726, 0.408248290463863, 0.408248290463863));\n\tp -= vec3(c, c, c);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\treturn length(p * vec3(1.0, 0.7071067811865475, 0.7071067811865475)) * 0.8660254037844386;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist3(vec3 p) {\n\tp = abs(p);\n\tfloat c = dot(p, vec3(0.81649658092772", "\n    return vec3(\n        pow(t, 6.0),\n        pow(t, 3.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 3.0),\n        pow(t, 6.0)\n    );\n}\n\n// makes one of the colormaps\nvec3 colormap(float t, int colormap) {\n    if (colormap == 0) {\n        return Cool(t);\n    } else if (colormap == 1) {\n        return Warm(t);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// makes the color of the pixel\nvec3 color(float t, int colormap) {\n    return colormap(t, colormap);\n}\n\n// makes the color of the pixel\nvec3 color(float t) {\n    return color(t, 0);\n}\n\n// makes the color of the pixel\nvec3 color(float t, int colormap, float alpha) {\n    return vec4(colormap(t, colormap), alpha);\n}\n\n// makes the color of the pixel\nvec3 color(float t, float alpha) {\n    return color(t, 0, alpha);\n}\n\n// makes the color of the pixel\nvec3 color(float t, int colormap, float alpha, float beta) {\n    return vec4(colormap(t, colormap), alpha, beta);\n}\n\n// makes the color of the pixel\nvec3 color(float t, float alpha, float beta) {\n    return color(t, 0, alpha, beta);\n}\n\n// makes the color of the pixel\nvec3 color(float t, int colormap, float alpha, float beta, float gamma) {\n    return vec4(colormap(t, colormap), alpha, beta, gamma);\n}\n\n// makes the color of the pixel\nvec3 color(float t, float alpha, float beta, float gamma) {\n    return color(t, 0, alpha, beta, gamma);\n}\n\n//", "\n    vec3 v1 = vec3(0.0, 0.0, 0.0);\n    vec3 v2 = vec3(0.0, 0.0, 0.0);\n    vec3 v3 = vec3(0.0, 0.0, 0.0);\n    vec3 v4 = vec3(0.0, 0.0, 0.0);\n    vec3 v5 = vec3(0.0, 0.0, 0.0);\n    vec3 v6 = vec3(0.0, 0.0, 0.0);\n    vec3 v7 = vec3(0.0, 0.0, 0.0);\n    vec3 v8 = vec3(0.0, 0.0, 0.0);\n    vec3 v9 = vec3(0.0, 0.0, 0.0);\n    vec3 v10 = vec3(0.0, 0.0, 0.0);\n    vec3 v11 = vec3(0.0, 0.0, 0.0);\n    vec3 v12 = vec3(0.0, 0.0, 0.0);\n    vec3 v13 = vec3(0.0, 0.0, 0.0);\n    vec3 v14 = vec3(0.0, 0.0, 0.0);\n    vec3 v15 = vec3(0.0, 0.0, 0.0);\n    vec3 v16 = vec3(0.0, 0.0, 0.0);\n    vec3 v17 = vec3(0.0, 0.0, 0.0);\n    vec3 v18 = vec3(0.0, 0.0, 0.0);\n    vec3 v19 = vec3(0.0, 0.0, 0.0);\n    vec3 v20 = vec3(0.0, 0.0, 0.0);\n    vec3 v21 = vec3(0.0, 0.0, 0.0);\n    vec3 v22 = vec3(0.0, 0.", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 co) {\n    vec2 v = fract(co);\n    v = v*v*(3.0-2.0*v);\n    return mix(mix(hash(co), hash(co + vec2(1.0, 0.0)), v.x), mix(hash(co + vec2(0.0, 1.0)), hash(co + vec2(1.0, 1.0)), v.x), v.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 co) {\n    float f = 0.0;\n    f += 0.5000*noise(co); co *= 2.02;\n    f += 0.2500*noise(co); co *= 2.03;\n    f += 0.1250*noise(co); co *= 2.01;\n    f += 0.0625*noise(co);\n    return f/0.9375;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm2(vec2 co) {\n    float f = 0.0;\n    f += 0.5000*noise(co); co *= 2.02;\n    f += 0.2500*noise(co); co *= 2.03;\n    f += 0.1250*noise(co); co *= 2.01;\n    f += 0.0625*noise(co); co *= 2.04;\n    f += 0.03125*noise(co);\n    return f/0.96875;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm3(vec2 co) {\n    float f = 0.0;\n    f += 0.5000*noise(co", "\n    return max(abs(p.x), abs(p.y));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec3 p) {\n    return max(abs(p.x), max(abs(p.y), abs(p.z)));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec4 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), abs(p.w))));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec5 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), max(abs(p.w), abs(p.z)))));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec6 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), max(abs(p.w), max(abs(p.z), abs(p.w))))));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec7 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), max(abs(p.w), max(abs(p.z), max(abs(p.w), abs(p.z)))))));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec8 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), max(abs(p.w), max(abs(p.z), max(abs(p.w), max(abs(p.z), abs(p.w))))))));\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec9 p) {\n    return max(abs(p.x), max(abs(p.y), max(abs(p.z), max(abs(p.w), max(abs(p.z), max(abs(p", "\n    vec2 r = vec2(1.0, 1.7320508075688772935274463415059);\n    vec2 h = r*0.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b, b)? a : b;\n    vec2 id = uv-gv;\n    return hexParams(gv, id);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexRound(vec2 gv) {\n    vec2 r = vec2(1.0, 1.7320508075688772935274463415059);\n    vec2 h = r*0.5;\n    vec2 a = mod(gv, r)-h;\n    vec2 b = mod(gv-h, r)-h;\n    return dot(a, a) < dot(b, b)? a : b;\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexRound(vec2 gv, vec2 id) {\n    vec2 r = vec2(1.0, 1.7320508075688772935274463415059);\n    vec2 h = r*0.5;\n    vec2 a = mod(gv, r)-h;\n    vec2 b = mod(gv-h, r)-h;\n    return dot(a, a) < dot(b, b)? a+id : b+id;\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec2 hexRound(vec2 gv, vec2 id, vec2 r) {\n    vec2 h = r*0.5;\n    vec2 a = mod(gv, r)-h;\n    vec2 b", "\n    return vec3(\n        clamp(1.5 - 4.0 * abs(t - 0.75), 0.0, 1.0),\n        clamp(1.5 - 4.0 * abs(t - 0.50), 0.0, 1.0),\n        clamp(1.5 - 4.0 * abs(t - 0.25), 0.0, 1.0)\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 magma(float t) {\n    return vec3(\n        clamp(t - 0.16666 * t * t, 0.0, 1.0),\n        clamp(t - 0.16666 * t * t, 0.0, 1.0),\n        clamp(t + 0.16666 * t * t, 0.0, 1.0)\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 inferno(float t) {\n    return vec3(\n        clamp(t + t * t, 0.0, 1.0),\n        clamp(1.5 - 2.0 * t - 2.0 * t * t, 0.0, 1.0),\n        clamp(4.0 * t - 1.0, 0.0, 1.0)\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 plasma(float t) {\n    return vec3(\n        clamp(sin(t * 3.0 + 0.0), 0.0, 1.0),\n        clamp(sin(t * 3.0 + 2.0), 0.0, 1.0),\n        clamp(sin(t * 3.0 + 4.0), 0.0, 1.0)\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://", "\n  return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n  return x * 2 - 1;\n}\n\n//returns the value of the given function at the given x\nfloat function(float x) {\n  return 1 / (1 + pow(2.71828, -x));\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative(float x) {\n  return function(x) * (1 - function(x));\n}\n\n//returns the value of the given function at the given x\nfloat function2(float x) {\n  return pow(x, 2);\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative2(float x) {\n  return 2 * x;\n}\n\n//returns the value of the given function at the given x\nfloat function3(float x) {\n  return pow(x, 3);\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative3(float x) {\n  return 3 * pow(x, 2);\n}\n\n//returns the value of the given function at the given x\nfloat function4(float x) {\n  return pow(x, 4);\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative4(float x) {\n  return 4 * pow(x, 3);\n}\n\n//returns the value of the given function at the given x\nfloat function5(float x) {\n  return pow(x, 5);\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative5(float x) {\n  return 5 * pow(x, 4);\n}\n\n//returns the value of the given function at the given x\nfloat function6(float x) {\n  return pow(x, 6);\n}\n\n//returns the derivative of the given function at the given x\nfloat derivative6(float x) {\n  return 6 * pow(x, 5);\n}\n\n//returns the value of the given function at the given x\nfloat function7(float x) {\n  return", "\n    float hex = hexCell(uv, offset, gridRes);\n    float hex2 = hexCell(uv, offset, gridRes * 0.5);\n    float hex3 = hexCell(uv, offset, gridRes * 0.25);\n    float hex4 = hexCell(uv, offset, gridRes * 0.125);\n    float hex5 = hexCell(uv, offset, gridRes * 0.0625);\n    float hex6 = hexCell(uv, offset, gridRes * 0.03125);\n    float hex7 = hexCell(uv, offset, gridRes * 0.015625);\n    float hex8 = hexCell(uv, offset, gridRes * 0.0078125);\n    float hex9 = hexCell(uv, offset, gridRes * 0.00390625);\n    float hex10 = hexCell(uv, offset, gridRes * 0.001953125);\n    float hex11 = hexCell(uv, offset, gridRes * 0.0009765625);\n    float hex12 = hexCell(uv, offset, gridRes * 0.00048828125);\n    float hex13 = hexCell(uv, offset, gridRes * 0.000244140625);\n    float hex14 = hexCell(uv, offset, gridRes * 0.0001220703125);\n    float hex15 = hexCell(uv, offset, gridRes * 0.00006103515625);\n    float hex16 = hexCell(uv, offset, gridRes * 0.000030517578125);\n    float hex17 = hexCell(uv, offset, gridRes * 0.0000152587890625);\n    float hex18 = hexCell(uv, offset, gridRes * 0.00000762939453125);\n    float hex19 = hexCell(uv, offset,", "\n    float x = uv.x;\n    float y = uv.y;\n    float t = time;\n    float r = gridRes;\n    float l = len;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float s = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z = 0.0;\n    float a1 = 0.0;\n    float b1 = 0.0;\n    float c1 = 0.0;\n    float d1 = 0.0;\n    float e1 = 0.0;\n    float f1 = 0.0;\n    float g1 = 0.0;\n    float h1 = 0.0;\n    float i1 = 0.0;\n    float j1 = 0.0;\n    float k1 = 0.0;\n    float m1 = 0.0;\n    float n1 = 0.0;\n    float o1 = 0.0;\n    float p1 = 0.0;\n    float q1 = 0.0;\n    float s1 = 0.0;\n    float u1 = 0.0;\n    float v1 = 0.0;\n    float w1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z1 = 0.0;\n    float a2 = 0.0;\n    float b2 = 0.0;\n    float c2 = 0.0;\n    float d2 = 0.", "\n    float dist = length(point);\n    float angle = atan(point.y, point.x);\n    float angle2 = angle + time;\n    float angle3 = angle - time;\n    float angle4 = angle + time * 0.5;\n    float angle5 = angle - time * 0.5;\n    float angle6 = angle + time * 0.25;\n    float angle7 = angle - time * 0.25;\n    float angle8 = angle + time * 0.75;\n    float angle9 = angle - time * 0.75;\n    float angle10 = angle + time * 0.125;\n    float angle11 = angle - time * 0.125;\n    float angle12 = angle + time * 0.375;\n    float angle13 = angle - time * 0.375;\n    float angle14 = angle + time * 0.625;\n    float angle15 = angle - time * 0.625;\n    float angle16 = angle + time * 0.875;\n    float angle17 = angle - time * 0.875;\n    float angle18 = angle + time * 0.0625;\n    float angle19 = angle - time * 0.0625;\n    float angle20 = angle + time * 0.1875;\n    float angle21 = angle - time * 0.1875;\n    float angle22 = angle + time * 0.3125;\n    float angle23 = angle - time * 0.3125;\n    float angle24 = angle + time * 0.4375;\n    float angle25 = angle - time * 0.4375;\n    float angle26 = angle + time * 0.5625;\n    float angle27 = angle - time * 0.5625;\n    float angle28 = angle + time * 0.6875;\n    float angle29 = angle - time * 0.6875;\n    float angle30 = angle + time * 0.8125;\n    float angle31 = angle - time * 0.8", "\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileOffset2) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileOffset2;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileOffset2, vec2 tileOffset3) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileOffset2 + tileOffset3;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileOffset2, vec2 tileOffset3, vec2 tileOffset4) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tileOffset2 + tileOffset3 + tileOffset4;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileOffset2, vec2 tileOffset3, vec2 tileOffset4, vec2 tileOffset5) {\n    vec2 tile = floor(pos / tileSize);\n    return tile * tileSize + tileSize / 2.0 + tileOffset + tile", "\n    vec2 v = p2 - p1;\n    vec2 w = p - p1;\n    float c1 = dot(w, v);\n    if (c1 <= 0.0) return distance(p, p1);\n    float c2 = dot(v, v);\n    if (c2 <= c1) return distance(p, p2);\n    float b = c1 / c2;\n    vec2 pB = p1 + b * v;\n    return distance(p, pB);\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    float d1 = line(p, p1, p2);\n    float d2 = line(p, p2, p3);\n    float d3 = line(p, p3, p1);\n    return min(min(d1, d2), d3);\n}\n\n// Computes the signed distance from a rectangle\nfloat rectangle(vec2 p, vec2 p1, vec2 p2) {\n    vec2 d = abs(p - p1) - (p2 - p1);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 p1, float r) {\n    return distance(p, p1) - r;\n}\n\n// Computes the signed distance from a regular polygon\nfloat polygon(vec2 p, vec2 p1, float r, int sides) {\n    vec2 d = p - p1;\n    float a = atan(d.y, d.x) + PI;\n    float s = TWO_PI / float(sides);\n    float u = floor(0.5 + a / s);\n    float v = fract(0.5 + a / s);\n    float w = r * sqrt(1.0 - v * v);\n    return mix(length(d - vec2(cos(u * s), sin(u * s)) * r), w, step(0.5, v));\n}\n\n// Computes the signed distance from a regular star\nfloat star(vec2 p, vec2 p1, float r,", "\n    // Arrow head\n    float head = sdCircle(p, 0.5);\n    // Arrow shaft\n    float shaft = sdSegment(p, vec2(0, 0), v);\n    // Arrow tail\n    float tail = sdCircle(p - v, 0.5);\n    return min(head, min(shaft, tail));\n}\n\n// Draws a single arrow\n// p = pixel coordinate\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float thickness) {\n    // Arrow head\n    float head = sdCircle(p, thickness);\n    // Arrow shaft\n    float shaft = sdSegment(p, vec2(0, 0), v);\n    // Arrow tail\n    float tail = sdCircle(p - v, thickness);\n    return min(head, min(shaft, tail));\n}\n\n// Draws a single arrow\n// p = pixel coordinate\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float thickness, float headLength) {\n    // Arrow head\n    float head = sdCircle(p, thickness);\n    // Arrow shaft\n    float shaft = sdSegment(p, vec2(0, 0), v);\n    // Arrow tail\n    float tail = sdCircle(p - v, thickness);\n    // Arrow head\n    float head2 = sdCircle(p - v * headLength, thickness);\n    return min(head, min(shaft, min(tail, head2)));\n}\n\n// Draws a single arrow\n// p = pixel coordinate\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float thickness, float headLength, float headThickness) {\n    // Arrow head\n    float head = sdCircle(p, thickness);\n    // Arrow shaft\n    float shaft = sdSegment(p, vec2(0, 0), v);\n    // Arrow tail\n    float tail = sdCircle(p - v, thickness);\n    // Arrow", "\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeNeg1to1(vec2 x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec3 make0to255(vec3 x) {\n\treturn x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec3 make0to1(vec3 x) {\n\treturn x / 255.0;\n}\n\n//shifts value range from 0-1 to 0-255\nvec4 make0to255(vec4 x) {\n\treturn x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nvec4 make0to1(vec4 x) {\n\treturn x / 255.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 makeNeg1to1(vec4 x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec4 make0to1(vec4 x) {\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to 0-255\nfloat make0to255(float x) {\n\treturn x * 255.0;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1(float x) {\n\treturn x / 255.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n\treturn x * 0.5 + ", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = offset * (1.0 - radius);\n    float angleOffset2 = offset * radius;\n    float angleOffset3 = offset * (1.0 - radius) * radius;\n    float angleOffset4 = offset * radius * (1.0 - radius);\n    float angleOffset5 = offset * (1.0 - radius) * radius * (1.0 - radius);\n    float angleOffset6 = offset * radius * (1.0 - radius) * (1.0 - radius);\n    float angleOffset7 = offset * (1.0 - radius) * radius * (1.0 - radius) * (1.0 - radius);\n    float angleOffset8 = offset * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset9 = offset * (1.0 - radius) * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset10 = offset * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset11 = offset * (1.0 - radius) * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset12 = offset * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset13 = offset * (1.0 - radius) * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset14 = offset * radius * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius) * (1.0 - radius);\n    float angleOffset15 = offset * (1.0 - radius)", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    return max(sdBox(q,c.xy),-p.y-c.z);\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h", "\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat sdBase2( in vec2 p, vec2 id, float sp, in float time )\n{\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat sdBase3( in vec2 p, vec2 id, float sp, in float time )\n{\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat sdBase4( in vec2 p, vec2 id, float sp, in float time )\n{\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat sdBase5( in vec2 p, vec2 id, float sp, in float time )\n{\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat sdBase6( in vec2 p, vec2 id, float sp, in float time )\n{\n    // repeat the space\n    p = mod(p,sp)-0.5*sp;\n    // animate\n    p.x += 0.2*time;\n    // return the distance to the shape\n    return length(p)-0.2;\n}\n\n// the SDF we want to repeat\nfloat", "\n    vec2 q = mod(p+0.5*sp,sp)-0.5*sp;\n    return length(q)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp )\n{\n    vec2 q = mod(p+0.5*sp,sp)-0.5*sp;\n    return length(q)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-0.5*sp;\n    return length(q)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float offset )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-0.5*sp;\n    return length(q)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset, float scale )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-0.5*sp;\n    return length(q*scale)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float offset, float scale )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-0.5*sp;\n    return length(q*scale)-ra;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset, float scale, float timeScale )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-0.5*sp;\n    return length(q*scale)-ra*timeScale;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float offset, float scale, float timeScale )\n{\n    vec2 q = mod(p+0.5*sp+offset,sp)-", "\n    return max(uvw.x, max(uvw.y, uvw.z));\n}\n\n//edge distance of a Box\nfloat boxDist(vec3 uvw, vec3 size) {\n    return max(abs(uvw.x) - size.x, max(abs(uvw.y) - size.y, abs(uvw.z) - size.z));\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw, vec2 size) {\n    return max(abs(uvw.x) - size.x, abs(uvw.z) - size.y);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw, vec2 size) {\n    return max(abs(uvw.x) - size.x, length(uvw.xz) - size.y);\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw, vec2 size) {\n    return length(vec2(length(uvw.xz) - size.x, uvw.y)) - size.y;\n}\n\n//edge distance of a Capsule\nfloat capsuleDist(vec3 uvw, vec2 size) {\n    return length(vec2(length(uvw.xz) - size.x, uvw.y)) - size.y;\n}\n\n//edge distance of a Capped Cylinder\nfloat cappedCylinderDist(vec3 uvw, vec2 size) {\n    return max(abs(uvw.x) - size.x, max(abs(uvw.z) - size.y, length(uvw.yz) - size.x));\n}\n\n//edge distance of a Capped Cone\nfloat cappedConeDist(vec3 uvw, vec2 size) {\n    return max(abs(uvw.x) - size.x, max(abs(uvw.z) - size.y, length(uvw.yz) - size.x));\n}\n\n//edge distance of a Capped Torus\nfloat cappedTorusDist(vec3 uvw, vec2 size) {\n    return max(abs(uvw.x) - size.x, max(abs(uvw.z) - size.y, length(vec2(length(uvw.xz) - size", "\n\tuvw = abs(uvw);\n\tvec3 uvw2 = uvw;\n\tuvw = min(uvw, 1.0 - uvw);\n\tuvw = min(uvw, uvw2);\n\treturn texture(iChannel0, uvw);\n}\n\n// 3D noise\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// 3D noise\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p = p * 2.02;\n\tf += 0.2500 * noise(p); p = p * 2.03;\n\tf += 0.1250 * noise(p); p = p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\n// 3D noise\nfloat fbm2(vec3 p) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p = p * 2.02;\n\tf += 0.2500 * noise(p); p = p * 2.03;\n\tf += 0.1250 * noise(p); p = p * 2.01;\n\tf += 0.0625 * noise(p); p = p * 2.02;\n\tf += 0.03125 * noise(p); p = p * 2.02;\n\tf += 0.0", "\n\tvec3 uvw_scaled = uvw * gridRes;\n\tvec3 uvw_scaled_offset = uvw_scaled + offset;\n\tvec3 uvw_scaled_offset_fract = fract(uvw_scaled_offset);\n\tvec3 uvw_scaled_offset_floor = floor(uvw_scaled_offset);\n\tvec3 uvw_scaled_offset_fract_scaled = uvw_scaled_offset_fract * gridRes;\n\tvec3 uvw_scaled_offset_fract_scaled_offset = uvw_scaled_offset_fract_scaled + offset;\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract = fract(uvw_scaled_offset_fract_scaled_offset);\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled = uvw_scaled_offset_fract_scaled_offset_fract * gridRes;\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset = uvw_scaled_offset_fract_scaled_offset_fract_scaled + offset;\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract = fract(uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset);\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled = uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract * gridRes;\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled_offset = uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled + offset;\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract = fract(uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled_offset);\n\tvec3 uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled = uvw_scaled_offset_fract_scaled_offset_fract_scaled_offset_fract_scaled", "\n    return mix(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t), mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), t), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r_2(float t) {\n    return mix(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t), mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), t), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r_3(float t) {\n    return mix(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t), mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), t), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r_4(float t) {\n    return mix(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t), mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), t), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com", "\n\treturn max(abs(p.x) - 1.0, max(abs(p.y) - 1.0, abs(p.z) - 1.0));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) {\n\tfloat phi = 1.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748475;\n\tfloat a = 1.0;\n\tfloat b = phi;\n\tfloat c = 1.0 / phi;\n\tfloat d = 1.0 / (phi * phi);\n\tfloat e = 1.0 / (phi * phi * phi);\n\tfloat f = 1.0 / (phi * phi * phi * phi);\n\tfloat g = 1.0 / (phi * phi * phi * phi * phi);\n\tfloat h = 1.0 / (phi * phi * phi * phi * phi * phi);\n\tfloat i = 1.0 / (phi * phi * phi * phi * phi * phi * phi);\n\tfloat j = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi);\n\tfloat k = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi * phi);\n\tfloat l = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi * phi * phi);\n\tfloat m = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi * phi * phi * phi);\n\tfloat n = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi * phi * phi * phi * phi);\n\tfloat o = 1.0 / (phi * phi * phi * phi * phi * phi * phi * phi *", "\n    return vec3(\n        pow(t, 6.0),\n        pow(t, 2.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 6.0),\n        pow(t, 2.0)\n    );\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(\n        pow(t, 2.0),\n        pow(t, 6.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(\n        pow(t, 6.0),\n        pow(t, 2.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    return vec3(\n        pow(t, 6.0),\n        pow(t, 2.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(\n        pow(t, 1.0),\n        pow(t, 6.0),\n        pow(t, 2.0)\n    );\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(\n        pow(t, 2.0),\n        pow(t, 6.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(\n        pow(t, 6.0),\n        pow(t, 2.0),\n        pow(t, 1.0)\n    );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    return vec3(\n        pow(t, 6.0),\n       ", "\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x);\n    uv2.y = floor(uv2.y);\n    return vec3(uv2, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, float size) {\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x * size);\n    uv2.y = floor(uv2.y * size);\n    return vec3(uv2, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 size) {\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x * size.x);\n    uv2.y = floor(uv2.y * size.y);\n    return vec3(uv2, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 size, vec2 offset) {\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x * size.x + offset.x);\n    uv2.y = floor(uv2.y * size.y + offset.y);\n    return vec3(uv2, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 size, vec2 offset, vec2 scale) {\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x * size.x * scale.x + offset.x);\n    uv2.y = floor(uv2.y * size.y * scale.y + offset.y);\n    return vec3(uv2, 0.0);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 size, vec2 offset, vec2 scale, vec2 repeat) {\n    vec2 uv2 = uv;\n    uv2.x = floor(uv2.x * size.x * scale.x + offset.x) % repeat.x;\n    uv2.y = floor(uv2.y * size.y * scale.y + offset.y) % repeat.y;\n    return vec3(uv2, 0.0);\n", "\n    vec2 grid = abs(uv);\n    vec2 d = abs(uv) - 0.5;\n    vec2 offset = vec2(0.5);\n    if (d.x > d.y) {\n        offset = vec2(0.0);\n    }\n    grid = step(vec2(0.5), grid);\n    return vec3(grid, offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, vec2 offset) {\n    vec2 grid = abs(uv);\n    vec2 d = abs(uv) - 0.5;\n    if (d.x > d.y) {\n        offset = vec2(0.0);\n    }\n    grid = step(vec2(0.5), grid);\n    return vec3(grid, offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, vec2 offset, vec2 scale) {\n    vec2 grid = abs(uv);\n    vec2 d = abs(uv) - 0.5;\n    if (d.x > d.y) {\n        offset = vec2(0.0);\n    }\n    grid = step(vec2(0.5), grid);\n    return vec3(grid, offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, vec2 offset, vec2 scale, vec2 size) {\n    vec2 grid = abs(uv);\n    vec2 d = abs(uv) - 0.5;\n    if (d.x > d.y) {\n        offset = vec2(0.0);\n    }\n    grid = step(vec2(0.5), grid);\n    return vec3(grid, offset);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, vec2 offset, vec2 scale, vec2 size, vec2 tile) {\n    vec2 grid = abs(uv);\n    vec2 d = abs(uv) - 0.5;\n    if (d.x > d.y) {\n        offset = vec2(0.0);\n    }\n    grid = step(vec2(0.5), grid);\n    return vec3(grid", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid2(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid3(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid4(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid5(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = floor(gridUv * 2.0);\n    return vec3(gridUv2, 0.0);\n}\n\n// makes a grid pattern\nvec3 grid", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 gridUv = fract(uv * gridRes);\n    vec2 gridUv2 = fract(uv * gridRes + vec2(0.5));\n    vec2 gridUv3 = fract(uv * gridRes + vec2(1.0));\n    vec2 gridUv4 = fract(uv * gridRes + vec2(1.5));\n    vec2 gridUv5 = fract(uv * gridRes + vec2(2.0));\n    vec2 gridUv6 = fract(uv * gridRes + vec2(2.5));\n    vec2 gridUv7 = fract(uv * gridRes + vec2(3.0));\n    vec2 gridUv8 = fract(uv * gridRes + vec2(3.5));\n    vec2 gridUv9 = fract(uv * gridRes + vec2(4.0));\n    vec2 gridUv10 = fract(uv * gridRes + vec2(4.5));\n    vec2 gridUv11 = fract(uv * gridRes + vec2(5.0));\n    vec2 gridUv12 = fract(uv * gridRes + vec2(5.5));\n    vec2 gridUv13 = fract(uv * gridRes + vec2(6.0));\n    vec2 gridUv14 = fract(uv * gridRes + vec2(6.5));\n    vec2 gridUv15 = fract(uv * gridRes + vec2(7.0));\n    vec2 gridUv16 = fract(uv * gridRes + vec2(7.5));\n    vec2 gridUv17 = fract(uv * gridRes + vec2(8.0));\n    vec2 gridUv18 = fract(uv * gridRes + vec2(8.5));\n    vec2 gridUv19 = fract(uv * gridRes + vec2(9.0));\n    vec2 gridUv20 = fract(uv * gridRes + vec2(9.5));\n    vec2 gridUv21 = fract(uv * gridRes + vec2(10.0));\n    vec2 gridUv22 = fract(uv * gridRes + vec2(10.5));\n    vec2 gridUv23 = fr", "\n    float cell = floor(uv.x * gridRes) + floor(uv.y * gridRes) * gridRes;\n    float cellTime = time + cell * 0.000001;\n    float cellOffset = sin(cellTime * 0.000001) * 0.000001;\n    float cellOffset2 = sin(cellTime * 0.000001 + 1000000.0) * 0.000001;\n    float cellOffset3 = sin(cellTime * 0.000001 + 2000000.0) * 0.000001;\n    float cellOffset4 = sin(cellTime * 0.000001 + 3000000.0) * 0.000001;\n    float cellOffset5 = sin(cellTime * 0.000001 + 4000000.0) * 0.000001;\n    float cellOffset6 = sin(cellTime * 0.000001 + 5000000.0) * 0.000001;\n    float cellOffset7 = sin(cellTime * 0.000001 + 6000000.0) * 0.000001;\n    float cellOffset8 = sin(cellTime * 0.000001 + 7000000.0) * 0.000001;\n    float cellOffset9 = sin(cellTime * 0.000001 + 8000000.0) * 0.000001;\n    float cellOffset10 = sin(cellTime * 0.000001 + 9000000.0) * 0.000001;\n    float cellOffset11 = sin(cellTime * 0.000001 + 10000000.0) * 0.000001;\n    float", "\n    float t = time * 0.001;\n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    float s = sin(a * gridRes + t);\n    float c = cos(a * gridRes + t);\n    float r = 1.0 / (d * len);\n    return r * (s * c);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time) {\n    return flowRhomCell(uv, gridRes, time, 1.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes) {\n    return flowRhomCell(uv, gridRes, 0.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv) {\n    return flowRhomCell(uv, 1.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes, float time, float len) {\n    float t = time * 0.001;\n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    float s = sin(a * gridRes + t);\n    float c = cos(a * gridRes + t);\n    float r = 1.0 / (d * len);\n    return r * (s * c);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes, float time) {\n    return flowRhom(uv, gridRes, time, 1.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes) {\n    return flowRhom(uv, gridRes, 0.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv) {\n    return flowRhom(uv, 1.0);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes, float time, float len, float speed) {\n    float t = time * 0.001;\n    float a = atan(uv.y,", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b-a), 1.0)) / ddx;\n    float x = (i.x+i.y)*w.x;\n    return x;\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b-a), 1.0)) / ddx;\n    float x = (i.x+i.y)*w.x;\n    return x;\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTexture( in vec2 p )\n{\n    vec2 w = vec2(0.5);\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b-a), 1.0)) / w;\n    float x = (i.x+i.y)*w.x;\n    return x;\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTexture( in vec2 p, in vec2 w )\n{\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*ceil(b-a), 1.0)) / w;\n    float x = (i.x+i.y)*w.x;\n    return x;\n}\n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTexture", "\n    const vec4 k = vec4(0.60, 0.40, 0.80, 0.20);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.zw, p), 0.0) * k.zw;\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p, float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    return -length(p) * sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float r) {\n    float da = abs(p.x) - r;\n    float db = abs(p.y) - r;\n    return min(max(da, db), 0.0) + length(max(vec2(da, db), 0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat star(vec2 p, float r) {\n    const float k = 0.5;\n    p.x = abs(p.x);\n    p -= 2.0 * min(dot(vec2(k, k), p), 0.0) * vec2(k, k);\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat pentagon(vec2 p, float r) {\n    const float k = 0.5", "\n    p = abs(p);\n    vec2 q = vec2(p.x, p.y * 0.5625 + p.x * 0.5);\n    if (q.x + q.y < p.x) {\n        p = q;\n    } else if (p.x - q.y < q.x) {\n        p = vec2(p.x - q.y, q.y);\n    }\n    return p;\n}\n\n// License: Unknown, author:, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hexagon(inout vec2 p) {\n    p.xy = abs(p.xy);\n    vec2 q = vec2(p.x * 0.5 + p.y * 0.5, p.y * 0.5 - p.x * 0.5);\n    if (q.x < 0.0) {\n        p = vec2(q.x, -q.y);\n    } else if (q.y < 0.0) {\n        p = vec2(-q.x, -q.y);\n    }\n    return p;\n}\n\n// License: Unknown, author:, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hexagon2(inout vec2 p) {\n    p.xy = abs(p.xy);\n    vec2 q = vec2(p.x * 0.866025 + p.y * 0.5, p.y * 0.866025 - p.x * 0.5);\n    if (q.x < 0.0) {\n        p = vec2(q.x, -q.y);\n    } else if (q.y < 0.0) {\n        p = vec2(-q.x, -q.y);\n    }\n    return p;\n}\n\n// License: Unknown, author:, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hexagon3(inout vec2 p) {\n    p.xy = abs(p.xy);\n    vec2 q = vec2", "\n    return cos(x*1.5)*cos(x*1.2+1.5)*cos(x*1.0+2.5)*cos(x*0.7+4.0);\n}\n\nfloat noise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.0-2.0*f);\n    return mix( fun(i), fun(i+1.0), u );\n}\n\nfloat fbm( float x )\n{\n    float f = 0.0;\n    f += 0.5000*noise( x ); x = 2.0*x;\n    f += 0.2500*noise( x ); x = 2.0*x;\n    f += 0.1250*noise( x ); x = 2.0*x;\n    f += 0.0625*noise( x );\n    return f/0.9375;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= resolution.x/resolution.y;\n    float a = time*4.0;\n    float d,e,f,g=1.0/40.0,h,i,r,q;\n    e=400.0*(p.x*0.5+0.5);\n    f=400.0*(p.y*0.5+0.5);\n    i=200.0+sin(e*g+a/150.0)*20.0;\n    d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;\n    r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));\n    q=f/r;\n    e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;\n    d=sin(e*g)*176.0+sin(e*", "\n    return mix(pow(t, vec3(2.2)) * 1.055 - 0.055, t * 12.92, vec3(lessThan(t, vec3(0.0031308))));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(float t) {\n    return mix(pow(t, 2.2) * 1.055 - 0.055, t * 12.92, step(t, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(float t, float gamma) {\n    return mix(pow(t, gamma) * 1.055 - 0.055, t * 12.92, step(t, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(float t, float gamma, float a, float b) {\n    return mix(pow(t, gamma) * a - b, t * 12.92, step(t, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(float t, float gamma, float a, float b, float c, float d) {\n    return mix(pow(t, gamma) * a - b, t * c - d, step(t, 0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(float t, float gamma, float a, float b, float c, float d,", "\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y);\n}\n\n// Truchet pattern with a hole\nfloat df1(vec2 p) {\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y) - 0.1;\n}\n\n// Truchet pattern with a hole and a border\nfloat df2(vec2 p) {\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y) - 0.1 - 0.01;\n}\n\n// Truchet pattern with a hole and a border and a hole in the border\nfloat df3(vec2 p) {\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y) - 0.1 - 0.01 - 0.005;\n}\n\n// Truchet pattern with a hole and a border and a hole in the border and a hole in the hole in the border\nfloat df4(vec2 p) {\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y) - 0.1 - 0.01 - 0.005 - 0.0025;\n}\n\n// Truchet pattern with a hole and a border and a hole in the border and a hole in the hole in the border and a hole in the hole in the hole in the border\nfloat df5(vec2 p) {\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    return max(q.x, q.y) - 0.1 - 0.01 - 0.005 - 0.0025 - 0.00", "\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n        s *= 0.5;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n        s *= 0.5;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n        s *= 0.5;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n        s *= 0.5;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n        s *= 0.5;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df6(vec2 p) {\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 4; i++) {\n        d += s * truchet(p);\n        p = 2.0 * p;\n       ", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                       vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                  vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)) );\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// signed distance to a 2D rectangle\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance to a 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x, r.y), 0.0);", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h < 0.0? -1.0 : -b - h;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.y;\n    float d2 = max(dot(q, c.yx), q.y);\n    return length(max(vec", "\n    return length(vec2(p.x, abs(p.y) - w)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float w, float r) {\n    return length(vec2(abs(p.x) - w, p.y)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedXY(vec2 p, vec2 w, float r) {\n    return length(max(abs(p) - w, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r, float t) {\n    return length(vec2(p.x, abs(p.y) - w)) - r - t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float w, float r, float t) {\n    return length(vec2(abs(p.x) - w, p.y)) - r - t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedXY(vec2 p, vec2 w, float r, float t) {\n    return length(max(abs(p) - w, 0.0)) - r - t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r, float t", "\n    p = abs(p);\n    float h = clamp( (p.x-p.y)*(p.x+p.y), 0.0, 1.0 );\n    return -length(p) / k + h * (k-1.0);\n}\n\n// k in (0,1) range\nfloat sdTriPrism( in vec2 p, float h, float k )\n{\n    vec2 q = abs(p);\n    return max(q.x*0.866025+p.y*0.5,-p.y) - h*k;\n}\n\n// k in (0,1) range\nfloat sdCylinder( in vec3 p, float r, float h, float k )\n{\n    return max( length(p.xz)-r, abs(p.y)-h*k );\n}\n\n// k in (0,1) range\nfloat sdCone( in vec3 p, float r1, float r2, float h, float k )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k1 = r2*b/a;\n    float k2 = r2/a;\n    float c = (q.x*b-q.y)/a;\n    float k3 = abs(p.y) > h? r1 : r2;\n    return -max(max(q.x - k1 + k*c, -q.y - k3),c - k2);\n}\n\n// k in (0,1) range\nfloat sdConeSection( in vec3 p, float h, float r1, float r2, float k )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    vec2 sc = vec2( q*si, -p.x );\n    vec2 oc = (r1 > r2? r1 : -r2)*vec2(b,1.0/b);\n    float a = dot(sc,oc);\n    float b = dot(oc,oc", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return (p.x<p.y)? p.y+p.x/2.0 : p.x+p.y/2.0;\n}\n\n// distance to y=-1/x\nfloat sdOONX( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return (p.x<p.y)? p.y-p.x/2.0 : p.x-p.y/2.0;\n}\n\n// distance to the line y=slope*x+bias\nfloat sdLine( in vec2 p, in float slope, in float bias )\n{\n    return abs(p.y - slope * p.x - bias)/sqrt(1.0+slope*slope);\n}\n\n// distance to a cylinder\nfloat sdCylinder( in vec3 p, in vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\n// distance to a cone\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c.xy,vec2(q,p.z));\n}\n\n// distance to a torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// distance to a hexagonal prism\nfloat sdHexPrism( in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Smooth minimum of two values, using a cubic polynomial\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pminCubic(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * h / (6.0 * k * k);\n}\n\n// Smooth minimum of two values, using a quintic polynomial\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pminQuintic(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * h * h * h / (6.0 * k * k * k * k);\n}\n\n// Smooth minimum of two values, using a quintic polynomial\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pminQuintic2(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * h * h * h / (6.0 * k * k * k * k);\n}\n\n// Smooth minimum of two values, using a quintic polynomial\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pminQuintic3(float a, float b, float k) {\n    float h = max(k - abs(a - b),", "\n    return log(exp(k * a) + exp(k * -a)) / k;\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmin(float a, float b, float k) {\n    return -pabs(-a, k) - pabs(b, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n    return pabs(a, k) + pabs(b, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmod(float a, float b, float k) {\n    return pabs(a, k) % pabs(b, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pfract(float a, float k) {\n    return pmod(a, 1.0, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pstep(float a, float b, float k) {\n    return step(a, b) * step(b, a);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psmoothstep(float a, float b, float x, float k) {\n    return smoothstep(a, b, x) * pstep(a, b, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmix(float a, float b, float t, float k) {\n    return (1.0 - t) * a + t * b;\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.", "\n    p.x *= 0.7;\n    p.y *= 0.7;\n    float a = atan(p.x, p.y) / 3.141592653589793;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0 * h - 22.0 * h * h + 10.0 * h * h * h) * r;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float s) {\n    float d = box(p, vec2(s, s / 2.0));\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float s, float w) {\n    float d = box(p, vec2(s, s / 2.0));\n    return max(d, -box(p, vec2(s - w, s / 2.0 - w)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float s, float w, float h) {\n    float d = box(p, vec2(s, s / 2.0));\n    return max(d, -box(p, vec2(s - w, s / 2.0 - h)));\n}\n\n// License", "\n\tvec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4) {\n\tp4 = fract(p4  *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.x + p4.y) * p4.z * p4.w);\n}\n\n// 2 out, 1 in...\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// 2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// 2 out, 3 in...\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a - b;\n    vec2 p = pos - A;\n    float k = 1.0/dot(b,b);\n    float s = k*dot(a,b);\n    float t = k*dot(b,p);\n    float r = k*dot(a,p) - s*t;\n    float d = r*r - t*(t - 1.0);\n    float q = sqrt(max(0.0,d));\n    float h = clamp(r-q, 0.0, 1.0);\n    float u = t - h;\n    float v = 1.0 - h;\n    float m = 1.0/(u*v);\n    vec2  g = m*vec2(v,u);\n    vec2  n = m*vec2(t-h-q,h+q);\n    return vec3( dot(C,vec2(u*v,h*g.x)), n.x, n.y );\n}\n\n// 2D Bezier curve with 3 control points\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 a = B - A;\n    vec2 b = C - B;\n    vec2 c = D - C;\n    vec2 d = A - 2.0*B + C;\n    vec2 e = B - 2.0*C + D;\n    vec2 f = a - b;\n    vec2 g = b - c;\n    vec2 h = d - e;\n    vec2 p = pos - A;\n    float k = 1.0/dot(e,e);\n    float s = k*dot(d,e);\n    float t = k*dot(e,p);\n    float r = k*dot(d,p) - s*t;", "\n    float x = pos.x;\n    float y = pos.y;\n    float k = he*wi*wi; // keep parabola upright\n    float d = k*(x*x) - (y*y);\n    float s = sign(d);\n    d = abs(d)/k;\n    return vec3( d, -2.0*s*x, 2.0*s*y );\n}\n\n// 2D ellipse\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in vec2 rad )\n{\n    return vec3( length(pos/rad) - 1.0, pos.x/rad.x, pos.y/rad.y );\n}\n\n// 2D hyperbola\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdHyperbola( in vec2 pos, in vec2 rad )\n{\n    return vec3( (length(pos/rad) - 1.0)*sign(pos.x), pos.x/rad.x, pos.y/rad.y );\n}\n\n// 2D hyperbolic paraboloid\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdHyperbolicParaboloid( in vec2 pos, in float he )\n{\n    float x = pos.x;\n    float y = pos.y;\n    float k = he*he; // keep parabola upright\n    float d = k*(x*x) - (y*y);\n    float s = sign(d);\n    d = abs(d)/k;\n   ", "\n    float x = pos.x;\n    float y = pos.y;\n    float a = k*k + 1.0;\n    float b = -2.0*k*y;\n    float c = k*k*x*x + y*y;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return vec3(0.0,0.0,1.0);\n    h = sqrt(h);\n    float x1 = (-b-h)/(2.0*a);\n    float y1 = k*x1;\n    float x2 = (-b+h)/(2.0*a);\n    float y2 = k*x2;\n    float dx = -k*y - x;\n    float dy = k*k*x + y;\n    if( h==0.0 )\n    {\n        return vec3( x1, y1, 0.0 );\n    }\n    else if( dx*x1+dy*y1>0.0 )\n    {\n        return vec3( x2, y2, 0.0 );\n    }\n    else\n    {\n        return vec3( x1, y1, 0.0 );\n    }\n}\n\n// Quadratic Bezier curve\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float k = 1.0 / dot(b,b);\n    float t = k * dot(a,d);\n    float s = k * dot(b,d);\n    float h = t * (2.0*b+a*t);\n    float g = s * (2.0*b+a*s);\n    float f = h*s - g*t;\n    float x2 = t*t;", "\n    vec2 q = p;\n    float r = length(q);\n    float c = cos(r*d);\n    float s = sin(r*d);\n    q = vec2(c,s)*q;\n    float f = sdEllipse(q, ra, rb);\n    vec2 df = sdEllipseGrad(q, ra, rb);\n    df = vec2(c,s)*df;\n    return vec3(f, df);\n}\n\n// p = (x,y)\n// d = 2\u03c0/n\n// ra = a\n// rb = b\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdStar(vec2 p, float d, float ra, float rb )\n{\n    vec2 q = p;\n    float r = length(q);\n    float c = cos(r*d);\n    float s = sin(r*d);\n    q = vec2(c,s)*q;\n    float f = sdEllipse(q, ra, rb);\n    vec2 df = sdEllipseGrad(q, ra, rb);\n    df = vec2(c,s)*df;\n    return vec3(f, df);\n}\n\n// p = (x,y)\n// d = 2\u03c0/n\n// ra = a\n// rb = b\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdStar2(vec2 p, float d, float ra, float rb )\n{\n    vec2 q = p;\n    float r = length(q);\n    float c = cos(r*d);\n    float s = sin(r*d);\n    q = vec2(c,s)*q;\n    float f = sdEllipse(q, ra, rb);\n    vec2 df = sdEllipseGrad(q, ra, rb);\n    df = vec2(c,s)*df;\n    return vec3", "\n    v = v * ivec2(4433, 4673);\n    v ^= v >> 17;\n    v *= ivec2(5033, 5233);\n    v ^= v >> 13;\n    v *= ivec2(4233, 4447);\n    v ^= v >> 16;\n    return v;\n}\n\nivec2 Pcg3(ivec2 v)\n{\n    v = v * ivec2(4433, 4673);\n    v ^= v >> 17;\n    v *= ivec2(5033, 5233);\n    v ^= v >> 13;\n    v *= ivec2(4233, 4447);\n    v ^= v >> 16;\n    return v;\n}\n\nivec2 Pcg4(ivec2 v)\n{\n    v = v * ivec2(4433, 4673);\n    v ^= v >> 17;\n    v *= ivec2(5033, 5233);\n    v ^= v >> 13;\n    v *= ivec2(4233, 4447);\n    v ^= v >> 16;\n    return v;\n}\n\nivec2 Pcg5(ivec2 v)\n{\n    v = v * ivec2(4433, 4673);\n    v ^= v >> 17;\n    v *= ivec2(5033, 5233);\n    v ^= v >> 13;\n    v *= ivec2(4233, 4447);\n    v ^= v >> 16;\n    return v;\n}\n\nivec2 Pcg6(ivec2 v)\n{\n    v = v * ivec2(4433, 4673);\n    v ^= v >> 17;\n    v *= ivec2(5033, 5233);\n    v ^= v >> 13;\n    v *= ivec2(4233, 4447);\n    v ^= v >> 16;\n    return v;\n}\n\nivec2 Pcg7(ivec2 v", "\n    v = v * ivec3(443, 445, 449);\n    v ^= v >> 16;\n    v *= ivec3(327, 329, 331);\n    v ^= v >> 10;\n    v *= ivec3(371, 373, 377);\n    v ^= v >> 4;\n    return v * ivec3(997, 991, 1009);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec2 v)\n{\n    v = v * ivec2(443, 445);\n    v ^= v >> 16;\n    v *= ivec2(327, 329);\n    v ^= v >> 10;\n    v *= ivec2(371, 373);\n    v ^= v >> 4;\n    return v * ivec2(997, 991) * ivec3(1, 1, 1009);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec4 v)\n{\n    v = v * ivec4(443, 445, 449, 457);\n    v ^= v >> 16;\n    v *= ivec4(327, 329, 331, 337);\n    v ^= v >> 10;\n    v *= ivec4(371, 373, 377, 383);\n    v ^= v >> 4;\n    return v * ivec4(997, 991, 1009, 1013);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = clamp(uv.x + uv.y + kx, 0.0, 1.0);\n        res = length(a * t + b * t * t + d) * sign(p);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3 t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n\n        vec3 u = sqrt(vec3(1.0 - t * t));\n        vec3 r = t * a + u * b;\n        vec3 d2 = length(r) * sign(dot(r, d)) + kz;\n        res = min(min(d2.x, d2.y), d2.z);\n    }\n\n    return res;\n}\n\n// signed distance to a", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nbool point_in_triangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    bool b1 = winding_sign(p, a, b) < 0.0;\n    bool b2 = winding_sign(p, b, c) < 0.0;\n    bool b3 = winding_sign(p, c, a) < 0.0;\n    return ((b1 == b2) && (b2 == b3));\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nbool point_in_quad(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return (point_in_triangle(p, a, b, c) || point_in_triangle(p, a, c, d));\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nbool point_in_rect(in vec2 p, in vec2 a, in vec2 b) {\n    return (p.x >= a.x && p.x <= b.x && p.y >= a.y && p.y <= b.y);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nbool point_in_circle(in vec2 p, in vec2 c, in float r) {\n    return (distance(p, c) <= r);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nbool point_in_ellipse(in vec2 p, in vec2 c, in vec2 r) {\n    return (distance(p, c) <= r.x * r.y / sqrt(pow(r.x * (p.y - c.y), 2.0) + pow(r.y * (p.x - c.x), 2.0)));\n}\n\n", "\n    vec3 m = vec3(0.0);\n    vec3 r = ro;\n    vec3 d = rd;\n    vec3 a = abs(d);\n    float ma = max( a.x, max( a.y, a.z ) );\n    float t = -1.0;\n    if( ma<1e-6 ) return vec4(-1.0);\n    vec3 p = s*sign(d)/ma;\n    vec3 q = (r+sign(d)*p)/ma;\n    vec3 dd = sign(d)/ma;\n    vec3 ad = abs(dd);\n    vec3 e = vec3(0.0);\n    vec3 id = vec3(0.0);\n    vec3 md = vec3(0.0);\n    vec3 n = vec3(0.0);\n    for( int i=0; i<64; i++ )\n    {\n        m = vec3(0.0);\n        m.x = max( q.x, 0.0 );\n        m.y = max( q.y, 0.0 );\n        m.z = max( q.z, 0.0 );\n        if( m.x>1.0 || m.y>1.0 || m.z>1.0 ) break;\n        t = dot( q, dd );\n        if( t>0.0 )\n        {\n            e = exp2( -5.0*t );\n            id = floor( q );\n            md = mod( q, vec3(1.0) );\n            if( md.x<md.y )\n            {\n                n = vec3( 1.0, 0.0, 0.0 );\n                m.x = ( md.x-md.y+e.x )/dd.x;\n            }\n            else\n            {\n                n = vec3( 0.0, 1.0, 0.0 );\n                m.y = ( md.y-md.x+e.y )/dd.y;\n            }\n            if( md.x<md.z )\n            {\n                n = vec3( 1.0, 0.0, 0.0 );\n                m.x = ( md.x-md.z+e.x )/dd.x;\n            }\n            else\n            {", "\n\tint n = a*int(b);\n\tret_n = n;\n\treturn fract(float(n)+x);\n}\n\n// https://www.shadertoy.com/view/4t33z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x, float y) {\n\tint n = a*int(b);\n\tret_n = n;\n\treturn fract(float(n)+x+y);\n}\n\n// https://www.shadertoy.com/view/4t33z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x, float y, float z) {\n\tint n = a*int(b);\n\tret_n = n;\n\treturn fract(float(n)+x+y+z);\n}\n\n// https://www.shadertoy.com/view/4t33z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x, float y, float z, float w) {\n\tint n = a*int(b);\n\tret_n = n;\n\treturn fract(float(n)+x+y+z+w);\n}\n\n// https://www.shadertoy.com/view/4t33z8\n// requires abs(a) < (1<<2", "\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = 0.5 - 0.5*(b-a)/k;\n    h = clamp( h, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k, float n )\n{\n    float h = 0.5 - 0.5*(b-a)/k;\n    h = clamp( h, 0.0, 1.0 );\n    return mix( a, b, pow(h,n) ) + k*pow(h,n)*(1.0-pow(h,n));\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k, float n, float m )\n{\n    float h = 0.5 - 0.5*(b-a)/k;\n    h = clamp( h, 0.0, 1.0 );\n    return mix( a, b, pow(h,n) ) + k*pow(h,n)*(1.0-pow(h,n));\n}\n\n// https://www.iquilezles.org/www/articles/s", "\n\tvec2 q = p/ab;\n\treturn (q.x*q.x - q.y*q.y);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a, in float b){\n\tvec2 q = p/vec2(a,b);\n\treturn (q.x*q.x - q.y*q.y);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a){\n\tvec2 q = p/vec2(a,a);\n\treturn (q.x*q.x - q.y*q.y);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a, in float b, in float c){\n\tvec2 q = p/vec2(a,b);\n\treturn (q.x*q.x - q.y*q.y - c);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a, in float c){\n\tvec2 q = p/vec2(a,a);\n\treturn (q.x*q.x - q.y*q.y - c);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a, in float b, in float c, in float d){\n\tvec2 q = p/vec2(a,b);\n\treturn (q.x*q.x - q.y*q.y - c*d);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in float a, in float c, in float d){\n\tvec2 q = p/vec2(a,a);\n\treturn (q.x*q.x - q.y*q.y - c*d);\n}", "\n\treturn a + b;\n}\n\nfloat sub_ploss(in float a, in float b){\n\treturn a - b;\n}\n\nfloat mul_ploss(in float a, in float b){\n\treturn a * b;\n}\n\nfloat div_ploss(in float a, in float b){\n\treturn a / b;\n}\n\nfloat mod_ploss(in float a, in float b){\n\treturn mod(a, b);\n}\n\nfloat pow_ploss(in float a, in float b){\n\treturn pow(a, b);\n}\n\nfloat atan2_ploss(in float a, in float b){\n\treturn atan(a, b);\n}\n\nfloat asin_ploss(in float a){\n\treturn asin(a);\n}\n\nfloat acos_ploss(in float a){\n\treturn acos(a);\n}\n\nfloat sin_ploss(in float a){\n\treturn sin(a);\n}\n\nfloat cos_ploss(in float a){\n\treturn cos(a);\n}\n\nfloat tan_ploss(in float a){\n\treturn tan(a);\n}\n\nfloat exp_ploss(in float a){\n\treturn exp(a);\n}\n\nfloat log_ploss(in float a){\n\treturn log(a);\n}\n\nfloat sqrt_ploss(in float a){\n\treturn sqrt(a);\n}\n\nfloat abs_ploss(in float a){\n\treturn abs(a);\n}\n\nfloat sign_ploss(in float a){\n\treturn sign(a);\n}\n\nfloat floor_ploss(in float a){\n\treturn floor(a);\n}\n\nfloat ceil_ploss(in float a){\n\treturn ceil(a);\n}\n\nfloat round_ploss(in float a){\n\treturn round(a);\n}\n\nfloat trunc_ploss(in float a){\n\treturn trunc(a);\n}\n\nfloat fract_ploss(in float a){\n\treturn fract(a);\n}\n\nfloat min_ploss(in float a, in float b){\n\treturn min(a, b);", "\n    vec2 p1 = pHyperbola( p, ab, s1 );\n    vec2 p2 = pHyperbola( p, ab, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec2 pEllipse_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 p1 = pEllipse( p, ab, s1 );\n    vec2 p2 = pEllipse( p, ab, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec2 pParabola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    vec2 p1 = pParabola( p, ab, s1 );\n    vec2 p2 = pParabola( p, ab, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec2 pCircle_sols( vec2 p, in float r, in float s1, in float s2 )\n{\n    vec2 p1 = pCircle( p, r, s1 );\n    vec2 p2 = pCircle( p, r, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec2 pLine_sols( vec2 p, in vec2 a, in vec2 b, in float s1, in float s2 )\n{\n    vec2 p1 = pLine( p, a, b, s1 );\n    vec2 p2 = pLine( p, a, b, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec2 pPoint_sols( vec2 p, in vec2 a, in float s1, in float s2 )\n{\n    vec2 p1 = pPoint( p, a, s1 );\n    vec2 p2 = pPoint( p, a, s2 );\n    return vec2( length(p1), length(p2) );\n}\n\n//for highlighting individual solutions\nvec", "\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    vec3  pox = pa - ba*clamp(paba/baba, 0.0, 1.0);\n    float xoxo = dot(pox,pox);\n    float k = ra*ra*baba - paba*paba;\n    float d = k >= 0.0? -rb*sqrt(k) : 0.0;\n    return vec4(sqrt(xoxo) - ra*sqrt(baba) + d, pox + sign(d)*ba*min(ra, rb));\n}\n\n// p: point\n// a: cone apex\n// b: cone base\n// ra: cone radius at apex\n// rb: cone radius at base\n// returns:\n//.x   distance to the cone\n//.yzw closest point\nvec4 udCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec4 k = sdcCappedCone(p, a, b, ra, rb);\n    return vec4(sqrt(k.x*k.x - k.y*k.y), k.yzw);\n}\n\n// p: point\n// a: cone apex\n// b: cone base\n// ra: cone radius at apex\n// rb: cone radius at base\n// returns:\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec4 k = sdcCappedCone(p, a, b, ra, rb);\n    return vec4(k.x - k.y*clamp( k.x/k.y, -1.0, 1.0 ), k.yzw);\n}\n\n// p: point\n// a: cone apex\n// b: cone base\n// ra: cone radius at apex\n// rb: cone radius at base\n// returns:\n//.x   distance to the con", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n", "\n    return length(p-cen) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return min(d1,d2);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, showSurface, samplePoint).x - map(pos-eps.xyy, showSurface, samplePoint).x,\n        map(pos+eps.yxy, showSurface, samplePoint).x - map(pos-eps.yxy, showSurface, samplePoint).x,\n        map(pos+eps.yyx, showSurface, samplePoint).x - map(pos-eps.yyx, showSurface, samplePoint).x );\n    return normalize(nor);\n}\n\n// https://www.shadertoy.com/view/4s23zG\nfloat calcAO( in vec3 pos, in vec3 nor, in bool showSurface, vec3 samplePoint )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, showSurface, samplePoint ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/4s23zG\nvec3 render( in vec3 ro, in vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 res = map(ro+rd*t, showSurface, samplePoint);\n        if( res.x<0.001 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos, showSurface, samplePoint );\n            vec3 ref = reflect( rd, nor );\n\n            // material        \n            col = 0.45 + 0.35*", "\n    float res = 1.0;\n    float t = 0.02;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tmax2 = 100.0;\n    float tmin2 = 0.0;\n    float tmax3 = 100.0;\n    float tmin3 = 0.0;\n    float tmax4 = 100.0;\n    float tmin4 = 0.0;\n    float tmax5 = 100.0;\n    float tmin5 = 0.0;\n    float tmax6 = 100.0;\n    float tmin6 = 0.0;\n    float tmax7 = 100.0;\n    float tmin7 = 0.0;\n    float tmax8 = 100.0;\n    float tmin8 = 0.0;\n    float tmax9 = 100.0;\n    float tmin9 = 0.0;\n    float tmax10 = 100.0;\n    float tmin10 = 0.0;\n    float tmax11 = 100.0;\n    float tmin11 = 0.0;\n    float tmax12 = 100.0;\n    float tmin12 = 0.0;\n    float tmax13 = 100.0;\n    float tmin13 = 0.0;\n    float tmax14 = 100.0;\n    float tmin14 = 0.0;\n    float tmax15 = 100.0;\n    float tmin15 = 0.0;\n    float tmax16 = 100.0;\n    float tmin16 = 0.0;\n    float tmax17 = 100.0;\n    float tmin17 = 0.0;\n    float tmax18 = 100.0;\n    float tmin18 = 0.0;\n    float tmax19 = 100.0;\n    float tmin19 = 0.0;\n    float tmax20 = 100.0;\n    float tmin2", "\n    vec2 q = abs(p);\n    vec2 h = vec2(ra,rb) - q;\n    float d = max(h.x,h.y);\n    float s = sign(d);\n    vec2 u = q - vec2(ra,rb) + vec2(s*he);\n    vec2 v = q - vec2(ra,rb) - vec2(s*he);\n    vec2 du = abs(u) - vec2(s*he);\n    vec2 dv = abs(v) - vec2(s*he);\n    float k = s*max(du.x,du.y) - s*max(dv.x,dv.y);\n    ocl = vec2(k,s);\n    return vec3(d,s*du/max(du.x,du.y),s*dv/max(dv.x,dv.y));\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he )\n{\n    vec2 ocl;\n    return sdgTrapezoid( p, ra, rb, he, ocl );\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb )\n{\n    vec2 ocl;\n    return sdgTrapezoid( p, ra, rb, 0.0, ocl );\n}\n\n// p.x = f(p)\n// p.y = \u2202f(p)/\u2202x\n// p.z = \u2202f(p)/\u2202y\n// p.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1", "\n\tvec2 q = vec2(length(p.xz)-ra,p.y);\n\treturn vec4(length(q)-rb,q.x,q.y,0.0);\n}\n\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy.com/view/4s23zG\n//https://www.shadertoy", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) - r\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udCircle( in vec2 p, in float radius )\n{\n    return length(p) - radius;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udTorus( in vec2 p, in vec2 t )\n{\n    return length( vec2(length(p.xy)-t.x,p.y) )-t.y;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*r,k.z*r), r))*sign(p.y-r),\n       p.y-r\n    );\n    return min(max(d.x,d.y),0.0) +", " return dot(v, v); }\nfloat udRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 a1 = normalize(a - b);\n    vec3 a2 = normalize(b - a);\n    vec3 b1 = a + r1 * a1;\n    vec3 b2 = b + r2 * a2;\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 pb = p - b;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - (r1 + h * (r2 - r1));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0)? -min(x2, y2) : (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\n// https://www.shader", "\n    vec2 d = max(vec2(0.0), abs(p-minCorner) - (maxCorner-minCorner));\n    return dot(d,d);\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float radius )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b, in float radius )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n\n// Distance to a line segment\nfloat sdSegment( in vec4 p, in vec4 a, in vec4 b, in float radius )\n{", "\n\tfloat t = iGlobalTime;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t2 = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat aw = 0.0;\n\tfloat ax = 0.0;\n", "\n\tvec3 ray = vec3(uv, 1.0);\n\tray.x = ray.x * 2.0 - 1.0;\n\tray.y = ray.y * 2.0 - 1.0;\n\tray.z = ray.z * 2.0 - 1.0;\n\tray = normalize(ray);\n\treturn ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 resolution)\n{\n\tvec3 ray = vec3(uv, 1.0);\n\tray.x = ray.x * 2.0 - 1.0;\n\tray.y = ray.y * 2.0 - 1.0;\n\tray.z = ray.z * 2.0 - 1.0;\n\tray = normalize(ray);\n\treturn ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 resolution, vec2 fov)\n{\n\tvec3 ray = vec3(uv, 1.0);\n\tray.x = ray.x * 2.0 - 1.0;\n\tray.y = ray.y * 2.0 - 1.0;\n\tray.z = ray.z * 2.0 - 1.0;\n\tray = normalize(ray);\n\treturn ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 resolution, vec2 fov, vec3 cam)\n{\n\tvec3 ray = vec3(uv, 1.0);\n\tray.x = ray.x * 2.0 - 1.0;\n\tray.y = ray.y * 2.0 - 1.0;\n\tray.z = ray.z * 2.0 - 1.0;\n\tray = normalize(ray);\n\treturn ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 resolution, vec2 fov, vec3 cam, vec3 dir)\n{\n", "\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\n\treturn v + 2.0 * cross(q, cross(q, v) + v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 s)\n{\n\treturn s * v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v, vec3 s)\n{\n\treturn s * v + 2.0 * cross(q, cross(q, v) + v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, float s)\n{\n\treturn s * v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v, float s)\n{\n\treturn s * v + 2.0 * cross(q, cross(q, v) + v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec4 s)\n{\n\treturn s.xyz * v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v, vec4 s)\n{\n\treturn s.xyz * v + 2.0 * cross(q, cross(q, v) + v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 s, float w)\n{\n\treturn s * v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q", "\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    return sdBox(p-r,b);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m )\n{\n    return sdBox(p-r,b*m);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o )\n{\n    return sdBox(p-r-o,b*m);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o, in vec2 n )\n{\n    return sdBox(p-r-o*n,b*m);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o, in vec2 n, in vec2 q )\n{\n    return sdBox(p-r-o*n,b*m*q);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o, in vec2 n, in vec2 q, in vec2 s )\n{\n    return sdBox(p-r-o*n,b*m*q*s);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o, in vec2 n, in vec2 q, in vec2 s, in vec2 t )\n{\n    return sdBox(p-r-o*n,b*m*q*s*t);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 m, in vec2 o, in vec2 n, in vec2 q", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    return length( vec2(length(p.xy)-t.x,p.y) )-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot", "\n    if( d<m.x )\n        m = vec2(d, a);\n    return m;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    if( d<m.x )\n        m = vec2(d, a);\n    return m;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    if( d>m.x )\n        m = vec2(d, a);\n    return m;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opSmoothUnion( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5+0.5*(m.x-d)/k, 0.0, 1.0 );\n    return mix( m, vec2(d, a), h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opSmoothSubtraction( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5+0.5*(m.x-d)/k, 0.0, 1.0 );\n    return mix( m, vec2(d, a), h ) + k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opSmoothIntersection( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5-0.5*(m.x-d)/k, 0.0, 1.0 );\n    return mix( m, vec2(d, a), h ) + k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec2 opBlend( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5-0.5*(m.x-d)/", "\n    float a = dot( rd, rd );\n    float b = 2.0*dot( ro, rd );\n    float c = dot( ro, ro ) - rad*rad;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) p1 = vec4(-1.0);\n    else\n    {\n        h = sqrt(h);\n        float t = (-b - h)/(2.0*a);\n        p1 = vec4( ro + t*rd, t );\n        t = (-b + h)/(2.0*a);\n        p2 = vec4( ro + t*rd, t );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectPlane( in vec2 ro, in vec2 rd, in vec2 n, float d, out vec4 p )\n{\n    float a = dot( n, rd );\n    float b = dot( n, ro ) - d;\n    if( abs(a)<1e-6 )\n    {\n        if( b==0.0 ) p = vec4( ro, 0.0 );\n        else p = vec4(-1.0);\n    }\n    else\n    {\n        float t = -b/a;\n        if( t>=0.0 ) p = vec4( ro + t*rd, t );\n        else p = vec4(-1.0);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectBox( in vec2 ro, in vec2 rd, in vec2 rad, out vec4 p1, out vec4 p2 )\n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*ro;\n    vec2 k = abs(m)*rad;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    float tN = max( t1.x, t1.y );\n    float tF = min( t2.x, t2.y );\n    if( tN>tF || tF<0.0 ) p1 = vec4(-1.0);\n    else p1 = vec4( ro + tN*rd, tN );\n    tN = min( t1.", "\n    vec2  d = p - c;\n    float l = length(d);\n    return vec3(l - r, d / l);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(d));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(d));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(d));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 s )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(d));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 s, in vec2 t )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0), sign(d));\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 s, in vec2 t, in vec2 u )\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d,0.0)) + min(max(d.", "\n    vec2 d = abs(p)-b;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n                 sign(d.x)*step(d.y,d.x),\n                 sign(d.y)*step(d.x,d.y) );\n}\n\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    float d = length(p) - r;\n    return vec3( d, normalize(p) );\n}\n\nvec3 sdgTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.y);\n    float d = length(q)-t.y;\n    return vec3( d, normalize(vec3(q,0.0)) );\n}\n\nvec3 sdgCylinder( in vec2 p, in float r )\n{\n    float d = length(p) - r;\n    return vec3( d, normalize(vec2(p.x,0.0)) );\n}\n\nvec3 sdgCone( in vec2 p, in float r )\n{\n    float d = length(p) - r;\n    return vec3( d, normalize(vec2(p.x,0.0)) );\n}\n\nvec3 sdgPlane( in vec2 p, in vec2 n )\n{\n    return vec3( dot(p,n), n );\n}\n\nvec3 sdgHexPrism( in vec2 p, in vec2 h )\n{\n    vec3 d = abs(p)-h;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n                 sign(d.x)*step(d.y,d.x),\n                 sign(d.y)*step(d.x,d.y) );\n}\n\nvec3 sdgTriPrism( in vec2 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return vec3( max(q.x*0.866025+p.y*0.5,-p.y),\n                 min(q.x", "\n    vec2 q = p*mat2(0.8,0.6,0.6,0.8);\n    float r = length(q);\n    float a = atan(q.x,q.y);\n    float h = abs(a/3.141593);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    return vec3(d*r, -8.0*p.x*p.y*(d+d-1.0),\n                d*(d*d-1.0));\n}\n\n// 2D Voronoi with distance to borders\n// p = point\n// id = cell id\n// o = offset\nvec3 sdgVoronoi( in vec2 p, out vec2 id, out vec2 o )\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    // first pass: regular voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash22( n + g );\n        o = 0.5 + 0.41*sin( iGlobalTime + 6.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash22( n + g );\n        o = 0.5 + 0.41*sin( iGlobalTime + 6.2831*o );\n        vec2 r = g + o - f;\n\n       ", "\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat h(float a1, float b1, float a2, float b2, float x) {\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat i(float a1, float b1, float a2, float b2, float x) {\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (alpha)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat j(float a1, float b1, float a2, float b2, float x) {\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat k(float a1, float b1, float a2, float b2, float x) {\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat l(float a1, float b1, float a2, float b2, float x) {\n  return a1 * pow(x, 3) + b1 * pow(x, 2) + a2 * x + b2;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com", "\n  return a * pow(abs(x), n) * pow(abs(1.0 - x), b);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y) {\n  return a * pow(abs(x), n) * pow(abs(1.0 - x), b) * pow(abs(y), n) * pow(abs(1.0 - y), b);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z) {\n  return a * pow(abs(x), n) * pow(abs(1.0 - x), b) * pow(abs(y), n) * pow(abs(1.0 - y), b) * pow(abs(z), n) * pow(abs(1.0 - z), b);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z, float w) {\n  return a * pow(abs(x), n) * pow(abs(1.0 - x), b) * pow(abs(y), n) * pow(abs(1.0 - y), b) * pow(abs(z", "\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 6; i++){\n                    noise += texture(iChannel0, uv * scale).r / scale;\n                    scale *= 2.0;\n                }\n                return noise;\n            }\n\n            void mainImage( out vec4 fragColor, in vec2 fragCoord )\n            {\n                vec2 uv = fragCoord.xy / iResolution.xy;\n                vec2 uv2 = uv;\n                uv.x *= iResolution.x / iResolution.y;\n                uv2.x *= iResolution.x / iResolution.y;\n                uv2.x += iTime * 0.1;\n                uv2.y += iTime * 0.1;\n                float noise = paperNoise(uv2);\n                float noise2 = paperNoise(uv2 * 2.0);\n                float noise3 = paperNoise(uv2 * 4.0);\n                float noise4 = paperNoise(uv2 * 8.0);\n                float noise5 = paperNoise(uv2 * 16.0);\n                float noise6 = paperNoise(uv2 * 32.0);\n                float noise7 = paperNoise(uv2 * 64.0);\n                float noise8 = paperNoise(uv2 * 128.0);\n                float noise9 = paperNoise(uv2 * 256.0);\n                float noise10 = paperNoise(uv2 * 512.0);\n                float noise11 = paperNoise(uv2 * 1024.0);\n                float noise12 = paperNoise(uv2 * 2048.0);\n                float noise13 = paperNoise(uv2 * 4096.0);\n                float noise14 = paperNoise(uv2 * 8192.0);\n                float noise15 = paperNoise(uv2 * 16384.0);\n                float noise16 = paperNoise(uv2 * 32768.0);\n                float noise17 = paperNoise(uv2 * 65536.0);\n                float noise18 = paperNoise(uv2 * 131072.0);\n                float noise19 = paperNoise(uv2 * 26", "\n\tvec3 sum = vec3(0.0);\n\tfor( int i = -2; i <= 2; i++ )\n\t{\n\t\tfor( int j = -2; j <= 2; j++ )\n\t\t{\n\t\t\tsum += texture( tex, vec2(x + i, y + j) ).rgb;\n\t\t}\n\t}\n\treturn sum / 25.0;\n}\n\nvoid main()\n{\n\tvec2 texCoord = gl_FragCoord.xy / vec2(textureSize(tex, 0));\n\tvec3 color = compute( int(texCoord.x * textureSize(tex, 0).x), int(texCoord.y * textureSize(tex, 0).y) );\n\tfragColor = vec4(color, 1.0);\n}\n/src/main.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <glm/gtx/string_cast.hpp>\n#include <glm/gtx/transform.hpp>\n#include <glm/gtx/rotate_vector.hpp>\n#include <glm/gtx/vector_angle.hpp>\n#include <glm/gtx/norm.hpp>\n#include <glm/gtx/projection.hpp>\n#include <glm/gtx/compatibility.hpp>\n#include <glm/gtx/euler_angles.hpp>\n#include <glm/gtx/matrix_decompose.hpp>\n#include <glm/gtx/matrix_operation.hpp>\n#include <glm/gtx/matrix_query.hpp>\n#include <glm/gtx/matrix_transform_2d.hpp>\n#include <glm/gtx/quaternion.hpp>\n#", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    float t = e0.x*e1.y - e0.y*e1.x;\n\n    return -sign(s)*sign(t)*min( min(dot(pq0,pq0),dot(pq1,pq1)), dot(pq2,pq2) )/s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p, in float s )\n{\n    const float k = 1.7320508075688772;\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;", "\n    vec2 d = abs(p-c)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in vec2 c, float r ) \n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(cross(ba,pa)) +\n     sign(cross(cb,pb)) +\n     sign(cross(ac,pc)) < 2.0)\n    ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(pa,nor)*dot(pa,nor)/dot2(nor) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p, in vec2 c, float s )\n{\n    p.x += s*0.57735027;\n    p.y += s*0.57735027;\n    p -= c;\n    float k = 2.0/3.0*s;\n    p.x = abs(p.x) - k;\n    p.y = p.y + k*0.5;\n    return -sign(p.y)*length(max(p,0.0)) + k", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    p = abs(p)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - length(r);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c )\n{\n    p = abs(p)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - length(r) - length(c);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 s )\n", "\n    vec2 pa = p-a, ba = b-a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 perp = pa - ba*h2;\n    float d2 = dot(perp,perp);\n    float d = sqrt(d2);\n    float t = clamp( (d-h)/d2min, 0.0, 1.0 );\n    return vec2( d, t );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 perp = pa - ba*h2;\n    float d2 = dot(perp,perp);\n    float d = sqrt(d2);\n    return vec2( d, d2 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, in float d2min, in float d2max )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h2 = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 perp = pa - ba*h2;\n    float d2 = dot(perp,perp);\n    float d = sqrt(d2);\n    float t = clamp( (d-h)/d2min, 0.0, 1.0 );\n    return vec2( d, t );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, in float d2min, in float d2max, in float d2max2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h2", "\n    float d = 1.0e+10;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2+0], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3] ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, kPath[i*2+0], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3] ) );\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[11], float kPath[22] )\n{\n    float d = 1.0e+10;\n    for( int i=0; i<11; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2+0], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3] ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, kPath[i*2+0], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3] ) );\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[15], float kPath[30] )\n{\n    float d = 1.0e+10;\n    for( int i=0; i<15; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2+0], kPath[i*2+1], kPath[i*2+2", "\n    return length(p)-1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    return 1.0-length(p);\n}\n\n// correct outside, incorrect inside\nfloat sdC( in vec2 p )\n{\n    return length(p.x)-1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    return 1.0-length(p.x);\n}\n\n// correct outside, incorrect inside\nfloat sdE( in vec2 p )\n{\n    return length(p.y)-1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\n    return 1.0-length(p.y);\n}\n\n// correct outside, incorrect inside\nfloat sdG( in vec2 p )\n{\n    return length(p.x)-length(p.y);\n}\n\n// correct inside, incorrect outside\nfloat sdH( in vec2 p )\n{\n    return length(p.x)+length(p.y)-1.0;\n}\n\n// correct outside, incorrect inside\nfloat sdI( in vec2 p )\n{\n    return length(p.x)-length(p.y);\n}\n\n// correct inside, incorrect outside\nfloat sdJ( in vec2 p )\n{\n    return length(p.x)+length(p.y)-1.0;\n}\n\n// correct outside, incorrect inside\nfloat sdK( in vec2 p )\n{\n    return length(p.x)-length(p.y);\n}\n\n// correct inside, incorrect outside\nfloat sdL( in vec2 p )\n{\n    return length(p.x)+length(p.y)-1.0;\n}\n\n// correct outside, incorrect inside\nfloat sdM( in vec2 p )\n{\n    return length(p.x)-length(p.y);\n}\n\n// correct inside, incorrect outside\nfloat sdN( in vec2 p )\n{\n    return length(p.x)+length(p.y)-1.0;\n}\n\n// correct outside, incorrect inside\nfloat sdO( in vec2 p )\n{\n    return length(p", "\n    return length(p)-0.3;\n}\n\nfloat sdC( in vec2 p )\n{\n    p.x = abs(p.x);\n    return max(p.x-0.25,p.y-0.25);\n}\n\nfloat sdD( in vec2 p )\n{\n    return max(sdC(p),-sdC(p.yx));\n}\n\nfloat sdE( in vec2 p )\n{\n    p.x = abs(p.x);\n    return (p.x-0.25)*(p.x-0.25)+(p.y-0.25)*(p.y-0.25)-0.0625;\n}\n\nfloat sdF( in vec2 p )\n{\n    p = abs(p);\n    return max(p.x-0.25,p.y-0.15);\n}\n\nfloat sdG( in vec2 p )\n{\n    p.x = abs(p.x);\n    if( p.x<0.05 ) return p.y-0.15;\n    if( p.x>0.25 ) return p.x-0.25;\n    return (p.x-0.25)*(p.x-0.25)+(p.y-0.15)*(p.y-0.15)-0.0625;\n}\n\nfloat sdH( in vec2 p )\n{\n    p = abs(p);\n    float d = (p.x-0.2)*(p.x-0.2)+(p.y-0.2)*(p.y-0.2)-0.04;\n    return min(max(d,p.x-0.05),max(p.y-0.05,-p.y+0.45));\n}\n\nfloat sdI( in vec2 p )\n{\n    p = abs(p);\n    return max(p.y-0.4,min(p.x+0.2,0.5-p.x)-p.y);\n}\n\nfloat sdJ( in vec2 p )\n{\n    p.x = abs(p.x);\n    if( p.x>", "\n    // Scale the UV coordinates.\n    uv *= 10.0;\n\n    // Get the fractional part of the UV coordinates.\n    vec2 f = fract( uv );\n\n    // Get the integer part of the UV coordinates.\n    vec2 i = floor( uv );\n\n    // Get the distance from the center of the cell.\n    float d = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d2 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d3 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d4 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d5 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d6 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d7 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d8 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d9 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d10 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d11 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d12 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d13 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d14 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d15 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d16 = length( f - 0.5 );\n\n    // Get the distance from the center of the cell.\n    float d17 = length( f - 0.5 );\n\n    // Get the distance", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = dot( pa, ba )/dot( ba, ba );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloLineSeg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloLineSeg2( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloLineSeg3( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloLineSeg4( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloLineSeg5( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa =", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec3 normal = cross( vec3(ba,0.0), vec3(ac,0.0) );\n    return - ( sign(dot(cross(vec3(ba,0.0),vec3(pa,0.0)),normal)) +\n                sign(dot(cross(vec3(cb,0.0),vec3(pb,0.0)),normal)) +\n                sign(dot(cross(vec3(ac,0.0),vec3(pc,0.0)),normal)) < 3.0 )\n               ?\n                min( min(\n                dot(ba*clamp(dot(ba,pa)/dot(ba,ba),0.0,1.0)-pa,pa),\n                dot", "\n    return cloRoundBox(p,b,vec2(r));\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    return cloRoundBox(p,b,r,r);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c )\n{\n    return cloRoundBox(p,b,r,c,c);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d )\n{\n    return cloRoundBox(p,b,r,c,d,d);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d, in vec2 e )\n{\n    return cloRoundBox(p,b,r,c,d,e,e);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d, in vec2 e, in vec2 f )\n{\n    return cloRoundBox(p,b,r,c,d,e,f,f);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g )\n{\n    return cloRoundBox(p,b,r,c,d,e,f,g,g);\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h )\n{\n    return cloRoundBox(p,b,r,c,d,e,f,g,h,h);\n}\n\n// closest point on rounded box\nvec2 clo", "\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d", "\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(nor.x)*pa.x*ba.y - sign(nor.y)*pa.y*ba.x > 0.0)?\n    (sign(nor.x)*pb.x*cb.y - sign(nor.y)*pb.y*cb.x > 0.0)?\n    (sign(nor.x)*pc.x*ac.y - sign(nor.y)*pc.y*ac.x > 0.0)?\n    min( min(\n    dot(ba, pa)/dot(ba, ba),\n    dot(cb, pb)/dot(cb, cb) ),\n    dot(ac, pc)/dot(ac, ac) ) :\n    length(ba*clamp(dot(ba,pa)/dot(ba,ba), 0.0, 1.0) - pa) :\n    length(cb*clamp(dot(cb,pb)/dot(cb,cb), 0.0, 1.0) - pb) :\n    length(ac*clamp(dot(ac,pc)/dot(ac,ac), 0.0, 1.0) - pc) );\n}\n\n// distance to a plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized", "\n\tvec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12s(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13s(vec3 p3)\n{\n\tp3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash14s(vec4 p4)\n{\n\tp4 = fract(p4  *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.x + p4.y) * p4.z * p4.w);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash15s(vec5 p5)\n{\n\tp5 = fract(p5  *.1031", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 35.344))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 35.344, 15.1667))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 1e4);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x)\n{\n    return fract(sin(float(x)) * 1e4);\n}\n\n// My take on the pseudo-random number thing\nfloat random(uint x)\n{\n    return fract(sin(float(x)) * 1e4);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y)\n{\n    return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z)\n{\n    return fract(sin(dot(vec3(x, y, z), vec3(12.9898, 78.233, 35.344))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w)\n", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by  - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    // Scale\n    st *= 10.0;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n    vec2 m_point;       // minimum point\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random", "\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0;\n\tfloat res = mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix(hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\treturn res;\n}\n\n// 2D noise implementation that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n// 2D noise implementation that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec4 x)\n{\n\tvec4 p = floor(x);\n\tvec4 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z + 170.0*", "\n    float f = 0.0;\n    f += 0.5000 * noise(x); x = m * x * 2.02;\n    f += 0.2500 * noise(x); x = m * x * 2.03;\n    f += 0.1250 * noise(x); x = m * x * 2.01;\n    f += 0.0625 * noise(x);\n    return f / 0.9375;\n}\n\n// Fractional Brownian Motion noise to test the \n// multi-octave noise function\nfloat fbm2(vec2 x)\n{\n    float f = 0.0;\n    f += 0.5000 * noise2(x); x = m * x * 2.02;\n    f += 0.2500 * noise2(x); x = m * x * 2.03;\n    f += 0.1250 * noise2(x); x = m * x * 2.01;\n    f += 0.0625 * noise2(x);\n    return f / 0.9375;\n}\n\n// Fractional Brownian Motion noise to test the \n// multi-octave noise function\nfloat fbm3(vec2 x)\n{\n    float f = 0.0;\n    f += 0.5000 * noise3(x); x = m * x * 2.02;\n    f += 0.2500 * noise3(x); x = m * x * 2.03;\n    f += 0.1250 * noise3(x); x = m * x * 2.01;\n    f += 0.0625 * noise3(x);\n    return f / 0.9375;\n}\n\n// Fractional Brownian Motion noise to test the \n// multi-octave noise function\nfloat fbm4(vec2 x)\n{\n    float f = 0.0;\n    f += 0.5000 * noise4(x); x = m * x * 2.02;\n    f += 0.2500 * noise4(", "\n    float s = 1.0;\n    float a = 0.0;\n    for(int i=0; i<6; i++)\n    {\n        vec2 p = floor(x+a);\n        vec2 f = fract(x+a);\n        vec2 uv = (p.x+p.y*57.0) + f;\n        vec2 rg = texture2D(iChannel0, (uv+0.5)/256.0, -100.0).yx;\n        a += rg.x*(1.0/256.0)+rg.y;\n        s += rg.x;\n        x*= 1.2;\n    }\n    return fract(s*100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float a = 0.0;\n    if(iMouse.z>0.0) a = 6.0*mo.x;\n    vec2 r = vec2(cos(a),sin(a));\n    float d = dot(p,r);\n    float f = pattern(vec2(d,iTime));\n    vec3 col = vec3(f);\n    col = mix(col,vec3(0.0),1.0-smoothstep(0.3,0.4,abs(d)));\n    col *= 0.5 + 0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.1);\n    fragColor = vec4(col,1.0);\n}\n/src/mod/pub/demo/gl-frag-shader-demo/res/fx-shaders/shadertoy/Spherical Harmonics.fsh\n// https://www.shadertoy.com/view/4d23D1\n// Spherical Harmonics\n// Created by  - iq/2013\n// License Creative Commons Attribution-Non", "\n    return atan(x * y, length(vec2(x, y)));\n}\n\nfloat texelSolidAngle(vec2 size, vec2 uv, float faceSize)\n{\n    vec2 uv0 = (floor(uv * faceSize) + 0.5) / faceSize;\n    vec2 uv1 = (ceil(uv * faceSize) - 0.5) / faceSize;\n    return areaElement(uv1.x - uv0.x, uv1.y - uv0.y) / (faceSize * faceSize);\n}\n\nvoid main()\n{\n    vec3 N = normalize(v_normal);\n    vec3 R = reflect(-v_viewDir, N);\n\n    vec3 irradiance = vec3(0.0);\n\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up         = cross(N, right);\n\n    float sampleDelta = 0.025;\n    float nrSamples = 0.0;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\n\n            irradiance += texture(u_environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, v_viewDir), 0.0), u_albedo, u_roughness);\n\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - u_metal", "\n\tp3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p) {\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm2(vec3 p) {\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p ); p = p*2.04;", "\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    return dot(n, vec4(31.415926535897932384626433832795));\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4sfGzS\nfloat simplex3d(vec3 p, vec3 offset) {\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y +", "\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D simplex noise\nfloat snoise(in vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x+p.y)*K1);\n\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y)? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot(n, vec3(70.0));\n}\n\n// 3D simplex noise\nfloat snoise(in vec3 p)\n{\n    const float K1 = 0.333333333; // 1/3\n    const float K2 = 0.166666667; // 1/6\n    vec3 i = floor(p + (p.x+p.y+p.z)*K1);\n    vec3 a = p - i + (i.x+i.y+i.z)*K", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    p = abs(p)-b;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r.x - r.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c )\n{\n    p = abs(p)-b;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r.x - r.y - c.x - c.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d )\n{\n    p = abs(p)-b;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r.x - r.y - c.x - c.y - d.x - d.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 c, in vec2 d, in vec2 e )\n{\n    p = abs(p)-b;\n    return min(max(p.x,p.y),0.0) + length(max(p,0.0)) - r.x - r.y - c.x - c.y - d.x - d.y - e.x - e.y;\n}\n\nfloat", "\n    p = abs(p) - b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0) - r.x - r.y;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    p = abs(p) - b;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0) - r.x - r.y - r.z;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    p = abs(p) - b;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,max(p.z,p.w))),0.0) - r.x - r.y - r.z - r.w;\n}\n\n// This is the final form\nfloat sdBox( in vec5 p, in vec5 b, in vec5 r )\n{\n    p = abs(p) - b;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,max(p.z,max(p.w,p.v)))),0.0) - r.x - r.y - r.z - r.w - r.v;\n}\n\n// This is the final form\nfloat sdBox( in vec6 p, in vec6 b, in vec6 r )\n{\n    p = abs(p) - b;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,max(p.z,max(p.w,max(p.v,p.u))))),0.0) - r.x - r.y - r.z - r.w - r.v - r.u;\n}\n\n// This is the final form\nfloat sdBox( in vec7 p, in vec7 b, in vec7 r )\n{\n    p = abs(p) - b;\n   ", "\n    vec3 view_dir = normalize(center - camera_pos);\n    float cos_theta = dot(view_dir, normal);\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n    float sin_phi = proj_info.x * sin_theta;\n    float cos_phi = sqrt(1.0 - sin_phi * sin_phi);\n    float sin_alpha = proj_info.y * sin_phi;\n    float cos_alpha = sqrt(1.0 - sin_alpha * sin_alpha);\n    float sin_beta = proj_info.y * cos_phi;\n    float cos_beta = sqrt(1.0 - sin_beta * sin_beta);\n    float sin_gamma = proj_info.x * cos_theta;\n    float cos_gamma = sqrt(1.0 - sin_gamma * sin_gamma);\n    float sin_delta = proj_info.y * sin_gamma;\n    float cos_delta = sqrt(1.0 - sin_delta * sin_delta);\n    float sin_epsilon = proj_info.y * cos_gamma;\n    float cos_epsilon = sqrt(1.0 - sin_epsilon * sin_epsilon);\n    float sin_eta = proj_info.x * sin_theta;\n    float cos_eta = sqrt(1.0 - sin_eta * sin_eta);\n    float sin_theta_prime = proj_info.y * sin_theta;\n    float cos_theta_prime = sqrt(1.0 - sin_theta_prime * sin_theta_prime);\n    float sin_phi_prime = proj_info.x * cos_theta;\n    float cos_phi_prime = sqrt(1.0 - sin_phi_prime * sin_phi_prime);\n    float sin_alpha_prime = proj_info.y * sin_phi_prime;\n    float cos_alpha_prime = sqrt(1.0 - sin_alpha_prime * sin_alpha_prime);\n    float sin_beta_prime = proj_info.y * cos_phi_prime;\n    float cos_beta_prime = sqrt(1.0 - sin_beta_prime * sin_beta_prime);\n    float sin_gamma_prime = proj_info.x * cos_theta_prime;\n    float cos_gamma_prime = sqrt(1", "\n\tvec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*57.0;\n    return mix(mix(Hash12(vec2(n+  0.0, n+  0.0)),\n                   Hash12(vec2(n+  1.0, n+  0.0)),f.x),\n               mix(Hash12(vec2(n+  0.0, n+  1.0)),\n                   Hash12(vec2(n+  1.0, n+  1.0)),f.x),f.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*Noise( p ); p = m*p*2.02;\n    f += 0.2500*Noise( p ); p = m*p*2.03;\n    f += 0.1250*Noise( p ); p = m*p*2.01;\n    f += 0.0625*Noise( p );\n    return f/0.9375;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Pattern(in vec2 p)\n{\n    vec2 q = vec2( Fbm(p + vec2(0.0,0.0)),\n                   Fbm(p + vec2(5.2,1.3)) );\n\t\n    vec2 r = vec2( Fbm(p + 4.0*q + vec2(1.7,9.2)),\n                   Fbm", "\n    float a = 2.0*PI/m;\n    float en = a*floor(0.5+an/a);\n    float e = en/2.0;\n    float c = cos(e);\n    float s = sin(e);\n    mat2 rot = mat2(c,-s,s,c);\n    vec2 q = abs(p);\n    q = mul(rot,q);\n    q -= 2.0*vec2(r*c,r*s);\n    q += vec2(r,r);\n    q = mul(rot,q);\n    q -= acs;\n    return length(q)-r;\n}\n\n// Signed distance to a regular polygon with n sides: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceRegularPolygon2D(in vec2 p, in float r, in float n)\n{\n    float a = atan(p.x,p.y)+PI;\n    float b = 2.0*PI/n;\n    float ad = a/b;\n    a = floor(ad+.5)*b;\n    p = mul(mat2(cos(a),sin(a),-sin(a),cos(a)),p);\n    return length(p)-r;\n}\n\n// Signed distance to a regular star polygon with n sides and m points per side: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceRegularStarPolygon2D(in vec2 p, in float r, in float n, in float m)\n{\n    float en = 2.0*PI/n;\n    float e = en/2.0;\n    float a = atan(p.x,p.y)+PI;\n    float b = 2.0*PI/m;\n    float ad = a/b;\n    a = floor(ad+.5)*b;\n    p = mul(mat2(cos(a),sin(a),-sin(a),cos(a)),p);\n    a = mod(a,en)-e;\n    p = mul(mat2(cos(a),sin(a),-sin(a),cos(a)),p);\n    return length(p)-r;\n}\n\n// Signed distance to a regular polygon with n sides and a pointy tip: https://www.shader", "\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x ) );\n}\n\n// https://www.shadertoy.com/view/4s23zG\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4s23zG\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/4s23zG\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.", "\n    float res = 1.0;\n    float t = t0;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*t);\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h<0.001 || t>t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Calculate the normal of the surface at the given position.\n// The normal is calculated by taking the gradient of the distance function.\n// This is cheaper than querying the distance function for small offsets.\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx));\n    return normalize(nor);\n}\n\n// Calculate the color of the surface at the given position.\n// The color is calculated by taking the gradient of the distance function.\n// This is cheaper than querying the distance function for small offsets.\nvec3 calcColor(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 col = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx));\n    return normalize(col);\n}\n\n// Calculate the color of the surface at the given position.\n// The color is calculated by taking the gradient of the distance function.\n// This is cheaper than querying the distance function for small offsets.\nvec3 calcColor2(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.", "\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcInterreflection( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfor( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.", "\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\t\n\treturn mat3(1, 0, 0,\n\t\t\t\t0, c, -s,\n\t\t\t\t0, s, c);\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\t\n\treturn mat3(c, 0, s,\n\t\t\t\t0, 1, 0,\n\t\t\t\t-s, 0, c);\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\t\n\treturn mat3(c, -s, 0,\n\t\t\t\ts, c, 0,\n\t\t\t\t0, 0, 1);\n}\n\n// Helper function generating a translation matrix\nmat4 createTranslationMatrix(vec3 translation) {\n\treturn mat4(1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\ttranslation.x, translation.y, translation.z, 1);\n}\n\n// Helper function generating", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    rayDir = normalize(rayDir * mat3(cameraRot));\n    return rayDir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay2(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    rayDir = normalize(rayDir * mat3(cameraRot));\n    return rayDir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay3(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    rayDir = normalize(rayDir * mat3(cameraRot));\n    return rayDir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay4(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    rayDir = normalize(rayDir * mat3(cameraRot));\n    return rayDir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay5(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n   ", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,34.233))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,34.233,12.233))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + seed) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float seed){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,34.233)) + seed) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co, float seed){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,34.233,12.233)) + seed) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// 2d noise\nfloat noise2d(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(rand2d(i + vec2(0.0, 0.0)), rand2d(i + vec2(1.0, 0.0)), u.x),\n               mix(rand2d(i + vec2(0.0, 1.0)), rand2d(i + vec2(1.0, 1.0)), u.x),\n               u.y);\n}\n\n// 3d noise\nfloat noise3d(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(rand3d(i + vec3(0.0, 0.0, 0.0)), rand3d(i + vec3(1.0, 0.0, 0.0)), u.x),\n                   mix(rand3d(i + vec3(0.0, 1.0, 0.0)), rand3d(i + vec3(1.0, 1.0, 0.0)), u.x),\n                   u.y),\n               mix(mix(rand3d(i + vec3(0.0, 0.0, 1.0", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n                   mix(hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with analytical derivative\n// https://www.shadertoy.com/view/XslGRr\nvec3 noise3d_grad(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n\n    float a = hash(n+0.0);\n    float b = hash(n+1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6", "\n    float n = 0.0;\n    float f = 1.0;\n    for(int i = 0; i < 4; i++){\n        n += f * noise(p);\n        f *= 0.5;\n        p *= 2.0;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale){\n    float n = 0.0;\n    float f = 1.0;\n    for(int i = 0; i < 4; i++){\n        n += f * noise(p);\n        f *= 0.5;\n        p *= 2.0;\n    }\n    return n * scale;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale, float scale2){\n    float n = 0.0;\n    float f = 1.0;\n    for(int i = 0; i < 4; i++){\n        n += f * noise(p);\n        f *= 0.5;\n        p *= 2.0;\n    }\n    return n * scale * scale2;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale, float scale2, float scale3){\n    float n = 0.0;\n    float f = 1.0;\n    for(int i = 0; i < 4; i++){\n        n += f * noise(p);\n        f *= 0.5;\n        p *= 2.0;\n    }\n    return n * scale * scale2 * scale3;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale, float scale2, float scale3, float scale4){\n    float n = 0.0;\n    float f = 1.0;\n    for(int i = 0; i < 4; i++){\n        n += f * noise(p);\n        f *= 0.5;\n        p *= 2.0;\n    }\n    return n * scale * scale2 * scale3 * scale4;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p,", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = m*p*2.02;\n    f += 0.2500*noise(p); p = m*p*2.03;\n    f += 0.1250*noise(p); p = m*p*2.01;\n    f += 0.0625*noise(p);\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\n// This is the clouds density function.\n// It's a simple polynomial smooth min (fSmoothMin) of 2 functions :\n// - The distance function to the nearest cloud\n// - A low frequency (1/256) noise function\n// This gives us a cloudy sky, and a nice cloud layer that moves with the camera.\nfloat cloudsDensity(vec3 p){\n    float d = 0.0;\n    d = fSmoothMin(d, length(p-vec3(0.0,0.0,time*0.00005))-0.1, 0.1);\n    d = fSmoothMin(d, noise(p*vec3(0.00390625,0.00390625,0.00390625))-0.25, 0.25);\n    return d;\n}\n\n// This is the clouds color function.\n// It's a polynomial smooth min (fSmoothMin) of 2 functions :\n// - A high frequency (1/16) noise function, that gives us the cloud color\n// - A low frequency (1/256) noise function, that gives us the cloud density\n// This gives us a cloudy sky, and a nice cloud layer that moves with the camera.\nvec3 cloudsColor(vec3 p){\n    vec3 c = vec3(0.0);\n    c = fSmoothMin(c, vec3(noise(p*vec3(0.0625,0.0625,0.0625))), vec3(0.5));\n    c = fSmoothMin(c, vec3(noise(p*vec3(0.003", "\n\tvec2 res = vec2(0.0);\n\tfloat d = 0.0;\n\tfloat dens = 0.0;\n\tfloat dens2 = 0.0;\n\tfloat dens3 = 0.0;\n\tfloat dens4 = 0.0;\n\tfloat dens5 = 0.0;\n\tfloat dens6 = 0.0;\n\tfloat dens7 = 0.0;\n\tfloat dens8 = 0.0;\n\tfloat dens9 = 0.0;\n\tfloat dens10 = 0.0;\n\tfloat dens11 = 0.0;\n\tfloat dens12 = 0.0;\n\tfloat dens13 = 0.0;\n\tfloat dens14 = 0.0;\n\tfloat dens15 = 0.0;\n\tfloat dens16 = 0.0;\n\tfloat dens17 = 0.0;\n\tfloat dens18 = 0.0;\n\tfloat dens19 = 0.0;\n\tfloat dens20 = 0.0;\n\tfloat dens21 = 0.0;\n\tfloat dens22 = 0.0;\n\tfloat dens23 = 0.0;\n\tfloat dens24 = 0.0;\n\tfloat dens25 = 0.0;\n\tfloat dens26 = 0.0;\n\tfloat dens27 = 0.0;\n\tfloat dens28 = 0.0;\n\tfloat dens29 = 0.0;\n\tfloat dens30 = 0.0;\n\tfloat dens31 = 0.0;\n\tfloat dens32 = 0.0;\n\tfloat dens33 = 0.0;\n\tfloat dens34 = 0.0;\n\tfloat dens35 = 0.0;\n\tfloat dens36 = 0.0;\n\tfloat dens37 = 0.0;\n\tfloat dens38 = 0.0;\n\tfloat dens", "\n\tvec3 color = vec3(0.0);\n\tfloat coverage = 1.0 - smoothstep(0.0, 0.05, dist);\n\tfloat shadow = 1.0 - smoothstep(0.0, 0.05, dist + 0.005);\n\tfloat shadow2 = 1.0 - smoothstep(0.0, 0.05, dist + 0.01);\n\tfloat shadow3 = 1.0 - smoothstep(0.0, 0.05, dist + 0.02);\n\tfloat shadow4 = 1.0 - smoothstep(0.0, 0.05, dist + 0.03);\n\tfloat shadow5 = 1.0 - smoothstep(0.0, 0.05, dist + 0.04);\n\tfloat shadow6 = 1.0 - smoothstep(0.0, 0.05, dist + 0.05);\n\tfloat shadow7 = 1.0 - smoothstep(0.0, 0.05, dist + 0.06);\n\tfloat shadow8 = 1.0 - smoothstep(0.0, 0.05, dist + 0.07);\n\tfloat shadow9 = 1.0 - smoothstep(0.0, 0.05, dist + 0.08);\n\tfloat shadow10 = 1.0 - smoothstep(0.0, 0.05, dist + 0.09);\n\tfloat shadow11 = 1.0 - smoothstep(0.0, 0.05, dist + 0.1);\n\tfloat shadow12 = 1.0 - smoothstep(0.0, 0.05, dist + 0.11);\n\tfloat shadow13 = 1.0 - smoothstep(0.0, 0.05, dist + 0.12);\n\tfloat shadow14 = 1.0 - smoothstep(0.0, 0.05, dist + 0.13);\n\tfloat shadow15 = 1.0 - smoothstep(0.0, 0.", "\n\tvec3 color = vec3(0.0);\n\tfloat alpha = 0.0;\n\tfloat alphaAccum = 0.0;\n\tfloat distAccum = 0.0;\n\tfloat distStep = 0.01;\n\tfloat distMax = 1.0;\n\tfloat distMaxInv = 1.0 / distMax;\n\tfloat distMaxInvSqr = distMaxInv * distMaxInv;\n\tfloat distMaxInvSqr2 = distMaxInvSqr * distMaxInvSqr;\n\tfloat distMaxInvSqr3 = distMaxInvSqr2 * distMaxInvSqr;\n\tfloat distMaxInvSqr4 = distMaxInvSqr3 * distMaxInvSqr;\n\tfloat distMaxInvSqr5 = distMaxInvSqr4 * distMaxInvSqr;\n\tfloat distMaxInvSqr6 = distMaxInvSqr5 * distMaxInvSqr;\n\tfloat distMaxInvSqr7 = distMaxInvSqr6 * distMaxInvSqr;\n\tfloat distMaxInvSqr8 = distMaxInvSqr7 * distMaxInvSqr;\n\tfloat distMaxInvSqr9 = distMaxInvSqr8 * distMaxInvSqr;\n\tfloat distMaxInvSqr10 = distMaxInvSqr9 * distMaxInvSqr;\n\tfloat distMaxInvSqr11 = distMaxInvSqr10 * distMaxInvSqr;\n\tfloat distMaxInvSqr12 = distMaxInvSqr11 * distMaxInvSqr;\n\tfloat distMaxInvSqr13 = distMaxInvSqr12 * distMaxInvSqr;\n\tfloat distMaxInvSqr14 = distMaxInvSqr13 * distMaxInvSqr;\n\tfloat distMaxInvSqr15 = distMaxInvSqr14 * distMaxInvSqr;\n\tfloat distMaxInvSqr16 = distMaxInvSqr15 * distMaxInvSqr;\n\tfloat distMaxInvSqr17 = distMaxInvSqr16 * distMaxInvSqr;\n\tfloat distMaxInvSqr18 = distMaxInvSqr17 * distMaxInvSqr;\n\tfloat", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_tex_coord).rgb;\n    color = aces_tonemap(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    o_color = vec4(color, 1.0);\n}\n/src/shaders/skybox.frag\n#version 450\n\nlayout(location = 0) in vec3 v_tex_coord;\n\nlayout(location = 0) out vec4 o_color;\n\nlayout(set = 0, binding = 0) uniform textureCube t_skybox;\nlayout(set = 0, binding = 1) uniform sampler s_skybox;\n\nvoid main() {\n    o_color = texture(samplerCube(t_skybox, s_skybox), v_tex_coord);\n}\n/src/shaders/pbr.frag\n#version 450\n\nlayout(location = 0) in vec3 v_position;\nlayout(location = 1) in vec3 v_normal;\nlayout(location = 2) in vec2 v_tex_coord;\n\nlayout(location = 0) out vec4 o_color;\n\nlayout(set = 0, binding = 0) uniform texture2D t_albedo;\nlayout(set = 0, binding = 1) uniform texture2D t_normal;\nlayout(set = 0, binding = 2) uniform texture2D t_metallic;\nlayout(set = 0, binding = 3) uniform texture2D t_roughness;\nlayout(set = 0, binding = 4) uniform texture2D t_ao;\n\nlayout(set = 0, binding = 5) uniform textureCube t_irradiance;\nlayout(set ="]}