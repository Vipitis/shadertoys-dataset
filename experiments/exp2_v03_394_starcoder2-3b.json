{"generations": [" return 0.28209479177387814347403972578039f * s.x; }\nfloat SH_0_1( in vec3 s ) { return 0.48860251190291992158670413686284f * s.y; }\nfloat SH_0_2( in vec3 s ) { return 0.48860251190291992158670413686284f * s.z; }\nfloat SH_0_3( in vec3 s ) { return 0.48860251190291992158670413686284f * s.x * s.y; }\nfloat SH_0_4( in vec3 s ) { return 0.48860251190291992158670413686284f * s.x * s.z; }\nfloat SH_0_5( in vec3 s ) { return 0.48860251190291992158670413686284f * s.y * s.z; }\nfloat SH_0_6( in vec3 s ) { return 0.48860251190291992158670413686284f * s.x * s.y * s.z; }\n\n// SH_1_0\nfloat SH_1_0( in vec3 s ) { return 0.48860251190291992158670413686284f * s.x; }\nfloat SH_1_1( in vec3 s ) { return 0.488602511902919921586704", "\n\treturn length( (b-a) * (p-a) - (b-a) * (b-a) );\n}\n\n// distance to a line segment (can't get simpler than this)\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n\treturn length( (b-a) * (p-a) - (b-a) * (b-a) ) / length(b-a);\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n\tvec2 ab = b-a;\n\tvec2 ac = c-a;\n\tvec2 ap = p-a;\n\tvec2 bp = p-b;\n\tvec2 cp = p-c;\n\tfloat d1 = length( cross(ab, ap) );\n\tfloat d2 = length( cross(ac, bp) );\n\tfloat d3 = length( cross(ab, cp) );\n\treturn min( min( d1, d2 ), d3 );\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat triangleSegment( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n\tvec2 ab = b-a;\n\tvec2 ac = c-a;\n\tvec2 ap = p-a;\n\tvec2 bp = p-b;\n\tvec2 cp = p-c;\n\tfloat d1 = length( cross(ab, ap) );\n\tfloat d2 = length( cross(ac, bp) );\n\tfloat d3 = length( cross(ab, cp) );\n\tfloat d = min( min( d1, d2 ), d3 );\n\tif( d1 == d ) return length( (b-a) * (p-a) - (b-a) * (b-a) );\n\tif( d2 == d ) return length( (c-a) * (p-a) - (c-a) * (c-a) );\n\tif( d3 == d ) return length( (a-b) * (p-b) -", "\n\treturn (v.x < r.x)? vec2(-v.x, v.y) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n\treturn (v.x < r.x)? vec3(-v.x, v.y, v.z) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n\treturn (v.x < r.x)? vec4(-v.x, v.y, v.z, v.w) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in float r )\n{\n\treturn (v.x < r)? vec2(-v.x, v.y) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in float r )\n{\n\treturn (v.x < r)? vec3(-v.x, v.y, v.z) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in float r )\n{\n\treturn (v.x < r)? vec4(-v.x, v.y, v.z, v.w) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in float v, in float r )\n{\n\treturn (v < r)? vec2(-v, v) : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in float v, in float r )\n{\n\treturn (v < r)? vec3(-", "\n\treturn v - 2.0 * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n\treturn v - 2.0 * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n\treturn v - 2.0 * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float d )\n{\n\treturn v - 2.0 * d * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in float d )\n{\n\treturn v - 2.0 * d * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r, in float d )\n{\n\treturn v - 2.0 * d * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in vec2 d )\n{\n\treturn v - 2.0 * dot(v, r) * r + 2.0 * dot(v, d) * d;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in vec3 d )\n{\n\treturn v - 2.0 * dot(v, r) * r + 2.", "\n\treturn (v.x < r.x)? vec2(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n\treturn (v.x > r.x)? vec2(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n\treturn (v.x < r.x)? vec3(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n\treturn (v.x > r.x)? vec3(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n\treturn (v.x < r.x)? vec4(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n\treturn (v.x > r.x)? vec4(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in float r )\n{\n\treturn (v.x < r)? vec2(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in float r )\n{\n\treturn (v.x > r)? vec2(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\n", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pab = a + ba * h;\n\treturn length( p - pab ) - w1;\n}\n\n// https://www.shadertoy.com/view/4sX3zN\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pab = a + ba * h;\n\treturn length( p - pab ) - w1;\n}\n\n// https://www.shadertoy.com/view/4sX3zN\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4 )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pab = a + ba * h;\n\treturn length( p - pab ) - w1;\n}\n\n// https://www.shadertoy.com/view/4sX3zN\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4, float w5 )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pab = a + ba * h;\n\treturn length( p - pab ) - w1;\n}\n\n// https://www.shadertoy.com/view/4sX3zN\nfloat sdArrow( in vec2", "\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius * sunRadius2;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2, float sunRadius3)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius * sunRadius2 * sunRadius3;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2, float sunRadius3, float sunRadius4)\n{\n\tfloat dot = dot(rayDir, sunDir);", "\n\tvec4 a = p0;\n\tvec4 b = 0.5 * (p1 - p0);\n\tvec4 c = 0.5 * (2.0 * p1 + p0 - 5.0 * p2 + 4.0 * p3);\n\tvec4 d = 0.5 * (3.0 * (p2 - p1) - p0 - 3.0 * p3);\n\treturn a + b * t + c * t * t + d * t * t * t;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRomDerivative(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tvec4 a = p0;\n\tvec4 b = 0.5 * (p1 - p0);\n\tvec4 c = 0.5 * (2.0 * p1 + p0 - 5.0 * p2 + 4.0 * p3);\n\tvec4 d = 0.5 * (3.0 * (p2 - p1) - p0 - 3.0 * p3);\n\treturn b + 2.0 * c * t + 3.0 * d * t * t;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRomDerivative2(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tvec4 a = p0;\n\tvec4 b = 0.5 * (p1 - p0);\n\tvec4 c = 0.5 * (2.0 * p1 + p0 - 5.0 * p2 + 4.0 * p3);\n\tvec4 d = 0.5 * (3.0 * (p2 - p1) - p0 - 3.0 * p3);\n\treturn 2.0 * b + 6.0 * c * t + 6.0 * d * t * t;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRomDerivative3(vec4 p0, vec4 p1,", "\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat theta = 0.0;\n\twhile (freq < 10000.0)\n\t{\n\t\tsum += sin(theta + p.x*freq + p.y*freq + p.z*freq) * amp;\n\t\ttheta += nudge * freq;\n\t\tamp *= 0.5;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum * normalizer;\n}\n\n// This is a 2D version of the above.\nconst float nudge2 = 0.739513;\t// size of perpendicular vector\nfloat normalizer2 = 1.0 / sqrt(1.0 + nudge2*nudge2);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoise2D(vec2 p)\n{\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat theta = 0.0;\n\twhile (freq < 10000.0)\n\t{\n\t\tsum += sin(theta + p.x*freq + p.y*freq) * amp;\n\t\ttheta += nudge2 * freq;\n\t\tamp *= 0.5;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum * normalizer2;\n}\n\n// This is a 3D version of the above.\nconst float nudge3 = 0.739513;\t// size of perpendicular vector\nfloat normalizer3 = 1.0 / sqrt(1.0 + nudge3*nudge3);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoise3D(vec3 p)\n{\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat theta = 0.0;\n\twhile (freq < 10000.0)\n\t{\n\t\tsum += sin(theta + p.x*freq + p.", "\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\tfloat t4 = t3*t;\n\tfloat t5 = t4*t;\n\tfloat t6 = t5*t;\n\tfloat t7 = t6*t;\n\tfloat t8 = t7*t;\n\tfloat t9 = t8*t;\n\tfloat t10 = t9*t;\n\tfloat t11 = t10*t;\n\tfloat t12 = t11*t;\n\tfloat t13 = t12*t;\n\tfloat t14 = t13*t;\n\tfloat t15 = t14*t;\n\tfloat t16 = t15*t;\n\tfloat t17 = t16*t;\n\tfloat t18 = t17*t;\n\tfloat t19 = t18*t;\n\tfloat t20 = t19*t;\n\tfloat t21 = t20*t;\n\tfloat t22 = t21*t;\n\tfloat t23 = t22*t;\n\tfloat t24 = t23*t;\n\tfloat t25 = t24*t;\n\tfloat t26 = t25*t;\n\tfloat t27 = t26*t;\n\tfloat t28 = t27*t;\n\tfloat t29 = t28*t;\n\tfloat t30 = t29*t;\n\tfloat t31 = t30*t;\n\tfloat t32 = t31*t;\n\tfloat t33 = t32*t;\n\tfloat t34 = t33*t;\n\tfloat t35 = t34*t;\n\tfloat t36 = t35*t;\n\tfloat t37 = t36*t;\n\tfloat t38 = t37*t;\n\tfloat t39 = t38*t;\n\tfloat t40 = t39*t;\n\tfloat t41 = t40*t;\n\tfloat t42 = t41", "\n\treturn 0.5f * (1.0f + sinf(u * 3.14159265358979323846f));\n}\n\nfloat Hash2d(float u, float v)\n{\n\treturn 0.5f * (1.0f + sinf(u * 3.14159265358979323846f + v * 2.0f * 3.14159265358979323846f));\n}\n\nfloat Hash3d(float u, float v, float w)\n{\n\treturn 0.5f * (1.0f + sinf(u * 3.14159265358979323846f + v * 2.0f * 3.14159265358979323846f + w * 3.0f * 3.14159265358979323846f));\n}\n\nfloat Hash4d(float u, float v, float w, float x)\n{\n\treturn 0.5f * (1.0f + sinf(u * 3.14159265358979323846f + v * 2.0f * 3.14159265358979323846f + w * 3.0f * 3.14159265358979323846f + x * 4.0f * 3.14159265358979323846f));\n}\n\n// noise functions\nfloat Noise1d(float u)\n{\n\tint i0 = (int)floor(u);\n\tint i1 = i0 + 1;\n\tfloat u0 = u - (float)i0;\n\tfloat u1 = u0 - 1.0f;\n", "\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat maxAmp = 0.0;\n\tfloat maxFreq = 0.0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfloat theta = p[i] * 0.25 * freq;\n\t\tfloat phi = p[i] * 0.5 * freq;\n\t\tfloat r = sqrt(p[i] * p[i] * freq * freq);\n\t\tfloat x = r * cos(theta) * cos(phi);\n\t\tfloat y = r * sin(theta) * cos(phi);\n\t\tfloat z = r * sin(phi);\n\t\tvec3 v = vec3(x, y, z);\n\t\tsum += amp * sin(dot(v, p) * 0.5 + 0.5);\n\t\tmaxAmp = max(maxAmp, amp);\n\t\tmaxFreq = max(maxFreq, freq);\n\t\tamp *= 0.5;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum * normalizer * maxAmp * maxFreq;\n}\n\n// This is a simple noise function that works on 2D and 3D.\n// It's not very good, but it's fast.\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n000 = dot(i, i) + dot(i, i + 1.0);\n\tfloat n100 = dot(i + 1.0, i) + dot(i + 1.0, i + 1.0);\n\tfloat n010 = dot(i, i + 1.0) + dot(i + 1.0, i + 1.0);\n\tfloat n110 = dot(i + 1.0, i + 1.0) + dot(i + 1.0, i + 2.0);\n\tfloat n001 = dot(i, i + 2", "\n\tfloat d = 0.0f;\n\tfloat d2 = 0.0f;\n\tfloat d3 = 0.0f;\n\tfloat d4 = 0.0f;\n\tfloat d5 = 0.0f;\n\tfloat d6 = 0.0f;\n\tfloat d7 = 0.0f;\n\tfloat d8 = 0.0f;\n\tfloat d9 = 0.0f;\n\tfloat d10 = 0.0f;\n\tfloat d11 = 0.0f;\n\tfloat d12 = 0.0f;\n\tfloat d13 = 0.0f;\n\tfloat d14 = 0.0f;\n\tfloat d15 = 0.0f;\n\tfloat d16 = 0.0f;\n\tfloat d17 = 0.0f;\n\tfloat d18 = 0.0f;\n\tfloat d19 = 0.0f;\n\tfloat d20 = 0.0f;\n\tfloat d21 = 0.0f;\n\tfloat d22 = 0.0f;\n\tfloat d23 = 0.0f;\n\tfloat d24 = 0.0f;\n\tfloat d25 = 0.0f;\n\tfloat d26 = 0.0f;\n\tfloat d27 = 0.0f;\n\tfloat d28 = 0.0f;\n\tfloat d29 = 0.0f;\n\tfloat d30 = 0.0f;\n\tfloat d31 = 0.0f;\n\tfloat d32 = 0.0f;\n\tfloat d33 = 0.0f;\n\tfloat d34 = 0.0f;\n\tfloat d35 = 0.0f;\n\tfloat d36 = 0.0f;\n\tfloat d37 = 0.0f;\n\tfloat d38 = 0.0f;\n\tfloat d39 = 0.0f;\n\tfloat d40 = 0.0f;\n\t", "\n\tvec3 envColor = vec3(0.0);\n\n\t// Softbox\n\tfloat softbox = 0.0;\n\tfloat softboxSize = 0.05;\n\tfloat softboxDist = 0.0;\n\tfloat softboxDistSq = 0.0;\n\tfloat softboxDistSqMax = softboxSize * softboxSize;\n\tfloat softboxDistSqMin = softboxDistSqMax * 0.25;\n\tfloat softboxDistSqMid = softboxDistSqMax * 0.5;\n\tfloat softboxDistSqMid2 = softboxDistSqMax * 0.75;\n\tfloat softboxDistSqMid3 = softboxDistSqMax * 0.9;\n\tfloat softboxDistSqMid4 = softboxDistSqMax * 0.95;\n\tfloat softboxDistSqMid5 = softboxDistSqMax * 0.975;\n\tfloat softboxDistSqMid6 = softboxDistSqMax * 0.99;\n\tfloat softboxDistSqMid7 = softboxDistSqMax * 0.995;\n\tfloat softboxDistSqMid8 = softboxDistSqMax * 0.9975;\n\tfloat softboxDistSqMid9 = softboxDistSqMax * 0.999;\n\tfloat softboxDistSqMid10 = softboxDistSqMax * 0.9995;\n\tfloat softboxDistSqMid11 = softboxDistSqMax * 0.99975;\n\tfloat softboxDistSqMid12 = softboxDistSqMax * 0.9999;\n\tfloat softboxDistSqMid13 = softboxDistSqMax * 0.99995;\n\tfloat softboxDistSqMid14 = softboxDistSqMax * 0.999975;\n\tfloat softboxDistSqMid15 = softboxDistSqMax * 0.99999;\n\tfloat softboxDistSqMid16 = softboxDistSqMax * 0.999995;\n\tfloat softboxDistSqMid17 = softboxDistSqMax * 0.9999", "\n\treturn a + k * (b - a);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);\nfloat lmin( float a, float b, float k )\n{\n\treturn a + k * (b - a);\n}\n\n// linear smooth max (k = 0.1);\nfloat lmax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);\nfloat lmin( float a, float b, float k )\n{\n\treturn a + k * (b - a);\n}\n\n// linear smooth max (k = 0.1);\nfloat lmax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);\nfloat lmin( float a, float b, float k )\n{\n\treturn a + k * (b - a);\n}\n\n// linear smooth max (k = 0.1);\nfloat lmax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);\nfloat lmin( float a, float b, float k )\n{\n\treturn a + k * (b - a);\n}\n\n// linear smooth max (k = 0.1);\nfloat lmax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);\nfloat lmin( float a, float b, float k )\n{\n\treturn a + k * (b - a);\n}\n\n// linear smooth max (k = 0.1);\nfloat lmax( float a, float b, float k )\n{\n\treturn b - k * (b - a);\n}\n\n// linear smooth min (k = 0.1);", "\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 dirVecNorm = normalize(dirVec);\n\tvec3 sphereToPos = pos - spherePos;\n\tfloat a = dot(dirVecNorm, dirVecNorm);\n\tfloat b = 2.0f * dot(dirVecNorm, sphereToPos);\n\tfloat c = dot(sphereToPos, sphereToPos) - rad * rad;\n\tfloat discriminant = b * b - 4.0f * a * c;\n\tif (discriminant < 0.0f)\n\t{\n\t\treturn -1.0f;\n\t}\n\telse\n\t{\n\t\tfloat t1 = (-b - sqrt(discriminant)) / (2.0f * a);\n\t\tfloat t2 = (-b + sqrt(discriminant)) / (2.0f * a);\n\t\tif (t1 < 0.0f)\n\t\t{\n\t\t\treturn t2;\n\t\t}\n\t\telse if (t2 < 0.0f)\n\t\t{\n\t\t\treturn t1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(t1, t2);\n\t\t}\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat PlaneIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos, vec3 planeNorm)\n{\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 dirVecNorm = normalize(dirVec);\n\tvec3 planeToPos = pos - planePos;\n\tfloat a = dot(dirVecNorm, planeNorm);\n\tfloat b = dot(planeNorm, planeToPos);\n\tif (a == 0.0f)\n\t{\n\t\treturn -1.0f;\n\t}\n\telse\n\t{\n\t\treturn -b / a;\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat TriangleIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 triPos1, vec3 triPos2, vec3 triPos3)\n{\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 dirVecNorm = normalize(dirVec);", "\n\t// Calculate the distance to the closest point on the object.\n\tvec3 closestPoint = ClosestPointOnObject(p);\n\tvec2 distance = p - closestPoint;\n\treturn distance;\n}\n\n// Calculate the closest point on the object to the given point.\nvec3 ClosestPointOnObject(vec3 p)\n{\n\t// Calculate the closest point on the object to the given point.\n\tvec3 closestPoint = p;\n\tclosestPoint.x = clamp(closestPoint.x, -1.0, 1.0);\n\tclosestPoint.y = clamp(closestPoint.y, -1.0, 1.0);\n\tclosestPoint.z = clamp(closestPoint.z, -1.0, 1.0);\n\treturn closestPoint;\n}\n\n// Calculate the closest point on the object to the given point.\nvec3 ClosestPointOnObject(vec2 p)\n{\n\t// Calculate the closest point on the object to the given point.\n\tvec3 closestPoint = vec3(p, 0.0);\n\tclosestPoint.x = clamp(closestPoint.x, -1.0, 1.0);\n\tclosestPoint.y = clamp(closestPoint.y, -1.0, 1.0);\n\treturn closestPoint;\n}\n\n// Calculate the closest point on the object to the given point.\nvec2 ClosestPointOnObject(vec2 p)\n{\n\t// Calculate the closest point on the object to the given point.\n\tvec2 closestPoint = p;\n\tclosestPoint.x = clamp(closestPoint.x, -1.0, 1.0);\n\tclosestPoint.y = clamp(closestPoint.y, -1.0, 1.0);\n\treturn closestPoint;\n}\n\n// Calculate the closest point on the object to the given point.\nvec3 ClosestPointOnObject(vec3 p, vec3 normal)\n{\n\t// Calculate the closest point on the object to the given point.\n\tvec3 closestPoint = p;\n\tclosestPoint.x = clamp(closestPoint.x, -1.0, 1.0);\n\tclosestPoint.y = clamp(closestPoint.y, -1.0, 1", "\n\treturn vec3(t, t*t, t*t*t);\n}\n\n// curve\nvec3 mapD1(float t)\n{\n\treturn vec3(3*t*t, 2*t*t*t, 3*t*t*t);\n}\n\n// curve\nvec3 mapD2(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD3(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD4(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD5(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD6(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD7(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD8(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD9(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD10(float t)\n{\n\treturn vec3(6*t*t, 6*t*t*t, 6*t*t*t);\n}\n\n// curve\nvec3 mapD11", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve acceleration (acceleration)\nvec3 mapD2(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve curvature (curvature)\nfloat mapD3(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD4(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD5(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD6(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD7(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD8(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD9(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD10(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD11(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD12(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD13(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD14(float t)\n{\n\treturn 0.0;\n}\n\n// curve curvature (curvature)\nfloat mapD15(float t)\n{\n\treturn 0.0;\n}\n\n// curve torsion (torsion)\nfloat mapD16(float t)\n{\n\treturn", "\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve seventh derivative (bounce)\nvec3 mapD7(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve eighth derivative (bounce)\nvec3 mapD8(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve ninth derivative (bounce)\nvec3 mapD9(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve tenth derivative (bounce)\nvec3 mapD10(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve eleventh derivative (bounce)\nvec3 mapD11(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve twelfth derivative (bounce)\nvec3 mapD12(float t)\n{\n\treturn vec3(0.0f, 0.0f, 0.0f);\n}\n\n// curve thirteenth derivative", "\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tvec3 bp = p - b;\n\tfloat ab2 = dot(ab, ab);\n\tfloat ap2 = dot(ap, ap);\n\tfloat bp2 = dot(bp, bp);\n\tfloat abap = dot(ab, ap);\n\tfloat abbp = dot(ab, bp);\n\tfloat t = abap / ab2;\n\tfloat u = abbp / ab2;\n\tfloat v = ap2 / ab2;\n\tfloat w = bp2 / ab2;\n\tif (t < 0.0)\n\t{\n\t\tt = 0.0;\n\t\tu = 0.0;\n\t\tv = 1.0;\n\t\tw = 0.0;\n\t}\n\telse if (t > 1.0)\n\t{\n\t\tt = 1.0;\n\t\tu = 0.0;\n\t\tv = 0.0;\n\t\tw = 1.0;\n\t}\n\telse\n\t{\n\t\tu = 1.0 - t;\n\t\tv = t;\n\t\tw = 0.0;\n\t}\n\treturn vec2(u, w);\n}\n\n// unsigned squared distance between point and triangle\nvec2 usqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 bc = c - b;\n\tvec3 ap = p - a;\n\tvec3 bp = p - b;\n\tvec3 cp = p - c;\n\tfloat ab2 = dot(ab, ab);\n\tfloat ac2 = dot(ac, ac);\n\tfloat bc2 = dot(bc, bc);\n\tfloat abac = dot(ab, ac);\n\tfloat abbc = dot(ab, bc);\n\tfloat abcp = dot(ab, cp);\n\tfloat abbp = dot(ab, bp);\n\tfloat abap = dot(ab, ap);\n\tfloat t = abap / ab2;\n\tfloat u = abcp / ab2;\n\tfloat v = ab", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d - a;\n\tvec3 bd = b - d;\n\tvec3 aoad = ao - ad;\n\tvec3 aoabd = ao - ab - bd;\n\tfloat t = dot( aoad, ad ) / dot( ad, ad );\n\tfloat u = dot( aoabd, ad ) / dot( ad, ad );\n\tfloat v = dot( aoabd, ab ) / dot( ab, ab );\n\treturn t * t * dot( ao, ao ) + u * u * dot( ad, ad ) + v * v * dot( ab, ab );\n}\n\n// unsigned squared distance between ray and triangle\nvec2 usqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = c - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d - a;\n\tvec3 aoad = ao - ad;\n\tvec3 aoabd = ao - ab - ad;\n\tvec3 aoac = ao - ac;\n\tvec3 aoabc = ao - ab - ac;\n\tfloat t = dot( aoad, ad ) / dot( ad, ad );\n\tfloat u = dot( aoabd, ad ) / dot( ad, ad );\n\tfloat v = dot( aoac, ad ) / dot( ad, ad );\n\tfloat w = dot( aoabc, ad ) / dot( ad, ad );\n\tfloat t2 = t * t;\n\tfloat u2 = u * u;\n\tfloat v2 = v * v;\n\tfloat w2 = w * w;\n\tfloat tuv = t * u;\n\tfloat tuw = t * w;\n\tfloat tvw = t * v;\n\tfloat uvw = u * v;\n\tfloat uvw2 = uvw * uvw;\n\tfloat t2u2 = t2 * u2;\n\tfloat t2v2 = t2 * v2;\n\tfloat t2w2 = t2 * w2;\n\tfloat u2v2 = u2 * v2;\n\t", "\n    vec2 d = abs(p) - b + r.xy;\n    return min(max(d.x, d.y), 0.0) + length(max(d.xy, 0.0)) - r.zw;\n}\n\n// p.x = x\n// p.y = y\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    vec2 d = abs(p) - b + r.xy;\n    return min(max(d.x, d.y), 0.0) + length(max(d.xy, 0.0)) - r.zw;\n}\n\n// p.x = x\n// p.y = y\n// p.z = z\n// b.x = width\n// b.y = height\n// b.z = depth\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n    vec3 d = abs(p) - b + r.xy;\n    return min(max(d.x, d.y), 0.0) + length(max(d.xy, 0.0)) - r.zw;\n}\n\n// p.x = x\n// p.y = y\n// p.z = z\n// b.x = width\n// b.y = height\n// b.z = depth\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n    vec3 d = abs(p) - b + r.xy;\n    return min", "\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius * sunRadius2;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2, float sunRadius3)\n{\n\tfloat dot = dot(rayDir, sunDir);\n\treturn sunCol * pow(dot, 10.0) * sunIntensity * sunRadius * sunRadius2 * sunRadius3;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir, float sunIntensity, float sunRadius, float sunRadius2, float sunRadius3, float sunRadius4)\n{\n\tfloat dot = dot(rayDir, sunDir);", "\n\t// Calculate the rotation matrix for the roll\n\tmat3 rollRotationMatrix = mat3(\n\t\tvec3( 1, 0, 0 ),\n\t\tvec3( 0, cos( roll ), -sin( roll ) ),\n\t\tvec3( 0, sin( roll ), cos( roll ) )\n\t);\n\n\t// Calculate the rotation matrix for the pitch\n\tmat3 pitchRotationMatrix = mat3(\n\t\tvec3( cos( roll ), 0, sin( roll ) ),\n\t\tvec3( 0, 1, 0 ),\n\t\tvec3( -sin( roll ), 0, cos( roll ) )\n\t);\n\n\t// Calculate the rotation matrix for the yaw\n\tmat3 yawRotationMatrix = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0 ),\n\t\tvec3( 0, 0, 1 )\n\t);\n\n\t// Calculate the rotation matrix for the yaw\n\tmat3 yawRotationMatrix2 = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0 ),\n\t\tvec3( 0, 0, 1 )\n\t);\n\n\t// Calculate the rotation matrix for the yaw\n\tmat3 yawRotationMatrix3 = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0 ),\n\t\tvec3( 0, 0, 1 )\n\t);\n\n\t// Calculate the rotation matrix for the yaw\n\tmat3 yawRotationMatrix4 = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0 ),\n\t\tvec3( 0, 0, 1 )\n\t);\n\n\t// Calculate the rotation matrix for the yaw\n\tmat3 yawRotationMatrix5 = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0 ),\n\t\tvec3( 0, 0, 1 )\n\t);\n\n\t// Calculate the rotation matrix", "\n\tvec2 balloon = vec2(0.0);\n\tvec2 balloonSize = vec2(0.0);\n\tvec2 balloonPosition = vec2(0.0);\n\tvec2 balloonVelocity = vec2(0.0);\n\tvec2 balloonAcceleration = vec2(0.0);\n\tvec2 balloonForce = vec2(0.0);\n\tvec2 balloonDrag = vec2(0.0);\n\tvec2 balloonGravity = vec2(0.0);\n\tvec2 balloonFriction = vec2(0.0);\n\tvec2 balloonCollision = vec2(0.0);\n\tvec2 balloonCollisionNormal = vec2(0.0);\n\tvec2 balloonCollisionPoint = vec2(0.0);\n\tvec2 balloonCollisionPointVelocity = vec2(0.0);\n\tvec2 balloonCollisionPointAcceleration = vec2(0.0);\n\tvec2 balloonCollisionPointForce = vec2(0.0);\n\tvec2 balloonCollisionPointDrag = vec2(0.0);\n\tvec2 balloonCollisionPointGravity = vec2(0.0);\n\tvec2 balloonCollisionPointFriction = vec2(0.0);\n\tvec2 balloonCollisionPointCollision = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionNormal = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPoint = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointVelocity = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointAcceleration = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointForce = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointDrag = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointGravity = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointFriction = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointCollision = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointCollisionNormal = vec2(0.0);\n\tvec2 balloonCollisionPointCollisionPointCollisionPoint = vec2(0.0);", "\n\tfloat distance1 = distance( thing1, thing2 );\n\tfloat distance2 = distance( thing1, thing2 );\n\tif( distance1 < distance2 ){\n\t\treturn thing1;\n\t}\n\telse{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3 ){\n\tfloat distance1 = distance( thing1, thing2 );\n\tfloat distance2 = distance( thing1, thing2 );\n\tfloat distance3 = distance( thing1, thing2 );\n\tif( distance1 < distance2 && distance1 < distance3 ){\n\t\treturn thing1;\n\t}\n\telse if( distance2 < distance1 && distance2 < distance3 ){\n\t\treturn thing2;\n\t}\n\telse{\n\t\treturn thing3;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3, vec2 thing4 ){\n\tfloat distance1 = distance( thing1, thing2 );\n\tfloat distance2 = distance( thing1, thing2 );\n\tfloat distance3 = distance( thing1, thing2 );\n\tfloat distance4 = distance( thing1, thing2 );\n\tif( distance1 < distance2 && distance1 < distance3 && distance1 < distance4 ){\n\t\treturn thing1;\n\t}\n\telse if( distance2 < distance1 && distance2 < distance3 && distance2 < distance4 ){\n\t\treturn thing2;\n\t}\n\telse if( distance3 < distance1 && distance3 < distance2 && distance3 < distance4 ){\n\t\treturn thing3;\n\t}\n\telse{\n\t\treturn thing4;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n", "\n\tvec2 closestPoint = vec2( 0.0, 0.0 );\n\tfloat closestDistance = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat epsilon = 0.00001;\n\tvec3 normal = vec3(0.0, 0.0, 0.0);\n\tvec3 delta = vec3(epsilon, 0.0, 0.0);\n\tvec3 delta2 = vec3(0.0, epsilon, 0.0);\n\tvec3 delta3 = vec3(0.0, 0.0, epsilon);\n\tvec3 delta4 = vec3(-epsilon, 0.0, 0.0);\n\tvec3 delta5 = vec3(0.0, -epsilon, 0.0);\n\tvec3 delta6 = vec3(0.0, 0.0, -epsilon);\n\tfloat d1 = getSDF(positionOfHit + delta);\n\tfloat d2 = getSDF(positionOfHit + delta2);\n\tfloat d3 = getSDF(positionOfHit + delta3);\n\tfloat d4 = getSDF(positionOfHit + delta4);\n\tfloat d5 = getSDF(positionOfHit + delta5);\n\tfloat d6 = getSDF(positionOfHit + delta6);\n\tnormal.x = d1 - d4;\n\tnormal.y = d2 - d5;\n\tnormal.z = d3 - d6;\n\treturn normalize(normal);\n}\n\n// This is the function that will be called to get the\n// color of the pixel.\nvec3 getColor( in vec3 positionOfHit ){\n\tvec3 normal = getNormalOfSurface(positionOfHit);\n\tvec3 lightDirection = normalize(vec3(0.0, 0.0, 1.0));\n\tfloat diffuse = max(0.0, dot(normal, lightDirection));\n\tvec3 color = vec3(diffuse, diffuse, diffuse);\n\treturn color;\n}\n\nvoid main(){\n\tvec3 positionOfHit = getPositionOfHit();\n\tvec3 color = getColor(positionOfHit);\n\tgl_FragColor = vec4(color, 1.0);\n}\n`\n\n// This is the function that will be called to get the\n// color of the pixel.\nfunc getColor(positionOfHit vec3) vec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// this is the function that does the actual lighting calculations.\n// it takes in the light position, the normal, and the position of the\n// point we are lighting.\nvec3 doLighting(vec3 lightPosition, vec3 normal, vec3 position){\n\t// first we need to calculate the light direction.\n\tvec3 lightDirection = normalize(lightPosition - position);\n\n\t// then we need to calculate the angle between the normal and the light direction.\n\tfloat nDotL = max(dot(lightDirection, normal), 0.0);\n\n\t// now we calculate the angle between the view direction and the light direction.\n\tvec3 viewDirection = normalize(cameraPosition - position);\n\tfloat vDotL = max(dot(lightDirection, viewDirection), 0.0);\n\n\t// finally we calculate the angle between the view direction and the normal.\n\tfloat vDotN = max(dot(normal, viewDirection), 0.0);\n\n\t// now we calculate the specular component.\n\tfloat specular = pow(vDotN, shininess);\n\n\t// and then we calculate the diffuse component.\n\tfloat diffuse = nDotL;\n\n\t// and then we calculate the ambient component.\n\tfloat ambient = 0.1;\n\n\t// and then we calculate the final color.\n\tvec3 color = ambient * ambientColor + diffuse * diffuseColor + specular * specularColor;\n\n\t// and we return it.\n\treturn color;\n}\n\n// this is the function that does the actual lighting calculations.\n// it takes in the light position, the normal, and the position of the\n// point we are lighting.\nvec3 doLighting2(vec3 lightPosition, vec3 normal, vec3 position){\n\t// first we need to calculate the light direction.\n\tvec3 lightDirection = normalize(lightPosition - position);\n\n\t// then we need to calculate the angle between the normal and the light direction.\n\tfloat nDotL = max(dot(lightDirection, normal), 0.0);\n\n\t// now we calculate the angle between the view direction and the light direction.\n\tvec3 viewDirection = normalize(cameraPosition - position);\n\tfloat vDotL =", "\n\tvec3 color = vec3(0.0,0.0,0.0);\n\tvec3 lightDirection = normalize(vec3(0.0,0.0,-1.0));\n\tvec3 lightColor = vec3(1.0,1.0,1.0);\n\tfloat diffuse = max(0.0, dot(lightDirection, normalOfSurface));\n\tcolor = lightColor * diffuse;\n\treturn color;\n}\n\n// This is the function that will be called for each ray\n// that is cast.\nvec3 doRayTrace(vec3 rayOrigin, vec3 rayDirection, int depth){\n\t// This is the color that will be returned.\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// does not hit anything.\n\tvec3 defaultColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the box.\n\tvec3 boxColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the sphere.\n\tvec3 sphereColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the plane.\n\tvec3 planeColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the cylinder.\n\tvec3 cylinderColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the cone.\n\tvec3 coneColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the torus.\n\tvec3 torusColor = vec3(0.0,0.0,0.0);\n\t// This is the color that will be returned if the ray\n\t// hits the ellipsoid.\n\tvec3 el", "\n\tvec3 color = vec3(0.0,0.0,0.0);\n\tvec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n\tvec3 hitNormal = normalize( hitPosition - vec3(0.0,0.0,0.0) );\n\tvec3 hitColor = vec3(0.0,0.0,0.0);\n\tfloat hitDistance = rayHitInfo.x;\n\tfloat hitDistanceSquared = rayHitInfo.x * rayHitInfo.x;\n\tfloat hitDistanceCubed = hitDistanceSquared * rayHitInfo.x;\n\tfloat hitDistanceQuartic = hitDistanceCubed * rayHitInfo.x;\n\tfloat hitDistanceQuintic = hitDistanceQuartic * rayHitInfo.x;\n\tfloat hitDistanceSextic = hitDistanceQuintic * rayHitInfo.x;\n\tfloat hitDistanceSeptic = hitDistanceSextic * rayHitInfo.x;\n\tfloat hitDistanceOctic = hitDistanceSeptic * rayHitInfo.x;\n\tfloat hitDistanceNonic = hitDistanceOctic * rayHitInfo.x;\n\tfloat hitDistanceDecic = hitDistanceNonic * rayHitInfo.x;\n\tfloat hitDistanceUndecic = hitDistanceDecic * rayHitInfo.x;\n\tfloat hitDistanceDuodecic = hitDistanceUndecic * rayHitInfo.x;\n\tfloat hitDistanceTredecic = hitDistanceDuodecic * rayHitInfo.x;\n\tfloat hitDistanceQuattuordecic = hitDistanceTredecic * rayHitInfo.x;\n\tfloat hitDistanceQuindecic = hitDistanceQuattuordecic * rayHitInfo.x;\n\tfloat hitDistanceSexdecic = hitDistanceQuindecic * rayHitInfo.x;\n\tfloat hitDistanceSeptendecic = hitDistanceSexdecic * rayHitInfo.x;\n\tfloat hitDistanceOctodecic = hitDistanceSeptendecic * rayHitInfo.x;\n\tfloat hitDistanceNovemdecic = hitDistanceOctodecic * rayHitInfo.x;\n\tfloat hitDistanceVigintic = hitDistanceNovemdecic * rayHitInfo.x;\n\tfloat hitDistanceUnvigintic = hit", "\n    return (x * x * (3.0 - 2.0 * b));\n}\n\n// smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat smoothstep(float x, float b) {\n    return (x * x * (3.0 - 2.0 * b));\n}\n\n// smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat smoothstep_2(float x, float b) {\n    return (x * x * (3.0 - 2.0 * b));\n}\n\n// smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat smoothstep_3(float x, float b) {\n    return (x * x * (3.0 - 2.0 * b));\n}\n\n// smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat smoothstep_4(float x, float b) {\n    return (x * x * (3.0 - 2.0 * b));\n}\n\n// smoothstep\n// https://", "\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n\treturn fract(sin(dot(p, vec3(12.9898, 78.233, 123.456))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n\treturn fract(sin(dot(p, vec4(12.9898, 78.233, 123.456, 76.5432))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n\treturn fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(int p){\n\treturn fract(sin(float(p) * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(ivec2 p){\n\treturn fract(sin(dot(p, ivec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(ivec3 p){\n\treturn fract(sin(dot(p, ivec3(12.9898, 78.233, 123.456))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1", "\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){\n\treturn rand(p) / 254.0;\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand_exclusive_inclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_inclusive_exclusive(vec2 p){\n\treturn rand(p) / 254.0;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_inclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_inclusive(vec2 p){\n\treturn rand(p) / 254.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_inclusive_exclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_inclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_inclusive(vec2 p){\n\treturn rand(p) / 254.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_inclusive_exclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive_inclusive(vec2 p){\n\treturn rand(p) / 255.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding", "\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input min and max --> is box min and max\n// pretty simple, just compare point to min and max\nfloat sdBox(vec3 p, vec3 min, vec3 max)\n{\n\tvec3 d = abs(p) - vec3(min, max);\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input p, r, h --> is cylinder position, radius and height\n// pretty simple, just compare point to cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n\tp.y = abs(p.y) - h/2.0;\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input p, r, h --> is cone position, radius and height\n// pretty simple, just compare point to cone\nfloat sdCone(vec3 p, float r, float h)\n{\n\tp.y = abs(p.y) - h/2.0;\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input p, r1, r2 --> is torus position, radius1 and radius2\n// pretty simple, just compare point to torus\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n\tp.xy = sqrt(dot(p.xy, p.xy)) - r1;\n\treturn length(p) - r2;\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input p, n --> is plane position and normal\n// pretty simple, just compare point to plane\nfloat sdPlane(vec3 p, vec3 n)\n{\n\treturn dot(p, n);\n}\n\n// ~~~~~~~ signed fistance fuction for triangle\n// input p, a, b, c --> is triangle position, a, b and c\n// pretty simple, just compare point to", "\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat r = t.x - t.y;\n\tfloat d = length(q) - r;\n\treturn d;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n// \tt.x = cylinder radius\n//\tt.y = cylinder height\n//  \n// think of the cylinder as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder height from that \nfloat sdCylinder(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat r = t.x;\n\tfloat d = length(q) - r;\n\treturn d;\n}\n\n// ~~~~~~~ signed distance function for cone\n// input t --> cone specs where:\n// \tt.x = cone radius\n//\tt.y = cone height\n//  \n// think of the cone as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone height from that \nfloat sdCone(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat r = t.x;\n\tfloat d = length(q) - r;\n\treturn d;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n// \tt.x = sphere radius\n//  \n// think of the sphere as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere circumference/core/radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat sdSphere(vec3 p,", "\n\tfloat a = 1.0f;\n\tfloat b = 0.5f;\n\tfloat t = 1.0f - (d1 / (d1 + d2));\n\treturn (1.0f - t) * (1.0f - t) * (1.0f - t) * a + t * t * t * b;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float a, float b)\n{\n\tfloat t = 1.0f - (d1 / (d1 + d2));\n\treturn (1.0f - t) * (1.0f - t) * (1.0f - t) * a + t * t * t * b;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float a, float b, float c)\n{\n\tfloat t = 1.0f - (d1 / (d1 + d2));\n\treturn (1.0f - t) * (1.0f - t) * (1.0f - t) * a + t * t * t * b + t * t * t * c;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float a, float", "\n\treturn (d1 + d2) / 2.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3)\n{\n\treturn (d1 + d2 + d3) / 3.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4)\n{\n\treturn (d1 + d2 + d3 + d4) / 4.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5)\n{\n\treturn (d1 + d2 + d3 + d4 + d5) / 5.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5, float d6)\n{\n\treturn (d1 + d2 + d3 + d4 + d5 + d6) / 6.0;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5, float d6, float d7)\n{\n\treturn (d1 + d2 + d3", "\n\tvec3 q = p;\n\tfloat r = length(p);\n\tfloat theta = atan(p.y, p.x);\n\tfloat phi = atan(p.z, sqrt(p.x*p.x + p.y*p.y));\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\tfloat s2 = sin(2*theta);\n\tfloat c2 = cos(2*theta);\n\tfloat s3 = sin(3*theta);\n\tfloat c3 = cos(3*theta);\n\tfloat s4 = sin(4*theta);\n\tfloat c4 = cos(4*theta);\n\tfloat s5 = sin(5*theta);\n\tfloat c5 = cos(5*theta);\n\tfloat s6 = sin(6*theta);\n\tfloat c6 = cos(6*theta);\n\tfloat s7 = sin(7*theta);\n\tfloat c7 = cos(7*theta);\n\tfloat s8 = sin(8*theta);\n\tfloat c8 = cos(8*theta);\n\tfloat s9 = sin(9*theta);\n\tfloat c9 = cos(9*theta);\n\tfloat s10 = sin(10*theta);\n\tfloat c10 = cos(10*theta);\n\tfloat s11 = sin(11*theta);\n\tfloat c11 = cos(11*theta);\n\tfloat s12 = sin(12*theta);\n\tfloat c12 = cos(12*theta);\n\tfloat s13 = sin(13*theta);\n\tfloat c13 = cos(13*theta);\n\tfloat s14 = sin(14*theta);\n\tfloat c14 = cos(14*theta);\n\tfloat s15 = sin(15*theta);\n\tfloat c15 = cos(15*theta);\n\tfloat s16 = sin(16*theta);\n\tfloat c16 = cos(16*theta);\n\tfloat s17 = sin(17*theta);\n\tfloat c17 = cos(17*theta);\n\tfloat s18 = sin(18*theta);\n\tfloat", "\n\tif (o1.x < o2.x) return o1;\n\telse return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3)\n{\n\tif (o1.x < o2.x)\n\t{\n\t\tif (o1.x < o3.x) return o1;\n\t\telse return o3;\n\t}\n\telse\n\t{\n\t\tif (o2.x < o3.x) return o2;\n\t\telse return o3;\n\t}\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3, vec2 o4)\n{\n\tif (o1.x < o2.x)\n\t{\n\t\tif (o1.x < o3.x)\n\t\t{\n\t\t\tif (o1.x < o4.x) return o1;\n\t\t\telse return o4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (o3.x < o4.x) return o3;\n\t\t\telse return o4;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (o2.x < o3.x)\n\t\t{\n\t\t\tif (o2.x < o4.x) return o2;\n\t\t\telse return o4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (o3.x < o4.x) return o3;\n\t\t\telse return o4;\n\t\t}\n\t}\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1,", "\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t", "\n\tfloat t = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\t// 1. find closest surface\n\tfloat t = findClosestSurface(ro, rd);\n\tif (t == -1) return vec3(0.0f);\n\n\t// 2. apply color\n\tvec3 surfaceColor = getSurfaceColor(ro, rd, t);\n\treturn surfaceColor;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, float t)\n{\n\t// 1. find closest surface\n\tif (t == -1) return vec3(0.0f);\n\n\t// 2. apply color\n\tvec3 surfaceColor = getSurfaceColor(ro, rd, t);\n\treturn surfaceColor;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, float t, vec3 surfaceColor)\n{\n\t// 1. find closest surface\n\tif (t == -1) return vec3(0.0f);\n\n\t// 2. apply color\n\treturn surfaceColor;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, float t, vec3 surfaceColor, vec3 lightColor)\n{\n\t// 1. find closest surface\n\tif (t == -1) return vec3(0.0f);\n\n\t// 2. apply color\n\treturn surfaceColor;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, float t, vec3 surfaceColor, vec3 lightColor, vec3 lightPosition)\n{\n\t// 1. find closest surface\n\tif (t == -1) return vec3(0.0f);", "\n\tvec3 camDir = normalize( camPos - targetPos );\n\tvec3 camRight = normalize( cross( camDir, vec3( 0.0, 1.0, 0.0 ) ) );\n\tvec3 camUp = normalize( cross( camRight, camDir ) );\n\n\tmat3 camRot = mat3( camRight, camUp, camDir );\n\tmat3 camRotRoll = rotate( camRot, roll, vec3( 0.0, 0.0, 1.0 ) );\n\n\tmat3 camTrans = mat3( 1.0, 0.0, -camPos.x, 0.0, 1.0, -camPos.y, 0.0, 0.0, 1.0 );\n\n\treturn camTrans * camRotRoll;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 camUp, float roll )\n{\n\tvec3 camDir = normalize( camPos - targetPos );\n\tvec3 camRight = normalize( cross( camDir, camUp ) );\n\tvec3 camUp = normalize( cross( camRight, camDir ) );\n\n\tmat3 camRot = mat3( camRight, camUp, camDir );\n\tmat3 camRotRoll = rotate( camRot, roll, vec3( 0.0, 0.0, 1.0 ) );\n\n\tmat3 camTrans = mat3( 1.0, 0.0, -camPos.x, 0.0, 1.0, -camPos.y, 0.0, 0.0, 1.0 );\n\n\treturn camTrans * camRotRoll;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos", "\n\tvec3 color;\n\tif(id == 0)\n\t{\n\t\tcolor = vec3(1.0, 0.0, 0.0);\n\t}\n\telse if(id == 1)\n\t{\n\t\tcolor = vec3(0.0, 1.0, 0.0);\n\t}\n\telse if(id == 2)\n\t{\n\t\tcolor = vec3(0.0, 0.0, 1.0);\n\t}\n\telse if(id == 3)\n\t{\n\t\tcolor = vec3(1.0, 1.0, 0.0);\n\t}\n\telse if(id == 4)\n\t{\n\t\tcolor = vec3(0.0, 1.0, 1.0);\n\t}\n\telse if(id == 5)\n\t{\n\t\tcolor = vec3(1.0, 0.0, 1.0);\n\t}\n\telse if(id == 6)\n\t{\n\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t}\n\telse if(id == 7)\n\t{\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\treturn color;\n}\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors2(float id)\n{\n\tvec3 color;\n\tif(id == 0)\n\t{\n\t\tcolor = vec3(1.0, 0.0, 0.0);\n\t}\n\telse if(id == 1)\n\t{\n\t\tcolor = vec3(0.0, 1.0, 0.0);\n\t}\n\telse if(id == 2)\n\t{\n\t\tcolor", "\n    p.xz = normalize(p.xz);\n    float d = length(p.xz) - t.x;\n    d = abs(d) - t.y;\n    return d;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n//  t.x = cylinder radius\n//  t.y = cylinder height\n// \n// think of the cylinder as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder height from that \nfloat sdCylinder(vec3 p, vec2 t)\n{\n    p.xz = normalize(p.xz);\n    float d = length(p.xz) - t.x;\n    d = abs(d) - t.y;\n    return d;\n}\n\n// ~~~~~~~ signed distance function for cone\n// input t --> cone specs where:\n//  t.x = cone radius\n//  t.y = cone height\n// \n// think of the cone as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone height from that \nfloat sdCone(vec3 p, vec2 t)\n{\n    p.xz = normalize(p.xz);\n    float d = length(p.xz) - t.x;\n    d = abs(d) - t.y;\n    return d;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n//  t.x = sphere radius\n// \n// think of the sphere as a circle with a flat top and bottom\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere circumference/core/radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat sdSphere(vec3 p, vec2 t)\n{\n    p.xz = normalize(p.xz", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> center x\n//        ps.z --> center y\n//        ps.w --> center z\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> center x\n//        ps.z --> center y\n//        ps.w --> center z\nfloat sdCylinder(vec3 p)\n{\n    vec3 q = p - vec3(ps.y, ps.z, ps.w);\n    return length(q) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> center x\n//        ps.z --> center y\n//        ps.w --> center z\nfloat sdCone(vec3 p)\n{\n    vec3 q = p - vec3(ps.y, ps.z, ps.w);\n    return length(q) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> center x\n//        ps.z --> center y\n//        ps.w --> center z\nfloat sdTorus(vec3 p)\n{\n    vec3 q = p - vec3(ps.y, ps.z, ps.w);\n    return length(vec2(length(q) - ps.x, q.y)) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for ellipsoid\n//  input ps --> specs of ellipsoid\n//        ps.x --> radius x\n//        ps.y --> radius y\n//        ps.z --> radius z\n//        ps.w --> center x\n//        ps.v --> center y\n//        ps.u --> center z\nfloat sdEllipsoid(vec3 p)\n{\n    vec3 q = p - vec", "\n\tfloat a = clamp( (d1/(d1+d2)), 0.0, 1.0 );\n\tfloat b = clamp( (d2/(d1+d2)), 0.0, 1.0 );\n\treturn b*b*b*(a*a*a*(10+k*k)-10);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float a, float b)\n{\n\tfloat a1 = clamp( (d1/(d1+d2)), a, b );\n\tfloat b1 = clamp( (d2/(d1+d2)), a, b );\n\treturn b1*b1*b1*(a1*a1*a1*(10+k*k)-10);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float a, float b, float c)\n{\n\tfloat a1 = clamp( (d1/(d1+d2)), a, b );\n\tfloat b1 = clamp( (d2/(d1+d2)), a, b );\n\treturn b1*b1*b1*(a1*a1*a1*(10+k*k)-10) + c;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d", "\n\tvec4 o1_dist = o1.xyz;\n\tvec4 o2_dist = o2.xyz;\n\tvec4 o1_color = o1.wzyx;\n\tvec4 o2_color = o2.wzyx;\n\n\tvec4 o1_dist_blend = mix(o1_dist, o2_dist, bf);\n\tvec4 o1_color_blend = mix(o1_color, o2_color, bf);\n\n\treturn vec4(o1_dist_blend, o1_color_blend);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2)\n{\n\tvec4 o1_dist = o1.xyz;\n\tvec4 o2_dist = o2.xyz;\n\tvec4 o1_color = o1.wzyx;\n\tvec4 o2_color = o2.wzyx;\n\n\tvec4 o1_dist_blend = mix(o1_dist, o2_dist, bf);\n\tvec4 o1_color_blend = mix(o1_color, o2_color, bf2);\n\n\treturn vec4(o1_dist_blend, o1_color_blend);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2, float bf3)\n{\n\tvec4 o1_dist = o1.xyz;\n\tvec4 o2_dist =", "\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2,float d3)\n{\n\treturn d1-d2-d3;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2,float d3,float d4)\n{\n\treturn d1-d2-d3-d4;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2,float d3,float d4,float d5)\n{\n\treturn d1-d2-d3-d4-d5;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2,float d3,float d4,float d5,float d6)\n{\n\treturn d1-d2-d3-d4-d5-d6;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output -->", "\n\tfloat x = rand() % 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ find the closest object\n\t", "\n    vec4 hit = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float tnear = 0.0;\n    float tfar = 0.0;\n    float tHit = 0.0;\n    float tTemp = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = ", "\n    float softShadow = 0.0;\n    float softShadow_max = 0.0;\n    float softShadow_min = 0.0;\n    float softShadow_step = 0.0;\n    float softShadow_dist = 0.0;\n    float softShadow_dist_max = 0.0;\n    float softShadow_dist_min = 0.0;\n    float softShadow_dist_step = 0.0;\n    float softShadow_dist_step_max = 0.0;\n    float softShadow_dist_step_min = 0.0;\n    float softShadow_dist_step_step = 0.0;\n    float softShadow_dist_step_step_max = 0.0;\n    float softShadow_dist_step_step_min = 0.0;\n    float softShadow_dist_step_step_step = 0.0;\n    float softShadow_dist_step_step_step_max = 0.0;\n    float softShadow_dist_step_step_step_min = 0.0;\n    float softShadow_dist_step_step_step_step = 0.0;\n    float softShadow_dist_step_step_step_step_max = 0.0;\n    float softShadow_dist_step_step_step_step_min = 0.0;\n    float softShadow_dist_step_step_step_step_step = 0.0;\n    float softShadow_dist_step_step_step_step_step_max = 0.0;\n    float softShadow_dist_step_step_step_step_step_min = 0.0;\n    float softShadow_dist_step_step_step_step_step_step = 0.0;\n    float softShadow_dist_step_step_step_step_step_step_max = 0.0;\n    float softShadow_dist_step_step_step_step_step_step_min = 0.0;\n    float softShadow_dist_step_step_step_step_step_step_step = 0.0;\n    float softShadow_dist_step_step_step_step_step_step_step_max = 0.0;\n    float softShadow_dist", "\n    float dist = 0.0;\n    float step = 0.001;\n    float maxDist = 10.0;\n    float maxSteps = 100.0;\n    float stepSize = 0.001;\n    float stepCount = 0.0;\n    float stepDist = 0.0;\n    float hitDist = 0.0;\n    float hitCount = 0.0;\n    float hitCountThresh = 0.0;\n    float hitCountThresh2 = 0.0;\n    float hitCountThresh3 = 0.0;\n    float hitCountThresh4 = 0.0;\n    float hitCountThresh5 = 0.0;\n    float hitCountThresh6 = 0.0;\n    float hitCountThresh7 = 0.0;\n    float hitCountThresh8 = 0.0;\n    float hitCountThresh9 = 0.0;\n    float hitCountThresh10 = 0.0;\n    float hitCountThresh11 = 0.0;\n    float hitCountThresh12 = 0.0;\n    float hitCountThresh13 = 0.0;\n    float hitCountThresh14 = 0.0;\n    float hitCountThresh15 = 0.0;\n    float hitCountThresh16 = 0.0;\n    float hitCountThresh17 = 0.0;\n    float hitCountThresh18 = 0.0;\n    float hitCountThresh19 = 0.0;\n    float hitCountThresh20 = 0.0;\n    float hitCountThresh21 = 0.0;\n    float hitCountThresh22 = 0.0;\n    float hitCountThresh23 = 0.0;\n    float hitCountThresh24 = 0.0;\n    float hitCountThresh25 = 0.0;\n    float hitCountThresh26 = 0.0;\n    float hitCountThresh27 = 0.0;\n    float hitCountThresh28 = 0.0;\n    float hitCountThresh29 = 0.0;\n    float hitCountThresh30 = 0.0;\n    float hitCountThresh3", "\n\tvec3 nor = vec3(0.0, 0.0, 0.0);\n\tvec3 nor2 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor3 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor4 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor5 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor6 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor7 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor8 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor9 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor10 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor11 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor12 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor13 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor14 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor15 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor16 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor17 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor18 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor19 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor20 = vec3(0.0, 0.0, 0.0);\n\tvec3 nor21 = vec3(0.0, 0.0, 0", "\n\treturn vec3(pow(c.r, 1.0/2.2), pow(c.g, 1.0/2.2), pow(c.b, 1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n\treturn vec3(pow(c.r, 1.0/gamma), pow(c.g, 1.0/gamma), pow(c.b, 1.0/gamma));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec4 c)\n{\n\treturn vec4(pow(c.r, 1.0/2.2), pow(c.g, 1.0/2.2), pow(c.b, 1.0/2.2), c.a);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec4 c, float gamma)\n{\n\treturn vec4(pow(c.r, 1.0/gamma), pow(c.g, 1.0/gamma), pow(c.b, 1.0/gamma), c.a);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected", "\n\tfloat f = clamp(fs.x*d,0.0,1.0);\n\tvec3 c1 = mix(fc1,fc2,f);\n\tvec3 c2 = mix(c,c1,pow(1.0-f,fs.y));\n\tvec3 c3 = mix(c2,c1,pow(1.0-f,fs.y));\n\tvec3 c4 = mix(c3,c2,pow(1.0-f,fs.y));\n\tvec3 c5 = mix(c4,c3,pow(1.0-f,fs.y));\n\tvec3 c6 = mix(c5,c4,pow(1.0-f,fs.y));\n\tvec3 c7 = mix(c6,c5,pow(1.0-f,fs.y));\n\tvec3 c8 = mix(c7,c6,pow(1.0-f,fs.y));\n\tvec3 c9 = mix(c8,c7,pow(1.0-f,fs.y));\n\tvec3 c10 = mix(c9,c8,pow(1.0-f,fs.y));\n\tvec3 c11 = mix(c10,c9,pow(1.0-f,fs.y));\n\tvec3 c12 = mix(c11,c10,pow(1.0-f,fs.y));\n\tvec3 c13 = mix(c12,c11,pow(1.0-f,fs.y));\n\tvec3 c14 = mix(c13,c12,pow(1.0-f,fs.y));\n\tvec3 c15 = mix(c14,c13,pow(1.0-f,fs.y));\n\tvec3 c16 = mix(c15,c14,pow(1.0-f,fs.y));\n\tvec3 c17 = mix(c16,c15,pow(1.0-f,fs.y));\n\tvec3 c18 = mix(c17,c16,pow(1.", "\n\treturn cF + lF * d + qF * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float a)\n{\n\treturn cF + lF * d + qF * d * d + a * d * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float a, float b)\n{\n\treturn cF + lF * d + qF * d * d + a * d * d * d + b * d * d * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float a, float b, float c)\n{\n\treturn cF + lF * d + qF * d * d + a * d * d * d + b * d * d * d * d + c * d * d * d * d * d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for", "\n    // ~~~~~~~ generate camera ray direction, different for each frag/pixel\n    // input fCoord --> pixel coordinate\n    // input cMatric --> camera matrix\n    // output --> ray direction\n    vec3 rayDir = vec3(0.0, 0.0, 0.0);\n    rayDir.x = (2.0 * fCoord.x / float(width) - 1.0) * tan(fov / 2.0) * aspect;\n    rayDir.y = (1.0 - 2.0 * fCoord.y / float(height)) * tan(fov / 2.0);\n    rayDir.z = -1.0;\n    rayDir = normalize(cMatrix * rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    // ~~~~~~~ generate camera ray origin, different for each frag/pixel\n    // input fCoord --> pixel coordinate\n    // input cMatric --> camera matrix\n    // output --> ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    rayOrigin.x = (2.0 * fCoord.x / float(width) - 1.0) * tan(fov / 2.0) * aspect;\n    rayOrigin.y = (1.0 - 2.0 * fCoord.y / float(height)) * tan(fov / 2.0);\n    rayOrigin.z = -1.0;\n    rayOrigin = cMatrix * rayOrigin;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, vec3 cPos)\n{\n    // ~~~~~~~ generate camera ray origin, different for each frag/pixel\n    // input fCoord --> pixel coordinate\n    // input cMatric --> camera matrix\n    // output --> ray origin\n    vec3 rayOrigin = vec3(0.0, 0.", "\n    vec3 cRay = vec3(fCoord,0.0);\n    vec3 cRay_n = normalize(cRay);\n    vec3 cRay_p = cMat * cRay_n;\n    vec3 cRay_p_n = normalize(cRay_p);\n    vec3 cRay_p_n_t = cRay_p_n;\n    vec3 cRay_p_n_b = cRay_p_n;\n    vec3 cRay_p_n_l = cRay_p_n;\n    vec3 cRay_p_n_r = cRay_p_n;\n    vec3 cRay_p_n_f = cRay_p_n;\n    vec3 cRay_p_n_b = cRay_p_n;\n    vec3 cRay_p_n_t = cRay_p_n;\n    vec3 cRay_p_n_tl = cRay_p_n;\n    vec3 cRay_p_n_tr = cRay_p_n;\n    vec3 cRay_p_n_bl = cRay_p_n;\n    vec3 cRay_p_n_br = cRay_p_n;\n    vec3 cRay_p_n_tf = cRay_p_n;\n    vec3 cRay_p_n_bf = cRay_p_n;\n    vec3 cRay_p_n_lf = cRay_p_n;\n    vec3 cRay_p_n_rf = cRay_p_n;\n    vec3 cRay_p_n_lt = cRay_p_n;\n    vec3 cRay_p_n_rt = cRay_p_n;\n    vec3 cRay_p_n_lb = cRay_p_n;\n    vec3 cRay_p_n_rb = cRay_p_n;\n    vec3 cRay_p_n_lt = cRay_p_n;\n    vec3 cRay_p_n_rt = cRay_p_n;\n    vec3 cRay_p_n_lb = cRay_p_n;\n    vec3 cRay_p_n_rb = cRay_p_n;\n    vec3 cRay_p_n_lt = c", "\n    // Get the pixel's x and y coordinates\n    float x = ( 2.0 * fragCoord.x / iResolution.x - 1.0 ) * iResolution.x / iResolution.y;\n    float y = ( 1.0 - 2.0 * fragCoord.y / iResolution.y );\n\n    // Set the initial values\n    float x0 = x;\n    float y0 = y;\n    float xTemp = 0.0;\n    float yTemp = 0.0;\n    float iteration = 0.0;\n\n    // Iterate the Mandelbrot Set\n    while( iteration < iTime )\n    {\n        // Calculate the next iteration\n        xTemp = x0 * x0 - y0 * y0 + x;\n        yTemp = 2.0 * x0 * y0 + y;\n        x0 = xTemp;\n        y0 = yTemp;\n\n        // Check if the point has escaped\n        if( x0 * x0 + y0 * y0 > 4.0 )\n        {\n            break;\n        }\n\n        // Increment the iteration count\n        iteration += 1.0;\n    }\n\n    // Calculate the color based on the number of iterations\n    float color = iteration / iTime;\n\n    // Set the color\n    fragColor = vec4( color, color, color, 1.0 );\n}\n\nvoid main()\n{\n    mainImage( gl_FragColor, gl_FragCoord.xy );\n}\n`;\n\nexport default fragmentShader;\n/src/shaders/fragment/mandelbrot.js\nconst fragmentShader = `\n#define iTime 100.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the pixel's x and y coordinates\n    float x = ( 2.0 * fragCoord.x / iResolution.x - 1.0 ) * iResolution.x / iResolution.y;\n    float y = ( 1.0 - 2.0 * fragCoord.y / iResolution.y );\n\n    // Set the initial values\n    float x0 = x;\n    float y0 = y;\n    float xTemp = 0.0;\n    float yTemp = 0.0;\n    float iteration = 0.0;\n\n    // Iterate the Mandelbrot Set\n    while( iteration < iTime", "\n    p = abs(p) - radius;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 axis, float radius)\n{\n    p = abs(p) - radius;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - length(p - axis * radius);\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec3 axis, float radius)\n{\n    p = abs(p) - radius;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - length(p - axis * radius);\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    p.xy -= radius;\n    return length(p) - radius.x;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius)\n{\n    p.xy -= radius;\n    return length(p) - radius.x + length(p.xz) * radius.y;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius, float twist)\n{\n    p.xy -= radius;\n    return length(p) - radius.x + length(p.xz) * radius.y + length(p.xz * cos(p.y * twist)) * radius.y;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius, float twist, float tilt)\n{\n    p.xy -= radius;\n    return length(p) - radius.x + length(p.xz) * radius.y + length(p.xz * cos(p.y * twist)) * radius", "\n\treturn length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// simple torus distance field\nfloat torus(vec2 p, float r1, float r2)\n{\n\tvec2 q = vec2(length(p.xy) - r1, p.z);\n\treturn length(q) - r2;\n}\n\n// simple plane distance field\nfloat plane(vec2 p, vec2 n)\n{\n\treturn dot(p, n);\n}\n\n// simple cone distance field\nfloat cone(vec2 p, float r, float h)\n{\n\tfloat d = length(p.xy);\n\treturn d - r + h;\n}\n\n// simple cylinder distance field\nfloat cylinder(vec2 p, float r, float h)\n{\n\tfloat d = length(p.xy);\n\treturn d - r + h;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r, float h)\n{\n\tfloat d = length(p.xy);\n\treturn d - r + h;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b, float h)\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + h;\n}\n\n// simple torus distance field\nfloat torus(vec2 p, float r1, float r2, float h)\n{\n\tvec2 q = vec2(length(p.xy) - r1, p.z);\n\treturn length(q) - r2 + h;\n}\n\n// simple plane distance field\nfloat plane(vec2 p, vec2 n, float h)\n{", "\n\t// The distance to the nearest surface.\n\tfloat d = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec2 result;\n\tresult.x = pow(c.x, 5);\n\tresult.y = pow(c.y, 5);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 6);\n\tresult.y = pow(c.y, 6);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 7);\n\tresult.y = pow(c.y, 7);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 8);\n\tresult.y = pow(c.y, 8);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 9);\n\tresult.y = pow(c.y, 9);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 10\nvec2 complexPower10(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 10);\n\tresult.y = pow(c.y, 10);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 11\nvec2 complexPower11(vec2 c)\n{\n\tvec2 result;\n\tresult.x = pow(c.x, 11);\n\tresult.y = pow(c.y, 11);\n\treturn result;\n}\n\n//Function that returns a complex number to power of 12\nvec2 complexPower12(vec2 c)\n{\n\tvec2 result;\n\tresult.x =", "\n\tvec2 coord2 = coord * morphConstant;\n\tvec2 coord3 = coord2 * morphConstant;\n\tvec2 coord4 = coord3 * morphConstant;\n\tvec2 coord5 = coord4 * morphConstant;\n\tvec2 coord6 = coord5 * morphConstant;\n\tvec2 coord7 = coord6 * morphConstant;\n\tvec2 coord8 = coord7 * morphConstant;\n\tvec2 coord9 = coord8 * morphConstant;\n\tvec2 coord10 = coord9 * morphConstant;\n\tvec2 coord11 = coord10 * morphConstant;\n\tvec2 coord12 = coord11 * morphConstant;\n\tvec2 coord13 = coord12 * morphConstant;\n\tvec2 coord14 = coord13 * morphConstant;\n\tvec2 coord15 = coord14 * morphConstant;\n\tvec2 coord16 = coord15 * morphConstant;\n\tvec2 coord17 = coord16 * morphConstant;\n\tvec2 coord18 = coord17 * morphConstant;\n\tvec2 coord19 = coord18 * morphConstant;\n\tvec2 coord20 = coord19 * morphConstant;\n\tvec2 coord21 = coord20 * morphConstant;\n\tvec2 coord22 = coord21 * morphConstant;\n\tvec2 coord23 = coord22 * morphConstant;\n\tvec2 coord24 = coord23 * morphConstant;\n\tvec2 coord25 = coord24 * morphConstant;\n\tvec2 coord26 = coord25 * morphConstant;\n\tvec2 coord27 = coord26 * morphConstant;\n\tvec2 coord28 = coord27 * morphConstant;\n\tvec2 coord29 = coord28 * morphConstant;\n\tvec2 coord30 = coord29 * morphConstant;\n\tvec2 coord31 = coord30 * morphConstant;\n\tvec2 coord32 = coord31 * morphConstant;\n\tvec2 coord33 = coord32 * morphConstant;\n\tvec2 coord34 = coord33 * morphConstant;\n\tvec2 coord35 = coord34 * morphConstant;\n\tvec2 coord36 = coord35 * morphConstant;\n\tvec2 coord", "\n\tvec2 offset = vec2(0.0, 0.0);\n\tvec2 offset2 = vec2(0.0, 0.0);\n\tvec2 offset3 = vec2(0.0, 0.0);\n\tvec2 offset4 = vec2(0.0, 0.0);\n\tvec2 offset5 = vec2(0.0, 0.0);\n\tvec2 offset6 = vec2(0.0, 0.0);\n\tvec2 offset7 = vec2(0.0, 0.0);\n\tvec2 offset8 = vec2(0.0, 0.0);\n\tvec2 offset9 = vec2(0.0, 0.0);\n\tvec2 offset10 = vec2(0.0, 0.0);\n\tvec2 offset11 = vec2(0.0, 0.0);\n\tvec2 offset12 = vec2(0.0, 0.0);\n\tvec2 offset13 = vec2(0.0, 0.0);\n\tvec2 offset14 = vec2(0.0, 0.0);\n\tvec2 offset15 = vec2(0.0, 0.0);\n\tvec2 offset16 = vec2(0.0, 0.0);\n\tvec2 offset17 = vec2(0.0, 0.0);\n\tvec2 offset18 = vec2(0.0, 0.0);\n\tvec2 offset19 = vec2(0.0, 0.0);\n\tvec2 offset20 = vec2(0.0, 0.0);\n\tvec2 offset21 = vec2(0.0, 0.0);\n\tvec2 offset22 = vec2(0.0, 0.0);\n\tvec2 offset23 = vec2(0.0, 0.0);\n\tvec2 offset24 = vec2(0.0, 0.0);\n\tvec2 offset25 = vec2(0.0, 0.0);\n\tvec2 offset26 = vec2(0.0, 0.0);\n\t", "\n\treturn x - floor(x);\n}\n\nfloat triangle(float x) {\n\treturn repeat(x + 0.5) - 0.5;\n}\n\n// A triangle wave with a period of 1\nfloat triangle_1(float x) {\n\treturn repeat(x + 0.5) - 0.5;\n}\n\n// A triangle wave with a period of 2\nfloat triangle_2(float x) {\n\treturn repeat(x + 1.0) - 0.5;\n}\n\n// A triangle wave with a period of 3\nfloat triangle_3(float x) {\n\treturn repeat(x + 1.5) - 0.5;\n}\n\n// A triangle wave with a period of 4\nfloat triangle_4(float x) {\n\treturn repeat(x + 2.0) - 0.5;\n}\n\n// A triangle wave with a period of 5\nfloat triangle_5(float x) {\n\treturn repeat(x + 2.5) - 0.5;\n}\n\n// A triangle wave with a period of 6\nfloat triangle_6(float x) {\n\treturn repeat(x + 3.0) - 0.5;\n}\n\n// A triangle wave with a period of 7\nfloat triangle_7(float x) {\n\treturn repeat(x + 3.5) - 0.5;\n}\n\n// A triangle wave with a period of 8\nfloat triangle_8(float x) {\n\treturn repeat(x + 4.0) - 0.5;\n}\n\n// A triangle wave with a period of 9\nfloat triangle_9(float x) {\n\treturn repeat(x + 4.5) - 0.5;\n}\n\n// A triangle wave with a period of 10\nfloat triangle_10(float x) {\n\treturn repeat(x + 5.0) - 0.5;\n}\n\n// A triangle wave with a period of 11\nfloat triangle_11(float x) {\n\treturn repeat(x + 5.5) - 0.5;\n}\n\n// A triangle wave", "\n\tvec2 d = pB - pA;\n\tvec2 u = normalize(d);\n\tvec2 v = vec2(u.y, -u.x);\n\tvec2 p = uv - pA;\n\tfloat dist = dot(p, u);\n\tfloat dist2 = dot(p, v);\n\tfloat dist3 = length(p);\n\tfloat dist4 = abs(dist2);\n\tfloat dist5 = dist3 - dist4;\n\tfloat dist6 = dist5 * dist5;\n\tfloat dist7 = dist6 * dist6;\n\tfloat dist8 = dist7 * dist7;\n\tfloat dist9 = dist8 * dist8;\n\tfloat dist10 = dist9 * dist9;\n\tfloat dist11 = dist10 * dist10;\n\tfloat dist12 = dist11 * dist11;\n\tfloat dist13 = dist12 * dist12;\n\tfloat dist14 = dist13 * dist13;\n\tfloat dist15 = dist14 * dist14;\n\tfloat dist16 = dist15 * dist15;\n\tfloat dist17 = dist16 * dist16;\n\tfloat dist18 = dist17 * dist17;\n\tfloat dist19 = dist18 * dist18;\n\tfloat dist20 = dist19 * dist19;\n\tfloat dist21 = dist20 * dist20;\n\tfloat dist22 = dist21 * dist21;\n\tfloat dist23 = dist22 * dist22;\n\tfloat dist24 = dist23 * dist23;\n\tfloat dist25 = dist24 * dist24;\n\tfloat dist26 = dist25 * dist25;\n\tfloat dist27 = dist26 * dist26;\n\tfloat dist28 = dist27 * dist27;\n\tfloat dist29 = dist28 * dist28;\n\tfloat dist30 = dist29 * dist29;\n\tfloat dist31 = dist30 * dist30;\n\tfloat dist32 = dist31 * dist31;\n\tfloat dist33 = dist32 * dist32", "\n\tvec2 p = uv * (pB - pA) + pA;\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tvec2 n = normalize(d);\n\tvec2 t = vec2(n.y, -n.x);\n\tvec2 p1 = p - t * thick.x;\n\tvec2 p2 = p + t * thick.x;\n\tvec2 p3 = p1 + t * thick.y;\n\tvec2 p4 = p2 + t * thick.y;\n\tvec2 p5 = p3 + t * thick.x;\n\tvec2 p6 = p4 + t * thick.x;\n\tvec2 p7 = p5 + t * thick.y;\n\tvec2 p8 = p6 + t * thick.y;\n\tfloat r = 0.0;\n\tif (rounded > 0.0) {\n\t\tr = rounded * 0.5;\n\t\tp1 = p1 + t * r;\n\t\tp2 = p2 + t * r;\n\t\tp3 = p3 + t * r;\n\t\tp4 = p4 + t * r;\n\t\tp5 = p5 + t * r;\n\t\tp6 = p6 + t * r;\n\t\tp7 = p7 + t * r;\n\t\tp8 = p8 + t * r;\n\t}\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tif (len > 0.0) {\n\t\ta = dot(p1, n);\n\t\tb = dot(p2, n);\n\t\tc = dot(p3, n);\n\t\td = dot(p4, n);\n\t\te = dot(p5, n);\n\t\tf = dot(p6, n);\n\t\tg = dot(p7, n);\n\t\th = dot(p8,", "\n\tfloat d = distance(pA, pB);\n\tfloat t = clamp(d / thick, 0.0, 1.0);\n\tfloat r = clamp(d / outlineThick, 0.0, 1.0);\n\tfloat a = smoothstep(0.0, 1.0, t);\n\tfloat b = smoothstep(0.0, 1.0, r);\n\tfloat c = smoothstep(0.0, 1.0, rounded);\n\treturn a * b * c;\n}\n\n// This makes an outlined line in world units. A 1.0 thick outline will be 1 world unit thick.\nfloat DrawOutlineWorld(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n\tvec2 pA_world = uvToWorld(uv, pA);\n\tvec2 pB_world = uvToWorld(uv, pB);\n\treturn DrawOutlinePix(uv, pA_world, pB_world, thick, rounded, outlineThick);\n}\n\n// This makes an outlined line in world units. A 1.0 thick outline will be 1 world unit thick.\nfloat DrawOutlineWorld(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n\treturn DrawOutlineWorld(uv, pA, pB, thick, rounded, 1.0);\n}\n\n// This makes an outlined line in world units. A 1.0 thick outline will be 1 world unit thick.\nfloat DrawOutlineWorld(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\treturn DrawOutlineWorld(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes an outlined line in world units. A 1.0 thick outline will be 1 world unit thick.\nfloat DrawOutlineWorld(vec2 uv, vec2 pA, vec2 pB, float thick) {\n\treturn DrawOutlineWorld(uv, pA, pB, vec2(thick, thick), 1.0);\n}\n\n// This", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tvec2 dir = d / len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = pA + dir * uv.x * len;\n\tvec2 p1 = p + perp * thick.x;\n\tvec2 p2 = p - perp * thick.x;\n\tvec2 p3 = p1 + perp * thick.y;\n\tvec2 p4 = p2 + perp * thick.y;\n\tvec2 p5 = p1 - perp * thick.y;\n\tvec2 p6 = p2 - perp * thick.y;\n\tfloat r = rounded;\n\tfloat r2 = r * r;\n\tfloat r3 = r2 * r;\n\tfloat r4 = r3 * r;\n\tfloat r5 = r4 * r;\n\tfloat r6 = r5 * r;\n\tfloat r7 = r6 * r;\n\tfloat r8 = r7 * r;\n\tfloat r9 = r8 * r;\n\tfloat r10 = r9 * r;\n\tfloat r11 = r10 * r;\n\tfloat r12 = r11 * r;\n\tfloat r13 = r12 * r;\n\tfloat r14 = r13 * r;\n\tfloat r15 = r14 * r;\n\tfloat r16 = r15 * r;\n\tfloat r17 = r16 * r;\n\tfloat r18 = r17 * r;\n\tfloat r19 = r18 * r;\n\tfloat r20 = r19 * r;\n\tfloat r21 = r20 * r;\n\tfloat r22 = r21 * r;\n\tfloat r23 = r22 * r;\n\tfloat r24 = r23 * r;\n\tfloat r25 = r24 * r;\n\tfloat r26 = r25 * r;\n\tfloat r27 = r26 * r;\n\tfloat r28 = r27 * r;", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir /= len;\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tfloat perpLen = len * thick.x;\n\tfloat perpLen2 = perpLen * 0.5;\n\tfloat perpLen3 = perpLen * 0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tvec2 n = normalize(d);\n\tvec2 p = pA + n * len * 0.5;\n\tvec2 p1 = p + n * len * 0.5;\n\tvec2 p2 = p - n * len * 0.5;\n\tvec2 p3 = p1 + n * len * 0.5;\n\tvec2 p4 = p2 - n * len * 0.5;\n\tvec2 p5 = p1 - n * len * 0.5;\n\tvec2 p6 = p2 + n * len * 0.5;\n\tvec2 p7 = p3 - n * len * 0.5;\n\tvec2 p8 = p4 + n * len * 0.5;\n\tvec2 p9 = p3 + n * len * 0.5;\n\tvec2 p10 = p4 - n * len * 0.5;\n\tvec2 p11 = p5 + n * len * 0.5;\n\tvec2 p12 = p6 - n * len * 0.5;\n\tvec2 p13 = p5 - n * len * 0.5;\n\tvec2 p14 = p6 + n * len * 0.5;\n\tvec2 p15 = p7 - n * len * 0.5;\n\tvec2 p16 = p8 + n * len * 0.5;\n\tvec2 p17 = p7 + n * len * 0.5;\n\tvec2 p18 = p8 - n * len * 0.5;\n\tvec2 p19 = p9 + n * len * 0.5;\n\tvec2 p20 = p10 - n * len * 0.5;\n\tvec2 p21 = p9 - n * len * 0.5;\n\tvec2 p22 = p10 + n * len * 0.5;\n\tvec2 p23 = p11 - n * len * 0.5;\n\tvec2 p24 = p12", "\n\tfloat d = 0.0001;\n\tfloat r = 0.0001;\n\tfloat g = 0.0001;\n\tfloat b = 0.0001;\n\tfloat a = 0.0001;\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n\tfloat z = p.z;\n\tfloat w = 1.0;\n\tfloat x1 = x - d;\n\tfloat y1 = y - d;\n\tfloat z1 = z - d;\n\tfloat w1 = 1.0;\n\tfloat x2 = x + d;\n\tfloat y2 = y + d;\n\tfloat z2 = z + d;\n\tfloat w2 = 1.0;\n\tfloat x3 = x - r;\n\tfloat y3 = y - r;\n\tfloat z3 = z - r;\n\tfloat w3 = 1.0;\n\tfloat x4 = x + r;\n\tfloat y4 = y + r;\n\tfloat z4 = z + r;\n\tfloat w4 = 1.0;\n\tfloat x5 = x - g;\n\tfloat y5 = y - g;\n\tfloat z5 = z - g;\n\tfloat w5 = 1.0;\n\tfloat x6 = x + g;\n\tfloat y6 = y + g;\n\tfloat z6 = z + g;\n\tfloat w6 = 1.0;\n\tfloat x7 = x - b;\n\tfloat y7 = y - b;\n\tfloat z7 = z - b;\n\tfloat w7 = 1.0;\n\tfloat x8 = x + b;\n\tfloat y8 = y + b;\n\tfloat z8 = z + b;\n\tfloat w8 = 1.0;\n\tfloat x9 = x - a;\n\tfloat y9 = y - a;\n\tfloat z9 = z - a;\n\tfloat w9 = 1.0;\n\tfloat x10 = x + a;\n\tfloat y10 = y + a;\n\tfloat z10 = z + a;\n\tfloat w10 = ", "\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - rad*rad;\n    float d = b*b - 4.0*a*c;\n    if (d < 0.0) return -1.0;\n    return (-b - sqrt(d)) / (2.0*a);\n}\n\n// ray-triangle intersection\nfloat iTri( in vec3 ro, in vec3 rd,               // ray: origin, direction\n           in vec3 v0, in vec3 v1, in vec3 v2 )    // triangle: vertices\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det < 1e-6) return -1.0;\n    vec3 s = ro - v0;\n    float u = dot(s, p) / det;\n    if (u < 0.0 || u > 1.0) return -1.0;\n    vec3 q = cross(s, e1);\n    float v = dot(rd, q) / det;\n    if (v < 0.0 || u + v > 1.0) return -1.0;\n    return dot(e2, q) / det;\n}\n\n// ray-triangle intersection\nfloat iTri( in vec3 ro, in vec3 rd,               // ray: origin, direction\n           in vec3 v0, in vec3 v1, in vec3 v2,     // triangle: vertices\n           out vec3 n )                            // triangle: normal\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det < 1e-6) return -1.0;\n    vec3 s = ro - v0;\n    float u = dot(s, p) / det;\n    if (u < 0.0 || u > 1.0) return -1.0;\n    vec3 q =", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen - ro + 2.0 * rad) / rd;\n\tvec3 t = min(tmin, tmax);\n\treturn max(t.x, max(t.y, t.z));\n}\n\n// ray-triangle intersection (simplified)\nvec2 iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross(rd, e2);\n\tfloat det = dot(e1, p);\n\tif (det > -0.00001 && det < 0.00001) return vec2(100000.0, 100000.0);\n\tfloat invDet = 1.0 / det;\n\tvec3 s = ro - v0;\n\tfloat u = dot(s, p) * invDet;\n\tif (u < 0.0 || u > 1.0) return vec2(100000.0, 100000.0);\n\tvec3 q = cross(s, e1);\n\tfloat v = dot(rd, q) * invDet;\n\tif (v < 0.0 || u + v > 1.0) return vec2(100000.0, 100000.0);\n\tfloat t = dot(e2, q) * invDet;\n\treturn vec2(t, 0.0);\n}\n\n// ray-sphere intersection (simplified)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\tvec3 oc = ro - cen;\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(rd, oc);\n\tfloat c = dot(oc, oc) - rad * rad;\n\tfloat d = b * b - a * c;\n\tif (d <", "\n\tvec3 d = pb - pa;\n\tfloat h = length(d) * 0.5;\n\tvec3 c = pa + d * 0.5;\n\tvec3 u = normalize(d);\n\tvec3 v = cross(u, vec3(0,1,0));\n\tvec3 w = cross(u, v);\n\tfloat r = ra;\n\treturn bound3(c - r * u - r * v, c + r * u + r * v);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 pa, in float ra )\n{\n\tvec3 c = pa;\n\tfloat r = ra;\n\treturn bound3(c - r, c + r);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 pa, in vec3 pb )\n{\n\tvec3 d = pb - pa;\n\treturn bound3(pa, pa + d);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tvec3 d = pb - pa;\n\tfloat h = length(d) * 0.5;\n\tvec3 c = pa + d * 0.5;\n\tvec3 u = normalize(d);\n\tvec3 v = cross(u, vec3(0,1,0));\n\tvec3 w = cross(u, v);\n\tfloat r = ra;\n\treturn bound3(c - r * u - r * v, c + r * u + r * v);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb", "\n    vec3 oc = ro - pa;\n    vec3 oc2 = oc * oc;\n    vec3 oc2_rd = oc2 - rd * rd;\n    float d = dot(oc, rd);\n    float d2 = d * d;\n    float r2 = ra * ra;\n    float a = d2 - oc2_rd;\n    float b = 2 * d * d2 - 2 * d * oc2_rd;\n    float c = d2 * oc2_rd - r2 * oc2;\n    float t = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n    vec3 n = (oc + t * rd) - pa;\n    n = normalize(n);\n    return vec4(t, n);\n}\n\n// ray-triangle intersection (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in vec3 pc )\n{\n    vec3 e1 = pb - pa;\n    vec3 e2 = pc - pa;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det > -0.00001 && det < 0.00001) return vec4(0, vec3(0, 0, 0));\n    float inv_det = 1 / det;\n    vec3 t = ro - pa;\n    float u = dot(t, p) * inv_det;\n    if (u < 0 || u > 1) return vec4(0, vec3(0, 0, 0));\n    vec3 q = cross(t, e1);\n    float v = dot(rd, q) * inv_det;\n    if (v < 0 || u + v > 1) return vec4(0, vec3(0, 0, 0));\n    float t_ = dot(e2, q) * inv_det;\n    return vec4(t_, normalize(cross(e1, e2)));\n}\n\n// ray-triangle intersection (returns t and normal)\nvec4 iTriangle2( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in vec3 pc )\n", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen - ro + 2.0 * rad) / rd;\n\tvec3 t = min(tmin, tmax);\n\treturn max(t.x, t.y);\n}\n\n// ray-triangle intersection\nvec2 iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross(rd, e2);\n\tfloat det = dot(e1, p);\n\tif (det > -0.00001 && det < 0.00001) return vec2(100000.0, 100000.0);\n\tfloat invDet = 1.0 / det;\n\tvec3 t = ro - v0;\n\tfloat u = dot(t, p) * invDet;\n\tif (u < 0.0 || u > 1.0) return vec2(100000.0, 100000.0);\n\tvec3 q = cross(t, e1);\n\tfloat v = dot(rd, q) * invDet;\n\tif (v < 0.0 || u + v > 1.0) return vec2(100000.0, 100000.0);\n\tfloat t_ = dot(e2, q) * invDet;\n\treturn vec2(t_, 1.0);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\tvec3 oc = ro - cen;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, oc);\n\tfloat c = dot(oc, oc) - rad * rad;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.", "\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - r*r;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return -1.0;\n\treturn b - sqrt(h);\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 p, in float r )\n{\n\tvec3 m = p - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - r*r;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return -1.0;\n\treturn b - sqrt(h);\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triangleIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc )\n{\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - 1.0;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return -1.0;\n\treturn b - sqrt(h);\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triangleIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in vec3 pc, in vec3 pn )\n{\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - 1.0;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return -1.0;\n\treturn b - sqrt(h);\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors", "\n\tvec3 n = normalize( cross( a, b ) );\n\treturn normalize( n + pos * r );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h )\n{\n\tvec3 n = normalize( cross( a, b ) );\n\treturn normalize( n + pos * r + vec3( 0.0, h, 0.0 ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float d )\n{\n\tvec3 n = normalize( cross( a, b ) );\n\treturn normalize( n + pos * r + vec3( 0.0, h, 0.0 ) + vec3( 0.0, 0.0, d ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float d, in float s )\n{\n\tvec3 n = normalize( cross( a, b ) );\n\treturn normalize( n + pos * r + vec3( 0.0, h, 0.0 ) + vec3( 0.0, 0.0, d ) + vec3( s, 0.0, 0.0 ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float d, in float s, in float t )\n{\n\tvec3 n = normalize( cross( a, b ) );\n\treturn normalize( n + pos * r + vec3( 0.0, h, 0.0 ) + vec3( 0.0, 0.0, d ) + vec3( s, 0.0, 0.0 ) + vec3( 0.0, t, 0.0 ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float d, in float s, in float", "\n\tvec2 t = vec2( -1.0, 1.0 );\n\tfor( int i = 0; i < 3; i++ ) \n\t{\n\t\tfloat t0 = ( rad[i] - ro[i] ) / rd[i];\n\t\tfloat t1 = ( rad[i] + ro[i] ) / rd[i];\n\t\tt = min( t, vec2( t0, t1 ) );\n\t}\n\treturn t;\n}\n\n// ray-box intersection in world space\nvec2 iBoxWS( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\tvec2 t = vec2( -1.0, 1.0 );\n\tfor( int i = 0; i < 3; i++ ) \n\t{\n\t\tfloat t0 = ( rad[i] - ro[i] ) / rd[i];\n\t\tfloat t1 = ( rad[i] + ro[i] ) / rd[i];\n\t\tt = min( t, vec2( t0, t1 ) );\n\t}\n\treturn t;\n}\n\n// ray-triangle intersection\nvec2 iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross( rd, e2 );\n\tfloat det = dot( e1, p );\n\tif( det > -0.00001 && det < 0.00001 ) return vec2( -1.0, -1.0 );\n\tfloat invDet = 1.0 / det;\n\tvec3 s = ro - v0;\n\tfloat u = dot( s, p ) * invDet;\n\tif( u < 0.0 || u > 1.0 ) return vec2( -1.0, -1.0 );\n\tvec3 q = cross( s, e1 );\n\tfloat v = dot( rd, q ) * invDet;\n\tif( v < 0.0 || u + v > 1.0", "\n\tvec3 p = ro;\n\tvec3 d = rd;\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0", "\n    float phi = 2.0 * PI * i / n;\n    float r = sqrt(i);\n    return vec3(r * cos(phi), r * sin(phi), 0.0);\n}\n\n// 2D spherical fibonacci mapping\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec2 forwardSF2D( float i, float n) \n{\n    float phi = 2.0 * PI * i / n;\n    float r = sqrt(i);\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\n// 3D spherical fibonacci mapping\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF3D( float i, float n) \n{\n    float phi = 2.0 * PI * i / n;\n    float r = sqrt(i);\n    return vec3(r * cos(phi), r * sin(phi), i / n);\n}\n\n// 2D spherical fibonacci mapping\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec2 forwardSF2D( float i, float n, float scale) \n{\n    float phi = 2.0 * PI * i / n;\n    float r = sqrt(i) * scale;\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\n// 3D spherical fibonacci mapping\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF3D( float i, float n, float scale) \n{\n    float phi = 2.0 * PI * i / n;\n    float r = sqrt(i) * scale;\n    return vec3", "\n\tvec3 res = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 0.0;\n\tfloat tnear = 0.0;\n\tfloat tfar = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.", "\n\tvec3 d = vec3( 0.0 );\n\tvec3 p3 = vec3( p );\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tvec3 g = vec3( 0.0 );\n\t\tg.x = permute( permute( permute( permute( vec4( p3.x + float( i ), p3.y + float( i ), p3.z + float( i ), p3.w + float( i ) ) ) ) + vec4( i ) ) ) + 0.0;\n\t\tg.yz = permute( permute( vec4( p3.x + g.x, p3.y + g.y, p3.z + g.z, p3.w + g.w ) ) ) + 1.0;\n\t\td += g * ( 1.0 / 7.0 );\n\t\tp3 += vec3( 1.0 / 7.0 );\n\t}\n\treturn d;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n\tvec3 d = vec3( 0.0 );\n\tvec3 p3 = vec3( p );\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tvec3 g = vec3( 0.0 );\n\t\tg.x = permute( permute( permute( permute( vec4( p3.x + float( i ), p3.y + float( i ), p3.z + float( i ), p3.w + float( i ) ) ) ) + vec4( i ) ) ) + 0.0;\n\t\tg.yz = permute( permute( vec4( p3.x + g.x, p3.y + g.y, p3.z + g.z, p3.w + g.w ) ) ) + 1.0;\n\t\td += g * ( 1.0 / 7.0 );\n\t\tp3 += vec3( 1.0 / 7.0 );\n\t}\n\treturn d;\n}\n\n//", "\n\tvec2 d = abs(p) - size;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat smoothMerge(float a, float b, float radius)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.0, radius, d));\n}\n\nfloat smoothMerge(float a, float b, float radius, float strength)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.0, radius, d)) * (1.0 - strength);\n}\n\nfloat smoothMerge(float a, float b, float radius, float strength, float bias)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.0, radius, d)) * (1.0 - strength) + bias;\n}\n\nfloat smoothMerge(float a, float b, float radius, float strength, float bias, float biasStrength)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.0, radius, d)) * (1.0 - strength) + bias * (1.0 - biasStrength);\n}\n\nfloat smoothMerge(float a, float b, float radius, float strength, float bias, float biasStrength, float biasBias)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.0, radius, d)) * (1.0 - strength) + bias * (1.0 - biasStrength) + biasBias;\n}\n\nfloat smoothMerge(float a, float b, float radius, float strength, float bias, float biasStrength, float biasBias, float biasBiasStrength)\n{\n\tfloat d = boxDist(a - b, vec2(1.0), radius);\n\treturn mix(a, b, smoothstep(0.", "\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0 + orient.y);\n\treturn p;\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0 + orient.y);\n\treturn p;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0 + orient.y);\n\treturn p;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0 + orient.y);\n\treturn p;\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0 + orient.y);\n\treturn p;\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0, 0.0);\n\tp.x = sin(uv.x * 10.0 + orient.x);\n\tp.y = sin(uv.y * 10.0", "\n\tvec2 p = vec2(0.0);\n\tp.x = sin(uv.x * 2.0 * 3.1415926535897932384626433832795 * orient.x);\n\tp.y = sin(uv.y * 2.0 * 3.1415926535897932384626433832795 * orient.y);\n\treturn p;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0);\n\tp.x = sin(uv.x * 2.0 * 3.1415926535897932384626433832795 * orient.x);\n\tp.y = sin(uv.y * 2.0 * 3.1415926535897932384626433832795 * orient.y);\n\treturn p;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0);\n\tp.x = sin(uv.x * 2.0 * 3.1415926535897932384626433832795 * orient.x);\n\tp.y = sin(uv.y * 2.0 * 3.1415926535897932384626433832795 * orient.y);\n\treturn p;\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n\tvec2 p = vec2(0.0);\n\tp.x = sin(uv.x * 2.0 * 3.14159265358979323", "\n\tfloat dx = ddx.x;\n\tfloat dy = ddy.y;\n\tfloat dx2 = ddx.y;\n\tfloat dy2 = ddy.x;\n\tfloat dx3 = ddx.x * ddx.x;\n\tfloat dy3 = ddy.y * ddy.y;\n\tfloat dx4 = ddx.y * ddx.y;\n\tfloat dy4 = ddy.x * ddy.x;\n\tfloat dx5 = ddx.x * ddx.y;\n\tfloat dy5 = ddy.x * ddy.y;\n\tfloat dx6 = ddx.x * ddx.x * ddx.x;\n\tfloat dy6 = ddy.y * ddy.y * ddy.y;\n\tfloat dx7 = ddx.y * ddx.y * ddx.y;\n\tfloat dy7 = ddy.x * ddy.x * ddy.x;\n\tfloat dx8 = ddx.x * ddx.x * ddx.y;\n\tfloat dy8 = ddy.x * ddy.x * ddy.y;\n\tfloat dx9 = ddx.x * ddx.y * ddx.y;\n\tfloat dy9 = ddy.x * ddy.y * ddy.y;\n\tfloat dx10 = ddx.x * ddx.x * ddx.y * ddx.y;\n\tfloat dy10 = ddy.x * ddy.x * ddy.y * ddy.y;\n\tfloat dx11 = ddx.x * ddx.x * ddx.y * ddx.y * ddx.y;\n\tfloat dy11 = ddy.x * ddy.x * ddy.y * ddy.y * ddy.y;\n\tfloat dx12 = ddx.x * ddx.x * ddx.y * ddx.y * ddx.y * ddx.y;\n\tfloat dy12 = ddy.x * ddy.x * ddy.y * ddy.y * ddy.y * ddy.y;\n\tfloat dx13 = ddx.x * ddx", "\n\tvec3 d = vec3( 0.0 );\n\td.x = 2.0 * ( p.x * p.x - p.y * p.y - p.z * p.z );\n\td.y = 2.0 * ( p.y * p.y - p.x * p.x - p.z * p.z );\n\td.z = 2.0 * ( p.z * p.z - p.x * p.x - p.y * p.y );\n\treturn d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 d )\n{\n\tvec3 d2 = vec3( 0.0 );\n\td2.x = 2.0 * ( p.x * d.x - p.y * d.y - p.z * d.z );\n\td2.y = 2.0 * ( p.y * d.x - p.x * d.y - p.z * d.z );\n\td2.z = 2.0 * ( p.z * d.x - p.x * d.y - p.y * d.z );\n\treturn d2;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 d, in vec3 d2 )\n{\n\tvec3 d3 = vec3( 0.0 );\n\td3.x = 2.0 * ( p.x * d2.x - p.y * d2.y - p.z * d2.z - p.x * d.x - p.y * d.y - p.z * d.z );\n\td3.y = 2.0 * ( p.y * d2.x - p.x * d2.y - p.z * d2.z - p.x * d.x - p.y * d.y - p.z * d.z );\n\td3.z = 2.0 * ( p.z * d2.x - p.x * d2.y - p.y * d", "\n\tv33 c;\n\tc.x=a.y;\n\tc.y=b.x;\n\tc.z=a.z;\n\ta=c;\n\tc.x=b.y;\n\tc.y=a.x;\n\tc.z=b.z;\n\tb=c;\n}\n\n//this is the function that actually does the ray-triangle intersection test\n//it returns 1 if the ray intersects the triangle, 0 if not\nint rayTriIntersect(v33 ray,v33 tri[3],v33 &hit){\n\t//first, we need to find the plane of the triangle\n\tv33 plane;\n\tplane.x=tri[0].x-tri[1].x;\n\tplane.y=tri[0].y-tri[1].y;\n\tplane.z=tri[0].z-tri[1].z;\n\t//now we need to find the intersection of the ray with the plane\n\tv33 rayPlane;\n\trayPlane.x=ray.x-tri[0].x;\n\trayPlane.y=ray.y-tri[0].y;\n\trayPlane.z=ray.z-tri[0].z;\n\t//now we need to find the dot product of the plane and the ray\n\tfloat dot=plane.x*rayPlane.x+plane.y*rayPlane.y+plane.z*rayPlane.z;\n\t//if the dot product is 0, then the ray is parallel to the plane, so it can't intersect\n\tif(dot==0)return 0;\n\t//now we need to find the intersection of the ray with the triangle\n\tv33 rayTri;\n\trayTri.x=ray.x-tri[0].x;\n\trayTri.y=ray.y-tri[0].y;\n\trayTri.z=ray.z-tri[0].z;\n\t//now we need to find the dot product of the plane and the ray\n\tdot=plane.x*rayTri.x+plane.y*rayTri.y+plane.z*rayTri.z;\n\t//if the dot product is 0, then the ray", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,vec3 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,vec3 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//dot product\nfloat dot(v33 a,v33 b){\n\treturn a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\n//cross product\nv33 cross(v33 a,v33 b){\n\treturn v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\n//normalize a vector\nv33 norm(v33 a){\n\tfloat mag = sqrt(dot(a,a));\n\treturn v33(a.x/mag,a.y/mag,a.z/mag);\n}\n\n//normalize a vector\nv33 norm(v33 a,v33 b){\n\tfloat mag = sqrt(dot(a,a));\n\treturn v33(a.x/mag,a.y/mag,a.z/mag);\n}\n\n//normalize a vector\nv33 norm(v33 a,v33 b,v33 c){\n\tfloat mag = sqrt(dot(a,a));\n\treturn v33(a.x/mag,a.y/mag,a.z/mag);\n}\n\n//normalize a vector\nv33 norm(v33 a,v33 b,v33 c,v33 d){\n\tfloat mag = sqrt(dot(a,a));\n\treturn v33(a.x/mag,a.y/mag,a.z/mag);\n}\n\n//normalize a vector\nv33 norm(v33 a,v33 b,v33 c,v33 d,v33 e){\n\tfloat mag = sqrt(dot(a,a));\n\treturn v33(a.x/mag,a.y/mag,a.z/mag);\n}\n\n//normalize a vector\nv33 norm(v33 a,v", "\n\treturn v2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec3 dt(v33 a,v33 b){\n\treturn v3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//v33-differentials for AA\nvec4 dt(v33 a,v33 b){\n\treturn v4(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w);\n}\n\n//v33-differentials for AA\nvec5 dt(v33 a,v33 b){\n\treturn v5(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w,a.v-b.v);\n}\n\n//v33-differentials for AA\nvec6 dt(v33 a,v33 b){\n\treturn v6(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w,a.v-b.v,a.u-b.u);\n}\n\n//v33-differentials for AA\nvec7 dt(v33 a,v33 b){\n\treturn v7(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w,a.v-b.v,a.u-b.u,a.t-b.t);\n}\n\n//v33-differentials for AA\nvec8 dt(v33 a,v33 b){\n\treturn v8(a.x-b.x,a.y-b.y,a.z-b.z,a.w-b.w,a.v-b.v,a.u-b.u,a.t-b.t,a.s-b.s);\n}\n\n//v33-differentials for AA\nvec9 dt(v33 a", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec3 dt(v33 a,vec2 b){\n\treturn vec3(dot(a.x,b),dot(a.y,b),dot(a.z,b));\n}\n\n//dual dotprodiuct on v33s\nvec3 dt(v33 a,vec3 b){\n\treturn vec3(dot(a.x,b),dot(a.y,b),dot(a.z,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec4 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec2 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec3 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec2 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec3 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),dot(a.w,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec4 b){\n\treturn vec4(dot(", "\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c){\n\treturn v33(a.x*b.x*c.x,a.y*b.x*c.x,a.z*b.x*c.x,a.x*b.y*c.x,a.y*b.y*c.x,a.z*b.y*c.x,a.x*b.z*c.x,a.y*b.z*c.x,a.z*b.z*c.x,a.x*b.x*c.y,a.y*b.x*c.y,a.z*b.x*c.y,a.x*b.y*c.y,a.y*b.y*c.y,a.z*b.y*c.y,a.x*b.z*c.y,a.y*b.z*c.y,a.z*b.z*c.y,a.x*b.x*c.z,a.y*b.x*c.z,a.z*b.x*c.z,a.x*b.y*c.z,a.y*b.y*c.z,a.z*b.y*c.z,a.x*b.z*", "\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF5(vec3 p,vec3 w){\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF6(vec3 p,vec3 w){\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF7(vec3 p,vec3 w){\n\tfloat d=dot(p,w);\n\treturn (d<0.0)?0.0:1.0;\n}\n\n//noe to self,maybe replace i", "\n\tvec3 q=p/w;\n\tfloat x=q.x,y=q.y,z=q.z;\n\tfloat x0=floor(x),y0=floor(y),z0=floor(z);\n\tfloat x1=x0+1,y1=y0+1,z1=z0+1;\n\tfloat x2=x0+2,y2=y0+2,z2=z0+2;\n\tfloat x3=x0+3,y3=y0+3,z3=z0+3;\n\tfloat x4=x0+4,y4=y0+4,z4=z0+4;\n\tfloat x5=x0+5,y5=y0+5,z5=z0+5;\n\tfloat x6=x0+6,y6=y0+6,z6=z0+6;\n\tfloat x7=x0+7,y7=y0+7,z7=z0+7;\n\tfloat x8=x0+8,y8=y0+8,z8=z0+8;\n\tfloat x9=x0+9,y9=y0+9,z9=z0+9;\n\tfloat x10=x0+10,y10=y0+10,z10=z0+10;\n\tfloat x11=x0+11,y11=y0+11,z11=z0+11;\n\tfloat x12=x0+12,y12=y0+12,z12=z0+12;\n\tfloat x13=x0+13,y13=y0+13,z13=z0+13;\n\tfloat x14=x0+14,y14=y0+14,z14=z0+14;\n\tfloat x15=x0+15,y15=y0+15,z15=z0+15;\n\tfloat x16=x0+16,y16", "\n\tfloat d=length(r.xyz);\n\tfloat t=dot(r.xyz,s.xyz);\n\tfloat t2=t*t;\n\tfloat b=t2-d*d;\n\tfloat c=s.w*s.w-b;\n\tif(c<0)return 0;\n\tfloat d2=sqrt(c);\n\tfloat t1=t-d2;\n\tfloat t3=t+d2;\n\tif(t1<0)t1=t3;\n\tif(t1<0)return 0;\n\treturn 1-(t1/d);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat d=length(r.xyz);\n\tfloat t=dot(r.xyz,s.xyz);\n\tfloat t2=t*t;\n\tfloat b=t2-d*d;\n\tfloat c=s.w*s.w-b;\n\tif(c<0)return 0;\n\tfloat d2=sqrt(c);\n\tfloat t1=t-d2;\n\tfloat t3=t+d2;\n\tif(t1<0)t1=t3;\n\tif(t1<0)return 0;\n\treturn 1-(t1/d);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat d=length(r.xyz);\n\tfloat t=dot(r.xyz,s.xyz);\n\tfloat t2=t*t;\n\tfloat b=t2-d*d;\n\tfloat c=s.w*s.w-b;\n\tif(c<0)return 0;\n\tfloat d2=sqrt(c);\n\tfloat t1=t-d2;\n\tfloat t3=t+d2;\n\tif(t1<0)t1=t3;\n\tif(t1<0)return 0;\n\treturn 1-(t1/d);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp", "\n\tvec3 p = u - s.xyz;\n\tfloat d = dot(p,n);\n\treturn d < s.w;\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 s){\n\tvec3 p = abs(u) - s.xyz;\n\tfloat d = max(max(p.x,p.y),p.z);\n\treturn d < 0.0;\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//ellipsoid occlusion\nfloat occEllipsoid(vec3 u,vec3 n,vec4 s){\n\tvec3 p = abs(u) - s.xyz;\n\tfloat d = max(max(p.x,p.y),p.z);\n\treturn d < 0.0;\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//capsule occlusion\nfloat occCapsule(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//mesh occlusion\nfloat occMesh(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n) - s.w;\n\treturn d < 0.0;\n}\n\n//ray occlusion\nfloat occRay(vec3 u,vec3 n,vec", "\n\tvec2 d0 = p1 - p0;\n\tvec2 d1 = p2 - p1;\n\tvec2 d2 = p0 - 2.0 * p1 + p2;\n\tvec2 d3 = p0 - p1;\n\tvec2 d4 = p1 - p2;\n\tvec2 d5 = p2 - p0;\n\tvec2 d6 = p0;\n\tvec2 d7 = p1;\n\tvec2 d8 = p2;\n\tvec2 d9 = p0 - p2;\n\tvec2 d10 = p1 - p0;\n\tvec2 d11 = p2 - p1;\n\tvec2 d12 = p0 - 2.0 * p1 + 2.0 * p2;\n\tvec2 d13 = p0 - p1;\n\tvec2 d14 = p1 - p2;\n\tvec2 d15 = p2 - p0;\n\tvec2 d16 = p0;\n\tvec2 d17 = p1;\n\tvec2 d18 = p2;\n\tvec2 d19 = p0 - p2;\n\tvec2 d20 = p1 - p0;\n\tvec2 d21 = p2 - p1;\n\tvec2 d22 = p0 - 2.0 * p1 + 2.0 * p2;\n\tvec2 d23 = p0 - p1;\n\tvec2 d24 = p1 - p2;\n\tvec2 d25 = p2 - p0;\n\tvec2 d26 = p0;\n\tvec2 d27 = p1;\n\tvec2 d28 = p2;\n\tvec2 d29 = p0 - p2;\n\tvec2 d30 = p1 - p0;\n\tvec2 d31 = p2 - p1;\n\tvec2 d32 = p0 - 2.0 * p1 + 2.0 * p2;\n\tvec2 d33 = p0 - p1;\n\tvec2 d34 = p1 - p2;\n\tvec2 d35 = p2 - p", "\n\tvec2 d0 = p1 - p0;\n\tvec2 d1 = p2 - p1;\n\tvec2 d2 = p0 - 2.0 * p1 + p2;\n\tvec2 d3 = p0 - p1;\n\tvec2 d4 = p1 - p2;\n\tvec2 d5 = p2 - p0;\n\tvec2 d6 = p0 - p2;\n\tvec2 d7 = p0 - p1;\n\tvec2 d8 = p1 - p0;\n\tvec2 d9 = p2 - p1;\n\tvec2 d10 = p0 - p1;\n\tvec2 d11 = p1 - p0;\n\tvec2 d12 = p2 - p1;\n\tvec2 d13 = p0 - p1;\n\tvec2 d14 = p1 - p0;\n\tvec2 d15 = p2 - p1;\n\tvec2 d16 = p0 - p1;\n\tvec2 d17 = p1 - p0;\n\tvec2 d18 = p2 - p1;\n\tvec2 d19 = p0 - p1;\n\tvec2 d20 = p1 - p0;\n\tvec2 d21 = p2 - p1;\n\tvec2 d22 = p0 - p1;\n\tvec2 d23 = p1 - p0;\n\tvec2 d24 = p2 - p1;\n\tvec2 d25 = p0 - p1;\n\tvec2 d26 = p1 - p0;\n\tvec2 d27 = p2 - p1;\n\tvec2 d28 = p0 - p1;\n\tvec2 d29 = p1 - p0;\n\tvec2 d30 = p2 - p1;\n\tvec2 d31 = p0 - p1;\n\tvec2 d32 = p1 - p0;\n\tvec2 d33 = p2 - p1;\n\tvec2 d34 = p0 - p1;\n\tvec2 d35 = p1 - p0;\n\tvec2 d36 = p2", "\n\tvec3 q0 = p0;\n\tvec3 q1 = p1;\n\tvec3 q2 = p2;\n\tvec3 q3 = p3;\n\n\tvec3 d = q1 - q0;\n\tvec3 r = q2 - q1;\n\tvec3 s = q3 - q2;\n\n\tvec3 e = d + r;\n\tvec3 f = r + s;\n\n\tvec3 g = e + f;\n\n\tvec3 h = (g * 0.25) + (d * 0.125) + (r * 0.125) + (s * 0.125);\n\n\tvec3 i = (g * 0.0625) + (d * 0.03125) + (r * 0.03125) + (s * 0.03125);\n\n\tvec3 j = (g * 0.015625) + (d * 0.0078125) + (r * 0.0078125) + (s * 0.0078125);\n\n\tvec3 k = (g * 0.00390625) + (d * 0.001953125) + (r * 0.001953125) + (s * 0.001953125);\n\n\tvec3 l = (g * 0.0009765625) + (d * 0.00048828125) + (r * 0.00048828125) + (s * 0.00048828125);\n\n\tvec3 m = (g * 0.000244140625) + (d * 0.0001220703125) + (r * 0.0001220703125) + (s * 0.000122070312", "\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\treturn vec4(p0123, 0.0, 1.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\treturn vec4(p0123, 0.0, 1.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p34 = mix(p3, p4, 0.5);\n\t", "\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(a, b, pos.y);\n    vec2 e = mix(b, c, pos.y);\n    return mix(d, e, pos.z);\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, in vec2 p4, vec2 pos)\n{\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(p3, p4, pos.x);\n    vec2 e = mix(a, b, pos.y);\n    vec2 f = mix(b, c, pos.y);\n    vec2 g = mix(c, d, pos.y);\n    return mix(e, f, pos.z);\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, in vec2 p4, in vec2 p5, vec2 pos)\n{\n    vec2 a = mix(p0, p1, pos.x);\n    vec2 b = mix(p1, p2, pos.x);\n    vec2 c = mix(p2, p3, pos.x);\n    vec2 d = mix(p3, p4, pos.x);\n    vec2 e = mix(p4, p5, pos.x);\n    vec2 f = mix(a, b, pos.y);\n    vec2 g = mix(b, c, pos.y);\n    vec2 h = mix(c, d, pos.y);\n    vec2 i = mix(d, e, pos.y);\n    return mix(f, g, pos.z", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det == 0.0)\n        return vec3(0.0);\n    vec3 s = ro - v0;\n    float u = dot(s, p);\n    if (u < 0.0 || u > det)\n        return vec3(0.0);\n    vec3 q = cross(s, e1);\n    float v = dot(rd, q);\n    if (v < 0.0 || u + v > det)\n        return vec3(0.0);\n    float t = dot(e2, q);\n    return vec3(t, u, v);\n}\n\n// Ray-sphere intersection. Returns { t, u, v }\nvec3 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 c, float r )\n{\n    vec3 oc = ro - c;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r * r;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return vec3(0.0);\n    float t = (-b - sqrt(d)) / (2.0 * a);\n    return vec3(t, 0.0, 0.0);\n}\n\n// Ray-plane intersection. Returns { t, u, v }\nvec3 planeIntersect( in vec3 ro, in vec3 rd, in vec3 n, in vec3 p )\n{\n    float t = dot(n, p - ro) / dot(n, rd);\n    if (t < 0.0)\n        return vec3(0.0);\n    return vec3(t, 0.0, 0.0);\n}\n\n// Ray-cylinder intersection. Returns { t, u, v }\nvec3 cylinderIntersect( in vec3 ro, in vec3 rd, in vec3 c, float r, float h )\n{\n    vec3 oc = ro - c;\n    float a = dot(rd, rd);", "\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 s = cross( nor, e0 );\n\tfloat d = dot( s, e1 );\n\tif( d == 0.0 )\n\t\treturn 0.0;\n\tvec3 p = pos - v0;\n\tfloat u = dot( s, p ) / d;\n\tif( u < 0.0 || u > 1.0 )\n\t\treturn 0.0;\n\tvec3 q = cross( p, e0 );\n\tfloat v = dot( nor, q ) / d;\n\tif( v < 0.0 || u + v > 1.0 )\n\t\treturn 0.0;\n\treturn 1.0;\n}\n\n// Triangle occlusion (if partially visible)\nfloat triOcclusionPart( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec3 s = cross( nor, e0 );\n\tfloat d = dot( s, e1 );\n\tif( d == 0.0 )\n\t\treturn 0.0;\n\tvec3 p = pos - v0;\n\tfloat u = dot( s, p ) / d;\n\tif( u < 0.0 || u > 1.0 )\n\t\treturn 0.0;\n\tvec3 q = cross( p, e0 );\n\tfloat v = dot( nor, q ) / d;\n\tif( v < 0.0 || u + v > 1.0 )\n\t\treturn 0.0;\n\treturn 1.0 - (u + v - 1.0);\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n\tvec3 e0 = v1 - v0;\n\tvec3 e1 = v2 - v0;\n\tvec", "\n\treturn length(pos - bezier(A, B, C));\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C )\n{\n\treturn length(pos - bezier(A, B, C));\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in vec3 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in vec3 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec4 pos, in vec4 A, in vec4 B, in vec4 C )\n{\n\treturn length(pos - bezier(A, B, C));\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec4 pos, in vec4 A, in vec4 B, in vec4 C, in vec4 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec4 pos, in vec4 A, in vec4 B, in vec4 C, in vec4 D )\n{\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a", "\n\tfloat h = abs(p.y);\n\tif( h > he ) return 0.0;\n\tfloat r = mix( r1, r2, h / he );\n\treturn length(p) - r;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n\tfloat h = abs(p.x);\n\tif( h > he ) return 0.0;\n\tfloat r = mix( r1, r2, h / he );\n\treturn length(p) - r;\n}\n\n// trapezoid / capped cone, specialized for Z alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n\tfloat h = abs(p.z);\n\tif( h > he ) return 0.0;\n\tfloat r = mix( r1, r2, h / he );\n\treturn length(p) - r;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he )\n{\n\tfloat h = abs(p.y);\n\tif( h > he ) return 0.0;\n\tfloat r = mix( r1, r2, h / he );\n\treturn length(p) - r;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he )\n{\n\tfloat h = abs(p.x);\n\tif( h > he ) return 0.0;\n\tfloat r = mix( r1, r2, h / he );\n\treturn length(p) - r;\n}\n\n// trapezoid / capped cone, specialized for Z alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he )\n{\n\tfloat h = abs(p.z);\n\tif( h > he ) return 0", "\n\tvec2 ap = p - a;\n\tvec2 bp = p - b;\n\tfloat apn = length(ap);\n\tfloat bpn = length(bp);\n\tfloat apn2 = apn * apn;\n\tfloat bpn2 = bpn * bpn;\n\tfloat apn2r = apn2 / ra;\n\tfloat bpn2r = bpn2 / rb;\n\tfloat apn2r2 = apn2r * apn2r;\n\tfloat bpn2r2 = bpn2r * bpn2r;\n\tfloat apn2r2r = apn2r2 / ra;\n\tfloat bpn2r2r = bpn2r2 / rb;\n\tfloat apn2r2r2 = apn2r2r * apn2r2r;\n\tfloat bpn2r2r2 = bpn2r2r * bpn2r2r;\n\tfloat apn2r2r2r = apn2r2r2 / ra;\n\tfloat bpn2r2r2r = bpn2r2r2 / rb;\n\tfloat apn2r2r2r2 = apn2r2r2r / ra;\n\tfloat bpn2r2r2r2 = bpn2r2r2r / rb;\n\tfloat apn2r2r2r2r = apn2r2r2r2 / ra;\n\tfloat bpn2r2r2r2r = bpn2r2r2r2 / rb;\n\tfloat apn2r2r2r2r2 = apn2r2r2r2 / ra;\n\tfloat bpn2r2r2r2r2 = bpn2r2r2r2 / rb;\n\tfloat apn2r2r2r2r2r = apn2r2r2r2 / ra;\n\tfloat bpn2r2r2r2r2r = bpn2r2r2r2 / rb;\n\tfloat apn2r2r2r2r2r2 = apn2r2r2r2 / ra;\n\tfloat bpn2r2r2r", "\n\tvec3 p = pos;\n\tvec3 f = vec3(0.001, 0.0, 0.0);\n\tvec3 n = vec3(0.0, 0.0, 0.0);\n\tn.x = sdBox(p + f, vec3(1.0, 0.0, 0.0));\n\tn.y = sdBox(p + f, vec3(0.0, 1.0, 0.0));\n\tn.z = sdBox(p + f, vec3(0.0, 0.0, 1.0));\n\treturn normalize(n);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nfloat sdBox( in vec3 p, in vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nfloat sdSphere( in vec3 p, in float s )\n{\n\treturn length(p) - s;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nfloat sdPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot(p,n) - d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nfloat sdCylinder( in vec3 p, in vec3 c, in float r )\n{\n\tvec3 h = abs(p) - c;\n\treturn length(h) - r;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nfloat sdTorus( in vec3 p, in vec3 t, in float r0, in float r1 )\n{\n\tvec2 q = vec2(length(p.xz)-r0,p.y", "\n\tfloat t = tmin;\n\tfloat t0 = tmin;\n\tfloat t1 = tmax;\n\tfloat t2 = tmax;\n\tfloat t3 = tmax;\n\tfloat t4 = tmax;\n\tfloat t5 = tmax;\n\tfloat t6 = tmax;\n\tfloat t7 = tmax;\n\tfloat t8 = tmax;\n\tfloat t9 = tmax;\n\tfloat t10 = tmax;\n\tfloat t11 = tmax;\n\tfloat t12 = tmax;\n\tfloat t13 = tmax;\n\tfloat t14 = tmax;\n\tfloat t15 = tmax;\n\tfloat t16 = tmax;\n\tfloat t17 = tmax;\n\tfloat t18 = tmax;\n\tfloat t19 = tmax;\n\tfloat t20 = tmax;\n\tfloat t21 = tmax;\n\tfloat t22 = tmax;\n\tfloat t23 = tmax;\n\tfloat t24 = tmax;\n\tfloat t25 = tmax;\n\tfloat t26 = tmax;\n\tfloat t27 = tmax;\n\tfloat t28 = tmax;\n\tfloat t29 = tmax;\n\tfloat t30 = tmax;\n\tfloat t31 = tmax;\n\tfloat t32 = tmax;\n\tfloat t33 = tmax;\n\tfloat t34 = tmax;\n\tfloat t35 = tmax;\n\tfloat t36 = tmax;\n\tfloat t37 = tmax;\n\tfloat t38 = tmax;\n\tfloat t39 = tmax;\n\tfloat t40 = tmax;\n\tfloat t41 = tmax;\n\tfloat t42 = tmax;\n\tfloat t43 = tmax;\n\tfloat t44 = tmax;\n\tfloat t45 = tmax;\n\tfloat t46 = tmax;\n\tfloat t47 = tmax;\n\tfloat t48 = tmax;\n\tfloat t49 = tmax;\n\tfloat t50 = tmax;\n\tfloat t", "\n\treturn dot(q, ivec2(127773, 261401));\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 v )\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec2 i  = floor(v + dot(v, C.yyy) );\n\tvec2 x0 = v -   i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec2 i1;\n\ti1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec4 x12 = x0.xyxy + C.xxww;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( i.y + vec4(0.0, i1.y, 1.0, 1.0 ))\n\t\t+ i.x + vec4(0.0, 0.0, i1.x, 1.0 ));\n\n\tvec4 m = max(0.5 - vec4(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\tm = m*m ;\n\tm = m*m ;\n\n\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n\tvec4 i3 =  i * C.zzww;\n\tvec4 x_ = 2.0 * fract(x0) - 1.0;\n\tvec4 y_ = 2.0 * fract(x12) - 1.", "\n\treturn fract(sin(dot(x,vec2(p)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p )\n{\n\treturn fract(sin(dot(x,vec3(p)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec4 x, in int p )\n{\n\treturn fract(sin(dot(x,vec4(p)))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p, in float f )\n{\n\treturn fract(sin(dot(x,vec2(p)))*f);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p, in float f )\n{\n\treturn fract(sin(dot(x,vec3(p)))*f);\n}\n\n// basic value noise\nfloat noise( in vec4 x, in int p, in float f )\n{\n\treturn fract(sin(dot(x,vec4(p)))*f);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p, in vec2 f )\n{\n\treturn fract(sin(dot(x,f))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p, in vec3 f )\n{\n\treturn fract(sin(dot(x,f))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec4 x, in int p, in vec4 f )\n{\n\treturn fract(sin(dot(x,f))*43758.5453);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p, in float f, in float g )\n{\n\treturn fract(sin(dot(x,vec2(p)))*f*g);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p, in float f, in", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x );\n\t\tsum += a;\n\t\ta *= b;\n\t}\n\treturn f / sum;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float lacunarity, in float gain )\n{\n\tfloat f = 0.0;\n\tfloat a = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x );\n\t\tsum += a;\n\t\ta *= lacunarity;\n\t\tamp *= gain;\n\t}\n\treturn f / sum;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float lacunarity, in float gain, in float offset )\n{\n\tfloat f = 0.0;\n\tfloat a = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x + offset );\n\t\tsum += a;\n\t\ta *= lacunarity;\n\t\tamp *= gain;\n\t}\n\treturn f / sum;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p, in float lacunarity, in float gain, in float offset, in float scale )\n{\n\tfloat f = 0.0;\n\tfloat a = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tfor( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x + offset * scale );\n\t\tsum += a;\n\t\ta *= lacunarity;\n\t\tamp", "\n\treturn length(p) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float a ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float a, in float b ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d, in float e ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/4dS3zD\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d, in float e, in float f ) \n{\n\treturn length(p - c) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy", "\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) );\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r, in vec2 s ) \n{\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) ) - s.x;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r, in vec2 s, in vec2 t ) \n{\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) ) - s.x - t.x;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r, in vec2 s, in vec2 t, in vec2 u ) \n{\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) ) - s.x - t.x - u.x;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r, in vec2 s, in vec2 t, in vec2 u, in vec2 v ) \n{\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) ) - s.x - t.x - u.x - v.x;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r, in vec2 s, in vec2 t, in vec2 u, in vec2 v, in vec2 w ) \n{\n\treturn length( vec2( length( p.xz ) - r.x, p.y - r.y ) ) - s.x - t.x - u.x - v.x - w.x;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec", "\n\treturn length(p) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a, in float b ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d, in float e ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d, in float e, in float f ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float a, in float b, in float d, in float e, in float f, in float g ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - simple but bad approximated distance\n", "\n\treturn length(p) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u, in vec3 v ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u, in vec3 v, in vec3 w ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u, in vec3 v, in vec3 w, in vec3 x ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u, in vec3 v, in vec3 w, in vec3 x, in vec3 y ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in vec3 u, in vec3 v, in vec3 w, in vec3 x, in vec3 y, in vec3 z ) \n{\n\treturn length(p-c) - r.x;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3", "\n\tvec2 uv = p * 0.5 + 0.5;\n\tvec2 uv2 = floor( uv * 16.0 );\n\tvec2 uv3 = fract( uv * 16.0 );\n\tvec2 uv4 = fract( uv2 * 16.0 );\n\tvec2 uv5 = fract( uv3 * 16.0 );\n\tvec2 uv6 = fract( uv4 * 16.0 );\n\tvec2 uv7 = fract( uv5 * 16.0 );\n\tvec2 uv8 = fract( uv6 * 16.0 );\n\tvec2 uv9 = fract( uv7 * 16.0 );\n\tvec2 uv10 = fract( uv8 * 16.0 );\n\tvec2 uv11 = fract( uv9 * 16.0 );\n\tvec2 uv12 = fract( uv10 * 16.0 );\n\tvec2 uv13 = fract( uv11 * 16.0 );\n\tvec2 uv14 = fract( uv12 * 16.0 );\n\tvec2 uv15 = fract( uv13 * 16.0 );\n\tvec2 uv16 = fract( uv14 * 16.0 );\n\tvec2 uv17 = fract( uv15 * 16.0 );\n\tvec2 uv18 = fract( uv16 * 16.0 );\n\tvec2 uv19 = fract( uv17 * 16.0 );\n\tvec2 uv20 = fract( uv18 * 16.0 );\n\tvec2 uv21 = fract( uv19 * 16.0 );\n\tvec2 uv22 = fract( uv20 * 16.0 );\n\tvec2 uv23 = fract( uv21 * 16.0 );\n\tvec2 uv24 = fract( uv22 * 16.0 );\n\tvec2 uv25 = fract( uv23 * 16.0 );\n\tvec2 uv26 = fract(", "\n\tfloat b = 1.0f - a;\n\tfloat c = 1.0f - b;\n\tfloat d = 1.0f - c;\n\tfloat e = 1.0f - d;\n\tfloat f = 1.0f - e;\n\tfloat g = 1.0f - f;\n\tfloat h = 1.0f - g;\n\tfloat i = 1.0f - h;\n\tfloat j = 1.0f - i;\n\tfloat k = 1.0f - j;\n\tfloat l = 1.0f - k;\n\tfloat m = 1.0f - l;\n\tfloat n = 1.0f - m;\n\tfloat o = 1.0f - n;\n\tfloat p = 1.0f - o;\n\tfloat q = 1.0f - p;\n\tfloat r = 1.0f - q;\n\tfloat s = 1.0f - r;\n\tfloat t = 1.0f - s;\n\tfloat u = 1.0f - t;\n\tfloat v = 1.0f - u;\n\tfloat w = 1.0f - v;\n\tfloat x1 = x * x;\n\tfloat x2 = x1 * x;\n\tfloat x3 = x2 * x;\n\tfloat x4 = x3 * x;\n\tfloat x5 = x4 * x;\n\tfloat x6 = x5 * x;\n\tfloat x7 = x6 * x;\n\tfloat x8 = x7 * x;\n\tfloat x9 = x8 * x;\n\tfloat x10 = x9 * x;\n\tfloat x11 = x10 * x;\n\tfloat x12 = x11 * x;\n\tfloat x13 = x12 * x;\n\tfloat x14 = x13 * x;\n\tfloat x15 = x14 * x;\n\tfloat x16 = x15 * x;\n\tfloat x17 = x16 * x;\n\tfloat x18 = x17 * x;\n\tfloat x19 = x18 * x", "\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased pulse\nfloat my_pul( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased noise\nfloat my_noi( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran2( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran3( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran4( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran5( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran6( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran7( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran8( float x, float p )\n{\n\treturn (x - p) / (1.0f - p);\n}\n\n// biased random\nfloat my_ran9( float x, float", "\n\tvec3 c = vec3( 0.0 );\n\tc.r = 0.5 + 0.5 * cos( 0.5 * h * 3.1415926535897932384626433832795 );\n\tc.g = 0.5 + 0.5 * cos( 0.5 * h * 3.1415926535897932384626433832795 + 0.5 * 3.1415926535897932384626433832795 );\n\tc.b = 0.5 + 0.5 * cos( 0.5 * h * 3.1415926535897932384626433832795 + 0.5 * 2.0 * 3.1415926535897932384626433832795 );\n\treturn c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_2( float h )\n{\n\tvec3 c = vec3( 0.0 );\n\tc.r = 0.5 + 0.5 * cos( 0.5 * h * 3.1415926535897932384626433832795 );\n\tc.g = 0.5 + 0.5 * cos( 0.5 * h * 3.1415926535897932384626433832795 + 0.5 * 3.1415926535897932384626433832795 );\n\tc.b = 0.5 + ", "\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - r*r;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return -1.0;\n\th = sqrt(h);\n\tfloat t0 = b - h;\n\tfloat t1 = b + h;\n\tif(t0 > t1) swap(t0, t1);\n\tif(t0 < 0.0) t0 = t1;\n\tif(t0 < 0.0) return -1.0;\n\treturn t0;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - r*r;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return -1.0;\n\th = sqrt(h);\n\tfloat t0 = b - h;\n\tfloat t1 = b + h;\n\tif(t0 > t1) swap(t0, t1);\n\tif(t0 < 0.0) t0 = t1;\n\tif(t0 < 0.0) return -1.0;\n\treturn t0;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n\tvec3 m = pa - ro;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - r*r;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return -1.0;\n\th = sqrt(h);\n\tfloat t0 = b - h;\n\tfloat", "\n\tvec3 ap = p - a;\n\tvec3 ab = b - a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n\tvec3 hp = a + h * ab;\n\tvec3 apn = normalize(ap);\n\tvec3 abn = normalize(ab);\n\tvec3 hpn = normalize(hp - a);\n\tfloat r = ra * ra - rb * rb;\n\tfloat d = dot(apn, hpn);\n\treturn sqrt(r * r + d * d);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 ap = p - a;\n\tvec3 ab = b - a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n\tvec3 hp = a + h * ab;\n\tvec3 apn = normalize(ap);\n\tvec3 abn = normalize(ab);\n\tvec3 hpn = normalize(hp - a);\n\tfloat d = dot(apn, hpn);\n\treturn sqrt(r * r + d * d);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n\tvec3 ap = p - a;\n\tvec3 ab = b - a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n\tvec3 hp = a + h * ab;\n\tvec3 apn = normalize(ap);\n\tvec3 abn = normalize(ab);\n\tvec3 hpn = normalize(hp - a);\n\tfloat r = ra * ra - rb * rb;\n\tfloat d = dot(apn, hpn);\n\treturn sqrt(r * r + d * d);\n}\n\n// http://iquilezles.org/www", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0", "\n    float r = rad1 + th * sin(uv.y * 2.0 * PI);\n    float a = atan(uv.x, uv.y);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\nvec2 snake_uv(vec2 p, float rad1, float rad2, float th)\n{\n    float r = rad1 + th * sin(p.y * 2.0 * PI);\n    float a = atan(p.x, p.y);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\nvec2 snake_uv_inv(vec2 p, float rad1, float rad2, float th)\n{\n    float r = rad1 + th * sin(p.y * 2.0 * PI);\n    float a = atan(p.x, p.y);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\nvec2 snake_uv_inv_2(vec2 p, float rad1, float rad2, float th)\n{\n    float r = rad1 + th * sin(p.y * 2.0 * PI);\n    float a = atan(p.x, p.y);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\nvec2 snake_uv_inv_3(vec2 p, float rad1, float rad2, float th)\n{\n    float r = rad1 + th * sin(p.y * 2.0 * PI);\n    float a = atan(p.x, p.y);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec2(x, y);\n}\n\nvec2 snake_uv_inv_4(vec2 p, float rad1, float rad2, float th)\n{\n    float r = rad1 + th * sin(p.y * 2.0 * PI);\n    float a = atan(p.x, p.y);\n    float", "\n\treturn r - length(p - c);\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length(p - c) - r;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p - c) - r;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec4 p, in vec4 c, in float r )\n{\n\treturn length(p - c) - r;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec2 p, in vec2 c, in vec2 r )\n{\n\treturn length(p - c) - r.x;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec3 p, in vec3 c, in vec3 r )\n{\n\treturn length(p - c) - r.x;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec4 p, in vec4 c, in vec4 r )\n{\n\treturn length(p - c) - r.x;\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a )\n{\n\treturn length(p - c) - r * cos(a);\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec3 p, in vec3 c, in float r, in float a )\n{\n\treturn length(p - c) - r * cos(a);\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec4 p, in vec4 c, in float r, in float a )\n{\n\treturn length(p - c) - r * cos(a);\n}\n\n// c is the center. r is the radius.\nfloat sdCircle( in vec2 p, in vec2 c, in vec2 r, in", "\n\tvec3 n = vec3( 4.0 * pos.x, 4.0 * pos.y, 4.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra )\n{\n\tvec3 n = vec3( 4.0 * pos.x, 4.0 * pos.y, 4.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2 )\n{\n\tvec3 n = vec3( 4.0 * pos.x, 4.0 * pos.y, 4.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2, in float ra3 )\n{\n\tvec3 n = vec3( 4.0 * pos.x, 4.0 * pos.y, 4.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in float ra2, in float ra3, in float ra4 )\n{\n\tvec3 n = vec3( 4.0 * pos.x, 4.0 * pos.y, 4.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4", "\n\tfloat a = atan( p.y, p.x );\n\tfloat b = atan( sca.y, sca.x );\n\tfloat c = atan( scb.y, scb.x );\n\tfloat d = ra * ra - rb * rb;\n\tfloat e = ra * ra + rb * rb;\n\tfloat f = ( a - b ) * ( a - b ) - ( c - d ) * ( c - d );\n\tfloat g = ( a - b ) * ( a - b ) - ( c - e ) * ( c - e );\n\tfloat h = ( a - b ) * ( a - b ) - ( c + d ) * ( c + d );\n\tfloat i = ( a - b ) * ( a - b ) - ( c + e ) * ( c + e );\n\tfloat j = ( a - b ) * ( a - b ) - ( c - d ) * ( c - d );\n\tfloat k = ( a - b ) * ( a - b ) - ( c - e ) * ( c - e );\n\tfloat l = ( a - b ) * ( a - b ) - ( c + d ) * ( c + d );\n\tfloat m = ( a - b ) * ( a - b ) - ( c + e ) * ( c + e );\n\tfloat n = ( a - b ) * ( a - b ) - ( c - d ) * ( c - d );\n\tfloat o = ( a - b ) * ( a - b ) - ( c - e ) * ( c - e );\n\tfloat p = ( a - b ) * ( a - b ) - ( c + d ) * ( c + d );\n\tfloat q = ( a - b ) * ( a - b ) - ( c + e ) * ( c + e );\n\tfloat r = ( a - b ) * ( a - b ) - ( c - d ) * ( c - d );\n\tfloat s = ( a - b ) * ( a - b ) - ( c - e ) * ( c - e );\n\tfloat t = ( a - b ) * ( a - b ) - ( c + d ) * ( c + d );\n\tfloat u = ( a - b ) * ( a - b ) - ( c", "\n\tfloat t = mint;\n\tfloat t0 = mint - 0.0001;\n\tfloat t1 = tmax + 0.0001;\n\tfor( int i = 0; i < 16; i++ )\n\t{\n\t\tfloat t2 = 0.5 * ( t0 + t1 );\n\t\tvec3 p = ro + t2 * rd;\n\t\tfloat d = length( p );\n\t\tif( d < 1.0 )\n\t\t{\n\t\t\tfloat n = 1.0 - d * d;\n\t\t\tif( n > 0.0 )\n\t\t\t{\n\t\t\t\tfloat a = sqrt( n );\n\t\t\t\tfloat phi = acos( ( d - 1.0 ) / a );\n\t\t\t\tfloat theta = phi * 0.5;\n\t\t\t\tfloat r = sin( theta ) / a;\n\t\t\t\tfloat g = cos( theta );\n\t\t\t\tfloat b = 1.0 - r - g;\n\t\t\t\treturn r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r *", "\n\tvec3 p = pos;\n\tvec3 n = normalize( p );\n\tvec3 t = vec3( 0.0, 0.0, 1.0 );\n\tvec3 b = vec3( 0.0, 1.0, 0.0 );\n\tvec3 c = vec3( 1.0, 0.0, 0.0 );\n\tvec3 d = vec3( 0.0, 0.0, 0.0 );\n\tvec3 e = vec3( 0.0, 0.0, 0.0 );\n\tvec3 f = vec3( 0.0, 0.0, 0.0 );\n\tvec3 g = vec3( 0.0, 0.0, 0.0 );\n\tvec3 h = vec3( 0.0, 0.0, 0.0 );\n\tvec3 i = vec3( 0.0, 0.0, 0.0 );\n\tvec3 j = vec3( 0.0, 0.0, 0.0 );\n\tvec3 k = vec3( 0.0, 0.0, 0.0 );\n\tvec3 l = vec3( 0.0, 0.0, 0.0 );\n\tvec3 m = vec3( 0.0, 0.0, 0.0 );\n\tvec3 n = vec3( 0.0, 0.0, 0.0 );\n\tvec3 o = vec3( 0.0, 0.0, 0.0 );\n\tvec3 p = vec3( 0.0, 0.0, 0.0 );\n\tvec3 q = vec3( 0.0, 0.0, 0.0 );\n\tvec3 r = vec3( 0.0, 0.0, 0.0 );\n\tvec3 s = vec3( 0.0, 0.0, 0.0 );\n\tvec3 t = vec3( 0.0, 0.0, 0.0 );\n\tvec3 u = vec3( 0.0,", "\n\tfloat t = mint;\n\tfloat t0 = mint - 0.0001;\n\tfloat t1 = tmax + 0.0001;\n\tfloat alpha = 0.001;\n\tfloat bias = 0.0001;\n\tfloat d = 0.0;\n\tfloat n = 0.0;\n\tfloat k = 0.0;\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat", "\n\tvec2 d = abs(dpdx) + abs(dpdy);\n\treturn 0.5 + 0.5 * sin(d.x * 10.0 + p.x * 0.1) * sin(d.y * 10.0 + p.y * 0.1);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale )\n{\n\tvec2 d = abs(dpdx) + abs(dpdy);\n\treturn 0.5 + 0.5 * sin(d.x * scale + p.x * 0.1) * sin(d.y * scale + p.y * 0.1);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale, in float bias )\n{\n\tvec2 d = abs(dpdx) + abs(dpdy);\n\treturn 0.5 + 0.5 * sin(d.x * scale + p.x * 0.1) * sin(d.y * scale + p.y * 0.1) + bias;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale, in float bias, in float power )\n{\n\tvec2 d = abs(dpdx) + abs(dpdy);\n\treturn 0.5 + 0.5 * pow(sin(d.x * scale + p.x * 0.1) * sin(d.y * scale + p.y * 0.1) + bias, power);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale,", "\n\treturn x*k;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase_inverse( in float x, in float k )\n{\n\treturn x/k;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase_inverse_2( in float x, in float k )\n{\n\treturn x/k;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase_inverse_3( in float x, in float k )\n{\n\treturn x/k;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase_inverse_4( in float x, in float k )\n{\n\treturn x/k;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase_inverse_5( in float x, in float k )\n{\n\treturn x/k;\n}\n\n//\n// Staircase function y", "\n\tvec3 sample_dir = normalize(sample_pos - light_dir);\n\tvec3 sample_col = texture(atmosphere_tex, sample_dir).rgb;\n\treturn sample_col * background_col;\n}\n\n/*\nThis is the main function that renders the scene\n*/\nvoid main() {\n\tvec3 view_dir = normalize(view_pos - frag_pos);\n\tvec3 light_dir = normalize(light_pos - frag_pos);\n\tvec3 surface_normal = normalize(normal_mat * frag_normal);\n\tvec3 background_col = texture(background_tex, view_dir).rgb;\n\tvec3 light_col = skylight(frag_pos, surface_normal, light_dir, background_col);\n\tfrag_col = light_col;\n}\n```\n\n## 2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2.2", "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec4 depth = vec4(0.0, 0.0, 0.0, 0.0);\n\n\t// render the scene\n\tfor (int i = 0; i < NUM_SPHERES; i++) {\n\t\tvec3 sphere_pos = spheres[i].pos;\n\t\tvec3 sphere_color = spheres[i].color;\n\t\tfloat sphere_radius = spheres[i].radius;\n\n\t\t// check if the sphere is visible from the current position\n\t\tfloat distance = length(pos - sphere_pos);\n\t\tif (distance < sphere_radius) {\n\t\t\t// calculate the color of the sphere\n\t\t\tvec3 sphere_color_rgb = sphere_color.xyz;\n\t\t\tfloat sphere_color_alpha = sphere_color.w;\n\t\t\tvec3 sphere_color_rgb_scaled = sphere_color_rgb * sphere_color_alpha;\n\n\t\t\t// calculate the color of the atmosphere\n\t\t\tvec3 atmosphere_color_rgb = atmosphere_color.xyz;\n\t\t\tfloat atmosphere_color_alpha = atmosphere_color.w;\n\t\t\tvec3 atmosphere_color_rgb_scaled = atmosphere_color_rgb * atmosphere_color_alpha;\n\n\t\t\t// calculate the color of the light\n\t\t\tvec3 light_color_rgb = light_color.xyz;\n\t\t\tfloat light_color_alpha = light_color.w;\n\t\t\tvec3 light_color_rgb_scaled = light_color_rgb * light_color_alpha;\n\n\t\t\t// calculate the color of the sphere\n\t\t\tvec3 sphere_color_rgb_scaled_with_light = sphere_color_rgb_scaled * light_color_rgb_scaled;\n\n\t\t\t// calculate the color of the atmosphere\n\t\t\tvec3 atmosphere_color_rgb_scaled_with_light = atmosphere_color_rgb_scaled * light_color_rgb_scaled;\n\n\t\t\t// calculate the color of the sphere\n\t\t\tvec3 sphere_color_rgb_scaled_with_atmosphere = sphere_color_rgb_scaled_with_light * atmosphere_color_rgb_scaled;\n\n\t\t\t// calculate the color of the atmosphere\n\t\t\tvec", "\n\t//get the camera vector\n\tvec3 camera_vector = vec3(0, 0, -1);\n\t//get the camera position\n\tvec3 camera_position = vec3(0, 0, 0);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n\t//get the camera forward vector\n\tvec3 camera_forward = vec3(0, 0, 1);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n\t//get the camera forward vector\n\tvec3 camera_forward = vec3(0, 0, 1);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n\t//get the camera forward vector\n\tvec3 camera_forward = vec3(0, 0, 1);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n\t//get the camera forward vector\n\tvec3 camera_forward = vec3(0, 0, 1);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n\t//get the camera forward vector\n\tvec3 camera_forward = vec3(0, 0, 1);\n\t//get the camera up vector\n\tvec3 camera_up = vec3(0, 1, 0);\n\t//get the camera right vector\n\tvec3 camera_right = vec3(1, 0, 0);\n", "\n\tfloat r = length(p);\n\tfloat a = acos(clamp(dot(p, c) / r, -1.0f, 1.0f));\n\treturn a * a / (r * r) * ra;\n}\n\n// sdSphere returns the distance to the closest point on the surface of a sphere\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// sdBox returns the distance to the closest point on the surface of a box\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sdCylinder returns the distance to the closest point on the surface of a cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n\tp.y = abs(p.y);\n\tfloat d = length(vec2(p.xz)) - r;\n\treturn min(max(d, 0.0), p.y - h);\n}\n\n// sdCone returns the distance to the closest point on the surface of a cone\nfloat sdCone(vec3 p, float r, float h)\n{\n\tp.y = abs(p.y);\n\tfloat d = length(vec2(p.xz)) - r;\n\treturn min(max(d, 0.0), p.y - h);\n}\n\n// sdTorus returns the distance to the closest point on the surface of a torus\nfloat sdTorus(vec3 p, float r0, float r1)\n{\n\tfloat a = length(vec2(p.xz)) - r0;\n\tfloat b = length(p.yz) - r1;\n\treturn length(vec2(a, b)) - r1;\n}\n\n// sdTorus returns the distance to the closest point on the surface of a torus\nfloat sdTorus(vec3 p, float r0, float r1, float ra)\n{\n\tfloat a = length(vec2(p.xz", "\n    vec3 color;\n    if (material == 0) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 2) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 3) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 4) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 5) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 6) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 7) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 8) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 9) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 10) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 11) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 12) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 13) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 14) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 15) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material ==", "\n    return material_reflectivity[material];\n}\n\n// Get the color of a material.\n// The color is a 3-component vector.\n// The color is in the range [0, 1].\nvec3 get_material_color(int material) {\n    return material_color[material];\n}\n\n// Get the emission of a material.\n// The emission is a 3-component vector.\n// The emission is in the range [0, 1].\nvec3 get_material_emission(int material) {\n    return material_emission[material];\n}\n\n// Get the shininess of a material.\n// The shininess is a scalar.\n// The shininess is in the range [0, 1].\nfloat get_material_shininess(int material) {\n    return material_shininess[material];\n}\n\n// Get the texture of a material.\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array of pixels.\n// The texture is in the range [0, 1].\n// The texture is a 2D array", "\n\treturn materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat get_material_reflectivity(int material) {\n\treturn materials[material].reflectivity;\n}\n\n// Get index of refraction of a material.\nfloat get_material_transparency(int material) {\n\treturn materials[material].transparency;\n}\n\n// Get index of refraction of a material.\nfloat get_material_ior(int material) {\n\treturn materials[material].ior;\n}\n\n// Get index of refraction of a material.\nfloat get_material_roughness(int material) {\n\treturn materials[material].roughness;\n}\n\n// Get index of refraction of a material.\nfloat get_material_metalness(int material) {\n\treturn materials[material].metalness;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission(int material) {\n\treturn materials[material].emission;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color(int material) {\n\treturn materials[material].emission_color;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color_r(int material) {\n\treturn materials[material].emission_color_r;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color_g(int material) {\n\treturn materials[material].emission_color_g;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color_b(int material) {\n\treturn materials[material].emission_color_b;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color_a(int material) {\n\treturn materials[material].emission_color_a;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color_h(int material) {\n\treturn materials[material].emission_color_h;\n}\n\n// Get index of refraction of a material.\nfloat", "\n    return materials[material].opacity;\n}\n\n// Get the number of materials in the scene.\nint get_num_materials() {\n    return num_materials;\n}\n\n// Get the number of lights in the scene.\nint get_num_lights() {\n    return num_lights;\n}\n\n// Get the number of objects in the scene.\nint get_num_objects() {\n    return num_objects;\n}\n\n// Get the number of triangles in the scene.\nint get_num_triangles() {\n    return num_triangles;\n}\n\n// Get the number of vertices in the scene.\nint get_num_vertices() {\n    return num_vertices;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in the scene.\nint get_num_edges() {\n    return num_edges;\n}\n\n// Get the number of faces in the scene.\nint get_num_faces() {\n    return num_faces;\n}\n\n// Get the number of edges in", "\n\tvec3 e1 = tri_b - tri_a;\n\tvec3 e2 = tri_c - tri_a;\n\tvec3 p = cross(line_b - line_a, e2);\n\tfloat det = dot(e1, p);\n\tif (det > -0.00001 && det < 0.00001) return vec3(false, 0, 0);\n\tfloat inv_det = 1.0 / det;\n\tvec3 t = line_a - tri_a;\n\tfloat u = dot(t, p) * inv_det;\n\tif (u < 0.0 || u > 1.0) return vec3(false, 0, 0);\n\tvec3 q = cross(t, e1);\n\tfloat v = dot(line_b - line_a, q) * inv_det;\n\tif (v < 0.0 || u + v > 1.0) return vec3(false, 0, 0);\n\treturn vec3(true, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n\tvec3 e1 = tri_b - tri_a;\n\tvec3 e2 = tri_c - tri_a;\n\tvec3 p = cross(line_b - line_a, e2);\n\tfloat det = dot(e1, p);\n\tif (det > -0.00001 && det < 0.00001) return vec3(false, 0, 0);\n\tfloat inv_det = 1.0 / det;\n\tvec3 t = line_a - tri_a;\n\tfloat u = dot(t, p) * inv_det;\n\tif (u < 0.0 || u > 1.0) return vec3(false, 0, 0", "\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}\n\n// Given a triangle and a point, compute the barycentric coordinates of the point\n// in the triangle.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates\nvec3 get_barycentric_coords(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 point) {\n    vec3 v0 = tri_c - tri_a;\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = point - tri_a;\n\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0f - v - w;\n\n    return vec3(u, v, w);\n}\n\n// Given a triangle and a point, compute the barycentric coordinates of the point\n// in the triangle.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates\nvec3 get_barycentric_coords_2(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 point) {\n    vec3 v0 = tri_c - tri_a;\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = point - tri_a;\n\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0, 1, 0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat3(x_axis, y_axis, z_axis);\n}\n\n// Generate a perspective projection matrix.\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(fov * 0.5);\n    return mat4(f / aspect, 0, 0, 0,\n                0, f, 0, 0,\n                0, 0, (far + near) / (near - far), -1,\n                0, 0, (2 * far * near) / (near - far), 0);\n}\n\n// Generate a perspective projection matrix.\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    return mat4(2 / (right - left), 0, 0, -(right + left) / (right - left),\n                0, 2 / (top - bottom), 0, -(top + bottom) / (top - bottom),\n                0, 0, -2 / (far - near), -(far + near) / (far - near),\n                0, 0, 0, 1);\n}\n\n// Generate a perspective projection matrix.\nmat4 orthographic_matrix(float left, float right, float bottom, float top) {\n    return orthographic_matrix(left, right, bottom, top, -1, 1);\n}\n\n// Generate a perspective projection matrix.\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    return orthographic_matrix(left, right, bottom, top, near, far);\n}\n\n// Generate a perspective projection matrix.\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near) {\n    return orthographic_matrix(left, right, bottom, top, near, 1);\n}\n\n// Generate a perspective projection matrix.\n", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float shadow_intensity = 0.0;\n    float shadow_distance = 0.0;\n    float shadow_distance_max = 1000.0;\n    float shadow_distance_step = 0.01;\n    float shadow_distance_step_max = 0.1;\n    float shadow_distance_step_min = 0.001;\n    float shadow_distance_step_step = 0.001;\n    float shadow_distance_step_step_max = 0.0001;\n    float shadow_distance_step_step_min = 0.00001;\n    float shadow_distance_step_step_step = 0.00001;\n    float shadow_distance_step_step_step_max = 0.000001;\n    float shadow_distance_step_step_step_min = 0.0000001;\n    float shadow_distance_step_step_step_step = 0.0000001;\n    float shadow_distance_step_step_step_step_max = 0.00000001;\n    float shadow_distance_step_step_step_step_min = 0.000000001;\n    float shadow_distance_step_step_step_step_step = 0.000000001;\n    float shadow_distance_step_step_step_step_step_max = 0.0000000001;\n    float shadow_distance_step_step_step_step_step_min = 0.00000000001;\n    float shadow_distance_step_step_step_step_step_step_max = 0.000000000001;\n    float shadow_distance_step_step_step_step_step_step_min = 0.0000000000001;\n    float shadow_distance_step_step_step_step_step_step_step_max = 0.00000000000001;\n    float shadow_distance_step_step_step", "\n\treturn x * 0.5 - 0.25;\n}\n\n// Noise with a period of 1\nfloat noise( in float x )\n{\n\treturn bnoise( x );\n}\n\n// Noise with a period of 2\nfloat noise2( in float x )\n{\n\treturn bnoise( x * 0.5 );\n}\n\n// Noise with a period of 4\nfloat noise4( in float x )\n{\n\treturn bnoise( x * 0.25 );\n}\n\n// Noise with a period of 8\nfloat noise8( in float x )\n{\n\treturn bnoise( x * 0.125 );\n}\n\n// Noise with a period of 16\nfloat noise16( in float x )\n{\n\treturn bnoise( x * 0.0625 );\n}\n\n// Noise with a period of 32\nfloat noise32( in float x )\n{\n\treturn bnoise( x * 0.03125 );\n}\n\n// Noise with a period of 64\nfloat noise64( in float x )\n{\n\treturn bnoise( x * 0.015625 );\n}\n\n// Noise with a period of 128\nfloat noise128( in float x )\n{\n\treturn bnoise( x * 0.0078125 );\n}\n\n// Noise with a period of 256\nfloat noise256( in float x )\n{\n\treturn bnoise( x * 0.00390625 );\n}\n\n// Noise with a period of 512\nfloat noise512( in float x )\n{\n\treturn bnoise( x * 0.001953125 );\n}\n\n// Noise with a period of 1024\nfloat noise1024( in float x )\n{\n\treturn bnoise( x * 0.0009765625 );\n}\n\n// Noise with a period of 2048\nfloat noise2048( in float", "\n\treturn p * ( 3.0 - abs( p * p * p ) );\n}\n\n// Perlin noise\nfloat pnoise( in float p )\n{\n\treturn p * ( 6.0 - abs( p * p * p ) );\n}\n\n// Traditional gradient noise\nfloat gnoise( in float2 p )\n{\n\treturn p.x * ( 3.0 - abs( p.x * p.x * p.x ) ) + p.y * ( 3.0 - abs( p.y * p.y * p.y ) );\n}\n\n// Perlin noise\nfloat pnoise( in float2 p )\n{\n\treturn p.x * ( 6.0 - abs( p.x * p.x * p.x ) ) + p.y * ( 6.0 - abs( p.y * p.y * p.y ) );\n}\n\n// Traditional gradient noise\nfloat gnoise( in float3 p )\n{\n\treturn p.x * ( 3.0 - abs( p.x * p.x * p.x ) ) + p.y * ( 3.0 - abs( p.y * p.y * p.y ) ) + p.z * ( 3.0 - abs( p.z * p.z * p.z ) );\n}\n\n// Perlin noise\nfloat pnoise( in float3 p )\n{\n\treturn p.x * ( 6.0 - abs( p.x * p.x * p.x ) ) + p.y * ( 6.0 - abs( p.y * p.y * p.y ) ) + p.z * ( 6.0 - abs( p.z * p.z * p.z ) );\n}\n\n// Traditional gradient noise\nfloat gnoise( in float4 p )\n{\n\treturn p.x * ( 3.0 - abs( p.x * p.x * p.x ) ) + p.y * ( 3.0 - abs( p.y * p.y * p.y ) ) + p.z * ( 3.0 - abs( p.z * p.z * p.z )", "\n\tn = (n ^ 61) ^ (n >> 16);\n\tn += (n << 3);\n\tn = (n ^ (n >> 4));\n\tn *= 0x27d4eb2d;\n\tn = (n ^ (n >> 15));\n\treturn n;\n}\n\n// hash function for strings\nint hash( const char *str )\n{\n\tint n = 0;\n\twhile( *str )\n\t{\n\t\tn = (n << 4) + *str++;\n\t\tint c = n & 0xf0000000;\n\t\tif( c )\n\t\t{\n\t\t\tn ^= c >> 24;\n\t\t\tn &= ~c;\n\t\t}\n\t}\n\treturn n;\n}\n\n// hash function for strings\nint hash( const std::string &str )\n{\n\treturn hash( str.c_str() );\n}\n\n// hash function for strings\nint hash( const std::wstring &str )\n{\n\treturn hash( str.c_str() );\n}\n\n// hash function for strings\nint hash( const std::u16string &str )\n{\n\treturn hash( str.c_str() );\n}\n\n// hash function for strings\nint hash( const std::u32string &str )\n{\n\treturn hash( str.c_str() );\n}\n\n// hash function for strings\nint hash( const std::u8string &str )\n{\n\treturn hash( str.c_str() );\n}\n\n// hash function for strings\nint hash( const std::string &str, int len )\n{\n\tint n = 0;\n\tfor( int i = 0; i < len; i++ )\n\t{\n\t\tn = (n << 4) + str[i];\n\t\tint c = n & 0xf0000000;\n\t\tif( c )\n\t\t{\n\t\t\tn ^= c >> 24;\n\t\t\tn &= ~c;\n\t\t}\n\t}\n\treturn n;\n}\n\n// hash function for strings\nint hash( const std::wstring &str, int len )\n{\n\tint", "\n\treturn p * ( 3.0 - abs( p * p * p ) );\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 p )\n{\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\n\t// Four corners in 2D of a tile\n\tfloat a = gnoise( i );\n\tfloat b = gnoise( i + vec2( 1.0, 0.0 ) );\n\tfloat c = gnoise( i + vec2( 0.0, 1.0 ) );\n\tfloat d = gnoise( i + vec2( 1.0, 1.0 ) );\n\n\t// Smooth Interpolation\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\n\t// Interpolate along x-axis\n\tfloat h = mix( a, b, u.x );\n\tfloat k = mix( c, d, u.x );\n\n\t// Interpolate along y-axis\n\treturn mix( h, k, u.y );\n}\n\n// 3D simplex noise\nfloat tnoise( in vec3 p )\n{\n\tvec3 i = floor( p );\n\tvec3 f = fract( p );\n\n\t// Four corners in 3D of a tile\n\tfloat a = gnoise( i );\n\tfloat b = gnoise( i + vec3( 1.0, 0.0, 0.0 ) );\n\tfloat c = gnoise( i + vec3( 0.0, 1.0, 0.0 ) );\n\tfloat d = gnoise( i + vec3( 1.0, 1.0, 0.0 ) );\n\tfloat e = gnoise( i + vec3( 0.0, 0.0, 1.0 ) );\n\tfloat f = gnoise( i + vec3( 1.0, 0.0, 1.0 ) );\n\tfloat g = gnoise( i + vec3( 0.0, 1.0, 1.0 ) );\n\tfloat h = gnoise( i + vec3( 1.0, 1.0,", "\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tsum += noise( x * freq ) * amp;\n\t\tamp *= G;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// fbm\nfloat fbm( in float x, in float y, in float G )\n{\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tsum += noise( x * freq, y * freq ) * amp;\n\t\tamp *= G;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// fbm\nfloat fbm( in float x, in float y, in float z, in float G )\n{\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tsum += noise( x * freq, y * freq, z * freq ) * amp;\n\t\tamp *= G;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// fbm\nfloat fbm( in float x, in float y, in float z, in float w, in float G )\n{\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tsum += noise( x * freq, y * freq, z * freq, w * freq ) * amp;\n\t\tamp *= G;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// fbm\nfloat fbm( in float x, in float y, in float z, in float w, in float u, in float G )\n{\n\tfloat sum = 0.0;\n\t", "\n    // The quadratic polynomial is:\n    //\n    //     (p.x)^2 + (p.y)^2 + (p.z)^2 - 1 = 0\n    //\n    // The solutions are:\n    //\n    //     p = (cos(t) * u, sin(t) * v, sqrt(1 - (cos(t) * u)^2 - (sin(t) * v)^2))\n    //\n    // where u and v are random numbers in the range [-1, 1]\n    // and t is a random number in the range [0, 2 * pi]\n    //\n    // The color is based on the value of t.\n    //\n    // The color is red if t is in the range [0, pi/2]\n    // The color is green if t is in the range [pi/2, pi]\n    // The color is blue if t is in the range [pi, 3 * pi/2]\n    // The color is white if t is in the range [3 * pi/2, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0, 2 * pi]\n    //\n    // The color is white if t is in the range [0", "\n    // Convert p to polar coordinates\n    float r = sqrt( dot(pb,pb) );\n    float theta = atan( pb.y, pb.x );\n    float phi = atan( pb.z, sqrt( dot(pb,pb) - pb.z*pb.z ) );\n\n    // Convert polar coordinates to 4D point\n    vec4 p = vec4( r*cos(theta)*sin(phi), r*sin(theta)*sin(phi), r*cos(phi), 1.0 );\n\n    // Map 4D point to cubic polynomial coefficients\n    vec4 coeffs = cubicMap( p );\n\n    // Evaluate cubic polynomial\n    float a = coeffs.x;\n    float b = coeffs.y;\n    float c = coeffs.z;\n    float d = coeffs.w;\n    float f = a + b*p.x + c*p.x*p.x + d*p.x*p.x*p.x;\n\n    // Convert cubic polynomial to color\n    float h = f;\n    float s = 1.0;\n    float v = 1.0;\n    vec3 rgb = hsv2rgb( vec3(h,s,v) );\n\n    return rgb;\n}\n\nvoid main()\n{\n    // Get point in -1..1\n    vec3 pb = gl_FragCoord.xy / resolution.xy - 0.5;\n\n    // Get color\n    vec3 rgb = getColor( pb );\n\n    // Output color\n    gl_FragColor = vec4( rgb, 1.0 );\n}\n\n```\n\nThe code is based on the [Cubic Mapping](http://www.iquilezles.org/www/articles/cubic/cubic.htm) article by.\nUpvotes: 2 ", "\n\tvec3 l = cen - ro;\n\tfloat t = dot(l, rd);\n\tvec3 p = ro + t * rd;\n\tvec3 d = p - cen;\n\tfloat r = dot(d, d);\n\tfloat s = dot(rad, rad);\n\tfloat q = dot(d, d) - s;\n\tfloat a = t * t - q;\n\tfloat b = 2 * t * q;\n\tfloat c = q * q - s;\n\tfloat t0 = (-b - sqrt(b * b - 4 * a * c)) / (2 * a);\n\tfloat t1 = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\n\tfloat t = min(t0, t1);\n\treturn vec4(t, t, t, t);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b)\n{\n\treturn min(a, b);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b)\n{\n\treturn max(a, b);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float c)\n{\n\treturn min(min(a, b), c);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float c)\n{\n\treturn max(max(a, b), c);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float c, float d)\n{\n\treturn min(min(a, b), min(c, d));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float c, float d)\n{\n", "\n\tvec3 d = ro - cen;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, d);\n\tfloat c = dot(d, d) - dot(rad, rad);\n\tfloat discr = b * b - 4.0 * a * c;\n\tif (discr < 0.0) return 0.0;\n\tfloat t = (-b - sqrt(discr)) / (2.0 * a);\n\treturn t;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 d = ro - cen;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, d);\n\tfloat c = dot(d, d) - dot(rad, rad);\n\tfloat discr = b * b - 4.0 * a * c;\n\tif (discr < 0.0) return 1000000.0;\n\tfloat t = (-b - sqrt(discr)) / (2.0 * a);\n\treturn t;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\tvec3 d = ro - cen;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, d);\n\tfloat c = dot(d, d) - rad * rad;\n\tfloat discr = b * b - 4.0 * a * c;\n\tif (discr < 0.0) return 1000000.0;\n\tfloat t = (-b - sqrt(discr)) / (2.0 * a);\n\treturn t;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat cylinder( in vec3 ro, in vec", "\n    float t = mint;\n    float d = 0.0001;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t4", " return seed = (seed * 1103515245 + 12345) & 0x7fffffff; }\nfloat randf(void) { return seed / 32768.0f; }\n\n// for ground truth comparison\nfloat randf(float min, float max) { return min + (max - min) * randf(); }\n\n// for ground truth comparison\nfloat randf(int min, int max) { return min + (max - min) * randf(); }\n\n// for ground truth comparison\nfloat randf(float min, float max, float step) { return min + (max - min) * randf() / step; }\n\n// for ground truth comparison\nfloat randf(int min, int max, int step) { return min + (max - min) * randf() / step; }\n\n// for ground truth comparison\nfloat randf(float min, float max, float step, float seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(int min, int max, int step, int seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(float min, float max, float step, float seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(int min, int max, int step, int seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(float min, float max, float step, float seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(int min, int max, int step, int seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(float min, float max, float step, float seed) { return min + (max - min) * randf(seed) / step; }\n\n// for ground truth comparison\nfloat randf(int min, int", "\n\treturn a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c )\n{\n\treturn a + b*cos( 6.28318*(c*t) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b )\n{\n\treturn a + b*cos( 6.28318*t );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a )\n{\n\treturn a;\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t )\n{\n\treturn vec3(t);\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in float a, in float b, in float c, in float d )\n{\n\treturn vec3(a + b*cos( 6.28318*(c*t+d) ));\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in float a, in float b, in float c )\n{\n\treturn vec3(a + b*cos( 6.28318*(c*t) ));\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in float a, in float b )\n{\n\treturn vec3(a + b*cos( 6.28318*t ));\n", "\n\tfloat d = length(vec2(la, lb));\n\tfloat a = ra * d;\n\tfloat b = ra * d;\n\tfloat c = ra * d;\n\tfloat s = (a + b + c) / 2.0;\n\tfloat area = sqrt(s * (s - a) * (s - b) * (s - c));\n\tfloat r = h / (2.0 * area);\n\treturn length(p) - r;\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(vec3 p, float r, float h, float ra)\n{\n\treturn sdRhombus(p, r, r, h, ra);\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(vec2 p, float r, float h, float ra)\n{\n\treturn sdRhombus(vec3(p, 0.0), r, h, ra);\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(vec2 p, float r, float h)\n{\n\treturn sdRhombus(vec3(p, 0.0), r, h, 0.0);\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(float2 p, float r, float h, float ra)\n{\n\treturn sdRhombus(vec3(p, 0.0), r, h, ra);\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(float2 p, float r, float h)\n{\n\treturn sdRhombus(vec3(p, 0.0), r, h, 0.0);\n}\n\n// p=point, r=radius, h=height, ra=corner\nfloat sdRhombus(float3 p, float r, float h, float ra)\n{\n\treturn sdRhombus(p, r, h, ra);\n}\n\n// p=point, r=radius, h=height, ra=corner\n", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pab = a + ba * h;\n\tvec2 pabp = pab - p;\n\tfloat d = length( pabp );\n\tfloat d2 = d * d;\n\tfloat d3 = d2 * d;\n\tfloat d4 = d3 * d;\n\tfloat d5 = d4 * d;\n\tfloat d6 = d5 * d;\n\tfloat d7 = d6 * d;\n\tfloat d8 = d7 * d;\n\tfloat d9 = d8 * d;\n\tfloat d10 = d9 * d;\n\tfloat d11 = d10 * d;\n\tfloat d12 = d11 * d;\n\tfloat d13 = d12 * d;\n\tfloat d14 = d13 * d;\n\tfloat d15 = d14 * d;\n\tfloat d16 = d15 * d;\n\tfloat d17 = d16 * d;\n\tfloat d18 = d17 * d;\n\tfloat d19 = d18 * d;\n\tfloat d20 = d19 * d;\n\tfloat d21 = d20 * d;\n\tfloat d22 = d21 * d;\n\tfloat d23 = d22 * d;\n\tfloat d24 = d23 * d;\n\tfloat d25 = d24 * d;\n\tfloat d26 = d25 * d;\n\tfloat d27 = d26 * d;\n\tfloat d28 = d27 * d;\n\tfloat d29 = d28 * d;\n\tfloat d30 = d29 * d;\n\tfloat d31 = d30 * d;\n\tfloat d32 = d31 * d;\n\tfloat d33 = d32 * d;\n\tfloat d34 = d33 * d;\n\tfloat d35 = d34 * d;\n", "\n    vec2 d = abs(p) - b;\n    return vec4( max(d.x, 0.0) + max(d.y, 0.0), \n                2.0 * max(max(d.x, d.y), 0.0), \n                length(p), \n                s );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t )\n{\n    vec2 d = abs(p) - b;\n    return vec4( max(d.x, 0.0) + max(d.y, 0.0), \n                2.0 * max(max(d.x, d.y), 0.0), \n                length(p), \n                s + t );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u )\n{\n    vec2 d = abs(p) - b;\n    return vec4( max(d.x, 0.0) + max(d.y, 0.0), \n                2.0 * max(max(d.x, d.y), 0.0), \n                length(p), \n                s + t + u );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float t, in float u, in float v )\n{\n    vec2 d = abs(p) - b;\n    return vec4( max(d.x, 0.0) + max(d.y, 0.0), \n                2.0 * max(max(d.x, d.y), 0.0), \n                length(p), \n                s + t + u + v );\n}\n\n// x = local dist\n", "\n    vec2 q = p - b;\n    vec2 r = abs(q) - b;\n    vec2 s = r - b;\n    return vec3(\n        s.x * s.y,\n        s.x * s.z,\n        s.y * s.z\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 q = p - b;\n    vec3 r = abs(q) - b;\n    vec3 s = r - b;\n    return vec3(\n        s.x * s.y,\n        s.x * s.z,\n        s.y * s.z\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec4 p, in vec4 b )\n{\n    vec4 q = p - b;\n    vec4 r = abs(q) - b;\n    vec4 s = r - b;\n    return vec3(\n        s.x * s.y,\n        s.x * s.z,\n        s.y * s.z\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec3 b )\n{\n    vec2 q = p - b.xy;\n    vec2 r = abs(q) - b.xy;\n    vec2 s = r - b.xy;\n    return vec3(\n        s.x * s.y,\n        s.x * s.z,\n        s.y * s.z\n    );\n}", "\n\tfloat d = distance(p, vec2(0.0));\n\tfloat a = atan(p.y, p.x);\n\tfloat x = d * cos(a);\n\tfloat y = d * sin(a);\n\tfloat z = d;\n\tfloat w = d - r;\n\treturn vec4(x, y, z, w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale ) \n{\n\tfloat d = distance(p, vec2(0.0));\n\tfloat a = atan(p.y, p.x);\n\tfloat x = d * cos(a);\n\tfloat y = d * sin(a);\n\tfloat z = d;\n\tfloat w = d - r;\n\treturn vec4(x, y, z, w) * scale;\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale, float offset ) \n{\n\tfloat d = distance(p, vec2(0.0));\n\tfloat a = atan(p.y, p.x);\n\tfloat x = d * cos(a);\n\tfloat y = d * sin(a);\n\tfloat z = d;\n\tfloat w = d - r;\n\treturn vec4(x, y, z, w) * scale + offset;\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale, float offset, float angle ) \n{\n\tfloat d = distance(p, vec2(0.0));\n\tfloat a = atan(p.y, p.x) + angle;\n\tfloat x = d * cos(a);\n\tfloat y = d * sin(a);\n\tfloat z = d;\n\tfloat w = d - r;\n\treturn", "\n\tfloat d = r;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tvec2 v = verts[i];\n\t\tvec2 w = verts[(i+1)%5];\n\t\tfloat t = dot(w-v, p-v) / dot(w-v, w-v);\n\t\tt = clamp(t, 0.0, 1.0);\n\t\td = min(d, length(p-v) - t*length(w-v));\n\t}\n\treturn d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5] ) \n{\n\treturn sdPoly(p, verts, 1.0);\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t ) \n{\n\tfloat d = r;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tvec2 v = verts[i];\n\t\tvec2 w = verts[(i+1)%5];\n\t\tfloat t = dot(w-v, p-v) / dot(w-v, w-v);\n\t\tt = clamp(t, 0.0, 1.0);\n\t\td = min(d, length(p-v) - t*length(w-v));\n\t}\n\treturn d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s ) \n{\n\tfloat d = r;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tvec2 v = verts[i];\n\t\tvec2 w = verts[(i+1)%5];\n\t\tfloat t = dot(w-v, p-v) / dot(w-v, w-v);\n\t\tt = clamp(t, 0.0, 1.0);\n\t\td = min(d, length(p-v) - t*length(w-v));\n\t}\n\treturn d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float", "\n\tvec2 d = p - verts[0];\n\tfloat d0 = length(d);\n\tfloat d1 = length(d - verts[1]);\n\tfloat d2 = length(d - verts[2]);\n\tfloat d3 = length(d - verts[3]);\n\tfloat d4 = length(d - verts[4]);\n\tfloat d5 = length(d - verts[0]);\n\tfloat d6 = length(d - verts[1]);\n\tfloat d7 = length(d - verts[2]);\n\tfloat d8 = length(d - verts[3]);\n\tfloat d9 = length(d - verts[4]);\n\tfloat d10 = length(d - verts[0]);\n\tfloat d11 = length(d - verts[1]);\n\tfloat d12 = length(d - verts[2]);\n\tfloat d13 = length(d - verts[3]);\n\tfloat d14 = length(d - verts[4]);\n\tfloat d15 = length(d - verts[0]);\n\tfloat d16 = length(d - verts[1]);\n\tfloat d17 = length(d - verts[2]);\n\tfloat d18 = length(d - verts[3]);\n\tfloat d19 = length(d - verts[4]);\n\tfloat d20 = length(d - verts[0]);\n\tfloat d21 = length(d - verts[1]);\n\tfloat d22 = length(d - verts[2]);\n\tfloat d23 = length(d - verts[3]);\n\tfloat d24 = length(d - verts[4]);\n\tfloat d25 = length(d - verts[0]);\n\tfloat d26 = length(d - verts[1]);\n\tfloat d27 = length(d - verts[2]);\n\tfloat d28 = length(d - verts[3]);\n\tfloat d29 = length(d - verts[4]);\n\tfloat d30 = length(d - verts[0]);\n\tfloat d31 = length(d - verts[1]);\n\tfloat d32 = length(d - verts[2]);\n\tfloat d33 = length(d - verts[3]);\n\tfloat d", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tvec2 pb = p - b;\n\tvec2 bb = b - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 bb = b - b;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\tvec2 aa = a - a;\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tvec2 pb = p - b;\n\tvec2 ab = a - b;\n\t", "\n\tvec3 v = vec3(0.0);\n\tv.x = 0.5 * ( 1.0 - cos(p.x) );\n\tv.y = 0.5 * ( 1.0 - cos(p.y) );\n\tv.z = 0.5 * ( 1.0 - cos(p.x + p.y) );\n\treturn v;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, in float r, in float s ) \n{\n\tvec3 v = vec3(0.0);\n\tv.x = 0.5 * ( 1.0 - cos(p.x) );\n\tv.y = 0.5 * ( 1.0 - cos(p.y) );\n\tv.z = 0.5 * ( 1.0 - cos(p.x + p.y) );\n\tv.yz = 1.0 / sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n\treturn v;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgHexagon( in vec2 p, in float r, in float s, in float t ) \n{\n\tvec4 v = vec4(0.0);\n\tv.x = 0.5 * ( 1.0 - cos(p.x) );\n\tv.y = 0.5 * ( 1.0 - cos(p.y) );\n\tv.z = 0.5 * ( 1.0 - cos(p.x + p.y) );\n\t", "\n\tvec3 x = X[0];\n\tvec3 y = X[1];\n\tvec3 z = X[2];\n\tvec3 u = p - X[3];\n\tvec3 v = cross(x, y);\n\tvec3 w = cross(x, z);\n\tvec3 t = cross(u, v);\n\tvec3 s = cross(u, w);\n\tfloat d = dot(t, s);\n\tif (d == 0.0) {\n\t\ttan1 = vec3(0.0);\n\t\ttan2 = vec3(0.0);\n\t\treturn false;\n\t}\n\tfloat d2 = 1.0 / d;\n\ttan1 = d2 * t;\n\ttan2 = d2 * s;\n\treturn true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2, out vec3 tan3) {\n\tvec3 x = X[0];\n\tvec3 y = X[1];\n\tvec3 z = X[2];\n\tvec3 u = p - X[3];\n\tvec3 v = cross(x, y);\n\tvec3 w = cross(x, z);\n\tvec3 t = cross(u, v);\n\tvec3 s = cross(u, w);\n\tfloat d = dot(t, s);\n\tif (d == 0.0) {\n\t\ttan1 = vec3(0.0);\n\t\ttan2 = vec3(0.0);\n\t\ttan3 = vec3(0.0);\n\t\treturn false;\n\t}\n\tfloat d2 = 1.0 / d;\n\ttan1 = d2 * t;\n\ttan2 = d2 * s;\n\ttan3 = cross(tan1, tan2);\n\treturn true;\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p,", "\n\tif (b.x == 0) b.x += 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Transforms\nvec3 RotateZ(vec3 p, float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(p.x * c + p.y * s, p.y * c - p.x * s, p.z);\n}\n\n// Transforms\nvec3 Rotate(vec3 p, vec3 a)\n{\n\treturn RotateZ(RotateY(RotateX(p, a.x), a.y), a.z);\n}\n\n// Transforms\nvec3 Scale(vec3 p, vec3 s)\n{\n\treturn vec3(p.x * s.x, p.y * s.y, p.z * s.z);\n}\n\n// Transforms\nvec3 Scale(vec3 p, float s)\n{\n\treturn vec3(p.x * s, p.y * s, p.z * s);\n}\n\n// Transforms\nvec3 Translate(vec3 p, vec3 t)\n{\n\treturn vec3(p.x + t.x, p.y + t.y, p.z + t.z);\n}\n\n// Transforms\nvec3 Translate(vec3 p, float t)\n{\n\treturn vec3(p.x + t, p.y + t, p.z + t);\n}\n\n// Transforms\nvec3 Transform(vec3 p, mat4 m)\n{\n\treturn vec3(m[0][0] * p.x + m[0][1] * p.y + m[0][2] * p.z + m[0][3],\n\t\tm[1][0] * p.x + m[1][1] * p.y + m[1][2] * p.z + m[1][3],\n\t\tm[2][0] * p.x + m[2][1] * p.y + m[2][2] * p.z + m", "\n\treturn 1.0f - (x * x) / (R * R);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2)\n{\n\treturn 1.0f - (x * x) / (R * R2);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3)\n{\n\treturn 1.0f - (x * x) / (R * R2 * R3);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4)\n{\n\treturn 1.0f - (x * x) / (R * R2 * R3 * R4);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5)\n{\n\treturn 1.0f - (x * x) / (R * R2 * R3 * R4 * R5);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5, float R6)\n{\n\treturn 1.0f - (x * x) / (R * R2 * R3 * R4 * R5 * R6);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5, float R6, float R7)\n{\n\treturn 1.0f - (x * x) / (R * R2 * R3 * R4 * R5 * R6 * R7);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3,", "\n\treturn 1.0f / (1.0f + e * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r)\n{\n\treturn 1.0f / (1.0f + e * R * r);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2)\n{\n\treturn 1.0f / (1.0f + e * R * r * r2);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3)\n{\n\treturn 1.0f / (1.0f + e * R * r * r2 * r3);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4)\n{\n\treturn 1.0f / (1.0f + e * R * r * r2 * r3 * r4);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4, float r5)\n{\n\treturn 1.0f / (1.0f + e * R * r * r2 * r3 * r4 * r5);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4, float r5, float r6)\n{\n\treturn 1.0f / (1.0f + e * R * r * r", "\n\tfloat k = 0.0f;\n\tif (a == b)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse\n\t{\n\t\tk = (a - b) / (R * R * e);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float d)\n{\n\tfloat k = 0.0f;\n\tif (a == b)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse\n\t{\n\t\tk = (a - b) / (R * R * e * d);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float d, float d2)\n{\n\tfloat k = 0.0f;\n\tif (a == b)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse\n\t{\n\t\tk = (a - b) / (R * R * e * d * d2);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float d, float d2, float d3)\n{\n\tfloat k = 0.0f;\n\tif (a == b)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse\n\t{\n\t\tk = (a - b) / (R * R * e * d * d2 * d3);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff", "\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Point(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Plane primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Triangle primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Triangle(vec3 p, vec3 c, float R, float e)\n{\n\treturn exp(-(length(p-c)/R)*e);\n}\n\n// Quad primitive field function\n// p: world point\n// c: center\n// R: radius\n// e", "\n\tfloat d = length(b - a);\n\tfloat d2 = length(c - a);\n\tfloat d3 = length(c - b);\n\tfloat d4 = length(c - (a + b) / 2.0f);\n\tfloat d5 = length(c - (a + b) / 2.0f + (b - a) / 2.0f);\n\tfloat d6 = length(c - (a + b) / 2.0f - (b - a) / 2.0f);\n\tfloat d7 = length(c - (a + b) / 2.0f + (b - a) / 2.0f + (b - a) / 2.0f);\n\tfloat d8 = length(c - (a + b) / 2.0f - (b - a) / 2.0f - (b - a) / 2.0f);\n\tfloat d9 = length(c - (a + b) / 2.0f + (b - a) / 2.0f - (b - a) / 2.0f);\n\tfloat d10 = length(c - (a + b) / 2.0f - (b - a) / 2.0f + (b - a) / 2.0f);\n\tfloat d11 = length(c - (a + b) / 2.0f + (b - a) / 2.0f + (b - a) / 2.0f - (b - a) / 2.0f);\n\tfloat d12 = length(c - (a + b) / 2.0f - (b - a) / 2.0f - (b - a) / 2.0f + (b - a) / 2.0f);\n\tfloat d13 = length(c - (a + b) / 2.0f + (b - a) / 2.0f - (b - a) / 2.0f + (b - a) / 2.0f);\n\tfloat d14 = length(c - (a + b) / 2.0f - (b", "\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v, float w)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v, float w, float x)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v, float w, float x, float y)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v, float w, float x, float y, float z)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - 1;\n}\n\n// Tree root\nfloat Object(vec3 p, float t, float u, float v, float w, float x, float y, float z, float a)\n{\n\treturn p.x * p.x + p.y * p.y + p.z * p.z - ", "\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) + sqrt(pow(b.x - c.x, 2) + pow(b.y - c.y, 2) + pow(b.z - c.z, 2));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) + sqrt(pow(b.x - c.x, 2) + pow(b.y - c.y, 2) + pow(b.z - c.z, 2)) + sqrt(pow(c.x - d.x, 2) + pow(c.y - d.y, 2) + pow(c.z - d.z, 2));\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2)) + sqrt(pow(b.x - c.x, 2) + pow(b.y - c.y, 2) + pow(b.z - c.z, 2)) + sqrt(pow(c.x - d.x, 2) + pow(c.y - d.y, 2) + pow(c.z - d.z, 2)) + sqrt(pow(d.x - e.x, 2) + pow", "\n\tvec3 N = vec3(0.0);\n\tN += Normal(p + vec3(1.0, 0.0, 0.0));\n\tN += Normal(p + vec3(-1.0, 0.0, 0.0));\n\tN += Normal(p + vec3(0.0, 1.0, 0.0));\n\tN += Normal(p + vec3(0.0, -1.0, 0.0));\n\tN += Normal(p + vec3(0.0, 0.0, 1.0));\n\tN += Normal(p + vec3(0.0, 0.0, -1.0));\n\treturn N;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 d )\n{\n\tvec3 N = vec3(0.0);\n\tN += Normal(p + d);\n\tN += Normal(p - d);\n\treturn N;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 d, in float eps )\n{\n\tvec3 N = vec3(0.0);\n\tN += Normal(p + d);\n\tN += Normal(p - d);\n\tN += Normal(p + d * eps);\n\tN += Normal(p - d * eps);\n\treturn N;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 d, in float eps, in float eps2 )\n{\n\tvec3 N = vec3(0.0);\n\tN += Normal(p + d);\n\tN += Normal(p - d);\n\tN += Normal(p + d * eps);\n\tN += Normal(p - d * eps);\n\tN += Normal(p + d * eps2);\n\tN += Normal(p - d * eps2);\n\treturn N;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 d, in float eps, in float eps2, in float eps3 )\n{\n\tvec3 N = vec3(0.0);\n\tN += Normal(p + d);\n\tN += Normal(", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 1000; i++)\n\t{\n\t\tt += 0.001;\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (t > 1000)\n\t\t{", "\n\treturn vec3(0.5, 0.7, 1.0);\n}\n\nvec3 Light(vec3 rd)\n{\n\treturn vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Shade(vec3 rd)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// Main function\nint main(int argc, char** argv)\n{\n\t// Initialize the window\n\tGLFWwindow* window = InitializeWindow();\n\n\t// Initialize the camera\n\tCamera camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0));\n\n\t// Initialize the scene\n\tScene scene;\n\tscene.AddObject(new Sphere(vec3(0.0, 0.0, -1.0), 0.5));\n\tscene.AddObject(new Sphere(vec3(0.0, -100.5, -1.0), 100.0));\n\n\t// Initialize the framebuffer\n\tFramebuffer framebuffer(1024, 768);\n\n\t// Initialize the timer\n\tTimer timer;\n\n\t// Main loop\n\twhile (!glfwWindowShouldClose(window))\n\t{\n\t\t// Start the timer\n\t\ttimer.Start();\n\n\t\t// Clear the framebuffer\n\t\tframebuffer.Clear();\n\n\t\t// Render the scene\n\t\tfor (int y = 0; y < framebuffer.GetHeight(); y++)\n\t\t{\n\t\t\tfor (int x = 0; x < framebuffer.GetWidth(); x++)\n\t\t\t{\n\t\t\t\t// Calculate the ray direction\n\t\t\t\tvec3 rd = camera.GetRayDirection(x, y);\n\n\t\t\t\t// Calculate the color\n\t\t\t\tvec3 color = Background(rd);\n\n\t\t\t\t// Shade the ray\n\t\t\t\tcolor = Shade(rd);\n\n\t\t\t\t// Set the pixel color\n\t\t\t\tframebuffer.SetPixel(x, y, color);\n\t\t\t}\n\t\t}\n\n\t\t// Swap the buffers\n\t\tglfwSwapBuffers(window);\n\n\t\t// Poll for and process events\n\t\tglfwPollEvents();\n\n\t\t// Stop the timer\n\t\ttimer.Stop();", "\n\tvec3 pa = p-a;\n\tvec3 ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\tvec3 hp = a + ba*h;\n\treturn length(p-hp) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h)\n{\n\tvec3 pa = p-a;\n\tvec3 ba = b-a;\n\tfloat h2 = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\tvec3 hp = a + ba*h2;\n\treturn length(p-hp) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float k)\n{\n\tvec3 pa = p-a;\n\tvec3 ba = b-a;\n\tfloat h2 = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\tvec3 hp = a + ba*h2;\n\treturn length(p-hp) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float k, float l)\n{\n\tvec3 pa = p-a;\n\tvec3 ba = b-a;\n\tfloat h2 = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\tvec3 hp = a + ba*h2;\n\treturn length(p-hp) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float k, float l, float m)\n{\n\tvec3 pa = p-a;\n\tvec3 ba = b-a;\n\tfloat h2 = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\tvec3 hp = a + ba*h2;\n", "\n\tvec3 t = (ro - rad) / rd;\n\tvec3 u = (ro + rad) / rd;\n\tvec3 tmin = min(t, u);\n\tvec3 tmax = max(t, u);\n\tvec3 tmin1 = min(tmin.x, tmin.y);\n\tvec3 tmax1 = max(tmax.x, tmax.y);\n\tvec3 tmin2 = min(tmin1, tmax1);\n\tvec3 tmax2 = max(tmax.z, tmin.z);\n\tvec3 tmin3 = min(tmin2, tmax2);\n\treturn tmin3;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat iSmin( in float a, in float b, in float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 iSmin( in vec3 a, in vec3 b, in float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 iSmin( in vec3 a, in vec3 b, in vec3 k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 iSmin( in vec3", "\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec3 uv_coord(vec3 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec3 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec2 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec3 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec2 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec3 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec2 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec3 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec4 coord) {\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec4 uv_coord(vec2 coord) {\n    return", "\n    vec2 r = p - q;\n    float d = length(r);\n    vec2 s = r / d;\n    vec2 t = vec2(s.y, -s.x);\n    return vec3(d, s.x, s.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r )\n{\n    vec2 s = p - q;\n    vec2 t = r - q;\n    float d = length(s);\n    vec2 u = s / d;\n    vec2 v = t / length(t);\n    return vec3(d, u.x, u.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s )\n{\n    vec2 t = p - q;\n    vec2 u = r - q;\n    vec2 v = s - q;\n    float d = length(t);\n    vec2 w = t / d;\n    vec2 x = u / length(u);\n    vec2 y = v / length(v);\n    return vec3(d, w.x, w.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q, in vec2 r, in vec2 s, in vec2 t )\n{\n    vec2 u = p - q;\n    vec2 v = r - q;", "\n    vec2 q = p - vec2(r, 0.0);\n    float t = length(q);\n    float s = clamp(t - d, 0.0, 1.0);\n    float c = clamp(d - t, 0.0, 1.0);\n    return vec3(s, c, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float s)\n{\n    vec2 q = p - vec2(r, 0.0);\n    float t = length(q);\n    float s = clamp(t - d, 0.0, 1.0);\n    float c = clamp(d - t, 0.0, 1.0);\n    return vec3(s, c, s * c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float s, float c)\n{\n    vec2 q = p - vec2(r, 0.0);\n    float t = length(q);\n    float s = clamp(t - d, 0.0, 1.0);\n    float c = clamp(d - t, 0.0, 1.0);\n    return vec3(s, c, s * c);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r, float d, float s, float c, float e)\n{\n   ", "\n    vec2 q = vec2( r * cos(p.x), r * sin(p.x) );\n    vec2 dq = vec2( -r * sin(p.x), r * cos(p.x) );\n    vec2 d2q = vec2( -r * cos(p.x), -r * sin(p.x) );\n    vec2 d2q2 = vec2( r * sin(p.x), -r * cos(p.x) );\n    vec2 d2q3 = vec2( -r * cos(p.x), r * sin(p.x) );\n    vec2 d2q4 = vec2( r * sin(p.x), -r * cos(p.x) );\n    vec2 d2q5 = vec2( -r * cos(p.x), -r * sin(p.x) );\n    vec2 d2q6 = vec2( r * sin(p.x), r * cos(p.x) );\n    vec2 d2q7 = vec2( -r * cos(p.x), r * sin(p.x) );\n    vec2 d2q8 = vec2( r * sin(p.x), -r * cos(p.x) );\n    vec2 d2q9 = vec2( -r * cos(p.x), -r * sin(p.x) );\n    vec2 d2q10 = vec2( r * sin(p.x), r * cos(p.x) );\n    vec2 d2q11 = vec2( -r * cos(p.x), r * sin(p.x) );\n    vec2 d2q12 = vec2( r * sin(p.x), -r * cos(p.x) );\n    vec2 d2q13 = vec2( -r * cos(p.x), -r * sin(p.x) );\n    vec2 d2q14 = vec2( r * sin(p.x), r * cos(p.x) );\n    vec2 d2q15 = vec2( -r * cos(p.x), r * sin(p.x) );\n    vec2 d2q16 = vec2( r * sin(p.x", "\n    vec2 e[3];\n    e[0] = v[1] - v[0];\n    e[1] = v[2] - v[1];\n    e[2] = v[0] - v[2];\n\n    vec2 n = cross( e[0], e[1] );\n    vec2 b = cross( e[2], e[1] );\n    vec2 c = cross( e[0], e[2] );\n\n    vec2 d = p - v[0];\n    vec2 e1 = cross( d, e[1] );\n    vec2 e2 = cross( d, e[2] );\n\n    vec2 f = e1 / n;\n    vec2 g = e2 / n;\n\n    vec2 h = f - g;\n    vec2 i = f + g;\n\n    vec2 j = b / n;\n    vec2 k = c / n;\n\n    vec2 l = j - k;\n    vec2 m = j + k;\n\n    vec2 n1 = h - l;\n    vec2 n2 = h + l;\n\n    vec2 o = i - m;\n    vec2 p = i + m;\n\n    vec2 q = n1 - o;\n    vec2 r = n1 + o;\n\n    vec2 s = n2 - p;\n    vec2 t = n2 + p;\n\n    vec2 u = q - s;\n    vec2 v = q + s;\n\n    vec2 w = r - t;\n    vec2 x = r + t;\n\n    vec2 y = u - w;\n    vec2 z = u + w;\n\n    vec2 a = v - x;\n    vec2 b = v + x;\n\n    vec2 c = y - z;\n    vec2 d = y + z;\n\n    vec2 e = a - b;\n    vec2 f = a + b;\n\n    vec2 g = c - d;\n    vec2 h = c + d;\n\n    vec2 i = e - g;\n    vec2 j = e + g;\n\n    vec2 k = f - h;\n    vec2 l = f + h;\n\n    vec2 m = i - k;\n    vec2 n = i + k;\n\n    vec2 o = j - l;\n    vec2 p = j + l;\n\n    vec2 q = m - n;\n    vec2 r = m + n;\n\n    vec2", "\n\tvec2 r = sca * p;\n\tfloat a = atan( r.y, r.x );\n\tfloat b = a + scb.x;\n\tfloat c = a + scb.y;\n\tfloat d = a + scb.x + scb.y;\n\tfloat e = a + scb.x - scb.y;\n\tfloat f = a + scb.x + scb.y + scb.y;\n\tfloat g = a + scb.x - scb.y + scb.y;\n\tfloat h = a + scb.x - scb.y - scb.y;\n\tfloat i = a + scb.x + scb.y - scb.y;\n\tfloat j = a + scb.x - scb.y - scb.y - scb.y;\n\tfloat k = a + scb.x + scb.y - scb.y - scb.y;\n\tfloat l = a + scb.x - scb.y - scb.y - scb.y - scb.y;\n\tfloat m = a + scb.x + scb.y - scb.y - scb.y - scb.y;\n\tfloat n = a + scb.x - scb.y - scb.y - scb.y - scb.y - scb.y;\n\tfloat o = a + scb.x + scb.y - scb.y - scb.y - scb.y - scb.y;\n\tfloat p = a + scb.x - scb.y - scb.y - scb.y - scb.y - scb.y - scb.y;\n\tfloat q = a + scb.x + scb.y - scb.y - scb.y - scb.y - scb.y - scb.y;\n\tfloat r = a + scb.x - scb.y - scb.y - scb.y - scb.y - scb.y - scb.y - scb.y;\n\tfloat s = a + scb.x + scb.y - sc", " return a.x * b.y - a.y * b.x; }\nfloat crs( in vec2 a, in vec2 b ) { return a.x * b.x + a.y * b.y; }\nfloat crs( in vec3 a, in vec3 b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat crs( in vec4 a, in vec4 b ) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) { return a.x * b.y - a.y * b.x; }\nfloat crs( in vec3 a, in vec3 b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat crs( in vec4 a, in vec4 b ) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec4 a, in vec4 b ) { return a.x * b.y - a.y * b.x; }\nfloat crs( in vec4 a, in vec4 b ) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n//.x =", "\n    vec2 q = p / ab;\n    vec2 r = q.yx;\n    vec2 s = q.xy;\n    vec2 t = q.yx * q.xy;\n    vec2 u = q.xy * q.yx;\n    vec2 v = q.yx * q.xy * q.xy;\n    vec2 w = q.xy * q.yx * q.xy * q.xy;\n    vec2 x = q.xy * q.yx * q.xy * q.xy * q.xy;\n    vec2 y = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy;\n    vec2 z = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 a = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 b = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 c = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 d = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 e = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 f = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy;\n    vec2 g = q.xy * q.yx * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy * q.xy", "\n\tfloat a = length(p);\n\tfloat b = length(p.xy);\n\tfloat c = a - b;\n\tfloat d = ra + rb;\n\tfloat e = ra - rb;\n\tfloat f = c * c;\n\tfloat g = d * d;\n\tfloat h = e * e;\n\tfloat i = f / g;\n\tfloat j = f / h;\n\tfloat k = i + j;\n\tfloat l = sqrt(k);\n\tfloat m = 1.0 / l;\n\tfloat n = m * m;\n\tfloat o = n * n;\n\tfloat p = 1.0 / o;\n\tfloat q = p * p;\n\tfloat r = q * q;\n\tfloat s = r * r;\n\tfloat t = s * s;\n\tfloat u = t * t;\n\tfloat v = u * u;\n\tfloat w = v * v;\n\tfloat x = w * w;\n\tfloat y = x * x;\n\tfloat z = y * y;\n\tfloat A = 1.0 / z;\n\tfloat B = A * A;\n\tfloat C = B * B;\n\tfloat D = C * C;\n\tfloat E = D * D;\n\tfloat F = E * E;\n\tfloat G = F * F;\n\tfloat H = G * G;\n\tfloat I = H * H;\n\tfloat J = I * I;\n\tfloat K = J * J;\n\tfloat L = K * K;\n\tfloat M = L * L;\n\tfloat N = M * M;\n\tfloat O = N * N;\n\tfloat P = O * O;\n\tfloat Q = P * P;\n\tfloat R = Q * Q;\n\tfloat S = R * R;\n\tfloat T = S * S;\n\tfloat U = T * T;\n\tfloat V = U * U;\n\tfloat W = V * V;\n\tfloat X = W * W;\n\tfloat Y = X * X;\n\tfloat Z = Y * Y;\n\tfloat aa = 1.0 / Z;\n\tfloat bb = aa * aa;\n\tfloat cc = bb * bb;\n\tfloat", "\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = clamp( dot(ap, ab) / dot(ab, ab), 0.0, 1.0 );\n\tvec3 pab = mix(a, b, t);\n\tvec3 d = p - pab;\n\tfloat d2 = dot(d, d);\n\tfloat r2 = r * r;\n\tfloat d2r2 = d2 - r2;\n\tfloat d2r2_2 = d2r2 * d2r2;\n\tfloat d2r2_3 = d2r2_2 * d2r2;\n\tfloat d2r2_4 = d2r2_3 * d2r2;\n\tfloat d2r2_5 = d2r2_4 * d2r2;\n\tfloat d2r2_6 = d2r2_5 * d2r2;\n\tfloat d2r2_7 = d2r2_6 * d2r2;\n\tfloat d2r2_8 = d2r2_7 * d2r2;\n\tfloat d2r2_9 = d2r2_8 * d2r2;\n\tfloat d2r2_10 = d2r2_9 * d2r2;\n\tfloat d2r2_11 = d2r2_10 * d2r2;\n\tfloat d2r2_12 = d2r2_11 * d2r2;\n\tfloat d2r2_13 = d2r2_12 * d2r2;\n\tfloat d2r2_14 = d2r2_13 * d2r2;\n\tfloat d2r2_15 = d2r2_14 * d2r2;\n\tfloat d2r2_16 = d2r2_15 * d2r2;\n\tfloat d2r2_17 = d2r2_16 * d2r2;\n\tfloat d2r2_18 = d2r2_17 * d2r2;\n\tfloat d2r2_19 =", "\n\tvec2 q = p - vec2(wi, he);\n\tfloat d = abs(q.x) - wi;\n\td = max(d, abs(q.y) - he);\n\td = max(d, dot(q, vec2(sk, 1.0)) - 1.0);\n\treturn d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n\tvec2 q = p - vec2(wi, he);\n\tfloat d = abs(q.x) - wi;\n\td = max(d, abs(q.y) - he);\n\td = max(d, dot(q, vec2(sk, 1.0)) - 1.0);\n\treturn d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n\tvec2 q = p - vec2(wi, he);\n\tfloat d = abs(q.x) - wi;\n\td = max(d, abs(q.y) - he);\n\td = max(d, dot(q, vec2(sk, 1.0)) - 1.0);\n\treturn d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n\tvec2 q = p - vec2(wi, he);\n\tfloat d = abs(q.x) - wi;\n\td = max(d, abs(q.y) - he);\n\td = max(d, dot(q, vec2(sk, 1.0)) - 1.0);\n\treturn d;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk )\n{\n\tvec2", "\n    vec2 q = p * vec2(wi, he);\n    vec2 r = vec2(0.0, 0.0);\n    vec2 s = vec2(0.0, 0.0);\n    vec2 t = vec2(0.0, 0.0);\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n    vec2 w = vec2(0.0, 0.0);\n    vec2 x = vec2(0.0, 0.0);\n    vec2 y = vec2(0.0, 0.0);\n    vec2 z = vec2(0.0, 0.0);\n    vec2 yz = vec2(0.0, 0.0);\n    vec2 xy = vec2(0.0, 0.0);\n    vec2 xz = vec2(0.0, 0.0);\n    vec2 yx = vec2(0.0, 0.0);\n    vec2 yz = vec2(0.0, 0.0);\n    vec2 zx = vec2(0.0, 0.0);\n    vec2 zy = vec2(0.0, 0.0);\n    vec2 xw = vec2(0.0, 0.0);\n    vec2 yw = vec2(0.0, 0.0);\n    vec2 zw = vec2(0.0, 0.0);\n    vec2 xv = vec2(0.0, 0.0);\n    vec2 yv = vec2(0.0, 0.0);\n    vec2 zv = vec2(0.0, 0.0);\n    vec2 xu = vec2(0.0, 0.0);\n    vec2 yu = vec2(0.0, 0.0);\n    vec2 zu = vec2(0.0, 0.0);\n    vec2 xu_ = vec2(0.0, 0.0);\n    vec2 yu_ = vec2(0.0, 0.0);\n    vec2 zu_ = vec2(0.0, 0.0);\n    vec2 x", "\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\tfloat r;\n\tr = p / c;\n\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\tfloat r;\n\tr = p + c;\n\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\tfloat r;\n\tr = p - c;\n\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\tfloat r;\n\tr = p / c;\n\treturn r;\n\t}\n\nfloat opRep7D( float p, float c )\n\t{\n\tfloat r;\n\tr = p + c;\n\treturn r;\n\t}\n\nfloat opRep8D( float p, float c )\n\t{\n\tfloat r;\n\tr = p - c;\n\treturn r;\n\t}\n\nfloat opRep9D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep10D( float p, float c )\n\t{\n\tfloat r;\n\tr = p / c;\n\treturn r;\n\t}\n\nfloat opRep11D( float p, float c )\n\t{\n\tfloat r;\n\tr = p + c;\n\treturn r;\n\t}\n\nfloat opRep12D( float p, float c )\n\t{\n\tfloat r;\n\tr = p - c;\n\treturn r;\n\t}\n\nfloat opRep13D( float p, float c )\n\t{\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\n\nfloat opRep14D( float p, float c )\n\t{\n\tfloat r;\n\tr = p / c;", "\n\treturn a + k * (b - a);\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float k) {\n\treturn a + k * (b - a) / 2;\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float c, float k) {\n\treturn a + k * (b - a) / 3 + k * (c - a) / 3;\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float c, float d, float k) {\n\treturn a + k * (b - a) / 4 + k * (c - a) / 4 + k * (d - a) / 4;\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float c, float d, float e, float k) {\n\treturn a + k * (b - a) / 5 + k * (c - a) / 5 + k * (d - a) / 5 + k * (e - a) / 5;\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float c, float d, float e, float f, float k) {\n\treturn a + k * (b - a) / 6 + k * (c - a) / 6 + k * (d - a) / 6 + k * (e - a) / 6 + k * (f - a) / 6;\n}\n\n// IQ's polynominal average\nfloat pavg(float a, float b, float c, float d, float e, float f, float g, float k) {\n\treturn a + k * (b - a) / 7 + k * (c - a) / 7 + k * (d - a) / 7 + k * (e - a) / 7 + k * (f - a) / 7 + k * (g", "\n\tvec2 q = fract(p);\n\treturn p - q;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 n) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(dot(p, n), 0.0), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 n, float r) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(dot(p, n), 0.0), r);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 n, float r, float s) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(dot(p, n), 0.0), r) + s;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 n, float r, float s, float t) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(dot(p, n), 0.0), r) + s + t;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 n, float r, float s, float t, float u) {\n\treturn length(max(abs(p) - b, 0.0)) + min(max(dot(p, n), 0.0), r) + s + t + u;\n}\n\n// http://mercury.sexy/hg_sdf/\n", "\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c, out vec3 hsv) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx),", "\n\tvec3 oc = s.xyz - ro;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - s.w * s.w;\n\tfloat d = b * b - c;\n\tif (d < 0.0) return vec2(-1.0, -1.0);\n\treturn vec2(b - sqrt(d), b + sqrt(d));\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec4 t) {\n\tvec3 e1 = t.xyz - t.w;\n\tvec3 e2 = t.w - t.xyz;\n\tvec3 p = cross(rd, e2);\n\tfloat det = dot(e1, p);\n\tif (det < 0.0001) return vec2(-1.0, -1.0);\n\tvec3 s = ro - t.w;\n\tfloat u = dot(s, p) / det;\n\tif (u < 0.0 || u > 1.0) return vec2(-1.0, -1.0);\n\tvec3 q = cross(s, e1);\n\tfloat v = dot(rd, q) / det;\n\tif (v < 0.0 || u + v > 1.0) return vec2(-1.0, -1.0);\n\treturn vec2(u, v);\n}\n\n// IQ's ray quad intersection\nvec2 rayQuad(vec3 ro, vec3 rd, vec4 q) {\n\tvec3 e1 = q.xyz - q.w;\n\tvec3 e2 = q.w - q.xyz;\n\tvec3 p = cross(rd, e2);\n\tfloat det = dot(e1, p);\n\tif (det < 0.0001) return vec2(-1.0, -1.0);\n\tvec3 s = ro - q.w;\n\tfloat u = dot(s, p) / det;\n\tif (u < 0.0 || u > 1.0) return vec2(-1.0, -1.0);\n\tvec3 q2 = cross(s", "\n    vec3 tmin = (boxSize - ro) / rd;\n    vec3 tmax = (boxSize - ro) / rd;\n    vec3 tminn = min(tmin, tmax);\n    vec3 tmaxx = max(tmin, tmax);\n    vec3 tminnn = min(tminn, tmaxx);\n    vec3 tmaxxx = max(tminn, tmaxx);\n    float tminn = min(tminnn.x, tminnn.y);\n    float tmaxx = max(tmaxxx.x, tmaxxx.y);\n    float tmin = min(tminn, tmaxx);\n    float tmax = max(tminn, tmaxx);\n    outNormal = normalize(rd);\n    return vec2(tmin, tmax);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sphereCenter, float sphereRadius, out vec3 outNormal )  {\n    vec3 oc = ro - sphereCenter;\n    float a = dot(rd, rd);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - a * c;\n    if (discriminant < 0.0) {\n        outNormal = vec3(0.0);\n        return vec2(-1.0, -1.0);\n    }\n    float sqrtDiscriminant = sqrt(discriminant);\n    float t1 = (-b - sqrtDiscriminant) / a;\n    float t2 = (-b + sqrtDiscriminant) / a;\n    float t = min(t1, t2);\n    outNormal = normalize(ro + t * rd - sphereCenter);\n    return vec2(t, t);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 outNormal )  {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det > -0.0000", "\n\tvec2 e12 = vec2(d.x, 0);\n\tvec2 e23 = vec2(0, d.y);\n\tvec2 e34 = vec2(-d.x, 0);\n\tvec2 e41 = vec2(0, -d.y);\n\tvec2 e123 = vec2(d.x, d.y);\n\tvec2 e234 = vec2(d.x, -d.y);\n\tvec2 e341 = vec2(-d.x, -d.y);\n\tvec2 e412 = vec2(-d.x, d.y);\n\tvec2 e1234 = vec2(d.x, d.y) + vec2(d.x, -d.y);\n\tvec2 e2341 = vec2(d.x, d.y) + vec2(-d.x, -d.y);\n\tvec2 e3412 = vec2(d.x, -d.y) + vec2(-d.x, d.y);\n\tvec2 e4123 = vec2(-d.x, d.y) + vec2(-d.x, -d.y);\n\tvec2 e12341 = vec2(d.x, d.y) + vec2(d.x, -d.y) + vec2(-d.x, d.y);\n\tvec2 e23412 = vec2(d.x, d.y) + vec2(d.x, -d.y) + vec2(-d.x, -d.y);\n\tvec2 e34123 = vec2(d.x, -d.y) + vec2(-d.x, d.y) + vec2(-d.x, -d.y);\n\tvec2 e41234 = vec2(-d.x, d.y) + vec2(-d.x, -d.y) + vec2(d.x, d.y);\n\tvec2 e123412 = vec2(d.x, d.y) + vec2(d.x, -d", "\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist2(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist3(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist4(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist5(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist6(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist7(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x, b.y - p.y)));\n}\n\nfloat linedist8(vec2 p, vec2 a, vec2 b) {\n\treturn length(cross(vec2(a.x - p.x, a.y - p.y), vec2(b.x - p.x", "\n    float d = length(b-a);\n    float t = clamp(dot(p-a,b-a)/d,0.0,1.0);\n    vec2 pa = a + t*(b-a);\n    vec2 pb = pa + normalize(b-a)*w2;\n    vec2 pc = pa + normalize(a-b)*w2;\n    vec2 pd = pa + normalize(a-b)*w1;\n    vec2 pe = pa + normalize(b-a)*w1;\n    return length(p-pa) + length(p-pb) + length(p-pc) + length(p-pd) + length(p-pe);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n    float d = length(b-a);\n    float t = clamp(dot(p-a,b-a)/d,0.0,1.0);\n    vec2 pa = a + t*(b-a);\n    vec2 pb = pa + normalize(b-a)*w2;\n    vec2 pc = pa + normalize(a-b)*w2;\n    vec2 pd = pa + normalize(a-b)*w1;\n    vec2 pe = pa + normalize(b-a)*w1;\n    vec2 pf = pa + normalize(b-a)*w3;\n    return length(p-pa) + length(p-pb) + length(p-pc) + length(p-pd) + length(p-pe) + length(p-pf);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4 )\n{\n    float d = length(b-a);\n    float t = clamp(dot(p-a,b-a)/d,0.0,1.0);\n    vec2 pa = a + t*(b-a);\n    vec2 pb = pa + normalize(b-a", "\n\tvec3 p = ro - tor.xyx;\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(rd, p * 2.0);\n\tfloat c = dot(p, p) - tor.x * tor.x;\n\tfloat d = b * b - a * c;\n\tif (d < 0.0) return -1.0;\n\tfloat s = sqrt(d);\n\tfloat t = (-b - s) / a;\n\tif (t < 0.0) t = (-b + s) / a;\n\treturn t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat rayCylinder(vec3 ro, vec3 rd, vec2 cyl) {\n\tvec3 op = ro - cyl.xyx;\n\tfloat k = dot(rd, rd) - cyl.x * cyl.x;\n\tfloat k2 = dot(op, op) - cyl.x * cyl.x;\n\tfloat d = k * k - k2;\n\tif (d < 0.0) return -1.0;\n\tfloat s = sqrt(d);\n\tfloat t = (-k - s) / k;\n\tif (t < 0.0) t = (-k + s) / k;\n\treturn t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat rayCone(vec3 ro, vec3 rd, vec2 cone) {\n\tvec3 op = ro - cone.xyx;\n\tfloat k = dot(rd, rd) - cone.x * cone.x;\n\tfloat k2 = dot(op, op) - cone.x * cone.x;\n\tfloat d = k * k - k2;\n\tif (d < 0.0) return -1.0;\n\tfloat s = sqrt(d);\n\tfloat t = (-k - s) / k;\n\tif (t < 0", "\n\tvec2 p = vec2(pos.x, pos.z);\n\tvec2 q = vec2(pos.x, pos.z) - tor;\n\tfloat r = length(p);\n\tfloat R = length(q);\n\tvec3 n = normalize(vec3(p.x * R, p.y * R, R * R));\n\treturn n;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torusDistance(vec3 p, vec2 tor) {\n\tvec2 q = vec2(p.x, p.z) - tor;\n\tfloat r = length(p.xy);\n\tfloat R = length(q);\n\treturn r - R;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torusDistance(vec3 p, vec2 tor, out vec3 n) {\n\tvec2 q = vec2(p.x, p.z) - tor;\n\tfloat r = length(p.xy);\n\tfloat R = length(q);\n\tn = normalize(vec3(p.x * R, p.y * R, R * R));\n\treturn r - R;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torusDistance(vec3 p, vec2 tor, out vec3 n, out vec3 t) {\n\tvec2 q = vec2(p.x, p.z) - tor;\n\tfloat r = length(p.xy);\n\tfloat R = length(q);\n\tn = normalize(vec3(p.x * R, p.y * R, R * R));\n\tt = normalize(vec3(q.x * R, q.y * R, R * R));\n\treturn r - R;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/", "\n    return 1.0f - 2.0f / (1.0f + expf(2.0f * x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_2(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_3(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_4(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_5(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_6(float x) {\n    return 1.0f - tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x) * tanh_approx(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv_7", "\n\tvec2 p = vec2(0.5, 0.5) + 0.5 * col.xy;\n\tfloat d = 0.5 - length(p - vec2(0.5, 0.5));\n\tfloat a = 0.5 + 0.5 * col.z;\n\tfloat b = 0.5 + 0.5 * col.w;\n\tfloat c = 0.5 + 0.5 * col.x;\n\tfloat e = 0.5 + 0.5 * col.y;\n\tfloat f = 0.5 + 0.5 * col.z;\n\tfloat g = 0.5 + 0.5 * col.w;\n\tfloat h = 0.5 + 0.5 * col.x;\n\tfloat i = 0.5 + 0.5 * col.y;\n\tfloat j = 0.5 + 0.5 * col.z;\n\tfloat k = 0.5 + 0.5 * col.w;\n\tfloat l = 0.5 + 0.5 * col.x;\n\tfloat m = 0.5 + 0.5 * col.y;\n\tfloat n = 0.5 + 0.5 * col.z;\n\tfloat o = 0.5 + 0.5 * col.w;\n\tfloat p = 0.5 + 0.5 * col.x;\n\tfloat q = 0.5 + 0.5 * col.y;\n\tfloat r = 0.5 + 0.5 * col.z;\n\tfloat s = 0.5 + 0.5 * col.w;\n\tfloat t = 0.5 + 0.5 * col.x;\n\tfloat u = 0.5 + 0.5 * col.y;\n\tfloat v = 0.5 + 0.5 * col.z;\n\tfloat w = 0.5 + 0.5 * col.w;\n\tfloat x = 0.5 + 0.5 * col.x;\n\tfloat y = 0.5 + 0.5 * col.y;\n\t", "\n    p.x = mod(p.x, size.x);\n    p.y = mod(p.y, size.y);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout float p, float size) {\n    p = mod(p, size);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, float size) {\n    p.x = mod(p.x, size);\n    p.y = mod(p.y, size);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout float p, vec2 size) {\n    p = mod(p, size.x);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n    p.x = mod(p.x, size.x);\n    p.y = mod(p.y, size.y);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout float p, vec2 size) {\n    p = mod(p, size.x);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec3 size) {\n    p.x = mod(p.x, size.x);\n    p.y = mod(p.y, size.y);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author:", "\n\tvec2 p = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(\n\t\tmix(\n\t\t\tdot(p.xy, p.xy),\n\t\t\tdot(p.xy + vec2(1.0, 0.0), p.xy + vec2(1.0, 0.0)),\n\t\t\tu.x),\n\t\tmix(\n\t\t\tdot(p.xy + vec2(0.0, 1.0), p.xy + vec2(0.0, 1.0)),\n\t\t\tdot(p.xy + vec2(1.0, 1.0), p.xy + vec2(1.0, 1.0)),\n\t\t\tu.x),\n\t\tu.y);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat grid(vec2 uv) {\n\treturn fract(sin(uv.x * 100.0) * sin(uv.y * 100.0) * 100.0);\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat grid2(vec2 uv) {\n\treturn fract(sin(uv.x * 100.0) * sin(uv.y * 100.0) * 100.0) * 0.5 + 0.5;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat grid3(vec2 uv) {\n\treturn fract(sin(uv.x * 100.0) * sin(uv.y * 100.0) * 100.0) * 0.5 + 0.5;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat grid4(vec2 uv) {\n\treturn fract(sin(uv.x * 100.0) * sin(uv.y * 100.0) * 100.0) * 0.5 + 0.", "\n    return length(p-c) - r;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return length(v0 * u + v1 * v + v2) - 1.0;\n}\n\n// signed distance to a rectangle\nfloat sdRectangle( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 d = abs(p - a) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 d = abs(p - a) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundedRectangle( in vec2 p, in vec2 a, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p - a) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r.x - r.y;\n}\n\n// signed distance to", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h );\n}\n\n// distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tvec2 ap = p - a;\n\tvec2 bp = p - b;\n\tvec2 cp = p - c;\n\tfloat d1 = dot( cross( ab, ap ), ac );\n\tfloat d2 = dot( cross( ac, bp ), ab );\n\tfloat d3 = dot( cross( bc, cp ), bc );\n\tif( d1 > 0.0 && d2 > 0.0 && d3 > 0.0 )\n\t{\n\t\treturn length( ap );\n\t}\n\telse\n\t{\n\t\tfloat d4 = dot( cross( ab, bp ), ac );\n\t\tfloat d5 = dot( cross( ac, cp ), ab );\n\t\tfloat d6 = dot( cross( bc, ap ), bc );\n\t\tif( d4 > 0.0 && d5 > 0.0 && d6 > 0.0 )\n\t\t{\n\t\t\treturn length( bp );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat d7 = dot( cross( ab, cp ), ac );\n\t\t\tfloat d8 = dot( cross( ac, ap ), ab );\n\t\t\tfloat d9 = dot( cross( bc, bp ), bc );\n\t\t\tif( d7 > 0.0 && d8 > 0.0 && d9 > 0.0 )\n\t\t\t{\n\t\t\t\treturn length( cp );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec2 e = cross( ab, ac );\n\t\t\t\tvec2 f = cross( ac, bc );\n\t\t\t\tvec2 g = cross( bc, ab );\n\t\t\t\tfloat d10 = dot( e, ap );\n\t\t\t\tfloat d11 = dot( f, bp );\n\t\t\t\tfloat d12 = dot", "\n\treturn dot(cross(b-a, b-a), cross(b-a, b-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c ) {\n\treturn dot(cross(b-a, c-a), cross(b-a, c-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d ) {\n\treturn dot(cross(d-a, c-a), cross(d-a, c-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e ) {\n\treturn dot(cross(e-a, d-a), cross(e-a, d-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f ) {\n\treturn dot(cross(f-a, e-a), cross(f-a, e-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g ) {\n\treturn dot(cross(g-a, f-a), cross(g-a, f-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h ) {\n\treturn dot(cross(h-a, g-a), cross(h-a, g-a));\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i ) {\n", "\n\treturn length(p.xy - vec2(s,s)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float a ) \n{\n\treturn length(p.xy - vec2(s,s)) - r - a;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in float r ) \n{\n\treturn length(p.xyz - vec3(s,s,s)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in float r, in float a ) \n{\n\treturn length(p.xyz - vec3(s,s,s)) - r - a;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in float s, in float r ) \n{\n\treturn length(p.xyz - vec3(s,s,s)) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in float s, in float r, in float a ) \n{\n\treturn length(p.xyz - vec3(s,s,s)) - r - a;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in vec2 s, in float r ) \n{\n\treturn length(p.xy - s) - r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in vec2 s, in float r, in float a ) \n{\n\treturn length(p.xy - s) - r - a;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in vec3 s, in float r ) \n", "\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_inv(vec3 x)\n{\n\treturn 1.0 / (x * x * (3.0 - 2.0 * x));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_inv_fast(vec3 x)\n{\n\treturn 1.0 / (x * x * (3.0 - 2.0 * x));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_fast(vec3 x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_fast_inv(vec3 x)\n{\n\treturn 1.0 / (x * x * (3.0 - 2.0 * x));\n}\n\n// Origin: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_fast_inv_fast(vec3 x)\n{\n\treturn 1.0 / (x *", "\n\treturn vec3(3.0f * x * (1.0f - x), 6.0f * (1.0f - x), 3.0f);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn vec3(x * x * (3.0f - 2.0f * x));\n}\n\n// s-curve derivative\nvec3 d_s_curve(vec3 x)\n{\n\treturn vec3(6.0f * x * (1.0f - x) - 3.0f);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn vec3(x * x * (3.0f - 2.0f * x));\n}\n\n// s-curve derivative\nvec3 d_s_curve(vec3 x)\n{\n\treturn vec3(6.0f * x * (1.0f - x) - 3.0f);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn vec3(x * x * (3.0f - 2.0f * x));\n}\n\n// s-curve derivative\nvec3 d_s_curve(vec3 x)\n{\n\treturn vec3(6.0f * x * (1.0f - x) - 3.0f);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn vec3(x * x * (3.0f - 2.0f * x));\n}\n\n// s-curve derivative\nvec3 d_s_curve(vec3 x)\n{\n\treturn vec3(6.0f * x * (1.0f - x) - 3.0f);\n}\n\n// s-curve\nvec3 s_curve(vec3 x)\n{\n\treturn vec3(x * x * (3.0f - 2.0f * x));\n}\n\n// s-curve derivative\nvec3 d_s_curve(vec3 x)\n{\n\treturn vec3(6.0f * x * (", "\n\tfloat a = atan(p.y,p.x);\n\tfloat r = length(p);\n\tfloat t = a/TWO_PI;\n\tfloat s = sin(t*k);\n\tfloat c = cos(t*k);\n\treturn r*s*c;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float r )\n{\n\tfloat a = atan(p.y,p.x);\n\tfloat t = a/TWO_PI;\n\tfloat s = sin(t*k);\n\tfloat c = cos(t*k);\n\treturn r*s*c;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float r, in float a )\n{\n\tfloat a2 = atan(p.y,p.x);\n\tfloat t = a2/TWO_PI;\n\tfloat s = sin(t*k);\n\tfloat c = cos(t*k);\n\treturn r*s*c;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float r, in float a, in float b )\n{\n\tfloat a2 = atan(p.y,p.x);\n\tfloat t = a2/TWO_PI;\n\tfloat s = sin(t*k);\n\tfloat c = cos(t*k);\n\treturn r*s*c;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float r, in float a, in float b, in float c )\n{\n\tfloat a2 = atan(p.y,p.x);\n\tfloat t = a2/TWO_PI;\n\tfloat s = sin(t*k);\n\tfloat c = cos(t*k);\n\treturn r*", "\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale)\n{\n\treturn exp(-opticalDepth * scale);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias)\n{\n\treturn exp(-opticalDepth * scale + bias);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias, float exponent)\n{\n\treturn exp(-pow(opticalDepth * scale + bias, exponent));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias, float exponent, float power)\n{\n\treturn exp(-pow(opticalDepth * scale + bias, exponent) * power);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias, float exponent, float power, float power2)\n{\n\treturn exp(-pow(opticalDepth * scale + bias, exponent) * power * power2);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias, float exponent, float power, float power2, float power3)\n{\n\treturn exp(-pow(opticalDepth * scale + bias, exponent) * power * power2 * power3);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float scale, float bias, float exponent, float power, float power2, float power3, float power4)\n{\n\treturn exp(-pow(opticalDepth * scale + bias, exponent) * power * power2 * power3 * power4);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float", "\n\t// Integrate over the ray length.\n\tvec3 result = vec3(0.0);\n\ttransmittance = vec3(1.0);\n\tfor (float i = 0.0; i < rayLength; i += 0.001)\n\t{\n\t\t// Get the current ray position.\n\t\tvec3 rayPos = rayStart + rayDir * i;\n\n\t\t// Get the optical depth at the current position.\n\t\tfloat opticalDepth = GetOpticalDepth(rayPos);\n\n\t\t// If the optical depth is zero, we are outside the scene.\n\t\tif (opticalDepth == 0.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the transmittance at the current position.\n\t\ttransmittance *= GetTransmittance(rayPos);\n\n\t\t// Get the scattering at the current position.\n\t\tvec3 scattering = GetScattering(rayPos);\n\n\t\t// Add the scattering to the result.\n\t\tresult += scattering * transmittance;\n\t}\n\n\t// Return the result.\n\treturn result;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance, out float opticalDepth)\n{\n\t// Integrate over the ray length.\n\tvec3 result = vec3(0.0);\n\ttransmittance = vec3(1.0);\n\topticalDepth = 0.0;\n\tfor (float i = 0.0; i < rayLength; i += 0.001)\n\t{\n\t\t// Get the current ray position.\n\t\tvec3 rayPos = rayStart + rayDir * i;\n\n\t\t// Get the optical depth at the current position.\n\t\topticalDepth = GetOpticalDepth(rayPos);\n\n\t\t// If the optical depth is zero, we are outside the scene.\n\t\tif (opticalDepth == 0.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the transmittance at the current position.\n\t\t", "\n\treturn length(p2) - ra - rb - d;\n}\n\n// p1 = point on the first sphere\n// p2 = point on the second sphere\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p1, in vec3 p2, in float ra, float rb, in float d )\n{\n\treturn length(p2 - p1) - ra - rb - d;\n}\n\n// p1 = point on the first sphere\n// p2 = point on the second sphere\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p1, in vec3 p2, in float ra, float rb, in float d, in float r )\n{\n\treturn length(p2 - p1) - ra - rb - d - r;\n}\n\n// p1 = point on the first sphere\n// p2 = point on the second sphere\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p1, in vec3 p2, in float ra, float rb, in float d, in float r, in float s )\n{\n\treturn length(p2 - p1) - ra - rb - d - r - s;\n}\n\n// p1 = point on the first sphere\n// p2 = point on the second sphere\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p1, in vec3 p2, in float ra, float rb, in float d, in float r, in float s, in float t )\n{\n\treturn length(p2 - p1) - ra - rb - d - r - s - t;\n}\n\n// p1 = point on the first sphere\n// p2 = point on the second sphere\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p1, in vec3", "\n\tfloat d = length(p) - r;\n\tif( d < 0 ) return 0;\n\treturn max( 0, d - t );\n}\n\n// sdCutHollowCylinder( p, r, h, t )\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\n\tfloat d = length(p) - r;\n\tif( d < 0 ) return 0;\n\treturn max( 0, d - t );\n}\n\n// sdCutHollowCone( p, r, h, t )\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\n\tfloat d = length(p) - r;\n\tif( d < 0 ) return 0;\n\treturn max( 0, d - t );\n}\n\n// sdCutHollowTorus( p, r, h, t )\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCutHollowTorus( vec3 p, float r, float h, float t )\n{\n\tfloat d = length(p) - r;\n\tif( d < 0 ) return 0;\n\treturn max( 0, d - t );\n}\n\n// sdCutHollowTorus( p, r, h, t )\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCutHollowTorus( vec3 p, float r, float h, float t )\n{\n\tfloat d = length(p) - r;\n\tif( d < 0 ) return 0;\n\treturn max( 0, d - t );\n}\n\n// sdCutHollowTorus( p, r, h, t )\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCutHollowTorus( vec3 p, float r, float h, float t )\n{\n\tfloat d = length(", "\n\tfloat t = tmin;\n\tfloat t0 = tmin;\n\tfloat t1 = tmax;\n\tfloat t2 = tmax;\n\tfloat t3 = tmax;\n\tfloat t4 = tmax;\n\tfloat t5 = tmax;\n\tfloat t6 = tmax;\n\tfloat t7 = tmax;\n\tfloat t8 = tmax;\n\tfloat t9 = tmax;\n\tfloat t10 = tmax;\n\tfloat t11 = tmax;\n\tfloat t12 = tmax;\n\tfloat t13 = tmax;\n\tfloat t14 = tmax;\n\tfloat t15 = tmax;\n\tfloat t16 = tmax;\n\tfloat t17 = tmax;\n\tfloat t18 = tmax;\n\tfloat t19 = tmax;\n\tfloat t20 = tmax;\n\tfloat t21 = tmax;\n\tfloat t22 = tmax;\n\tfloat t23 = tmax;\n\tfloat t24 = tmax;\n\tfloat t25 = tmax;\n\tfloat t26 = tmax;\n\tfloat t27 = tmax;\n\tfloat t28 = tmax;\n\tfloat t29 = tmax;\n\tfloat t30 = tmax;\n\tfloat t31 = tmax;\n\tfloat t32 = tmax;\n\tfloat t33 = tmax;\n\tfloat t34 = tmax;\n\tfloat t35 = tmax;\n\tfloat t36 = tmax;\n\tfloat t37 = tmax;\n\tfloat t38 = tmax;\n\tfloat t39 = tmax;\n\tfloat t40 = tmax;\n\tfloat t41 = tmax;\n\tfloat t42 = tmax;\n\tfloat t43 = tmax;\n\tfloat t44 = tmax;\n\tfloat t45 = tmax;\n\tfloat t46 = tmax;\n\tfloat t47 = tmax;\n\tfloat t48 = tmax;\n\tfloat t49 = tmax;\n\tfloat t50 = tmax;\n\tfloat t", "\n\treturn length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h )\n{\n\treturn length(p) - r - h.x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec2 h )\n{\n\treturn length(p) - r - h.x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec4 h )\n{\n\treturn length(p) - r - h.x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in mat2 h )\n{\n\treturn length(p) - r - h[0].x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in mat3 h )\n{\n\treturn length(p) - r - h[0].x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in mat4 h )\n{\n\treturn length(p) - r - h[0].x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in dmat2 h )\n{\n\treturn length(p) - r - h[0].x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in dmat3 h )\n{\n\treturn length(p) - r - h[0].x;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in dmat4 h )\n{\n\treturn length(p) - r - h[0].x", "\n\tvec3 n = vec3(0.0);\n\tfloat d = 0.0001;\n\tn.x = sdBox( pos + vec3( d, 0.0, 0.0 ), vec3( 1.0, 1.0, 1.0 ) );\n\tn.y = sdBox( pos + vec3( 0.0, d, 0.0 ), vec3( 1.0, 1.0, 1.0 ) );\n\tn.z = sdBox( pos + vec3( 0.0, 0.0, d ), vec3( 1.0, 1.0, 1.0 ) );\n\treturn normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdBox( in vec3 p, in vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdSphere( in vec3 p, in float s )\n{\n\treturn length(p) - s;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot(p,n) - d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdCylinder( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdCone( in vec3 p, in vec3 c, in float r, in float h )\n{\n\treturn length(p-c) - r - h;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sdTorus( in vec3 p, in vec3 c, in float r, in float R )\n", "\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, n=normal, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in vec3 n, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n\treturn length(p.xy) - r + h;\n}\n\n// p=point, r=radius, h=height\nfloat sdCutDisk( in vec3 p, in float r", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix( mix( mix( dot(f,vec3(n,n+1.0,n+57.0)), dot(f,vec3(n+1.0,n+1.0,n+57.0)), f.x), mix( dot(f,vec3(n+57.0,n+57.0,n+1.0)), dot(f,vec3(n+57.0,n+57.0,n+57.0)), f.x), f.y), mix( mix( dot(f,vec3(n+1.0,n+1.0,n+1.0)), dot(f,vec3(n+1.0,n+1.0,n+57.0)), f.x), mix( dot(f,vec3(n+57.0,n+1.0,n+1.0)), dot(f,vec3(n+57.0,n+1.0,n+57.0)), f.x), f.y), f.z);\n}\n\n// 3d simplex noise function\nfloat simplex( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix( mix( mix( dot(f,vec3(n,n+1.0,n+57.0)), dot(f,vec3(n+1.0,n+1.0,n+57.0)), f.x), mix( dot(f,vec3(n+57.0,n+57.0,n+1.0)), dot(f,vec3(n+57.0,n+57.0", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += a * noise( p * freq );\n\t\ta *= b;\n\t\tfreq *= 2.0;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p )\n{\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += a * noise( p * freq );\n\t\ta *= b;\n\t\tfreq *= 2.0;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec4 p )\n{\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += a * noise( p * freq );\n\t\ta *= b;\n\t\tfreq *= 2.0;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float freq )\n{\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat amp = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += a * noise( p * freq );\n\t\ta *= b;\n\t\tfreq *= 2.0;\n\t}\n\treturn f;\n}", "\n\tvec3 i3 = floor(p3);\n\tvec3 f3 = fract(p3);\n\tf3 = f3*f3*(3.0-2.0*f3);\n\n\tfloat n = dot(i3, vec3(1.0, 157.0, 113.0));\n\tn = dot(n, vec3(1.0, 17.0, 311.0));\n\tn = dot(n, vec3(7.0, 37.0, 127.0));\n\tn = dot(n, vec3(19.0, 13.0, 73.0));\n\tn = dot(n, vec3(23.0, 59.0, 19.0));\n\tn = dot(n, vec3(11.0, 83.0, 3.0));\n\tn = dot(n, vec3(29.0, 11.0, 71.0));\n\tn = dot(n, vec3(13.0, 23.0, 17.0));\n\tn = dot(n, vec3(31.0, 47.0, 43.0));\n\tn = dot(n, vec3(5.0, 17.0, 23.0));\n\tn = dot(n, vec3(11.0, 19.0, 37.0));\n\tn = dot(n, vec3(13.0, 29.0, 41.0));\n\tn = dot(n, vec3(17.0, 31.0, 47.0));\n\tn = dot(n, vec3(19.0, 43.0, 53.0));\n\tn = dot(n, vec3(23.0, 59.0, 61.0));\n\tn = dot(n, vec3(29.0, 71.0, 73.0));\n\tn = dot(n, vec3(37.0,", "\n    // Get the pixel's screen position\n    vec2 screenPos = fragCoord.xy / iResolution.xy;\n\n    // Get the pixel's time\n    float time = iTime;\n\n    // Get the pixel's mouse position\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n\n    // Get the pixel's mouse velocity\n    vec2 mouseVel = iMouse.zw / iResolution.xy;\n\n    // Get the pixel's keyboard state\n    bool keyPressed = iKeyPressed == 1;\n\n    // Get the pixel's keyboard state\n    bool keyReleased = iKeyReleased == 1;\n\n    // Get the pixel's keyboard state\n    bool keyDown = iKeyDown == 1;\n\n    // Get the pixel's keyboard state\n    bool keyUp = iKeyUp == 1;\n\n    // Get the pixel's keyboard state\n    bool keyRepeat = iKeyRepeat == 1;\n\n    // Get the pixel's keyboard state\n    bool keyRepeatEnd = iKeyRepeatEnd == 1;\n\n    // Get the pixel's keyboard state\n    bool keyCtrl = iKeyCtrl == 1;\n\n    // Get the pixel's keyboard state\n    bool keyShift = iKeyShift == 1;\n\n    // Get the pixel's keyboard state\n    bool keyAlt = iKeyAlt == 1;\n\n    // Get the pixel's keyboard state\n    bool keySuper = iKeySuper == 1;\n\n    // Get the pixel's keyboard state\n    bool keyFn = iKeyFn == 1;\n\n    // Get the pixel's keyboard state\n    bool keyA = iKeyA == 1;\n\n    // Get the pixel's keyboard state\n    bool keyB = iKeyB == 1;\n\n    // Get the pixel's keyboard state\n    bool keyC = iKeyC == 1;\n\n    // Get the pixel's keyboard state\n    bool keyD = iKeyD == 1;\n\n    // Get the pixel's keyboard state\n    bool keyE = iKeyE == 1;\n\n    // Get the pixel's keyboard state\n    bool keyF = iKeyF == 1;\n\n    // Get the pixel's keyboard state\n    bool keyG = iKeyG == 1;\n\n    // Get the pixel's keyboard state\n    bool keyH = iKeyH == 1;\n\n    // Get the pixel's keyboard state\n    bool keyI = iKeyI == 1;\n\n    // Get the pixel's keyboard state\n    bool keyJ = iKeyJ == 1;\n\n    // Get the pixel's", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(float h, float s, float v) {\n    return rgb2hsv(vec3(h, s, v));\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(float r, float g, float b) {\n    return hsv2rgb(vec3(r, g, b));\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    return rgb2hsv(c.", "\n    p = fract(p);\n    p *= size;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod3(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    p -= 0.5;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod4(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    p -= 0.25;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod5(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    p -= 0.125;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod6(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    p -= 0.0625;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod7(inout float p, float size) {\n    p = fract(p);\n    p *= size;\n    p -= floor(p);\n    p -= 0.03125", "\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(double co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(long co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(unsigned long co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(long long co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(unsigned long long co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(char* co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(const char* co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::string co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::wstring co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<float> co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<double> co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<long> co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<unsigned long> co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<long long> co) {\n\treturn co;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(std::vector<unsigned long long> co) {\n\t", "\n\treturn pow(t, 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat sRGBInv(float t) {\n\treturn pow(t, 1.0 / 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat sRGBToLinear(float t) {\n\treturn t <= 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat linearToSRGB(float t) {\n\treturn t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat sRGBToLinear(vec3 t) {\n\treturn vec3(sRGBToLinear(t.x), sRGBToLinear(t.y), sRGBToLinear(t.z));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat linearToSRGB(vec3 t) {\n\treturn vec3(linearToSRGB(t.x), linearToSRGB(t.y), linearToSRGB(t.z));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nfloat sRGBToLinear(vec4 t) {\n\treturn vec4(sRGBToLinear(t.x), sRGBToLinear(t.y), sRGBToLinear(t.z), t.w);\n", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBInv(in vec3 c) {\n    return pow(c, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBToLinear(in vec3 c) {\n    return mix(c, sRGBInv(c), c.r * c.g * c.b < 0.04045? 0.0 : 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 linearToSRGB(in vec3 c) {\n    return mix(c, sRGB(c), c.r * c.g * c.b < 0.0031308? 0.0 : 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBToLinear(in vec3 c) {\n    return mix(c, sRGBInv(c), c.r * c.g * c.b < 0.04045? 0.0 : 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 linearToSRGB(in vec3 c) {\n    return mix(c, sRGB(c), c.r * c.g * c.b < 0.0031308? 0.0 : 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBToLinear(in vec3 c) {\n    return mix(c, sRGBInv(c), c.", "\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin.js\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n", "\n    vec3 sph_pos = sph.xyz;\n    float sph_rad = sph.w;\n    vec3 sph_norm = normalize(sph_pos);\n    float sph_dist = length(sph_pos);\n    float sph_dist2 = sph_dist * sph_dist;\n    float sph_rad2 = sph_rad * sph_rad;\n    float sph_rad3 = sph_rad2 * sph_rad;\n    float sph_rad4 = sph_rad3 * sph_rad;\n    float sph_rad5 = sph_rad4 * sph_rad;\n    float sph_rad6 = sph_rad5 * sph_rad;\n    float sph_rad7 = sph_rad6 * sph_rad;\n    float sph_rad8 = sph_rad7 * sph_rad;\n    float sph_rad9 = sph_rad8 * sph_rad;\n    float sph_rad10 = sph_rad9 * sph_rad;\n    float sph_rad11 = sph_rad10 * sph_rad;\n    float sph_rad12 = sph_rad11 * sph_rad;\n    float sph_rad13 = sph_rad12 * sph_rad;\n    float sph_rad14 = sph_rad13 * sph_rad;\n    float sph_rad15 = sph_rad14 * sph_rad;\n    float sph_rad16 = sph_rad15 * sph_rad;\n    float sph_rad17 = sph_rad16 * sph_rad;\n    float sph_rad18 = sph_rad17 * sph_rad;\n    float sph_rad19 = sph_rad18 * sph_rad;\n    float sph_rad20 = sph_rad19 * sph_rad;\n    float sph_rad21 = sph_rad20 * sph_rad;\n    float sph_rad22 = sph_rad21 * sph_rad;\n    float sph_rad23 = sph_rad22 * sph_", "\n\tvec4 q = vec4(0.0);\n\tfor (int i = 0; i < 10; i++) {\n\t\tq += vec4(0.0, 0.0, 0.0, 1.0) / pow(p.x, 2.0 + i);\n\t}\n\treturn vec4(q.x, q.y, q.z, 1.0);\n}\n\nvoid main() {\n\tvec4 p = vec4(gl_FragCoord.xy, 0.0, 1.0);\n\tp.x = p.x / iResolution.x * 2.0 - 1.0;\n\tp.y = p.y / iResolution.y * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tp = formula(p);\n\tp.x = p.x * 0.5 + 0.5;\n\tp.y = p.y * 0.5 + 0.5;\n\tp.z = p.z * 0.5 + 0.5;\n\tp.w = 1.0;\n\tgl_FragColor = p;\n}\n`;\n\nexport default shader;\n/src/shaders/shader-10.ts\nconst shader = `\n// \"\" fractal\n// https://www.shadertoy.com/view/Xsl3zN\n\n#define PI 3.1415926535897932384626433832795\n\nvec4 formula(vec4 p) {\n\tvec4 q = vec4(0.0);\n\tfor (int i = 0; i < 10; i++) {\n\t\tq += vec4(0.0, 0.0, 0.0, 1.0) / pow(p.x, 2.0 + i);\n\t}\n\treturn vec4(q.x, q.y, q.z, 1.0);\n}\n\nvoid main() {\n\tvec4 p = vec4(gl_FragCoord.xy,", "\n    vec3 q = p / r;\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q35 = q34 * q;\n    vec3 q36 = q35 * q;\n    vec3 q37 = q36 * q;\n    vec3 q38 = q37 * q;\n    vec3 q39 = q38 * q;\n    vec3 q40 = q39 * q;\n    vec3 q41 = q40 * q;\n   ", "\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front * (1.0 - back.a);\n}\n\n// License", "\n\treturn back + front.rgb * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n\treturn back + front * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, float front) {\n\treturn back + front * (1.0 - front);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n\treturn back + front * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, float alpha) {\n\treturn back + front.rgb * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n\treturn back + front * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, float front, float alpha) {\n\treturn back + front * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n\treturn back + front.rgb * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front) {\n\treturn back + front * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, float front) {\n\treturn back + front * (1.0 - front);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front, float alpha) {\n\treturn back + front * (1.0 - alpha);\n}", "\n    vec2 q = vec2(r, r);\n    vec2 q2 = vec2(r * 0.5, r * 0.5);\n    vec2 q3 = vec2(r * 0.25, r * 0.25);\n    vec2 q4 = vec2(r * 0.125, r * 0.125);\n    vec2 q5 = vec2(r * 0.0625, r * 0.0625);\n    vec2 q6 = vec2(r * 0.03125, r * 0.03125);\n    vec2 q7 = vec2(r * 0.015625, r * 0.015625);\n    vec2 q8 = vec2(r * 0.0078125, r * 0.0078125);\n    vec2 q9 = vec2(r * 0.00390625, r * 0.00390625);\n    vec2 q10 = vec2(r * 0.001953125, r * 0.001953125);\n    vec2 q11 = vec2(r * 0.0009765625, r * 0.0009765625);\n    vec2 q12 = vec2(r * 0.00048828125, r * 0.00048828125);\n    vec2 q13 = vec2(r * 0.000244140625, r * 0.000244140625);\n    vec2 q14 = vec2(r * 0.0001220703125, r * 0.0001220703125);\n    vec2 q15 = vec2(r * 0.00006103515625, r * 0.00006", "\n    vec3 v_lin = v * v * v * (v * (v * 0.18784374989423188 + 0.07527728447298646) + 0.2708855214151611);\n    return v_lin;\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 filmic_approx(vec3 v) {\n    vec3 v_lin = v * v * v * (v * (v * 0.2259036001380312 + 0.09997166666345518) + 0.2019876861740614);\n    return v_lin;\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx(vec3 v) {\n    vec3 v_lin = v * v * v * (v * (v * 0.2259036001380312 + 0.09997166666345518) + 0.2019876861740614);\n    return v_lin;\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 filmic_approx_2(vec3 v) {\n    vec3 v_lin = v * v * v * (v * (v * 0.2259036001380312 + 0.09997166666345518) + 0.2019876861740614);\n    return v_lin;\n}\n\n// License:", " return fract(sin(p)*vec2(12.9898,78.233)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash3(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash4(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash5(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash6(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash7(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash8(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash9(vec2 p) { return fract(sin(dot(p,vec2(12.9898,78.233)))*144269.421); }\n\n// License: Unknown, author: Unknown, found: don't remember", "\n    float c1 = 1.0 / 1.438775;\n    float c2 = 1.0 / 57.3;\n    float c3 = 1.0 / 10000000.0;\n    float c4 = 1.0 / 10000000000.0;\n    float c5 = 1.0 / 10000000000000.0;\n    float c6 = 1.0 / 10000000000000000.0;\n    float c7 = 1.0 / 10000000000000000000.0;\n    float c8 = 1.0 / 1000000000000000000000.0;\n    float c9 = 1.0 / 100000000000000000000000.0;\n    float c10 = 1.0 / 10000000000000000000000000.0;\n    float c11 = 1.0 / 1000000000000000000000000000.0;\n    float c12 = 1.0 / 100000000000000000000000000000.0;\n    float c13 = 1.0 / 10000000000000000000000000000000.0;\n    float c14 = 1.0 / 1000000000000000000000000000000000.0;\n    float c15 = 1.0 / 1000000000000000000000000", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = mix(mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x), mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);\n\n    // Smoothly interpolate between the four corners\n    return mix(a, mix(noise(i + vec2(1.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://shadertoy.com/view/XslGRr\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = mix(mix(noise(i), noise(i + vec3(1.0, 0.0, 0.0)), f.x), mix(noise(i + vec3(0.0, 1.0, 0.0)), noise(i + vec3(1.0, 1.0, 0.0)), f.x), f.y);\n\n    // Smoothly interpolate between the four corners\n    return mix(a, mix(noise(i + vec3(1.0, 1.0, 0.0)), noise(i + vec3(1.0, 1.0, 1.0)), f.x), f.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://shadertoy.com/view/XslGRr\nfloat noise(vec4 p) {\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = mix(mix(noise(i), noise(i + vec4(1.0, 0.0, 0.0, 0.0)), f.x), mix(noise(i + vec4(", "\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w;\n\tfloat discr = b * b - c;\n\tif (discr < 0.0) return vec2(-1.0);\n\treturn vec2(b - sqrt(discr), b + sqrt(discr));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sph) {\n\tvec3 oc = ro - sph;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - 1.0;\n\tfloat discr = b * b - c;\n\tif (discr < 0.0) return vec2(-1.0);\n\treturn vec2(b - sqrt(discr), b + sqrt(discr));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere(vec3 ro, vec3 rd, float sph) {\n\tvec3 oc = ro;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph * sph;\n\tfloat discr = b * b - c;\n\tif (discr < 0.0) return vec2(-1.0);\n\treturn vec2(b - sqrt(discr), b + sqrt(discr));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sph, float sph2) {\n\tvec3 oc = ro - sph;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph2;\n\tfloat discr = b * b - c;\n\tif (discr < 0.0) return vec2(-1.", "\n    vec2 q = abs(p) - vec2(n, n);\n    return vec3(length(max(q, 0.0)) - n, q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r)\n{\n    vec2 q = abs(p) - vec2(n, n);\n    return vec3(length(max(q, 0.0)) - n, q.x, q.y) / r;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float a)\n{\n    vec2 q = abs(p) - vec2(n, n);\n    return vec3(length(max(q, 0.0)) - n, q.x, q.y) / r * a;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float a, float b)\n{\n    vec2 q = abs(p) - vec2(n, n);\n    return vec3(length(max(q, 0.0)) - n, q.x, q.y) / r * a + b;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f", "\n\treturn ( 1.0f - cos( x * t ) ) * 0.5f;\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * t;\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv2( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * ( t * t - 1.0f );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv3( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * ( t * t * t - 3.0f * t );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv4( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * ( t * t * t * t - 6.0f * t * t + 3.0f );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv5( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * ( t * t * t * t * t - 10.0f * t * t * t + 15.0f * t * t - 5.0f );\n}\n\n// generalization of Devil's Staircase\nfloat cantor_deriv6( float x, float t )\n{\n\treturn ( 1.0f - cos( x * t ) ) * sin( x * t ) * ( t * t * t * t * t * t - 15.0f * t * t * t * t + 45.0f * t * t * t - 105.0f * t * t + 105.0f * t - 2", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length( p ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a )\n{\n\tvec2 q = p - c;\n\treturn length( q ) - r * cos( a * q.x * q.y );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a, in float b )\n{\n\tvec2 q = p - c;\n\treturn length( q ) - r * cos( a * q.x * q.y + b );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c )\n{\n\tvec2 q = p - c;\n\treturn length( q ) - r * cos( a * q.x * q.y + b * q.x + c );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a, in float b, in float c, in float d )\n{\n\tvec2 q = p - c;\n\treturn length( q ) - r * cos( a * q.x * q.", "\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr += pow(p.x, i) * pow(p.y, i) * pow(p.z, i) * pow(p.w, i);\n\t}\n\treturn r;\n}\n\n// main fractal func\nfloat map2(in vec3 p, int idx) {\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr += pow(p.x, i) * pow(p.y, i) * pow(p.z, i) * pow(p.w, i);\n\t}\n\treturn r;\n}\n\n// main fractal func\nfloat map3(in vec3 p, int idx) {\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr += pow(p.x, i) * pow(p.y, i) * pow(p.z, i) * pow(p.w, i);\n\t}\n\treturn r;\n}\n\n// main fractal func\nfloat map4(in vec3 p, int idx) {\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr += pow(p.x, i) * pow(p.y, i) * pow(p.z, i) * pow(p.w, i);\n\t}\n\treturn r;\n}\n\n// main fractal func\nfloat map5(in vec3 p, int idx) {\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr += pow(p.x, i) * pow(p.y, i) * pow(p.z, i) * pow(p.w, i);\n\t}\n\treturn r;\n}\n\n// main fractal func\nfloat map6(in vec3 p, int idx) {\n\tfloat r = 0.0;\n\t", "\n    float x2 = x * x;\n    float r = 0.0f;\n    r += x2 * 0.044715f;\n    r += x2 * -0.001009f;\n    r += x2 * 0.000007f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;\n    r += x2 * -0.000000f;\n    r += x2 * 0.000000f;", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y); }\nvec2 csqrt(vec2 z) { return vec2(sqrt(z.x), sqrt(z.y)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x), exp(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(z.x), log(z.y)); }\nvec2 csin(vec2 z) { return vec2(sin(z.x), sin(z.y)); }\nvec2 ccos(vec2 z) { return vec2(cos(z.x), cos(z.y)); }\nvec2 ctan(vec2 z) { return vec2(tan(z.x), tan(z.y)); }\nvec2 casin(vec2 z) { return vec2(asin(z.x), asin(z.y)); }\nvec2 cacos(vec2 z) { return vec2(acos(z.x), acos(z.y)); }\nvec2 catan(vec2 z) { return vec2(atan(z.x), atan(z.y)); }\nvec2 catan2(vec2 z, vec2 w) { return vec2(atan2(z.x, w.x), atan2(z.y, w.y)); }\nvec2 cpow(vec2 z, vec2 w) { return vec2(pow(z.x, w.x), pow(z.y, w.y)); }\nvec2 cabs(vec2 z) { return vec2(abs(z.x), abs(z.y)); }\nvec2 csign(vec2 z) { return vec2(sign(z.x), sign(z.y)); }\nvec2 cceil(vec2 z) { return vec2(ceil(z.x), ceil(z.y)); }\nvec", "\n\treturn log((z + 1.0f) / (z - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z) {\n\treturn log((z + 1.0f) / (z - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z) {\n\treturn log((z + 1.0f) / (z - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(mat2 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(mat3 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(mat4 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(mat2x3 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(mat2x4 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(mat3x2 m) {\n\treturn log((m + 1.0f) / (m - 1.0f)) / 2.0f;\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(mat3x4 m) {\n\treturn log((m + 1.0f) / (m - ", "\n\tvec2 t = exp(z);\n\treturn vec2(t.x, t.y * tanh(z.y));\n}\n\n// My own attempt at an csinh\nvec2 csinh(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * sinh(z.y), t.y);\n}\n\n// My own attempt at an ccosh\nvec2 ccosh(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x, t.y * cosh(z.y));\n}\n\n// My own attempt at an csin\nvec2 csin(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * sin(z.y), t.y * cos(z.y));\n}\n\n// My own attempt at an ccos\nvec2 ccos(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * cos(z.y), t.y * -sin(z.y));\n}\n\n// My own attempt at an ctan\nvec2 ctan(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * tan(z.y), t.y * (1.0 / cos(z.y)));\n}\n\n// My own attempt at an ccot\nvec2 ccot(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * (1.0 / tan(z.y)), t.y * -cos(z.y));\n}\n\n// My own attempt at an csec\nvec2 csec(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * (1.0 / cos(z.y)), t.y * (1.0 / sin(z.y)));\n}\n\n// My own attempt at an ccosec\nvec2 ccosec(vec2 z) {\n\tvec2 t = exp(z);\n\treturn vec2(t.x * -sin(z.y),", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y); }\nvec2 csqrt(vec2 z) { return vec2(sqrt(z.x), sqrt(z.y)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x), exp(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(z.x), log(z.y)); }\nvec2 csin(vec2 z) { return vec2(sin(z.x), sin(z.y)); }\nvec2 ccos(vec2 z) { return vec2(cos(z.x), cos(z.y)); }\nvec2 ctan(vec2 z) { return vec2(tan(z.x), tan(z.y)); }\nvec2 casin(vec2 z) { return vec2(asin(z.x), asin(z.y)); }\nvec2 cacos(vec2 z) { return vec2(acos(z.x), acos(z.y)); }\nvec2 catan(vec2 z) { return vec2(atan(z.x), atan(z.y)); }\nvec2 catan2(vec2 z, vec2 w) { return vec2(atan2(z.x, w.x), atan2(z.y, w.y)); }\nvec2 cpow(vec2 z, vec2 w) { return vec2(pow(z.x, w.x), pow(z.y, w.y)); }\nvec2 csinh(vec2 z) { return vec2(sinh(z.x), sinh(z.y)); }\nvec2 ccosh(vec2 z) { return vec2(cosh(z.x), cosh(z.y)); }\nvec2 ctanh(vec2 z) { return vec2(tanh(z.x), tanh(", "\n\tvec2 t = vec2(1.0, 1.0);\n\tvec2 e = vec2(1.0, 1.0);\n\tvec2 x = vec2(1.0, 1.0);\n\tvec2 y = vec2(1.0, 1.0);\n\tvec2 z2 = z * z;\n\tvec2 z4 = z2 * z2;\n\tvec2 z6 = z4 * z2;\n\tvec2 z8 = z6 * z2;\n\tvec2 z10 = z8 * z2;\n\tvec2 z12 = z10 * z2;\n\tvec2 z14 = z12 * z2;\n\tvec2 z16 = z14 * z2;\n\tvec2 z18 = z16 * z2;\n\tvec2 z20 = z18 * z2;\n\tvec2 z22 = z20 * z2;\n\tvec2 z24 = z22 * z2;\n\tvec2 z26 = z24 * z2;\n\tvec2 z28 = z26 * z2;\n\tvec2 z30 = z28 * z2;\n\tvec2 z32 = z30 * z2;\n\tvec2 z34 = z32 * z2;\n\tvec2 z36 = z34 * z2;\n\tvec2 z38 = z36 * z2;\n\tvec2 z40 = z38 * z2;\n\tvec2 z42 = z40 * z2;\n\tvec2 z44 = z42 * z2;\n\tvec2 z46 = z44 * z2;\n\tvec2 z48 = z46 * z2;\n\tvec2 z50 = z48 * z2;\n\tvec2 z52 = z50 * z2;\n\tvec2 z54 = z52 * z2;\n\tvec2 z56 = z54 * z2;\n\tvec2 z58 = z56 * z2;\n\tvec2 z60 = z58 * z2;\n", "\n    return vec4(smoothstep(0.5 - contrast, 0.5 + contrast, alpha), alpha.w);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(float alpha, float contrast) {\n    return vec4(smoothstep(0.5 - contrast, 0.5 + contrast, alpha), alpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(float alpha, float contrast, float min, float max) {\n    return vec4(smoothstep(min - contrast, max + contrast, alpha), alpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float min, float max) {\n    return vec4(smoothstep(min - contrast, max + contrast, alpha), alpha.w);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(float alpha, float contrast, vec4 min, vec4 max) {\n    return vec4(smoothstep(min.x - contrast, max.x + contrast, alpha), smoothstep(min.y - contrast, max.y + contrast, alpha), smoothstep(min.z - contrast, max.z + contrast, alpha), alpha.w);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, vec4 min, vec4 max", "\n\treturn length(p - vec3(0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec2 p) {\n\treturn length(p - vec2(0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec4 p) {\n\treturn length(p - vec4(0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec5 p) {\n\treturn length(p - vec5(0.0, 0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec6 p) {\n\treturn length(p - vec6(0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec7 p) {\n\treturn length(p - vec7(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec8 p) {\n\treturn length(p - vec8(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec9 p) {\n\treturn length(p - vec9(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Dodeca", "\n\tvec3 v = uvw;\n\tvec3 w = uvw;\n\tvec3 u = uvw;\n\tvec3 t = uvw;\n\tvec3 s = uvw;\n\tvec3 r = uvw;\n\tvec3 q = uvw;\n\tvec3 p = uvw;\n\tvec3 o = uvw;\n\tvec3 n = uvw;\n\tvec3 m = uvw;\n\tvec3 l = uvw;\n\tvec3 k = uvw;\n\tvec3 j = uvw;\n\tvec3 i = uvw;\n\tvec3 h = uvw;\n\tvec3 g = uvw;\n\tvec3 f = uvw;\n\tvec3 e = uvw;\n\tvec3 d = uvw;\n\tvec3 c = uvw;\n\tvec3 b = uvw;\n\tvec3 a = uvw;\n\tvec3 z = uvw;\n\tvec3 y = uvw;\n\tvec3 x = uvw;\n\tvec3 ww = uvw;\n\tvec3 vv = uvw;\n\tvec3 uu = uvw;\n\tvec3 tt = uvw;\n\tvec3 ss = uvw;\n\tvec3 rr = uvw;\n\tvec3 qq = uvw;\n\tvec3 pp = uvw;\n\tvec3 oo = uvw;\n\tvec3 nn = uvw;\n\tvec3 mm = uvw;\n\tvec3 ll = uvw;\n\tvec3 kk = uvw;\n\tvec3 jj = uvw;\n\tvec3 ii = uvw;\n\tvec3 hh = uvw;\n\tvec3 gg = uvw;\n\tvec3 ff = uvw;\n\tvec3 ee = uvw;\n\tvec3 dd = uvw;\n\tvec3 cc = uvw;\n\tvec3 bb = uvw;\n\tvec3 aa = uvw;\n\tvec3 zz = uvw;\n\tvec3 yy = uvw;\n\tvec3 xx = uvw;\n\tvec3 ww = uvw;\n\tvec3 vv = uvw;\n\tvec3 uu = uvw;\n\tvec3 tt = uvw;\n\tvec3 ss", "\n\tvec3 uvwOffset = uvw + offset;\n\tfloat u = uvwOffset.x;\n\tfloat v = uvwOffset.y;\n\tfloat w = uvwOffset.z;\n\tfloat u2 = u * u;\n\tfloat v2 = v * v;\n\tfloat w2 = w * w;\n\tfloat u3 = u2 * u;\n\tfloat v3 = v2 * v;\n\tfloat w3 = w2 * w;\n\tfloat u4 = u3 * u;\n\tfloat v4 = v3 * v;\n\tfloat w4 = w3 * w;\n\tfloat u5 = u4 * u;\n\tfloat v5 = v4 * v;\n\tfloat w5 = w4 * w;\n\tfloat u6 = u5 * u;\n\tfloat v6 = v5 * v;\n\tfloat w6 = w5 * w;\n\tfloat u7 = u6 * u;\n\tfloat v7 = v6 * v;\n\tfloat w7 = w6 * w;\n\tfloat u8 = u7 * u;\n\tfloat v8 = v7 * v;\n\tfloat w8 = w7 * w;\n\tfloat u9 = u8 * u;\n\tfloat v9 = v8 * v;\n\tfloat w9 = w8 * w;\n\tfloat u10 = u9 * u;\n\tfloat v10 = v9 * v;\n\tfloat w10 = w9 * w;\n\tfloat u11 = u10 * u;\n\tfloat v11 = v10 * v;\n\tfloat w11 = w10 * w;\n\tfloat u12 = u11 * u;\n\tfloat v12 = v11 * v;\n\tfloat w12 = w11 * w;\n\tfloat u13 = u12 * u;\n\tfloat v13 = v12 * v;\n\tfloat w13 = w12 * w;\n\tfloat u14 = u13 * u;\n\tfloat v14 = v13 * v;\n\tfloat w14 = w13 * w;\n\tfloat u15 = u14 * u;", "\n\tfloat gridSize = 1.0 / gridRes;\n\tfloat gridOffset = 0.5 * gridSize;\n\tfloat gridOffset2 = 0.5 * gridSize * contrast;\n\tfloat gridOffset3 = 0.5 * gridSize * contrast * contrast;\n\tfloat gridOffset4 = 0.5 * gridSize * contrast * contrast * contrast;\n\tfloat gridOffset5 = 0.5 * gridSize * contrast * contrast * contrast * contrast;\n\tfloat gridOffset6 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset7 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset8 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset9 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset10 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset11 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset12 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset13 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset14 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset15 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset16 = 0.5 * gridSize * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast * contrast;\n\tfloat gridOffset17 = 0.5", "\n\treturn length(p - vec3(0.0, 0.0, 0.0));\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec2 p) {\n\treturn length(p - vec2(0.0, 0.0));\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p) {\n\treturn abs(p);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q) {\n\treturn abs(p - q);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r) {\n\treturn abs(p - q - r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s) {\n\treturn abs(p - q - r - s);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s, float t) {\n\treturn abs(p - q - r - s - t);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s, float t, float u) {\n\treturn abs(p - q - r - s - t - u);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s, float t, float u, float v) {\n\treturn abs(p - q - r - s - t - u - v);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s, float t, float u, float v, float w) {\n\treturn abs(p - q - r - s - t - u - v - w);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p, float q, float r, float s, float t, float u, float v, float w, float x) {\n\treturn abs(p - q - r - s - t - u - v - w - x);\n}\n\n//", "\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Hot colormap with polynimal 6\nvec3 Hot(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Gray colormap with polynimal 6\nvec3 Gray(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Black colormap with polynimal 6\nvec3 Black(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes White colormap with polynimal 6\nvec3 White(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Red colormap with polynimal 6\nvec3 Red(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Green colormap with polynimal 6\nvec3 Green(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Blue colormap with polynimal 6\nvec3 Blue(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Yellow colormap with polynimal 6\nvec3 Yellow(float t) {\n\treturn vec3(pow(t, 2.2), pow(t, 2.2), pow(t, 2.2));\n}\n\n// makes Cyan colormap with polynimal 6\nvec3 Cyan", "\n\tvec3 s = sin(a);\n\tvec3 c = cos(a);\n\tvec3 t = 1.0 - c;\n\treturn vec3(\n\t\tv.x * (t.x * v.x + c) + v.y * (t.y * v.x + s.z) + v.z * (t.z * v.x - s.y),\n\t\tv.x * (t.y * v.x - s.z) + v.y * (t.x * v.y + s.x) + v.z * (t.z * v.y + s.y),\n\t\tv.x * (t.z * v.x + s.y) + v.y * (t.z * v.y - s.x) + v.z * (t.x * v.z + s.z)\n\t);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, float a)\n{\n\tvec3 s = sin(a);\n\tvec3 c = cos(a);\n\tvec3 t = 1.0 - c;\n\treturn vec3(\n\t\tv.x * (t.x * v.x + c) + v.y * (t.y * v.x + s.z) + v.z * (t.z * v.x - s.y),\n\t\tv.x * (t.y * v.x - s.z) + v.y * (t.x * v.y + s.x) + v.z * (t.z * v.y + s.y),\n\t\tv.x * (t.z * v.x + s.y) + v.y * (t.z * v.y - s.x) + v.z * (t.x * v.z + s.z)\n\t);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a, vec3 b)\n{\n", "\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co) {\n\treturn fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.455))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co) {\n\treturn fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 45.455, 1.0))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float p) {\n\treturn fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float p, float q) {\n\treturn fract(sin(p * 12.9898 + q * 78.233) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float p, float q, float r) {\n\treturn fract(sin(p * 12.9898 + q * 78.233 + r * 45.455) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float p, float q, float r, float s) {\n\treturn fract(sin(p * 12.9898 + q * 78.233 + r * 45.455 + s * 1.0) * 43", "\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\n// Hexagonal Distance from the 0,0 coords to the given coords\nfloat hexDist(vec2 p1, vec2 p2) {\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n// Hexagonal Distance from the 0,0 coords to the given coords\nfloat hexDist(vec3 p1, vec3 p2) {\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z));\n}\n\n// Hexagonal Distance from the 0,0 coords to the given coords\nfloat hexDist(vec4 p1, vec4 p2) {\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z) + (p1.w - p2.w) * (p1.w - p2.w));\n}\n\n// Hexagonal Distance from the 0,0 coords to the given coords\nfloat hexDist(vec5 p1, vec5 p2) {\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z) + (p1.w - p2.w) * (p1.w - p2.w) + (p1.v - p2.v) * (p1.v - p2.v", "\n\tvec2 p = vec2(0.0);\n\tvec2 q = vec2(0.0);\n\tvec2 r = vec2(0.0);\n\tvec2 s = vec2(0.0);\n\tvec2 t = vec2(0.0);\n\tvec2 u = vec2(0.0);\n\tvec2 v = vec2(0.0);\n\tvec2 w = vec2(0.0);\n\tvec2 x = vec2(0.0);\n\tvec2 y = vec2(0.0);\n\tvec2 z = vec2(0.0);\n\tvec2 a = vec2(0.0);\n\tvec2 b = vec2(0.0);\n\tvec2 c = vec2(0.0);\n\tvec2 d = vec2(0.0);\n\tvec2 e = vec2(0.0);\n\tvec2 f = vec2(0.0);\n\tvec2 g = vec2(0.0);\n\tvec2 h = vec2(0.0);\n\tvec2 i = vec2(0.0);\n\tvec2 j = vec2(0.0);\n\tvec2 k = vec2(0.0);\n\tvec2 l = vec2(0.0);\n\tvec2 m = vec2(0.0);\n\tvec2 n = vec2(0.0);\n\tvec2 o = vec2(0.0);\n\tvec2 p = vec2(0.0);\n\tvec2 q = vec2(0.0);\n\tvec2 r = vec2(0.0);\n\tvec2 s = vec2(0.0);\n\tvec2 t = vec2(0.0);\n\tvec2 u = vec2(0.0);\n\tvec2 v = vec2(0.0);\n\tvec2 w = vec2(0.0);\n\tvec2 x = vec2(0.0);\n\tvec2 y = vec2(0.0);\n\tvec2 z = vec2(0.0);\n\tvec2 a = vec2(0.0);\n\tvec2 b = vec2(0.0);\n\tvec2 c", "\n\treturn vec3(mix(vec3(0.2081, 0.1663, 0.5292), vec3(0.2116, 0.4284, 0.8571), t), mix(vec3(0.0593, 0.0559, 0.3105), vec3(0.2171, 0.4296, 0.8591), t), mix(vec3(0.1765, 0.0188, 0.3529), vec3(0.4275, 0.1559, 0.8591), t));\n}\n\n// makes magma colormap with polynimal 6 https://shadertoy.com/view/4dS3R2\nvec3 magma(float t) {\n\treturn vec3(mix(vec3(0.2081, 0.1663, 0.5292), vec3(0.2116, 0.4284, 0.8571), t), mix(vec3(0.0593, 0.0559, 0.3105), vec3(0.2171, 0.4296, 0.8591), t), mix(vec3(0.1765, 0.0188, 0.3529), vec3(0.4275, 0.1559, 0.8591), t));\n}\n\n// makes inferno colormap with polynimal 6 https://shadertoy.com/view/4dS3R2\nvec3 inferno(float t) {\n\treturn vec3(mix(vec3(0.2081, 0.1663, 0.5292), vec3(0.2116, 0.4284, 0.8571), t), mix(vec3(0.0593, 0.0559, 0", "\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1Neg1to1(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to10(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1Neg1to10(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to100(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1Neg1to100(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1000(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1Neg1to1000(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to10000(float x) {\n\treturn (x * 2) - 1;\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1Neg1to10000(float x) {\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to100000(float x)", "\n\tfloat t = time * 0.001;\n\tfloat x = uv.x * gridRes;\n\tfloat y = uv.y * gridRes;\n\tfloat z = 0.0;\n\tfloat r = sqrt(x * x + y * y);\n\tfloat theta = atan(y, x);\n\tfloat phi = atan(z, r);\n\tfloat u = sin(theta + t) * cos(phi + t);\n\tfloat v = sin(theta + t) * sin(phi + t);\n\tfloat w = cos(theta + t);\n\tfloat d = len * 0.5;\n\tfloat u1 = u * d;\n\tfloat v1 = v * d;\n\tfloat w1 = w * d;\n\tfloat u2 = u * d * 0.5;\n\tfloat v2 = v * d * 0.5;\n\tfloat w2 = w * d * 0.5;\n\tfloat u3 = u * d * 0.25;\n\tfloat v3 = v * d * 0.25;\n\tfloat w3 = w * d * 0.25;\n\tfloat u4 = u * d * 0.125;\n\tfloat v4 = v * d * 0.125;\n\tfloat w4 = w * d * 0.125;\n\tfloat u5 = u * d * 0.0625;\n\tfloat v5 = v * d * 0.0625;\n\tfloat w5 = w * d * 0.0625;\n\tfloat u6 = u * d * 0.03125;\n\tfloat v6 = v * d * 0.03125;\n\tfloat w6 = w * d * 0.03125;\n\tfloat u7 = u * d * 0.015625;\n\tfloat v7 = v * d * 0.015625;\n\tfloat w7 = w * d * 0.015625;\n\tfloat u8 = u * d * 0.0078125;\n\t", "\n\tfloat t = time * 0.001;\n\tfloat r = 0.001;\n\tfloat d = 0.0001;\n\tfloat s = 0.0001;\n\tfloat a = 0.0001;\n\tfloat b = 0.0001;\n\tfloat c = 0.0001;\n\tfloat d = 0.0001;\n\tfloat e = 0.0001;\n\tfloat f = 0.0001;\n\tfloat g = 0.0001;\n\tfloat h = 0.0001;\n\tfloat i = 0.0001;\n\tfloat j = 0.0001;\n\tfloat k = 0.0001;\n\tfloat l = 0.0001;\n\tfloat m = 0.0001;\n\tfloat n = 0.0001;\n\tfloat o = 0.0001;\n\tfloat p = 0.0001;\n\tfloat q = 0.0001;\n\tfloat r = 0.0001;\n\tfloat s = 0.0001;\n\tfloat t = 0.0001;\n\tfloat u = 0.0001;\n\tfloat v = 0.0001;\n\tfloat w = 0.0001;\n\tfloat x = 0.0001;\n\tfloat y = 0.0001;\n\tfloat z = 0.0001;\n\tfloat aa = 0.0001;\n\tfloat bb = 0.0001;\n\tfloat cc = 0.0001;\n\tfloat dd = 0.0001;\n\tfloat ee = 0.0001;\n\tfloat ff = 0.0001;\n\tfloat gg = 0.0001;\n\tfloat hh = 0.0001;\n\tfloat ii = 0.0001;\n\tfloat jj =", "\n\tfloat angle = time * 2 * PI;\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float speed) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float speed, float scale) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float speed, float scale, float offset) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float speed, float scale, float offset, float strength) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float speed, float scale, float offset, float strength, float strength2) {\n\tfloat x = radius * cos(angle);\n\tfloat y = radius * sin(angle);\n\treturn vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow", "\n\treturn vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(int x, int y) {\n\treturn vec2(floor(x / TILE_SIZE), floor(y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(int x, int y, int z) {\n\treturn vec2(floor(x / TILE_SIZE), floor(y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec3 arrowTileCenterCoord(vec3 pos) {\n\treturn vec3(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE), floor(pos.z / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec3 arrowTileCenterCoord(int x, int y, int z) {\n\treturn vec3(floor(x / TILE_SIZE), floor(y / TILE_SIZE), floor(z / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec4 arrowTileCenterCoord(vec4 pos) {\n\treturn vec4(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE), floor(pos.z / TILE_SIZE), floor(pos.w / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec4 arrowTileCenterCoord(int x, int y, int z, int w) {\n\treturn vec4(floor(x / TILE_SIZE), floor(y / TILE_SIZE), floor(z / TILE_SIZE), floor(w / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, int z) {\n\treturn vec2(floor(pos.x / TILE_SIZE), floor(pos.y / TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(int x, int y, int z) {\n\treturn vec2(floor(x / TILE_SIZE),", "\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat c1 = dot(w, v);\n\tif (c1 <= 0) return length(w);\n\tfloat c2 = dot(v, v);\n\tif (c2 <= c1) return length(p2 - p);\n\tfloat b = c1 / c2;\n\tvec2 Pb = p1 + b * v;\n\treturn length(w - Pb);\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 v0 = c - a;\n\tvec2 v1 = b - a;\n\tvec2 v2 = p - a;\n\tfloat dot00 = dot(v0, v0);\n\tfloat dot01 = dot(v0, v1);\n\tfloat dot02 = dot(v0, v2);\n\tfloat dot11 = dot(v1, v1);\n\tfloat dot12 = dot(v1, v2);\n\tfloat invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n\tfloat u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tfloat v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\tif (u < 0 || v < 0 || u + v > 1) return length(p - a);\n\treturn length(cross(v0, v2) * invDenom);\n}\n\n// Computes the signed distance from a quad\nfloat quad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n\tvec2 v0 = c - a;\n\tvec2 v1 = b - a;\n\tvec2 v2 = d - a;\n\tvec2 v3 = d - c;\n\tvec2 v4 = p - a;\n\tfloat dot00 = dot(v0, v0);\n\tfloat dot01 = dot(v0, v1);\n\tfloat dot02 = dot(v0", "\n\tfloat arrowLength = 0.05;\n\tfloat arrowWidth = 0.02;\n\tfloat arrowHeight = 0.01;\n\tfloat arrowTipLength = 0.01;\n\tfloat arrowTipWidth = 0.005;\n\tfloat arrowTipHeight = 0.005;\n\tfloat arrowTipRadius = 0.0025;\n\tfloat arrowTipRadius2 = arrowTipRadius * arrowTipRadius;\n\tfloat arrowTipRadius3 = arrowTipRadius2 * arrowTipRadius;\n\tfloat arrowTipRadius4 = arrowTipRadius3 * arrowTipRadius;\n\tfloat arrowTipRadius5 = arrowTipRadius4 * arrowTipRadius;\n\tfloat arrowTipRadius6 = arrowTipRadius5 * arrowTipRadius;\n\tfloat arrowTipRadius7 = arrowTipRadius6 * arrowTipRadius;\n\tfloat arrowTipRadius8 = arrowTipRadius7 * arrowTipRadius;\n\tfloat arrowTipRadius9 = arrowTipRadius8 * arrowTipRadius;\n\tfloat arrowTipRadius10 = arrowTipRadius9 * arrowTipRadius;\n\tfloat arrowTipRadius11 = arrowTipRadius10 * arrowTipRadius;\n\tfloat arrowTipRadius12 = arrowTipRadius11 * arrowTipRadius;\n\tfloat arrowTipRadius13 = arrowTipRadius12 * arrowTipRadius;\n\tfloat arrowTipRadius14 = arrowTipRadius13 * arrowTipRadius;\n\tfloat arrowTipRadius15 = arrowTipRadius14 * arrowTipRadius;\n\tfloat arrowTipRadius16 = arrowTipRadius15 * arrowTipRadius;\n\tfloat arrowTipRadius17 = arrowTipRadius16 * arrowTipRadius;\n\tfloat arrowTipRadius18 = arrowTipRadius17 * arrowTipRadius;\n\tfloat arrowTipRadius19 = arrowTipRadius18 * arrowTipRadius;\n\tfloat arrowTipRadius20 = arrowTipRadius19 * arrowTipRadius;\n\tfloat arrowTipRadius21 = arrowTipRadius20 * arrowTipRadius;\n\tfloat arrowTipRadius22 = arrowTipRadius21 * arrowTipRadius;\n\tfloat arrowTipRadius23 = arrowTipRadius22 * arrowTipRadius;\n\tfloat arrowTipRadius24 = arrowTipRadius23 * arrowTipRadius;\n", "\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x) {\n\treturn (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make1to0(vec2 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec3 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make1to1(vec3 x) {\n\treturn (x * 2.0) - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec3 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec4 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make1to1(vec4 x) {\n\treturn (x * 2.0) - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec4 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(mat2 x) {\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make1to1(mat2 x) {\n\treturn (x * 2.0) - 1.0;\n}\n\n//shifts value range from 0-1 to -", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float donutRadius = radius + spread;\n    float donutAngle = angle + offset;\n    float donutX = cos(donutAngle) * donutRadius;\n    float donutY = sin(donutAngle) * donutRadius;\n    return vec2(donutX, donutY);\n}\n\n// makes a simple flowmap in the shape of a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius)\n{\n    float angle = atan(point.y, point.x);\n    float donutAngle = angle + offset;\n    float donutX = cos(donutAngle) * radius;\n    float donutY = sin(donutAngle) * radius;\n    return vec2(donutX, donutY);\n}\n\n// makes a simple flowmap in the shape of a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle)\n{\n    float donutAngle = angle + offset;\n    float donutX = cos(donutAngle) * radius;\n    float donutY = sin(donutAngle) * radius;\n    return vec2(donutX, donutY);\n}\n\n// makes a simple flowmap in the shape of a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleSpread)\n{\n    float donutAngle = angle + offset + angleSpread * sin(angle);\n    float donutX = cos(donutAngle) * radius;\n    float donutY = sin(donutAngle) * radius;\n    return vec2(donutX, donutY);\n}\n\n// makes a simple flowmap in the shape of a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float angle, float angleSpread, float angleOffset)\n{\n    float donutAngle = angle + offset + angleSpread * sin(angle + angleOffset);\n    float donutX = cos(donutAngle) * radius;\n    float donutY = sin(donutAngle", "\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( in vec4 p, in vec4 b ) \n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 c ) \n{\n\tvec2 d = abs(p)-b;\n\treturn length(max(d,c-d));\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in vec3 c ) \n{\n\tvec3 d = abs(p)-b;\n\treturn length(max(d,c-d));\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in vec4 c ) \n{\n\tvec4 d = abs(p)-b;\n\treturn length(max(d,c-d));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec2 p, in vec2 c ) \n{\n\treturn length(p)-c.x;\n}\n\nfloat sdCone( in vec3 p, in vec3 c ) \n{\n\treturn length(p)-c.x;\n}\n\nfloat sdCone( in vec4 p, in vec4 c ) \n{\n\treturn length(p)-c.x;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec2 p, in vec2 c, in vec2 a ) \n{\n\tvec2 d = abs(p)-c;\n\treturn length(max(d,a-d));\n}\n\nfloat sdCone( in vec3 p, in vec3 c, in vec3 a ) \n{\n\tvec3 d = abs(p)-c;\n\treturn length(max(d,a-d));\n}\n\nfloat sdCone( in vec4 p, in vec4 c, in vec4 a ) \n{\n\t", "\n\tfloat sd = 0.0;\n\tfloat sd2 = 0.0;\n\tfloat sd3 = 0.0;\n\tfloat sd4 = 0.0;\n\tfloat sd5 = 0.0;\n\tfloat sd6 = 0.0;\n\tfloat sd7 = 0.0;\n\tfloat sd8 = 0.0;\n\tfloat sd9 = 0.0;\n\tfloat sd10 = 0.0;\n\tfloat sd11 = 0.0;\n\tfloat sd12 = 0.0;\n\tfloat sd13 = 0.0;\n\tfloat sd14 = 0.0;\n\tfloat sd15 = 0.0;\n\tfloat sd16 = 0.0;\n\tfloat sd17 = 0.0;\n\tfloat sd18 = 0.0;\n\tfloat sd19 = 0.0;\n\tfloat sd20 = 0.0;\n\tfloat sd21 = 0.0;\n\tfloat sd22 = 0.0;\n\tfloat sd23 = 0.0;\n\tfloat sd24 = 0.0;\n\tfloat sd25 = 0.0;\n\tfloat sd26 = 0.0;\n\tfloat sd27 = 0.0;\n\tfloat sd28 = 0.0;\n\tfloat sd29 = 0.0;\n\tfloat sd30 = 0.0;\n\tfloat sd31 = 0.0;\n\tfloat sd32 = 0.0;\n\tfloat sd33 = 0.0;\n\tfloat sd34 = 0.0;\n\tfloat sd35 = 0.0;\n\tfloat sd36 = 0.0;\n\tfloat sd37 = 0.0;\n\tfloat sd38 = 0.0;\n\tfloat sd39 = 0.0;\n\tfloat sd40 = 0.0;\n\tfloat sd41 = 0.0;\n\tfloat sd42 = 0.0;\n\tfloat sd43 = 0.0;\n\tfloat sd44", "\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r )\n{\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r, r);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r, float r2 )\n{\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r, r2);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r, float r2, float r3 )\n{\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r, r2, r3);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r, float r2, float r3, float r4 )\n{\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r, r2, r3, r4);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r, float r2, float r3, float r4, float r5 )\n{\n\tfloat t = time * sp;\n\tfloat r = ra * (1.0 + sin(t));\n\treturn sdCircle(p, r, r2, r3, r4, r5);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r, float r2, float r3, float r4, float r5,", "\n\treturn max(abs(uvw.x), max(abs(uvw.y), abs(uvw.z)));\n}\n\n//edge distance of a Tetrahedron\nfloat tetraDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Octahedron\nfloat octaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Icosahedron\nfloat icosaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Dodecahedron\nfloat dodecaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Dodecahedron\nfloat dodecaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Dodecahedron\nfloat dodecaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a Dodecahedron\nfloat dodecaDist(vec3 uvw) {\n\treturn max(abs(uvw.x), max(abs(uvw.y), max(abs(uvw.z), abs(uvw.x + uvw.y + uvw.z))));\n}\n\n//edge distance of a", "\n    vec3 v = abs(uvw);\n    vec3 t = 1.0 - v;\n    vec3 r = 1.0 - uvw;\n    vec3 s = 1.0 - v;\n    vec3 q = 1.0 - uvw;\n    vec3 p = 1.0 - uvw;\n    vec3 o = 1.0 - uvw;\n    vec3 n = 1.0 - uvw;\n    vec3 m = 1.0 - uvw;\n    vec3 l = 1.0 - uvw;\n    vec3 k = 1.0 - uvw;\n    vec3 j = 1.0 - uvw;\n    vec3 i = 1.0 - uvw;\n    vec3 h = 1.0 - uvw;\n    vec3 g = 1.0 - uvw;\n    vec3 f = 1.0 - uvw;\n    vec3 e = 1.0 - uvw;\n    vec3 d = 1.0 - uvw;\n    vec3 c = 1.0 - uvw;\n    vec3 b = 1.0 - uvw;\n    vec3 a = 1.0 - uvw;\n    vec3 z = 1.0 - uvw;\n    vec3 y = 1.0 - uvw;\n    vec3 x = 1.0 - uvw;\n    vec3 w = 1.0 - uvw;\n    vec3 v = 1.0 - uvw;\n    vec3 u = 1.0 - uvw;\n    vec3 t = 1.0 - uvw;\n    vec3 s = 1.0 - uvw;\n    vec3 r = 1.0 - uvw;\n    vec3 q = 1.0 - uvw;\n    vec3 p = 1.0 - uvw;\n    vec3 o = 1.0 - uvw;\n    vec3 n = 1.0 - uvw;\n    vec3 m = 1.0 - uvw;\n    vec3 l = 1.0 - uvw;\n    vec3 k = 1.0 - uvw;\n    vec3 j = 1.0 - uvw;\n    vec3 i = 1.0 - uvw;\n    vec3 h = 1.0 - u", "\n\tvec3 cell = floor(uvw * gridRes);\n\tvec3 cellOffset = uvw * gridRes - cell;\n\tvec3 cellOffsetScaled = cellOffset * offset;\n\treturn vec4(cell, cellOffsetScaled);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes) {\n\treturn cubeCell(uvw, vec3(1.0), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset) {\n\treturn cubeCell(uvw, vec3(offset), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, vec3 offset) {\n\treturn cubeCell(uvw, offset, gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset, float offset2) {\n\treturn cubeCell(uvw, vec3(offset, offset2), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset, float offset2, float offset3) {\n\treturn cubeCell(uvw, vec3(offset, offset2, offset3), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset, float offset2, float offset3, float offset4) {\n\treturn cubeCell(uvw, vec3(offset, offset2, offset3, offset4), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset, float offset2, float offset3, float offset4, float offset5) {\n\treturn cubeCell(uvw, vec3(offset, offset2, offset3, offset4, offset5), gridRes);\n}\n\n// returns the cell and offset for the given uvw\nvec4 cubeCell(vec3 uvw, float gridRes, float offset, float offset2, float offset3, float", "\n    return vec3(\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000, 0.000000), vec3(0.000000, 0.000000, 0.000000), t),\n        mix(vec3(0.000000, 0.000000", "\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, cubocEdge[i]));\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p, vec3 q) {\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, q, cubocEdge[i]));\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p, vec3 q, vec3 r) {\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, q, r, cubocEdge[i]));\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p, vec3 q, vec3 r, vec3 s) {\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, q, r, s, cubocEdge[i]));\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t) {\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, q, r, s, t, cubocEdge[i]));\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p, vec3 q, vec3 r, vec3 s, vec3 t, vec3 u) {\n\tfloat d = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\td = max(d, distance(p, q, r,", "\n\treturn vec3(pow(t, 6.0));\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n\treturn vec3(pow(t, 6.0));\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n\treturn vec3(pow(t, 6.0));\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n\treturn vec3(pow(t, 6.0));\n}\n\n// makes color map with polynimal 6\nvec3 colorMap(float t) {\n\tif (t < 0.25) {\n\t\treturn winter(t * 4.0);\n\t}\n\telse if (t < 0.5) {\n\t\treturn spring((t - 0.25) * 4.0);\n\t}\n\telse if (t < 0.75) {\n\t\treturn summer((t - 0.5) * 4.0);\n\t}\n\telse {\n\t\treturn autumn((t - 0.75) * 4.0);\n\t}\n}\n\n// makes color map with polynimal 6\nvec3 colorMap(float t, float t2) {\n\tif (t < 0.25) {\n\t\treturn winter(t * 4.0);\n\t}\n\telse if (t < 0.5) {\n\t\treturn spring((t - 0.25) * 4.0);\n\t}\n\telse if (t < 0.75) {\n\t\treturn summer((t - 0.5) * 4.0);\n\t}\n\telse {\n\t\treturn autumn((t - 0.75) * 4.0);\n\t}\n}\n\n// makes color map with polynimal 6\nvec3 colorMap(float t, float t2, float t3) {\n\tif (t < 0.25) {\n\t\treturn winter(t * 4.0);\n\t}\n\telse if (t < 0.5) {", "\n\tvec2 tile = floor(uv * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec3 squareTile(vec3 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec3 squareTile(vec4 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec4 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec2 uv) {\n\tvec2 tile = floor(uv * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec3 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec4 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec2 uv) {\n\tvec2 tile = floor(uv * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec3 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec4 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec2 uv) {\n\tvec2 tile = floor(uv * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec3 uv) {\n\tvec2 tile = floor(uv.xy * 2.0);\n\treturn tile;\n}\n\n// simple square Tiling\nvec4 squareTile(vec4 uv) {\n\tvec2 tile = floor(uv.xy * 2.0", "\n\tvec2 p = uv * 2.0 - 1.0;\n\tvec2 q = abs(p);\n\tvec2 r = max(q.x, q.y);\n\treturn vec3(r, 1.0 - r, 1.0 - r);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec3 uv) {\n\tvec3 p = uv * 2.0 - 1.0;\n\tvec3 q = abs(p);\n\tvec3 r = max(q.x, max(q.y, q.z));\n\treturn vec3(r, 1.0 - r, 1.0 - r);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec4 uv) {\n\tvec4 p = uv * 2.0 - 1.0;\n\tvec4 q = abs(p);\n\tvec4 r = max(q.x, max(q.y, max(q.z, q.w)));\n\treturn vec3(r, 1.0 - r, 1.0 - r);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(ivec2 uv) {\n\tvec2 p = uv * 2.0 - 1.0;\n\tvec2 q = abs(p);\n\tvec2 r = max(q.x, q.y);\n\treturn vec3(r, 1.0 - r, 1.0 - r);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(ivec3 uv) {\n\tvec3 p = uv * 2.0 - 1.0;\n\tvec3 q = abs(p);\n\tvec3 r = max(q.x, max(q.y, q.z));\n\treturn vec3(r, 1.0 - r, 1.0 - r);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(ivec4 uv) {\n\tvec4 p = uv * 2.0 - 1.0;\n\tvec4 q", "\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale) {\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0) * scale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float offsetScale) {\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0) * scale + offsetScale;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float offsetScale, float offsetScale2) {\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0) * scale + offsetScale + offsetScale2;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float offsetScale, float offsetScale2, float offsetScale3) {\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0) * scale + offsetScale + offsetScale2 + offsetScale3;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float offsetScale, float offsetScale2, float offsetScale3, float offsetScale4) {\n\tvec2 grid = floor(uv * gridRes) + offset;\n\treturn vec3(grid.x, grid.y, 0.0) * scale + offsetScale + offsetScale2 + offsetScale3 + offsetScale4;\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float", "\n\tvec2 grid = floor(uv * gridRes);\n\tvec2 gridFrac = fract(uv * gridRes);\n\tvec2 gridFrac2 = gridFrac * gridFrac;\n\tvec2 gridFrac3 = gridFrac2 * gridFrac;\n\tvec2 gridFrac4 = gridFrac3 * gridFrac;\n\tvec2 gridFrac5 = gridFrac4 * gridFrac;\n\tvec2 gridFrac6 = gridFrac5 * gridFrac;\n\tvec2 gridFrac7 = gridFrac6 * gridFrac;\n\tvec2 gridFrac8 = gridFrac7 * gridFrac;\n\tvec2 gridFrac9 = gridFrac8 * gridFrac;\n\tvec2 gridFrac10 = gridFrac9 * gridFrac;\n\tvec2 gridFrac11 = gridFrac10 * gridFrac;\n\tvec2 gridFrac12 = gridFrac11 * gridFrac;\n\tvec2 gridFrac13 = gridFrac12 * gridFrac;\n\tvec2 gridFrac14 = gridFrac13 * gridFrac;\n\tvec2 gridFrac15 = gridFrac14 * gridFrac;\n\tvec2 gridFrac16 = gridFrac15 * gridFrac;\n\tvec2 gridFrac17 = gridFrac16 * gridFrac;\n\tvec2 gridFrac18 = gridFrac17 * gridFrac;\n\tvec2 gridFrac19 = gridFrac18 * gridFrac;\n\tvec2 gridFrac20 = gridFrac19 * gridFrac;\n\tvec2 gridFrac21 = gridFrac20 * gridFrac;\n\tvec2 gridFrac22 = gridFrac21 * gridFrac;\n\tvec2 gridFrac23 = gridFrac22 * gridFrac;\n\tvec2 gridFrac24 = gridFrac23 * gridFrac;\n\tvec2 gridFrac25 = gridFrac24 * gridFrac;\n\tvec2 gridFrac26 = gridFrac25 * gridFrac;\n\tvec2 gridFrac27 = gridFrac26 * gridFrac;\n\tvec2 gridFrac28 = gridFrac27 * gridFrac;\n\tvec2 gridFrac29 = gridFrac28 * gridFrac;\n\tvec2 gridFrac30 = gridFrac29 * gridFrac;\n\tvec2 gridFrac31 =", "\n\tfloat t = time * 0.001;\n\tfloat x = uv.x * gridRes;\n\tfloat y = uv.y * gridRes;\n\tfloat x0 = floor(x);\n\tfloat y0 = floor(y);\n\tfloat x1 = x0 + 1.0;\n\tfloat y1 = y0 + 1.0;\n\tfloat u = x - x0;\n\tfloat v = y - y0;\n\tfloat u1 = 1.0 - u;\n\tfloat v1 = 1.0 - v;\n\tfloat w00 = u1 * v1;\n\tfloat w01 = u * v1;\n\tfloat w10 = u1 * v;\n\tfloat w11 = u * v;\n\tfloat dx00 = w00 * (x1 - x0);\n\tfloat dy00 = w00 * (y1 - y0);\n\tfloat dx01 = w01 * (x1 - x0);\n\tfloat dy01 = w01 * (y1 - y0);\n\tfloat dx10 = w10 * (x1 - x0);\n\tfloat dy10 = w10 * (y1 - y0);\n\tfloat dx11 = w11 * (x1 - x0);\n\tfloat dy11 = w11 * (y1 - y0);\n\tfloat d00 = w00 * (dx00 + dy00);\n\tfloat d01 = w01 * (dx01 + dy01);\n\tfloat d10 = w10 * (dx10 + dy10);\n\tfloat d11 = w11 * (dx11 + dy11);\n\tfloat d0 = w00 * d00 + w01 * d01;\n\tfloat d1 = w10 * d10 + w11 * d11;\n\tfloat d = w00 * d0 + w01 * d1;\n\tfloat f = sin(d * len + t);\n\treturn f;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float grid", "\n\tfloat t = time * 0.001;\n\tfloat r = gridRes * 0.5;\n\tfloat x = uv.x * r;\n\tfloat y = uv.y * r;\n\tfloat z = len * 0.5;\n\tfloat w = 0.0;\n\tfloat h = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat e = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n", "\n\tvec2 uv = p;\n\tvec2 uv0 = floor(uv);\n\tvec2 uv1 = uv0 + vec2(1.0);\n\tvec2 uv2 = uv0 + vec2(1.0, 0.0);\n\tvec2 uv3 = uv0 + vec2(0.0, 1.0);\n\tvec2 uv4 = uv0 + vec2(1.0, 1.0);\n\tvec2 uv5 = uv0 + vec2(0.5);\n\tvec2 uv6 = uv0 + vec2(0.5, 0.5);\n\tvec2 uv7 = uv0 + vec2(0.5, 0.0);\n\tvec2 uv8 = uv0 + vec2(0.0, 0.5);\n\tvec2 uv9 = uv0 + vec2(0.25);\n\tvec2 uv10 = uv0 + vec2(0.25, 0.25);\n\tvec2 uv11 = uv0 + vec2(0.25, 0.0);\n\tvec2 uv12 = uv0 + vec2(0.0, 0.25);\n\tvec2 uv13 = uv0 + vec2(0.75);\n\tvec2 uv14 = uv0 + vec2(0.75, 0.75);\n\tvec2 uv15 = uv0 + vec2(0.75, 0.0);\n\tvec2 uv16 = uv0 + vec2(0.0, 0.75);\n\tvec2 uv17 = uv0 + vec2(0.5, 0.5);\n\tvec2 uv18 = uv0 + vec2(0.5, 0.0);\n\tvec2 uv19 = uv0 + vec2(0.0, 0.5);\n\tvec2 uv20 = uv0 + vec2(0.25, 0.25);\n\tvec2 uv21 = uv0 + vec2(0.25, 0.0);\n\tvec2 uv22 = uv0 + vec2(0.0, 0.25);\n\t", "\n\tfloat a = atan(p.y, p.x);\n\tfloat b = atan(r, r);\n\tfloat c = a - b;\n\tfloat d = a + b;\n\tfloat e = abs(c) - PI;\n\tfloat f = abs(d) - PI;\n\tfloat g = abs(e) + abs(f);\n\treturn g;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float a) {\n\tfloat b = atan(p.y, p.x);\n\tfloat c = b - a;\n\tfloat d = b + a;\n\tfloat e = abs(c) - PI;\n\tfloat f = abs(d) - PI;\n\tfloat g = abs(e) + abs(f);\n\treturn g;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float a, float b) {\n\tfloat c = atan(p.y, p.x);\n\tfloat d = c - a;\n\tfloat e = c + a;\n\tfloat f = c - b;\n\tfloat g = c + b;\n\tfloat h = abs(d) - PI;\n\tfloat i = abs(e) - PI;\n\tfloat j = abs(f) - PI;\n\tfloat k = abs(g) - PI;\n\tfloat l = abs(h) + abs(i) + abs(j) + abs(k);\n\treturn l;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float a, float b, float c) {\n\tfloat d = atan(p.y, p.x);\n\tfloat e = d - a;\n\tfloat f = d + a", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return i + u;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile_grad(inout vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return i + u;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile_grad_2(inout vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return i + u;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile_grad_3(inout vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return i + u;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile_grad_4(inout vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return i + u;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile_grad_5(inout vec2 p)", "\n\treturn 0.5 * ( 1.0 + sin( 10.0 * x ) );\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 p = 2.0 * uv - 1.0;\n\tvec2 q = p * iResolution.xy / iResolution.x;\n\tvec2 r = q * q;\n\tvec2 s = r * q;\n\tvec2 t = s * q;\n\tvec2 u = t * q;\n\tvec2 v = u * q;\n\tvec2 w = v * q;\n\tvec2 x = w * q;\n\tvec2 y = x * q;\n\tvec2 z = y * q;\n\tvec2 a = z * q;\n\tvec2 b = a * q;\n\tvec2 c = b * q;\n\tvec2 d = c * q;\n\tvec2 e = d * q;\n\tvec2 f = e * q;\n\tvec2 g = f * q;\n\tvec2 h = g * q;\n\tvec2 i = h * q;\n\tvec2 j = i * q;\n\tvec2 k = j * q;\n\tvec2 l = k * q;\n\tvec2 m = l * q;\n\tvec2 n = m * q;\n\tvec2 o = n * q;\n\tvec2 p = o * q;\n\tvec2 q = p * q;\n\tvec2 r = q * q;\n\tvec2 s = r * q;\n\tvec2 t = s * q;\n\tvec2 u = t * q;\n\tvec2 v = u * q;\n\tvec2 w = v * q;\n\tvec2 x = w * q;\n\tvec2 y = x * q;\n\tvec2 z = y * q;\n\tvec2 a = z * q;\n\tvec2 b = a * q;\n\tvec2 c = b * q;\n\tvec2 d = c * q;\n\tvec2 e = d * q;\n\tvec2 f = e * q;\n\tvec2 g = f * q;\n\tvec2", "\n    return pow(t, vec3(1.0/2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBInv(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBToLinear(vec3 t) {\n    return mix(pow(t, vec3(2.2)), t, t <= vec3(0.04045));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 linearToSRGB(vec3 t) {\n    return mix(pow(t, vec3(1.0/2.2)), t * (1.0/12.92) + vec3(0.055), t < vec3(0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGBToLinear(vec3 t) {\n    return mix(pow(t, vec3(2.2)), t * (1.0/12.92) + vec3(0.055), t < vec3(0.04045));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 linearToSRGB(vec3 t) {\n    return mix(pow(t, vec3(1.0/2.2)), t * (1.0/12.92) + vec3(0.055), t < vec3(0.0031308));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n    return", "\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df8(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10.0 * p.x + 10.0 * p.y));\n}\n\n// Classic truchet pattern\nfloat df9(vec2 p) {\n\treturn 0.5 * (1.0 + sin(10", "\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1 * (1.0 - abs(p.x - 0.5) - abs(p.y - 0.5));\n\t}\n\treturn a;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1 * (1.0 - abs(p.x - 0.5) - abs(p.y - 0.5));\n\t}\n\treturn a;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1 * (1.0 - abs(p.x - 0.5) - abs(p.y - 0.5));\n\t}\n\treturn a;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1 * (1.0 - abs(p.x - 0.5) - abs(p.y - 0.5));\n\t}\n\treturn a;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1 * (1.0 - abs(p.x - 0.5) - abs(p.y - 0.5));\n\t}\n\treturn a;\n}\n\n// Multiscale truchet\nfloat df6(vec2 p) {\n\tfloat a = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\ta += 0.1", "\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tfloat a = dot(e0, e0);\n\tfloat b = dot(e0, e1);\n\tfloat c = dot(e0, e2);\n\tfloat d = dot(e1, e1);\n\tfloat e = dot(e1, e2);\n\tfloat f = dot(e2, e2);\n\n\tfloat D = a*d - b*c;\n\tfloat s = b*f - c*e;\n\tfloat t = a*e - b*d;\n\n\tfloat invD = 1.0 / D;\n\ts *= invD;\n\tt *= invD;\n\n\tfloat u = s;\n\tfloat v = t;\n\tfloat w = 1.0 - s - t;\n\n\tfloat d0 = dot(v0, v0);\n\tfloat d1 = dot(v1, v1);\n\tfloat d2 = dot(v2, v2);\n\n\tfloat d01 = d0 + d1;\n\tfloat d02 = d0 + d2;\n\tfloat d12 = d1 + d2;\n\n\tfloat d012 = d01 + d2;\n\tfloat d021 = d02 + d1;\n\tfloat d120 = d12 + d0;\n\n\tfloat d0123 = d012 + d120;\n\n\tfloat d0123_s = d0123 * s;\n\tfloat d0123_t = d0123 * t;\n\tfloat d0123_w = d0123 * w;\n\n\tfloat d0123_s_d0 = d0123_s * d0;\n\tfloat d0123_s_d1 = d0123_s * d1;\n\tfloat d0123_s_d2", "\n\tvec3 ro2 = ro - sph.xyz;\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(rd, ro2);\n\tfloat c = dot(ro2, ro2) - sph.w * sph.w;\n\tfloat d = b * b - a * c;\n\tif (d < 0.0) return 0.0;\n\td = sqrt(d);\n\tfloat t0 = (-b - d) / a;\n\tfloat t1 = (-b + d) / a;\n\tif (t0 > t1) { float tmp = t1; t1 = t0; t0 = tmp; }\n\tif (t0 < 0.0) { t0 = t1; if (t0 < 0.0) return 0.0; }\n\tif (t1 > dbuffer) return 0.0;\n\treturn 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphered_grad(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\tvec3 ro2 = ro - sph.xyz;\n\tfloat a = dot(rd, rd);\n\tfloat b = dot(rd, ro2);\n\tfloat c = dot(ro2, ro2) - sph.w * sph.w;\n\tfloat d = b * b - a * c;\n\tif (d < 0.0) return 0.0;\n\td = sqrt(d);\n\tfloat t0 = (-b - d) / a;\n\tfloat t1 = (-b + d) / a;\n\tif (t0 > t1) { float tmp = t1; t1 = t0; t0 = tmp; }\n\tif (t0 < 0.0) { t0 = t1; if (t0 < 0.0) return 0.0; }\n\tif (t1 > dbuffer) return 0.0;\n\treturn 1.0;\n}\n\n// License: MIT, author: Inigo Qu", "\n\tfloat d = length(p);\n\tfloat a = atan(p.y, p.x);\n\tfloat a0 = a - r;\n\tfloat a1 = a + r;\n\tfloat d0 = d * cos(a0);\n\tfloat d1 = d * cos(a1);\n\tfloat d2 = d * cos(a);\n\tfloat d3 = d * cos(a - w);\n\tfloat d4 = d * cos(a + w);\n\tfloat d5 = d * cos(a - 2.0 * w);\n\tfloat d6 = d * cos(a + 2.0 * w);\n\tfloat d7 = d * cos(a - 3.0 * w);\n\tfloat d8 = d * cos(a + 3.0 * w);\n\tfloat d9 = d * cos(a - 4.0 * w);\n\tfloat d10 = d * cos(a + 4.0 * w);\n\tfloat d11 = d * cos(a - 5.0 * w);\n\tfloat d12 = d * cos(a + 5.0 * w);\n\tfloat d13 = d * cos(a - 6.0 * w);\n\tfloat d14 = d * cos(a + 6.0 * w);\n\tfloat d15 = d * cos(a - 7.0 * w);\n\tfloat d16 = d * cos(a + 7.0 * w);\n\tfloat d17 = d * cos(a - 8.0 * w);\n\tfloat d18 = d * cos(a + 8.0 * w);\n\tfloat d19 = d * cos(a - 9.0 * w);\n\tfloat d20 = d * cos(a + 9.0 * w);\n\tfloat d21 = d * cos(a - 10.0 * w);\n\tfloat d22 = d * cos(a + 10.0 * w);\n\tfloat d23 = d * cos(a - 11.0 * w);\n\tfloat d24 = d * cos(a + 11.0 * w);\n\tfloat", "\n\treturn 1.0 / (1.0 + k * k * (p.x * p.x + p.y * p.y));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n\treturn 1.0 / (1.0 + k * k * (p.x * p.x + p.y * p.y + p.z * p.z));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\n\treturn 1.0 / (1.0 + k * k * (p.x * p.x + p.y * p.y + p.z * p.z + p.w * p.w));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, in vec2 k )\n{\n\treturn 1.0 / (1.0 + k.x * k.x * (p.x * p.x + p.y * p.y) + k.y * k.y * (p.x * p.x + p.y * p.y));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, in vec3 k )\n{\n\treturn 1.0 / (1.0 + k.x * k.x * (p.x * p.x + p.y * p.y + p.z * p.z) + k.y * k.y * (p.x * p.x + p.y * p.y + p.z * p.z) + k.z * k.z * (p.x * p.x + p.y * p.y + p.z * p.z));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, in vec4 k )\n{\n\treturn 1.0 / (1.0 + k.x * k.x * (p.x * p.x + p.y * p.y + p.z * p.z + p", "\n\treturn length(p.xy) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOY( in vec2 p )\n{\n\treturn length(p.yx) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOZ( in vec2 p )\n{\n\treturn length(p.zy) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p )\n{\n\treturn length(p.zy) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in vec3 p )\n{\n\treturn length(p.zy) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in vec4 p )\n{\n\treturn length(p.zy) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in float p )\n{\n\treturn length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in float p, in float q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in float p, in vec2 q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in float p, in vec3 q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in float p, in vec4 q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p, in float q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOO( in vec2 p, in vec2 q )\n{\n\treturn length(p - q) - 1.0;\n}\n\n// distance", "\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n\treturn a + k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n\treturn b - k * (b - a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/", "\n    return a < 0.0? -a : a;\n}\n\nfloat pmin(float a, float b) {\n    return a < b? a : b;\n}\n\nfloat pmax(float a, float b) {\n    return a > b? a : b;\n}\n\nfloat pclamp(float a, float min, float max) {\n    return pmin(pmax(a, min), max);\n}\n\nfloat pmix(float a, float b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nfloat psmoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat psmoothstep(float edge0, float edge1, float x, float k) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t) * k;\n}\n\nfloat psmoothstep(float x, float k) {\n    float t = clamp(x, 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t) * k;\n}\n\nfloat psmoothstep(float x) {\n    float t = clamp(x, 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat psmoothstep(float x, float min, float max) {\n    float t = clamp((x - min) / (max - min), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nfloat psmoothstep(float x, float min, float max, float k) {\n    float t = clamp((x - min) / (max - min), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t) * k;\n}\n\n", "\n\tfloat a = 0.5;\n\tfloat b = 0.25;\n\tfloat c = 0.125;\n\tfloat d = 0.0625;\n\tfloat e = 0.03125;\n\tfloat f = 0.015625;\n\tfloat g = 0.0078125;\n\tfloat h = 0.00390625;\n\tfloat i = 0.001953125;\n\tfloat j = 0.0009765625;\n\tfloat k = 0.00048828125;\n\tfloat l = 0.000244140625;\n\tfloat m = 0.0001220703125;\n\tfloat n = 0.00006103515625;\n\tfloat o = 0.000030517578125;\n\tfloat p = 0.0000152587890625;\n\tfloat q = 0.00000762939453125;\n\tfloat r = 0.000003814697265625;\n\tfloat s = 0.0000019073486328125;\n\tfloat t = 0.00000095367431640625;\n\tfloat u = 0.000000476837158203125;\n\tfloat v = 0.0000002384185791015625;\n\tfloat w = 0.00000011920928955078125;\n\tfloat x = 0.000000059604644775390", "\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash17(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash18(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758", "\n\tvec2 AB = B - A;\n\tvec2 BC = C - B;\n\tvec2 AC = C - A;\n\tvec2 p = pos - A;\n\tvec2 q = p - AB;\n\tvec2 r = q - BC;\n\tvec2 s = r - AC;\n\tvec2 t = s - AB;\n\tvec2 u = t - BC;\n\tvec2 v = u - AC;\n\tvec2 w = v - AB;\n\tvec2 x = w - BC;\n\tvec2 y = x - AC;\n\tvec2 z = y - AB;\n\tvec2 yz = z - BC;\n\treturn vec3(y, z, yz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C )\n{\n\tvec3 AB = B - A;\n\tvec3 BC = C - B;\n\tvec3 AC = C - A;\n\tvec3 p = pos - A;\n\tvec3 q = p - AB;\n\tvec3 r = q - BC;\n\tvec3 s = r - AC;\n\tvec3 t = s - AB;\n\tvec3 u = t - BC;\n\tvec3 v = u - AC;\n\tvec3 w = v - AB;\n\tvec3 x = w - BC;\n\tvec3 y = x - AC;\n\tvec3 z = y - AB;\n\tvec3 yz = z - BC;\n\treturn vec3(y, z, yz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec4 pos, in vec4 A, in vec4 B, in", "\n    vec2 p = pos.xy;\n    float d = p.x * p.x + p.y * p.y;\n    float h = he * 0.5;\n    float w = wi * 0.5;\n    float f = d - w * w;\n    return vec3(f, 2.0 * p.x, 2.0 * p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec2 pos, in float wi, in float he )\n{\n    vec2 p = pos.xy;\n    float d = p.x * p.x + p.y * p.y + p.y * p.y;\n    float h = he * 0.5;\n    float w = wi * 0.5;\n    float f = d - w * w;\n    return vec3(f, 2.0 * p.x, 2.0 * p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid2( in vec2 pos, in float wi, in float he )\n{\n    vec2 p = pos.xy;\n    float d = p.x * p.x + p.y * p.y + p.x * p.x;\n    float h = he * 0.5;\n    float w = wi * 0.5;\n    float f = d - w * w;\n    return vec3(f, 2.0 * p.x, 2.0 * p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p", "\n    vec2 p = pos - vec2(k, 0.0);\n    return vec3(p.x, p.y, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec2 pos, in float k )\n{\n    vec2 p = pos - vec2(k, 0.0);\n    return vec3(p.x, p.y, p.x);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec3 pos, in float k )\n{\n    vec3 p = pos - vec3(k, 0.0, 0.0);\n    return vec3(p.x, p.y, p.x);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec3 pos, in float k, in float m )\n{\n    vec3 p = pos - vec3(k, 0.0, 0.0);\n    return vec3(p.x, p.y, p.x + m * p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec3 pos, in float k, in float m, in float n )\n{\n    vec3 p = pos -", "\n\tvec2 q = p - vec2(d,0);\n\tfloat a = length(q);\n\tfloat b = ra + rb;\n\tfloat c = ra - rb;\n\tfloat d = a*a - b*b;\n\tfloat e = a*a - c*c;\n\tfloat f = a*a - d*d;\n\tfloat g = a*a - e*e;\n\tfloat h = a*a - f*f;\n\tfloat i = a*a - g*g;\n\tfloat j = a*a - h*h;\n\tfloat k = a*a - i*i;\n\tfloat l = a*a - j*j;\n\tfloat m = a*a - k*k;\n\tfloat n = a*a - l*l;\n\tfloat o = a*a - m*m;\n\tfloat p = a*a - n*n;\n\tfloat q = a*a - o*o;\n\tfloat r = a*a - p*p;\n\tfloat s = a*a - q*q;\n\tfloat t = a*a - r*r;\n\tfloat u = a*a - s*s;\n\tfloat v = a*a - t*t;\n\tfloat w = a*a - u*u;\n\tfloat x = a*a - v*v;\n\tfloat y = a*a - w*w;\n\tfloat z = a*a - x*x;\n\tfloat A = a*a - z*z;\n\tfloat B = a*a - y*y;\n\tfloat C = a*a - x*x;\n\tfloat D = a*a - w*w;\n\tfloat E = a*a - v*v;\n\tfloat F = a*a - u*u;\n\tfloat G = a*a - t*t;\n\tfloat H = a*a - s*s;\n\tfloat I = a*a - r*r;\n\tfloat J = a*a - q*q;\n\tfloat K = a*a - p*p;\n\tfloat L = a*a - o*o;\n\tfloat M = a*a - n*n;\n\t", "\n\tv = v * 0x196608b;\n\tv = v ^ (v >> 11);\n\tv = v * 0x85ebca6b;\n\tv = v ^ (v >> 15);\n\tv = v * 0xc2b2ae35;\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg3(ivec2 v)\n{\n\tv = v * 0x196608b;\n\tv = v ^ (v >> 11);\n\tv = v * 0x85ebca6b;\n\tv = v ^ (v >> 15);\n\tv = v * 0xc2b2ae35;\n\tv = v ^ (v >> 11);\n\tv = v * 0x196608b;\n\tv = v ^ (v >> 11);\n\tv = v * 0x85ebca6b;\n\tv = v ^ (v >> 15);\n\tv = v * 0xc2b2ae35;\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg4(ivec2 v)\n{\n\tv = v * 0x196608b;\n\tv = v ^ (v >> 11);\n\tv = v * 0x85ebca6b;\n\tv = v ^ (v >> 15);\n\tv = v * 0xc2b2ae35;\n\tv = v ^ (v >> 11);\n\tv = v * 0x196608b;\n\tv = v ^ (v >> 11);\n\tv = v * 0x85ebca6b;\n\tv = v ^ (v >> 15);\n\tv = v * ", "\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 a)\n{\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v + a;\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 a, ivec3 b)\n{\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v + a;\n\tv = v + b;\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 a, ivec3 b, ivec3 c)\n{\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v * 0x8469f965;\n\tv = v ^ (v >> 16);\n\tv = v + a;\n\tv = v + b;\n\tv = v + c;\n\treturn v;\n", "\n\treturn length(pos - bezier(A, B, C));\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n\treturn length(pos - bezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdQuadraticBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n\treturn length(pos - quadraticBezier(A, B, C));\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n\treturn length(pos - cubicBezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdQuadraticBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n\treturn length(pos - quadraticBezier(A, B, C));\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n\treturn length(pos - cubicBezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdQuadraticBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n\treturn length(pos - quadraticBezier(A, B, C));\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n\treturn length(pos - cubicBezier(A, B, C, D));\n}\n\n// signed distance to a quadratic bezier\nfloat sdQuadraticBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n\treturn length(pos - quadraticBezier(A, B, C));\n}\n\n// signed distance to a cubic bezier\nfloat sdCubicBezier", "\n    return (b.x - a.x) * p.y - (b.y - a.y) * p.x;\n}\n\nfloat winding_sign(in vec3 p, in vec3 a, in vec3 b) {\n    return (b.x - a.x) * p.y - (b.y - a.y) * p.x + (b.z - a.z) * p.x;\n}\n\nfloat winding_sign(in vec4 p, in vec4 a, in vec4 b) {\n    return (b.x - a.x) * p.y - (b.y - a.y) * p.x + (b.z - a.z) * p.x + (b.w - a.w) * p.x;\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) * winding_sign(p, b, c);\n}\n\nfloat winding_sign(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    return winding_sign(p, a, b) * winding_sign(p, b, c);\n}\n\nfloat winding_sign(in vec4 p, in vec4 a, in vec4 b, in vec4 c) {\n    return winding_sign(p, a, b) * winding_sign(p, b, c);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) * winding_sign(p, b, c, d);\n}\n\nfloat winding_sign(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return winding_sign(p, a, b, c) * winding_sign(p, b, c, d);\n}\n\nfloat winding_sign(in vec4 p, in vec4 a, in vec4 b, in vec4 c,", "\n    vec3 p = ro + rd*s.x;\n    vec3 n = normalize( cross( rd, s.yzw ) );\n    float d = dot( n, p );\n    if( d < 0.0 ) return vec4( 0.0, 0.0, 0.0, 0.0 );\n    return vec4( s.x, n, d );\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s, inout float t )\n{\n    vec3 p = ro + rd*t;\n    vec3 n = normalize( cross( rd, s.yzw ) );\n    float d = dot( n, p );\n    if( d < 0.0 ) return vec4( 0.0, 0.0, 0.0, 0.0 );\n    return vec4( t, n, d );\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s, inout float t, inout float u )\n{\n    vec3 p = ro + rd*t;\n    vec3 n = normalize( cross( rd, s.yzw ) );\n    float d = dot( n, p );\n    if( d < 0.0 ) return vec4( 0.0, 0.0, 0.0, 0.0 );\n    u = dot( n, s.yzw );\n    return vec4( t, n, d );\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in", "\n\tfloat ret = a*b+x;\n\tret_n = ret;\n\treturn fract(ret);\n}\n\n// https://www.shadertoy.com/view/4sB3zN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32_2 (out int ret_n, int a, float b, float x) {\n\tfloat ret = a*b+x;\n\tret_n = ret;\n\treturn fract(ret);\n}\n\n// https://www.shadertoy.com/view/4sB3zN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32_3 (out int ret_n, int a, float b, float x) {\n\tfloat ret = a*b+x;\n\tret_n = ret;\n\treturn fract(ret);\n}\n\n// https://www.shadertoy.com/view/4sB3zN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32_4 (out int ret_n, int a, float b, float x) {\n\tfloat ret = a*b+x;\n\tret_n = ret;\n\treturn fract(ret);\n}\n\n// https://www.shadertoy.com/view/4sB3zN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)", "\n\tvec3 c = a - b;\n\tfloat d = length(c);\n\tif ( d < k ) return vec3(0.0);\n\treturn normalize(c) * k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n\tvec3 c = a - b;\n\tfloat d = length(c);\n\tif ( d < k ) return vec3(0.0);\n\treturn normalize(c) * k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMin( in vec3 a, in vec3 b, in vec3 k )\n{\n\tvec3 c = a - b;\n\tfloat d = length(c);\n\tif ( d < k.x ) return vec3(0.0);\n\tif ( d < k.y ) return vec3(0.0);\n\tif ( d < k.z ) return vec3(0.0);\n\treturn normalize(c) * k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in vec3 k )\n{\n\tvec3 c = a - b;\n\tfloat d = length(c);\n\tif ( d < k.x ) return vec3(0.0);\n\tif ( d < k.y ) return vec3(0.0);\n\tif", "\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = sqrt(a*a + b*b);\n\tfloat d = sqrt(a*a - b*b);\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat x_ = x/c;\n\tfloat y_ = y/d;\n\tfloat x_2 = x_*x_;\n\tfloat y_2 = y_*y_;\n\tfloat x_3 = x_2*x_;\n\tfloat y_3 = y_2*y_;\n\tfloat x_4 = x_3*x_;\n\tfloat y_4 = y_3*y_;\n\tfloat x_5 = x_4*x_;\n\tfloat y_5 = y_4*y_;\n\tfloat x_6 = x_5*x_;\n\tfloat y_6 = y_5*y_;\n\tfloat x_7 = x_6*x_;\n\tfloat y_7 = y_6*y_;\n\tfloat x_8 = x_7*x_;\n\tfloat y_8 = y_7*y_;\n\tfloat x_9 = x_8*x_;\n\tfloat y_9 = y_8*y_;\n\tfloat x_10 = x_9*x_;\n\tfloat y_10 = y_9*y_;\n\tfloat x_11 = x_10*x_;\n\tfloat y_11 = y_10*y_;\n\tfloat x_12 = x_11*x_;\n\tfloat y_12 = y_11*y_;\n\tfloat x_13 = x_12*x_;\n\tfloat y_13 = y_12*y_;\n\tfloat x_14 = x_13*x_;\n\tfloat y_14 = y_13*y_;\n\tfloat x_15 = x_14*x_;\n\tfloat y_15 = y_14*y_;\n\tfloat x_16 = x_15*x_;\n\tfloat y_16 = y_15*y_;\n\tfloat x_17 = x_16*x", "\n\treturn a + b;\n}\n\n//precision loss testing\nfloat sub_ploss(in float a, in float b){\n\treturn a - b;\n}\n\n//precision loss testing\nfloat mul_ploss(in float a, in float b){\n\treturn a * b;\n}\n\n//precision loss testing\nfloat div_ploss(in float a, in float b){\n\treturn a / b;\n}\n\n//precision loss testing\nfloat mod_ploss(in float a, in float b){\n\treturn a % b;\n}\n\n//precision loss testing\nfloat pow_ploss(in float a, in float b){\n\treturn pow(a, b);\n}\n\n//precision loss testing\nfloat sqrt_ploss(in float a){\n\treturn sqrt(a);\n}\n\n//precision loss testing\nfloat exp_ploss(in float a){\n\treturn exp(a);\n}\n\n//precision loss testing\nfloat log_ploss(in float a){\n\treturn log(a);\n}\n\n//precision loss testing\nfloat log2_ploss(in float a){\n\treturn log2(a);\n}\n\n//precision loss testing\nfloat log10_ploss(in float a){\n\treturn log10(a);\n}\n\n//precision loss testing\nfloat sin_ploss(in float a){\n\treturn sin(a);\n}\n\n//precision loss testing\nfloat cos_ploss(in float a){\n\treturn cos(a);\n}\n\n//precision loss testing\nfloat tan_ploss(in float a){\n\treturn tan(a);\n}\n\n//precision loss testing\nfloat asin_ploss(in float a){\n\treturn asin(a);\n}\n\n//precision loss testing\nfloat acos_ploss(in float a){\n\treturn acos(a);\n}\n\n//precision loss testing\nfloat atan_ploss(in float a){\n\treturn atan(a);\n}\n\n//precision loss testing\nfloat atan2_ploss(in float a, in float b){\n\treturn atan2(a, b);\n}\n\n//precision loss testing\nfloat sinh_ploss(in float a){\n\treturn", "\n\tvec2 sols = vec2(0.0, 0.0);\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = s1;\n\tfloat d = s2;\n\tfloat e = p.x;\n\tfloat f = p.y;\n\tfloat g = a*a;\n\tfloat h = b*b;\n\tfloat i = 2.0*a*c;\n\tfloat j = 2.0*b*d;\n\tfloat k = c*c;\n\tfloat l = d*d;\n\tfloat m = 2.0*a*e;\n\tfloat n = 2.0*b*f;\n\tfloat o = e*e;\n\tfloat p = f*f;\n\tfloat q = g+h;\n\tfloat r = i+j;\n\tfloat s = k+l;\n\tfloat t = m+n;\n\tfloat u = o+p;\n\tfloat v = q*s;\n\tfloat w = r*t;\n\tfloat x = u*v;\n\tfloat y = 2.0*a*b*c*d;\n\tfloat z = 2.0*a*b*e*f;\n\tfloat A = 2.0*a*b*c*d;\n\tfloat B = 2.0*a*b*e*f;\n\tfloat C = 2.0*a*b*c*d;\n\tfloat D = 2.0*a*b*e*f;\n\tfloat E = 2.0*a*b*c*d;\n\tfloat F = 2.0*a*b*e*f;\n\tfloat G = 2.0*a*b*c*d;\n\tfloat H = 2.0*a*b*e*f;\n\tfloat I = 2.0*a*b*c*d;\n\tfloat J = 2.0*a*b*e*f;\n\tfloat K = 2.0*a*b*c*d;\n\tfloat L = 2.0*a*b*e*f;\n\tfloat M = 2", "\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    float ab2 = dot(ab, ab);\n    float apab = dot(ap, ab);\n    float apab2 = apab * apab;\n    float ab2ra2 = ab2 * ra * ra;\n    float ab2rb2 = ab2 * rb * rb;\n    float apab2ra2 = apab2 * ra * ra;\n    float apab2rb2 = apab2 * rb * rb;\n    float apab2ra2rb2 = apab2ra2 * rb2;\n    float apab2rb2ra2 = apab2rb2 * ra2;\n    float apab2ra2rb2ra2 = apab2ra2rb2 * ra2;\n    float apab2rb2ra2rb2 = apab2rb2ra2 * rb2;\n    float apab2ra2rb2ra2rb2 = apab2ra2rb2ra2 * rb2;\n    float apab2ra2rb2ra2rb2ra2 = apab2ra2rb2ra2rb2 * ra2;\n    float apab2ra2rb2ra2rb2ra2rb2 = apab2ra2rb2ra2rb2ra2 * rb2;\n    float apab2ra2rb2ra2rb2ra2rb2ra2 = apab2ra2rb2ra2rb2ra2rb2 * ra2;\n    float apab2ra2rb2ra2rb2ra2rb2ra2rb2 = apab2ra2rb2ra2rb2ra2rb2ra2 * rb2;\n    float apab2ra2rb2ra2rb2ra2rb2ra2rb2ra2 = apab2ra2rb2ra2rb2ra2rb2ra2rb2 * ra2;\n    float apab2ra2rb2ra2rb2ra2rb2ra2rb2ra2rb2 = apab2ra2rb2ra2rb2ra2rb2ra2rb2ra2 * rb2;\n    float apab2ra2rb2ra2rb2ra2rb2ra2rb2ra2rb2rb2 = apab2ra2rb2ra2rb2ra2rb2", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 hp = a + h * ba;\n\treturn length( p - hp ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 hp = a + h * ba;\n\treturn length( p - hp ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 hp = a + h * ba;\n\treturn length( p - hp ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 hp = a + h * ba;\n\treturn length( p - hp ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 a, float r )\n{\n\treturn length( p - a ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec3 a, vec3 n )\n{\n\treturn", "\n\treturn length( p - cen ) - rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 bmin, vec3 bmax )\n{\n\tvec3 d = abs( p ) - bmin;\n\tvec3 e = bmax - abs( p );\n\treturn min( max( d.x, max( d.y, d.z ) ), min( e.x, min( e.y, e.z ) ) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 cen, float rad, float h )\n{\n\tvec2 d = vec2( length( p.xz - cen.xz ), p.y - cen.y );\n\treturn length( d ) - rad - h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec3 cen, float rad, float h )\n{\n\tvec2 d = vec2( length( p.xz - cen.xz ), p.y - cen.y );\n\treturn length( d ) - rad - h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec3 cen, float rad, float r )\n{\n\tvec2 d = vec2( length( p.xz - cen.xz ), p.y - cen.y );\n\treturn length( d ) - rad - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec3 cen, float rad, float r, float h )\n{\n\tvec2 d = vec2( length( p.xz - cen.xz ), p.y - cen.y );\n\treturn length( d ) - rad - r - h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec3 cen, float rad, float r, float h, float phi )\n{\n\tvec2 d = vec", "\n\tvec3 normal = vec3(0.0);\n\tif( showSurface )\n\t{\n\t\tnormal = vec3(0.0);\n\t}\n\telse\n\t{\n\t\tfloat eps = 0.0001;\n\t\tvec3 p1 = pos + vec3( eps, 0.0, 0.0 );\n\t\tvec3 p2 = pos + vec3( -eps, 0.0, 0.0 );\n\t\tvec3 p3 = pos + vec3( 0.0, eps, 0.0 );\n\t\tvec3 p4 = pos + vec3( 0.0, -eps, 0.0 );\n\t\tvec3 p5 = pos + vec3( 0.0, 0.0, eps );\n\t\tvec3 p6 = pos + vec3( 0.0, 0.0, -eps );\n\t\tfloat d1 = distance( p1, samplePoint );\n\t\tfloat d2 = distance( p2, samplePoint );\n\t\tfloat d3 = distance( p3, samplePoint );\n\t\tfloat d4 = distance( p4, samplePoint );\n\t\tfloat d5 = distance( p5, samplePoint );\n\t\tfloat d6 = distance( p6, samplePoint );\n\t\tnormal = normalize( vec3( d1, d2, d3 ) - vec3( d4, d5, d6 ) );\n\t}\n\treturn normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat calcSDF( in vec3 pos, in vec3 normal, in vec3 samplePoint )\n{\n\tfloat dist = distance( pos, samplePoint );\n\tfloat dot = dot( normal, samplePoint - pos );\n\treturn dist - dot;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat calcSDF( in vec3 pos, in vec3 normal, in vec3 samplePoint, in float radius )\n{\n\tfloat dist = distance( pos, samplePoint );\n\tfloat dot = dot( normal, samplePoint - pos );\n\treturn dist - dot - radius;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nfloat calcSDF", "\n\tfloat softShadow = 0.0;\n\tfloat softShadowSum = 0.0;\n\tfloat softShadowSumWeight = 0.0;\n\tfloat softShadowSumWeight2 = 0.0;\n\tfloat softShadowSumWeight3 = 0.0;\n\tfloat softShadowSumWeight4 = 0.0;\n\tfloat softShadowSumWeight5 = 0.0;\n\tfloat softShadowSumWeight6 = 0.0;\n\tfloat softShadowSumWeight7 = 0.0;\n\tfloat softShadowSumWeight8 = 0.0;\n\tfloat softShadowSumWeight9 = 0.0;\n\tfloat softShadowSumWeight10 = 0.0;\n\tfloat softShadowSumWeight11 = 0.0;\n\tfloat softShadowSumWeight12 = 0.0;\n\tfloat softShadowSumWeight13 = 0.0;\n\tfloat softShadowSumWeight14 = 0.0;\n\tfloat softShadowSumWeight15 = 0.0;\n\tfloat softShadowSumWeight16 = 0.0;\n\tfloat softShadowSumWeight17 = 0.0;\n\tfloat softShadowSumWeight18 = 0.0;\n\tfloat softShadowSumWeight19 = 0.0;\n\tfloat softShadowSumWeight20 = 0.0;\n\tfloat softShadowSumWeight21 = 0.0;\n\tfloat softShadowSumWeight22 = 0.0;\n\tfloat softShadowSumWeight23 = 0.0;\n\tfloat softShadowSumWeight24 = 0.0;\n\tfloat softShadowSumWeight25 = 0.0;\n\tfloat softShadowSumWeight26 = 0.0;\n\tfloat softShadowSumWeight27 = 0.0;\n\tfloat softShadowSumWeight28 = 0.0;\n\tfloat softShadowSumWeight29 = 0.0;\n\tfloat softShadowSumWeight30 = 0.0;\n\tfloat softShadowSumWeight31 = 0.0;\n\tfloat softShadowSumWeight32 = 0.0;\n\tfloat softShadowSumWeight33 = 0.0;\n\tfloat soft", "\n\tvec2 p0 = p - vec2( ra, 0.0 );\n\tvec2 p1 = p + vec2( ra, 0.0 );\n\tvec2 p2 = p + vec2( ra, he );\n\tvec2 p3 = p - vec2( ra, he );\n\n\tvec2 p4 = p - vec2( rb, 0.0 );\n\tvec2 p5 = p + vec2( rb, 0.0 );\n\tvec2 p6 = p + vec2( rb, he );\n\tvec2 p7 = p - vec2( rb, he );\n\n\tvec2 p8 = p - vec2( ra, he );\n\tvec2 p9 = p + vec2( ra, he );\n\tvec2 p10 = p + vec2( rb, he );\n\tvec2 p11 = p - vec2( rb, he );\n\n\tvec2 p12 = p - vec2( ra, 0.0 );\n\tvec2 p13 = p + vec2( ra, 0.0 );\n\tvec2 p14 = p + vec2( rb, 0.0 );\n\tvec2 p15 = p - vec2( rb, 0.0 );\n\n\tvec2 p16 = p - vec2( ra, 0.0 );\n\tvec2 p17 = p + vec2( ra, 0.0 );\n\tvec2 p18 = p + vec2( ra, he );\n\tvec2 p19 = p - vec2( ra, he );\n\n\tvec2 p20 = p - vec2( rb, 0.0 );\n\tvec2 p21 = p + vec2( rb, 0.0 );\n\tvec2 p22 = p + vec2( rb, he );\n\tvec2 p23 = p - vec2( rb, he );\n\n\tvec2 p24 = p - vec2( ra, he );\n\tvec2 p25 = p + vec2( ra, he );\n\tvec2 p26 = p + vec2( rb, he );\n\tvec2 p27 = p - vec2( rb, he );\n\n\tvec2 p28 = p -", "\n\tfloat a = length(p);\n\tfloat b = length(p - vec3(ra,0,0));\n\tfloat c = length(p - vec3(0,ra,0));\n\tfloat d = length(p - vec3(0,0,ra));\n\tfloat e = length(p - vec3(ra,ra,0));\n\tfloat f = length(p - vec3(0,ra,ra));\n\tfloat g = length(p - vec3(ra,0,ra));\n\tfloat h = length(p - vec3(ra,ra,ra));\n\tfloat r = ra + rb;\n\tfloat R = ra - rb;\n\tfloat t = (a*a + b*b - c*c - d*d) / (2*a*b);\n\tfloat u = (a*a + c*c - b*b - d*d) / (2*a*c);\n\tfloat v = (a*a + d*d - b*b - c*c) / (2*a*d);\n\tfloat w = (b*b + c*c - a*a - d*d) / (2*b*c);\n\tfloat x = (b*b + d*d - a*a - c*c) / (2*b*d);\n\tfloat y = (c*c + d*d - a*a - b*b) / (2*c*d);\n\tfloat z = (a*a + b*b - c*c - d*d) / (2*a*b);\n\tfloat A = (a*a + b*b - c*c - d*d) / (2*a*b);\n\tfloat B = (a*a + c*c - b*b - d*d) / (2*a*c);\n\tfloat C = (a*a + d*d - b*b - c*c) / (2*a*d);\n\tfloat D = (b*b + c*c - a*a - d*d) / (2*b*c);\n\tfloat E = (b*b + d*d - a*a - c*c) / (2*b*d", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r - s;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s, in float t )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r - s - t;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float s, in float t, in float u )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0", "\n\treturn v.x * v.x + v.y * v.y;\n}\n\nfloat dot3(in vec3 v) {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nfloat dot4(in vec4 v) {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;\n}\n\nfloat dot3(in vec3 v1, in vec3 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot4(in vec4 v1, in vec4 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z + v1.w * v2.w;\n}\n\nfloat dot3(in vec3 v1, in vec4 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot4(in vec4 v1, in vec3 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot3(in vec4 v1, in vec4 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot4(in vec3 v1, in vec3 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot3(in vec4 v1, in vec3 v2) {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nfloat dot4(in vec3 v1, in", "\n\tvec2 d = max( minCorner - p, 0.0 ) + max( p - maxCorner, 0.0 );\n\treturn dot( d, d );\n}\n\n// Returns the squared distance from a point to a line segment\nfloat sqLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat ab2 = dot( ab, ab );\n\tfloat t = dot( ab, ap ) / ab2;\n\tt = clamp( t, 0.0, 1.0 );\n\tvec2 projection = a + ab * t;\n\treturn dot( p - projection, p - projection );\n}\n\n// Returns the squared distance from a point to a line segment\nfloat sqLineSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 closestPoint )\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat ab2 = dot( ab, ab );\n\tfloat t = dot( ab, ap ) / ab2;\n\tt = clamp( t, 0.0, 1.0 );\n\tvec2 projection = a + ab * t;\n\tclosestPoint = projection;\n\treturn dot( p - projection, p - projection );\n}\n\n// Returns the squared distance from a point to a line segment\nfloat sqLineSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 closestPoint, out float t )\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat ab2 = dot( ab, ab );\n\tt = dot( ab, ap ) / ab2;\n\tt = clamp( t, 0.0, 1.0 );\n\tvec2 projection = a + ab * t;\n\tclosestPoint = projection;\n\treturn dot( p - projection, p - projection );\n}\n\n// Returns the squared distance from a point to a line segment\nfloat sqLineSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 closestPoint, out float t, out float u )\n{\n\tvec", "\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;\n\tfloat t4", "\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = -1.0;\n    ray = normalize(ray);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = -1.0;\n    ray = normalize(ray);\n    ray.z = -1.0 / tan(fov * 0.5);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, float aspect)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = -1.0;\n    ray = normalize(ray);\n    ray.z = -1.0 / tan(fov * 0.5);\n    ray.xy = ray.xy * vec2(1.0, 1.0 / aspect);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, float aspect, float near, float far)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.z = -1.0;\n    ray = normalize(ray);\n    ray.z = -1.0 / tan(fov * 0.5);\n    ray.xy = ray.xy * vec2(1.0, 1.0 / aspect);\n    ray.z = (far - near) * 0.5;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, float aspect, float near, float far, float znear, float zfar)\n{\n    vec3 ray = vec3(uv, 1.", "\n\tvec3 uv, uuv;\n\tvec3 qvec = q.xyz;\n\tuv = cross(qvec, v);\n\tuuv = cross(qvec, uv);\n\tuv *= 2.0 * q.w;\n\tuuv *= 2.0;\n\treturn v + uv + uuv;\n}\n\n// Quaternion-quaternion multiplication\nquat quatmul(quat q, quat r)\n{\n\tquat p;\n\tp.w = q.w * r.w - dot(q.xyz, r.xyz);\n\tp.xyz = q.w * r.xyz + r.w * q.xyz + cross(q.xyz, r.xyz);\n\treturn p;\n}\n\n// Quaternion-matrix multiplication\nmat4 quatmat(quat q)\n{\n\tmat4 m;\n\tm[0] = 1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z;\n\tm[1] = 2.0 * q.x * q.y + 2.0 * q.w * q.z;\n\tm[2] = 2.0 * q.x * q.z - 2.0 * q.w * q.y;\n\tm[3] = 0.0;\n\tm[4] = 2.0 * q.x * q.y - 2.0 * q.w * q.z;\n\tm[5] = 1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z;\n\tm[6] = 2.0 * q.y * q.z + 2.0 * q.w * q.x;\n\tm[7] = 0.0;\n\tm[8] = 2.0 * q.x * q.z + 2.0 * q.w * q.y;\n\tm[9] = 2.0 * q.y * q.z - 2.0 * q.w * q.x;\n\tm[10] = 1.0 - 2.0 * q.x * q", "\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec4 p, in vec4 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in vec3 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in vec4 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in float p, in float r )\n{\n\treturn p - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in vec3 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in vec4 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCircle( in float p, in float r )\n{\n\treturn p - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec4 p, in vec4 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\nfloat sdCircle( in vec3 p, in float r", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n\treturn length( pa - ba * h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length(p - c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec3 p, in float r )\n{\n\treturn length(p.xyz) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p.xyz - c.xyz) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec4 p, in float r )\n{\n\treturn length(p.xyz) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec4 p, in vec4 c, in float r )\n{\n\treturn length(p.xyz - c.xyz) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r, in float a )\n{\n\treturn length(p - c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec3 p, in vec3 c, in float r, in float a )\n{\n\treturn length(p.xyz - c.xyz) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec4 p, in vec4", "\n\treturn vec2(\n\t\topUnion( m.x, d, a ),\n\t\topUnion( m.y, d, a )\n\t);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec3 opUnion( vec3 m, float d, float a )\n{\n\treturn vec3(\n\t\topUnion( m.x, d, a ),\n\t\topUnion( m.y, d, a ),\n\t\topUnion( m.z, d, a )\n\t);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec4 opUnion( vec4 m, float d, float a )\n{\n\treturn vec4(\n\t\topUnion( m.x, d, a ),\n\t\topUnion( m.y, d, a ),\n\t\topUnion( m.z, d, a ),\n\t\topUnion( m.w, d, a )\n\t);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opUnion( float m, float d, float a )\n{\n\treturn min( m, d + a );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opUnion( float m, float d, float a, float b )\n{\n\treturn min( min( m, d + a ), d + b );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opUnion( float m, float d, float a, float b, float c )\n{\n\treturn min( min( min( m, d + a ), d + b ), d + c );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opUnion( float m, float d, float a, float b, float c, float d2 )\n{\n\treturn min( min( min( min( m, d + a ), d + b ), d + c ), d2 );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opUnion( float m, float d, float a, float b, float c, float d2, float e )\n{\n", "\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, ro);\n\tfloat c = dot(ro, ro) - rad * rad;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) {\n\t\tp1 = vec4(0.0, 0.0, 0.0, 0.0);\n\t\tp2 = vec4(0.0, 0.0, 0.0, 0.0);\n\t} else {\n\t\tfloat e = sqrt(d);\n\t\tfloat t0 = (-b - e) / (2.0 * a);\n\t\tfloat t1 = (-b + e) / (2.0 * a);\n\t\tp1 = vec4(ro.x + t0 * rd.x, ro.y + t0 * rd.y, t0, 1.0);\n\t\tp2 = vec4(ro.x + t1 * rd.x, ro.y + t1 * rd.y, t1, 1.0);\n\t}\n}\n\n// https://iquilezles.org/articles/raysphere/\nvoid intersectSphere( in vec3 ro, in vec3 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, ro);\n\tfloat c = dot(ro, ro) - rad * rad;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) {\n\t\tp1 = vec4(0.0, 0.0, 0.0, 0.0);\n\t\tp2 = vec4(0.0, 0.0, 0.0, 0.0);\n\t} else {\n\t\tfloat e = sqrt(d);\n\t\tfloat t0 = (-b - e) / (2.0 * a);\n\t\tfloat t1 = (-b + e) / (2.0 * a);\n\t\tp1 = vec4(ro.x + t0 * rd.x, ro.y +", "\n    vec2 d = p - c;\n    float a = dot(d, d) - r*r;\n    return vec3(d, a);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r ) \n{\n    vec2 d = p - c;\n    float a = dot(d, d) - dot(d, d) / dot(r, r);\n    return vec3(d, a);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParabola( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = p - c;\n    float a = dot(d, d) - r*r;\n    return vec3(d, a);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParaboloid( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = p - c;\n    float a = dot(d, d) - r*r;\n    return vec3(d, a);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParaboloid2( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = p - c;\n    float a = dot(d, d) - r*r;\n    return vec3(d, a);\n}\n\n// SDFs from iquile", "\n    vec2 q = abs(p) - b;\n    return vec3(\n        dot(q, q),\n        q.x,\n        q.y\n    );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgDisc( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p - c;\n    return vec3(\n        dot(q, q) - r*r,\n        q.x,\n        q.y\n    );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p - c;\n    return vec3(\n        dot(q, q) - r*r,\n        q.x,\n        q.y\n    );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 a )\n{\n    vec2 q = p - c;\n    return vec3(\n        dot(q, q) / dot(a, a),\n        q.x / a.x,\n        q.y / a.y\n    );\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p - c;\n    return vec3(\n        dot(q, q) - r*r,\n        q.x,\n        q.y\n    );\n}\n\n//", "\n    vec2 q = p * 2.0 - 1.0;\n    vec2 r = q * q;\n    vec2 s = r * q;\n    vec2 t = s * q;\n    vec2 u = t * q;\n    vec2 v = u * q;\n    vec2 w = v * q;\n    vec2 x = w * q;\n    vec2 y = x * q;\n    vec2 z = y * q;\n    vec2 a = z * q;\n    vec2 b = a * q;\n    vec2 c = b * q;\n    vec2 d = c * q;\n    vec2 e = d * q;\n    vec2 f = e * q;\n    vec2 g = f * q;\n    vec2 h = g * q;\n    vec2 i = h * q;\n    vec2 j = i * q;\n    vec2 k = j * q;\n    vec2 l = k * q;\n    vec2 m = l * q;\n    vec2 n = m * q;\n    vec2 o = n * q;\n    vec2 p = o * q;\n    vec2 q = p * q;\n    vec2 r = q * q;\n    vec2 s = r * q;\n    vec2 t = s * q;\n    vec2 u = t * q;\n    vec2 v = u * q;\n    vec2 w = v * q;\n    vec2 x = w * q;\n    vec2 y = x * q;\n    vec2 z = y * q;\n    vec2 a = z * q;\n    vec2 b = a * q;\n    vec2 c = b * q;\n    vec2 d = c * q;\n    vec2 e = d * q;\n    vec2 f = e * q;\n    vec2 g = f * q;\n    vec2 h = g * q;\n    vec2 i = h * q;\n    vec2 j = i * q;\n    vec2 k = j * q;\n    vec2 l = k * q;\n    vec2 m = l * q;\n    vec2 n = m * q;\n    vec2 o = n * q;\n    vec2 p = o * q;\n    vec2 q = p * q;\n    vec2 r = q * q;\n    vec2 s = r * q;\n    vec2 t = s * q;", "\n  return a1 * (1 - cos(x * PI)) / 2 + a2 * (1 - cos(x * PI)) / 2;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/j11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "\n  return pow(abs(x), n) * (1 - abs(x)) * a + b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y) {\n  return pow(abs(x), n) * (1 - abs(x)) * a + b + pow(abs(y), n) * (1 - abs(y)) * a + b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z) {\n  return pow(abs(x), n) * (1 - abs(x)) * a + b + pow(abs(y), n) * (1 - abs(y)) * a + b + pow(abs(z), n) * (1 - abs(z)) * a + b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z, float w) {\n  return pow(abs(x), n) * (1 - abs(x)) * a + b + pow(abs(y), n) * (1 - abs(y)) * a + b + pow(abs(z), n) * (1 - abs(z)) * a", "\n                vec2 i = floor(uv);\n                vec2 f = fract(uv);\n                vec2 u = f*f*(3.0-2.0*f);\n                return mix(mix(dot(i,i), dot(i+vec2(1.0,0.0),i), u.x), mix(dot(i+vec2(0.0,1.0),i), dot(i+vec2(1.0,1.0),i), u.x), u.y);\n            }\n\n            float paperNoise(vec2 uv, float scale){\n                return paperNoise(uv*scale);\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset){\n                return paperNoise(uv*scale) + offset;\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset, float scale2){\n                return paperNoise(uv*scale) + offset + paperNoise(uv*scale2);\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset, float scale2, float scale3){\n                return paperNoise(uv*scale) + offset + paperNoise(uv*scale2) + paperNoise(uv*scale3);\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset, float scale2, float scale3, float scale4){\n                return paperNoise(uv*scale) + offset + paperNoise(uv*scale2) + paperNoise(uv*scale3) + paperNoise(uv*scale4);\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset, float scale2, float scale3, float scale4, float scale5){\n                return paperNoise(uv*scale) + offset + paperNoise(uv*scale2) + paperNoise(uv*scale3) + paperNoise(uv*scale4) + paperNoise(uv*scale5);\n            }\n\n            float paperNoise(vec2 uv, float scale, float offset, float scale2, float scale3, float scale4, float scale5, float scale6){\n                return paperNoise(uv*scale) + offset + paperNoise(uv*scale2) + paperNoise(uv*scale3) + paperNoise(uv*scale4) + paperNoise(uv*scale5) + paperNoise(uv*scale6);\n            }\n\n            float paperNoise(vec2 uv", "\n\tvec3 result;\n\tresult.x = (x * 6 + y * 6) / 13;\n\tresult.y = (x * 6 - y * 6) / 13;\n\tresult.z = (x * 6 + y * 6) / 13;\n\treturn result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y, int z )\n{\n\tvec3 result;\n\tresult.x = (x * 6 + y * 6 + z * 6) / 13;\n\tresult.y = (x * 6 - y * 6 + z * 6) / 13;\n\tresult.z = (x * 6 + y * 6 - z * 6) / 13;\n\treturn result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y, int z, int w )\n{\n\tvec3 result;\n\tresult.x = (x * 6 + y * 6 + z * 6 + w * 6) / 13;\n\tresult.y = (x * 6 - y * 6 + z * 6 - w * 6) / 13;\n\tresult.z = (x * 6 + y * 6 - z * 6 - w * 6) / 13;\n\treturn result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y, int z, int w, int v )\n{\n\tvec3 result;\n\tresult.x = (x * 6 + y * 6 + z * 6 + w * 6 + v * 6) / 13;\n\tresult.y = (x * 6 - y * 6 + z * 6 - w * 6 + v * 6) / 13;\n\tresult.z = (x * 6 + y * 6 - z * 6 - w * 6 + v * 6) / 13;\n\t", "\n\treturn length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec3 p, in vec3 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec3 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec4 p, in vec4 c, in float r )\n{\n\treturn length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec4 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in float p, in float c, in float r )\n{\n\treturn abs(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in float p, in float r )\n{\n\treturn abs(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float c, in float r )\n{\n\treturn abs(length(p-c) - r);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec3 p, in float c, in float r )\n{\n\treturn abs(length(p-c) - r);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec4 p, in float c, in float r )\n{\n\t", "\n\tvec2 d = abs(p - c) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSphere( in vec2 p, in float r ) \n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEllipsoid( in vec2 p, in vec2 c, in vec2 b ) \n{\n\tvec2 q = p - c;\n\treturn length(q / b) - 1.0;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTorus( in vec2 p, in float r0, in float r1 ) \n{\n\tvec2 q = vec2(length(p.xy) - r0, p.z);\n\treturn length(q) - r1;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCylinder( in vec2 p, in float r, in float h ) \n{\n\tvec2 d = abs(p.xy) - vec2(r, h * 0.5);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCone( in vec2 p, in float r, in float h ) \n{\n\tvec2 d = abs(p.xy) - vec2(r, h * 0.5);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdParaboloid( in vec2 p, in float r ) \n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn pa - ba * h;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqDisk( in vec2 p, in vec2 c, float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tvec2 ca = c - a;\n\tvec2 cb = c - b;\n\tvec2 pc = p - c;\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 q = pa - ba * h;\n\tfloat h2 = clamp( dot( q, ca ) / dot( ca, ca ), 0.0, 1.0 );\n\tvec2 r = q - ca * h2;\n\tfloat h3 = clamp( dot( r, cb ) / dot( cb, cb ), 0.0, 1.0 );\n\tvec2 s = r - cb * h3;\n\tfloat h4 = clamp( dot( s, ac ) / dot( ac, ac ), 0.0, 1.0 );\n\tvec2 t = s - ac * h4;\n\tfloat h5 = clamp( dot( t, bc ) / dot( bc, bc ), 0.0, 1.0 );\n\tvec2 u = t - bc * h5;\n\treturn length( u );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqCircle( in vec2 p, in vec2 c, float r )\n{\n\treturn", "\n\tvec2 pa = p-a;\n\tvec2 ba = b-a;\n\tfloat h2 = h*h;\n\tfloat d2 = dot(pa,pa);\n\tfloat d = sqrt(d2);\n\tfloat d2min2 = d2min*d2min;\n\tfloat d2max2 = d2min2 + h2;\n\tfloat t = dot(ba,pa)/dot(ba,ba);\n\tfloat t2 = t*t;\n\tfloat t2max = 1.0;\n\tfloat t2min = 0.0;\n\tfloat t2min2 = t2min*t2min;\n\tfloat t2max2 = t2max*t2max;\n\tfloat t2minmax = t2min2 + h2;\n\tfloat t2minmax = t2max2 + h2;\n\tfloat t2minmax2 = t2minmax*t2minmax;\n\tfloat t2minmax2 = t2minmax*t2minmax;\n\tfloat t2min2max = t2min2 + t2max2;\n\tfloat t2min2max2 = t2min2max*t2min2max;\n\tfloat t2max2min = t2max2 + t2min2;\n\tfloat t2max2min2 = t2max2min*t2max2min;\n\tfloat t2min2maxmin = t2min2max + t2min2;\n\tfloat t2min2maxmin2 = t2min2maxmin*t2min2maxmin;\n\tfloat t2max2minmax = t2max2min + t2max2;\n\tfloat t2max2minmax2 = t2max2minmax*t2max2minmax;\n\tfloat t2min2maxminmax = t2min2maxmin + t2min2max;\n\tfloat t2min2maxminmax2 = t2min2maxminmax*t2min2maxminmax;\n\tfloat t2max2minmaxmin = t2max2minmax + t2max2min;\n\tfloat t2max2minmaxmin2 = t2max2minmaxmin*t2max2minmaxmin;\n", "\n\tfloat d = 1000000.0;\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 0 )\n\t\t{\n\t\t\td = min( d, sdLine( p, kPath[i*2], kPath[i*2+1] ) );\n\t\t}\n\t\telse if( kType[i] == 1 )\n\t\t{\n\t\t\td = min( d, sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3], kPath[i*2+4] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kOffset[7] )\n{\n\tfloat d = 1000000.0;\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 0 )\n\t\t{\n\t\t\td = min( d, sdLine( p, kPath[i*2], kPath[i*2+1], kOffset[i] ) );\n\t\t}\n\t\telse if( kType[i] == 1 )\n\t\t{\n\t\t\td = min( d, sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3], kPath[i*2+4], kOffset[i] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kOffset[7], float kScale[7] )\n{\n\tfloat d = 1000000.0;\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 0 )", "\n\treturn 0.0;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct inside\nfloat sdC( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct inside\nfloat sdD( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdE( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdF( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdG( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdH( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdI( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdJ( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdK( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdL( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdM( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdN( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdO( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdP( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct outside, correct outside\nfloat sdQ( in vec2 p )\n{\n\treturn 0.0;\n}\n\n// correct inside, correct outside\nfloat sdR( in vec2 p )\n{\n\t", "\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdG( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdH( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdI( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdJ( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdK( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdL( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdM( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdN( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdO( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdP( in vec2 p )\n{\n\treturn length(p) - 0.5;\n}\n\n// correct inside, incorrect", "\n    vec2 p = floor( uv * 4.0 );\n    vec2 f = fract( uv * 4.0 );\n    vec2 d = f - 0.5;\n    return abs( d ) - 0.5;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in float scale )\n{\n    vec2 p = floor( uv * scale );\n    vec2 f = fract( uv * scale );\n    vec2 d = f - 0.5;\n    return abs( d ) - 0.5;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in float scale, in float offset )\n{\n    vec2 p = floor( uv * scale + offset );\n    vec2 f = fract( uv * scale + offset );\n    vec2 d = f - 0.5;\n    return abs( d ) - 0.5;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in float scale, in float offset, in float offsetScale )\n{\n    vec2 p = floor( uv * scale + offset * offsetScale );\n    vec2 f = fract( uv * scale + offset * offsetScale );\n    vec2 d = f - 0.5;\n    return abs( d ) - 0.5;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in float scale, in float offset, in float offsetScale, in float offsetOffset )\n{\n    vec2 p = floor( uv * scale + offset * offsetScale + offsetOffset );\n    vec2 f = fract( uv * scale + offset * offsetScale + offsetOffset );\n    vec2 d = f - 0.5;\n    return abs( d ) - 0.5;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in float scale, in float offset, in float offsetScale, in float offsetOffset, in float offsetOffsetScale )\n{\n    vec2 p = floor( uv * scale + offset * offset", "\n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\tfloat t = dot(ap, ab) / dot(ab, ab);\n\tif (t < 0.0) t = 0.0;\n\tif (t > 1.0) t = 1.0;\n\treturn a + t * ab;\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn cloSegment(p, a, b, 0.0);\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 th )\n{\n\treturn cloSegment(p, a, b, dot(th, b - a));\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 th, in float t )\n{\n\treturn cloSegment(p, a, b, dot(th, b - a) * t);\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 th, in float t, in float th2 )\n{\n\treturn cloSegment(p, a, b, dot(th, b - a) * t, th2);\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 th, in float t, in float th2, in float th3 )\n{\n\treturn cloSegment(p, a, b, dot(th, b - a) * t, th2, th3);\n}\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 th, in float t, in float th2, in float th3, in float th4 )\n{\n\treturn cloSegment(p, a, b, dot(th, b - a) * t, th2, th3, th4);\n}\n\n// Closest point on segment\nvec2", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - th;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tvec2 ap = p - a;\n\tvec2 bp = p - b;\n\tvec2 cp = p - c;\n\tfloat d1 = dot( cross( ab, ap ), ac );\n\tfloat d2 = dot( cross( ac, bp ), ab );\n\tfloat d3 = dot( cross( bc, cp ), ac );\n\tif( d1 > 0.0 && d2 > 0.0 && d3 > 0.0 ) return length( ap );\n\tif( d1 < 0.0 && d2 < 0.0 && d3 < 0.0 ) return length( bp );\n\tif( d1 * d2 < 0.0 ) return length( cross( ab, ap ) / dot( ab, ab ) );\n\tif( d2 * d3 < 0.0 ) return length( cross( ac, bp ) / dot( ac, ac ) );\n\tif( d3 * d1 < 0.0 ) return length( cross( bc, cp ) / dot( bc, bc ) );\n\treturn min( min( d1, d2 ), d3 );\n}\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs( p ) - b;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 d = abs( p ) - b;\n\td = max( d, 0.0", "\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, inout vec2 d )\n{\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\td = q;\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, inout vec2 d, inout float s )\n{\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\td = q;\n\ts = dot(q, q);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, inout vec2 d, inout float s, inout float t )\n{\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\td = q;\n\ts = dot(q, q);\n\tt = dot(q, q);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, inout vec2 d, inout float s, inout float t, inout float u )\n{\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\td = q;\n\ts = dot(q, q);\n\tt = dot(q, q);\n\tu = dot(q, q);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, inout vec2 d, inout float s, inout float t, inout float u, inout float v )\n{\n\tvec2 q = p - b;\n\tq = abs(q) - r;\n\td = q;\n\ts = dot(q, q);\n\tt = dot(q, q);\n", "\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) + r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) + r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) + r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) - r.x - r.y;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) - r.x - r.y - r.z;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) - r.x - r.y - r.z - r.w;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 s )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) - r.x - r.y - s.x - s.y;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 s )\n{\n\tp = abs(p) - b;\n\treturn length(max(p, 0.0)) - r.x - r.y - r.z - s.x -", "\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to sphere\nfloat sdSphere( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec2 p, in float r, in float h )\n{\n\tvec2 q = abs(p.xy) - vec2(r,h/2.0);\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// distance to cone\nfloat sdCone( in vec2 p, in float r, in float h )\n{\n\tvec2 q = abs(p.xy) - vec2(r,h/2.0);\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 v0 = b - a;\n\tvec2 v1 = c - a;\n\tvec2 v2 = p - a;\n\n\tfloat d00 = dot(v0,v0);\n\tfloat d01 = dot(v0,v1);\n\tfloat d11 = dot(v1,v1);\n\tfloat d20 = dot(v2,v0);\n\tfloat d21 = dot(v2,v1);\n\n\tfloat denom = d00 * d11 - d01 * d01;\n\tfloat v = (d11 * d20 - d01 * d21) / denom;\n\tfloat w = (d00 * d21 - d01 * d20) / denom;\n\tfloat t = (d01 * v - d11 * w) / d00;\n\n\treturn length(p - a) - t;\n}\n\n// distance to quad\nfloat sdQuad( in vec2 p,", "\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash17(vec2 p){\n\treturn fract(sin(dot(p,vec2(12", "\n\treturn fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n\treturn fract(sin(dot(x, vec3(12.9898, 78.233, 1.0))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n\treturn fract(sin(dot(x, vec4(12.9898, 78.233, 1.0, 1.0))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n\treturn fract(sin(x * 12.9898) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y)\n{\n\treturn fract(sin(x * 12.9898 + y * 78.233) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z)\n{\n\treturn fract(sin(x * 12.9898 + y * 78.233 + z * 1.0) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w)\n{\n\treturn fract(sin(x * 12.9898 + y * 78.233 + z * 1.0 + w * 1.0) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float", "\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5453);\n}\n\n// From iq\nvec2 random3(vec2 st){\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5453);\n}\n\n// From iq\nvec2 random4(vec2 st){\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5453);\n}\n\n// From iq\nvec2 random5(vec2 st){\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5453);\n}\n\n// From iq\nvec2 random6(vec2 st){\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5453);\n}\n\n// From iq\nvec2 random7(vec2 st){\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))))*43758.5", "\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 u = f*f*(3.0-2.0*f);\n\treturn mix(mix(dot(p,p+vec2(1.0,0.0)), dot(p+vec2(0.0,1.0),p+vec2(1.0,1.0)), u.x), mix(dot(p+vec2(1.0,0.0),p+vec2(1.0,1.0)), dot(p+vec2(0.0,1.0),p+vec2(1.0,1.0)), u.x), u.y);\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tvec3 u = f*f*(3.0-2.0*f);\n\treturn mix(mix(mix(dot(p,p+vec3(1.0,0.0,0.0)), dot(p+vec3(0.0,1.0,0.0),p+vec3(1.0,1.0,0.0)), u.x), mix(dot(p+vec3(0.0,0.0,1.0),p+vec3(1.0,1.0,1.0)), dot(p+vec3(0.0,1.0,0.0),p+vec3(1.0,1.0,1.0)), u.x), u.y), mix(mix(dot(p+vec3(0.0,0.0,1.0),p+vec3(1.0,1.0,1.0)), dot(p+vec3(0.0,1.0,0.0),p+vec3(1.0,1.0,1.0)), u.x), mix(dot(p+vec3(0.0,0.0,", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat h = 0.5;\n\tfloat n = 1.0;\n\tfloat m = 1.0;\n\tfloat k = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x1 = 0.0;\n\tfloat x2 = 0.0;\n\tfloat x3 = 0.0;\n\tfloat x4 = 0.0;\n\tfloat x5 = 0.0;\n\tfloat x6 = 0.0;\n\tfloat x7 = 0.0;\n\tfloat x8 = 0.0;\n\tfloat x9 = 0.0;\n\tfloat x10 = 0.0;\n\tfloat x11 = 0.0;\n\tfloat x12 = 0.0;\n\tfloat x13 = 0.0;\n\tfloat x14 = 0.0;\n\tfloat x15 = 0.0;\n\tfloat x16 = 0.0;\n\tfloat x17 = 0.0;\n\tfloat x18 = 0.0;\n\tfloat x19 = 0.0;\n\tfloat x20 = 0.0;\n\tfloat x21 = 0.0;\n\tfloat x22 = 0.0;\n\tfloat x23 = 0.0;\n\tfloat x24 = 0.0;\n\tfloat x25 = 0.0;\n\tfloat x26 = 0.0;\n\tfloat x27 = 0.0;\n\tfloat x28 = 0.0;\n\tfloat x29 = 0.0;\n\tfloat x30 = 0.0;\n\tfloat x31 = 0.0;\n\tfloat x32 = 0.0;\n\tfloat x33 = 0.0;\n\tfloat x3", "\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\t", "\n    return 4.0f * (1.0f - x * x - y * y);\n}\n\nfloat texelSolidAngle(float x, float y, float z)\n{\n    float r = sqrt(x * x + y * y + z * z);\n    return areaElement(x / r, y / r) / (4.0f * PI);\n}\n\n//\n// This is the main function that generates the cubemap.\n//\nvoid generateCubemap(const char* filename, const char* envmap, int size)\n{\n    //\n    // Load the environment map.\n    //\n    Image image;\n    if (!image.load(envmap))\n    {\n        printf(\"Failed to load environment map %s\\n\", envmap);\n        return;\n    }\n\n    //\n    // Create the cubemap.\n    //\n    Cubemap cubemap;\n    cubemap.create(size);\n\n    //\n    // Generate the cubemap.\n    //\n    for (int i = 0; i < 6; i++)\n    {\n        //\n        // Get the image for the face.\n        //\n        Image face;\n        face.create(size, size, 3);\n        for (int y = 0; y < size; y++)\n        {\n            for (int x = 0; x < size; x++)\n            {\n                //\n                // Get the pixel from the environment map.\n                //\n                float u = (float)x / (float)size;\n                float v = (float)y / (float)size;\n                float r, g, b;\n                image.getPixel(u, v, r, g, b);\n\n                //\n                // Convert the pixel to a vector.\n                //\n                float x = r * 2.0f - 1.0f;\n                float y = g * 2.0f - 1.0f;\n                float z = b * 2.0f - 1.0f;\n\n                //\n                // Convert the vector to a unit vector.\n                //\n                float r2 = x * x + y * y + z * z;\n                if (r2 > 0.0f)\n                {\n                    float inv = 1.0f / sqrt(r2);\n                    x *= inv;\n                    y *= inv;\n                    z *= inv;\n                }\n\n                //\n                // Convert the vector to a texture coordinate", "\n\tvec3 p = fract(vec3(dot(p3, vec3(127.1, 311.7, 419.2)), dot(p3, vec3(269.5, 183.3, 246.1)), dot(p3, vec3(113.5, 199.5, 97.9))));\n\treturn p - floor(p + dot(p, p3.z * 0.14285714285714285714285714285714));\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tvec3 p = fract(vec3(dot(p3, vec3(127.1, 311.7, 419.2)), dot(p3, vec3(269.5, 183.3, 246.1)), dot(p3, vec3(113.5, 199.5, 97.9))));\n\treturn p - floor(p + dot(p, p3.z * 0.14285714285714285714285714285714));\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tvec3 p = fract(vec3(dot(p3, vec3(127.1, 311.7, 419.2)), dot(p3, vec3(269.5, 183.3, 246.1)), dot(p3, vec3(113.5, 199.5, 97.9))));\n\treturn p - floor(p + dot(p, p3.z * 0.142857142857142857", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    vec3 g = vec3(0.0);\n    g.x = dot(i.xyz+vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));\n    g.y = dot(i.xyz+vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0));\n    g.z = dot(i.xyz+vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0));\n    g.x = g.x*g.x*g.x*(1.0+f.x*g.x*8.0);\n    g.y = g.y*g.y*g.y*(1.0+f.y*g.y*8.0);\n    g.z = g.z*g.z*g.z*(1.0+f.z*g.z*8.0);\n    return 42.0*dot(g, f*f*f);\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4sX3zN\nfloat simplex3d(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    vec3 g = vec3(0.0);\n    g.x = dot(i.xyz+vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));\n    g.y = dot(i.xyz+vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0));\n    g.z = dot(i.xyz+vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0));\n    g.x = g.x*g.x", "\n    return fract(sin(x)*43758.5453123);\n}\n\n// this is a simple 2d noise function.\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = mix( mix( hash(p), hash(p+vec2(1.0,0.0)), f.x),\n                   mix( hash(p+vec2(0.0,1.0)), hash(p+vec2(1.0,1.0)), f.x), f.y);\n    return mix(a.x, a.y, f.y);\n}\n\n// this is a simple 3d noise function.\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    // Four corners in 3D of a tile\n    float a = mix( mix( hash(p), hash(p+vec3(1.0,0.0,0.0)), f.x),\n                   mix( hash(p+vec3(0.0,1.0,0.0)), hash(p+vec3(1.0,1.0,0.0)), f.x), f.y);\n    a = mix(a.x, a.y, f.y);\n\n    return mix(a.x, a.y, f.z);\n}\n\n// this is a simple 4d noise function.\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\n    // Four corners in 4D of a tile\n    float a = mix( mix( hash(p), hash(p+vec4(1.0,0.0,0.0,0.0)), f.x),\n                   mix( hash(p+vec4(0.0,1.0,0.0,0.0)), hash(p+vec4(1.0,1.0,0.0,0.0)), f.x), f.y);\n    a = mix(a.x, a.y, f.y);\n\n    a =", "\n\treturn length( abs( p - a ) - abs( p - b ) );\n}\n\n// for visualization purposes only\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length( p ) - r;\n}\n\n// for visualization purposes only\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs( p ) - b;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// for visualization purposes only\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 v0 = b - a;\n\tvec2 v1 = c - a;\n\tvec2 v2 = p - a;\n\n\tfloat dot00 = dot( v0, v0 );\n\tfloat dot01 = dot( v0, v1 );\n\tfloat dot02 = dot( v0, v2 );\n\tfloat dot11 = dot( v1, v1 );\n\tfloat dot12 = dot( v1, v2 );\n\n\tfloat invDenom = 1.0 / ( dot00 * dot11 - dot01 * dot01 );\n\tfloat u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\tfloat v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\treturn length( max( 0.0, 1.0 - u - v ) ) - 0.001;\n}\n\n// for visualization purposes only\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 pah = pa - h * ba;\n\treturn length( pah ) - r;\n}\n\n// for visualization purposes only\nfloat sdCylinder( in vec2 p, in vec", "\n\tvec2 d = abs(p) - r;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n\tvec3 d = abs(p) - r;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n\tvec4 d = abs(p) - r;\n\treturn min(max(d.x, max(d.y, max(d.z, d.w))), 0.0) + length(max(d, 0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\treturn length(max(abs(p) - b, 0.0)) - b.x;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b )\n{\n\treturn length(max(abs(p) - b, 0.0)) - b.x;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b )\n{\n\treturn length(max(abs(p) - b, 0.0)) - b.x;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in float b )\n{\n\treturn length(max(abs(p) - vec2(b), 0.0)) - b;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in float b )\n{\n\treturn length(max(abs(p) - vec3(b), 0.0)) - b;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in float b )\n{\n\treturn length(max(abs(p) - vec4", "\n    // https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Ellipse#", "\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash13(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(13.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash14(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(14.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash15(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(15.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash16(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(16.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash17(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(17.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash18(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(18.9898, 78.233))) * 43758.5453);\n}\n\n// https://www.shadertoy.", "\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n", "\n\tvec3 n = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tfloat d = 0.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tvec3 q = p - vertices[i];\n\t\tfloat l = length(q);\n\t\tif( l > 0.0 )\n\t\t{\n\t\t\te += q / l;\n\t\t\td += 1.0 / l;\n\t\t}\n\t}\n\te /= d;\n\tn = normalize(e);\n\treturn n;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p )\n{\n\tvec3 n = normal(p);\n\tfloat d = dot(n,p);\n\treturn length(p) - d;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p, vec3 n )\n{\n\tfloat d = dot(n,p);\n\treturn length(p) - d;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p, vec3 n, float d )\n{\n\treturn length(p) - d;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p, vec3 n, float d, float r )\n{\n\treturn length(p) - d - r;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p, vec3 n, float d, float r, float s )\n{\n\treturn length(p) - d - r - s;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nfloat sdf( vec3 p, vec3 n, float d, float r, float s, float t )\n{\n\treturn length(p) - d - r - s - t;\n}\n\n// https://iquilezles.org/articles/normals", "\n    float t = t0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (p.y < 0)\n        {\n            return t;\n        }\n        t += EPSILON;\n    }\n    return t1;\n}\n\n// Returns the color of the ray at the given position\nvec3 rayColor(vec3 ro, vec3 rd, int depth)\n{\n    // If the ray hits the surface, return the color of the surface\n    if (depth > 10)\n    {\n        return vec3(0, 0, 0);\n    }\n    float t = shadow(ro, rd, EPSILON, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat ao = 0.0;\n\tfloat ao_max = 0.0;\n\tfloat ao_min = 0.0;\n\tfloat ao_step = 0.0;\n\tfloat ao_dist = 0.0;\n\tfloat ao_dist_max = 0.0;\n\tfloat ao_dist_min = 0.0;\n\tfloat ao_dist_step = 0.0;\n\tfloat ao_dist_step_max = 0.0;\n\tfloat ao_dist_step_min = 0.0;\n\tfloat ao_dist_step_step = 0.0;\n\tfloat ao_dist_step_step_max = 0.0;\n\tfloat ao_dist_step_step_min = 0.0;\n\tfloat ao_dist_step_step_step = 0.0;\n\tfloat ao_dist_step_step_step_max = 0.0;\n\tfloat ao_dist_step_step_step_min = 0.0;\n\tfloat ao_dist_step_step_step_step = 0.0;\n\tfloat ao_dist_step_step_step_step_max = 0.0;\n\tfloat ao_dist_step_step_step_step_min = 0.0;\n\tfloat ao_dist_step_step_step_step_step = 0.0;\n\tfloat ao_dist_step_step_step_step_step_max = 0.0;\n\tfloat ao_dist_step_step_step_step_step_min = 0.0;\n\tfloat ao_dist_step_step_step_step_step_step = 0.0;\n\tfloat ao_dist_step_step_step_step_step_step_max = 0.0;\n\tfloat ao_dist_step_step_step_step_step_step_min = 0.0;\n\tfloat ao_dist_step_step_step_step_step_step_step = 0.0;\n\tfloat ao_dist_step_step_step_step_step_step_step_max = 0.0;\n\tfloat ao_dist", "\n\tmat3 rotationMatrix = mat3(1.0f);\n\tfloat cosAngle = cos(angle);\n\tfloat sinAngle = sin(angle);\n\tfloat oneMinusCosAngle = 1.0f - cosAngle;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\trotationMatrix[0][0] = cosAngle + x * x * oneMinusCosAngle;\n\trotationMatrix[0][1] = x * y * oneMinusCosAngle - z * sinAngle;\n\trotationMatrix[0][2] = x * z * oneMinusCosAngle + y * sinAngle;\n\trotationMatrix[1][0] = x * y * oneMinusCosAngle + z * sinAngle;\n\trotationMatrix[1][1] = cosAngle + y * y * oneMinusCosAngle;\n\trotationMatrix[1][2] = y * z * oneMinusCosAngle - x * sinAngle;\n\trotationMatrix[2][0] = x * z * oneMinusCosAngle - y * sinAngle;\n\trotationMatrix[2][1] = y * z * oneMinusCosAngle + x * sinAngle;\n\trotationMatrix[2][2] = cosAngle + z * z * oneMinusCosAngle;\n\treturn rotationMatrix;\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n\tmat3 rotationMatrix = mat3(1.0f);\n\tfloat cosAngle = cos(angle);\n\tfloat sinAngle = sin(angle);\n\trotationMatrix[1][1] = cosAngle;\n\trotationMatrix[1][2] = -sinAngle;\n\trotationMatrix[2][1] = sinAngle;\n\trotationMatrix[2][2] = cosAngle;\n\treturn rotationMatrix;\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n\tmat3 rotationMatrix = mat3(1.0f);\n\tfloat cosAngle = cos(angle);\n\tfloat sinAngle = sin(angle);\n\trotationMatrix[0][0] = cosAngle;\n\trotationMatrix[0][2] = sinAngle;\n\t", "\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    dir.z = -1.0;\n    dir = normalize(dir);\n    return dir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    dir.z = -1.0;\n    dir = normalize(dir);\n    return dir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec2 iResolution) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    dir.z = -1.0;\n    dir = normalize(dir);\n    return dir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec2 iResolution, vec3 camPos) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    dir.z = -1.0;\n    dir = normalize(dir);\n    return dir;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, vec2 iResolution, vec3 camPos, vec3 camDir) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);", "\n\treturn rand2d(co + vec2(time));\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n\treturn rand3dTime(co);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n\treturn rand3d(co + vec3(time));\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co){\n\treturn rand4dTime(co);\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co){\n\treturn rand4d(co + vec4(time));\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float time){\n\treturn rand2dTime(co, time);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float time){\n\treturn rand3dTime(co, time);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co, float time){\n\treturn rand4dTime(co, time);\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co, float time){\n\treturn rand2d(co + vec2(time));\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co, float time){\n\treturn rand3d(co + vec3(time));\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co, float time){\n\treturn rand4d(co + vec4(time));\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float time, float seed){\n\treturn rand2dTime(co, time, seed);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float time, float seed){\n\treturn rand3dTime(co, time, seed);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co, float time, float seed){\n\treturn rand4dTime(co, time, seed);\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co, float time, float seed){\n\t", "\n\treturn p.x*p.x + p.y*p.y + p.z*p.z;\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\treturn p.x*p.x + p.y*p.y;\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec1 p){\n\treturn p.x*p.x;\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n\treturn p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w;\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p, float a){\n\treturn p.x*p.x + p.y*p.y + a;\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec1 p, float a){\n\treturn p.x*p.x + a;\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p, float a){\n\treturn p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w + a;\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p, float a){\n\treturn p.x*p.x + p.y*p.y + p.z*p.z + a;\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p, float a, float b){\n\treturn p.x*p.x + p.y*p.y + a + b;\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec1 p, float a, float b){\n\treturn p.x*p.x + a + b;\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p, float a, float b){\n\treturn p.x*p.x + p.y*p.y + p.z*p.z + p.w*p.w + a + b;\n}\n", "\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tint i1 = int(p.x);\n\tint j1 = int(p.y);\n\tint k1 = int(p.z);\n\tint i2 = int(p.x) + 1;\n\tint j2 = int(p.y) + 1;\n\tint k2 = int(p.z) + 1;\n\n\t// Hashing\n\tvec3 h = vec3(i1, j1, k1);\n\tvec3 h2 = vec3(i2, j2, k2);\n\n\t// Noise contributions from the four corners\n\tvec3 n0 = fade(hash(h));\n\tvec3 n1 = fade(hash(h2));\n\n\t// Compute the x,y gradients\n\tvec3 gx = vec3(f.x, f.y, f.z);\n\tvec3 gy = vec3(f.x, f.y, f.z);\n\n\t// Compute the fade curve value for x,y\n\tfloat n1x = dot(gx, vec3(i1, j1, k1));\n\tfloat n1y = dot(gy, vec3(i1, j1, k1));\n\tfloat n1z = dot(gx, vec3(i1, j1, k1));\n\tfloat n2x = dot(gx, vec3(i2, j2, k2));\n\tfloat n2y = dot(gy, vec3(i2, j2, k2));\n\tfloat n2z = dot(gx, vec3(i2, j2, k2));\n\n\t// Add contributions from each corner to get the final noise value.\n\treturn 42.0 * (n0.x * n1x + n0.y * n1y + n0.z * n1z + n0.w * n1w) +\n\t\t42.0 * (n1.x * n2x + n1.y * n2y + n1.z * n2z + n1.w * n2w);\n}\n\n// 2D value noise", "\n\tvec3 pi = floor(p);\n\tvec3 pf = p - pi;\n\tvec3 pf3 = pf * pf * pf;\n\tvec3 pf2 = pf * pf;\n\tvec3 pf4 = pf2 * pf2;\n\tvec3 pf5 = pf4 * pf;\n\tvec3 pf6 = pf5 * pf;\n\tvec3 pf7 = pf6 * pf;\n\tvec3 pf8 = pf7 * pf;\n\tvec3 pf9 = pf8 * pf;\n\tvec3 pf10 = pf9 * pf;\n\tvec3 pf11 = pf10 * pf;\n\tvec3 pf12 = pf11 * pf;\n\tvec3 pf13 = pf12 * pf;\n\tvec3 pf14 = pf13 * pf;\n\tvec3 pf15 = pf14 * pf;\n\tvec3 pf16 = pf15 * pf;\n\tvec3 pf17 = pf16 * pf;\n\tvec3 pf18 = pf17 * pf;\n\tvec3 pf19 = pf18 * pf;\n\tvec3 pf20 = pf19 * pf;\n\tvec3 pf21 = pf20 * pf;\n\tvec3 pf22 = pf21 * pf;\n\tvec3 pf23 = pf22 * pf;\n\tvec3 pf24 = pf23 * pf;\n\tvec3 pf25 = pf24 * pf;\n\tvec3 pf26 = pf25 * pf;\n\tvec3 pf27 = pf26 * pf;\n\tvec3 pf28 = pf27 * pf;\n\tvec3 pf29 = pf28 * pf;\n\tvec3 pf30 = pf29 * pf;\n\tvec3 pf31 = pf30 * pf;\n\tvec3 pf32 = pf31 * pf;\n\tvec3 pf33 = pf32 * pf;\n\tvec3 pf34 = pf33 * pf;\n\tvec3 pf35 = pf34 * pf;\n\tvec3 pf36 = pf35 * pf;\n\tvec3 pf37 = pf36 * pf;\n\tvec3", "\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < 10; i++){\n\t\tfbm += abs(noise(p * freq)) * amp;\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM2(vec3 p){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < 10; i++){\n\t\tfbm += abs(noise(p * freq)) * amp;\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM3(vec3 p){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < 10; i++){\n\t\tfbm += abs(noise(p * freq)) * amp;\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM4(vec3 p){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < 10; i++){\n\t\tfbm += abs(noise(p * freq)) * amp;\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM5(vec3 p){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1", "\n\tvec2 density = vec2(0.0,0.0);\n\tvec3 pos_ = pos;\n\tvec3 pos_2 = pos;\n\tvec3 pos_3 = pos;\n\tvec3 pos_4 = pos;\n\tvec3 pos_5 = pos;\n\tvec3 pos_6 = pos;\n\tvec3 pos_7 = pos;\n\tvec3 pos_8 = pos;\n\tvec3 pos_9 = pos;\n\tvec3 pos_10 = pos;\n\tvec3 pos_11 = pos;\n\tvec3 pos_12 = pos;\n\tvec3 pos_13 = pos;\n\tvec3 pos_14 = pos;\n\tvec3 pos_15 = pos;\n\tvec3 pos_16 = pos;\n\tvec3 pos_17 = pos;\n\tvec3 pos_18 = pos;\n\tvec3 pos_19 = pos;\n\tvec3 pos_20 = pos;\n\tvec3 pos_21 = pos;\n\tvec3 pos_22 = pos;\n\tvec3 pos_23 = pos;\n\tvec3 pos_24 = pos;\n\tvec3 pos_25 = pos;\n\tvec3 pos_26 = pos;\n\tvec3 pos_27 = pos;\n\tvec3 pos_28 = pos;\n\tvec3 pos_29 = pos;\n\tvec3 pos_30 = pos;\n\tvec3 pos_31 = pos;\n\tvec3 pos_32 = pos;\n\tvec3 pos_33 = pos;\n\tvec3 pos_34 = pos;\n\tvec3 pos_35 = pos;\n\tvec3 pos_36 = pos;\n\tvec3 pos_37 = pos;\n\tvec3 pos_38 = pos;\n\tvec3 pos_39 = pos;\n\tvec3 pos_40 = pos;\n\tvec3 pos_41 = pos;\n\tvec3 pos_42 = pos;\n\tvec3 pos_43 = pos;\n\tvec3 pos_44 = pos;\n\tvec3 pos_45 = pos;\n\tvec3 pos_46 = pos", "\n\tvec3 normal = vec3(0.0, 1.0, 0.0);\n\tvec3 light = vec3(0.0, 1.0, 0.0);\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tvec3 shadow = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowLight = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor2 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal2 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowLight2 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor3 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal3 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowLight3 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor4 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal4 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowLight4 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor5 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal5 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowLight5 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowColor6 = vec3(0.0, 0.0, 0.0);\n\tvec3 shadowNormal6 = vec3(0.0, 0.0, 0.", "\n\tvec3 point = pointStart;\n\tvec3 color = background;\n\tfloat t = 0.0;\n\tfloat tMax = 10000.0;\n\tfloat tDelta = 0.001;\n\tfloat tDelta2 = 0.0001;\n\tfloat tDelta3 = 0.00001;\n\tfloat tDelta4 = 0.000001;\n\tfloat tDelta5 = 0.0000001;\n\tfloat tDelta6 = 0.00000001;\n\tfloat tDelta7 = 0.000000001;\n\tfloat tDelta8 = 0.0000000001;\n\tfloat tDelta9 = 0.00000000001;\n\tfloat tDelta10 = 0.000000000001;\n\tfloat tDelta11 = 0.0000000000001;\n\tfloat tDelta12 = 0.00000000000001;\n\tfloat tDelta13 = 0.000000000000001;\n\tfloat tDelta14 = 0.0000000000000001;\n\tfloat tDelta15 = 0.00000000000000001;\n\tfloat tDelta16 = 0.000000000000000001;\n\tfloat tDelta17 = 0.0000000000000000001;\n\tfloat tDelta18 = 0.00000000000000000001;\n\tfloat tDelta19 = 0.000000000000000000001;\n\tfloat tDelta20 = 0.0000000000000", "\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_linear(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_linear_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma_gamma_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma_gamma_gamma_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma_gamma_gamma_gamma_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zN\nvec3 tonemap_gamma_gamma_gamma_gamma_gamma_gamma(vec3 color) {\n\treturn color / (color + vec3(1.0));\n}\n\n// https://www.shadertoy.com/view/4"]}