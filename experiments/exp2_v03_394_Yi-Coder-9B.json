{"generations": ["\n    return 1.0;\n}\n\nvec3 SH_1_0( in vec3 s ) {\n    return s.z;\n}\n\nvec3 SH_1_1( in vec3 s ) {\n    return s.y;\n}\n\nvec3 SH_1_2( in vec3 s ) {\n    return s.x;\n}\n\nvec3 SH_2_0( in vec3 s ) {\n    return 0.886275 * s.z * s.z - 0.494090 * s.y;\n}\n\nvec3 SH_2_1( in vec3 s ) {\n    return 1.732050 * s.z * s.y;\n}\n\nvec3 SH_2_2( in vec3 s ) {\n    return 1.732050 * s.z * s.x;\n}\n\nvec3 SH_2_3( in vec3 s ) {\n    return 1.732050 * s.y * s.x;\n}\n\nvec3 SH_2_4( in vec3 s ) {\n    return 0.429043 * s.x * s.x - 0.303267 * s.z;\n}\n\nvec3 SH_2_5( in vec3 s ) {\n    return 1.732050 * s.x * s.y;\n}\n\nvec3 SH_3_0( in vec3 s ) {\n    return 1.092548 * s.z * s.z * s.z - 1.064848 * s.z * s.y;\n}\n\nvec3 SH_3_1( in vec3 s ) {\n    return 0.546274 * s.z * s.z * s.y - 0.511664 * s.x * s.y;\n}\n\nvec3 SH_3_2( in vec3 s ) {\n    return 0.766044 * s.z * s.z * s.x - 0", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment2( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment3( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment4( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment5( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance", "\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// 2D rotation\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// 2D rotation around a point\nmat2 rot(float a, vec2 p) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c)*mat2(p.x,-p.y,p.y,p.x);\n}\n\n// 2D reflection\nmat2 refl(vec2 r) {\n    return mat2(r.x,r.y,-r.y,r.x);\n}\n\n// 2D reflection around a point\nmat2 refl(vec2 r, vec2 p) {\n    return mat2(r.x,r.y,-r.y,r.x)*mat2(p.x,-p.y,p.y,p.x);\n}\n\n// 2D shear\nmat2 shear(float a) {\n    return mat2(1.0,tan(a),tan(a),1.0);\n}\n\n// 2D shear around a point\nmat2 shear(float a, vec2 p) {\n    return mat2(1.0,tan(a),tan(a),1.0)*mat2(p.x,-p.y,p.y,p.x);\n}\n\n// 2D scaling\nmat2 scale(vec2 s) {\n    return mat2(s.x,0.0,0.0,s.y);\n}\n\n// 2D scaling around a point\nmat2 scale(vec2 s, vec2 p) {\n    return mat2(s.x,0.0,0.0,s.y)*mat2(p.x,-p.y,p.y,p.x);\n}\n\n// 2D translation\nmat2 trans(vec2 t) {\n    return mat2(1.0,0.0,", "\n    return dot(v,r)<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return dot(v,r)<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return dot(v,r)<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float d )\n{\n    return d<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in float d )\n{\n    return d<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r, in float d )\n{\n    return d<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in vec2 d )\n{\n    return d.x<0.0? r*2.0*dot(r,v)-v : v;\n}\n\n// Reflect v if in the negative half space defined by r", "\n    return v.y<0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return v.y>0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the negative quadrant defined by r (this works in 3D too)\nvec2 clipIfNegQuad( in vec2 v, in vec2 r )\n{\n    return v.y<0.0 && v.x<0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the positive quadrant defined by r (this works in 3D too)\nvec2 clipIfPosQuad( in vec2 v, in vec2 r )\n{\n    return v.y>0.0 && v.x>0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the negative octant defined by r (this works in 3D too)\nvec2 clipIfNegOct( in vec2 v, in vec2 r )\n{\n    return v.y<0.0 && v.x<0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the positive octant defined by r (this works in 3D too)\nvec2 clipIfPosOct( in vec2 v, in vec2 r )\n{\n    return v.y>0.0 && v.x>0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the negative quadrant defined by r (this works in 3D too)\nvec2 clipIfNegQuad( in vec2 v, in vec2 r )\n{\n    return v.y<0.0 && v.x<0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the positive quadrant defined by r (this works in 3D too)\nvec2 clipIfPosQuad( in vec", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix( w1, w2, h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCone( in vec2 p, in float r1, in float r2, in float h )\n{\n    float q = length(p);\n    float l = r2-r1;\n    return sqrt(q*q+h*h)-l*atan(q,h)-r1;\n}\n\nfloat sdCone( in vec2 p, in float r1, in float r2, in float h, in float a1, in float a2 )\n{\n    float q = length(p);\n    float l = r2-r1;\n    float a = atan(p.y,p.x);\n    float k = (a2-a1)/(l*l);\n    float b = (r2*r2-r1*r1)/(2.0*l);\n    float c = r1 - b*a1;\n    float d = b*b*k*k + b*k + c;\n    float t = (d-a*k-q)/k;\n    float y = t*k+a;\n    float x = t;\n    return length(vec2(x,y-a)) - r1;\n}\n\nfloat sdCone( in vec2 p, in float r1, in float r2, in float h, in float a1, in float a2, in float a3 )\n{\n    float q = length(p);\n    float l = r2-r1;\n    float a = atan(p", "\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27 * sunDot;\n    float sunDot29 = sunDot28 * sunDot;\n    float sunDot30 = sunDot29 * sunDot;\n    float sunDot31 = sunDot30 * sunDot;\n    float sunDot32 = sunDot31 * sunDot;\n    float sunDot33 = sunDot32 * sunDot;\n    float sun", "\n    vec4 v0 = (p2 - p0) * 0.5;\n    vec4 v1 = (p3 - p1) * 0.5;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension)\n{\n    vec4 v0 = (p2 - p0) * tension;\n    vec4 v1 = (p3 - p1) * tension;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension, float bias)\n{\n    vec4 v0 = (p2 - p0) * (1.0 - bias) * tension;\n    vec4 v1 = (p3 - p1) * (1.0 - bias) * tension;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\n", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tn += dot(sin(freq * p), vec3(0.5, 0.5, 0.5)) * amp;\n\t\tfreq += 1.0;\n\t\tamp *= 0.5;\n\t\tp *= normalizer;\n\t\tp.xy = p.yx;\n\t\tp.xy *= nudge;\n\t}\n\treturn n;\n}\n\n// 3D simplex noise\n//\n// Based on original code by Stefan Gustavson (stegu@itn.liu.se)\n// Optimized for three dimensions by Stefan Gustavson (stegu@itn.liu.se)\n// Optimized for two dimensions by Stefan Gustavson (stegu@itn.liu.se)\n// Optimized for one dimension by Stefan Gustavson (stegu@itn.liu.se)\n//\n// This is a three-dimensional version of simplex noise originally\n// published in a paper called \"Simplex Noise\" by Ken Perlin.\n//\n// The noise function returns a value in the range -1 to +1.\n//\n// The code is based on a simplex noise implementation by\n// Stefan Gustavson (stegu@itn.liu.se)\n//\n// The original implementation is in C++, and this is a port of that\n// implementation to GLSL.\n//\n// The original implementation is available at:\n// http://web.archive.org/web/20150228194847/http://stegu.org/glslnoise/\n//\n// The original implementation is licensed under the MIT license:\n//\n// Copyright (c) 2011 Stefan Gustavson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the", "\n    float tt = t * float(NUM_CAM_POINTS);\n    int i = int(tt);\n    if (i >= NUM_CAM_POINTS - 1)\n        return camPoints[NUM_CAM_POINTS - 1];\n    float t0 = float(i);\n    float t1 = t0 + 1.0;\n    float t2 = t1 + 1.0;\n    float t3 = t2 + 1.0;\n    vec4 p0 = camPoints[i];\n    vec4 p1 = camPoints[i + 1];\n    vec4 p2 = camPoints[i + 2];\n    vec4 p3 = camPoints[i + 3];\n    vec4 h0 = 2.0 * p0 - 2.0 * p1 + p2 - p3;\n    vec4 h1 = -3.0 * p0 + 3.0 * p1 - 2.0 * p2 + p3;\n    vec4 h2 = p0 - 2.0 * p1 + p2;\n    vec4 h3 = -p0 + p1;\n    return h0 * pow(tt - t0, 3.0) + h1 * pow(tt - t0, 2.0) + h2 * (tt - t0) + h3;\n}\n\n// This is the main function for the camera.\n// It takes in a time t, and returns a camera position,\n// a camera target, and a camera up vector.\n// It also returns the camera's field of view.\n// The camera is a simple third-person camera,\n// with a field of view of 60 degrees.\n// The camera is always looking at the target,\n// and the up vector is always the world up vector.\n// The camera is always at a fixed distance from the target.\n// The camera is always at a fixed height above the target.\n// The camera is always at a fixed angle from the target.\n// The camera is always at a fixed angle from the world up vector.\n// The camera is always at a fixed angle from the world right vector.\n// The camera is always at a fixed angle from the world forward vector.", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 uv)\n{\n    return fract(sin(dot(uv, vec3(12.9898, 78.233, 15.787))) * 43758.5453);\n}\n\nfloat Hash4d(vec4 uv)\n{\n    return fract(sin(dot(uv, vec4(12.9898, 78.233, 15.787, 78.233))) * 43758.5453);\n}\n\n// noise functions\nfloat Noise1d(float u)\n{\n    float f = fract(u);\n    float a = Hash1d(floor(u));\n    float b = Hash1d(floor(u) + 1.0);\n    return mix(a, b, f);\n}\n\nfloat Noise2d(vec2 uv)\n{\n    vec2 f = fract(uv);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    float a = Hash2d(floor(uv));\n    float b = Hash2d(floor(uv) + vec2(1.0, 0.0));\n    float c = Hash2d(floor(uv) + vec2(0.0, 1.0));\n    float d = Hash2d(floor(uv) + vec2(1.0, 1.0));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat Noise3d(vec3 uv)\n{\n    vec3 f = fract(uv);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n", "\n\tfloat n = 0.0;\n\tfloat z = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tn += sin(p.x + p.y + p.z + z);\n\t\tz += 0.1;\n\t\tp *= 1.3;\n\t}\n\treturn n;\n}\n\n// 3D OpenSimplex2S noise\n//\n// Based on the 2D OpenSimplex2S noise, this 3D noise function uses the same simplex grid as the 2D version, but with\n// a different set of primitive curves for the third dimension.\n//\n// The third dimension uses the same curve as the first, but the second dimension uses a curve that is rotated by 60\n// degrees. This is the same curve used in the 2D OpenSimplex2S noise, but rotated to be perpendicular to the first\n// curve.\n//\n// The result is a grid of simplex cells that are rotated and skewed in a way that gives a more even distribution of\n// noise values than the 2D version.\n//\n// The 3D noise function is a little slower than the 2D version, but it is still very fast.\n//\n// The 3D noise function is also a little more accurate than the 2D version, since it uses a different set of curves\n// for the third dimension.\n//\n// The 3D noise function is also a little more consistent than the 2D version, since it uses a different set of curves\n// for the third dimension.\n//\n// The 3D noise function is also a little more random than the 2D version, since it uses a different set of curves\n// for the third dimension.\n//\n// The 3D noise function is also a little more interesting than the 2D version, since it uses a different set of curves\n// for the third dimension.\n//\n// The 3D noise function is also a little more complex than the 2D version, since it uses a different set of curves\n// for the third dimension.\n//\n// The 3D noise function is also a little more versatile than the 2D version, since it uses a different set of curves\n// for the third dimension.\n", "\n    float d = 1000.0;\n    float t = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x) + abs(p.y) + abs(p.z) - 0.05);\n        d = min(d, abs(p.x", "\n    vec3 envColor = vec3(0.0);\n\n    // Fade from bottom to top.\n    float fade = 1.0 - clamp(rayDir.y, 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * fade;\n\n    // Add a softbox.\n    float softbox = 1.0 - clamp(dot(rayDir, sunDir), 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * softbox;\n\n    // Add 4 lights in a circle.\n    float circle = 1.0 - clamp(dot(rayDir, sunDir), 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * circle;\n\n    return envColor;\n}\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor3(vec3 rayDir, vec3 sunDir)\n{\n    vec3 envColor = vec3(0.0);\n\n    // Fade from bottom to top.\n    float fade = 1.0 - clamp(rayDir.y, 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * fade;\n\n    // Add a softbox.\n    float softbox = 1.0 - clamp(dot(rayDir, sunDir), 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * softbox;\n\n    // Add 4 lights in a circle.\n    float circle = 1.0 - clamp(dot(rayDir, sunDir), 0.0, 1.0);\n    envColor += vec3(0.0, 0.0, 0.0) * circle;\n\n    return envColor;\n}\n\n// This is a procedural environment map with a giant overhead softbox", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// ------------------------------------------------------------------------\n// 2D noise\n// ------------------------------------------------------------------------\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = hash( i + vec2(0.0,0.0) );\n    float b = hash( i + vec2(1.0,0.0) );\n    float c = hash( i + vec2(0.0,1.0) );\n    float d = hash( i + vec2(1.0,1.0) );\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n           (c - a)* u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// ------------------------------------------------------------------------\n// 3D noise\n// ------------------------------------------------------------------------\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0", "\n    vec3 posToSphere = spherePos - pos;\n    float t = dot(posToSphere, dirVecPLZNormalizeMeFirst);\n    if (t < 0.0)\n        return -1.0;\n    float d2 = dot(posToSphere, posToSphere) - t * t;\n    if (d2 > rad * rad)\n        return -1.0;\n    return t - sqrt(rad * rad - d2);\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 normal)\n{\n    vec3 posToSphere = spherePos - pos;\n    float t = dot(posToSphere, dirVecPLZNormalizeMeFirst);\n    if (t < 0.0)\n        return -1.0;\n    float d2 = dot(posToSphere, posToSphere) - t * t;\n    if (d2 > rad * rad)\n        return -1.0;\n    normal = normalize(posToSphere + t * dirVecPLZNormalizeMeFirst);\n    return t - sqrt(rad * rad - d2);\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 normal, out vec3 hitPos)\n{\n    vec3 posToSphere = spherePos - pos;\n    float t = dot(posToSphere, dirVecPLZNormalizeMeFirst);\n    if (t < 0.0)\n        return -1.0;\n    float d2 = dot(posToSphere, posToSphere) - t * t;\n    if (d2 > rad * rad)\n        return -1.0;\n    normal = normalize(posToSphere + t * dirVecPLZNormalizeMeFirst);\n    hitPos = pos + t * dirVecPLZNormalizeMeFirst;\n    return t - sqrt(rad * rad - d2);\n}\n\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out", "\n    vec2 d = vec2(0.0);\n    d.x = DistanceToSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    d.y = DistanceToSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    return d;\n}\n\n// Calculate the normal of the object.\nvec3 Normal(vec3 p)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        DistanceToObject(p + e.xyy).x - DistanceToObject(p - e.xyy).x,\n        DistanceToObject(p + e.yxy).x - DistanceToObject(p - e.yxy).x,\n        DistanceToObject(p + e.yyx).x - DistanceToObject(p - e.yyx).x\n    ));\n}\n\n// Calculate the color of the object.\nvec3 Color(vec3 p)\n{\n    vec3 n = Normal(p);\n    vec3 l = normalize(vec3(0.0, 1.0, 0.0));\n    float d = DistanceToObject(p).x;\n    return vec3(1.0, 0.0, 0.0) * clamp(dot(n, l), 0.0, 1.0);\n}\n\n// Calculate the color of the object.\nvec3 Color(vec3 p, vec3 n, vec3 l)\n{\n    return vec3(1.0, 0.0, 0.0) * clamp(dot(n, l), 0.0, 1.0);\n}\n\n// Calculate the color of the object.\nvec3 Color(vec3 p, vec3 n, vec3 l, vec3 a)\n{\n    return vec3(1.0, 0.0, 0.0) * clamp(dot(n, l), 0.0, 1.0);\n}\n\n// Calculate the color of the object.\nvec3 Color", "\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n\nvec3 mapD1(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n\nvec3 mapD2(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n\nvec3 mapD3(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n\nvec3 mapD4(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y = sin(p.x * 2.0) * 0.5 + 0.5;\n    p.z = sin(p.x * 2.0) * 0.5 + 0.5;\n    return p;\n}\n\nvec3 mapD5(float t)\n{\n    vec3 p = vec3(t, 0.0, 0.0);\n    p.y =", "\n    vec3 p = map(t);\n    float e = 0.001;\n    vec3 dp = map(t + e) - map(t - e);\n    return normalize(dp);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    vec3 p = map(t);\n    float e = 0.001;\n    vec3 dp = map(t + e) - map(t - e);\n    vec3 d2p = map(t + 2.0 * e) - map(t - 2.0 * e) - 2.0 * dp;\n    return normalize(d2p);\n}\n\n// curve curvature\nfloat mapK(float t)\n{\n    vec3 dp = mapD1(t);\n    vec3 d2p = mapD2(t);\n    return length(cross(dp, d2p)) / pow(length(dp), 3.0);\n}\n\n// curve torsion\nfloat mapT(float t)\n{\n    vec3 dp = mapD1(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD3(t);\n    return dot(cross(dp, d2p), d3p) / pow(length(dp), 4.0);\n}\n\n// curve torsion\nfloat mapR(float t)\n{\n    vec3 dp = mapD1(t);\n    vec3 d2p = mapD2(t);\n    return length(dp) / sqrt(1.0 + dot(dp, dp) + dot(d2p, d2p));\n}\n\n// curve torsion\nfloat mapA(float t)\n{\n    vec3 dp = mapD1(t);\n    vec3 d2p = mapD2(t);\n    return length(dp) / sqrt(1.0 + dot(dp, dp) + dot(d2p, d2p));\n}\n\n// curve torsion\nfloat mapB(float t)\n{\n    vec3 dp = mapD1(t);\n    vec3 d2p = mapD2(t);\n    return", "\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    return d2p;\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD3(t);\n    return d3p;\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD3(t);\n    vec3 d4p = mapD4(t);\n    return d4p;\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD3(t);\n    vec3 d4p = mapD4(t);\n    vec3 d5p = mapD5(t);\n    return d5p;\n}\n\n// curve sixth derivative (pop)\nvec3 mapD6(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD3(t);\n    vec3 d4p = mapD4(t);\n    vec3 d5p = mapD5(t);\n    vec3 d6p = mapD6(t);\n    return d6p;\n}\n\n// curve seventh derivative (pop)\nvec3 mapD7(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 d2p = mapD2(t);\n    vec3 d3p = mapD", "\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot(pa-h*ba,pa-h*ba), h );\n}\n\n// signed squared distance between point and segment\nfloat sqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return dot(pa-h*ba,pa-h*ba);\n}\n\n// signed distance to plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz)+n.w;\n}\n\n// signed distance to box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) +\n           min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// signed distance to cylinder\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\n// signed distance to torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.", "\n    vec3 ab = b-a;\n    vec3 oa = a-o;\n    float t = dot( ab, oa );\n    float f = dot( ab, ab );\n    float g = dot( oa, oa );\n    float h = dot( oa, d );\n    float k = dot( ab, d );\n    float m = t*t - f*g + 2.0*t*h - f*k;\n    float n = 4.0*f*f*g - f*f*f - f*m;\n    float s = sqrt( clamp( n, 0.0, 1.0 ) );\n    float r0 = clamp( ( t - s*f + h ) / n, 0.0, 1.0 );\n    float r1 = clamp( ( t + s*f + h ) / n, 0.0, 1.0 );\n    float d0 = dot( oa + r0*ab, oa + r0*ab );\n    float d1 = dot( oa + r1*ab, oa + r1*ab );\n    return vec2( min( d0, d1 ), min( r0, r1 ) );\n}\n\n// signed squared distance between ray and segment\nfloat ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 u = usqdLineSegment( a, b, o, d );\n    return sign( u.y ) * u.x;\n}\n\n// signed squared distance between ray and triangle\nfloat ssqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n    vec3 ba = b-a;\n    vec3 oa = a-o;\n    vec3 n = cross( ba, c-a );\n    float h = dot( oa, n );\n    if( h > 0.0 )\n    {\n        float t = dot( n, d );\n        if( t > 0.0 )\n        {\n            float s = dot( d, oa );\n            if( s > 0.0 )\n            {", "\n  vec2 w = abs(p) - b;\n  float d = length(max(w,0.0)) + min(max(w.x,w.y),0.0);\n  return d - r.x;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n  vec2 e;\n  vec2 v0, v1, v2;\n  float s, t, a0, a1, a2, k;\n\n  v0 = b - a;\n  v1 = c - b;\n  v2 = a - c;\n\n  e = p - a;\n  s = dot(e,v0);\n  t = dot(e,v1);\n  if( t < 0.0 ) return length(e);\n  if( s < 0.0 ) return length(e);\n  a0 = dot(v0,v0);\n  a1 = dot(v0,v1);\n  a2 = dot(v1,v1);\n  k = a0*a2 - a1*a1;\n  t = clamp( t*(k-s*a1)/k, 0.0, 1.0 );\n  s = clamp( s*(k-t*a1)/k, 0.0, 1.0 );\n  return length(e - s*v0 - t*v1);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length", "\n    float sunDot = dot(rayDir, sunDir);\n    float sunDot2 = sunDot * sunDot;\n    float sunDot3 = sunDot2 * sunDot;\n    float sunDot4 = sunDot3 * sunDot;\n    float sunDot5 = sunDot4 * sunDot;\n    float sunDot6 = sunDot5 * sunDot;\n    float sunDot7 = sunDot6 * sunDot;\n    float sunDot8 = sunDot7 * sunDot;\n    float sunDot9 = sunDot8 * sunDot;\n    float sunDot10 = sunDot9 * sunDot;\n    float sunDot11 = sunDot10 * sunDot;\n    float sunDot12 = sunDot11 * sunDot;\n    float sunDot13 = sunDot12 * sunDot;\n    float sunDot14 = sunDot13 * sunDot;\n    float sunDot15 = sunDot14 * sunDot;\n    float sunDot16 = sunDot15 * sunDot;\n    float sunDot17 = sunDot16 * sunDot;\n    float sunDot18 = sunDot17 * sunDot;\n    float sunDot19 = sunDot18 * sunDot;\n    float sunDot20 = sunDot19 * sunDot;\n    float sunDot21 = sunDot20 * sunDot;\n    float sunDot22 = sunDot21 * sunDot;\n    float sunDot23 = sunDot22 * sunDot;\n    float sunDot24 = sunDot23 * sunDot;\n    float sunDot25 = sunDot24 * sunDot;\n    float sunDot26 = sunDot25 * sunDot;\n    float sunDot27 = sunDot26 * sunDot;\n    float sunDot28 = sunDot27 * sunDot;\n    float sunDot29 = sunDot28 * sunDot;\n    float sunDot30 = sunDot29 * sunDot;\n    float sunDot31 = sunDot30 * sunDot;\n    float sunDot32 = sunDot31 * sunDot;\n    float sunDot33 = sunDot32 * sunDot;\n    float sun", "\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// This is the function that actually does the ray marching.\n// It takes in a ray origin and a ray direction and returns a vec4\n// which contains the distance to the surface, the surface normal,\n// and the material type.\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 rd_ = rd;\n    vec3 ro_ = ro;\n    vec4 mat = vec4(0.0);\n\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec4 res = map( p );\n\n        if( res.a > 0.0 )\n        {\n            mat = res;\n            break;\n        }\n\n        t += res.a;\n    }\n\n    return mat;\n}\n\n// This is the function that actually does the ray marching.\n// It takes in a ray origin and a ray direction and returns a vec4\n// which contains the distance to the surface, the surface normal,\n// and the material type.\nvec4 raymarch_shadow( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 rd_ = rd;\n    vec3 ro_ = ro;\n    vec4 mat = vec4(0.0);\n\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec4 res = map( p );\n\n        if( res.a > 0.0 )\n        {\n            mat = res;\n            break;\n        }\n\n        t += res.a;\n    }\n\n    return mat;\n}\n\n// This is the function that actually", "\n    vec3 balloonCenter = vec3(0.0, 0.0, 0.0);\n    vec3 balloonSize = vec3(1.0, 1.0, 1.0);\n    vec3 balloonPosition = currentRayPosition - balloonCenter;\n    balloonPosition.y = abs(balloonPosition.y);\n    balloonPosition.y = max(balloonPosition.y, 0.0);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.z);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x);\n    balloonPosition.y = max(balloonPosition.y, -balloonPosition.x", "\n\n  // distance to thing 1\n  float d1 = distance( thing1, vUv );\n  // distance to thing 2\n  float d2 = distance( thing2, vUv );\n\n  // if d1 is less than d2\n  if( d1 < d2 ){\n    // return thing 1\n    return thing1;\n  }\n  // if d2 is less than d1\n  if( d2 < d1 ){\n    // return thing 2\n    return thing2;\n  }\n  // if they are equal\n  if( d1 == d2 ){\n    // return thing 1\n    return thing1;\n  }\n\n  // return thing 1\n  return thing1;\n\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){\n\n  // distance to thing 1\n  float d1 = distance( thing1, vUv );\n  // distance to thing 2\n  float d2 = distance( thing2, vUv );\n\n  // if d1 is less than d2\n  if( d1 < d2 ){\n    // return thing 1\n    return thing1;\n  }\n  // if d2 is less than d1\n  if( d2 < d1 ){\n    // return thing 2\n    return thing2;\n  }\n  // if they are equal\n  if( d1 == d2 ){\n    // return thing 1\n    return thing1;\n  }\n\n  // return thing 1\n  return thing1;\n\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2 ){\n\n", "\n\n  // This is the distance to the closest thing in the world\n  float closestDistance = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance2 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance3 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance4 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance5 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance6 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance7 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance8 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance9 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance10 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance11 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance12 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance13 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance14 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance15 = 10000.0;\n\n  // This is the distance to the closest thing in the world\n  float closestDistance16 = 10000.0;\n\n  // This is the distance to the", "\n\n\t// We are going to use a small value to figure out\n\t// how much the SDF changes in each direction.\n\t// This is a very small value, but it is not\n\t// zero, because zero would cause the SDF to\n\t// return zero, which is not what we want.\n\tfloat epsilon = 0.0001;\n\n\t// We are going to figure out how much the SDF\n\t// changes in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in each direction.\n\t// We are going to do this by adding and subtracting\n\t// the epsilon value from the position of the hit.\n\t// We are going to do this in", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the main function that gets called\n// for every pixel.\nvec3 doMain(vec2 fragCoord){\n    // this is the ray origin, which is the camera\n    // position.\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\n    // this is the ray direction. we have to convert\n    // the 2d pixel coordinate to a 3d ray direction.\n    // this is what the camera matrix is for.\n    vec3 rayDirection = normalize(vec3(\n        cameraMatrix * vec4(\n            (fragCoord.x / u_resolution.x) * 2.0 - 1.0,\n            (fragCoord.y / u_resolution.y) * 2.0 - 1.0,\n            1.0,\n            1.0\n        )\n    ));\n\n    // now we have to figure out what object we're\n    // hitting.\n    float closestObjectDistance = 1000000.0;\n    vec3 closestObjectColor = vec3(0.0, 0.0, 0.0);\n    for(int i = 0; i < u_numObjects; i++){\n        // this is the object's position.\n        vec3 objectPosition = u_objectPositions[i];\n\n        // this is the object's radius.\n        float objectRadius = u_objectRadii[i];\n\n        // this is the object's color.\n        vec3 objectColor = u_objectColors[i];\n\n        // now we have to figure out if we're hitting\n        // the object.\n        float objectDistance = intersectSphere(\n            rayOrigin,\n            rayDirection,\n            objectPosition,\n            objectRadius\n        );\n\n        // if we're hitting the object, and it's closer\n        // than the closest object we've hit so far,\n        // then we have to update the closest object.\n        if(objectDistance < closestObjectDistance){\n            closestObjectDistance = objectDistance;\n            closestObjectColor = objectColor;\n        ", "\n  vec3 color = vec3(0.0,0.0,0.0);\n  vec3 lightDirection = normalize(vec3(1.0,1.0,1.0));\n  float lightIntensity = max(0.0,dot(normalOfSurface,lightDirection));\n  color = vec3(lightIntensity);\n  return color;\n}\n\n// This function is used to calculate the color of the sphere\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n  vec3 color = vec3(0.0,0.0,0.0);\n  vec3 lightDirection = normalize(vec3(1.0,1.0,1.0));\n  float lightIntensity = max(0.0,dot(normalOfSurface,lightDirection));\n  color = vec3(lightIntensity);\n  return color;\n}\n\n// This function is used to calculate the color of the plane\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doPlaneColor(vec3 positionOfHit, vec3 normalOfSurface ){\n  vec3 color = vec3(0.0,0.0,0.0);\n  vec3 lightDirection = normalize(vec3(1.0,1.0,1.0));\n  float lightIntensity = max(0.0,dot(normalOfSurface,lightDirection));\n  color = vec3(lightIntensity);\n  return color;\n}\n\n// This function is used to calculate the color of the cylinder\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n  vec3 color = vec3(0.0,0.0,0.0);\n  vec3 lightDirection = normalize(vec3(1.0,1.0,1.0));\n  float lightInt", "\n\n\t// this is the color of the world\n\tvec3 worldColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sky\n\tvec3 skyColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the ground\n\tvec3 groundColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sun\n\tvec3 sunColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the moon\n\tvec3 moonColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the stars\n\tvec3 starColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the clouds\n\tvec3 cloudColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the fog\n\tvec3 fogColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the water\n\tvec3 waterColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the sand\n\tvec3 sandColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the grass\n\tvec3 grassColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the tree\n\tvec3 treeColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the rock\n\tvec3 rockColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the snow\n\tvec3 snowColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the ice\n\tvec3 iceColor = vec3(0.0,0.0,0.0);\n\n\t// this is the color of the lava\n\tvec3 lavaColor", "\n  return pow(x, log(b) / log(0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec3 bias(vec3 x, float b) {\n  return pow(x, log(b) / log(0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec4 bias(vec4 x, float b) {\n  return pow(x, log(b) / log(0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain(float x, float b) {\n  float e = bias(b, 0.5);\n  return mix(2.0 * x * pow(x, e - 1.0), 1.0 - 2.0 * (1.0 - x) * pow(1.0 - x, e - 1.0), step(x, 0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec3 gain(", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat rand(vec2 p, float t){\n    return rand(vec2(p.x + t, p.y + t));\n}\n\nvec2 rand2(vec2 p, float t){\n    return vec2(rand(p, t), rand(vec2(p.y, p.x), t));\n}\n\nvec2 rand2(vec2 p){\n    return vec2(rand(p), rand(vec2(p.y, p.x)));\n}\n\nvec2 rand2(vec2 p, vec2 t){\n    return vec2(rand(p, t.x), rand(vec2(p.y, p.x), t.y));\n}\n\nvec2 rand2(vec2 p, float t, float t2){\n    return vec2(rand(p, t), rand(vec2(p.y, p.x), t2));\n}\n\nvec2 rand2(vec2 p, vec2 t, vec2 t2){\n    return vec2(rand(p, t.x), rand(vec2(p.y, p.x), t2.y));\n}\n\nvec2 rand2(vec2 p, vec2 t, float t2){\n    return vec2(rand(p, t.x), rand(vec2(p.y, p.x), t2));\n}\n\nvec2 rand2(vec2 p, float t, vec2 t2){\n    return vec2(rand(p, t), rand(vec2(p.y, p.x), t2.y));\n}\n\nvec2 rand2(vec2 p, float t, float t2, float t3){\n    return vec2(rand(p, t), rand(vec2(p.y, p.x), t2));\n}\n\nvec2 rand2(vec2 p, float t, float t2, float t3, float t4){\n    return vec2", "\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123) * (1.0 - 0.00001);\n}\n\n// creates white noise in the range 0..1 excluding 0..0.00001\nfloat rand_exclusive_0(vec2 p){\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123) * (1.0 - 0.00001) + 0.00001;\n}\n\n// creates white noise in the range 0..1 excluding 0.99999..1\nfloat rand_exclusive_1(vec2 p){\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123) * (1.0 - 0.00001);\n}\n\n// creates white noise in the range 0..1 excluding 0.5\nfloat rand_exclusive_05(vec2 p){\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453123) * (1.0 - 0.00001) + 0.00001;\n}\n\n// creates white noise in the range 0..1 excluding 0.5\nfloat rand_exclusive_05(vec2 p){\n    return fract(sin(", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fdistance function for box\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) +\n           length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fdistance function for cylinder\n// input h --> is cylinder height\n// input r --> is cylinder radius\n// pretty simple, just compare point to cylinder height and radius\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fdistance function for torus\n// input r1 --> is torus outer radius\n// input r2 --> is torus inner radius\n// pretty simple, just compare point to torus outer and inner radius\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\n// ~~~~~~~ signed fdistance function for rounded box\n// input b --> is box size\n// input r --> is box rounding radius\n// pretty simple, just compare point to box size and rounding radius\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return min(min(q.x, q.y), q.z) +\n           length(max(q, 0.0)) - r;\n}\n\n// ~~~~~~~ signed fdistance function for rounded cylinder\n// input h --> is cylinder height\n// input r1 --> is cylinder outer radius\n// input r2 --> is cylinder inner", "\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\n//\n// simply subtract the sphere radius from the distance to the origin\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\n//\n// simply subtract the box dimensions from the distance to the origin\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\n//\n// simply subtract the cylinder dimensions from the distance to the origin\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\treturn length(p.xz)-c.x;\n}\n\n// ~~~~~~~ signed distance function for capsule\n// input c --> capsule specs where:\n// \tc.x = capsule radius\n//\tc.y = capsule height\n//\n// simply subtract the capsule dimensions from the distance to the origin\nfloat sdCapsule(vec3 p, vec2 c)\n{\n\tvec2 d = abs(vec2(length(p.xz)-c.x,p.y))-c.y;\n\treturn min(max(d.x,d.y),0.0)+length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for rounded box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z =", "\n    float h = clamp( 0.5 - 0.5*(d2-d1)/d1, 0.0, 1.0 );\n    return mix( d2, d1, h ) - h*h*h*d1*(1.0/6.0);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/d1, 0.0, 1.0 );\n    return mix( d2, d1, h ) + h*h*h*d1*(1.0/6.0);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - h*h*h*k*(1.0/6.0);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.", "\n    return min(d1,d2);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h );\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float e )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow( h, e ) );\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float e, float a )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow( h, e*a ) );\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float e, float a, float b )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow( h, e", "\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    q.xy *= mat2(cos(yaw),-sin(yaw),sin(yaw),cos(yaw));\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// ~~~~~~~ domain", "\n    if(o1.x < o2.x) return o1;\n    return o2;\n}\n\n// ~~~~~~~ do Subtraction / difference 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if(), and we negate the distance\nvec2 opS(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x) return vec2(o1.x, o1.y);\n    return vec2(-o2.x, o2.y);\n}\n\n// ~~~~~~~ do Intersection / difference 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if(), and we negate the distance\nvec2 opI(vec2 o1, vec2 o2)\n{\n    if(o1.x > o2.x) return vec2(o1.x, o1.y);\n    return vec2(-o2.x, o2.y);\n}\n\n// ~~~~~~~ do Intersection / difference 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if(), and we negate the distance\nvec2 opX(vec2 o1, vec2 o2)\n{\n    if(o1.x > o2.x) return vec2(o1.x, o1.y);\n    return vec2(-o2.x, o2.y);\n}\n\n// ~~~~~~~ do Intersection / difference 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if(), and we negate the distance\nvec2 opD(vec2 o1, vec2 o2)\n{\n    if(o1.x > o2.x) return vec2(o1.x,", "\n    float d = 1e10;\n    float id = -1.;\n\n    // sphere\n    float d1 = length(p) - 1.;\n    if (d1 < d) {\n        d = d1;\n        id = 1.;\n    }\n\n    // box\n    vec3 q = abs(p) - vec3(.5,.5,.5);\n    float d2 = length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n    if (d2 < d) {\n        d = d2;\n        id = 2.;\n    }\n\n    // torus\n    vec2 q1 = vec2(length(p.xz) -.5, p.y);\n    float d3 = length(q1) -.1;\n    if (d3 < d) {\n        d = d3;\n        id = 3.;\n    }\n\n    // cylinder\n    vec2 q2 = vec2(length(p.xz) -.2, p.y);\n    float d4 = length(q2) -.1;\n    if (d4 < d) {\n        d = d4;\n        id = 4.;\n    }\n\n    // cone\n    float d5 = max(abs(p.z) -.2, abs(length(p.xy) -.2));\n    if (d5 < d) {\n        d = d5;\n        id = 5.;\n    }\n\n    // plane\n    float d6 = p.y + 1.;\n    if (d6 < d) {\n        d = d6;\n        id = 6.;\n    }\n\n    return vec2(d, id);\n}\n\n// ~~~~~~~ shade the world\n// input p --> is ray position\n// input n --> is ray normal\n// input id --> is object id\n// output is color\nvec3 shade(vec3 p, vec3 n, float id)\n{\n    vec3 col = vec3(0);\n\n    ", "\n\tfloat t = 0.0;\n\tfloat hit = 0.0;\n\tfor(int i=0; i<MAX_MARCHING_STEPS; i++)\n\t{\n\t\tvec3 p = ro + rd*t;\n\t\tfloat d = map(p);\n\t\tif(d<0.001)\n\t\t{\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tif(t>MAX_DISTANCE)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2(t, hit);\n}\n\n// ~~~~~~~ get the normal of the surface at a given point\n// input p --> point on surface\n// output normal vector\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ~~~~~~~ get the color of the surface at a given point\n// input p --> point on surface\n// output color\nvec3 getColor(vec3 p)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// ~~~~~~~ get the light intensity at a given point\n// input p --> point on surface\n// input n --> normal vector\n// output light intensity\nfloat getLight(vec3 p, vec3 n)\n{\n\tvec3 l = normalize(vec3(0.0, 0.0, 1.0));\n\treturn max(dot(n, l), 0.0);\n}\n\n// ~~~~~~~ get the color of the surface at a given point\n// input p --> point on surface\n// input n --> normal vector\n// output color\nvec3 getLightColor(vec3 p, vec3 n)\n{\n\treturn vec3(1.0, 1.0, 1.0", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = map(pos);\n        if (d < 0.001)\n        {\n            col = vec3(0.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    col = render(ro, rd);\n    fragColor = vec4(col, 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Raymarching - 2D';\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n  }\n  fragmentPrecision?(): string {\n    return PRECISION_MEDIUMP;\n  }\n  destory(): void {}\n  initial?(gl: WebGLRenderingContext, program: WebGLProgram): Function {\n    return () => {};\n  }\n}<|endoftext|>import { createCanvas, iSub, PRECISION_MEDIUMP, WEBGL_2 } from '../libs';\nimport * as webglUtils from '../webgl-utils';\n\nconst fragment = `\n// ------------------------------", "\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross( vec3(sin(roll), cos(roll),0.0), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    return mat3( uu, vv, ww );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up )\n{\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross( up, ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    return mat3( uu, vv, ww );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up, in vec3 right )\n{\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross( up, ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    return mat3( uu, vv, ww);\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up, in vec3 right, in vec3 forward )\n{\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross( up, ww ) );\n    vec3 v", "\n    if (id == 0.0) return color0;\n    if (id == 1.0) return color1;\n    if (id == 2.0) return color2;\n    if (id == 3.0) return color3;\n    if (id == 4.0) return color4;\n    if (id == 5.0) return color5;\n    if (id == 6.0) return color6;\n    if (id == 7.0) return color7;\n    if (id == 8.0) return color8;\n    if (id == 9.0) return color9;\n    if (id == 10.0) return color10;\n    if (id == 11.0) return color11;\n    if (id == 12.0) return color12;\n    if (id == 13.0) return color13;\n    if (id == 14.0) return color14;\n    if (id == 15.0) return color15;\n    if (id == 16.0) return color16;\n    if (id == 17.0) return color17;\n    if (id == 18.0) return color18;\n    if (id == 19.0) return color19;\n    if (id == 20.0) return color20;\n    if (id == 21.0) return color21;\n    if (id == 22.0) return color22;\n    if (id == 23.0) return color23;\n    if (id == 24.0) return color24;\n    if (id == 25.0) return color25;\n    if (id == 26.0) return color26;\n    if (id == 27.0) return color27;\n    if (id == 28.0) return color28;\n    if (id == 29.0) return color29;\n    if (id == 30.0) return color30;\n    if (id", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input r --> sphere radius\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input b --> box size\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\nfloat sdCylinder(vec3 p, vec2 c)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - c;\n    return min(max(d.x,d.y),0.0) +\n        length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for capsule\n// input c --> capsule specs where:\n//  c.x = capsule radius\n//  c.y = capsule height\nfloat sdCapsule(vec3 p, vec2 c)\n{\n    vec2 q = vec2(length(p.xz)-c.x,p.y);\n    return length(max(abs(q)-c.y,0.0));\n}\n\n// ~~~~~~~ signed distance function for rounded box\n// input b --> box size\n// input r --> box rounding radius\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return min(min(q.x,q.y),q.z) +\n        length(max(q,0.0)) - r;\n}\n\n// ~~~~~~~ signed distance function for rounded cylinder\n// input c --> cylinder specs where:", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        ps.w --> radius\nfloat sdSphere(vec3 p, vec4 ps)\n{\n    return length(p - ps.xyz) - ps.w;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        ps.w --> unused\nfloat sdBox(vec3 p, vec4 ps)\n{\n    vec3 q = abs(p) - ps.xyz;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        ps.w --> radius\nfloat sdCylinder(vec3 p, vec4 ps)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(ps.w, ps.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        ps.w --> radius\nfloat sdTorus(vec3 p, vec4 ps)\n{\n    vec2 q = vec2(length(p.xz) - ps.w, p.y);\n    return length(q) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for capsule\n//  ", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    float d = mix( d1, d2, bf);\n    vec3 c = mix( c1, c2, bf);\n    return vec4( d, c);\n}\n\n// ~~~~~~~ distance union, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opUnion( vec4 o1, vec4 o2, float bf)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    float d = min( d1, d2);\n    vec3 c = (d1 < d2)? c1 : c2;\n    return vec4( d, c);\n}\n\n// ~~~~~~~ distance difference, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opDifference( vec4 o1, vec4 o2, float bf)\n{\n    float d1 = o1.x;\n    float d2 = o2.x;\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    float d = max( d1, -d2);\n    vec3 c = (d1 > -d2)? c1 : c2;\n    return vec4( d, c);\n}\n\n// ~~~~~~~ distance intersection", "\n\treturn max(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, adds d2 to d1\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> added distance\nfloat opUnion(float d1,float d2)\n{\n\treturn min(d1,d2);\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> intersected distance\nfloat opIntersect(float d1,float d2)\n{\n\treturn max(d1,d2);\n}\n\n// ~~~~~~~ do shape blend, blends d2 and d1\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// input k --> blend factor\n// output --> blended distance\nfloat opBlend(float d1,float d2,float k)\n{\n\treturn mix(d1,d2,k);\n}\n\n// ~~~~~~~ do shape smooth subtract, smooths d2 out of d1\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// input k --> blend factor\n// output --> smooth subtracted distance\nfloat opSmoothSub(float d1,float d2,float k)\n{\n\tfloat h = clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);\n\treturn mix(d2,-d1,h) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape smooth union, smooths d2 into d1\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// input k --> blend factor\n// output --> smooth unioned distance\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n\tfloat h = clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);\n\treturn -(d2 + k", "\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightDir()\n{\n    vec3 lightDir = vec3(0.0, 0.0, 0.0);\n    return lightDir;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightColor()\n{\n    vec3 lightColor = vec3(0.0, 0.0, 0.0);\n    return lightColor;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightIntensity()\n{\n    vec3 lightIntensity = vec3(0.0, 0.0, 0.0);\n    return lightIntensity;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightAmbient()\n{\n    vec3 lightAmbient = vec3(0.0, 0.0, 0.0);\n    return lightAmbient;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightDiffuse()\n{\n    vec3 lightDiffuse = vec3(0.0, 0.0, 0.0);\n    return lightDiffuse;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightSpecular()\n{\n    vec3 lightSpecular = vec3(0.0, 0.0, 0.0);\n    return lightSpecular;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightShininess()\n{\n    vec3 lightShininess = vec3(0.0, 0.0, 0.0);\n    return lightShininess;\n}\n\n// ~~~~~~~~ generates world position of point light", "\n    // ~~~~~~~ sphere\n    // sphere is a simple object, it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it's just a sphere\n    // it", "\n    float t = 0.0;\n    float hit = 0.0;\n    float hitDist = 1000.0;\n    float hitID = 0.0;\n    float hitRatio = 0.0;\n    float hitDistRatio = 1.0;\n    float hitDistRatio2 = 1.0;\n    float hitDistRatio3 = 1.0;\n    float hitDistRatio4 = 1.0;\n    float hitDistRatio5 = 1.0;\n    float hitDistRatio6 = 1.0;\n    float hitDistRatio7 = 1.0;\n    float hitDistRatio8 = 1.0;\n    float hitDistRatio9 = 1.0;\n    float hitDistRatio10 = 1.0;\n    float hitDistRatio11 = 1.0;\n    float hitDistRatio12 = 1.0;\n    float hitDistRatio13 = 1.0;\n    float hitDistRatio14 = 1.0;\n    float hitDistRatio15 = 1.0;\n    float hitDistRatio16 = 1.0;\n    float hitDistRatio17 = 1.0;\n    float hitDistRatio18 = 1.0;\n    float hitDistRatio19 = 1.0;\n    float hitDistRatio20 = 1.0;\n    float hitDistRatio21 = 1.0;\n    float hitDistRatio22 = 1.0;\n    float hitDistRatio23 = 1.0;\n    float hitDistRatio24 = 1.0;\n    float hitDistRatio25 = 1.0;\n    float hitDistRatio26 = 1.0;\n    float hitDistRatio27 = 1.0;\n    float hitDistRatio28 = 1.0;\n    float hitDistRatio29 = 1.0;\n    float hitDistRatio30 = 1.0;\n    float hitDistRatio31 = 1.0;\n    float hitDistRatio32 = 1.0;\n    float hitDistRatio33 = 1.0;\n    float hit", "\n    float shadow = 1.0;\n    vec3 dir = lp - sp;\n    float len = length(dir);\n    dir = normalize(dir);\n    float t = 0.0;\n    float step = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        step = 0.01 * len;\n        t += step;\n        if(t > len)\n            break;\n        vec3 pos = sp + dir * t;\n        float h = getHeight(pos);\n        if(h > 0.0)\n        {\n            shadow = min(shadow, step / (len - t));\n            break;\n        }\n    }\n    return shadow;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    float shadow = 1.0;\n    vec3 dir = lp - sp;\n    float len = length(dir);\n    dir = normalize(dir);\n    float t = 0.0;\n    float step = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        step = 0.01 * len;\n        t += step;\n        if(t > len)\n            break;\n        vec3 pos = sp + dir * t;\n        float h = getHeight(pos);\n        if(h > 0.0)\n        {\n            shadow = min(shadow, step / (len - t));\n            break;\n        }\n    }\n    return shadow;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows", "\n    float d = 0.0;\n    float t = 0.0;\n    float tMax = 1.0;\n    float tMin = 0.0;\n    float tStep = 0.01;\n    float tMaxStep = 0.05;\n    float tMaxStep2 = 0.005;\n    float tMaxStep3 = 0.0005;\n    float tMaxStep4 = 0.00005;\n    float tMaxStep5 = 0.000005;\n    float tMaxStep6 = 0.0000005;\n    float tMaxStep7 = 0.00000005;\n    float tMaxStep8 = 0.000000005;\n    float tMaxStep9 = 0.0000000005;\n    float tMaxStep10 = 0.00000000005;\n    float tMaxStep11 = 0.000000000005;\n    float tMaxStep12 = 0.0000000000005;\n    float tMaxStep13 = 0.00000000000005;\n    float tMaxStep14 = 0.000000000000005;\n    float tMaxStep15 = 0.0000000000000005;\n    float tMaxStep16 = 0.00000000000000005;\n    float tMaxStep17 = 0.000000000000000005;\n    float tMaxStep18 = 0.0000000000000000005;\n    float tMaxStep19 = 0.00000000000000000005;\n    float tMaxStep20 = 0.", "\n    vec3 n = oN;\n    vec3 d = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = p + (rand3(p + float(i)) - 0.5) * 0.01;\n        vec3 nr = normal(r);\n        d += nr - n;\n        n = nr;\n    }\n    return d;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    vec3 n = oN;\n    vec3 d = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = p + (rand3(p + float(i)) - 0.5) * 0.01;\n        vec3 nr = normal(r);\n        d += nr - n;\n        n = nr;\n    }\n    return d;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    vec3 n = oN;\n    vec3 d = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = p + (rand3(p + float(i)) - 0.5) * 0.01;\n        vec3 nr = normal(r);\n        d += nr - n;\n        n = nr;\n    }\n    return d;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN -->", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyToneMapping(vec3 c)\n{\n    // tone mapping\n    float exposure = 0.001;\n    float white = 1.0;\n    float averageLuminance = 0.2;\n    float averageLuminance2 = 0.2;\n    float averageLuminance3 = 0.2;\n    float averageLuminance4 = 0.2;\n    float averageLuminance5 = 0.2;\n    float averageLuminance6 = 0.2;\n    float averageLuminance7 = 0.2;\n    float averageLuminance8 = 0.2;\n    float averageLuminance9 = 0.2;\n    float averageLuminance10 = 0.2;\n    float averageLuminance11 = 0.2;\n    float averageLuminance12 = 0.2;\n    float averageLuminance13 = 0.2;\n    float averageLuminance14 = 0.2;\n    float averageLuminance15 = 0.2;\n    float averageLuminance16 = 0.2;\n    float averageLuminance17 = 0.2;\n    float averageLuminance18 = 0.2;\n    float averageLuminance19 = 0.2;\n    float averageLuminance20 = 0.2;\n    float averageLuminance21 = 0.2;\n    float averageLuminance22 = 0.2;\n    float averageLuminance23 = 0.2;\n    float averageLuminance24 = 0.2;\n    float averageLuminance25 = 0.2;\n    float averageLuminance26 = 0.2;\n    float averageLumin", "\n    float fogAmount = 1.0 - exp(-fs.x*d);\n    vec3 fogColor = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor2 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor3 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor4 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor5 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor6 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor7 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor8 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor9 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor10 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor11 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor12 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor13 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor14 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor15 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor16 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor17 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor18 = mix(fc1,fc2,pow(fogAmount,fs.y));\n    vec3 fogColor19 = mix(fc1,fc2,", "\n\treturn cF + lF*d + qF*d*d;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nvec3 calculateLightAttn(float cF, float lF, float qF, vec3 d)\n{\n\treturn vec3(cF + lF*d.x + qF*d.x*d.x, cF + lF*d.y + qF*d.y*d.y, cF + lF*d.z + qF*d.z*d.z);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nvec3 calculateLightAttn(float cF, float lF, float qF, float d, vec3 c)\n{\n\treturn vec3(cF + lF*d + qF*d*d, cF + lF*d + qF*d*d, cF + lF*d + qF*d*d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nvec3 calculateLightAttn(float cF, float lF, float qF, vec3 d, vec3 c)\n{\n\treturn vec3(cF + l", "\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n//", "\n    vec3 col = vec3(0.0);\n    vec3 col_AA = vec3(0.0);\n    vec3 col_AA_tmp = vec3(0.0);\n    vec3 col_AA_tmp2 = vec3(0.0);\n    vec3 col_AA_tmp3 = vec3(0.0);\n    vec3 col_AA_tmp4 = vec3(0.0);\n    vec3 col_AA_tmp5 = vec3(0.0);\n    vec3 col_AA_tmp6 = vec3(0.0);\n    vec3 col_AA_tmp7 = vec3(0.0);\n    vec3 col_AA_tmp8 = vec3(0.0);\n    vec3 col_AA_tmp9 = vec3(0.0);\n    vec3 col_AA_tmp10 = vec3(0.0);\n    vec3 col_AA_tmp11 = vec3(0.0);\n    vec3 col_AA_tmp12 = vec3(0.0);\n    vec3 col_AA_tmp13 = vec3(0.0);\n    vec3 col_AA_tmp14 = vec3(0.0);\n    vec3 col_AA_tmp15 = vec3(0.0);\n    vec3 col_AA_tmp16 = vec3(0.0);\n    vec3 col_AA_tmp17 = vec3(0.0);\n    vec3 col_AA_tmp18 = vec3(0.0);\n    vec3 col_AA_tmp19 = vec3(0.0);\n    vec3 col_AA_tmp20 = vec3(0.0);\n    vec3 col_AA_tmp21 = vec3(0.0);\n    vec3 col_AA_tmp22 = vec3(0.0);\n    vec3 col_AA_tmp23 = vec3(0.0);\n    vec3 col_AA_tmp24 = vec3(0.0);\n    vec3 col_AA_tmp25 = vec3(0.0);\n    vec3 col_AA_tmp26 = vec3(0.0);", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 c = vec2(0.0, 0.0);\n    vec2 z = uv;\n\n    float iterations = 0.0;\n    float maxIterations = 100.0;\n\n    for(float i = 0.0; i < maxIterations; i++)\n    {\n        float x = z.x * z.x - z.y * z.y;\n        float y = 2.0 * z.x * z.y;\n\n        z = vec2(x, y) + c;\n\n        if(length(z) > 2.0)\n        {\n            iterations = i;\n            break;\n        }\n    }\n\n    float color = iterations / maxIterations;\n    color = pow(color, 0.2);\n\n    fragColor = vec4(color, color, color, 1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n`;\n\nexport default mandelbrot;", "\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sph(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// simple torus distance field\nfloat tor(vec2 p, float r1, float r2)\n{\n    return length(vec2(length(p)-r1,r2));\n}\n\n// simple rounded box distance field\nfloat rbox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// simple rounded cylinder distance field\nfloat rcyl(vec2 p, float r, float h)\n{\n    return max(length(p) - r, abs(p.y) - h);\n}\n\n// simple rounded sphere distance field\nfloat rsph(vec2 p, float r, float h)\n{\n    return max(length(p) - r, abs(p.y) - h);\n}\n\n// simple rounded torus distance field\nfloat rtor(vec2 p, float r1, float r2, float h)\n{\n    return max(length(vec2(length(p)-r1,r2)), abs(p.y) - h);\n}\n\n// simple rounded capsule distance field\nfloat rcap(vec2 p, float r, float h)\n{\n    return max(max(length(p) - r, abs(p.y) - h), -p.y);\n}\n\n// simple rounded cone distance field\nfloat rcone(vec2 p, float r, float h)\n{\n    return max(max(length(p) - r, abs(p.y) - h), p.y);\n}\n\n// simple rounded cylinder distance field\nfloat", "\n    // The distance to the nearest surface\n    float d = 10000.0;\n\n    // The material number\n    float m = 0.0;\n\n    // The distance to the sphere\n    float dSphere = length(p) - 1.0;\n\n    // If the distance to the sphere is less than the current distance\n    if (dSphere < d)\n    {\n        // Set the distance to the sphere\n        d = dSphere;\n\n        // Set the material number to the sphere\n        m = 1.0;\n    }\n\n    // The distance to the plane\n    float dPlane = p.y + 1.0;\n\n    // If the distance to the plane is less than the current distance\n    if (dPlane < d)\n    {\n        // Set the distance to the plane\n        d = dPlane;\n\n        // Set the material number to the plane\n        m = 2.0;\n    }\n\n    // Return the distance to the nearest surface and the material number\n    return vec2(d, m);\n}\n\n// This is the function that makes the ray.\n// The input is a position in space.\n// The output is the ray direction and the ray origin\nvec3 Ray(vec2 uv)\n{\n    // The ray direction\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n\n    // The ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\n    // Return the ray direction and the ray origin\n    return rayDirection;\n}\n\n// This is the function that makes the color.\n// The input is a position in space.\n// The output is the color\nvec3 Color(vec3 p, vec3 rayDirection)\n{\n    // The color\n    vec3 color = vec3(0.0);\n\n    // The distance to the nearest surface\n    vec2 d = DistanceToObject(p);\n\n    // If the distance to the nearest surface is less than 0.0\n    if (d.x < 0.0)\n    {\n        // Set the color to white\n        color = vec3(1.0", "\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r5 = pow(r, 5.0);\n    float theta5 = 5.0 * theta;\n    return vec2(r5 * cos(theta5), r5 * sin(theta5));\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r6 = pow(r, 6.0);\n    float theta6 = 6.0 * theta;\n    return vec2(r6 * cos(theta6), r6 * sin(theta6));\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r7 = pow(r, 7.0);\n    float theta7 = 7.0 * theta;\n    return vec2(r7 * cos(theta7), r7 * sin(theta7));\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r8 = pow(r, 8.0);\n    float theta8 = 8.0 * theta;\n    return vec2(r8 * cos(theta8), r8 * sin(theta8));\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float r9 = pow(r, 9.0);\n    float theta9 = 9.0 * theta;\n    return vec2(r9 * cos(theta9), r9 * sin(theta9));\n", "\n    vec2 morphCoord = coord;\n    vec2 morphCoord2 = coord;\n    vec2 morphCoord3 = coord;\n    vec2 morphCoord4 = coord;\n    vec2 morphCoord5 = coord;\n    vec2 morphCoord6 = coord;\n    vec2 morphCoord7 = coord;\n    vec2 morphCoord8 = coord;\n    vec2 morphCoord9 = coord;\n    vec2 morphCoord10 = coord;\n    vec2 morphCoord11 = coord;\n    vec2 morphCoord12 = coord;\n    vec2 morphCoord13 = coord;\n    vec2 morphCoord14 = coord;\n    vec2 morphCoord15 = coord;\n    vec2 morphCoord16 = coord;\n    vec2 morphCoord17 = coord;\n    vec2 morphCoord18 = coord;\n    vec2 morphCoord19 = coord;\n    vec2 morphCoord20 = coord;\n    vec2 morphCoord21 = coord;\n    vec2 morphCoord22 = coord;\n    vec2 morphCoord23 = coord;\n    vec2 morphCoord24 = coord;\n    vec2 morphCoord25 = coord;\n    vec2 morphCoord26 = coord;\n    vec2 morphCoord27 = coord;\n    vec2 morphCoord28 = coord;\n    vec2 morphCoord29 = coord;\n    vec2 morphCoord30 = coord;\n    vec2 morphCoord31 = coord;\n    vec2 morphCoord32 = coord;\n    vec2 morphCoord33 = coord;\n    vec2 morphCoord34 = coord;\n    vec2 morphCoord35 = coord;\n    vec2 morphCoord36 = coord;\n    vec2 morphCoord37 = coord;\n    vec2 morphCoord38 = coord;\n    vec2 morphCoord39 = coord;\n    vec2 morphCoord40 = coord;\n    vec2 morphCoord41 = coord;\n    vec2 morphCoord42 = coord;\n    vec2 morphCoord43 = coord;\n    vec2 morphCoord44 = coord;\n    vec2 morphCoord45 = coord;\n    vec2 morphCoord46 = coord;\n    vec2 morphCoord47 = coord;\n    vec2 morph", "\n    vec4 color = vec4(0.0);\n    for (float x = 0.0; x < 2.0; x++)\n    {\n        for (float y = 0.0; y < 2.0; y++)\n        {\n            vec2 offset = vec2(x, y) / 2.0;\n            color += biomorph(uv + offset, constant);\n        }\n    }\n    return color / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 constant = vec2(0.0, 0.0);\n    vec4 color = antiAliasedBiomorph(uv, constant);\n    gl_FragColor = color;\n}\n`;\n\nexport default biomorphShader;", "\n    return abs(fract(x) - 0.5);\n}\n\nfloat triangle(float x) {\n    return 1.0 - 2.0 * abs(fract(x) - 0.5);\n}\n\nfloat triangle(float x, float y) {\n    return 1.0 - 2.0 * abs(fract(x + y) - 0.5);\n}\n\nfloat triangle(float x, float y, float z) {\n    return 1.0 - 2.0 * abs(fract(x + y + z) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w, float v) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w + v) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w, float v, float u) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w + v + u) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w, float v, float u, float t) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w + v + u + t) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w, float v, float u, float t, float s) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w + v + u + t + s) - 0.5);\n}\n\nfloat triangle(float x, float y, float z, float w, float v, float u, float t, float s, float r) {\n    return 1.0 - 2.0 * abs(fract(x + y + z + w", "\n  vec2 p = uv - pA;\n  vec2 d = pB - pA;\n  vec2 n = vec2(-d.y, d.x);\n  float l = length(d);\n  float t = dot(p, d) / l;\n  float d1 = dot(p, n) / l;\n  float d2 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d3 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d4 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d5 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d6 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d7 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d8 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d9 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d10 = (t < 0.0)? dot(p, d) : (t > 1.0)? dot(p - d, d) : d1;\n  float d11 = (t < 0.0)? dot(p, d) : (t >", "\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - pA;\n    float d1 = dot(p, d);\n    float d2 = dot(p, n);\n    float d3 = dot(pB - pA, n);\n    float d4 = dot(pB - pA, d);\n    float d5 = dot(pA - pB, d);\n    float d6 = dot(pA - pB, n);\n    float d7 = dot(pB - pA, pB - pA);\n    float d8 = dot(pA - pB, pA - pB);\n    float d9 = dot(p, p);\n    float d10 = dot(pA - pB, pA - pB);\n    float d11 = dot(pB - pA, pB - pA);\n    float d12 = dot(pA - pB, pA - pB);\n    float d13 = dot(pB - pA, pB - pA);\n    float d14 = dot(pA - pB, pA - pB);\n    float d15 = dot(pB - pA, pB - pA);\n    float d16 = dot(pA - pB, pA - pB);\n    float d17 = dot(pB - pA, pB - pA);\n    float d18 = dot(pA - pB, pA - pB);\n    float d19 = dot(pB - pA, pB - pA);\n    float d20 = dot(pA - pB, pA - pB);\n    float d21 = dot(pB - pA, pB - pA);\n    float d22 = dot(pA - pB, pA - pB);\n    float d23 = dot(pB - pA, pB - pA);\n    float d24 = dot(pA - pB, pA - pB);\n    float d25 = dot(pB - pA", "\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n    vec2 w = abs(p - thick * n);\n    float d1 = max(dot(p, n), 0.0);\n    float d2 = max(dot(p, -n), 0.0);\n    float d3 = max(w.x, w.y);\n    float d4 = max(d1, d2);\n    float d5 = max(d3, outlineThick);\n    return d5;\n}\n\n// This makes a rounded line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawRoundedLinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n    vec2 w = abs(p - thick * n);\n    float d1 = max(dot(p, n), 0.0);\n    float d2 = max(dot(p, -n), 0.0);\n    float d3 = max(w.x, w.y);\n    float d4 = max(d1, d2);\n    float d5 = max(d3, outlineThick);\n    float d6 = min(d5, rounded);\n    return d6;\n}\n\n// This makes a rounded line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawRoundedLinePix2(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n", "\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    float t = dot(p, n);\n    float l = dot(p, d);\n    float w = dot(thick, d);\n    float r = rounded * w;\n    float s = smoothstep(0.0, r, abs(t)) * smoothstep(0.0, r, abs(l - w));\n    return s;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    return FillLine(uv, pA, pB, vec2(thick), rounded);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return FillLine(uv, pA, pB, vec2(thick), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB) {\n    return FillLine(uv, pA, pB, vec2(1.0), 0.0);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float alpha) {\n    return FillLine(uv, pA, pB, thick, rounded) * alpha;\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0.0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick,", "\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    float l = length(d);\n    d /= l;\n    float t = dot(d, p);\n    float tt = t / l;\n    float tt2 = tt * l;\n    float tt3 = tt2 - floor(tt2);\n    float tt4 = tt3 * l;\n    float tt5 = tt4 - floor(tt4);\n    float tt6 = tt5 / l;\n    float tt7 = tt6 * l;\n    float tt8 = tt7 - floor(tt7);\n    float tt9 = tt8 / l;\n    float tt10 = tt9 * l;\n    float tt11 = tt10 - floor(tt10);\n    float tt12 = tt11 / l;\n    float tt13 = tt12 * l;\n    float tt14 = tt13 - floor(tt13);\n    float tt15 = tt14 / l;\n    float tt16 = tt15 * l;\n    float tt17 = tt16 - floor(tt16);\n    float tt18 = tt17 / l;\n    float tt19 = tt18 * l;\n    float tt20 = tt19 - floor(tt19);\n    float tt21 = tt20 / l;\n    float tt22 = tt21 * l;\n    float tt23 = tt22 - floor(tt22);\n    float tt24 = tt23 / l;\n    float tt25 = tt24 * l;\n    float tt26 = tt25 - floor(tt25);\n    float tt27 = tt26 / l;\n    float tt28 = tt27 * l;\n    float tt29 = tt28 - floor(tt28);\n    float tt30 = tt29", "\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n    vec2 w = abs(p - p.x * n * thick.x - p.y * n * thick.y);\n    float d1 = max(dot(w, n), dot(w, vec2(n.y, -n.x)));\n    float d2 = length(max(w - thick, 0.0));\n    float d3 = max(d1, d2);\n    float d4 = max(d3, outlineThick);\n    return d4;\n}\n\n// Draw a rounded rectangle.\n//\n// pA and pB are the opposite corners of the rectangle.\n//\n// thick is the thickness of the line in UV units. A 1.0 thick line will span 0..1 in UV space.\n//\n// rounded is the radius of the rounded corners in UV units. A 1.0 rounded radius will span 0..1 in UV space.\n//\n// outlineThick is the thickness of the outline in UV units. A 1.0 outline thick will span 0..1 in UV space.\nfloat DrawRoundedRectangle(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    vec2 d = pB - pA;\n    vec2 n = normalize(vec2(-d.y, d.x));\n    vec2 p = uv - (pA + pB) / 2.0;\n    vec2 w = abs(p - p.x * n * thick.x - p.y * n * thick.y);\n    float d1 = max(dot(w, n), dot(w, vec2(n.y, -n.x)));\n    float d2 = length(max(w - thick, 0.0));\n    float d3 = max(d1, d2);\n    float d4 = max(d3, outlineThick);\n    float d5 = max(d4, rounded);\n    ", "\n    vec2 p2 = uv - p;\n    float d = length(p2);\n    if (d < 0.001) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n}\n\n// This is the main function that draws the fractal.\nvec3 DrawFractal(vec2 uv) {\n    // This is the color of the fractal.\n    vec3 col = vec3(0.0);\n\n    // This is the point that we are drawing.\n    vec2 p = vec2(0.0);\n\n    // This is the number of iterations that we have done.\n    int iter = 0;\n\n    // This is the number of iterations that we have done.\n    int maxIter = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter2 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter3 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter4 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter5 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter6 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter7 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter8 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter9 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter10 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter11 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter12 = 100;\n\n    // This is the number of iterations that we have done.\n    int maxIter13 = ", "\n    float t = -dot(nor,ro-cen)/dot(nor,rd);\n    vec3  x = ro + rd*t;\n    return (length(x-cen)-rad)/dot(rd,nor);\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 pos, float rad )\n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - m*pos;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\n// ray-triangle intersection\nfloat iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1-v0;\n    vec3  e2 = v2-v0;\n    vec3  h  = cross(rd,e2);\n    float a  = dot(e1,h);\n    if( a<0.001 ) return -1.0;\n    vec3  s  = ro-v0;\n    float f  = 1.0/a;\n    float u  = f * dot(", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ", "\n    vec3 ba = pb-pa;\n    vec3 oa = vec3(0.0);\n    vec3 oc = vec3(0.0);\n    vec3 e = vec3(1.0,0.0,0.0);\n    vec3 f = vec3(0.0,1.0,0.0);\n    vec3 g = vec3(0.0,0.0,1.0);\n    vec3 h = vec3(0.0,0.0,0.0);\n    vec3 i = vec3(0.0,0.0,0.0);\n    vec3 j = vec3(0.0,0.0,0.0);\n    vec3 k = vec3(0.0,0.0,0.0);\n    vec3 l = vec3(0.0,0.0,0.0);\n    vec3 m = vec3(0.0,0.0,0.0);\n    vec3 n = vec3(0.0,0.0,0.0);\n    vec3 o = vec3(0.0,0.0,0.0);\n    vec3 p = vec3(0.0,0.0,0.0);\n    vec3 q = vec3(0.0,0.0,0.0);\n    vec3 r = vec3(0.0,0.0,0.0);\n    vec3 s = vec3(0.0,0.0,0.0);\n    vec3 t = vec3(0.0,0.0,0.0);\n    vec3 u = vec3(0.0,0.0,0.0);\n    vec3 v = vec3(0.0,0.0,0.0);\n    vec3 w = vec3(0.0,0.0,0.0);\n    vec3 x = vec3(0.0,0.0,0.0);\n    vec3 y = vec3(0.0,0.0,0.0);\n    vec3 z = vec3(0.0,0.0,0.0);\n    vec3 aa = vec3(0", "\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float bardoc = dot(ba,rd*oc);\n    float ococ = dot(oc,oc);\n    float rarara = ra*ra;\n    float h = max( -bardoc, 0.0 );\n    float f = baba*rarara - bardoc*bardoc;\n    float t = -baba*rarara + baba*h*h;\n    if( t<0.0 ) return vec4(0.0);\n    t = sqrt( t );\n    float t0 = h/bard + t/baba;\n    float t1 = h/bard - t/baba;\n    if( t0>t1 ) swap(t0,t1);\n    if( t0>0.0 )\n    {\n        vec3 n = (oc+ba*t0/baba)/ra;\n        return vec4( t0, n );\n    }\n    if( t1>0.0 )\n    {\n        vec3 n = (oc+ba*t1/baba)/ra;\n        return vec4( t1, n );\n    }\n    return vec4(0.0);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 pos, in float rad )\n{\n    vec3 oc = ro-pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(0.0);\n    h = sqrt( h );\n    return vec4( -b-h, -b+h );\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor )\n{\n    float h = dot( nor, (pos-ro", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - cen*m;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 pos, in float rad )\n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor )\n{\n    return dot( pos-ro, nor ) / dot( rd, nor );\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1-v0;\n    vec3 e2 = v2-v0;\n    vec3 tN = cross( rd, e2 );\n    float d = dot( e1, tN );\n    if( d<0.001 ) return -1.0;\n    vec3 t0 = ro - v0;\n    float s = dot( t0, tN );\n    if( s<0.0 || s>d ) return -1.0;\n    vec3 q = t0 - e1*s/d;\n    float v = dot( rd, cross(e1,q) );\n    if( v<0.0", "\n    vec3  ba = pb-pa, oa = ro-pa;\n    float baba = dot(ba,ba), oaba = dot(oa,ba), oaoa = dot(oa,oa);\n    float f = clamp( (oaba/baba)-((r*r)/baba), 0.0, 1.0 );\n    float d = sqrt(max(0.0,r*r - oaoa + 2.0*f*oaba + f*f*baba));\n    return (oaba-f*baba-d > 0.0)? (oaba-f*baba+d) : (oaba-f*baba-d);\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 pos, in float rad )\n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b + h;\n}\n\n// intersect plane : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec3 nor, in float h )\n{\n    return (h - dot(ro,nor)) / dot(rd,nor);\n}\n\n// intersect box : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro - m*pos;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 =", "\n    vec3 ba = b-a;\n    vec3 pa = pos-a;\n    vec3 pb = pos-b;\n    vec3 n = normalize( cross( ba, pa ) );\n    vec3 n2 = normalize( cross( ba, pb ) );\n    return mix( n, n2, step( dot(pb,ba), 0.0 ) );\n}\n\n// compute intersection\nvec3 intersect( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a;\n    vec3 pa = ro-a;\n    vec3 pb = ro-b;\n    vec3 n = normalize( cross( ba, pa ) );\n    vec3 n2 = normalize( cross( ba, pb ) );\n    float h = dot( pa, n );\n    float h2 = dot( pb, n2 );\n    float t = -h/dot( rd, n );\n    float t2 = -h2/dot( rd, n2 );\n    vec3 pos = ro + rd*t;\n    vec3 pos2 = ro + rd*t2;\n    return mix( pos, pos2, step( h2, 0.0 ) );\n}\n\n// compute intersection\nvec3 intersect2( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a;\n    vec3 pa = ro-a;\n    vec3 pb = ro-b;\n    vec3 n = normalize( cross( ba, pa ) );\n    vec3 n2 = normalize( cross( ba, pb ) );\n    float h = dot( pa, n );\n    float h2 = dot( pb, n2 );\n    float t = -h/dot( rd, n );\n    float t2 = -h2/dot( rd, n2 );\n    vec3 pos = ro + rd*t;\n    vec3 pos2 = ro + rd*t2;\n    return mix( pos, pos2, step( h2, 0.0 ) );\n}\n\n//", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 off ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-off);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 off, in vec3 scl ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-off);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 off, in vec3 scl, in vec3 rot", "\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( abs(h)<0.001 ) break;\n        t += h;\n    }\n    res.x = t;\n    res.y = map( ro + rd*t );\n    res.z = 1.0;\n    return res;\n}\n\n//-----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\n    // camera\n    vec3 ro = vec3(0.0,0.0,-3.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    vec4 res = interesect( ro, rd );\n\n    // lighting\n    vec3 pos = ro + rd*res.x;\n    vec3 nor = normal( pos );\n    vec3 lig = normalize( vec3(0.5,0.7,0.5) );\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n    vec3 lin = vec3(0.0);\n    lin += 0.5000*vec3(1.", "\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nvec3 forwardSF( float i, float n, float offset) \n{\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n + offset;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nvec3 forwardSF( float i, float n, float offset, float offset2) \n{\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n + offset + offset2;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nvec3 forwardSF( float i, float n, float offset, float offset2, float offset3) \n{\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n + offset + offset2 + offset3;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nvec3 forwardSF( float i, float n, float offset, float offset2, float offset3, float offset4) \n{\n    float phi = acos(1.0 - 2.0 * i / n);\n    float theta = 2.0 * PI * i / n + offset + offset2 + offset3 + offset4;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\nvec3 forwardSF( float i, float n, float offset, float offset2, float offset3, float offset4, float offset5", "\n    vec4 res = vec4(0.0);\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tdelta = 0.0;\n    float tstep = 0.0;\n    float tstep2 = 0.0;\n    float tstep3 = 0.0;\n    float tstep4 = 0.0;\n    float tstep5 = 0.0;\n    float tstep6 = 0.0;\n    float tstep7 = 0.0;\n    float tstep8 = 0.0;\n    float tstep9 = 0.0;\n    float tstep10 = 0.0;\n    float tstep11 = 0.0;\n    float tstep12 = 0.0;\n    float tstep13 = 0.0;\n    float tstep14 = 0.0;\n    float tstep15 = 0.0;\n    float tstep16 = 0.0;\n    float tstep17 = 0.0;\n    float tstep18 = 0.0;\n    float tstep19 = 0.0;\n    float tstep20 = 0.0;\n    float tstep21 = 0.0;\n    float tstep22 = 0.0;\n    float tstep23 = 0.0;\n    float tstep24 = 0.0;\n    float tstep25 = 0.0;\n    float tstep26 = 0.0;\n    float tstep27 = 0.0;\n    float tstep28 = 0.0;\n    float tstep29 = 0.0;\n    float tstep30 = 0.0;\n    float tstep31 = 0.0;\n    float tstep32 = 0.0;\n    float tstep33 = 0.0;\n    float tstep34 = 0.0;\n    float tstep35 = 0.0;\n    float tstep36 =", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return vec3(mix(a, b, u.x), mix(c, d, u.x), mix(mix(a, b, u.x), mix(c, d, u.x), u.y));\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Get the gradient for each corner\n    vec3 g000 = grad(i);\n    vec3 g100 = grad(i + vec3(1.0, 0.0, 0.0));\n    vec3 g010 = grad(i + vec3(0.0, 1.0, 0.0));\n    vec3 g110 = grad(i + vec3(1.0, 1.0, 0.0));\n    vec3 g001 = grad(i + vec3(0.0, 0.0, 1.0));\n    vec3 g101 = grad(i + vec3(1.0, 0.0, 1.0));\n    vec3 g011 = grad(i + vec3(0.0, 1.0, 1.0));\n    vec3 g111 = grad(i + vec3(1.0, 1.", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat smoothMerge(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphereDist(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sphereDist(vec3 p, float radius, float k)\n{\n    return smoothMerge(sphereDist(p, radius), sphereDist(p, radius + k), k);\n}\n\nfloat sphereDist(vec3 p, float radius, float k, float k2)\n{\n    return smoothMerge(smoothMerge(sphereDist(p, radius), sphereDist(p, radius + k), k), sphereDist(p, radius + k + k2), k2);\n}\n\nfloat sphereDist(vec3 p, float radius, float k, float k2, float k3)\n{\n    return smoothMerge(smoothMerge(smoothMerge(sphereDist(p, radius), sphereDist(p, radius + k), k), sphereDist(p, radius + k + k2), k2), sphereDist(p, radius + k + k2 + k3), k3);\n}\n\nfloat sphereDist(vec3 p, float radius, float k, float k2, float k3, float k4)\n{\n    return smoothMerge(smoothMerge(smoothMerge(smoothMerge(sphereDist(p, radius), sphereDist(p, radius + k), k), sphereDist(p, radius + k + k2), k2), sphereDist(p, radius + k + k2 + k3), k3), sphereDist(p, radius + k + k2 + k3 + k4), k4);\n}\n\nfloat sphereDist(vec3 p, float radius, float k, float k", "\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x);\n    uv2.y = abs(uv2.y);\n    uv2.x = abs(uv2.x - orient.x);\n    uv2.y = abs(uv2.y - orient.y);\n    return vec3(uv2.x, uv2.y, 0.0);\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x);\n    uv2.y = abs(uv2.y);\n    uv2.x = abs(uv2.x - orient.x);\n    uv2.y = abs(uv2.y - orient.y);\n    return vec3(uv2.x, uv2.y, 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x);\n    uv2.y = abs(uv2.y);\n    uv2.x = abs(uv2.x - orient.x);\n    uv2.y = abs(uv2.y - orient.y);\n    return vec3(uv2.x, uv2.y, 0.0);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x);\n    uv2.y = abs(uv2.y);\n    uv2.x = abs(uv2.x - orient.x);\n    uv2.y = abs(uv2.y - orient.y);\n    return vec3(uv2.x, uv2.y, 0.0);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x", "\n    vec2 uv2 = uv;\n    uv2.x = abs(uv2.x);\n    uv2.y = abs(uv2.y);\n    vec2 uv3 = uv;\n    uv3.x = abs(uv3.x);\n    uv3.y = abs(uv3.y);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0.5);\n    uv3.y = abs(uv3.y - 0.5);\n    uv3.x = abs(uv3.x - 0", "\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    vec2 h = step(f,vec2(0.5));\n    vec2 k = vec2(1.0)-h;\n    vec2 l = f-h;\n    vec2 m = f+k-1.0;\n    vec2 n = dFdx(g);\n    vec2 o = dFdy(g);\n    vec2 a = dFdx(l);\n    vec2 b = dFdy(l);\n    vec2 c = dFdx(m);\n    vec2 d = dFdy(m);\n    vec2 e = dFdx(f);\n    vec2 f0 = dFdy(f);\n    vec2 g0 = dFdx(h);\n    vec2 h0 = dFdy(h);\n    vec2 i0 = dFdx(k);\n    vec2 j0 = dFdy(k);\n    vec2 k0 = dFdx(vec2(0.0));\n    vec2 l0 = dFdy(vec2(0.0));\n    vec2 m0 = dFdx(vec2(1.0));\n    vec2 n0 = dFdy(vec2(1.0));\n    vec2 o0 = dFdx(vec2(0.5));\n    vec2 p0 = dFdy(vec2(0.5));\n    vec2 q = vec2(0.5)-f;\n    vec2 r = vec2(1.0)-f;\n    vec2 s = vec2(1.0)-q;\n    vec2 t = vec2(0.5)-f;\n    vec2 u = vec2(0.5)-q;\n    vec2 v = vec2(0.5)-r;\n    vec2 w = vec2(0.5)-s;\n    vec2 x = vec2(0.5)-t;\n    vec2 y = vec2(0.5)-u;\n    vec2 z = vec2(0.5)-v;\n    vec2 a0 = vec2(0.5)-w;\n    vec2 b0 = vec2(0.5", "\n    vec3 n = vec3(0.0);\n    float d = map(p);\n    float e = 0.001;\n    n.x = map(p+vec3(e,0.0,0.0))-d;\n    n.y = map(p+vec3(0.0,e,0.0))-d;\n    n.z = map(p+vec3(0.0,0.0,e))-d;\n    return normalize(n);\n}\n\n// raymarching\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.001 ) break;\n        t += h*0.5;\n    }\n    return vec3(t,t*rd);\n}\n\n// lighting\nvec3 lighting( in vec3 pos, in vec3 rd, in vec3 n, in vec3 col )\n{\n    vec3 lig = normalize(vec3(0.5,0.5,0.5));\n    float dif = clamp( dot(n,lig), 0.0, 1.0 );\n    vec3 lin = vec3(0.0);\n    lin += 0.500*vec3(1.0)*dif;\n    return col*lin;\n}\n\n// main image processing function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0.0,0.0,-2.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n    float cr = cos(iTime*0.25);\n    float sr = sin", "\n\tv33 c=a;\n\ta=b;\n\tb=c;\n}\n\n//this is a function that takes a ray and a plane and returns the intersection point\n//if the ray doesn't intersect the plane, it returns a point at infinity\nv3 rayPlaneIntersection(v3 rayOrigin,v3 rayDirection,v3 planeNormal,v3 planePoint){\n\t//first, we need to find the distance from the ray origin to the plane\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray origin to the plane along the plane normal\n\t//this is the distance from the ray", "\n\treturn v33(a.a-b,a.b-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n\treturn v33(a.a-b.a,a.b-b.b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,vec3 c){\n\treturn v33(a.a-b.a,a.b-b.b,c);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c){\n\treturn v33(a.a-b.a,a.b-b.b,c.a-c.b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,vec3 d){\n\treturn v33(a.a-b.a,a.b-b.b,c.a-c.b,d);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,v33 d){\n\treturn v33(a.a-b.a,a.b-b.b,c.a-c.b,d.a-d.b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,v33 d,vec3 e){\n\treturn v33(a.a-b.a,a.b-b.b,c.a-c.b,d.a-d.b,e);\n}\n\n//swap direction(.b)of [", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//component wise ray addition\nv33 addc(v33  a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n//component wise ray multiplication\nv33 mulc(v33  a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n//component wise ray division\nv33 divc(v33  a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n//component wise ray division\nv33 divc(v33  a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\n//component wise ray division\nv33 divc(float a,v33 b){\n\treturn v33(a/b.x,a/b.y,a/b.z);\n}\n//component wise ray division\nv33 divc(v33  a,int b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\n//component wise ray division\nv33 divc(int a,v33 b){\n\treturn v33(a/b.x,a/b.y,a/b.z);\n}\n//component wise ray division\nv33 divc(v33  a,double b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\n//component wise ray division\nv33 divc(double a,v33 b){\n\treturn v33(a/b.x,a/b.y,a/b.z);\n}\n//component wise ray division\nv33 divc(v33  ", "\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v3", "\n  return vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n  return vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n  return vec2(dot(a.x,b.x,c.x),dot(a.y,b.y,c.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n  return vec2(dot(a.x,b.x,c.x,d.x),dot(a.y,b.y,c.y,d.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n  return vec2(dot(a.x,b.x,c.x,d.x,e.x),dot(a.y,b.y,c.y,d.y,e.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n  return vec2(dot(a.x,b.x,c.x,d.x,e.x,f.x),dot(a.y,b.y,c.y,d.y,e.y,f.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n  return vec2(dot(a.x,b.x,c.x", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec4 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v34 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v43 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v44 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v34 a,vec2 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v34 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v34 a,vec4 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);", "\n\tfloat a=dot(p,w);\n\treturn (a>0.5)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,float a){\n\tfloat aa=dot(p,w);\n\treturn (aa>a)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 a){\n\tfloat aa=dot(p,w);\n\treturn (aa>a.x)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 a,vec3 b){\n\tfloat aa=dot(p,w);\n\treturn (aa>a.x)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 a,vec3 b,vec3 c){\n\tfloat aa=dot(p,w);\n\treturn (aa>a.x)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 a,vec3 b,vec3 c,vec3 d){\n\tfloat aa=dot(p,w);\n\treturn (aa>a.x)?1.:0.;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 a,vec3 b,vec3 c,vec3 d,vec3 e){\n\tfloat aa=dot(p,w);\n\treturn (aa>a.x)?1.:0.;\n}\n", "\n\tvec3 q=abs(p);\n\tfloat a=dot(q,w);\n\tfloat b=dot(q,w*2.);\n\tfloat c=dot(q,w*3.);\n\treturn tri(a,b,c);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat a=dot(q,w);\n\tfloat b=dot(q,w*2.);\n\tfloat c=dot(q,w*3.);\n\tfloat d=dot(q,w*4.);\n\treturn tri(a,b,c,d);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat a=dot(q,w);\n\tfloat b=dot(q,w*2.);\n\tfloat c=dot(q,w*3.);\n\tfloat d=dot(q,w*4.);\n\tfloat e=dot(q,w*5.);\n\treturn tri(a,b,c,d,e);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat a=dot(q,w);\n\tfloat b=dot(q,w*2.);\n\tfloat c=dot(q,w*3.);\n\tfloat d=dot(q,w*4.);\n\tfloat e=dot(q,w*5.);\n\tfloat f=dot(q,w*6.);\n\treturn tri(a,b,c,d,e,f", "\n  v33 d=r.xyz-s.xyz;\n  float l=length(d);\n  float rr=s.w;\n  float rl=rr-0.001;\n  float rl2=rl*rl;\n  float rr2=rr*rr;\n  float l2=l*l;\n  float l2m=l2-rl2;\n  float l2p=l2-rr2;\n  float l2m2=l2m*l2m;\n  float l2p2=l2p*l2p;\n  float l2m3=l2m2*l2m;\n  float l2p3=l2p2*l2p;\n  float l2m4=l2m2*l2m2;\n  float l2p4=l2p2*l2p2;\n  float l2m5=l2m4*l2m;\n  float l2p5=l2p4*l2p;\n  float l2m6=l2m4*l2m2;\n  float l2p6=l2p4*l2p2;\n  float l2m7=l2m6*l2m;\n  float l2p7=l2p6*l2p;\n  float l2m8=l2m6*l2m2;\n  float l2p8=l2p6*l2p2;\n  float l2m9=l2m8*l2m;\n  float l2p9=l2p8*l2p;\n  float l2m10=l2m8*l2m2;\n  float l2p10=l2p8*l2p2;\n  float l2m11=l2m10*l2m;\n  float l2p11=l2p10*l2p;\n  float l2m12=l2m10*l2m2;\n  float l2p12=l2p10*l2p2;\n  float l2m13=l2m12", "\n\tvec3 d=s.xyz-u;\n\tfloat l=length(d);\n\treturn 1.-smoothstep(s.w-.01,s.w+.01,l);\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 b){\n\tvec3 d=abs(u-b.xyz)-b.w;\n\treturn 1.-smoothstep(0.,.01,max(max(d.x,d.y),d.z));\n}\n\n//occlusion\nfloat occ(vec3 u,vec3 n){\n\tfloat o=1.;\n\to*=occSphere(u,n,vec4(vec3(0.),.5));\n\to*=occBox(u,n,vec4(vec3(0.,-.5,0.),.5));\n\to*=occBox(u,n,vec4(vec3(0.,.5,0.),.5));\n\treturn o;\n}\n\n//lighting\nvec3 light(vec3 u,vec3 n,vec3 l,vec3 c){\n\tvec3 r=reflect(normalize(l-u),n);\n\tfloat d=max(dot(n,l-u),0.);\n\tfloat s=max(dot(r,-l),0.);\n\treturn c*vec3(d,d,d)*occ(u,n)+c*vec3(s,s,s)*occ(u,r)*pow(s,10.);\n}\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p=fragCoord.xy/iResolution.xy;\n\tvec2 uv=(p*2.-1.)*vec2(iResolution.x/iResolution.y,1.);\n\tvec3 u=vec3(uv,0.);\n\tvec3 n=vec3(0.,0.,1.);\n\tvec3 l=vec3(0.,0.,1.);\n\tvec3 c=vec3(1.,", "\n    vec2 c = p1 - p0;\n    vec2 d = p2 - p1;\n    vec2 e = p0 - p2;\n    vec2 f = c + d + e;\n    vec2 g = 2.0 * (c + d);\n    vec2 h = d + e;\n    vec2 i = 2.0 * (c + d);\n    vec2 j = 2.0 * (c + d);\n    vec2 k = 2.0 * (c + d);\n    vec2 l = 2.0 * (c + d);\n    vec2 m = 2.0 * (c + d);\n    vec2 n = 2.0 * (c + d);\n    vec2 o = 2.0 * (c + d);\n    vec2 p = 2.0 * (c + d);\n    vec2 q = 2.0 * (c + d);\n    vec2 r = 2.0 * (c + d);\n    vec2 s = 2.0 * (c + d);\n    vec2 t = 2.0 * (c + d);\n    vec2 u = 2.0 * (c + d);\n    vec2 v = 2.0 * (c + d);\n    vec2 w = 2.0 * (c + d);\n    vec2 x = 2.0 * (c + d);\n    vec2 y = 2.0 * (c + d);\n    vec2 z = 2.0 * (c + d);\n    vec2 aa = 2.0 * (c + d);\n    vec2 ab = 2.0 * (c + d);\n    vec2 ac = 2.0 * (c + d);\n    vec2 ad = 2.0 * (c + d);\n    vec2 ae = 2.0 * (c + d);\n    vec2 af = 2.0 * (c + d);\n    vec2 ag = 2.0 * (c + d);\n    vec2 ah = 2.0 * (c + d);\n    vec2 ai = 2.0 * (c + d);\n    vec", "\n    vec2 c = p1 - p0;\n    vec2 d = p2 - p1;\n    vec2 e = c + d;\n    vec2 f = e * 0.5;\n    vec2 g = p0 + f;\n    vec2 h = p0 + c;\n    vec2 i = p2 - d;\n    vec2 j = p0 + p2;\n    vec2 k = j * 0.5;\n    vec2 l = p1 - k;\n    vec2 m = p1 + l;\n    vec2 n = p1 + p2;\n    vec2 o = n * 0.5;\n    vec2 p = p1 + o;\n    vec2 q = p1 + p;\n    vec2 r = p1 + q;\n    vec2 s = p1 + r;\n    vec2 t = p1 + s;\n    vec2 u = p1 + t;\n    vec2 v = p1 + u;\n    vec2 w = p1 + v;\n    vec2 x = p1 + w;\n    vec2 y = p1 + x;\n    vec2 z = p1 + y;\n    vec2 aa = p1 + z;\n    vec2 ab = p1 + aa;\n    vec2 ac = p1 + ab;\n    vec2 ad = p1 + ac;\n    vec2 ae = p1 + ad;\n    vec2 af = p1 + ae;\n    vec2 ag = p1 + af;\n    vec2 ah = p1 + ag;\n    vec2 ai = p1 + ah;\n    vec2 aj = p1 + ai;\n    vec2 ak = p1 + aj;\n    vec2 al = p1 + ak;\n    vec2 am = p1 + al;\n    vec2 an = p1 + am;\n    vec2 ao = p1 + an;\n    vec2 ap = p1 + ao;\n    vec2 aq = p1 + ap;\n    vec2 ar = p1 + aq;\n    vec2 as = p1 + ar;\n    vec2 at = p1 + as;\n    vec2 au", "\n    vec3 b = p0 + (p1 - p0)*3.0;\n    vec3 c = p3 + (p2 - p3)*3.0;\n    vec3 q0 = 2.0*p1 - b;\n    vec3 q1 = 2.0*p2 - c;\n    vec3 a = c - p3 + q0;\n    vec3 b = b - p0 - q0;\n    vec3 c = p0;\n\n    vec3 m = max(a,0.0);\n    vec3 M = min(a,0.0);\n    vec3 t0 = -(2.0*b)/a;\n    vec3 t1 = -b/(2.0*a);\n    vec3 t2 = sqrt(t1*t1 - t1*m*m/a);\n    vec3 t3 = sqrt(t1*t1 - t1*M*M/a);\n    vec3 t4 = sqrt(t0*t0 - t0*m*m/a);\n    vec3 t5 = sqrt(t0*t0 - t0*M*M/a);\n    vec3 t6 = t1 - t2;\n    vec3 t7 = t1 + t2;\n    vec3 t8 = t1 - t3;\n    vec3 t9 = t1 + t3;\n    vec3 t10 = t0 - t4;\n    vec3 t11 = t0 + t4;\n    vec3 t12 = t0 - t5;\n    vec3 t13 = t0 + t5;\n\n    vec3 p = a*t13*t13 + b*t13 + c;\n    vec3 q = a*t12*t12 + b*t12 + c;\n    vec3 r = a*t11*t11 + b*t11 + c;\n    vec3 s = a*t10*t10 + b*t10 + c;\n    vec3 u = a*t9*t9 + b*t9 + c;\n    vec3 v = a*t8*t8 + b*t", "\n    vec2 min = min(min(min(p0, p1), p2), p3);\n    vec2 max = max(max(max(p0, p1), p2), p3);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a quadratic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 min = min(min(p0, p1), p2);\n    vec2 max = max(max(p0, p1), p2);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a line\nvec4 bboxLineSimple(in vec2 p0, in vec2 p1 )\n{\n    vec2 min = min(p0, p1);\n    vec2 max = max(p0, p1);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a circle\nvec4 bboxCircleSimple(in vec2 p0, in float r )\n{\n    vec2 min = p0 - vec2(r);\n    vec2 max = p0 + vec2(r);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a rectangle\nvec4 bboxRectangleSimple(in vec2 p0, in vec2 p1 )\n{\n    vec2 min = min(p0, p1);\n    vec2 max = max(p0, p1);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a triangle\nvec4 bboxTriangleSimple(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 min = min(min(p0, p1), p2);\n    vec2 max = max(max(p0, p1), p2);\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a quad\nvec4 bboxQuadSimple(in vec2 p0, in vec2 p1, in vec2 p2,", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return udBezier(p0123, p123, p23, p3, pos);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return udBezier(p0123, p123, p23, p3, pos);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23,", "\n    vec3 e1 = v1-v0;\n    vec3 e2 = v2-v0;\n    vec3 p = cross(rd,e2);\n    float det = dot(e1,p);\n    if( abs(det) < 0.0001 ) return vec3(1.0,0.0,0.0);\n    float invdet = 1.0/det;\n    vec3 t = ro - v0;\n    float u = dot(t,p)*invdet;\n    if( u<0.0 || u>1.0 ) return vec3(1.0,0.0,0.0);\n    vec3 q = cross(t,e1);\n    float v = dot(rd,q)*invdet;\n    if( v<0.0 || (u+v)>1.0 ) return vec3(1.0,0.0,0.0);\n    float tt = dot(e2,q)*invdet;\n    return vec3(tt,u,v);\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//----------------------------------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//----------------------------------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//----------------------------------------------------------------------------------------------------------------------\n\n//------", "\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 n = normalize( cross(e0,e1) );\n    float d = dot(v0,n);\n    return smoothstep( 0.0, 0.001, -dot(pos,n)+d );\n}\n\n//-----------------------------------------------------\n//  MAIN\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    float cr = cos( time*0.1 );\n    float sr = sin( time*0.1 );\n    ro.xz += vec2( cr, sr )*0.2;\n    ta.xz += vec2( cr, sr )*0.2;\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( ww, vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    vec2 p = ( 2.0 * gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // ray march\n    float t = 0.0;\n    vec3 pos = vec3(0.0);\n    for( int i=0; i<128; i++ )\n    {\n        pos = ro + t*rd;\n        float h = map( pos );\n        if( abs(h)<0.001 || t>10.0 ) break;\n        t += h;\n    }\n\n    // lighting\n    vec3 col = vec3(0.0);\n    if( t<1", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a*2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/(3.0*dot(a,a));\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float q = kz - 3.0*kx*ky + 2.0*kx*kx*kx;\n    float det = q*q + 4.0*p*p*p;\n\n    if( det<0.0 )\n    {\n        float r = sqrt( kx*kx + ky - kz );\n        float t1 = 2.0*r*cos( acos( kz/r )/3.0 ) - kx;\n        res = length( d + c*t1 );\n    }\n    else\n    {\n        float t1 = 2.0*sqrt( p )*cos( acos( q/sqrt(p*p*p) )/3.0 ) - kx;\n        float t2 = 2.0*sqrt( p )*cos( acos( q/sqrt(p*p*p) )/3.0 + 2.0*PI/3.0 ) - kx;\n        float t3 = 2.0*sqrt( p )*cos( acos( q/sqrt(p*p*p) )/3.0 + 4.0*PI/3.0 ) - kx;\n        res = min( length( d + c*t1 ), length( d + c*t2 ) );\n        res = min( res, length( d + c*t3 ) );\n    }\n\n    return res;\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2", "\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    vec2 ca = vec2(max(dot(k1,p),0.0),abs(p.y)-he);\n    vec2 cb = p-k2;\n    float s = (cb.x < 0.0)? -1.0 : 1.0;\n    cb.x = abs(cb.x);\n    return sign(s)*sqrt(min(dot(ca,ca),dot(cb,cb)));\n}\n\n//----------------------------------------------------------------------------------------\n// 2D rotation\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n//----------------------------------------------------------------------------------------\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy+vec2(0.5,1.0).xy;\n\tuv = (uv+vec2(37.0,17.0).xy)*uv;\n\tvec2 r = fract(uv);\n\tr.x += dot(f.xy,vec2(-1.0, 1.0).xy);\n\tr.y += dot(f.xy,vec2( 1.0,-1.0).xy);\n\treturn fract(r.x*r.y*(103.0*r.x+101.0*r.y));\n}\n\n//----------------------------------------------------------------------------------------\n// 2D fBm\nfloat fbm(", "\n    vec2 d = abs(p)-a;\n    vec2 e = vec2( max(d.x,d.y), min(d.x,d.y) );\n    float s = sign(d.y);\n    float h = clamp( 0.5+0.5*(e.x-e.y)/(b.y-a.y), 0.0, 1.0 );\n    float r = mix( ra, rb, h );\n    float sd = sqrt( e.y*e.y + (e.x-0.5*s*(b.x-a.x))*(e.x-0.5*s*(b.x-a.x)) );\n    return s*sd*h + s*e.x*(1.0-h) + r*sqrt(1.0-h);\n}\n\n// capsule\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x;\n}\n\n// rounded box\nfloat sdRoundedBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r.x;\n}\n\n// rounded box\nfloat sdRoundedBox( in vec3 p, in vec3 b, in vec3 r, in vec3 e )\n{\n    vec3 d = abs(p)-b;\n    vec", "\n    vec2 e = vec2(1.0, -1.0)*0.5773;\n    return normalize( e.xyy*f( pos + e.xyy ) +\n                      e.yyx*f( pos + e.yyx ) +\n                      e.yxy*f( pos + e.yxy ) +\n                      e.xxx*f( pos + e.xxx ) );\n}\n\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    // camera movement\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    float cr = cos(iTime*0.25);\n    float sr = sin(iTime*0.25);\n    ro.x += cr*0.5;\n    ro.z += sr*0.5;\n    // camera matrix\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float t = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = f(pos);\n        if( abs(h)<0.0001 || t>8.0 ) break;\n        t += h;\n    }\n\n    // shading/lighting\n    vec3 col = vec3(0.0);\n    if( t<8.0 )\n    {\n        vec3 pos = ro + t*rd;", "\n    float res = 1.0;\n    float ph = 1e10; // precision holder\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*tmin );\n        if( h<0.001 ) return 0.0;\n        float d = h/ph;\n        res = min( res, k*d/ph );\n        ph = h;\n        tmin += h;\n        if( h<0.01 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//-----------------------------------------------------\n//---", "\n    return fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453123);\n}\n\n// 2D simplex noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*512.0;\n\n    float res = mix(mix( hash(ivec2(n  +  0.0)),\n                         hash(ivec2(n  +  1.0)),f.x),\n                    mix( hash(ivec2(n  + 512.0)),\n                         hash(ivec2(n  + 513.0)),f.x),f.y);\n\n    return res;\n}\n\n// 2D value noise\nfloat fnoise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*512.0;\n\n    float res = mix(mix( hash(ivec2(n  +  0.0)),\n                         hash(ivec2(n  +  1.0)),f.x),\n                    mix( hash(ivec2(n  + 512.0)),\n                         hash(ivec2(n  + 513.0)),f.x),f.y);\n\n    return res;\n}\n\n// 2D fBm\nfloat fbm( in vec2 x )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5),sin(0.5),-sin(0.5),cos", "\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// 2D simplex noise\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187,  // (3*sqrt(3)-1)/6\n                        0.366025403784439,  // 0.5*(sqrt(3)-1)\n                        -0.577350269189626,  // -1/sqrt(3)\n                        0.024390243902439); // 1/4*(1-sqrt(3))\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5", "\n    float f = 0.0;\n    float w = 0.5;\n    for( int i=0; i<p; i++ )\n    {\n        f += w * noise(x);\n        x = x * 2.0;\n        w = w*0.5;\n    }\n    return f;\n}\n\n// 2D random\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2D random\nfloat rand(vec2 co, float t)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + t) * 43758.5453);\n}\n\n// 2D random\nfloat rand(vec2 co, float t, float t2)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + t + t2) * 43758.5453);\n}\n\n// 2D random\nfloat rand(vec2 co, float t, float t2, float t3)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + t + t2 + t3) * 43758.5453);\n}\n\n// 2D random\nfloat rand(vec2 co, float t, float t2, float t3, float t4)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + t + t2 + t3 + t4) * 43758.5453);\n}\n\n// 2D random\nfloat rand(vec2 co, float t, float t2, float t3, float t4, float t5)\n{\n    return fract(sin(dot(co", "\n    float k0 = dot(p,p)/(r.x*r.x);\n    float k1 = dot(p,p)/(r.y*r.y);\n    float k2 = dot(p,p)/(r.z*r.z);\n    return (k0*k1*k2 - 1.0)/sqrt(k0 + k1 + k2);\n}\n\n//================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================", "\n    vec3 q = abs(p);\n    float l = length(q.xz);\n    float m = max(l,q.y);\n    if( l < r.x )\n    {\n        if( q.y < r.y ) return m-r.y;\n        return sqrt(dot(q,q))-r.y;\n    }\n    if( q.y > r.y ) return sqrt(dot(q,q))-r.y;\n    return max(l-r.x,q.y-r.y);\n}\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//===============================================================================================\n//================================================================", "\n    vec3 q = abs(p);\n    float d = max(dot(q,r),0.0);\n    return d;\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p);\n    float d = max(dot(q,r),0.0);\n    float s = max(q.x,max(q.y,q.z));\n    if( q.x>r.x ) q.x = r.x;\n    if( q.y>r.y ) q.y = r.y;\n    if( q.z>r.z ) q.z = r.z;\n    d = min(d,length(q-r));\n    return d*sign(s);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid2( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p);\n    float d = max(dot(q,r),0.0);\n    float s = max(q.x,max(q.y,q.z));\n    if( q.x>r.x ) q.x = r.x;\n    if( q.y>r.y ) q.y = r.y;\n    if( q.z>r.z ) q.z = r.z;\n    d = min(d,length(q-r));\n    return d*sign(s);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid3( in vec3 p, in vec3 r ) \n{\n    vec3 q = abs(p);\n    float d = max(dot(q,r),0.0);\n    float s = max(q.x,max(q.y,q.z));\n    if( q.x>r.x ) q.x = r.x;\n    if( q.y>r.y ) q.y = r.y;\n    if( q.z>r.z ) q.z = r.z", "\n    vec3 q = abs(p);\n    float d = 0.0;\n    if( max(q.x,max(q.y,q.z)) > r.x )\n    {\n        d = max(q.x,max(q.y,q.z)) - r.x;\n    }\n    else\n    {\n        vec3 z = (q-r)*(q-r);\n        d = min(max(z.x,max(z.y,z.z)),0.0);\n    }\n    return sqrt(d);\n}\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ---------------------------------------------------", "\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    float s = dot(q, vec2(1.0, -1.0));\n    float a = 1.0 - abs(s);\n    float b = 1.0 - abs(s+1.0);\n    float c = 1.0 - abs(s-1.0);\n    float k = smoothstep(0.0, 1.0, a*r.x + b*(1.0-r.x));\n    return mix(a, c, k);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec3 p )\n{\n    vec3 q = floor(p);\n    vec3 r = fract(p);\n    float s = dot(q, vec3(1.0, -1.0, 0.0));\n    float a = 1.0 - abs(s);\n    float b = 1.0 - abs(s+1.0);\n    float c = 1.0 - abs(s-1.0);\n    float k = smoothstep(0.0, 1.0, a*r.x + b*(1.0-r.x));\n    return mix(a, c, k);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec4 p )\n{\n    vec4 q = floor(p);\n    vec4 r = fract(p);\n    float s = dot(q, vec4(1.0, -1.0, 0.0, 0.0));\n    float a = 1.0 - abs(s);\n    float b = 1.0 - abs(s+1.0);\n    float c = 1.0 - abs(s-1.0);\n    float k = smoothstep(0.0, 1.0, a*r.x + b*(1.0-r.x));\n    return mix(a, c, k);\n}\n\n// http", "\n    return a / (1.0 - a * (1.0 - x));\n}\n\n// Schlick white-out function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat whiteOut( float a, float x )\n{\n    return 1.0 - a * x;\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat schlick( float a, float x )\n{\n    return bias( whiteOut( a, x ), x );\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 schlick( vec3 a, float x )\n{\n    return bias( whiteOut( a, x ), x );\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 schlick( vec3 a, vec3 x )\n{\n    return bias( whiteOut( a, x ), x );\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 schlick( float a, vec3 x )\n{\n    return bias( whiteOut( a, x ), x );\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 schlick( vec3 a, vec3 x )\n{\n    return bias( whiteOut( a, x ), x );\n}\n\n// Schlick fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.", "\n    return 1.0 - 2.0 * p + 2.0 * p * fract( x / p );\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( fract( x / p ) - 0.5 );\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * step( 0.5, fract( x / p ) );\n}\n\n// biased random\nfloat my_rnd( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * fract( sin( x ) * 12345.6789 );\n}\n\n// biased noise\nfloat my_noi( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * fract( noise( x ) );\n}\n\n// biased sine\nfloat my_sin( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( sin( x ) );\n}\n\n// biased cosine\nfloat my_cos( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( cos( x ) );\n}\n\n// biased tangent\nfloat my_tan( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( tan( x ) );\n}\n\n// biased arcsine\nfloat my_asin( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( asin( x ) );\n}\n\n// biased arccosine\nfloat my_acos( float x, float p )\n{\n    return 1.0 - 2.0 * p + 2.0 * p * abs( acos", "\n    vec3 c = vec3(0.0);\n    c.r = smoothstep( 0.0, 0.2, h );\n    c.g = smoothstep( 0.2, 0.4, h );\n    c.b = smoothstep( 0.4, 0.6, h );\n    c.r = smoothstep( 0.6, 0.8, h );\n    c.g = smoothstep( 0.8, 1.0, h );\n    return c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_2( float h )\n{\n    vec3 c = vec3(0.0);\n    c.r = smoothstep( 0.0, 0.2, h );\n    c.g = smoothstep( 0.2, 0.4, h );\n    c.b = smoothstep( 0.4, 0.6, h );\n    c.r = smoothstep( 0.6, 0.8, h );\n    c.g = smoothstep( 0.8, 1.0, h );\n    return c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_3( float h )\n{\n    vec3 c = vec3(0.0);\n    c.r = smoothstep( 0.0, 0.2, h );\n    c.g = smoothstep( 0.2, 0.4, h );\n    c.b = smoothstep( 0.4, 0.6, h );\n    c.r = smoothstep( 0.6, 0.8, h );\n    c.g = smoothstep( 0.8, 1.0, h );\n    return c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_4( float h )\n{\n    vec3 c = vec3", "\n    vec3  ba = pb-pa, pa1 = ro-pa, ba2 = rd*dot(ba,rd);\n    float a = dot(ba,ba), b = 2.0*dot(ba,pa1), c = dot(pa1,pa1)-r*r;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = (-b+h)/(2.0*a), t2 = (-b-h)/(2.0*a);\n    float t = min( t1, t2 );\n    if( t<0.0 ) t = max( t1, t2 ); if( t<0.0 ) return -1.0;\n    vec3  q = pa1 + t*rd;\n    if( dot(q,q) > r*r )\n    {\n        t = dot(pa1,ba)/dot(ba,ba);\n        if( t<0.0 ) t=0.0; if( t>1.0 ) t=1.0;\n        q = ba*t - pa1;\n        t = dot(q,q);\n        if( t>r*r ) return -1.0;\n        t = sqrt(r*r-t);\n        q = pa + ba*t;\n        q = q - ro;\n        t = dot(q,rd);\n    }\n    return t;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb-pa, pa1 = ro-pa, ba2 = rd*dot(ba,rd);\n    float a = dot(ba,ba), b = 2.0*dot", "\n    vec3 pa = p - a, ba = b - a;\n    float h = dot(ba, pa) / dot(ba, ba);\n    return length(pa - ba * h) - mix(ra, rb, h);\n}\n\nfloat sdCone(vec3 p, float h, float r)\n{\n    float q = length(p.xz);\n    return sqrt(q*q + p.y*p.y) - h*r;\n}\n\nfloat sdCone(vec3 p, float h, float r1, float r2)\n{\n    float q = length(p.xz);\n    float l = r2-r1;\n    return sqrt(q*q + p.y*p.y) - (r1*h+q*l)/(h*l);\n}\n\nfloat sdCone(vec3 p, float h, float r1, float r2, float a, float b)\n{\n    float q = length(p.xz);\n    float l = r2-r1;\n    return sqrt(q*q + p.y*p.y) - (r1*h+q*l)/(h*l);\n}\n\nfloat sdCone(vec3 p, float h, float r1, float r2, float a, float b, float c, float d)\n{\n    float q = length(p.xz);\n    float l = r2-r1;\n    return sqrt(q*q + p.y*p.y) - (r1*h+q*l)/(h*l);\n}\n\nfloat sdCone(vec3 p, float h, float r1, float r2, float a, float b, float c, float d, float e, float f)\n{\n    float q = length(p.xz);\n    float l = r2-r1;\n    return sqrt(q*q + p.y*p.y) - (r1*h+q*l)/(h*l);\n}\n\nfloat sdCone(vec3 p, float h, float r1, float r2, float a, float b, float c, float d, float e, float f", "\n    vec3 ba = b-a;\n    vec3 oa = ro-a;\n    float t = dot(rd,ba)/dot(rd,rd);\n    float d = dot(rd,oa)/dot(rd,rd);\n    float h = dot(rd,cross(rd,ba))/dot(rd,rd);\n    float r2 = r*r;\n    float h2 = h*h;\n    float d2 = d*d;\n    float t2 = t*t;\n    float t2h2 = t2-h2;\n    float t2d2 = t2-d2;\n    float t2d2r2 = t2d2*r2;\n    float t2h2r2 = t2h2*r2;\n    float t2h2d2 = t2h2-d2;\n    float t2h2d2r2 = t2h2d2*r2;\n    float t2d2h2 = t2d2-h2;\n    float t2d2h2r2 = t2d2h2*r2;\n    float t2d2h2r2d2 = t2d2h2r2*d2;\n    float t2h2d2r2d2 = t2h2d2r2*d2;\n    float t2d2h2r2d2r2 = t2d2h2r2d2*r2;\n    float t2h2d2r2d2r2 = t2h2d2r2*r2;\n    float t2h2d2r2d2r2h2 = t2h2d2r2d2r2*h2;\n    float t2d2h2r2d2r2h2 = t2d2h2r2d2r2*h2;\n    float t2d2h2r2d2r2h2r2 = t2d2h2r2d2r2h2*r2;\n    float t2h2d2r2d2r2h2r2 = t2h2d2r2d2r2h2*r", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float r1 = r * sin(a * 0.5);\n    float r2 = r * cos(a * 0.5);\n    float r3 = r1 * rad1 + r2 * rad2;\n    float r4 = r1 * rad1 - r2 * rad2;\n    float r5 = r3 * 0.5 + r4 * 0.5;\n    float r6 = r3 * 0.5 - r4 * 0.5;\n    float r7 = r5 * 0.5 + r6 * 0.5;\n    float r8 = r5 * 0.5 - r6 * 0.5;\n    float r9 = r7 * 0.5 + r8 * 0.5;\n    float r10 = r7 * 0.5 - r8 * 0.5;\n    float r11 = r9 * 0.5 + r10 * 0.5;\n    float r12 = r9 * 0.5 - r10 * 0.5;\n    float r13 = r11 * 0.5 + r12 * 0.5;\n    float r14 = r11 * 0.5 - r12 * 0.5;\n    float r15 = r13 * 0.5 + r14 * 0.5;\n    float r16 = r13 * 0.5 - r14 * 0.5;\n    float r17 = r15 * 0.5 + r16 * 0.5;\n    float r18 = r15 * 0.5 - r16 * 0.5;\n    float r19 = r17 * 0.5 + r18 * 0.5;\n    float r20 = r17 * 0.5 - r18 * 0.5;\n    float r21 = r19 * 0.5 + r20 * 0.5;\n    float r22 = r19", "\n    float a = atan(p.y,p.x);\n    float d = length(p);\n    float s = 1.0 - step(a,c.x) - step(c.y,a);\n    return (s*d - r);\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Ellipse\n//----------------------------------------------------------------------------------------\n\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    p = abs(p);\n    p = p/r;\n    return length(p) - 1.0;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Circle\n//----------------------------------------------------------------------------------------\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Rectangle\n//----------------------------------------------------------------------------------------\n\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Square\n//----------------------------------------------------------------------------------------\n\nfloat sdSquare( in vec2 p, in", "\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere5( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere6( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere7( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere8( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere9( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere10( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere11( in vec3 pos )\n{\n    return normalize(pos);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere12( in vec3 pos )\n{\n    return normalize(", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float aa = a*sca.x + r*sca.y;\n    float bb = a*scb.x + r*scb.y;\n    float rr = r*scb.y - a*scb.x;\n    return max( abs(rr) - ra, max( abs(aa) - rb, 0.0 ) );\n}\n\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    float res = 1.0;\n    float ph = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*tmax ).x;\n        res = min( res, 8.0*h/ph );\n        ph = h;\n        tmax += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n//-----------------------------------------------------\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0);\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec2 h = map( pos );\n        if( h.x<0.001 || t>100.0 ) break;\n        t += h.x;\n    }\n    if( t<100.0 )\n    {\n        res = vec2( t, map( ro + t*rd ).y );\n    }\n    return res;\n}\n\n//-----------------------------------------------------\n//", "\n    const float eps = 0.0001;\n    const vec2 h = vec2( eps, 0.0 );\n    return normalize( vec3(\n        map( pos + h.xyy, time ).x - map( pos - h.xyy, time ).x,\n        map( pos + h.yxy, time ).x - map( pos - h.yxy, time ).x,\n        map( pos + h.yyx, time ).x - map( pos - h.yyx, time ).x ) );\n}\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//=====================================================================================================================\n//=====================================================================================================================\n//=====================================================================================================================\n\n//================", "\n    float res = 1.0;\n    float ph = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*tmax ).x;\n        if( h<0.001 ) return 0.0;\n        float d = h*h/(1.0+ph);\n        ph = h;\n        tmax += d;\n        res = min( res, 10.0*h/tmax );\n        if( d>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( vec3(\n        map( pos+e.xyy ).x - map( pos-e.xyy ).x,\n        map( pos+e.yxy ).x - map( pos-e.yxy ).x,\n        map( pos+e.yyx ).x - map( pos-e.yyx ).x ) );\n}\n\n//------------------------------------------", "\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    vec2 e = dpdx*r.x + dpdy*r.y;\n    vec2 g = dpdx*r.y + dpdy*r.x;\n    vec2 h = dpdx*r.y - dpdy*r.x;\n    vec2 i = dpdx*r.x - dpdy*r.y;\n    vec2 j = dpdx*r.y + dpdy*r.x;\n    vec2 k = dpdx*r.y - dpdy*r.x;\n    vec2 l = dpdx*r.x - dpdy*r.y;\n    vec2 m = dpdx*r.x + dpdy*r.y;\n    vec2 n = dpdx*r.y - dpdy*r.x;\n    vec2 o = dpdx*r.y + dpdy*r.x;\n    vec2 p = dpdx*r.x - dpdy*r.y;\n    vec2 q = dpdx*r.x + dpdy*r.y;\n    vec2 r = dpdx*r.y - dpdy*r.x;\n    vec2 s = dpdx*r.y + dpdy*r.x;\n    vec2 t = dpdx*r.x - dpdy*r.y;\n    vec2 u = dpdx*r.x + dpdy*r.y;\n    vec2 v = dpdx*r.y - dpdy*r.x;\n    vec2 w = dpdx*r.y + dpdy*r.x;\n    vec2 x = dpdx*r.x - dpdy*r.y;\n    vec2 y = dpdx*r.x + dpdy*r.y;\n    vec2 z = dpdx*r.y - dpdy*r.x;\n    vec2 a = dpdx*r.y + dpdy*r.x;\n    vec2 b = dpdx*r.x - dpdy*r.y;\n    vec2 c = dpdx*r.x + dpdy*r.y;\n    vec2 d = dpdx*r.y", "\n    float y = floor(x*k+0.5);\n    return y/k;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  Signed distance function for a sphere\n//\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  Signed distance function for a box\n//\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  Signed distance function for a cylinder\n//\nfloat sdCylinder( vec3 p, float r, float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  Signed distance function for a torus\n//\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//------------------------------------------------------------------------------", "\n    vec3 sample_dir = normalize(sample_pos - camera_pos);\n    float sample_dist = length(sample_pos - camera_pos);\n    float sample_dist_sq = sample_dist * sample_dist;\n    float sample_dist_inv = 1.0 / sample_dist;\n    float sample_dist_inv_sq = 1.0 / sample_dist_sq;\n\n    float sample_height = sample_dist_inv * (sample_dist - planet_radius);\n    float sample_height_sq = sample_height * sample_height;\n    float sample_height_inv = 1.0 / sample_height;\n    float sample_height_inv_sq = 1.0 / sample_height_sq;\n\n    float sample_height_offset = sample_height - planet_radius;\n    float sample_height_offset_sq = sample_height_offset * sample_height_offset;\n    float sample_height_offset_inv = 1.0 / sample_height_offset;\n    float sample_height_offset_inv_sq = 1.0 / sample_height_offset_sq;\n\n    float sample_height_offset_inv_cubed = sample_height_offset_inv * sample_height_offset_inv * sample_height_offset_inv;\n    float sample_height_offset_inv_squared_cubed = sample_height_offset_inv_sq * sample_height_offset_inv_sq * sample_height_offset_inv_sq;\n\n    float sample_height_offset_inv_cubed_inv = 1.0 / sample_height_offset_inv_cubed;\n    float sample_height_offset_inv_squared_cubed_inv = 1.0 / sample_height_offset_inv_squared_cubed;\n\n    float sample_height_offset_inv_cubed_inv_cubed = sample_height_offset_inv_cubed_inv * sample_height_offset_inv_cubed_inv * sample_height_offset_inv_cubed_inv;\n    float sample_height_offset_inv_squared_cubed_inv_cubed = sample_height_offset_inv_squared_cubed_inv * sample_", "\n\tvec3 light_color = vec3(0.0, 1.0, 0.0);\n\tvec3 light_pos = vec3(0.0, 0.0, 0.0);\n\tvec3 light_dir = normalize(light_pos - pos);\n\tfloat light_dist = length(light_pos - pos);\n\tfloat light_attenuation = 1.0 / (1.0 + 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_attenuation * light_color;\n\tvec3 light_color = light_color * (max(0.0, dot(light_dir, dir)) + 0.5 * max(0.0, dot(light_dir, dir)) * max(0.0, dot(light_dir, dir)));\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.0001 * light_dist * light_dist * light_dist);\n\tvec3 light_color = light_color * (1.0 - 0.001 * light_dist * light_dist + 0.000", "\n    vec2 xy = coord.xy;\n    vec2 xy_norm = xy / resolution.xy;\n    vec2 xy_norm_offset = xy_norm * 2.0 - 1.0;\n    vec2 xy_norm_offset_scaled = xy_norm_offset * vec2(1.0, -1.0);\n    vec2 xy_norm_offset_scaled_aspect = xy_norm_offset_scaled * vec2(1.0, 1.0);\n    vec3 camera_vector = vec3(xy_norm_offset_scaled_aspect, 1.0);\n    return camera_vector;\n}\n\n/*\nnow we need to calculate the ray direction\n\nthe ray direction is the camera vector rotated by the camera rotation\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec3 camera_rotation) {\n    vec3 ray_direction = camera_vector;\n    ray_direction = rotate_x(ray_direction, camera_rotation.x);\n    ray_direction = rotate_y(ray_direction, camera_rotation.y);\n    ray_direction = rotate_z(ray_direction, camera_rotation.z);\n    return ray_direction;\n}\n\n/*\nnow we need to calculate the ray origin\n\nthe ray origin is the camera position\n*/\nvec3 get_ray_origin(vec3 camera_position) {\n    vec3 ray_origin = camera_position;\n    return ray_origin;\n}\n\n/*\nnow we need to calculate the ray\n\nthe ray is the ray origin and the ray direction\n*/\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay get_ray(vec3 camera_position, vec3 camera_rotation, vec3 resolution, vec2 coord) {\n    vec3 camera_vector = get_camera_vector(resolution, coord);\n    vec3 ray_direction = get_ray_direction(camera_vector, camera_rotation);\n    vec3 ray_origin = get_ray_origin(camera_position);\n    Ray ray = Ray(ray_origin, ray_direction);\n    return ray;\n}\n\n/*\nnow we need to calculate the", "\n    float d = dot(p, c.xy);\n    float h = length(p) - d;\n    return max(h, -d) - ra;\n}\n\n//----------------------------------------------------------------------------------------\n// Sphere\n//----------------------------------------------------------------------------------------\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n//----------------------------------------------------------------------------------------\n// Tetrahedron\n//----------------------------------------------------------------------------------------\n\nfloat sdTetrahedron(vec3 p, float s)\n{\n    float invsqrt3 = 0.577350269189625764509148780501957;\n    float invsqrt6 = 0.288675134594812882259921626891946;\n    float v1 = dot(p, vec3(invsqrt3, invsqrt3, invsqrt3));\n    float v2 = dot(p, vec3(invsqrt3, -invsqrt3, -invsqrt3));\n    float v3 = dot(p, vec3(-invsqrt3, invsqrt3, -invsqrt3));\n    float v4 = dot(p, vec3(-invsqrt3, -invsqrt3, invsqrt3));\n    float mx = max(max(v1, v2), max(v3, v4));\n    float mn = min(min(v1, v2), min(v3, v4));\n    float m = max(mx, -mn);\n    float d = length(p) - s;\n    return max(d, m * invsqrt6);\n}\n\n//------", "\n  vec3 color = vec3(0.0);\n  if (material == 0) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 1) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 2) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 3) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 4) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 5) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 6) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 7) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 8) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 9) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 10) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 11) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 12) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 13) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (material == 14) {\n    color = vec3(0.0, 0.0, 0.0);\n", "\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.9f;\n        case MATERIAL_METAL:\n            return 0.8f;\n        case MATERIAL_WOOD:\n            return 0.3f;\n        case MATERIAL_PLASTIC:\n            return 0.2f;\n        case MATERIAL_CONCRETE:\n            return 0.1f;\n        case MATERIAL_WATER:\n            return 0.0f;\n        default:\n            return 0.0f;\n    }\n}\n\n// Get the absorption of a material.\n// 0.0 is not absorbed at all.\n// 1.0 is fully absorbed.\nfloat get_material_absorption(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.0f;\n        case MATERIAL_METAL:\n            return 0.0f;\n        case MATERIAL_WOOD:\n            return 0.0f;\n        case MATERIAL_PLASTIC:\n            return 0.0f;\n        case MATERIAL_CONCRETE:\n            return 0.0f;\n        case MATERIAL_WATER:\n            return 0.0f;\n        default:\n            return 0.0f;\n    }\n}\n\n// Get the scattering of a material.\n// 0.0 is not scattered at all.\n// 1.0 is fully scattered.\nfloat get_material_scattering(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.0f;\n        case MATERIAL_METAL:\n            return 0.0f;\n        case MATERIAL_WOOD:\n            return 0.0f;\n        case MATERIAL_PLASTIC:\n            return 0.0f;\n        case MATERIAL_CONCRETE:\n            return 0.0f;\n        case MATERIAL_WATER:\n            return 0.0f;\n        default:\n            return 0.0f;\n    }\n", "\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 1.5;\n        case MATERIAL_PLASTIC:\n            return 1.3;\n        case MATERIAL_METAL:\n            return 1.0;\n        default:\n            return 1.0;\n    }\n}\n\n// Get color of a material.\nvec3 get_material_color(int material) {\n    switch (material) {\n        case MATERIAL_GLASS:\n            return vec3(0.0, 0.0, 1.0);\n        case MATERIAL_PLASTIC:\n            return vec3(0.0, 1.0, 0.0);\n        case MATERIAL_METAL:\n            return vec3(1.0, 1.0, 1.0);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Get the color of a pixel.\nvec3 get_pixel_color(vec3 ray_origin, vec3 ray_direction, int max_depth) {\n    // Initialize the color to black.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    // Initialize the ray to the camera.\n    vec3 ray_position = ray_origin;\n    vec3 ray_direction = ray_direction;\n\n    // Initialize the depth to 0.\n    int depth = 0;\n\n    // Initialize the intersection to false.\n    bool intersected = false;\n\n    // Initialize the intersection point to the origin.\n    vec3 intersection_point = vec3(0.0, 0.0, 0.0);\n\n    // Initialize the intersection normal to the origin.\n    vec3 intersection_normal = vec3(0.0, 0.0, 0.0);\n\n    // Initialize the intersection material to 0.\n    int intersection_material = 0;\n\n    // Initialize the intersection distance to 0.\n    float intersection_distance = 0.0;\n\n    // Initialize the intersection color to black.\n    vec3 intersection_color = vec3(0", "\n    return material_opacity[material];\n}\n\n// Get the color of a material.\n// The color is a 3-tuple of floats, representing the red, green, and blue\n// components of the color.\nvec3 get_material_color(int material) {\n    return material_color[material];\n}\n\n// Get the specular exponent of a material.\n// The specular exponent is a float between 0.0 and 1.0, representing the\n// exponent of the specular component of the Phong lighting model.\nfloat get_material_specular_exponent(int material) {\n    return material_specular_exponent[material];\n}\n\n// Get the specular color of a material.\n// The specular color is a 3-tuple of floats, representing the red, green, and\n// blue components of the specular color.\nvec3 get_material_specular_color(int material) {\n    return material_specular_color[material];\n}\n\n// Get the diffuse color of a material.\n// The diffuse color is a 3-tuple of floats, representing the red, green, and\n// blue components of the diffuse color.\nvec3 get_material_diffuse_color(int material) {\n    return material_diffuse_color[material];\n}\n\n// Get the ambient color of a material.\n// The ambient color is a 3-tuple of floats, representing the red, green, and\n// blue components of the ambient color.\nvec3 get_material_ambient_color(int material) {\n    return material_ambient_color[material];\n}\n\n// Get the texture of a material.\n// The texture is a 2-tuple of floats, representing the x and y coordinates of\n// the texture.\nvec2 get_material_texture(int material) {\n    return material_texture[material];\n}\n\n// Get the texture of a material.\n// The texture is a 2-tuple of floats, representing the x and y coordinates of\n// the texture.\nvec2 get_material_texture_scale(int material) {\n    return material_texture_scale[material];\n}\n\n// Get the texture of a material.\n// The texture is a 2-tuple of", "\n    vec3 line_dir = line_b - line_a;\n    vec3 tri_normal = normalize(cross(tri_b - tri_a, tri_c - tri_a));\n    float d = dot(tri_normal, tri_a);\n    float t = (d - dot(tri_normal, line_a)) / dot(tri_normal, line_dir);\n    vec3 intersection = line_a + t * line_dir;\n    vec3 v0 = tri_b - tri_a;\n    vec3 v1 = tri_c - tri_a;\n    vec3 v2 = intersection - tri_a;\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return vec3(u >= 0.0 && v >= 0.0 && u + v < 1.0, u, v);\n}\n\n// Determine whether a line intersects a quad.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_quad(vec3 line_a, vec3 line_b, vec3 quad_a, vec3 quad_b, vec3 quad_c, vec3 quad_d) {\n    vec3 tri_a = quad_a;\n    vec3 tri_b = quad_b;\n    vec3 tri_c = quad_c;\n    vec3 tri_d = quad_d;\n    vec3 tri_e = quad_a;\n    vec3 tri_f = quad_c;", "\n    vec3 tri_normal = cross(tri_b - tri_a, tri_c - tri_a);\n    return normalize(tri_normal);\n}\n\n// Given a point and a triangle,\n// compute the distance from the point to the triangle.\nfloat get_point_tri_distance(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 tri_normal = get_tri_surface_normal(tri_a, tri_b, tri_c);\n    float distance = dot(tri_normal, point - tri_a);\n    return abs(distance);\n}\n\n// Given a point and a triangle,\n// compute the distance from the point to the plane of the triangle.\nfloat get_point_tri_plane_distance(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 tri_normal = get_tri_surface_normal(tri_a, tri_b, tri_c);\n    float distance = dot(tri_normal, point - tri_a);\n    return distance;\n}\n\n// Given a point and a triangle,\n// compute the distance from the point to the plane of the triangle.\nfloat get_point_tri_plane_distance_squared(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 tri_normal = get_tri_surface_normal(tri_a, tri_b, tri_c);\n    float distance = dot(tri_normal, point - tri_a);\n    return distance * distance;\n}\n\n// Given a point and a triangle,\n// compute the distance from the point to the plane of the triangle.\nfloat get_point_tri_plane_distance_squared_fast(vec3 point, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 tri_normal = get_tri_surface_normal(tri_a, tri_b, tri_c);\n    float distance = dot(tri_normal, point - tri_a);\n    return distance * distance;\n}\n\n// Given a point and a triangle,\n// compute the distance from the point to the", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat3(x_axis, y_axis, z_axis);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat4 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat4(x_axis, y_axis, z_axis, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/matrix-transformations/projection-matrix\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(radians(fov / 2.0));\n    float range = far - near;\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, -(far + near) / range, -1.0,\n        0.0, 0.0, -(2.0 * far * near) / range, 0.0\n    );\n}\n\n// Generate an orthographic projection matrix.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-", "\n    cast_ray_result result;\n    result.intersected = false;\n    result.distance = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n  vec3 ray_direction = normalize(ray_target - ray_origin);\n  float shadow_distance = 1.0;\n  float shadow_opacity = 1.0;\n  float shadow_step = 0.0;\n  float shadow_step_size = 0.001;\n  float shadow_step_max = 100.0;\n  float shadow_step_min = 0.0;\n  float shadow_step_epsilon = 0.00001;\n  float shadow_step_max_distance = 100.0;\n  float shadow_step_max_opacity = 0.99;\n  float shadow_step_min_opacity = 0.01;\n  float shadow_step_max_distance_epsilon = 0.00001;\n  float shadow_step_max_opacity_epsilon = 0.00001;\n  float shadow_step_min_opacity_epsilon = 0.00001;\n  float shadow_step_max_distance_epsilon = 0.00001;\n  float shadow_step_max_opacity_epsilon = 0.00001;\n  float shadow_step_min_opacity_epsilon = 0.00001;\n  float shadow_step_max_distance_epsilon = 0.00001;\n  float shadow_step_max_opacity_epsilon = 0.00001;\n  float shadow_step_min_opacity_epsilon = 0.00001;\n  float shadow_step_max_distance_epsilon = 0.00001;\n  float shadow_step_max_opacity_epsilon = 0.00001;\n  float shadow_step_min_opacity_epsilon = 0.00001;\n  float shadow_step_max_distance_epsilon = 0.00001;\n  float shadow_step_max_opacity_epsilon = 0.00001;\n  float shadow_step_min_opacity_epsilon = 0.00001;\n  float shadow_step_max_distance_epsilon", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix( mix( bnoise(n+  0.0), bnoise(n+  1.0),f.x),\n                mix( bnoise(n+ 57.0), bnoise(n+ 58.0),f.x),f.y);\n}\n\n// 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*491.0;\n    return mix( mix( mix( bnoise(n+  0.0), bnoise(n+  1.0),f.x),\n                        mix( bnoise(n+ 57.0), bnoise(n+ 58.0),f.x),f.y),\n                mix( mix( bnoise(n+491.0), bnoise(n+492.0),f.x),\n                        mix( bnoise(n+548.0), bnoise(n+549.0),f.x),f.y),f.z);\n}\n\n// 4D noise\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*491.0 + p.w*34369.0;\n    return mix( mix( mix", "\n    float fl = floor(p);\n    float fc = fract(p);\n    float fc2 = fc*fc;\n    float fc3 = fc2*fc;\n    float fc4 = fc3*fc;\n    float fc5 = fc4*fc;\n    float fc6 = fc5*fc;\n    float fc7 = fc6*fc;\n    float fc8 = fc7*fc;\n    float fc9 = fc8*fc;\n    float fc10 = fc9*fc;\n    float fc11 = fc10*fc;\n    float fc12 = fc11*fc;\n    float fc13 = fc12*fc;\n    float fc14 = fc13*fc;\n    float fc15 = fc14*fc;\n    float fc16 = fc15*fc;\n    float fc17 = fc16*fc;\n    float fc18 = fc17*fc;\n    float fc19 = fc18*fc;\n    float fc20 = fc19*fc;\n    float fc21 = fc20*fc;\n    float fc22 = fc21*fc;\n    float fc23 = fc22*fc;\n    float fc24 = fc23*fc;\n    float fc25 = fc24*fc;\n    float fc26 = fc25*fc;\n    float fc27 = fc26*fc;\n    float fc28 = fc27*fc;\n    float fc29 = fc28*fc;\n    float fc30 = fc29*fc;\n    float fc31 = fc30*fc;\n    float fc32 = fc31*fc;\n    float fc33 = fc32*fc;\n    float fc34 = fc33*fc;\n    float fc35 = fc34*fc;\n", "\n    return fract(sin(float(n)*1e-3)*456789.456);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(41,289)))*456789.456);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 p )\n{\n    return fract(sin(dot(p,vec3(7,157,113)))*456789.456);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n, float seed )\n{\n    return fract(sin((n+seed)*1e-3)*456789.456);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 p, float seed )\n{\n    return fract(sin(dot(p,vec2(41,289))+seed)*456789.456);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 p, float seed )\n{\n    return fract(sin(dot(p,vec3(7,157,113))+seed)*456789.456);\n}\n\n// 3D Value Noise by Ian McEwan, Ashima Arts\n// https://github.com/ashima/webgl-noise\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.7928429140015", "\n    float n = floor(p);\n    float f = fract(p);\n    float s = f*f*(3.0-2.0*f);\n    return mix( rand(n), rand(n+1.0), s );\n}\n\n// 2D gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float s = f*f*(3.0-2.0*f);\n    return mix( mix( rand(n), rand(n+vec2(1.0,0.0)), s.x ),\n                mix( rand(n+vec2(0.0,1.0)), rand(n+vec2(1.0,1.0)), s.x ), s.y );\n}\n\n// 3D gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float s = f*f*(3.0-2.0*f);\n    return mix( mix( mix( rand(n), rand(n+vec3(1.0,0.0,0.0)), s.x ),\n                     mix( rand(n+vec3(0.0,1.0,0.0)), rand(n+vec3(1.0,1.0,0.0)), s.x ), s.y ),\n                mix( mix( rand(n+vec3(0.0,0.0,1.0)), rand(n+vec3(1.0,0.0,1.0)), s.x ),\n                     mix( rand(n+vec3(0.0,1.0,1.0)), rand(n+vec3(1.0,1.0,1.0)), s.x ), s.y ), s.z );\n}\n\n// 4D gradient noise\nfloat gnoise( in vec4 p )\n{\n    vec4 n = floor(p);\n    vec4 f = fract(p);\n    float s = f*f", "\n    float f = 0.0;\n    float A = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += A * noise(x);\n        x = x * 2.0 + G;\n        A = A * 0.5;\n    }\n    return f;\n}\n\n// ----------------------------------------------------------------------------\n// main\n// ----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // time\n    float t = iTime * 0.5;\n\n    // noise\n    float n = fbm( p.x * 2.0 + t, 0.0 );\n\n    // color\n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0", "\n    // Quadratic polynomial coefficients\n    float a = 1.0;\n    float b = 2.0*dot(p,p);\n    float c = dot(p,p) - 1.0;\n\n    // Quadratic polynomial solutions\n    float t0 = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n    float t1 = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n\n    // Return the color associated to the closest solution\n    return (t0 > 0.0)? vec3(1.0,0.0,0.0) : vec3(0.0,0.0,1.0);\n}\n\nvoid main()\n{\n    // Normalized pixel coordinates (x and y in [0,1])\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Sphere center\n    vec3 center = vec3(0.0,0.0,0.0);\n\n    // Sphere radius\n    float radius = 0.5;\n\n    // Sphere surface point\n    vec3 p = center + radius * normalize(vec3(uv.x, uv.y, 0.0));\n\n    // Sphere surface color\n    vec3 color = getColor(p);\n\n    // Output to screen\n    gl_FragColor = vec4(color,1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Quadratic Polynomial';\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n  }\n  fragmentPrecision?(): string {\n    return PRECISION_MEDIUMP;\n  }\n  destory(): void {}\n  initial?(gl: WebGLRenderingContext, program: Web", "\n    // 3D cubic polynomial\n    float a = dot(pb,pb);\n    float b = dot(pb,pb*pb);\n    float c = dot(pb,pb*pb*pb);\n    float d = dot(pb,pb*pb*pb*pb);\n\n    // Find the roots of the polynomial\n    float r1, r2, r3;\n    findCubicRoots(a,b,c,d,r1,r2,r3);\n\n    // Return a color based on the roots\n    return vec3(r1,r2,r3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Rotate the camera around the origin\n    float t = iTime*0.25;\n    vec3 ro = vec3(0.0,0.0,1.0);\n    ro = rotate(ro,vec3(0.0,1.0,0.0),t);\n\n    // Ray direction\n    vec3 rd = normalize(vec3(uv.xy-0.5,1.0));\n    rd = rotate(rd,vec3(0.0,1.0,0.0),t);\n\n    // Ray march\n    float d = 0.0;\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + rd*d;\n        d += 0.01;\n        if(d>10.0) break;\n        float h = map(pos);\n        if(h<0.001) break;\n    }\n\n    // Get the color at the surface\n    vec3 pb = ro + rd*d;\n    col = getColor(pb);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec4( -1.0 );\n    return vec4( tN, tF );\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n\tvec3 n = vec3(\n        map( pos + e.xyy, time ).x - map( pos - e.xyy, time ).x,\n        map( pos + e.yxy, time ).x - map( pos - e.yxy, time ).x,\n        map( pos + e.yyx, time ).x - map( pos - e.yyx, time ).x );\n    return normalize( n );\n}\n\n// https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    float tmin = 1000.0;\n    vec3  cen = vec3( 0.0 );\n    float rad = 1.0;\n    vec4  hit = boxIntersect( ro, rd, cen, rad );\n    if( hit.x>0.0 ) tmin = hit.x;\n    return tmin;\n}\n\n// https://iquilezles.org/www/articles/shadertoydefines/shadertoydefines.htm\n#define R(p,a)vec4(cos(a)*p,sin(a", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro + cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normalSDF( in vec3 pos, in float eps, in float sdf( in vec3 ) )\n{\n    const vec2 e = vec2( eps, 0.0 );\n    return normalize( vec3(\n        sdf( pos + e.xyy ) - sdf( pos - e.xyy ),\n        sdf( pos + e.yxy ) - sdf( pos - e.yxy ),\n        sdf( pos + e.yyx ) - sdf( pos - e.yyx ) ) );\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normalSDF( in vec3 pos, in float eps, in float sdf( in vec3 ) )\n{\n    const vec2 e = vec2( eps, 0.0 );\n    return normalize( vec3(\n        sdf( pos + e.xyy ) - sdf( pos - e.xyy ),\n        sdf( pos + e.yxy ) - sdf( pos - e.yxy )", "\n    float res = 1.0;\n    float ph = 1.0;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*tmax).x;\n        if(h<0.001) return 0.0;\n        float d = h*h/(10.0*tmax);\n        tmax -= d;\n        res = min(res, w*ph);\n        ph *= 1.0-d;\n        if(tmax<mint) break;\n    }\n    return res;\n}\n\n//------------------------------------------------------------------\n//\n// Soft shadows, based on\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and further fixed and improved\n//\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float k)\n{\n    float res = 1.0;\n    float ph = 1.0;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*tmax).x;\n        if(h<0.001) return 0.0;\n        float d = max(h, 0.001);\n        tmax -= d;\n        res = min(res, k*ph);\n        ph *= 1.0-d;\n        if(tmax<mint) break;\n    }\n    return res;\n}\n\n//------------------------------------------------------------------\n//\n// Hard shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat hard", " seed = fract(10000.0*seed); return seed; }\nfloat rand(float x) { return rand(x*1000.0); }\nfloat rand(float x, float y) { return rand(x*1000.0 + y); }\nfloat rand(float x, float y, float z) { return rand(x*1000.0 + y*100.0 + z); }\nfloat rand(float x, float y, float z, float w) { return rand(x*1000.0 + y*100.0 + z*10.0 + w); }\nfloat rand(vec2 p) { return rand(p.x, p.y); }\nfloat rand(vec3 p) { return rand(p.x, p.y, p.z); }\nfloat rand(vec4 p) { return rand(p.x, p.y, p.z, p.w); }\n\nfloat rand_float(vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rand_vec3(vec2 p) {\n    return vec3(rand_float(p), rand_float(p + vec2(1.0)), rand_float(p + vec2(2.0)));\n}\n\nvec3 rand_vec3(vec3 p) {\n    return vec3(rand_float(p), rand_float(p + vec2(1.0)), rand_float(p + vec2(2.0)));\n}\n\nvec3 rand_vec3(vec4 p) {\n    return vec3(rand_float(p), rand_float(p + vec2(1.0)), rand_float(p + vec2(2.0)));\n}\n\nvec3 rand_vec3(float p) {\n    return vec3(rand_float(p), rand_float(p + 1.0), rand_float(p + 2.0));\n}\n\nvec3 rand_vec", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c )\n{\n    return pal( t, a, b, c, vec3(1.0) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b )\n{\n    return pal( t, a, b, vec3(1.0) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a )\n{\n    return pal( t, a, vec3(1.0) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t )\n{\n    return pal( t, vec3(1.0) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f )\n{\n    return a + b*cos( 6.28318*(c*t+d) ) + c*cos( 6.28318*(e*t+f) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e )\n{\n    return pal( t, a, b, c, d", "\n    p.xz = abs(p.xz);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.xz-lb);\n    p.xz = abs(p.xz-la);\n    p.xz = abs(p.", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  x = a + ba*h;\n    float d = length( p - x );\n    float s = sign( cross( ba, pa ) );\n    float g = smoothstep( -band, band, d - r );\n    float w = s*d;\n    return vec4( x, w, g );\n}\n\n//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    vec2 q = abs(p)-b;\n    vec2 w = max(q,0.0);\n    float d = length(max(vec2(0.0),q));\n    float d2 = min(max(q.x,q.y),0.0);\n    d = min(d,-d2);\n    d = max(d,-length(w));\n    d = max(d,-abs(length(p)-r)-s);\n    return vec4(d,length(p),0.0,0.0);\n}\n\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  v = max(w,0.0);\n    float a = length(v);\n    float b = min(max(w.x,w.y),0.0);\n    return vec3(a,b,s);\n}\n\n// signed distance function\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    return length(max(w,0.0)) + min(max(w.x,w.y),0.0);\n}\n\n// signed distance function\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance function\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = a-p;\n    vec2 pb = b-p;\n    vec2 pc = c-p;\n    vec2 u = b-a;\n    vec2 v = c-b;\n    vec2 w = a-c;\n    vec2 uu = u*u;\n    vec2 vv = v*v;\n    vec2 ww = w*w;\n    vec2 uv = u*v;\n    vec2 uw = u*w;\n    vec2 x = (v*ww-uv*v)*pa + (w*uv-uw*u)*pb + (u*uw-vv*w)*pc;\n    vec2 y = (v*ww-uv*v) + (w*uv-uw*u) + (u*uw-vv*w);\n    float d = sign(dot(x,x)-dot(y,y)*0.25);\n    vec2  z = d*sqrt(abs(x*x-y*y*0.25));\n    float s = max(sign(dot(u", "\n    float d = length(p);\n    float d2 = abs(d - r);\n    float d3 = abs(d - band);\n    float d4 = min(d2, d3);\n    return vec4(d, d2, d3, d4);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float bandWidth ) \n{\n    float d = length(p);\n    float d2 = abs(d - r);\n    float d3 = abs(d - band);\n    float d4 = min(d2, d3);\n    float d5 = abs(d4 - bandWidth);\n    return vec4(d, d2, d3, d4, d5);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float bandWidth, float bandWidth2 ) \n{\n    float d = length(p);\n    float d2 = abs(d - r);\n    float d3 = abs(d - band);\n    float d4 = min(d2, d3);\n    float d5 = abs(d4 - bandWidth);\n    float d6 = abs(d5 - bandWidth2);\n    return vec4(d, d2, d3, d4, d5, d6);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float bandWidth, float bandWidth2, float bandWidth3 ) \n{\n    float d = length(p);\n    float d2 = abs(d - r);\n    float d3 = abs(d - band);\n    float d4 = min(d2, d3);\n    float d5 = abs(d4 - bandWidth);\n    float d6 = abs(d5 - bandWidth2);\n    float d7 =", "\n    float d = 1e10;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%5];\n        d = min( d, sdSegment( p, a, b, r ) );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, in float r )\n{\n    vec2 verts[5];\n    verts[0] = vec2( 0.0, 0.0 );\n    verts[1] = vec2( 0.0, 1.0 );\n    verts[2] = vec2( 1.0, 1.0 );\n    verts[3] = vec2( 1.0, 0.0 );\n    verts[4] = vec2( 0.5, 0.5 );\n    return sdPoly( p, verts, r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a )\n{\n    vec2 verts[5];\n    verts[0] = vec2( 0.0, 0.0 );\n    verts[1] = vec2( 0.0, 1.0 );\n    verts[2] = vec2( 1.0, 1.0 );\n    verts[3] = vec2( 1.0, 0.0 );\n    verts[4] = vec2( 0.5, 0.5 );\n    return sdPoly( p, verts, r );\n}\n\nfloat sdPoly( in vec2 p, in float r, in float a, in float b )\n{\n    vec2 verts[5];\n    verts[0] = vec2( 0.0, 0.0 );\n    verts[1] = vec2( 0.0, 1.0 );\n    verts[2] = vec2( 1.0, 1.0 );\n    verts[3] = vec2( 1.0, 0.0 );\n    verts[4] = vec2( 0.5, 0.5", "\n    vec2  v0 = verts[0], v1 = verts[1], v2 = verts[2], v3 = verts[3], v4 = verts[4];\n    float d = 0.0;\n    float l = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float z0 = 0.0;\n    float z1 = 0.0;\n    float z2 = 0.0;\n    float z3 = 0.0;\n    float z4 = 0.0;\n    float z5 = 0.0;\n    float z6 = 0.0;\n    float z7 = 0.0;\n    float z8 = 0.0;\n    float z9 = 0.0;\n    float z10 = 0.0;\n    float z11 = 0.0;\n    float z12 = 0.0;\n    float z13 = 0.0;\n    float z14 = 0.0;\n    float z15 = 0.0;\n    float z16 = 0.0;\n    float z17 = 0", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), h, ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    return vec3( length(p)-r, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec3 ba = sdgSegment(p,b,a);\n    vec3 ca = sdgSegment(p,c,a);\n    vec3 cb = sdgSegment(p,c,b);\n    float s = sign( ba.y*ca.z", "\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y = p.y+p.x*k*0.5;\n    p.y = abs(p.y);\n    p.x = p.x*2.0;\n    if( p.y<k*r )\n    {\n        p.x -= clamp(p.y*2.0/k,0.0,r*2.0);\n    }\n    else\n    {\n        p.y -= k*r;\n        p = vec2( p.x-2.0*r, p.y );\n    }\n    p = abs(p);\n    p.x -= r;\n    p.y = abs(p.y-(k*r*0.5));\n    p.y -= k*r*0.5;\n    float d = length(p)*sign(p.x);\n    return vec3( d, 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgOctagon( in vec2 p, in float r ) \n{\n    const float k = sqrt(2.0-sqrt(2.0))/2.0;\n    const float l = sqrt(0.5+k);\n    const vec2 k2 = vec2(1.0-k,1.0+k);\n    p = abs(p);\n    p -= vec2(clamp(p.x,-r*k2.x,r*k2.y),clamp(p.y,-r*k2.x,r*k2.y));\n    p = vec2(abs(p.x)-r*k,abs(p.y)-r*k);\n    float d = length(p)*sign(p.x*p.y);\n    float d1 = length", "\n  vec3 e = X * p;\n  float a = dot(e, e);\n  float b = dot(e, X[2]);\n  float c = dot(X[2], X[2]);\n  float d = b * b - a * c;\n  if (d < 0.0) return false;\n  float s = sqrt(d);\n  float t1 = (b - s) / c;\n  float t2 = (b + s) / c;\n  tan1 = p + t1 * X[2];\n  tan2 = p + t2 * X[2];\n  return true;\n}\n\n// Return the intersection of the line p + t * d with the conic X.\n// Return false if no intersection.\nbool intersect(vec3 p, vec3 d, mat3 X, out vec3 p1, out vec3 p2) {\n  vec3 e = X * p;\n  vec3 f = X * d;\n  float a = dot(e, f);\n  float b = dot(e, e) - 1.0;\n  float c = dot(f, f);\n  float d = a * a - b * c;\n  if (d < 0.0) return false;\n  float s = sqrt(d);\n  float t1 = (a - s) / c;\n  float t2 = (a + s) / c;\n  p1 = p + t1 * d;\n  p2 = p + t2 * d;\n  return true;\n}\n\n// Return the intersection of the line p + t * d with the conic X.\n// Return false if no intersection.\nbool intersect(vec3 p, vec3 d, mat3 X, out float t1, out float t2) {\n  vec3 e = X * p;\n  vec3 f = X * d;\n  float a = dot(e, f);\n  float b = dot(e, e) - 1.0;\n  float c = dot(f, f);\n  float d = a * a - b * c;\n  if (d < 0.0) return false;\n  float s = sqrt(d);", "\n    return vec3(a.x / max(b.x, 0.000001), a.y / max(b.y, 0.000001), a.z / max(b.z, 0.000001));\n}\n\nvec3 div(vec3 a, float b) {\n    return vec3(a.x / max(b, 0.000001), a.y / max(b, 0.000001), a.z / max(b, 0.000001));\n}\n\nvec3 div(float a, vec3 b) {\n    return vec3(a / max(b.x, 0.000001), a / max(b.y, 0.000001), a / max(b.z, 0.000001));\n}\n\nvec3 div(float a, float b) {\n    return vec3(a / max(b, 0.000001), a / max(b, 0.000001), a / max(b, 0.000001));\n}\n\nvec3 div(float a, float b, float c) {\n    return vec3(a / max(b, 0.000001), a / max(b, 0.000001), a / max(c, 0.000001));\n}\n\nvec3 div(float a, vec3 b, float c) {\n    return vec3(a / max(b.x, 0.000001), a / max(b.y, 0.000001), a / max(c, 0.000001));\n}\n\nvec3 div(float a, float b, vec3 c) {\n    return vec3(a / max(b, 0.000001), a / max(b, 0.000001), a / max(c", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.y, -s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, float a, vec3 axis)\n{\n    float s = sin(a);\n    float c = cos(a);\n    float t = 1.0 - c;\n    float x = axis.x, y = axis.y, z = axis.z;\n    float tx = t * x, ty = t * y;\n    return vec3(tx * x + c, tx * y - z * s, tx * z + y * s) * p.x +\n           vec3(tx * y + z * s, ty * y + c, ty * z - x * s) * p.y +\n           vec3(tx * z - y * s, ty * z + x * s, t * z * z + c) * p.z;\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.y, -s", "\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5, float R6)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float R2, float R3, float R4, float R5, float R6, float R7)\n{\n    float f = x / R;\n    return 1.0 - f * f * (3.0 - 2.0 * f);\n}\n\n//", "\n    return 1.0 / (1.0 + e * R * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r)\n{\n    return 1.0 / (1.0 + e * R * R * r * r);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2)\n{\n    return 1.0 / (1.0 + e * R * R * r * r * r2);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3)\n{\n    return 1.0 / (1.0 + e * R * R * r * r * r2 * r3);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4)\n{\n    return 1.0 / (1.0 + e * R * R * r * r * r2 * r3 * r4);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4, float r5)\n{\n    return 1.0 / (1.0 + e * R * R * r * r * r2 * r3 * r4 * r5);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float r, float r2, float r3, float r4, float r5, float r6)\n{\n    return 1.0 / (1.0 + e * R * R", "\n    float k = 0.0;\n    if (e > 0.0)\n    {\n        k = (a - b) / (e * R);\n    }\n    return k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k)\n{\n    float k2 = 0.0;\n    if (e > 0.0)\n    {\n        k2 = (a - b) / (e * R);\n    }\n    return k + k2;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k2)\n{\n    float k3 = 0.0;\n    if (e > 0.0)\n    {\n        k3 = (a - b) / (e * R);\n    }\n    return k + k2 + k3;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k2, float k3)\n{\n    float k4 = 0.0;\n    if (e > 0.0)\n    {\n        k4 = (a - b) / (e * R);\n    }\n    return k + k2 + k3 + k4;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e, float k, float k2, float k3, float k4)\n{\n    float k5 = 0", "\n    float d = length(p - c);\n    return e * exp(-d * d / (2.0 * R * R));\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    float d = length(p - c);\n    return e * exp(-(d - R) * (d - R) / (2.0 * R * R));\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Box(vec3 p, vec3 c, vec3 s, float e)\n{\n    vec3 d = abs(p - c) - s;\n    return e * exp(-length(max(d, 0.0)) * length(max(d, 0.0)) / (2.0 * R * R));\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, vec3 s, float e)\n{\n    vec3 d = abs(p - c);\n    d.y -= s.y;\n    return e * exp(-length(max(d, 0.0)) * length(max(d, 0.0)) / (2.0 * R * R));\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Cone(vec3 p, vec3 c, vec3 s, float e)\n{\n    vec3 d = abs(p - c);\n    d.y -= s.y;\n    return e * exp(-length(max(d, 0.0)) * length(max(d, 0.0)) / (2.0 * R * R));\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Torus(vec3 p, vec3 c, vec3 s, float e)\n", "\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 bc = c - b;\n    float ab2 = dot(ab, ab);\n    float ac2 = dot(ac, ac);\n    float bc2 = dot(bc, bc);\n    float abbc = dot(ab, bc);\n    float abac = dot(ab, ac);\n    float bcac = dot(bc, ac);\n    float abbc2 = abbc * abbc;\n    float abac2 = abac * abac;\n    float bcac2 = bcac * bcac;\n    float ab2bc2 = ab2 * bc2;\n    float ab2ac2 = ab2 * ac2;\n    float bc2ac2 = bc2 * ac2;\n    float abbc2ab2 = abbc2 / ab2;\n    float abac2ab2 = abac2 / ab2;\n    float bcac2bc2 = bcac2 / bc2;\n    float abbc2bc2 = abbc2 / bc2;\n    float abac2ac2 = abac2 / ac2;\n    float bcac2ab2 = bcac2 / ab2;\n    float abbc2ac2 = abbc2 / ac2;\n    float abac2bc2 = abac2 / bc2;\n    float bcac2abac = bcac2 / abac;\n    float abbc2abac = abbc2 / abac;\n    float abac2abbc = abac2 / abbc;\n    float bcac2abbc = bcac2 / abbc;\n    float abbc2bcac = abbc2 / bcac;\n    float abac2bcac = abac2 / bcac;\n    float bcac2ab2bc2 = bcac2 / ab2bc2;\n    float abac2ab2ac2 = abac2 / ab2ac2;\n    float bcac2bc2ac2 = bcac2 / bc2ac2;\n    float abbc2ab2bc2 = abbc2 / ab2bc2;\n    float abac2ab2ac2 = abac2 / ab2ac2;\n    float bcac", "\n    float d = 1000.0;\n    float t = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        float r = 0.0;\n        for (int j = 0; j < 10; j++)\n        {\n            float s = 1.0;\n            for (int k = 0; k < 10; k++)\n            {\n                float a = 0.0;\n                for (int l = 0; l < 10; l++)\n                {\n                    float b = 0.0;\n                    for (int m = 0; m < 10; m++)\n                    {\n                        float c = 0.0;\n                        for (int n = 0; n < 10; n++)\n                        {\n                            float d = 0.0;\n                            for (int o = 0; o < 10; o++)\n                            {\n                                float e = 0.0;\n                                for (int p = 0; p < 10; p++)\n                                {\n                                    float f = 0.0;\n                                    for (int q = 0; q < 10; q++)\n                                    {\n                                        float g = 0.0;\n                                        for (int r = 0; r < 10; r++)\n                                        {\n                                            float h = 0.0;\n                                            for (int s = 0; s < 10; s++)\n                                            {\n                                                float i = 0.0;\n                                                for (int t = 0; t < 10; t++)\n                                                {\n                                                    float j = 0.0;\n                                                    for (int u = 0; u < 10; u++)\n                                                    {\n                                                        float k = 0.0;\n                                                        for (int v = 0; v < 10; v++)\n                                                        {\n                                                            float l = 0.", "\n    vec3 ab = b - a;\n    return length(ab) * (1.0 + 0.5 * dot(ab, ab));\n}\n\n// K root\nfloat KBox(vec3 b)\n{\n    return 1.4426950408889634 * length(b);\n}\n\n// K root\nfloat KSphere(float r)\n{\n    return 2.0 * r;\n}\n\n// K root\nfloat KCapsule(float r, float h)\n{\n    return 2.0 * r + h;\n}\n\n// K root\nfloat KCone(float r, float h)\n{\n    return sqrt(r * r + h * h);\n}\n\n// K root\nfloat KCylinder(float r, float h)\n{\n    return sqrt(r * r + h * h);\n}\n\n// K root\nfloat KCone(float r, float h, float r2, float h2)\n{\n    return max(sqrt(r * r + h * h), sqrt(r2 * r2 + h2 * h2));\n}\n\n// K root\nfloat KCylinder(float r, float h, float r2, float h2)\n{\n    return max(sqrt(r * r + h * h), sqrt(r2 * r2 + h2 * h2));\n}\n\n// K root\nfloat KCone(float r, float h, float r2, float h2, float r3, float h3)\n{\n    return max(max(sqrt(r * r + h * h), sqrt(r2 * r2 + h2 * h2)), sqrt(r3 * r3 + h3 * h3));\n}\n\n// K root\nfloat KCylinder(float r, float h, float r2, float h2, float r3, float h3)\n{\n    return max(max(sqrt(r * r + h * h), sqrt(r2 * r2 + h2 * h2)), sqrt(r3 * r3 + h3 * h3));\n}\n\n// K root\nfloat KCone(float", "\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        Object(p + e.xyy) - Object(p - e.xyy),\n        Object(p + e.yxy) - Object(p - e.yxy),\n        Object(p + e.yyx) - Object(p - e.yyx)\n    ));\n}\n\n// Raymarching\nfloat Raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = Object(p);\n        if(d < 0.001) break;\n        t += d;\n    }\n    return t;\n}\n\n// Shading\nvec3 Shade(in vec3 ro, in vec3 rd, in float t)\n{\n    vec3 pos = ro + rd * t;\n    vec3 nor = ObjectNormal(pos);\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(0.5, 0.5, 0.5));\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    col += vec3(0.8, 0.6, 0.4) * dif;\n    return col;\n}\n\n// Camera\nvec3 Camera(in vec2 uv)\n{\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float t = Raymarch(ro, rd);\n    vec3 col = Shade(ro, rd, t);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3", "\n    float t = 0.0;\n    float r = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float m = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float c = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 q = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 m1 = vec3(0.0);\n    vec3 m2 = vec3(0.0);\n    vec3 m3 = vec3(0.0);\n    vec3 m4 = vec3(0.0);\n    vec3 m5 = vec3(0.0);\n    vec3 m6 = vec3(0.0);\n    vec3 m7 = vec3(0.0);\n    vec3 m8 = vec3(0.0);\n    vec3 m9 = vec3(0.0);\n    vec3 m10 = vec3(0.0);\n    vec3 m11 = vec3(0.0);\n    vec3 m12 = vec3(0.0);\n    vec3 m13 = vec3(0.0);\n    vec3 m14 = vec3(0.0);\n    vec3 m15 = vec3(0.0);\n    vec3 m16 = vec3(0.0);\n    vec3 m17 = vec3(0.0);\n    vec3 m18 = vec3(0.0);\n    vec3 m19 = vec3(0.0);\n    vec3 m20 = vec3(0.0);\n    vec3 m21 = vec3(0.0);\n    vec3", "\n    float t = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float m = 0.0;\n    float r = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float a = 0.0;\n    float l = 0.0;\n    float g = 0.0;\n    float f = 0.0;\n    float v = 0.0;\n    float n = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float tt = 0.0;\n    float tt2 = 0.0;\n    float tt3 = 0.0;\n    float tt4 = 0.0;\n    float tt5 = 0.0;\n    float tt6 = 0.0;\n    float tt7 = 0.0;\n    float tt8 = 0.0;\n    float tt9 = 0.0;\n    float tt10 = 0.0;\n    float tt11 = 0.0;\n    float tt12 = 0.0;\n    float tt13 = 0.0;\n    float tt14 = 0.0;\n    float tt15 = 0.0;\n    float tt16 = 0.0;\n    float tt17 = 0.0;\n    float tt18 = 0.0;\n    float tt19 = 0.0;\n    float tt20 = 0.0;\n    float tt21 = 0.0;\n    float tt22 = 0.0;\n    float tt23 = 0.0;\n    float", "\n    return vec3(0.0);\n}\n\nvec3 Sky(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Ground(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Light(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Material(vec3 rd, vec3 n, vec3 l, vec3 v)\n{\n    return vec3(0.0);\n}\n\n// Raytracing functions\nvec3 Raytrace(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float tmin = 1000000.0;\n    vec3 n = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 v = vec3(0.0);\n\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            n = Normal(p);\n            l = Light(p);\n            v = -rd;\n            col = Material(rd, n, l, v);\n            break;\n        }\n        t += d;\n        if (t > tmin)\n        {\n            col = Background(rd);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3((uv - 0.5) * 2.0, 1.0));\n    col = Raytrace(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n`;\n\nexport default fragmentShader;", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n// ------------------------------------------------------------------------\n\n// ------------------------------------------------------------------------\n// ------------------------", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n//----------------------------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*fBox( pos + e.xyy*t, t ) +\n\t\t\t\t\t  e.yyx*fBox( pos + e.yyx*t, t ) +\n\t\t\t\t\t  e.yxy*fBox( pos + e.yxy*t, t ) +\n\t\t\t\t\t  e.xxx*fBox( pos + e.xxx*t, t ) );\n}\n\n//----------------------------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 res = vec3(0.0);\n    float t = tmin;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = fBox( pos,", "\n  return coord / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution) {\n  return coord / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset) {\n  return (coord - offset) / resolution;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale) {\n  return (coord - offset) / resolution * scale;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation) {\n  return (coord - offset) / resolution * scale * rotation;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 translation) {\n  return (coord - offset) / resolution * scale * rotation + translation;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 translation, vec2 shear) {\n  return (coord - offset) / resolution * scale * rotation + translation * shear;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 translation, vec2 shear, vec2 skew) {\n  return (coord - offset) / resolution * scale * rotation + translation * shear + skew;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 translation, vec2 shear, vec2 skew, vec2 perspective) {\n  return (coord - offset) / resolution * scale * rotation + translation * shear + skew + perspective;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 resolution, vec2 offset, vec2 scale, vec2 rotation, vec2 translation, vec2 shear, vec2 skew, vec2 perspective, vec2 perspective_offset) {\n  return (coord - offset)", "\n    vec2  a = vec2(q.x,q.y-q.x);\n    vec2  b = vec2(q.x,q.y+q.x);\n    vec2  c = vec2(0.0,0.0);\n    vec2  d = vec2(p.x,p.y);\n    float s = 1.0-sign(a.x*d.y-a.y*d.x);\n    vec2  e = s*a + (1.0-s)*b;\n    vec2  f = s*b + (1.0-s)*c;\n    vec2  g = s*c + (1.0-s)*a;\n    vec2  h = s*d + (1.0-s)*e;\n    vec2  i = s*e + (1.0-s)*f;\n    vec2  j = s*f + (1.0-s)*g;\n    vec2  k = s*g + (1.0-s)*d;\n    vec2  l = s*h + (1.0-s)*i;\n    vec2  m = s*i + (1.0-s)*j;\n    vec2  n = s*j + (1.0-s)*k;\n    vec2  o = s*k + (1.0-s)*h;\n    vec2  p = s*l + (1.0-s)*m;\n    vec2  q = s*m + (1.0-s)*n;\n    vec2  r = s*n + (1.0-s)*o;\n    vec2  s = s*o + (1.0-s)*l;\n    vec2  t = s*p + (1.0-s)*q;\n    vec2  u = s*q + (1.0-s)*r;\n    vec2  v = s*r + (1.0-s)*s;\n    vec2  w = s*s + (1.0-s)*p;\n    vec2  x = s*t + (1.0-s)*u;\n    vec2", "\n    float a = r*r - d*d;\n    float b = 2.0*r*d;\n    float c = r*r + d*d;\n    float x = sqrt(a*a + b*b);\n    float y = sqrt(a*a + c*c);\n    float z = sqrt(b*b + c*c);\n    float rr = sqrt(x*x + y*y + z*z);\n    float rx = sqrt(x*x + y*y);\n    float ry = sqrt(x*x + z*z);\n    float rz = sqrt(y*y + z*z);\n    float rxy = sqrt(x*x + 1.0);\n    float ryz = sqrt(y*y + 1.0);\n    float rzx = sqrt(z*z + 1.0);\n    float rx2 = sqrt(x*x + 2.0);\n    float ry2 = sqrt(y*y + 2.0);\n    float rz2 = sqrt(z*z + 2.0);\n    float rxy2 = sqrt(x*x + 2.0);\n    float ryz2 = sqrt(y*y + 2.0);\n    float rzx2 = sqrt(z*z + 2.0);\n    float rxy3 = sqrt(x*x + 3.0);\n    float ryz3 = sqrt(y*y + 3.0);\n    float rzx3 = sqrt(z*z + 3.0);\n    float rxy4 = sqrt(x*x + 4.0);\n    float ryz4 = sqrt(y*y + 4.0);\n    float rzx4 = sqrt(z*z + 4.0);\n    float rxy5 = sqrt(x*x + 5.0);\n    float ryz5 = sqrt(y*y + 5.0);\n    float rzx5 = sqrt(z*z + 5.0);\n    float rxy6 = sqrt(x*x + 6.0);\n    float ryz6 = sqrt(y*y + 6.0);\n    ", "\n    vec2 q = p-c;\n    float a = atan(q.y,q.x);\n    float k = a/6.28318530718;\n    k = abs(abs(k)-.5);\n    k = clamp( k, 0.0, 1.0 );\n    float s = sign(q.x*c.y-q.y*c.x);\n    float d = length(q);\n    float d2 = length(vec2(d,k-0.5)*vec2(1.0,2.0));\n    return vec3( d2-r, a, s );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    vec2 q = p-c;\n    float a = atan(q.y,q.x);\n    float k = a/6.28318530718;\n    k = abs(abs(k)-.5);\n    k = clamp( k, 0.0, 1.0 );\n    float s = sign(q.x*c.y-q.y*c.x);\n    float d = length(q);\n    float d2 = length(vec2(d,k-0.5)*vec2(1.0,2.0));\n    return vec3( d2-r, a, s );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1", "\n    vec2  e[3] = vec2[3](v[0]-v[1], v[1]-v[2], v[2]-v[0]);\n    vec2  n[3] = vec2[3](normalize(vec2(-e[0].y,e[0].x)),\n                         normalize(vec2(-e[1].y,e[1].x)),\n                         normalize(vec2(-e[2].y,e[2].x)));\n    float d[3] = vec3(dot(n[0],v[0]), dot(n[1],v[1]), dot(n[2],v[2]));\n    vec2  w = p - v[2];\n    vec2  q = vec2(dot(e[0],w),dot(e[1],w));\n    vec2  r = vec2(dot(n[0],w),dot(n[1],w));\n    vec2  s = vec2(dot(e[0],e[1]),dot(e[1],e[2]));\n    vec2  t = (q-r*s)/(1.0-s*s);\n    float u = clamp(t.x,0.0,1.0);\n    float v = clamp(t.y,0.0,1.0);\n    float w = clamp(1.0-u-v,0.0,1.0);\n    float a = u+v+w;\n    float b = 1.0-a;\n    float dS = min(min(dot(n[0],p-v[0]),dot(n[1],p-v[1])),dot(n[2],p-v[2]));\n    float dT = length(t)*sign(a*dS);\n    vec2  g = b*v[0] + u*v[1] + v*v[2];\n    vec2  h = b*n[0] + u*n[1] + v*n[2];\n    return vec3", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float aa = a*a;\n    float raa = ra*ra;\n    float rba = rb*ra;\n    float rbb = rb*rb;\n    float rbaa = rba*rba;\n    float rbbaa = rbb*rbb;\n    float rbaa2 = rbaa*2.0;\n    float rbbaa2 = rbbaa*2.0;\n    float rbaa4 = rbaa*4.0;\n    float rbbaa4 = rbbaa*4.0;\n    float rbaa6 = rbaa*6.0;\n    float rbbaa6 = rbbaa*6.0;\n    float rbaa8 = rbaa*8.0;\n    float rbbaa8 = rbbaa*8.0;\n    float rbaa10 = rbaa*10.0;\n    float rbbaa10 = rbbaa*10.0;\n    float rbaa12 = rbaa*12.0;\n    float rbbaa12 = rbbaa*12.0;\n    float rbaa14 = rbaa*14.0;\n    float rbbaa14 = rbbaa*14.0;\n    float rbaa16 = rbaa*16.0;\n    float rbbaa16 = rbbaa*16.0;\n    float rbaa18 = rbaa*18.0;\n    float rbbaa18 = rbbaa*18.0;\n    float rbaa20 = rbaa*20.0;\n    float rbbaa20 = rbbaa*20.0;\n    float rbaa22 = rbaa*22.0;\n    float rbbaa22 = rbbaa*22.0;\n    float rbaa24 = rbaa*24.0;\n    float rbbaa24 = rbbaa*24.0;\n    float", " return a.x*b.y - a.y*b.x; }\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\n// ", "\n    p = p*ab;\n    vec2 q = p;\n    p = abs(p);\n    float l = length(p-vec2(0.5*ab.x,0.5*ab.y));\n    p = vec2( l, abs(p.y-0.5*ab.y) );\n    float m = min(p.x,p.y);\n    float n = max(p.x,p.y);\n    p = vec2( m, n );\n    float g = max(0.,sign(p.y-0.5*ab.y));\n    float h = max(0.,sign(p.x-0.5*ab.x));\n    float k = max(0.,sign(p.y-0.5*ab.y-0.5*ab.x+0.5*ab.y));\n    float s = max(0.,sign(p.x-0.5*ab.x-0.5*ab.y+0.5*ab.x));\n    float t = max(0.,sign(p.y-0.5*ab.y-0.5*ab.x-0.5*ab.y));\n    float u = max(0.,sign(p.x-0.5*ab.x+0.5*ab.y));\n    float v = max(0.,sign(p.y-0.5*ab.y+0.5*ab.x));\n    float w = max(0.,sign(p.x-0.5*ab.x+0.5*ab.y-0.5*ab.y));\n    float x = max(0.,sign(p.y-0.5*ab.y-0.5*ab.x+0.5*ab.y));\n    float y = max(0.,sign(p.x-0.5*ab.x-0.5*ab.y+0.5*ab.y));\n    float z = max(0.,sign(p.y-0.5*ab.y+0.5*ab.x-0.5*ab.y));\n    float", "\n  vec2 q = vec2(length(p.xz)-ra,p.y);\n  return vec4( length(q)-rb, q.x, q.y, 1.0 );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n  return vec4( length(p)-r, p, 1.0 );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return vec4(\n    length(max(q,0.0))\n    + min(max(q.x,max(q.y,q.z)),0.0),\n    normalize(q),\n    1.0 );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-r, abs(p.y)-h );\n  return vec4( max(d.x,d.y),\n               normalize(vec3(d.x,-sign(p.y),d.y)),\n               1.0 );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float r, float h )\n{\n  float q = length(p.xz);\n  vec2 d = vec2( max(q-r,0.0), abs(p.y)-h );\n  return vec", "\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec4( length(pa-ba*h) - r, ba*h );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return vec4(\n    length(max(q,0.0))\n    + min(max(q.x,max(q.y,q.z)),0.0),\n    sign(p)\n  );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n  return vec4( length(p) - r, p );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec4( length(q)-t.y, normalize(vec3(q,0.0)) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec2 h )\n{\n  vec2 d = vec2(length(p.xz)-h.x,p.y);\n  return vec4( max(d.x,-d.y), normalize(vec3(d.x,-1.0,d.y))", "\n    vec2 k1 = vec2(  wi,  sk );\n    vec2 k2 = vec2( -sk,  wi );\n    vec2 k3 = vec2(  wi, -sk );\n    vec2 k4 = vec2(  sk,  wi );\n\n    vec2 a = vec2( dot(p,k1), dot(p,k2) );\n    vec2 b = vec2( dot(p,k3), dot(p,k4) );\n\n    vec2 d = min( a, b );\n    d = min( d, -p );\n    d = max( d, vec2(0.0) );\n\n    return length(d);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 k1 = vec2(  wi,  sk );\n    vec2 k2 = vec2( -sk,  wi );\n    vec2 k3 = vec2(  wi, -sk );\n    vec2 k4 = vec2(  sk,  wi );\n\n    vec2 a = vec2( dot(p,k1), dot(p,k2) );\n    vec2 b = vec2( dot(p,k3), dot(p,k4) );\n\n    vec2 d = min( a, b );\n    d = min( d, -p );\n    d = max( d, vec2(0.0) );\n\n    return length(d);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    vec2 k1 = vec2(  wi,  sk );\n    vec2 k2 = vec2( -sk,  wi );\n    vec2 k3 = vec2(  wi, -sk );\n    vec2 k4 = vec2(  sk,  wi );\n\n    vec2 a = vec2( dot(p,k1), dot(p,", "\n    vec2  q = abs(p);\n    vec2  e = vec2(wi,he);\n    float d = length(max(q-e,0.0));\n    float s = max(q.x-e.y,q.y-e.x);\n    float t = max(q.x-e.x,q.y-e.y);\n    float w = max(q.y-e.x,q.x-e.y);\n    float h = max(q.y-e.y,q.x-e.x);\n    float r = max(s,max(t,max(w,h)));\n    float g = max(q.x-e.x,q.y-e.y);\n    float f = max(q.y-e.x,q.x-e.y);\n    float k = max(q.x-e.y,q.y-e.x);\n    float j = max(q.y-e.y,q.x-e.y);\n    float a = max(g,max(f,max(k,j)));\n    float b = max(s,max(t,max(w,h)));\n    float c = max(q.x-e.x,q.y-e.y);\n    float v = max(q.y-e.x,q.x-e.y);\n    float x = max(q.x-e.y,q.y-e.x);\n    float y = max(q.y-e.y,q.x-e.y);\n    float u = max(q.x-e.x,q.y-e.y);\n    float o = max(q.y-e.x,q.x-e.y);\n    float n = max(q.x-e.y,q.y-e.x);\n    float m = max(q.y-e.y,q.x-e.y);\n    float l = max(q.x-e.x,q.y-e.y);\n    float i = max(q.y-e.x,q.x-", "\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\tfor( int m = 0; m < p; m++ )\n\t\t\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor", "\n\treturn (a + b) / 2 - (a - b) * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n\treturn (a + b) / 2 + (a - b) * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float k) {\n\treturn (a + b + c) / 3 - (a - b) * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float k) {\n\treturn (a + b + c) / 3 + (a - b) * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float k) {\n\treturn (a + b + c + d) / 4 - (a - b) * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float k) {\n\treturn (a + b + c + d) / 4 + (a - b) * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float k) {\n\treturn (a + b + c + d + e) / 5 - (a - b) * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float k) {\n\treturn (a + b + c + d + e) / 5 + (a - b) * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float f, float k) {\n\treturn (a + b + c + d + e + f) / 6 - (a - b) * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float f, float", "\n    vec2 q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\nvec2 modn(inout vec2 p, float n) {\n    vec2 q = floor(p / n);\n    p = fract(p / n) * n;\n    return q;\n}\n\nvec2 mod289(inout vec2 p) {\n    vec2 q = floor(p / 289.0);\n    p = fract(p / 289.0) * 289.0;\n    return q;\n}\n\nvec3 mod289(inout vec3 p) {\n    vec3 q = floor(p / 289.0);\n    p = fract(p / 289.0) * 289.0;\n    return q;\n}\n\nvec4 mod289(inout vec4 p) {\n    vec4 q = floor(p / 289.0);\n    p = fract(p / 289.0) * 289.0;\n    return q;\n}\n\nvec2 mod76(inout vec2 p) {\n    vec2 q = floor(p / 76.0);\n    p = fract(p / 76.0) * 76.0;\n    return q;\n}\n\nvec3 mod76(inout vec3 p) {\n    vec3 q = floor(p / 76.0);\n    p = fract(p / 76.0) * 76.0;\n    return q;\n}\n\nvec4 mod76(inout vec4 p) {\n    vec4 q = floor(p / 76.0);\n    p = fract(p / 76.0) * 76.0;\n    return q;\n}\n\nvec2 mod128(inout vec2 p) {\n    vec2 q = floor(p / 128.0);\n    p = fract(p / 128.0) * 128.0;\n    return q;\n}\n\n", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsl(vec3 c) {\n    float l = (c.r + c.g + c.b) / 3.0;\n    float s = 0.0;\n    float d = max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n    if (d > 0.0) {\n        s = d / (1.0 - abs(2.0 * l - 1.0));\n    }\n    return vec3(rgb2hsv(c).x, s, l);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    return hsv2rgb(vec3(c.x, c.y, c.z *", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n    vec3 p = ro + rd*tN;\n    outNormal = vec3(p.x > boxSize.x? -1 : (p.x < -boxSize.x? 1 : 0),\n                     p.y > boxSize.y? -1 : (p.y < -boxSize.y? 1 : 0),\n                     p.z > boxSize.z? -1 : (p.z < -boxSize.z? 1 : 0) );\n    return vec2(tN, tF);\n}\n\n// IQ's ray sphere intersection\nfloat raySphere(vec3 ro, vec3 rd, vec3 pos, float rad) {\n    vec3 oc = ro - pos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec3 pos, vec3 nor) {\n    return dot(pos-ro, nor) / dot(rd, nor);\n}\n\n// IQ's ray triangle intersection\nfloat rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    ", "\n  vec2 e = abs(d);\n  vec2 s = sign(d);\n  vec2 q = abs(p);\n  vec2 r = e - q;\n  vec2 t = q - e;\n  vec2 u = vec2(e.x, t.y);\n  vec2 v = vec2(t.x, e.y);\n  vec2 w = vec2(r.x, t.y);\n  vec2 x = vec2(t.x, r.y);\n  vec2 y = vec2(r.x, r.y);\n  vec2 z = vec2(t.x, t.y);\n  vec2 a = vec2(e.x, e.y);\n  vec2 b = vec2(e.x, t.y);\n  vec2 c = vec2(t.x, e.y);\n  vec2 d = vec2(t.x, t.y);\n  vec2 e = vec2(r.x, e.y);\n  vec2 f = vec2(e.x, r.y);\n  vec2 g = vec2(t.x, r.y);\n  vec2 h = vec2(r.x, t.y);\n  vec2 i = vec2(r.x, r.y);\n  vec2 j = vec2(t.x, t.y);\n  vec2 k = vec2(t.x, r.y);\n  vec2 l = vec2(r.x, t.y);\n  vec2 m = vec2(r.x, r.y);\n  vec2 n = vec2(t.x, t.y);\n  vec2 o = vec2(t.x, r.y);\n  vec2 p = vec2(r.x, t.y);\n  vec2 q = vec2(r.x, r.y);\n  vec2 r = vec2(t.x, t.y);\n  vec2 s = vec2(t.x, r.y);\n  vec2 t = vec2(r.x, t.y);\n  vec2 u = vec2(r.x, r.y);\n  vec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec3 colour(vec2 p) {\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(1.0, 0.0);\n    vec2 c = vec2(1.0, 1.0);\n    vec2 d = vec2(0.0, 1.0);\n    float da = linedist(p, a, b);\n    float db = linedist(p, b, c);\n    float dc = linedist(p, c, d);\n    float dd = linedist(p, d, a);\n    float min = min(da, min(db, min(dc, dd)));\n    if (min == da) {\n        return vec3(1.0, 0.0, 0.0);\n    } else if (min == db) {\n        return vec3(0.0, 1.0, 0.0);\n    } else if (min == dc) {\n        return vec3(0.0, 0.0, 1.0);\n    } else {\n        return vec3(1.0, 1.0, 0.0);\n    }\n}\n\nvoid main() {\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    vec3 col = colour(p);\n    gl_FragColor = vec4(col, 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Square - Closest Edge';\n  }\n  sort() {\n    return 101;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1*h - w2*(1.0-h);\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  2D Line Segment\n//\n//----------------------------------------------------------------------------------------------------------------------\n\n// Returns the distance from a point p to a line segment a-b.\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Returns the distance from a point p to a line segment a-b.\n// The line segment is closed, so the distance is zero if p is\n// on the line segment.\nfloat sdClosedLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * (h*(2.0-h)-1.0);\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n//\n//  2D Line\n//\n//---------------------------------------------------------------------------------------------------", "\n    vec3 ca = ro - tor.y*vec3(0.0,1.0,0.0);\n    vec3 ta = normalize(vec3(0.0,1.0,0.0));\n    vec3 cp = vec3(ca.x,0.0,ca.z);\n    vec3 tp = vec3(0.0,1.0,0.0);\n    float h = length(ca.xz) - tor.x;\n    float l = length(ca);\n    float c = cos(tor.x);\n    float s = sin(tor.x);\n    float k = dot(ca,ca) - tor.x*tor.x;\n    float b = dot(rd,ca);\n    float det = b*b - dot(rd,rd)*k;\n    float t = -b - sqrt(det);\n    vec3  p = ro + t*rd;\n    vec3  q = p - tor.y*vec3(0.0,1.0,0.0);\n    float r = length(q.xz);\n    float ph = atan(q.z,q.x);\n    float th = atan(r,tor.y);\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCylinder(vec3 ro, vec3 rd, float r) {\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - b*b;\n    ", "\n  vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n  vec2 n = vec2(q.x/tor.x, 1.0);\n  float l = length(n);\n  n /= l;\n  return normalize(pos - n*tor.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q) - t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus(vec3 p, vec2 t, out vec3 n) {\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  float l = length(q);\n  n = vec3(q.x/t.x, 1.0, q.y)/l;\n  return l - t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus(vec3 p, vec2 t, out vec3 n, out vec3 c) {\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  float l = length(q);\n  n = vec3(q.x/t.x, 1.0, q.y)/l;\n  c = vec3(p.x, 0.0, p.z);\n  return l - t.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sdTorus(vec3 p, vec2 t", "\n    float x2 = x * x;\n    return x * (8.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx2(float x) {\n    float x2 = x * x;\n    return x * (1.0f - (1.0f / (1.0f + x2 + x2 * x2)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx3(float x) {\n    float x2 = x * x;\n    return x * (1.0f - (1.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx4(float x) {\n    float x2 = x * x;\n    return x * (1.0f - (1.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2 + x2 * x2 * x2 * x2)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx5(float x) {\n    float x2 = x * x;\n    return x * (1.0f - (1.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2 + x2 * x2 * x2 * x2 + x2 * x2 * x2 * x2 * x2)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx6(float x) {\n    float x2 = x * x;\n    return x * (1.0f - (1.0f / (1.0f + x2 + x2 * x2 + x2 * x2 * x2 + x2 * x2 * x2 * x2 + x2 * x2 * x2 * x2", "\n  col = pow(col, vec3(0.85));\n  col *= 1.05;\n  col = 1.0 - col;\n  col = 1.0 - pow(col, vec3(0.95));\n  col *= 0.95;\n  col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.05, abs(q.x)));\n  col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.05, abs(q.y)));\n  return col;\n}\n\nvoid main() {\n  vec2 q = gl_FragCoord.xy / resolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= resolution.x / resolution.y;\n  vec3 col = vec3(0.0);\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 rd = normalize(vec3(p, -1.5));\n  float t = 0.0;\n  for (int i = 0; i < 128; i++) {\n    vec3 pos = ro + t * rd;\n    float d = map(pos);\n    if (d < 0.001) {\n      col = vec3(1.0, 0.5, 0.0);\n      break;\n    }\n    t += d;\n  }\n  col = postProcess(col, q);\n  gl_FragColor = vec4(col, 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Raymarching - 3D';\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment", "\n    vec2 q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\nvec2 mod2(inout vec2 p, float size) {\n    return mod2(p, vec2(size));\n}\n\nvec2 mod2(vec2 p, vec2 size) {\n    vec2 q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\nvec2 mod2(vec2 p, float size) {\n    return mod2(p, vec2(size));\n}\n\nvec2 mod2(vec2 p, vec2 size, out vec2 q) {\n    q = floor(p / size);\n    p = fract(p / size) * size;\n    return q;\n}\n\nvec2 mod2(vec2 p, float size, out vec2 q) {\n    return mod2(p, vec2(size), q);\n}\n\nvec2 mod2(vec2 p, vec2 size, out float q) {\n    vec2 q2;\n    q = floor(p / size);\n    p = fract(p / size) * size;\n    return q2;\n}\n\nvec2 mod2(vec2 p, float size, out float q) {\n    return mod2(p, vec2(size), q);\n}\n\nvec2 mod2(vec2 p, vec2 size, out vec2 q, out float q2) {\n    q = floor(p / size);\n    p = fract(p / size) * size;\n    return q2;\n}\n\nvec2 mod2(vec2 p, float size, out vec2 q, out float q2) {\n    return mod2(p, vec2(size), q, q2);\n}\n\nvec2 mod2(vec2 p, vec2 size, out float q, out vec2 q2) {\n    q = floor(p / size);\n    p = fract(p / size) * size;\n    return q2;\n}\n\nvec2 mod2(vec2 p, float size, out float q, out vec2 q2) {\n", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; ++i) {\n        v += a * noise(uv);\n        uv = uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    uv.x *= 2.0;\n    uv.y *= 2.0;\n    float n = fbm(uv);\n    gl_FragColor = vec4(vec3(n), 1.0);\n}\n`;\n\nconst vertexShader = `\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nvarying vec2 vUv;\n\nuniform sampler2D uTexture;\nuniform float uTime;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec2 uv2 = uv;\n    uv2", "\n  return length(p-c)-r;\n}\n\n// signed distance to a ring\nfloat sdRing( in vec2 p, in vec2 c, in float r, in float w )\n{\n  return length(p-c)-r-w/2.0;\n}\n\n// signed distance to a square\nfloat sdSquare( in vec2 p, in vec2 c, in float s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 c, in float s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a hexagon\nfloat sdHexagon( in vec2 p, in vec2 c, in float s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a pentagon\nfloat sdPentagon( in vec2 p, in vec2 c, in float s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a star\nfloat sdStar( in vec2 p, in vec2 c, in float s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a polygon\nfloat sdPolygon( in vec2 p, in vec2 c, in float s, in int n )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n  return length(p-c)-r;\n}\n\n// signed distance to a rectangle\nfloat sdRectangle( in vec2 p, in vec2 c, in vec2 s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 c, in vec2 s )\n{\n  return length(p-c)-s;\n}\n\n// signed distance to a square\nfloat sdSquare( in vec2 p, in vec2 c, in vec2 s )\n{\n  return length(p-c)-s;", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance to a line segment\nfloat sdSegmentSigned( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign(pa.x*ba.y - pa.y*ba.x);\n}\n\n// signed distance to a line segment\nfloat sdSegmentSigned( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign(pa.x*ba.y - pa.y*ba.x);\n}\n\n// signed distance to a line segment\nfloat sdSegmentSigned( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign(pa.x*ba.y - pa.y*ba.x);\n}\n\n// signed distance to a line segment\nfloat sdSegmentSigned( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * sign(pa.x*ba.y - pa.y*ba.x);\n}\n\n// signed distance", "\n    return a.x*b.y-a.y*b.x;\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri2(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri3(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri4(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri5(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri6(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri7(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri8(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri9(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return cro(a-p, b-p)*cro(b-p, c-p);\n}\n\nfloat tri10(in vec2 p, in vec2 a, in vec2 b, in vec", "\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float t ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - t;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float t, in float t2 ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - t - t2;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float t, in float t2, in float t3 ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - t - t2 - t3;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float t, in float t2, in float t3, in float t4 ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - t - t2 - t3 - t4;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float t, in float t2, in float t3", "\n    const float a = 0.2;\n    const float b = 0.4;\n    const float c = 0.8;\n    const float d = 1.2;\n    return clamp((x * (a * x + c * b) + d * c) / (x * (a * x + b) + d * a), 0.0, 1.0);\n}\n\n// From: https://www.shadertoy.com/view/XdX3zr\nvec3 tone_map(vec3 color)\n{\n    const float exposure = 0.0;\n    const float gamma = 2.2;\n    const float white_point = 1.0;\n    const float white_point_squared = white_point * white_point;\n    const float white_point_cubed = white_point_squared * white_point;\n    const float white_point_to_the_fourth = white_point_cubed * white_point;\n    const float white_point_to_the_fifth = white_point_to_the_fourth * white_point;\n\n    vec3 color_with_exposure = color * pow(2.0, exposure);\n    vec3 color_with_gamma = pow(color_with_exposure, vec3(1.0 / gamma));\n    vec3 color_with_white_point = color_with_gamma / (color_with_gamma + vec3(1.0) / white_point_to_the_fifth);\n    vec3 color_with_white_point_squared = color_with_white_point * color_with_white_point;\n    vec3 color_with_white_point_cubed = color_with_white_point_squared * color_with_white_point;\n    vec3 color_with_white_point_to_the_fourth = color_with_white_point_cubed * color_with_white_point;\n    vec3 color_with_white_point_to_the_fifth = color_with_white_point_to_the_fourth * color_with_white_point;\n    vec3 color_with_white_point_to_", "\n    return 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nfloat s_curve(float x)\n{\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// derivative of s-curve\nfloat d_s_curve(float x)\n{\n    return 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nfloat s_curve(float x, float a, float b)\n{\n    return a * x * x * (3.0 - 2.0 * x) + b;\n}\n\n// derivative of s-curve\nfloat d_s_curve(float x, float a, float b)\n{\n    return a * 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec2 s_curve(vec2 x, float a, float b)\n{\n    return a * x * x * (3.0 - 2.0 * x) + b;\n}\n\n// derivative of s-curve\nvec2 d_s_curve(vec2 x, float a, float b)\n{\n    return a * 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec3 s_curve(vec3 x, float a, float b)\n{\n    return a * x * x * (3.0 - 2.0 * x) + b;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, float a, float b)\n{\n    return a * 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec4 s_curve(vec4 x, float a, float b)\n{\n    return a * x * x * (3.0 - 2.0 * x) + b;\n}\n\n// derivative of s-curve\nvec4 d_s_curve(vec4 x, float a, float b)\n{\n    return a * 3.0 * x * (1.0 - x);\n}\n\n// s-curve\nvec2 s_curve(vec2", "\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    float d = abs(mod(a,2.*k)-k)-.5;\n    return sqrt(d*d+r*r)/w;\n}\n\n//----------------------------------------------------------------------------------------\n// Spiral\n//----------------------------------------------------------------------------------------\n\n// p is the point\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec3 p, float w, in float k )\n{\n    float a = atan(p.x,p.z);\n    float r = length(p.xz);\n    float d = abs(mod(a,2.*k)-k)-.5;\n    return sqrt(d*d+r*r)/w;\n}\n\n//----------------------------------------------------------------------------------------\n// Spiral\n//----------------------------------------------------------------------------------------\n\n// p is the point\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec4 p, float w, in float k )\n{\n    float a = atan(p.x,p.z);\n    float r = length(p.xz);\n    float d = abs(mod(a,2.*k)-k)-.5;\n    return sqrt(d*d+r*r)/w;\n}\n\n//----------------------------------------------------------------------------------------\n// Spiral\n//----------------------------------------------------------------------------------------\n\n// p is the point\n// w is the width / distance from", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float wavelength)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float wavelength)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color, float exposure)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color, float exposure, float gamma)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color, float exposure, float gamma, float contrast)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color, float exposure, float gamma, float contrast, float brightness)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 wavelength, vec3 color, float exposure, float gamma, float contrast, float brightness, float saturation)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec", "\n    float opticalDepth = 0.0;\n    float opticalDepthDelta = 0.0;\n    vec3 scattering = vec3(0.0);\n    vec3 transmittanceTemp = vec3(1.0);\n    for (float t = 0.0; t < rayLength; t += opticalDepthDelta)\n    {\n        vec3 samplePoint = rayStart + rayDir * t;\n        vec3 samplePointToLight = lightDir - samplePoint;\n        float samplePointToLightLength = length(samplePointToLight);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCamera = -rayDir;\n        float samplePointToCameraLength = length(samplePointToCamera);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        vec3 samplePointToCameraDir = normalize(samplePointToCamera);\n        vec3 samplePointToLightDir = normalize(samplePointToLight);\n        ", "\n    vec3 p = p2;\n    p.xz = abs(p.xz);\n    p.xz = p.xz - 2.0*min(0.0, min(p.x, p.z));\n    float d2 = length(p);\n    float d3 = max(0.0, d2 - rb);\n    float d4 = max(0.0, length(p.xz - vec2(d,0.0)) - rb);\n    float d5 = max(0.0, length(p.xz - vec2(0.0,d)) - rb);\n    float d6 = max(0.0, length(p.xz - vec2(d,d)) - rb);\n    float d7 = max(0.0, length(p.xz - vec2(0.0,-d)) - rb);\n    float d8 = max(0.0, length(p.xz - vec2(-d,0.0)) - rb);\n    float d9 = max(0.0, length(p.xz - vec2(-d,-d)) - rb);\n    float d10 = max(0.0, length(p.xz - vec2(0.0,d)) - rb);\n    float d11 = max(0.0, length(p.xz - vec2(d,0.0)) - rb);\n    float d12 = max(0.0, length(p.xz - vec2(d,d)) - rb);\n    float d13 = max(0.0, length(p.xz - vec2(0.0,-d)) - rb);\n    float d14 = max(0.0, length(p.xz - vec2(-d,0.0)) - rb);\n    float d15 = max(0.0, length(p.xz - vec2(-d,-d)) - rb);\n    float d16 = max(0.0, length(p.xz - vec2(0.0,d)) - rb);\n    float d17 = max(0.0, length(p.xz - vec2(d,0.", "\n    float d = length(p) - r;\n    float d2 = length(p.xz) - r;\n    float d3 = length(p.xy) - r;\n    float d4 = length(p.yz) - r;\n    float d5 = length(p.xy - vec2(0.0, h)) - r;\n    float d6 = length(p.xz - vec2(0.0, h)) - r;\n    float d7 = length(p.yz - vec2(0.0, h)) - r;\n    float d8 = length(p.xy - vec2(h, 0.0)) - r;\n    float d9 = length(p.xz - vec2(h, 0.0)) - r;\n    float d10 = length(p.yz - vec2(h, 0.0)) - r;\n    float d11 = length(p.xy - vec2(0.0, -h)) - r;\n    float d12 = length(p.xz - vec2(0.0, -h)) - r;\n    float d13 = length(p.yz - vec2(0.0, -h)) - r;\n    float d14 = length(p.xy - vec2(-h, 0.0)) - r;\n    float d15 = length(p.xz - vec2(-h, 0.0)) - r;\n    float d16 = length(p.yz - vec2(-h, 0.0)) - r;\n    float d17 = length(p.xy - vec2(0.0, h)) - r - t;\n    float d18 = length(p.xz - vec2(0.0, h)) - r - t;\n    float d19 = length(p.yz - vec2(0.0, h)) - r - t;\n    float d20 = length(p.xy - vec2(h, 0.0)) - r - t;\n    float d21 = length(p.xz - vec2(h, 0.0)) - r - t;\n    float d22 = length(p.yz - vec", "\n    float res = 1.0;\n    float ph = 1e10; // precision holder\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*tmin );\n        if( h<0.001 ) return 0.0;\n        float d = h/ph;\n        res = min( res, k*d/ph );\n        ph = h;\n        tmin += h;\n        if( h<0.01 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ) +\n                      e.yyx*map( pos + e.yyx ) +\n                      e.yxy*map( pos + e.yxy ) +\n                      e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/fogvolumes\nfloat calcFog( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float res = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*tmin );\n        if( h<0.001 ) return 1.0;\n        res = max( res, h/tmin );\n        tmin += h;\n        if( h<0.01 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/shadows\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 1.0;\n    for( int i=0; i<6", "\n    float d = length(p) - r;\n    float s = p.y - h;\n    float k = d*d - s*s;\n    return k < 0.0? s : sqrt(k);\n}\n\n//----------------------------------------------------------------------------------------\n// Sphere\n//----------------------------------------------------------------------------------------\n\n// s is the sphere's position, r is the sphere's radius\nfloat sdSphere( in vec3 p, in vec3 s, in float r )\n{\n    return length(p-s) - r;\n}\n\n//----------------------------------------------------------------------------------------\n// Box\n//----------------------------------------------------------------------------------------\n\n// b is the box's position, r is the box's radius\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 q = abs(p-b) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//----------------------------------------------------------------------------------------\n// Cylinder\n//----------------------------------------------------------------------------------------\n\n// c is the cylinder's position, r is the cylinder's radius, h is the cylinder's height\nfloat sdCylinder( in vec3 p, in vec3 c, in float r, in float h )\n{\n    vec2 d = abs(vec2(length(p.xz-c.xz),p.y-c.y)) - vec2(r,h/2.0);\n    return min", "\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.005;\n    return normalize( e.xyy*f( pos + e.xyy ) +\n                      e.yyx*f( pos + e.yyx ) +\n                      e.yxy*f( pos + e.yxy ) +\n                      e.xxx*f( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/intersectors/\nfloat intersectRaySphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat intersectRayPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return -(dot(ro,pla.xyz)+pla.w)/dot(rd,pla.xyz);\n}\n\nfloat intersectRayBox( in vec3 ro, in vec3 rd, in vec3 box )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*box;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\nfloat intersectRayTorus( in vec3 ro, in vec3 rd, in vec4 tor )\n{\n    vec3 q = ro - tor.xyz;\n    float a = dot", "\n    vec2 q = vec2(length(p),p.y);\n    q.x = abs(q.x-r);\n    float d = length(max(vec2(0.0,h),q));\n    d = min(d,max(q.y,q.x-r));\n    return d;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Sphere\n//----------------------------------------------------------------------------------------\n\nfloat sdSphere( in vec2 p, in float s )\n{\n    return length(p)-s;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Box\n//----------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Capsule\n//----------------------------------------------------------------------------------------\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//------------------------------------------------------------------------------------", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n// 3d curl noise function\nvec3 curlnoise( in vec3 p )\n{\n    const float e =.1;\n    float n1 = noise(vec3(p.x, p.y, p.z));\n    float n2 = noise(vec3(p.x, p.y, p.z + e));\n    float n3 = noise(vec3(p.x, p.y + e, p.z));\n    float n4 = noise(vec3(p.x, p.y + e, p.z + e));\n    float n5 = noise(vec3(p.x + e, p.y, p.z));\n    float n6 = noise(vec3(p.x + e, p.y, p.z + e));\n    float n7 = noise(vec3(p.x + e, p.y + e, p.z));\n    float n8 = noise(vec3(p.x + e, p.y + e, p.z + e));\n    float x = n2 - n1 - n5 + n6;\n    float y = n4 - n1 - n7 + n2;\n    float z = n6 - n5 - n8 + n7;\n    const float divisor = 1.0 / ( 8.0 * e );\n    return vec3(x, y, z) * divisor;\n}\n\n// 3d curl noise function\nvec3 curlnoise( in vec3 p, in float t )\n{\n    const float e =.1;\n    float n1 = noise(vec", "\n    float f = 0.0;\n    float s = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += s*noise( p );\n        p = p*2.0 + vec3( 0.0, 0.0, 0.0 );\n        s *= 0.5;\n    }\n    return f;\n}\n\n// ----------------------------------------------------------------------------\n// main\n// ----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // time\n    float t = iTime * 0.5;\n\n    // 3d camera position\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\n\n    // 3d camera target\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n    // camera matrix\n    mat4 m = lookAt( ro, ta, vec3( 0.0, 1.0, 0.0 ) );\n\n    // create view ray\n    vec3 rd = normalize( m * vec4( 2.0*(uv - 0.5), 1.0, 1.0 ) ).xyz;\n\n    // ray marching\n    float d = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + rd*d;\n        d += 0.01*fbm( p );\n    }\n\n    // shading\n    vec3 col = vec3( 0.0 );\n    if( d < 100.0 )\n    {\n        vec3 p = ro + rd*d;\n        vec3 n = normal( p );\n        vec3 l = normalize( vec3( 0", "\n    float h = dot(p3, vec3(127.1, 311.7, 741.2));\n    return fract(sin(h) * 43758.5453123);\n}\n\n//value noise\nfloat noise(vec3 p3)\n{\n    vec3 p = floor(p3);\n    vec3 f = fract(p3);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(hash31(vec3(n + 0.0, n + 0.0, n + 0.0)), hash31(vec3(n + 1.0, n + 0.0, n + 0.0)), f.x),\n                   mix(hash31(vec3(n + 0.0, n + 1.0, n + 0.0)), hash31(vec3(n + 1.0, n + 1.0, n + 0.0)), f.x), f.y),\n              mix(mix(hash31(vec3(n + 0.0, n + 0.0, n + 1.0)), hash31(vec3(n + 1.0, n + 0.0, n + 1.0)), f.x),\n                   mix(hash31(vec3(n + 0.0, n + 1.0, n + 1.0)), hash31(vec3(n + 1.0, n + 1.0, n + 1.0)), f.x), f.y), f.z);\n}\n\n//fbm\nfloat fbm(vec3 p3)\n{\n    float f = 0.0;\n    float s = 0.5;\n    f += s * noise(p3);\n    s *= 0.5;\n    p3 *= 2.0", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n    uv2.x = fract(uv2.x);\n    uv2.y = fract(uv2.y);\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n    uv3.x += 0.5;\n    uv3.y += 0.5;\n    uv3.x = fract(uv3.x);\n    uv3.y = fract(uv3.y);\n    uv3.x += 0.5;\n    uv3.y += 0.5;\n    uv3.x = fract(uv3.x);\n    uv3.y = fract(uv3.y);\n    vec2 uv4 = fragCoord.xy / iResolution.xy;\n    uv4.x += 0.5;\n    uv4.y += 0.5;\n    uv4.x = fract(uv4.x);\n    uv4.y = fract(uv4.y);\n    uv4.x += 0.5;\n    uv4.y += 0.5;\n    uv4.x = fract(uv4.x);\n    uv4.y = fract(uv4.y);\n    uv4.x += 0.5;\n    uv4.y += 0.5;\n    uv4.x = fract(uv4.x);\n    uv4.y = fract(uv4.y);\n    vec2 uv5 = fragCoord.xy / iResolution.xy;\n    uv5.x += 0.5;\n    uv5.y += 0.5;\n    uv5.x = fract(uv5.x);\n    uv5.y = fract(uv5.y);\n    uv5.x += 0.5;\n    uv5.y += 0.5;\n    uv5.x = fract(uv5.x);\n    uv5.y = fract(uv5.y);\n    ", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsl(vec3 c) {\n    float h = rgb2hsv(c).x;\n    float s = 0.5 * (1.0 - 1.0 / (1.0 + rgb2hsv(c).z));\n    float l = 0.5 * (1.0 + rgb2hsv(c).z);\n    return vec3(h, s, l);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    return hsv2rgb(vec3(c.x, c.y / (1.0 - c.z), c.z + c.z * c.y));\n}\n\nvec3 rgb2lab(vec3 c) {\n    vec3 xyz =", "\n    float m = p % size;\n    if (m < 0.0) m += size;\n    p = m;\n    return m;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 h) {\n    float q = length(p.xz);\n    return dot(h, vec2(q, p.y));\n}\n\nfloat sdCone(vec3 p, vec2 h, float e) {\n    float q = length(p.xz);\n    return max(dot(h, vec2(q, p.y)), -q * e);\n}\n\nfloat sdCone(vec3 p, vec2 h, float e, float r) {\n    float q = length(p.xz);\n    return max(dot(h, vec2(q, p.y)), -q * e) - r;\n}\n\nfloat sdCone(vec3 p, vec2 h, float e, float r, float a) {\n    float q = length(p.xz);\n    return max(dot(h, vec2(q, p.y)), -q * e) - r * cos(a);\n}\n\nfloat sdCone(vec3 p, vec2 h, float e, float r, float a, float b) {\n    float q = length(p.xz);\n    return max(dot(h, vec2(q, p.y)), -q * e) - r * cos(a) - b;\n}\n\nfloat sdCone(vec3 p, vec2 h", "\n    return fract(sin(co*12.9898)*43758.5453);\n}\n\nfloat noise(float co) {\n    return mix(hash(floor(co)),\n               hash(floor(co)+1.0),\n               fract(co));\n}\n\nfloat fbm(float co) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 10; i++) {\n        v += a * noise(co);\n        co *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat pattern(float x, float y) {\n    return fbm(x*0.01 + fbm(y*0.01));\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    float p = pattern(uv.x, uv.y);\n    gl_FragColor = vec4(vec3(p), 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Noise - Fractal Brownian Motion';\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n  }\n  fragmentPrecision?(): string {\n    return PRECISION_MEDIUMP;\n  }\n  destory(): void {}\n  initial?(gl: WebGLRenderingContext, program: WebGLProgram): Function {\n    return () => {};\n  }\n}<|endoftext|>import { createCanvas, iSub, PRECISION_MEDIUMP, WEBGL_2 } from '../libs';\nimport * as webglUtils from '../webgl-utils';\n\nconst fragment =", "\n    return t < 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nfloat lRGB(float t) {\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec3 sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\nvec3 lRGB(vec3 t) {\n    return vec3(lRGB(t.r), lRGB(t.g), lRGB(t.b));\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = clamp(abs(mod(hsl.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return hsl.z + hsl.y * (rgb - 0.5) * (1.0 - abs(2.0 * hsl.z - 1.0));\n}\n\nvec3 rgb2hsl(vec3 rgb) {\n    float r = rgb.r, g = rgb.g, b = rgb.b;\n    float c_min = min(r, min(g, b));\n    float c_max = max(r, max(g, b));\n    float delta = c_max - c_min;\n    float h = 0.0, s = 0.0, l = (c_max + c_min) / 2.0;\n\n    if (delta > 0.0) {\n        if (c_max == r ) h = (g - b) / delta;\n        if (c_max == g ) h = (b - r) / delta + 2.0;\n        ", "\n    return pow(c, vec3(1.0/2.2));\n}\n\nvec3 RGB(in vec3 c) {\n    return pow(c, vec3(2.2));\n}\n\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, K.wz), vec4(c.zx, K.xy), (c.x < c.y));\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.yzx, p.w), (p.x < p.y));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsl2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsl(in vec", "\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(b, a, h) + k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmod(float x, float y) {\n    float q = floor(x/y);\n    return x - y * q;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmod(float x, float y, float k) {\n    float q = floor(x/y);\n    float f = abs(x - y * q);\n    float d = f - y;\n    float w = smoothstep(0.0, k, -d);\n    return mix(x, x - y * (q + 1.0), w);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmod(float x, float y, float k, float l) {\n    float q = floor(x/y);\n    float f = abs(x - y * q);\n    float d = f - y;\n    float w = smoothstep(0.0, k, -d);\n    float s = smoothstep(0.0, l, -d);\n    return mix(x, mix(x - y * (q + 1.0), x + y * (1.0 - q), s), w);\n}\n\n// License: MIT, author: Inigo Quilez, found", "\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > dbuffer) return -1.0;\n    if (t2 < dbuffer) return -1.0;\n    return min(t1, t2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat spherei(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > 0.0) return t1;\n    if (t2 > 0.0) return t2;\n    return -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphintersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (", "\n  float t = iTime * 0.1;\n  float s = 0.0;\n  float r = 0.0;\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float aa = 0.0;\n  float bb = 0.0;\n  float cc = 0.0;\n  float dd = 0.0;\n  float ee = 0.0;\n  float ff = 0.0;\n  float gg = 0.0;\n  float hh = 0.0;\n  float ii = 0.0;\n  float jj = 0.0;\n  float kk = 0.0;\n  float ll = 0.0;\n  float mm = 0.0;\n  float nn = 0.0;\n  float oo = 0.0;\n  float pp = 0.0;\n  float qq = 0.0;\n  float rr = 0.0;\n  float ss = 0.0;\n  float tt = 0.0;\n  float uu = 0", "\n  p = abs(p);\n  vec3 q = p - r;\n  float d = length(q);\n  float s = max(dot(q,r), 0.0);\n  return vec4( d, s, 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r )\n{\n  p = abs(p);\n  vec3 q = p - r;\n  float d = length(q);\n  float s = max(dot(q,r), 0.0);\n  return vec4( d, s, 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r )\n{\n  p = abs(p);\n  vec3 q = p - r;\n  float d = length(q);\n  float s = max(dot(q,r), 0.0);\n  return vec4( d, s, 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw =", "\n    vec4 res = front + back * (1.0 - front.a);\n    res.a = front.a + back.a * (1.0 - front.a);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    vec4 res = front + back * (1.0 - front.a * alpha);\n    res.a = front.a * alpha + back.a * (1.0 - front.a * alpha);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n    vec4 res = front + back * (1.0 - front.a * alpha);\n    res.a = front.a * alpha + back.a * (1.0 - front.a * alpha);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, float alpha2) {\n    vec4 res = front + back * (1.0 - front.a * alpha * alpha2);\n    res.a = front.a * alpha * alpha2 + back.a * (1.0 - front.a * alpha * alpha2);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2) {\n    vec4 res = front + back * (1.0 - front.a * alpha * alpha2);\n    res.a = front.a * alpha * alpha2 + back.a * (1.0 - front.a * alpha * alpha2);\n    return res;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, float alpha3) {\n    vec4 res = front + back * (1.0 - front.a * alpha * alpha2", "\n    return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return alpha * front + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return alphaBlend(back, front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front, float alpha) {\n    return alphaBlend(back, front.rgb, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n    return alphaBlend(back, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec4 front) {\n    return alphaBlend(back.rgb, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front, float alpha) {\n    return alphaBlend(back.rgb, front, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec3 front) {\n    return alphaBlend(back.rgb, front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return alphaBlend(back.rgb, front.rgb, alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec4 back, vec4 front) {\n    return alphaBlend(back.rgb, front.rgb, front.a);\n}\n\n// License: Unknown,", "\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex2(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex3(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex4(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex5(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex6(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex7(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.x,p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex8(vec2 p, float r ) {\n    p = abs(p);\n    return max(p.", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx2(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx3(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx4(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx5(vec3 v) {\n    return v / (1.0 + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; i++) {\n        v += a * noise(p);\n        p = p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm2(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2", "\n    vec3 col = vec3(pow(Temp, 4.0)) * vec3(3.6621810e-13, 1.5873000e-10, 1.0100900e-07);\n    return col;\n}\n\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0)),\n                   dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),\n               mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0)),\n                   dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; ++i) {\n        v += a * noise(p);\n        p = p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat pattern(vec2 p) {\n    return fbm(p * 0.01);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 color = vec3(pattern(uv * 100.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return 'XslGRr';\n  }\n  name(): string {\n    return 'Noise - 2D - fractal Brownian motion';\n  }\n  sort() {\n    return 100;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec4 sph) {\n    return length(p - sph.xyz) - sph.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec3 sph) {\n    return length(p - sph.xyz) - sph.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec3 sph, float s) {\n    return length(p - sph.xyz) - sph.w * s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec3 sph, float s, float t) {\n    return length(p - sph.xyz) - sph.w * s * t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec3 sph, float s, float t, float r) {", "\n    vec2 q = abs(p);\n    float d = length(q) - 1.0;\n    float a = max(q.x, q.y);\n    float b = min(q.x, q.y);\n    float c = sqrt(a*a - b*b);\n    float d1 = a - c;\n    float d2 = a + c;\n    float d3 = a - b;\n    float d4 = a + b;\n    float d5 = d1 - d2;\n    float d6 = d3 - d4;\n    float d7 = d1 - d4;\n    float d8 = d3 - d2;\n    float d9 = d5 - d6;\n    float d10 = d7 - d8;\n    float d11 = d5 - d8;\n    float d12 = d7 - d6;\n    float d13 = d9 - d10;\n    float d14 = d11 - d12;\n    float d15 = d13 - d14;\n    float d16 = d15 - d15;\n    float d17 = d16 - d16;\n    float d18 = d17 - d17;\n    float d19 = d18 - d18;\n    float d20 = d19 - d19;\n    float d21 = d20 - d20;\n    float d22 = d21 - d21;\n    float d23 = d22 - d22;\n    float d24 = d23 - d23;\n    float d25 = d24 - d24;\n    float d26 = d25 - d25;\n    float d27 = d26 - d26;\n    float d28 = d27 - d27;\n    float d29 = d28 - d28;\n    float d30 = d29 - d29;\n    float d31 = d30 - d30;\n    float d32 = d31 - d31;\n    float d", "\n\tfloat y = 0.0;\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat aa = 1.0;\n\tfloat bb = 1.0;\n\tfloat cc = 1.0;\n\tfloat dd = 1.0;\n\tfloat ee = 1.0;\n\tfloat ff = 1.0;\n\tfloat gg = 1.0;\n\tfloat hh = 1.0;\n\tfloat ii = 1.0;\n\tfloat jj = 1.0;\n\tfloat kk = 1.0;\n\tfloat ll = 1.0;\n\tfloat mm = 1.0;\n\tfloat nn = 1.0;\n\tfloat oo = 1.0;\n\tfloat pp = 1.0;\n\tfloat qq = 1.0;\n\tfloat rr = 1.0;\n\tfloat ss = 1.0;\n\tfloat uu = 1.0;\n\tfloat vv = 1.0;\n\tfloat ww = 1.0;\n\tfloat xx = 1.0;\n\tfloat yy = 1.", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 e;\n    e.x = dot( b-a, b-a );\n    e.y = dot( c-b, c-b );\n    e.z = dot( a-c, a-c );\n\n    vec3 i = vec3( -1.0 );\n\n    vec2 uv = a-p;\n    if( dot(uv,b-a)>=0.0 && dot(uv,c-a)<=0.0 )\n    {\n        float v = clamp( dot(uv,uv)/e.x, 0.0, 1.0 );\n        i.xy = mix( a, b, v );\n        i.z = length( p - i.xy );\n    }\n    uv = b-p;\n    if( dot(uv,c-b)>=0.0 && dot(uv,a-b)<=0.0 )\n    {\n        float v = clamp( dot(uv,uv)/e.y, 0.0, 1.0 );\n        i.xy = mix( b, c, v );\n        i.z = length( p - i.xy );\n    }\n    uv = c-p;\n    if( dot(uv,a-c)>=0.0 && dot(uv,b-c)<=0.0 )\n    {\n        float v = clamp( dot(uv,uv)/e.z", "\n    float d = 0.;\n    float t = 0.;\n    float s = 0.;\n    float r = 0.;\n    float a = 0.;\n    float b = 0.;\n    float c = 0.;\n    float e = 0.;\n    float f = 0.;\n    float g = 0.;\n    float h = 0.;\n    float i = 0.;\n    float j = 0.;\n    float k = 0.;\n    float l = 0.;\n    float m = 0.;\n    float n = 0.;\n    float o = 0.;\n    float p1 = 0.;\n    float q = 0.;\n    float r1 = 0.;\n    float s1 = 0.;\n    float t1 = 0.;\n    float u = 0.;\n    float v = 0.;\n    float w = 0.;\n    float x = 0.;\n    float y = 0.;\n    float z = 0.;\n    float a1 = 0.;\n    float b1 = 0.;\n    float c1 = 0.;\n    float d1 = 0.;\n    float e1 = 0.;\n    float f1 = 0.;\n    float g1 = 0.;\n    float h1 = 0.;\n    float i1 = 0.;\n    float j1 = 0.;\n    float k1 = 0.;\n    float l1 = 0.;\n    float m1 = 0.;\n    float n1 = 0.;\n    float o1 = 0.;\n    float p2 = 0.;\n    float q1 = 0.;\n    float r2 = 0.;\n    float s2 = 0.;\n    float t2 = 0.;\n    float u1 = 0.;\n    float v1 = 0.;\n    float w1 = 0.;\n    float x1 = 0.;\n    float y1 = ", "\n    float z = x + y;\n    return 0.15 * z * z * (1.0 / (z * z + 0.4)) - 0.5 * y;\n}\n\nfloat atan_approx(float y_over_x) {\n    return atan_approx(y_over_x, 1.0);\n}\n\nfloat atan2_approx(float y, float x) {\n    float a = atan_approx(y, x);\n    return x < 0.0? (a + 3.14159265) : a;\n}\n\nfloat atan2_approx(float y, float x, float center_x, float center_y) {\n    return atan2_approx(y - center_y, x - center_x);\n}\n\nfloat atan2_approx(float y, float x, vec2 center) {\n    return atan2_approx(y, x, center.x, center.y);\n}\n\nfloat atan2_approx(vec2 p, vec2 center) {\n    return atan2_approx(p.y, p.x, center.x, center.y);\n}\n\nfloat atan2_approx(vec2 p) {\n    return atan2_approx(p.y, p.x);\n}\n\nfloat atan2_approx(vec2 p, float center_x, float center_y) {\n    return atan2_approx(p.y, p.x, center_x, center_y);\n}\n\nfloat atan2_approx(vec2 p, vec2 center) {\n    return atan2_approx(p.y, p.x, center.x, center.y);\n}\n\nfloat atan2_approx(vec2 p, float center_x, float center_y, float scale) {\n    return atan2_approx(p.y, p.x, center_x, center_y) * scale;\n}\n\nfloat atan2_approx(vec2 p, vec2 center, float scale) {\n    return atan2_approx(p.y, p.x, center.x, center.", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / dot(w, w);\n}\n\nvec2 csqrt(vec2 z) {\n    float r = sqrt(length(z));\n    return vec2(r * cos(atan(z.y, z.x) / 2.0), r * sin(atan(z.y, z.x) / 2.0));\n}\n\nvec2 cpow(vec2 z, float p) {\n    float r = length(z);\n    return vec2(r * cos(atan(z.y, z.x) * p), r * sin(atan(z.y, z.x) * p));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    float r = length(z);\n    return vec2(r * cos(atan(z.y, z.x) * w.x - w.y * log(r)), r * sin(atan(z.y, z.x) * w.x - w.y * log(r)));\n}\n\nvec2 cexp(vec2 z) {\n    float r = exp(z.x);\n    return vec2(r * cos(z.y), r * sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.", "\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic cotangent\nvec2 ccotanh(vec2 z) {\n    return 0.5 * log((z + 1.0) / (z - 1.0));\n}\n\n// Inverse hyperbolic secant\nvec2 csech(vec2 z) {\n    return 0.5 * log((1.0 + 1.0 / z) / (1.0 - 1.0 / z));\n}\n\n// Inverse hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 0.5 * log((z + 1.0 / z) / (z - 1.0 / z));\n}\n\n// Inverse hyperbolic sine\nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosine\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic tangent\nvec2 catanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic cotangent\nvec2 ccotanh(vec2 z) {\n    return 0.5 * log((z + 1.0) / (z - 1.0));\n}\n\n// Inverse hyperbolic secant\nvec2 csech(vec2 z) {\n    return 0.5 * log((1.0 + 1.0 / z) / (1.0 - 1.0 / z));\n}\n\n// Inverse hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 0.5 * log((z + 1.0 / z) / (z - 1.0 / z));\n}\n\n// Inverse hyperbolic sine\nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return cdiv(cexp(z) - cexp(-z), cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 -", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / dot(w, w); }\nvec2 csqrt(vec2 z) { return vec2(sqrt(length(z) + z.x), sign(z.y) * sqrt(abs(z.y))) * vec2(1.0, 1.0) / sqrt(2.0); }\nvec2 cpow(vec2 z, vec2 w) { return csqrt(cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), z))) * vec2(1.0, 1.0) / csqrt(cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), z))); }\nvec2 ctanh(vec2 z) { return cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, 0.0), cdiv(vec2(1.0, ", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return cdiv(cexp(z) - cexp(-z), cexp(z) + cexp(-z));\n}\n\nvec2 ctanh_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 - z * z)), 2.0);\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(exp(z) - exp(-z), exp(z) + exp(-z));\n}\n\nvec2 ctanh_inv_inv_inv_inv_inv_inv_inv_inv_inv(vec2 z) {\n    return cdiv(log(z + sqrt(1.0 -", "\n  float a = alpha.r;\n  float b = alpha.g;\n  float c = alpha.b;\n  float d = alpha.a;\n  float sum = a + b + c + d;\n  float a_ = a / sum;\n  float b_ = b / sum;\n  float c_ = c / sum;\n  float d_ = d / sum;\n  float a__ = pow(a_, contrast);\n  float b__ = pow(b_, contrast);\n  float c__ = pow(c_, contrast);\n  float d__ = pow(d_, contrast);\n  float sum__ = a__ + b__ + c__ + d__;\n  return vec4(\n    a__ / sum__,\n    b__ / sum__,\n    c__ / sum__,\n    d__ / sum__\n  );\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel(vec2 position) {\n  vec2 uv = position / resolution;\n  return texture2D(image, uv);\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel(vec2 position, float scale) {\n  vec2 uv = position / resolution;\n  return texture2D(image, uv * scale);\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel(vec2 position, float scale, float offset) {\n  vec2 uv = position / resolution;\n  return texture2D(image, uv * scale + offset);\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel(vec2 position, float scale, float offset, float rotation) {\n  vec2 uv = position / resolution;\n  return texture2D(image, uv * scale + offset * rotation);\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel(vec2 position, float scale, float offset, float rotation, float contrast) {\n  vec2 uv = position / resolution;\n  return texture2D(image, uv * scale + offset * rotation);\n}\n\n// Returns the color of the pixel at the given position\nvec4 getPixel", "\n    vec3 q = abs(p);\n    float d1 = max(q.x, max(q.y, q.z));\n    float d2 = min(q.x, min(q.y, q.z));\n    float d3 = q.x + q.y + q.z - d1 - d2;\n    return max(d1 - 1.0, max(d2 - 1.0, d3 - 1.0));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) {\n    vec3 q = abs(p);\n    float d1 = max(q.x, max(q.y, q.z));\n    float d2 = min(q.x, min(q.y, q.z));\n    float d3 = q.x + q.y + q.z - d1 - d2;\n    return max(d1 - 1.0, max(d2 - 1.0, d3 - 1.0));\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {\n    vec3 q = abs(p);\n    float d1 = max(q.x, max(q.y, q.z));\n    float d2 = min(q.x, min(q.y, q.z));\n    float d3 = q.x + q.y + q.z - d1 - d2;\n    return max(d1 - 1.0, max(d2 - 1.0, d3 - 1.0));\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    vec3 q = abs(p);\n    float d1 = max(q.x, max(q.y, q.z));\n    float d2 = min(q.x, min(q.y, q.z));\n    float d3 = q.x + q.y + q.z - d1 - d2;\n    return max(d1 - 1.0, max(d2 - 1.0, d3 - 1.0));\n}\n\n", "\n  vec3 uv = uvw.xy;\n  vec3 vw = uvw.yz;\n  vec3 wu = uvw.zw;\n  vec3 u = uvw.xyz;\n  vec3 v = uvw.yzx;\n  vec3 w = uvw.zxy;\n  vec3 r = uvw.wzy;\n  vec3 s = uvw.zyx;\n  vec3 t = uvw.yxw;\n  vec3 uv2 = uv * 2.;\n  vec3 vw2 = vw * 2.;\n  vec3 wu2 = wu * 2.;\n  vec3 u2 = u * 2.;\n  vec3 v2 = v * 2.;\n  vec3 w2 = w * 2.;\n  vec3 r2 = r * 2.;\n  vec3 s2 = s * 2.;\n  vec3 t2 = t * 2.;\n  vec3 uv3 = uv * 3.;\n  vec3 vw3 = vw * 3.;\n  vec3 wu3 = wu * 3.;\n  vec3 u3 = u * 3.;\n  vec3 v3 = v * 3.;\n  vec3 w3 = w * 3.;\n  vec3 r3 = r * 3.;\n  vec3 s3 = s * 3.;\n  vec3 t3 = t * 3.;\n  vec3 uv4 = uv * 4.;\n  vec3 vw4 = vw * 4.;\n  vec3 wu4 = wu * 4.;\n  vec3 u4 = u * 4.;\n  vec3 v4 = v * 4.;\n  vec3 w4 = w * 4.;\n  vec3 r4 = r * 4.;\n  vec3 s4 = s * 4.;\n  vec3 t4 = t * 4.;\n  vec3 uv5 = uv * 5.;\n  vec3 vw5 = vw * 5.;\n  vec3 wu", "\n  vec3 uv = uvw.xy;\n  vec3 vw = uvw.yz;\n  vec3 wu = uvw.zw;\n  vec3 u = uvw.xyz;\n  vec3 v = uvw.yzx;\n  vec3 w = uvw.zxy;\n  vec3 r = uvw.xzy;\n  vec3 s = uvw.yxz;\n  vec3 t = uvw.zyx;\n  vec3 uv2 = uvw.xy + uvw.yz;\n  vec3 vw2 = uvw.yz + uvw.zw;\n  vec3 wu2 = uvw.zw + uvw.xyz;\n  vec3 u2 = uvw.xyz + uvw.xyz;\n  vec3 v2 = uvw.yzx + uvw.yzx;\n  vec3 w2 = uvw.zxy + uvw.zxy;\n  vec3 r2 = uvw.xzy + uvw.xzy;\n  vec3 s2 = uvw.yxz + uvw.yxz;\n  vec3 t2 = uvw.zyx + uvw.zyx;\n  vec3 uv3 = uvw.xy + uvw.yz + uvw.zw;\n  vec3 vw3 = uvw.yz + uvw.zw + uvw.xyz;\n  vec3 wu3 = uvw.zw + uvw.xyz + uvw.yz;\n  vec3 u3 = uvw.xyz + uvw.xyz + uvw.xyz;\n  vec3 v3 = uvw.yzx + uvw.yzx + uvw.yzx;\n  vec3 w3 = uvw.zxy + uvw.zxy + uvw.zxy;\n  vec3 r3 = uvw.xzy + uvw.xzy + uvw.xzy;\n  vec3 s3 = uvw.yxz + uvw.yxz + uvw.yxz;\n  vec3 t3 = uvw.zyx + uvw.zyx + uvw.zyx;\n  vec3 uv4 = uvw.xy + uvw.yz + uvw.zw +", "\n    vec3 uv = uvw.xy;\n    vec3 w = uvw.z;\n    vec3 uv2 = uv * 2.0;\n    vec3 uv3 = uv * 3.0;\n    vec3 uv4 = uv * 4.0;\n    vec3 uv5 = uv * 5.0;\n    vec3 uv6 = uv * 6.0;\n    vec3 uv7 = uv * 7.0;\n    vec3 uv8 = uv * 8.0;\n    vec3 uv9 = uv * 9.0;\n    vec3 uv10 = uv * 10.0;\n    vec3 uv11 = uv * 11.0;\n    vec3 uv12 = uv * 12.0;\n    vec3 uv13 = uv * 13.0;\n    vec3 uv14 = uv * 14.0;\n    vec3 uv15 = uv * 15.0;\n    vec3 uv16 = uv * 16.0;\n    vec3 uv17 = uv * 17.0;\n    vec3 uv18 = uv * 18.0;\n    vec3 uv19 = uv * 19.0;\n    vec3 uv20 = uv * 20.0;\n    vec3 uv21 = uv * 21.0;\n    vec3 uv22 = uv * 22.0;\n    vec3 uv23 = uv * 23.0;\n    vec3 uv24 = uv * 24.0;\n    vec3 uv25 = uv * 25.0;\n    vec3 uv26 = uv * 26.0;\n    vec3 uv27 = uv * 27.0;\n    vec3 uv28 = uv * 28.0;\n    vec3 uv29 = uv * 29.0;\n", "\n    float d = length(p);\n    float a = 1.0 / cos(radians(36.0));\n    float r = a * sqrt(3.0);\n    float s = r / 2.0;\n    float t = s / tan(radians(36.0));\n    float u = t / 2.0;\n    float v = sqrt(u * u + t * t);\n    float w = v - u;\n    float x = w / sqrt(2.0);\n    float y = x / cos(radians(36.0));\n    float z = y / tan(radians(36.0));\n    float e = z / 2.0;\n    float f = e / cos(radians(36.0));\n    float g = f / 2.0;\n    float h = g / cos(radians(36.0));\n    float i = h / 2.0;\n    float j = i / cos(radians(36.0));\n    float k = j / 2.0;\n    float l = k / cos(radians(36.0));\n    float m = l / 2.0;\n    float n = m / cos(radians(36.0));\n    float o = n / 2.0;\n    float p1 = o / cos(radians(36.0));\n    float q = p1 / 2.0;\n    float r1 = q / cos(radians(36.0));\n    float s1 = r1 / 2.0;\n    float t1 = s1 / cos(radians(36.0));\n    float u1 = t1 / 2.0;\n    float v1 = u1 / cos(radians(36.0));\n    float w1 = v1 / 2.0;\n    float x1 = w1 / cos(radians(36.0));\n    float y1 = x1 / 2.0;\n    float z1 = y1 / cos(radians(36.0));\n    float a1 = z1 / 2.0;\n    float b = a", "\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0.2, t));\n}\n\n// makes a colormap with a polynomial of 6\nvec3 Poly6(float t) {\n    return vec3(smoothstep(0.0, 0.2, t),\n                smoothstep(0.0, 0", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    s = sin(a.y);\n    c = cos(a.y);\n    m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    s = sin(a.z);\n    c = cos(a.z);\n    m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    v = m * v;\n    return v;\n}\n\n// returns a random number between 0 and 1\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// returns a random number between 0 and 1\nfloat rand(float co)\n{\n    return fract(sin(co) * 43758.5453);\n}\n\n// returns a random number between 0 and 1\nfloat rand(float co, float seed)\n{\n    return fract(sin(co + seed) * 43758.5453);\n}\n\n// returns a random number between 0 and 1\nfloat rand(vec2 co, float seed)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)) + seed) * 43758.5453);\n}\n\n// returns a random number between 0 and 1\nfloat rand(vec3 co, float seed)\n{\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 12.9898)) + seed) * 43758.545", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 co) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; i++) {\n        v += a * noise(co);\n        co = co * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm2(vec2 co) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; i++) {\n        v += a * noise(co);\n        co = co * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm3(vec2 co) {\n    float v = 0.0;\n    float a = 0", "\n  vec2 k = abs(p);\n  return max(k.x, (k.y + (k.x * 0.5)));\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * 0.3, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g, float a) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g, float a, float s) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g, float a, float s, float o) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g, float a, float s, float o, float e) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float r, float g, float a, float s, float o, float e, float f) {\n  float d = hexDist(p) - r;\n  return 1.0 - smoothstep(0.0, r * g, d);\n}\n\n// Hexagonal Grid\nfloat hexGrid(vec2 p, float", "\n    vec2 q = vec2(uv.x, uv.y + uv.x / 2.0);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 g = mod(i, 2.0);\n    vec2 r = mod(i, 3.0);\n    vec2 s = mod(i, 4.0);\n    vec2 t = mod(i, 5.0);\n    vec2 u = mod(i, 6.0);\n    vec2 v = mod(i, 7.0);\n    vec2 w = mod(i, 8.0);\n    vec2 x = mod(i, 9.0);\n    vec2 y = mod(i, 10.0);\n    vec2 z = mod(i, 11.0);\n    vec2 a = mod(i, 12.0);\n    vec2 b = mod(i, 13.0);\n    vec2 c = mod(i, 14.0);\n    vec2 d = mod(i, 15.0);\n    vec2 e = mod(i, 16.0);\n    vec2 f = mod(i, 17.0);\n    vec2 g = mod(i, 18.0);\n    vec2 h = mod(i, 19.0);\n    vec2 i = mod(i, 20.0);\n    vec2 j = mod(i, 21.0);\n    vec2 k = mod(i, 22.0);\n    vec2 l = mod(i, 23.0);\n    vec2 m = mod(i, 24.0);\n    vec2 n = mod(i, 25.0);\n    vec2 o = mod(i, 26.0);\n    vec2 p = mod(i, 27.0);\n    vec2 q = mod(i, 28.0);\n    vec2 r = mod(i, 29.0);\n    vec2 s = mod(i, 30.0);\n    vec2 t = mod(", "\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = vec3(0.0);\n    c += 0.2141 * pow(t, 6.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.4129 * pow(t, 5.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.5979 * pow(t, 4.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.7045 * pow(t, 3.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.7691 * pow(t, 2.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.7934 * pow(t, 1.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.7934 * pow(t, 0.0) * vec3(0.3776, 0.4331, 0.4545);\n    return c;\n}\n\n// makes plasma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 plasma(float t) {\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = vec3(0.0);\n    c += 0.2141 * pow(t, 6.0) * vec3(0.3776, 0.4331, 0.4545);\n    c += 0.4129 * pow(t, ", "\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n\treturn (x * 2) - 1;\n}\n\n//returns a random float between -1 and 1\nfloat randomFloat() {\n\treturn makeNeg1to1(random());\n}\n\n//returns a random float between 0 and 1\nfloat random0to1() {\n\treturn random();\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max) {\n\treturn min + (max - min) * random();\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed) {\n\treturn min + (max - min) * random(seed);\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed, float seed2) {\n\treturn min + (max - min) * random(seed, seed2);\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed, float seed2, float seed3) {\n\treturn min + (max - min) * random(seed, seed2, seed3);\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed, float seed2, float seed3, float seed4) {\n\treturn min + (max - min) * random(seed, seed2, seed3, seed4);\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed, float seed2, float seed3, float seed4, float seed5) {\n\treturn min + (max - min) * random(seed, seed2, seed3, seed4, seed5);\n}\n\n//returns a random float between min and max\nfloat randomMinMax(float min, float max, float seed, float seed2, float seed3, float seed4, float seed5, float seed6) {\n\treturn min + (max - min) * random(seed,", "\n    vec2 p = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    float d = 1.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash2(p + g + offset);\n            vec2 r = g + o - f;\n            float l = length(r);\n            float n = smoothstep(0.0, 1.0, 1.0 - abs(l - 0.5));\n            d = min(d, n);\n        }\n    }\n    return d;\n}\n\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float d = 1.0;\n    for (int i = 0; i < 3; i++) {\n        float t = time * 0.1 + float(i) * 0.1;\n        float l = float(i) * 0.1 + len;\n        d = min(d, flowHexCell(uv, offset, gridRes, t, l));\n    }\n    return d;\n}\n\nvec3 flowHexColor(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float d = flowHex(uv, offset, gridRes, time, len);\n    return vec3(d);\n}\n\nvec3 flowHexColor(vec2 uv, float time, float len) {\n    vec2 offset = vec2(0.0);\n    float gridRes = 10.0;\n    return flowHexColor(uv, offset, gridRes, time, len);\n}\n\nvec3 flowHexColor(vec2 uv, float time) {\n    float len = 0.0;\n    return flowHexColor(uv, time, len);\n}\n\nvec3 flowHexColor(vec2 uv) {\n    float time = 0.0;\n    return flowHexColor(uv, time);\n}\n\nvec3 flow", "\n    float x = uv.x;\n    float y = uv.y;\n    float t = time;\n    float res = gridRes;\n    float len = len;\n    float x1 = sin(x * res + t) * len;\n    float x2 = sin(x * res + t + 1.0) * len;\n    float x3 = sin(x * res + t + 2.0) * len;\n    float y1 = sin(y * res + t) * len;\n    float y2 = sin(y * res + t + 1.0) * len;\n    float y3 = sin(y * res + t + 2.0) * len;\n    float x1y1 = x1 * y1;\n    float x2y2 = x2 * y2;\n    float x3y3 = x3 * y3;\n    float x1y2 = x1 * y2;\n    float x2y3 = x2 * y3;\n    float x3y1 = x3 * y1;\n    float x1y3 = x1 * y3;\n    float x2y1 = x2 * y1;\n    float x3y2 = x3 * y2;\n    float x1y1x2y2 = x1y1 * x2y2;\n    float x1y1x3y3 = x1y1 * x3y3;\n    float x2y2x3y3 = x2y2 * x3y3;\n    float x1y2x2y3 = x1y2 * x2y3;\n    float x1y2x3y1 = x1y2 * x3y1;\n    float x1y3x3y2 = x1y3 * x3y2;\n    float x2y1x3y2 = x2y1 * x3y2;\n    float x2y1x3y1 = x2y1 * x3y1;\n    float x2y3x3y1 = x2y3 * x3y1;\n    float x1y2x3y3 = x1y2 * x3y3;\n    ", "\n  vec2 center = vec2(0.5, 0.5);\n  vec2 dir = normalize(point - center);\n  float dist = distance(point, center);\n  float speed = 0.005;\n  float strength = 0.005;\n  float angle = atan(dir.y, dir.x);\n  angle += speed * time;\n  float distFlow = strength * (radius - dist);\n  angle += distFlow;\n  return vec2(cos(angle), sin(angle));\n}\n\n// makes a simple flowmap of a vortex\nvec2 vortexFlow(vec2 point, float radius, float time) {\n  vec2 center = vec2(0.5, 0.5);\n  vec2 dir = normalize(point - center);\n  float dist = distance(point, center);\n  float speed = 0.005;\n  float strength = 0.005;\n  float angle = atan(dir.y, dir.x);\n  angle += speed * time;\n  float distFlow = strength * (radius - dist);\n  angle += distFlow;\n  return vec2(cos(angle), sin(angle));\n}\n\n// makes a simple flowmap of a tornado\nvec2 tornadoFlow(vec2 point, float radius, float time) {\n  vec2 center = vec2(0.5, 0.5);\n  vec2 dir = normalize(point - center);\n  float dist = distance(point, center);\n  float speed = 0.005;\n  float strength = 0.005;\n  float angle = atan(dir.y, dir.x);\n  angle += speed * time;\n  float distFlow = strength * (radius - dist);\n  angle += distFlow;\n  return vec2(cos(angle), sin(angle));\n}\n\n// makes a simple flowmap of a tornado\nvec2 tornadoFlow(vec2 point, float radius, float time) {\n  vec2 center = vec2(0.5, 0.5);\n  vec2 dir = normalize(point - center);\n  float dist = distance(point, center);\n  float speed = 0.0", "\n  return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize) {\n  return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2) {\n  return floor(pos / tileSize) * tileSize + tileSize2 / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2, float tileSize3) {\n  return floor(pos / tileSize) * tileSize + tileSize3 / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2, float tileSize3, float tileSize4) {\n  return floor(pos / tileSize) * tileSize + tileSize4 / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2, float tileSize3, float tileSize4, float tileSize5) {\n  return floor(pos / tileSize) * tileSize + tileSize5 / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2, float tileSize3, float tileSize4, float tileSize5, float tileSize6) {\n  return floor(pos / tileSize) * tileSize + tileSize6 / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileSize2, float tileSize3, float tileSize4, float tileSize5, float tileSize6, float tileSize7) {\n  return floor(pos / tileSize) * tileSize + tileSize7", "\n  vec2 pa = p - p1;\n  vec2 ba = p2 - p1;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness) {\n  return line(p, p1, p2) - thickness;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t) {\n  return line(p, p1, p2, thickness) - t;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t, float t2) {\n  return line(p, p1, p2, thickness, t) - t2;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t, float t2, float t3) {\n  return line(p, p1, p2, thickness, t, t2) - t3;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t, float t2, float t3, float t4) {\n  return line(p, p1, p2, thickness, t, t2, t3) - t4;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t, float t2, float t3, float t4, float t5) {\n  return line(p, p1, p2, thickness, t, t2, t3, t4) - t5;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float thickness, float t, float t", "\n  vec2 p1 = arrowTileCenterCoord(p);\n  vec2 p2 = p1 + v;\n  vec2 p3 = p1 + v * 0.5;\n  vec2 p4 = p1 + v * 0.5 + v.yx * 0.5;\n  vec2 p5 = p1 + v * 0.5 - v.yx * 0.5;\n  vec2 p6 = p1 + v * 0.5 + v.yx * 0.5 * 0.5;\n  vec2 p7 = p1 + v * 0.5 - v.yx * 0.5 * 0.5;\n  vec2 p8 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5;\n  vec2 p9 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5;\n  vec2 p10 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p11 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p12 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p13 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p14 = p1 + v * 0.5 + v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n  vec2 p15 = p1 + v * 0.5 - v.yx * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n", "\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make_1to1(vec2 x) {\n  return (x * 2.0) - 1.0;\n}\n\n//converts from polar to cartesian\nvec2 polarToCartesian(vec2 x) {\n  return vec2(cos(x.y), sin(x.y)) * x.x;\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\nvec2 cartesianToPolar(vec2 x) {\n  return vec2(length(x), atan(x.y, x.x));\n}\n\n//converts from cartesian to polar\n", "\n    vec2 center = vec2(0.5, 0.5);\n    float radius = 0.25;\n    float innerRadius = 0.1;\n    float outerRadius = 0.3;\n    float innerSpread = 0.05;\n    float outerSpread = 0.05;\n    float innerOffset = 0.0;\n    float outerOffset = 0.0;\n    float innerAngle = atan(point.y - center.y, point.x - center.x);\n    float outerAngle = atan(point.y - center.y, point.x - center.x);\n    float innerDistance = distance(point, center);\n    float outerDistance = distance(point, center);\n    float innerFlow = innerSpread * sin(innerAngle + innerOffset);\n    float outerFlow = outerSpread * sin(outerAngle + outerOffset);\n    float innerFlowX = innerFlow * cos(innerAngle);\n    float innerFlowY = innerFlow * sin(innerAngle);\n    float outerFlowX = outerFlow * cos(outerAngle);\n    float outerFlowY = outerFlow * sin(outerAngle);\n    float innerFlowMap = smoothstep(innerRadius, innerRadius + innerSpread, innerDistance);\n    float outerFlowMap = smoothstep(outerRadius, outerRadius + outerSpread, outerDistance);\n    float innerFlowMapX = innerFlowMap * innerFlowX;\n    float innerFlowMapY = innerFlowMap * innerFlowY;\n    float outerFlowMapX = outerFlowMap * outerFlowX;\n    float outerFlowMapY = outerFlowMap * outerFlowY;\n    float innerFlowMapX = innerFlowMap * innerFlowX;\n    float innerFlowMapY = innerFlowMap * innerFlowY;\n    float outerFlowMapX = outerFlowMap * outerFlowX;\n    float outerFlowMapY = outerFlowMap * outerFlowY;\n    float innerFlowMapX = innerFlowMap * innerFlowX;\n    float innerFlowMapY = innerFlowMap * innerFlowY;\n    float outerFlowMapX = outerFlowMap * outerFlowX;\n    float outerFlowMapY = outerFlowMap * outerFlowY;\n    float innerFlow", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n  vec2 e;\n  vec2 v;\n  float d = 0.0;\n  float s = 1.0;\n\n  e = b - a; d = dot(e,e);\n  v = p - a;\n  float t = clamp( dot(v,e)/d, 0.0, 1.0 );\n  d = dot( v - e*t, v - e*t );\n\n  e = c - b; d += dot(e,e);\n  v = p - b;\n  t = clamp( dot(v,e)/d, 0.0, 1.0 );\n  d = min( d, dot( v - e*t, v - e*t ) );\n\n  e = a - c; d += dot(e,e);\n  v = p - c;\n  t = clamp( dot(v,e)/d, 0.0, 1.0 );\n  d = min( d, dot( v - e*t, v - e*t ) );\n\n  return sqrt(d)*s;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0", "\n    vec2 q = p + vec2(0.0, 0.0);\n    float s = 0.0;\n    float t = time;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v =", "\n    float t = time;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float aa = mod(a+t,sp)-sp/2.0;\n    float rr = ra + aa*2.0/sp;\n    return r - rr;\n}\n\n//----------------------------------------------------------------------------------------\n// main\n//----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\n    // time\n    float t = iTime*0.5;\n\n    // circular repetition\n    float d = sdCircularRepetition(p,0.5,3.14159,t);\n\n    // color\n    vec3 col = vec3(0.0);\n    col = mix(vec3(0.0,0.0,1.0),vec3(1.0,0.0,0.0),smoothstep(0.0,0.01,d));\n\n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Circular Repetition';\n  }\n  sort() {\n    return 19;\n  }\n  tags?(): string[] {\n    return [];\n  }\n  main(): HTMLCanvasElement {\n    return createCanvas();\n  }\n  userFragment(): string {\n    return fragment;\n  }\n  fragmentPrecision?(): string {\n    return PRECISION_MEDIUMP;\n  }\n  destory(): void {}\n  initial?(gl: WebGLRenderingContext, program: WebGLProgram): Function {\n    return ()", "\n  return min(min(uvw.x, uvw.y), uvw.z);\n}\n\n//distance function\nfloat sdf(vec3 p) {\n  //cube\n  vec3 uvw = abs(p) - vec3(0.5);\n  return cubeDist(uvw) + min(max(uvw.x, max(uvw.y, uvw.z)), 0.0);\n}\n\n//normal function\nvec3 normal(vec3 p) {\n  float e = 0.001;\n  return normalize(vec3(\n    sdf(vec3(p.x + e, p.y, p.z)) - sdf(vec3(p.x - e, p.y, p.z)),\n    sdf(vec3(p.x, p.y + e, p.z)) - sdf(vec3(p.x, p.y - e, p.z)),\n    sdf(vec3(p.x, p.y, p.z + e)) - sdf(vec3(p.x, p.y, p.z - e))\n  ));\n}\n\n//ray marching\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float d = 0.0;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * d;\n    d += sdf(p);\n  }\n  return d;\n}\n\n//lighting\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n  vec3 color = vec3(0.0);\n  vec3 lightPos = vec3(0.0, 0.0, 0.0);\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightDir = normalize(lightPos - p);\n  float lightDist = distance(lightPos, p);\n  float lightAtten = 1.0 / (1.0 + 0.001 * lightDist * lightDist);\n  float diffuse = max(dot(n,", "\n  vec3 u = abs(uvw);\n  vec3 i = step(u.yzx, u);\n  i = step(u.zxy, u) - i;\n  vec3 j = 1.0 - i;\n  return vec4(i, j);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, vec4 ij) {\n  return uvw * ij.xy + ij.zw;\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, vec3 ij) {\n  return uvw * ij.xy + ij.zw;\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, float i, float j) {\n  return uvw * vec3(i, j) + vec3(1.0 - i, 1.0 - j);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, float i, float j, float k) {\n  return uvw * vec3(i, j, k) + vec3(1.0 - i, 1.0 - j, 1.0 - k);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, float i, float j, float k, float l) {\n  return uvw * vec3(i, j, k) + vec3(1.0 - i, 1.0 - j, 1.0 - k);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, float i, float j, float k, float l, float m) {\n  return uvw * vec3(i, j, k) + vec3(1.0 - i, 1.0 - j, 1.0 - k);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw, float i, float j, float k, float l, float m, float n) {\n  return uvw * vec3(i, j, k) + vec3(1.0 - i, 1.0 - j, 1.0 - k);\n}\n\n// Cube Tiling\nvec3 cubeTile(vec3 uvw,", "\n  vec3 cell = floor(uvw * gridRes);\n  vec3 uvw_ = fract(uvw * gridRes);\n  uvw_ -= 0.5;\n  uvw_ += 0.5 * offset;\n  uvw_ *= 2.0;\n  uvw_ = abs(uvw_);\n  uvw_ = max(uvw_, 1.0 - uvw_);\n  return vec4(cell, uvw_.x * uvw_.y * uvw_.z);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, vec3 offset, float gridRes) {\n  return floor(uvw * gridRes);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, float gridRes) {\n  return floor(uvw * gridRes);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw) {\n  return floor(uvw);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, vec3 offset) {\n  return floor(uvw);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, float gridRes, vec3 offset) {\n  return floor(uvw * gridRes);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, float gridRes) {\n  return floor(uvw * gridRes);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with offset cube tiling\nvec3 cubeCellIndex(vec3 uvw, vec3 offset) {\n  return floor(uvw);\n}\n\n// returns the cell index of the cell that contains the given point\n// scaled with", "\n    t = clamp(t, 0.0, 1.0);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y", "\n    vec3 q = abs(p);\n    float s = max(q.x, max(q.y, q.z));\n    float t = min(q.x, min(q.y, q.z));\n    float u = (q.x + q.y + q.z - s - t) / 2.0;\n    return length(vec3(s - t, s - u, u)) - 1.0;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) {\n    vec3 q = abs(p);\n    float s = max(q.x, max(q.y, q.z));\n    float t = min(q.x, min(q.y, q.z));\n    float u = (q.x + q.y + q.z - s - t) / 2.0;\n    return length(vec3(s - t, s - u, u)) - 1.0;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    vec3 q = abs(p);\n    float s = max(q.x, max(q.y, q.z));\n    float t = min(q.x, min(q.y, q.z));\n    float u = (q.x + q.y + q.z - s - t) / 2.0;\n    return length(vec3(s - t, s - u, u)) - 1.0;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    vec3 q = abs(p);\n    float s = max(q.x, max(q.y, q.z));\n    float t = min(q.x, min(q.y, q.z));\n    float u = (q.x + q.y + q.z - s - t) / 2.0;\n    return length(vec3(s - t, s - u, u)) - 1.0;\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {", "\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter2(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter3(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter4(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter5(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter6(float t) {\n  return vec3(\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t),\n    smoothstep(0.0, 0.2, t)\n  );\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter7(float t) {\n  ", "\n  vec2 tile = floor(uv);\n  vec2 tileF = fract(uv);\n  vec2 tileC = tileF - 0.5;\n  vec2 tileN = vec2(0.0);\n  if (tileC.x > tileC.y) {\n    tileN = vec2(1.0, -1.0);\n  } else {\n    tileN = vec2(-1.0, 1.0);\n  }\n  return vec3(tile, tileN.x * tileN.y);\n}\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) {\n  vec2 tile = floor(uv);\n  vec2 tileF = fract(uv);\n  vec2 tileC = tileF - 0.5;\n  vec2 tileN = vec2(0.0);\n  if (tileC.x > tileC.y) {\n    tileN = vec2(1.0, -1.0);\n  } else {\n    tileN = vec2(-1.0, 1.0);\n  }\n  return vec3(tile, tileN.x * tileN.y);\n}\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) {\n  vec2 tile = floor(uv);\n  vec2 tileF = fract(uv);\n  vec2 tileC = tileF - 0.5;\n  vec2 tileN = vec2(0.0);\n  if (tileC.x > tileC.y) {\n    tileN = vec2(1.0, -1.0);\n  } else {\n    tileN = vec2(-1.0, 1.0);\n  }\n  return vec3(tile, tileN.x * tileN.y);\n}\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) {\n  vec2 tile = floor(uv);\n  vec2 tileF = fract(uv);\n  vec2 tileC = tileF - 0.5;\n  vec2 tileN = vec2(0.0);\n  if (tileC.x > tileC.y) {\n    tileN = vec2", "\n  vec2 p = fract(uv);\n  vec2 q = abs(p - 0.5);\n  vec2 r = 0.5 - q;\n  vec2 s = step(p, 0.5);\n  vec2 t = s - (1.0 - s);\n  vec2 u = t * r + (1.0 - t) * q;\n  return vec3(u, 0.0);\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile2(vec2 uv) {\n  vec2 p = fract(uv);\n  vec2 q = abs(p - 0.5);\n  vec2 r = 0.5 - q;\n  vec2 s = step(p, 0.5);\n  vec2 t = s - (1.0 - s);\n  vec2 u = t * r + (1.0 - t) * q;\n  return vec3(u, length(u));\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile3(vec2 uv) {\n  vec2 p = fract(uv);\n  vec2 q = abs(p - 0.5);\n  vec2 r = 0.5 - q;\n  vec2 s = step(p, 0.5);\n  vec2 t = s - (1.0 - s);\n  vec2 u = t * r + (1.0 - t) * q;\n  return vec3(u, length(u));\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile4(vec2 uv) {\n  vec2 p = fract(uv);\n  vec2 q = abs(p - 0.5);\n  vec2 r = 0.5 - q;\n  vec2 s = step(p, 0.5);\n  vec2 t = s - (1.0 - s);\n  vec2 u = t * r + (1.0 - t) * q;\n  return vec3(u, length(u));\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile5(vec2 uv) {\n  vec2 p = fract", "\n  vec2 pixel = floor(uv * gridRes);\n  vec2 pixelCenter = (pixel + 0.5) / gridRes;\n  vec2 pixelOffset = pixelCenter + offset;\n  return vec3(pixelOffset, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale) {\n  vec2 pixel = floor(uv * gridRes);\n  vec2 pixelCenter = (pixel + 0.5) / gridRes;\n  vec2 pixelOffset = pixelCenter + offset;\n  return vec3(pixelOffset, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float rotation) {\n  vec2 pixel = floor(uv * gridRes);\n  vec2 pixelCenter = (pixel + 0.5) / gridRes;\n  vec2 pixelOffset = pixelCenter + offset;\n  return vec3(pixelOffset, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float rotation, float opacity) {\n  vec2 pixel = floor(uv * gridRes);\n  vec2 pixelCenter = (pixel + 0.5) / gridRes;\n  vec2 pixelOffset = pixelCenter + offset;\n  return vec3(pixelOffset, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float rotation, float opacity, float brightness) {\n  vec2 pixel = floor(uv * gridRes);\n  vec2 pixelCenter = (pixel + 0.5) / gridRes;\n  vec2 pixelOffset = pixelCenter + offset;\n  return vec3(pixelOffset, 0.0);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset, float scale, float rotation, float opacity, float brightness, float contrast) {\n  vec2 pixel = floor", "\n  vec2 grid = floor(uv * gridRes);\n  vec2 gridCenter = (grid + 0.5) / gridRes;\n  vec2 gridOffset = gridCenter - uv;\n  vec2 gridOffset2 = gridOffset * gridRes;\n  vec2 gridOffset3 = gridOffset2 * gridRes;\n  vec2 gridOffset4 = gridOffset3 * gridRes;\n  vec2 gridOffset5 = gridOffset4 * gridRes;\n  vec2 gridOffset6 = gridOffset5 * gridRes;\n  vec2 gridOffset7 = gridOffset6 * gridRes;\n  vec2 gridOffset8 = gridOffset7 * gridRes;\n  vec2 gridOffset9 = gridOffset8 * gridRes;\n  vec2 gridOffset10 = gridOffset9 * gridRes;\n  vec2 gridOffset11 = gridOffset10 * gridRes;\n  vec2 gridOffset12 = gridOffset11 * gridRes;\n  vec2 gridOffset13 = gridOffset12 * gridRes;\n  vec2 gridOffset14 = gridOffset13 * gridRes;\n  vec2 gridOffset15 = gridOffset14 * gridRes;\n  vec2 gridOffset16 = gridOffset15 * gridRes;\n  vec2 gridOffset17 = gridOffset16 * gridRes;\n  vec2 gridOffset18 = gridOffset17 * gridRes;\n  vec2 gridOffset19 = gridOffset18 * gridRes;\n  vec2 gridOffset20 = gridOffset19 * gridRes;\n  vec2 gridOffset21 = gridOffset20 * gridRes;\n  vec2 gridOffset22 = gridOffset21 * gridRes;\n  vec2 gridOffset23 = gridOffset22 * gridRes;\n  vec2 gridOffset24 = gridOffset23 * gridRes;\n  vec2 gridOffset25 = gridOffset24 * gridRes;\n  vec2 gridOffset26 = gridOffset25 * gridRes;\n  vec2 gridOffset27 = gridOffset26 * gridRes;\n  vec2 gridOffset28 = gridOffset27 * gridRes;\n  vec2 gridOffset29 = gridOffset28 * gridRes;\n  vec2 gridOffset30 =", "\n    vec2 p = floor(uv * gridRes);\n    vec2 t = fract(uv * gridRes);\n    float tt = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt2 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt3 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt4 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt5 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt6 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt7 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt8 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt9 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt10 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt11 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt12 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt13 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt14 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt15 = 1.0 - abs(t.x - 0.5) * 2.0;\n    float tt16 = 1.0 - abs(t.y - 0.5) * 2.0;\n    float tt17 = 1.0 - abs(t", "\n    float t = time * 0.0001;\n    float x = uv.x + gridRes * sin(t);\n    float y = uv.y + gridRes * cos(t);\n    float x1 = floor(x);\n    float y1 = floor(y);\n    float x2 = x1 + 1.0;\n    float y2 = y1 + 1.0;\n    float d1 = length(vec2(x - x1, y - y1));\n    float d2 = length(vec2(x - x2, y - y1));\n    float d3 = length(vec2(x - x1, y - y2));\n    float d4 = length(vec2(x - x2, y - y2));\n    float m = min(min(d1, d2), min(d3, d4));\n    return smoothstep(len, len + 0.01, m);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes, float time, float len) {\n    float t = time * 0.0001;\n    float x = uv.x + gridRes * sin(t);\n    float y = uv.y + gridRes * cos(t);\n    float x1 = floor(x);\n    float y1 = floor(y);\n    float x2 = x1 + 1.0;\n    float y2 = y1 + 1.0;\n    float d1 = length(vec2(x - x1, y - y1));\n    float d2 = length(vec2(x - x2, y - y1));\n    float d3 = length(vec2(x - x1, y - y2));\n    float d4 = length(vec2(x - x2, y - y2));\n    float m = min(min(d1, d2), min(d3, d4));\n    return smoothstep(len, len + 0.01, m);\n}\n\n// generates pixelated directional waves\nfloat flowRhom(vec2 uv, float gridRes, float time, float len) {\n    ", "\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    vec2 g = vec2(0.0);\n    float d = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 id = vec2(i,j);\n        vec2 b = vec2( lessThanEqual( abs(r.x-0.5+id.x), ddx.x ),\n                       lessThanEqual( abs(r.y-0.5+id.y), ddy.y ) );\n        float w = dot(b,b);\n        if( w>0.0 )\n        {\n            vec2  gid = q + id;\n            float l = length(r - 0.5 - id);\n            float v = gridTexture( gid );\n            d = min(d, l);\n            g += v*w;\n        }\n    }\n    return g/d;\n}\n\n//----------------------------------------------------------------------------------------------------------\n//\n//----------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 q = p;\n\n    //------------------------------------------------------------------------------------------------------\n    //\n    //------------------------------------------------------------------------------------------------------\n\n    float t = iTime * 0.1;\n    float a = 0.0;\n    float b = 0.", "\n    p = abs(p);\n    return max(p.x, p.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p, float r) {\n    p = abs(p);\n    return max(p.x + p.y - r, -p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat star(vec2 p, float r) {\n    p = abs(p);\n    float a = atan(p.y, p.x);\n    float k = 1.0 + cos(floor(a * 12.0 + 0.5) * (2.0 * PI / 12.0));\n    return length(p) * sign(cos(floor(a * 12.0 + 0.5) * (2.0 * PI / 12.0))) - r * k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon(vec2 p, float r, float n) {\n    p = abs(p);\n    float a = atan(p.y, p.x);\n    float k = 1.0 + cos(floor(a * n + 0.5) * (2.0 * PI / n));\n    return length(p) * sign(cos(floor(a * n + 0.5) * (2.0 * PI / n))) - r * k;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://", "\n    vec2 q = vec2(p.x + p.y / 2, p.y);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    f = 0.5 - abs(f - 0.5);\n    vec2 g = mod(i, 2.0);\n    vec2 h = 0.5 - abs(f - 0.5);\n    vec2 j = (g - h) * 0.5;\n    vec2 k = i + j;\n    vec2 l = k + f;\n    return l;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile2(inout vec2 p) {\n    vec2 q = vec2(p.x + p.y / 2, p.y);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    f = 0.5 - abs(f - 0.5);\n    vec2 g = mod(i, 2.0);\n    vec2 h = 0.5 - abs(f - 0.5);\n    vec2 j = (g - h) * 0.5;\n    vec2 k = i + j;\n    vec2 l = k + f;\n    return l;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile3(inout vec2 p) {\n    vec2 q = vec2(p.x + p.y / 2, p.y);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    f = 0.5 - abs(f - 0.5);\n    vec2 g = mod(i, 2.0);\n    vec2 h = 0.5 - abs(f - 0.5);\n    vec2 j = (g - h) * 0.5;\n    vec2 k = i + j;", "\n    float f = floor(x);\n    float s = fract(x);\n    float a = 1.0-s;\n    float b = s;\n    float c = 1.0-a*a;\n    float d = b*b;\n    return 0.5*(c + d);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 s = fract(x);\n    s = 3.0*s*s - 2.0*s*s*s;\n    float u = s.x;\n    float v = s.y;\n    float a = fun( p.x + p.y );\n    float b = fun( p.x + 1.0 + p.y );\n    float c = fun( p.x + p.y + 1.0 );\n    float d = fun( p.x + 1.0 + p.y + 1.0 );\n    return mix(mix( a, b, u), mix( c, d, u), v);\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p ); p = m*p;\n    f /= 0.9375;\n    return f;\n}\n\nfloat fbm2( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p ); p = m*p;\n    f /= 0.9375;", "\n    return pow(t, vec3(1.0/2.2));\n}\n\nvec3 RGB(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return pow(t, vec3(1.0/gamma));\n}\n\nvec3 RGB(vec3 t, float gamma) {\n    return pow(t, vec3(gamma));\n}\n\nvec3 sRGB(vec3 t, float gamma, float offset) {\n    return pow(t, vec3(1.0/gamma)) + offset;\n}\n\nvec3 RGB(vec3 t, float gamma, float offset) {\n    return pow(t, vec3(gamma)) - offset;\n}\n\nvec3 sRGB(vec3 t, float gamma, float offset, float scale) {\n    return pow(t, vec3(1.0/gamma)) * scale + offset;\n}\n\nvec3 RGB(vec3 t, float gamma, float offset, float scale) {\n    return pow(t, vec3(gamma)) / scale - offset;\n}\n\nvec3 sRGB(vec3 t, float gamma, float offset, float scale, float bias) {\n    return pow(t, vec3(1.0/gamma)) * scale + offset + bias;\n}\n\nvec3 RGB(vec3 t, float gamma, float offset, float scale, float bias) {\n    return pow(t, vec3(gamma)) / scale - offset - bias;\n}\n\nvec3 sRGB(vec3 t, float gamma, float offset, float scale, float bias, float clamp) {\n    return pow(t, vec3(1.0/gamma)) * scale + offset + bias;\n}\n\nvec3 RGB(vec3 t, float gamma, float offset, float scale, float bias, float clamp) {\n    return pow(t, vec3(gamma)) / scale - offset - bias;\n}\n\nvec3 sRGB(vec3 t, float gamma, float offset, float scale, float bias, float clamp, float contrast) {\n    return pow(t, vec3(1.0/gamma)) * scale + offset + bias;\n}\n", "\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel0, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel1, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel2, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel3, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i++) {\n        s += k * texture(iChannel4, p * k).x;\n        k *= 2.0;\n    }\n    return s;\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n    float k = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < 10; i", "\n    float s = 0.0;\n    for (int i = 0; i < 3; i++) {\n        vec2 q = p;\n        for (int j = 0; j < 3; j++) {\n            q = abs(q);\n            if (j % 2 == 0) {\n                q.x = 1.0 - q.x;\n            }\n            if (j % 3 == 0) {\n                q.y = 1.0 - q.y;\n            }\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1.0 - q.x;\n            q.y = 1.0 - q.y;\n            q = abs(q);\n            q.x = 1", "\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign(e0.x*e2.y - e0.y*e2.x);\n    float d0 = dot( pq0, pq0 );\n    float d1 = dot( pq1, pq1 );\n    float d2 = dot( pq2, pq2 );\n    float d01 = dot( pq0, pq1 );\n    float d02 = dot( pq0, pq2 );\n    float d12 = dot( pq1, pq2 );\n    float h = sqrt(max(0.0,1.0-d01*d01/(d0*d1)));\n    float a = d01 - d0*h;\n    float b = d01 - d1*h;\n    float c = d02 + a*b;\n    float d = d12 - d1*h;\n    float e = d02 + a*d;\n    float f = d12 + b*d;\n    float det = c*f - e*e;\n    float t = clamp( (d*e-c*f)/det, 0.0, 1.0 );\n    float u = clamp( (t*e-a)/d, 0.0, 1.0 );\n    float v = clamp( (t*f-b)/d", "\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > dbuffer) return -1.0;\n    if (t2 < dbuffer) return -1.0;\n    return min(t1, t2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spherei(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 > dbuffer) return -1.0;\n    if (t2 < dbuffer) return -1.0;\n    return min(t1, t2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spherei(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 o = ro - sph.xyz;\n    float b = dot(o, rd);\n    float c = dot(o, o) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h", "\n  vec2 d = abs(p) - w;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float h, float r) {\n  vec2 d = abs(p) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedRect(vec2 p, vec2 b, float r) {\n  return min(min(roundedX(vec2(p.x,p.y+b.y),b.x,r),roundedX(vec2(p.x,p.y-b.y),b.x,r)),roundedY(vec2(p.x+b.x,p.y),b.y,r));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedRect2(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p) - b;\n  return min(min(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedRect3(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p) - b;\n  return min(min(d.x,d.y),0.0) + max(d.x,d.y) - r", "\n    float k2 = k*k;\n    float l = length(p);\n    float l2 = l*l;\n    float d = l2 - k2;\n    float d2 = d*d;\n    float d4 = d2*d2;\n    float d6 = d4*d2;\n    float d8 = d4*d4;\n    float d10 = d6*d4;\n    float d12 = d6*d6;\n    float d14 = d6*d8;\n    float d16 = d8*d8;\n    float d18 = d12*d6;\n    float d20 = d10*d10;\n    float d22 = d12*d8;\n    float d24 = d12*d12;\n    float d26 = d14*d12;\n    float d28 = d16*d12;\n    float d30 = d20*d10;\n    float d32 = d16*d16;\n    float d34 = d22*d16;\n    float d36 = d24*d16;\n    float d38 = d26*d16;\n    float d40 = d28*d16;\n    float d42 = d30*d16;\n    float d44 = d32*d16;\n    float d46 = d34*d16;\n    float d48 = d36*d16;\n    float d50 = d38*d16;\n    float d52 = d40*d16;\n    float d54 = d42*d16;\n    float d56 = d44*d16;\n    float d58 = d46*d16;\n    float d60 = d48*d16;\n    float d62 = d50*d16;\n    float d64 = d52*d16;\n    float d66 = d54*d16;\n", "\n  return length(p*vec2(1.0,-1.0))-1.0;\n}\n\n// distance to y=1/x^2\nfloat sdOOXX( in vec2 p )\n{\n  return length(p*vec2(1.0,-0.5))-1.0;\n}\n\n// distance to y=1/x^3\nfloat sdOOXXX( in vec2 p )\n{\n  return length(p*vec2(1.0,-0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5*(a-b)/k, 0., 1.);\n    return mix(b, a, h) + k*h*(1.-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pmin(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x-b.x)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pmax(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 - 0.5*(a.x-b.x)/k, 0., 1.);\n    return mix(b, a, h) + k*h*(1.-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec3 pmin(vec3 a, vec3 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x-b.x)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\n// License: MIT, author: In", "\n    return k * (a + 1.0) - 1.0;\n}\n\nfloat psin(float a, float k) {\n    return k * (sin(a) + 1.0) - 1.0;\n}\n\nfloat pcos(float a, float k) {\n    return k * (cos(a) + 1.0) - 1.0;\n}\n\nfloat ptan(float a, float k) {\n    return k * (tan(a) + 1.0) - 1.0;\n}\n\nfloat psqrt(float a, float k) {\n    return k * (sqrt(a) + 1.0) - 1.0;\n}\n\nfloat pclamp(float a, float k) {\n    return k * (clamp(a, 0.0, 1.0) + 1.0) - 1.0;\n}\n\nfloat pclamp(float a, float k, float min, float max) {\n    return k * (clamp(a, min, max) + 1.0) - 1.0;\n}\n\nfloat pclamp(float a, float k, float min, float max, float min_out, float max_out) {\n    return k * (clamp(a, min, max) * (max_out - min_out) + min_out + 1.0) - 1.0;\n}\n\nfloat pclamp(float a, float k, float min, float max, float min_out, float max_out, float min_in, float max_in) {\n    return k * (clamp(a, min, max) * (max_out - min_out) + min_out + 1.0) - 1.0;\n}\n\nfloat pclamp(float a, float k, float min, float max, float min_out, float max_out, float min_in, float max_in, float min_out_in, float max_out_in) {\n    return k * (clamp(a, min, max) * (max_out - min_out) + min_out + 1.0)", "\n    float a = p.x*p.x + p.y*p.y - 1.0;\n    return -a*a*a + 0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat star(vec2 p) {\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float t = a + 0.5*PI;\n    t = mod(t, 2.0*PI/5.0);\n    t = abs(t - 2.0*PI/10.0);\n    return cos(t)*r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p) {\n    p.x = abs(p.x);\n    p.y = p.y + p.x - 1.0;\n    p.x = p.x*0.5 + 0.5;\n    p = abs(p);\n    return max(p.y, p.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p) {\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.y = p.y - (p.x - 0.5*p.x)*0.5;\n    p.x = p.x*0.5 + 0.5;\n    p = abs(p);\n    return max(p.y, p.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat octagon(vec2 p) {\n    p.x = abs(p.x", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)),\n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)),\n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; ++i) {\n        v += a * noise(p);\n        p = p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat pattern(vec2 p) {\n    return fbm(p * 0.01);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 color = vec3(pattern(uv * 100.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default class implements iSub {\n  key(): string {\n    return '4sX3z2';\n  }\n  name(): string {\n    return 'Noise - Fractal Brownian Motion';\n  }\n  sort() {\n", "\n    vec2 a = B-A, b = C-B, c = A-2.0*B+C, d = pos-B;\n    float t0 = dot(a,a), t1 = dot(a,b), t2 = dot(b,b), t3 = dot(a,d), t4 = dot(b,d);\n    float det = t0*t2 - t1*t1;\n    float s = clamp( (t1*t4 - t2*t3) / det, 0.0, 1.0 );\n    float t = clamp( (t0*t4 - t1*t3) / det, 0.0, 1.0 );\n    float h = s+t;\n    float r = (1.0-h)*t3 + h*t4;\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h2*h2;\n    float h5 = h4*h;\n    float h6 = h4*h2;\n    float h7 = h6*h;\n    float h8 = h4*h4;\n    float h9 = h8*h;\n    float h10 = h8*h2;\n    float h11 = h10*h;\n    float h12 = h8*h4;\n    float h13 = h12*h;\n    float h14 = h12*h2;\n    float h15 = h14*h;\n    float h16 = h8*h8;\n    float h17 = h16*h;\n    float h18 = h16*h2;\n    float h19 = h18*h;\n    float h20 = h16*h4;\n    float h21 = h20*h;\n    float h22 = h20*h2;\n    float h23 = h22*h;\n    float h24 = h16*h8;\n    float h25 = h24*h;\n    float h26 = h24*", "\n    vec2 p = pos;\n    p.x *= wi/he;\n    float h = 1.0-abs(p.y);\n    float d = length(p)*h;\n    return vec3( d, h, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSphere( in vec3 pos, in float rad )\n{\n    return vec3( length(pos)-rad, pos.x, pos.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdCylinder( in vec3 pos, in float rad, in float he )\n{\n    vec2 d = abs(vec2(length(pos.xz)-rad,pos.y))-vec2(0.0,he);\n    return vec3( min(max(d.x,d.y),0.0)+length(max(d,0.0)), pos.x, pos.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTorus( in vec3 pos, in float rad1, in float rad2 )\n{\n    vec2 q = vec2(length(pos.xz)-rad1,pos.y);\n    return vec3( length(q)-rad2, pos.x, pos.y );\n}", "\n    float d = pos.y - pos.x*pos.x*k;\n    float h = 1.0 - 4.0*k*pos.x;\n    float s = sqrt(0.25-h*h*k);\n    float t = pos.x - 0.5*h;\n    float a = t - s;\n    float b = t + s;\n    float c = clamp( (a+b)*0.5, a, b );\n    float e = clamp( (a-b)*0.5, a, b );\n    float g = clamp( (a+b)*0.5, a, b );\n    float f = clamp( (a-b)*0.5, a, b );\n    float m = min(d,min(a,min(b,min(c,min(e,min(f,min(g,d)))))));\n    float n = max(d,max(a,max(b,max(c,max(e,max(f,max(g,d)))))));\n    float o = clamp( (a+b)*0.5, a, b );\n    float p = clamp( (a-b)*0.5, a, b );\n    float q = clamp( (a+b)*0.5, a, b );\n    float r = clamp( (a-b)*0.5, a, b );\n    float s1 = min(m,min(o,min(p,min(q,min(r,m)))));\n    float s2 = max(n,max(o,max(p,max(q,max(r,n)))));\n    float t1 = clamp( (a+b)*0.5, a, b );\n    float t2 = clamp( (a-b)*0.5, a, b );\n    float t3 = clamp( (a+b)*0.5, a, b );\n    float t4 = clamp( (a-b)*0.5, a, b );\n    float t5 = clamp( (a+b)*0.5, a, b );\n    float t6 = clamp( (a-b)*0.5, a,", "\n    vec2 q = vec2(p.x, p.y);\n    float a = atan(q.x, q.y);\n    float r = length(q);\n    float r2 = r*r;\n    float r3 = r*r2;\n    float r4 = r2*r2;\n    float r5 = r*r4;\n    float r6 = r2*r4;\n    float r7 = r*r6;\n    float r8 = r2*r6;\n    float r9 = r*r8;\n    float r10 = r2*r8;\n    float r11 = r*r10;\n    float r12 = r2*r10;\n    float r13 = r*r12;\n    float r14 = r2*r12;\n    float r15 = r*r14;\n    float r16 = r2*r14;\n    float r17 = r*r16;\n    float r18 = r2*r16;\n    float r19 = r*r18;\n    float r20 = r2*r18;\n    float r21 = r*r20;\n    float r22 = r2*r20;\n    float r23 = r*r22;\n    float r24 = r2*r22;\n    float r25 = r*r24;\n    float r26 = r2*r24;\n    float r27 = r*r26;\n    float r28 = r2*r26;\n    float r29 = r*r28;\n    float r30 = r2*r28;\n    float r31 = r*r30;\n    float r32 = r2*r30;\n    float r33 = r*r32;\n    float r34 = r2*r32;\n    float r35 = r*r34;\n    float r36 = r2*r34;\n    float r37 = r*r36;\n    float", "\n    v = v * 747783649u + 2891336453u;\n    v = (v ^ (v >> 16)) * 2049140787u;\n    v = (v ^ (v >> 15)) * 2766017073u;\n    v = (v ^ (v >> 16));\n    return v;\n}\n\nivec2 Pcg3(ivec2 v)\n{\n    v = v * 747783649u + 2891336453u;\n    v = (v ^ (v >> 16)) * 2049140787u;\n    v = (v ^ (v >> 15)) * 2766017073u;\n    v = (v ^ (v >> 16));\n    return v;\n}\n\nivec2 Pcg4(ivec2 v)\n{\n    v = v * 747783649u + 2891336453u;\n    v = (v ^ (v >> 16)) * 2049140787u;\n    v = (v ^ (v >> 15)) * 2766017073u;\n    v = (v ^ (v >> 16));\n    return v;\n}\n\nivec2 Pcg5(ivec2 v)\n{\n    v = v * 747783649u + 2891336453u;\n    v = (v ^ (v >> 16)) * 2049140787u;\n    v = (v ^ (v >> 15)) * 2766017073u;\n    v = (v ^ (v >> 16));\n    return v;\n}\n\nivec2 Pcg6(ivec2 v)\n{\n    v = v * 747783649", "\n    v = v * 1664525 + 1013904223;\n    v = (v ^ (v >> 16)) * 2246822507;\n    v = (v ^ (v >> 16)) * 3266489917;\n    return v ^ (v >> 16);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg4(ivec3 v)\n{\n    v = v * 1664525 + 1013904223;\n    v = (v ^ (v >> 16)) * 2246822507;\n    v = (v ^ (v >> 16)) * 3266489917;\n    v = (v ^ (v >> 16)) * 1202036333;\n    return v ^ (v >> 16);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg5(ivec3 v)\n{\n    v = v * 1664525 + 1013904223;\n    v = (v ^ (v >> 16)) * 2246822507;\n    v = (v ^ (v >> 16)) * 3266489917;\n    v = (v ^ (v >> 16)) * 1202036333;\n    v = (v ^ (v >> 16)) * 2122429787;\n    return v ^ (v >> 16);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float k = 1.0 / dot(b, b);\n    float p = k * dot(a, b);\n    float q = k * (2.0 * dot(a, a) + dot(d, b) - 2.0 * dot(a, d));\n    float r = k * dot(d, a);\n\n    float t = clamp((-p + sqrt(p * p - q)) / 2.0, 0.0, 1.0);\n    vec2  x = A + t * (2.0 * (1.0 - t) * (B - A) + t * t * (C - A));\n    return length(pos - x);\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n    vec2 a = B - A;\n    vec2 b = C - B;\n    vec2 c = A - 3.0 * B + 3.0 * C - D;\n    vec2 d = 3.0 * (B - A) - 6.0 * (C - B) + 3.0 * (D - C);\n    vec2 e = a * 3.0;\n    vec2 f = b * 6.0;\n    vec2 g = c * 3.0;\n    vec2 h = pos - D;\n\n    float k = 1.0 / dot(d, d);\n    float p = k * dot(c, d);\n    float q = k * (3.0 * dot(b, d) + dot(g, h));\n    float r = k * (2.0 * dot(a, d) + dot(f, h));\n    float s = k * (dot(e, d) + dot(e, h));\n\n    float t = clamp((-q + sqrt(q * q - 3.0 *", "\n    return sign(cross(a - p, b - p));\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b) {\n    return winding_sign(p, a, b) * 0.5;\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_number(p, a, b) + winding_number(p, b, c) + winding_number(p, c, a);\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_number(p, a, b, c) + winding_number(p, c, d, a);\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_number(p, a, b, c, d) + winding_number(p, d, e, a);\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_number(p, a, b, c, d, e) + winding_number(p, e, f, a);\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_number(p, a, b, c, d, e, f) + winding_number(p, f, g, a);\n}\n\nfloat winding_number(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h) {\n    return winding_number(p, a, b, c, d, e, f, g) + winding_number(p, g, h, a);\n}\n", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec4( -1.0 );\n    vec3  iu = vec3( t1.y<0.0, t1.z<0.0, t1.x<0.0 );\n    vec3 id = vec3( t2.y<0.0, t2.z<0.0, t2.x<0.0 );\n    vec3  is = vec3(iu.y*iu.z,iu.x*iu.z,iu.x*iu.y);\n    vec3  id2 = vec3(id.y*id.z,id.x*id.z,id.x*id.y);\n    vec3  ns = vec3(iu.y*id.z,iu.x*id.z,iu.x*id.y);\n    vec3  nd = vec3(id.y*iu.z,id.x*iu.z,id.x*iu.y);\n    vec3  n2 = vec3(iu.y*id.z,iu.x*id.z,iu.x*id.y);\n    vec3  n3 = vec3(id.y*iu.z,id.x*iu.z,id.x*iu.y);\n    vec3  n4 = vec3(iu.y*id.z,iu.x*id.z,iu.x*id.y);\n    vec3  n5 = vec3(id.y*iu.z,id.x*iu.z,id.x*iu.y);\n    vec3  n6 = vec3(iu.y*id.z,iu.x*id", "\n    float a_f = (float)a;\n    float a_f_abs = abs(a_f);\n    float a_f_abs_24 = floor(a_f_abs);\n    float a_f_abs_24_f = (float)a_f_abs_24;\n    float a_f_abs_24_f_24 = floor(a_f_abs_24_f);\n    float a_f_abs_24_f_24_f = (float)a_f_abs_24_f_24;\n    float a_f_abs_24_f_24_f_24 = floor(a_f_abs_24_f_24_f);\n    float a_f_abs_24_f_24_f_24_f = (float)a_f_abs_24_f_24_f_24;\n    float a_f_abs_24_f_24_f_24_f_24 = floor(a_f_abs_24_f_24_f_24_f);\n    float a_f_abs_24_f_24_f_24_f_24_f = (float)a_f_abs_24_f_24_f_24_f_24;\n    float a_f_abs_24_f_24_f_24_f_24_f_24 = floor(a_f_abs_24_f_24_f_24_f_24_f);\n    float a_f_abs_24_f_24_f_24_f_24_f_24_f = (float)a_f_abs_24_f_24_f_24_f_24_f_24;\n    float a_f_abs_24_f_24_f_24_f_24_f_24_f_24 = floor(a_f_abs_24_f_24_f_", "\n    vec3 h = max(k-abs(a),0.0);\n    return min(a,b) - h*(h.x+h.y+h.z)/3.0;\n}\n\n// signed distance function\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance function\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// signed distance function\nfloat sdCylinder( in vec3 p, in float r, in float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance function\nfloat sdTorus( in vec3 p, in float r1, in float r2 )\n{\n    vec2 q = vec2(length(p.xz)-r1,p.y);\n    return length(q)-r2;\n}\n\n// signed distance function\nfloat sdCone( in vec3 p, in float r, in float h )\n{\n    float q = length(p.xz);\n    float d = (r*h - q*p.y) / sqrt(h*h+q*q);\n    return length(vec2(d,p.y)) - h;\n}\n\n// signed distance function\nfloat sdCappedCone( in vec3 p, in float r1, in float r2, in float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d = (r1-r2)*q.y/h + r2;\n    return length(q-vec2(d,-h/2.0));\n}\n\n// signed distance function\nfloat sdCappedC", "\n    return (p.x*p.x - p.y*p.y) - (ab.x*ab.x - ab.y*ab.y);\n}\n\n//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    return a + b;\n}\n\nfloat sub_ploss(in float a, in float b){\n    return a - b;\n}\n\nfloat mul_ploss(in float a, in float b){\n    return a * b;\n}\n\nfloat div_ploss(in float a, in float b){\n    return a / b;\n}\n\nfloat mod_ploss(in float a, in float b){\n    return mod(a, b);\n}\n\nfloat pow_ploss(in float a, in float b){\n    return pow(a, b);\n}\n\nfloat sqrt_ploss(in float a){\n    return sqrt(a);\n}\n\nfloat exp_ploss(in float a){\n    return exp(a);\n}\n\nfloat log_ploss(in float a){\n    return log(a);\n}\n\nfloat sin_ploss(in float a){\n    return sin(a);\n}\n\nfloat cos_ploss(in float a){\n    return cos(a);\n}\n\nfloat tan_ploss(in float a){\n    return tan(a);\n}\n\nfloat asin_ploss(in float a){\n    return asin(a);\n}\n\nfloat acos_ploss(in float a){\n    return acos(a);\n}\n\nfloat atan_ploss(in float a){\n    return atan(a);\n}\n\nfloat sinh_ploss(in float a){\n    return sinh(a);\n}\n\nfloat cosh_ploss(in float a){\n    return cosh(a);\n}\n\nfloat tanh_ploss(in float a){\n    return tanh(a);\n}\n\nfloat asinh_ploss(in float a){\n    return asinh(a);\n}\n\nfloat acosh_ploss(in float a){\n    return acosh(a);\n}\n\nfloat atanh_ploss(in float a){\n    return atanh(a);\n}\n\nfloat ceil_ploss(in float a){\n    return ceil(a);\n}\n\nfloat floor_ploss(in float a){\n    ", "\n    vec2 p1 = pHyperbola( p, ab, s1 );\n    vec2 p2 = pHyperbola( p, ab, s2 );\n    return p1 * (1.0 - s2) + p2 * s2;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3 )\n{\n    vec2 p1 = pHyperbola( p, ab, s1 );\n    vec2 p2 = pHyperbola( p, ab, s2 );\n    vec2 p3 = pHyperbola( p, ab, s3 );\n    return p1 * (1.0 - s2) + p2 * s2 * (1.0 - s3) + p3 * s3;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4 )\n{\n    vec2 p1 = pHyperbola( p, ab, s1 );\n    vec2 p2 = pHyperbola( p, ab, s2 );\n    vec2 p3 = pHyperbola( p, ab, s3 );\n    vec2 p4 = pHyperbola( p, ab, s4 );\n    return p1 * (1.0 - s2) + p2 * s2 * (1.0 - s3) + p3 * s3 * (1.0 - s4) + p4 * s4;\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4, in float s5 )\n{\n    vec2 p1 = pHyperbola( p, ab, s1 );\n    vec2 p2 = pHyperbola( p, ab, s2 );\n    vec2 p3 = pHyperbola( p, ab, s3 );\n    vec2 p4 = pHyperbola( p, ab, s4 );\n    vec2 p5 = pHyperbola( p, ab, s5 );\n    ", "\n    vec3  ba = b - a;\n    float baba = dot(ba,ba);\n    float babap1 = baba + 1.0;\n    float babap1r = 1.0 / babap1;\n    float baba2 = baba + 2.0;\n    float baba2r = 1.0 / baba2;\n    float baba2r2 = baba2r * baba2r;\n    float baba2r3 = baba2r2 * baba2r;\n    float baba2r4 = baba2r2 * baba2r2;\n    vec3  pa = p - a;\n    float d = dot(ba,pa);\n    float h = clamp(d,0.0,baba);\n    vec3  x = a + ba * h * babap1r;\n    vec3  y = x - p;\n    float r = mix(ra,rb,h * baba2r);\n    float d2 = dot(y,y);\n    float d = sqrt(d2);\n    float h2 = h * baba2r2;\n    float h3 = h * baba2r3;\n    float h4 = h * baba2r4;\n    return vec4(d - r, y, h2, h3);\n}\n\n//.x   distance to the sphere\n//.yzw closest point\nvec4 sdcSphere(vec3 p, vec3 c, float r)\n{\n    vec3  x = p - c;\n    float d = length(x);\n    return vec4(d - r, x);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec4 sdcCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float babap1 = baba + 1.0;\n    float babap1r = 1.0 / babap1;\n    float h = clamp(dot(ba,", "\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, float r, float h )\n{\n  return length( p.xz ) - r - abs( p.y - h*0.5 );\n}\n\nfloat sdCylinder( vec3 p, float r, float h )\n{\n  return max( length( p.xz ) - r, abs( p.y - h*0.5 ) ) - h*0.5;\n}\n\nfloat sdCone( vec3 p, float r, float h )\n{\n  return max( length( p.xz ) - r, abs( p.y - h*0.5 ) ) - h*0.5;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdQuadric", "\n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 cen, vec3 rad )\n{\n    vec3 d = abs(p-cen) - rad;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 cen, float rad, float h )\n{\n    vec2 d = abs(vec2(length(p.xz)-rad,p.y)) - vec2(0.0,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec3 cen, float rad, float h )\n{\n    float q = length(p.xz);\n    return max(q*q/(rad*rad) + p.y*p.y/(h*h) - 1.0, -p.y);\n}\n\nfloat sdTorus( vec3 p, vec3 cen, float r1, float r2 )\n{\n    vec2 q = vec2(length(p.xz)-r1,p.y);\n    return length(q)-r2;\n}\n\nfloat sdCapsule( vec3 p, vec3 cen, float r, float h )\n{\n    vec2 q = vec2(length(p.xz)-h,p.y);\n    return length(q)-r;\n}\n\nfloat sdCone( vec3 p, vec3 cen, float r, float h )\n{\n    float q = length(p.xz);\n    return max(q*q/(r*r) + p.y*p.y/(h*h) - 1.0, -p.y);\n}\n\nfloat sdCone( vec3 p, vec3 cen, float r, float h )\n{\n    float q = length(p.xz);\n    return max(q*q/(r*r) + p.y*p.y/(", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        calcDist( pos + eps.xyy, showSurface, samplePoint ) - calcDist( pos - eps.xyy, showSurface, samplePoint ),\n        calcDist( pos + eps.yxy, showSurface, samplePoint ) - calcDist( pos - eps.yxy, showSurface, samplePoint ),\n        calcDist( pos + eps.yyx, showSurface, samplePoint ) - calcDist( pos - eps.yyx, showSurface, samplePoint )\n    );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/articles/intersectors/\nfloat intersectSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// https://iquilezles.org/articles/intersectors/\nfloat intersectPlane( in vec3 ro, in vec3 rd, in vec3 no, in float h )\n{\n    float t = -( dot(ro,no) + h ) / dot(rd,no);\n    return t;\n}\n\n// https://iquilezles.org/articles/intersectors/\nfloat intersectBox( in vec3 ro, in vec3 rd, in vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min(", "\n    float res = 1.0;\n    float ph = 1e10;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( samplePoint + rd*ph ).x;\n        float k = h*h/(2.0*ph);\n        res = min( res, k );\n        ph = h;\n        if( h<0.001 ) break;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    float ph = 1e10;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( samplePoint + rd*ph ).x;\n        res = min( res, 8.0*h/ph );\n        ph = h;\n        if( h<0.001 ) break;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k )\n{\n    float res = 1.0;\n    float ph = 1e10;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( samplePoint + rd*ph ).x;\n        res = min( res, k*h/ph );\n        ph = h;\n        if( h<0.001 ) break;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k, float t )\n{\n    float res = 1.0;\n    float ph = 1e10;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( samplePoint +", "\n    vec2  q = abs(p);\n    float d = 0.0;\n    if( q.y > he )\n    {\n        d = length(q-vec2(ra,he))-rb;\n        ocl = vec2(sign(p.x),1.0);\n    }\n    else\n    {\n        d = max(q.y-he,q.x-ra);\n        ocl = vec2(sign(p.x),0.0);\n    }\n    return vec3( d, 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b, out vec2 ocl )\n{\n    vec2  q = abs(p)-b;\n    vec2  d = max(q,0.0);\n    float s = max(d.x,d.y);\n    vec2  e = vec2(step(q.y,q.x),step(q.x,q.y));\n    vec2  w = (d.x>d.y)? d.xy : d.yx;\n    vec2  c = min(0.0,w);\n    ocl = e;\n    return vec3( s, c.x, c.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r, out vec2 ocl )\n{\n    float d = length(p)-r;\n    ocl = vec2(0.0);\n    ", "\n    vec2 q = abs(vec2(length(p.xz)-ra,p.y))-rb;\n    return vec4( min(max(q.x,q.y),0.0), max(q.x,q.y), q.x>q.y? vec2(1.0,0.0) : vec2(0.0,1.0) );\n}\n\n//----------------------------------------------------------------------------------------\n//\tmain\n//----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec3 ro = vec3( 0.0, 0.0, 3.0 );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tfloat cr = cos( t*0.25 );\n\tfloat sr = sin( t*0.25 );\n\tro.xz += vec2( cr, sr )*0.5;\n\tta.xz += vec2( cr, sr )*0.5;\n\tvec3 ww = normalize( ta - ro );\n\tvec3 uu = normalize( cross( ww, vec3(0.0,1.0,0.0) ) );\n\tvec3 vv = normalize( cross( uu, ww ) );\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// ray march\n\tfloat t = 0.0;\n\tfor( int i=0; i<128; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 s = sdgTorus( pos, 0.5, 0.2 );\n\t\tif( s.x<0.001 ) break;", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat udBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 e1 = b - a, e2 = c - a;\n    vec2 v1 = p - a, v2 = p - b, v3 = p - c;\n    float s1 = e1.x*v2.y-e1.y*v2.x;\n    float s2 = e2.x*v3.y-e2.y*v3.x;\n    float s3 = v1.x*e2.y-v1.y*e2.x;\n    if( s1 >= 0.0 && s2 >= 0.0 && s3 >= 0.0 )\n    {\n        return length(cross(e1,v1)) / length(e1);\n    }\n    else\n    {\n        return min(min(udSegment(p,a,b),udSegment(p,b,c)),udSegment(p,c,a));\n    }\n}\n\nfloat udPolygon( in vec2 p, in vec2[4] v )\n{\n    float d = udSegment(p,v[0],v[1]);\n    d = min(d,udSegment(p,v[1],v[2]));\n    d = min(d,udSegment(p,v[2],v[3]));\n    d = min(d,udSegment(p,v[3],v", " return dot(v, v); }\nfloat sdCappedCylinder(in vec3 p, in float r, in float h) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h/2.0);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e) {\n  return sdCappedCylinder(p, r, h) - e;\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e, in float e2) {\n  return sdCappedCylinder(p, r, h, e) - e2;\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e, in float e2, in float e3) {\n  return sdCappedCylinder(p, r, h, e, e2) - e3;\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e, in float e2, in float e3, in float e4) {\n  return sdCappedCylinder(p, r, h, e, e2, e3) - e4;\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e, in float e2, in float e3, in float e4, in float e5) {\n  return sdCappedCylinder(p, r, h, e, e2, e3, e4) - e5;\n}\n\nfloat sdCappedCylinder(in vec3 p, in float r, in float h, in float e, in float e2, in float e3, in float e4, in float e5, in float e6) {\n  return sdCappedCylinder(p, r, h, e, e2,", "\n    vec2 d = abs(p) - maxCorner;\n    return min(max(d.x,d.y),0.0) + dot(max(d,vec2(0.0)),max(d,vec2(0.0)));\n}\n\n//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    vec2 uv2 = uv * 10.0;\n    vec2 uv3 = uv * 100.0;\n    vec2 uv4 = uv * 1000.0;\n    vec2 uv5 = uv * 10000.0;\n    vec2 uv6 = uv * 100000.0;\n    vec2 uv7 = uv * 1000000.0;\n    vec2 uv8 = uv * 10000000.0;\n    vec2 uv9 = uv * 100000000.0;\n    vec2 uv10 = uv * 1000000000.0;\n    vec2 uv11 = uv * 10000000000.0;\n    vec2 uv12 = uv * 100000000000.0;\n    vec2 uv13 = uv * 1000000000000.0;\n    vec2 uv14 = uv * 10000000000000.0;\n    vec2 uv15 = uv * 100000000000000.0;\n    vec2 uv16 = uv * 1000000000000000.0;\n    vec2 uv17 = uv * 10000000000000000.0;\n    vec2 uv18 = uv * 100000000000000000.0;\n    vec2 uv19 = uv * 1000000000000000000.0;\n    vec2 uv20 = uv * 10000000000000000000.0;\n    vec2 uv2", "\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 2.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect, float near, float far)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect, float near, float far, float x, float y, float z)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return normalize(vec3(xy, -z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float fov, float aspect, float near, float far, float x, float y, float z, float w)\n{\n    vec2 xy = uv * 2.0 - 1.0;\n    return", "\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Quaternion conjugate\nvec4 quatconj(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// Quaternion inverse\nvec4 quatinv(vec4 q)\n{\n    return quatconj(q) / dot(q, q);\n}\n\n// Quaternion rotation\nvec4 quatrot(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    return vec4(axis * s, cos(angle / 2.0));\n}\n\n// Quaternion rotation around the X axis\nvec4 quatrotx(float angle)\n{\n    float s = sin(angle / 2.0);\n    return vec4(vec3(1.0, 0.0, 0.0) * s, cos(angle / 2.0));\n}\n\n// Quaternion rotation around the Y axis\nvec4 quatroty(float angle)\n{\n    float s = sin(angle / 2.0);\n    return vec4(vec3(0.0, 1.0, 0.0) * s, cos(angle / 2.0));\n}\n\n// Quaternion rotation around the Z axis\nvec4 quatrotz(float angle)\n{\n    float s = sin(angle / 2.0);\n    return vec4(vec3(0.0, 0.0, 1.0) * s, cos(angle / 2.0));\n}\n\n// Quaternion rotation around the axis of a vector\nvec", "\n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(r.x,r.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float g )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(r,g);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 g )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(r.x,r.y,g.x,g.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float g, in float s )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(r,g,s);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in vec2 g,", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 e;\n    vec2 v0, v1, v2;\n    vec2 p0, p1, p2;\n    float s, t, a, h;\n\n    v0 = b - a; v1 = c - b; v2 = a - c;\n    p0 = p - a; p1 = p - b; p2 = p - c;\n\n    s = dot(v0,p0);\n    t = dot(v1,p1);\n    if ( s <= 0.0 && t <= 0.0 )\n        return length(p0);\n\n    s = dot(v1,p0);\n    t = dot(v2,p1);\n    if ( s <= 0.0 && t <= 0.0 )\n        return length(p1);\n\n    s = dot(v2,p0);\n    t = dot(v0,p1);\n    if ( s <= 0.0 && t <= 0.0 )\n        return length(p2);\n\n    e = v0*clamp(dot(p0,v0)/dot(v0,v0),0.0,1.0) - p0;\n    a = dot(e,e);\n    if ( a > 0.0 ) return sqrt(a);\n\n    e = v1*clamp(dot(p1,v1)/dot(", "\n    float h = max(a-d,0.0);\n    return vec2(m.x+h, m.y+h);\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    float h = max(a+d,0.0);\n    return vec2(m.x+h, m.y+h);\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    float h = max(a-d,0.0);\n    return vec2(m.x+h, m.y+h);\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 + 0.5*(a-d)/a, 0.0, 1.0 );\n    return vec2( mix( m.x, m.x+a, h ), m.y + abs(h-0.5)*a*2.0 );\n}\n\nvec2 opSmoothSubtraction( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 - 0.5*(a+d)/a, 0.0, 1.0 );\n    return vec2( mix( m.x, m.x+a, h ), m.y + abs(h-0.5)*a*2.0 );\n}\n\nvec2 opSmoothIntersection( vec2 m, float d, float a )\n{\n    float h = clamp( 0.5 - 0.5*(a-d)/a, 0.0, 1.0 );\n    return vec2( mix( m.x, m.x+a, h ), m.y + abs(h-0.5)*a*2.0 );\n}\n\nvec2 opRepetition( vec2 m, vec2 size, vec2 offset )\n{\n    vec2 p = mod(m.xy,size) - offset;\n    return vec2(p.x, p.y);\n}\n\nvec2 opRepeat( vec2 m, vec2 size )\n{\n    vec2 p", "\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) p1 = p2 = vec4(0.0);\n    else\n    {\n        h = sqrt( h );\n        p1 = vec4( -b-h, 1.0 );\n        p2 = vec4( -b+h, 1.0 );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectSphere( in vec3 ro, in vec3 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) p1 = p2 = vec4(0.0);\n    else\n    {\n        h = sqrt( h );\n        p1 = vec4( -b-h, 1.0 );\n        p2 = vec4( -b+h, 1.0 );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectPlane( in vec3 ro, in vec3 rd, in vec3 nor, out vec4 p1, out vec4 p2 )\n{\n    float h = dot(nor,rd);\n    if( abs(h)<0.001 ) p1 = p2 = vec4(0.0);\n    else\n    {\n        float d = dot(nor,ro);\n        p1 = vec4( -d, 1.0 );\n        p2 = vec4( -d-h, 1.0 );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCylinder( in vec3 ro, in vec3 rd, float rad, float h, out vec4 p1, out vec4 p2 )\n{\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - rad*", "\n    vec2  dp = p-c;\n    float l = length(dp);\n    return vec3( l-r, dp/l );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), vec2(p.x>b.x?1:p.x<-b.x?-1:0, p.y>b.y?1:p.y<-b.y?-1:0) );\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), ba*h/dot(ba,ba) );\n}\n\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 uv = triArea(p,a,b,c)/triArea(a,b,c);\n    vec2 g = mix( b-a, c-a, uv.x );\n    return vec3( length(p-a-g*uv.y), normalize(g) );\n}\n\nvec3 sdgQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 uv = quadArea(p,a,b,c,d)/quadArea(a,b,c,d);\n    vec2 g = mix( mix( b-a, c-a, uv.x ), mix( d-a, c-a, uv.x ), uv.y );\n    return vec3( length(p-a-g*uv.y), normalize(g) );\n}\n\nvec3 sdgPoly( in vec2 p, in vec", "\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  v = max(w,0.0);\n    float a = length(v);\n    float b = min(max(w.x,w.y),0.0);\n    return vec3(a+b,s*((g>0.0)?(a*g+b):vec2(dot(v,v),dot(p,v))));\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    return vec3(length(p)-r,p/length(p));\n}\n\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = a-p;\n    vec2 pb = b-p;\n    vec2 pc = c-p;\n    vec2 ea = b-a;\n    vec2 eb = c-b;\n    vec2 ec = a-c;\n    vec2 n = normalize(cross(ea,vec3(0.0)));\n    float s = dot(n,pa);\n    float t = dot(n,pb);\n    float u = dot(n,pc);\n    float d = dot(n,ea);\n    float e = dot(n,eb);\n    float f = dot(n,ec);\n    float g = dot(n,vec2(0.0));\n    float h = dot(n,p);\n    float i = dot(n,vec2(0.0));\n    float j = dot(n,vec2(0.0));\n    float k = dot(n,vec2(0.0));\n    float l = dot(n,vec2(0.0));\n    float m = dot(n,vec2(0.0));\n    float n = dot(n,vec2(0.0));\n    float o = dot(n,vec2(0.0));", "\n    p.x *= 0.57735;\n    p.y *= 0.57735;\n    p.x += 0.5*p.y;\n\n    vec3 q = abs(p);\n    vec2 w = (q.x>q.y)? vec2(q.y,q.x) : q.xy;\n    float t = max(0.0,1.0-2.0*w.y-w.x);\n    float s = 1.0-w.y-max(0.0,w.x-0.25);\n    float a = 0.5*max(0.0,w.x-0.75);\n    float b = 0.5*max(0.0,w.x-0.5);\n    float c = 0.5*max(0.0,w.x-0.25);\n    float d = 0.5*max(0.0,w.x-0.0);\n    float e = 0.5*max(0.0,w.x-0.25);\n    float f = 0.5*max(0.0,w.x-0.5);\n    float g = 0.5*max(0.0,w.x-0.75);\n    float h = 0.5*max(0.0,w.x-1.0);\n    float i = 0.5*max(0.0,w.x-1.25);\n    float j = 0.5*max(0.0,w.x-1.5);\n    float k = 0.5*max(0.0,w.x-1.75);\n    float l = 0.5*max(0.0,w.x-2.0);\n    float m = 0.5*max(0.0,w.x-2.25);\n    float n = 0.5*max(0.0,w.x-2.5);\n    float o = 0.5*max(0.0,w.x-2.", "\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat g(float a1, float b1, float a2, float b2, float x) {\n  return a1 * x + b1 + a2 * x * x + b2 * x;\n}\n", "\n  return pow(pow(abs(x), n) + pow(abs(a * sin(b * x)), n), 1.0 / n);\n}\n\n// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n                float noise = 0.0;\n                float scale = 1.0;\n                for(int i = 0; i < 5; i++){\n                    noise += scale * noise2(uv * scale);\n                    scale *= 0.5;\n                }\n                return noise;\n            }\n\n            float paper(vec2 uv){\n                float noise = paperNoise(uv);\n                float paper = 0.0;\n                paper += noise;\n                paper += noise * 0.5;\n                paper += noise * 0.25;\n                paper += noise * 0.125;\n                return paper;\n            }\n\n            vec3 paperColor(vec2 uv){\n                float noise = paper(uv);\n                vec3 color = vec3(noise);\n                return color;\n            }\n\n            vec3 paperColor(vec2 uv, float scale){\n                float noise = paper(uv * scale);\n                vec3 color = vec3(noise);\n                return color;\n            }\n\n            vec3 paperColor(vec2 uv, float scale, float alpha){\n                float noise = paper(uv * scale);\n                vec3 color = vec3(noise);\n                color.a = alpha;\n                return color;\n            }\n\n            vec3 paperColor(vec2 uv, float scale, float alpha, float offset){\n                float noise = paper(uv * scale);\n                vec3 color = vec3(noise);\n                color.a = alpha;\n                color.rgb += offset;\n                return color;\n            }\n\n            vec3 paperColor(vec2 uv, float scale, float alpha, float offset, float contrast){\n                float noise = paper(uv * scale);\n                vec3 color = vec3(noise);\n                color.a = alpha;\n                color.rgb += offset;\n                color.rgb *= contrast;\n                return color;\n            }\n\n            vec3 paperColor(vec2 uv, float scale, float alpha, float offset, float contrast, float brightness){\n                float noise = paper(uv * scale);\n                vec3 color = vec3(noise);\n                color.a = alpha;\n                color.rgb +=", "\n    vec3 p = vec3(x,y,0);\n    vec3 q = vec3(x,y,0);\n    vec3 r = vec3(x,y,0);\n    vec3 s = vec3(x,y,0);\n    vec3 t = vec3(x,y,0);\n    vec3 u = vec3(x,y,0);\n    vec3 v = vec3(x,y,0);\n    vec3 w = vec3(x,y,0);\n    vec3 x = vec3(x,y,0);\n    vec3 y = vec3(x,y,0);\n    vec3 z = vec3(x,y,0);\n    vec3 a = vec3(x,y,0);\n    vec3 b = vec3(x,y,0);\n    vec3 c = vec3(x,y,0);\n    vec3 d = vec3(x,y,0);\n    vec3 e = vec3(x,y,0);\n    vec3 f = vec3(x,y,0);\n    vec3 g = vec3(x,y,0);\n    vec3 h = vec3(x,y,0);\n    vec3 i = vec3(x,y,0);\n    vec3 j = vec3(x,y,0);\n    vec3 k = vec3(x,y,0);\n    vec3 l = vec3(x,y,0);\n    vec3 m = vec3(x,y,0);\n    vec3 n = vec3(x,y,0);\n    vec3 o = vec3(x,y,0);\n    vec3 p = vec3(x,y,0);\n    vec3 q = vec3(x,y,0);\n    vec3 r = vec3(x,y,0);\n    vec3 s = vec3(x,y,0);\n    vec3 t = vec3(x,y,0);\n    vec3 u = vec3(x,y,0);\n    vec3 v = vec3(x,y,0);\n    vec3 w = vec3(x,y,0);\n    ", "\n    return length(p-c)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a )\n{\n    vec2  q = p - vec2(cos(a),sin(a))*vec2(r);\n    float k = dot(q,q);\n    float l = length(q);\n    return (l-r)*min(l,r)/k;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float b )\n{\n    vec2  q = p - vec2(cos(a),sin(a))*vec2(r);\n    float k = dot(q,q);\n    float l = length(q);\n    return (l-r)*min(l,r)/k;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float b, in float c )\n{\n    vec2  q = p - vec2(cos(a),sin(a))*vec2(r);\n    float k = dot(q,q);\n    float l = length(q);\n    return (l-r)*min(l,r)/k;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float b, in float c, in float d )\n{\n    vec2  q = p - vec2(cos(a),sin(a))*vec2(r);\n    float k = dot(q,q);\n    float l = length(q);\n    return (l-r)*min(l,r)/k;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float b, in float c, in float d, in float e )\n{\n    vec2  q = p - vec2(cos(a),sin(a))*vec2(r);\n    float k = dot(q,q);\n    float l = length(q);\n    return (l-r)*min(l,r", "\n  vec2 d = abs(p-c) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a )\n{\n  p.x -= cos(a);\n  p.y -= sin(a);\n  return length(p)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float s )\n{\n  p.x -= cos(a);\n  p.y -= sin(a);\n  return length(p)-r*s;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float s, in float t )\n{\n  p.x -= cos(a);\n  p.y -= sin(a);\n  return length(p)-r*s*t;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float s, in float t, in float o )\n{\n  p.x -= cos(a);\n  p.y -= sin(a);\n  return length(p)-r*s*t*o;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float s, in float t, in float o, in float f )\n{\n  p.x -= cos(a);\n  p.y -= sin(a);\n  return length(p)-r*s*t*o*f;\n}\n\nfloat sdCircle( in vec2 p, in float r, in float a, in float s, in float t, in float o, in float f, in float g )\n{\n  ", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 e1 = b - a, e2 = c - a;\n    vec2 v0 = a - p, v1 = e1, v2 = e2;\n    vec2 c1 = v0 - v1 * clamp( dot(v0,v1)/dot(v1,v1), 0.0, 1.0 ),\n         c2 = v0 - v2 * clamp( dot(v0,v2)/dot(v2,v2), 0.0, 1.0 );\n    float s = sign( dot(v1,v2) ),\n          d1 = dot( c1, c1 ),\n          d2 = dot( c2, c2 );\n    return s*sqrt( min(s*d1,s*d2) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRhombus( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p);\n    return max( dot(q,b), length(q", "\n    vec2  ab = b-a;\n    float l2 = dot(ab,ab);\n    float l  = sqrt(l2);\n    vec2  n  = vec2(-ab.y,ab.x)/l;\n    vec2  ap = p-a;\n    float t  = dot(ap,ab)/l2;\n    vec2  q  = a + t*ab;\n    vec2  v  = p - q;\n    float d2 = dot(v,v);\n    float d  = sqrt(d2);\n    float s  = sign(dot(v,n));\n    float t2 = clamp(t,0.0,1.0);\n    float t1 = clamp(t-s*h/l,0.0,1.0);\n    float d1 = d2 - d2min;\n    float d0 = mix(d,h,t2)*s;\n    float dm = mix(d0,d1,t1);\n    return vec2(dm,s);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    return sdSqArc(p,a,b,h,0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b )\n{\n    return sdSqArc(p,a,b,0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in float h )\n{\n    return sdSqArc(p,a,a+vec2(1.0,0.0),h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a )\n{\n    return sdSqArc(p,a,a+vec2(", "\n    float d = 1e10;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s =", "\n    float a = 0.5;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.5;\n    float e = 0.5;\n    float f = 0.5;\n    float g = 0.5;\n    float h = 0.5;\n    float i = 0.5;\n    float j = 0.5;\n    float k = 0.5;\n    float l = 0.5;\n    float m = 0.5;\n    float n = 0.5;\n    float o = 0.5;\n    float p = 0.5;\n    float q = 0.5;\n    float r = 0.5;\n    float s = 0.5;\n    float t = 0.5;\n    float u = 0.5;\n    float v = 0.5;\n    float w = 0.5;\n    float x = 0.5;\n    float y = 0.5;\n    float z = 0.5;\n    float aa = 0.5;\n    float bb = 0.5;\n    float cc = 0.5;\n    float dd = 0.5;\n    float ee = 0.5;\n    float ff = 0.5;\n    float gg = 0.5;\n    float hh = 0.5;\n    float ii = 0.5;\n    float jj = 0.5;\n    float kk = 0.5;\n    float ll = 0.5;\n    float mm = 0.5;\n    float nn = 0.5;\n    float oo = 0.5;\n    float pp = 0.5;\n    float qq = 0.5;\n    float rr = 0.5;\n    float ss = 0.5;\n    float tt = 0.5;\n    float uu = 0.5;\n    float vv = 0.5;\n    float ww = 0.5;\n    float xx = 0.", "\n    float d = 0.0;\n    float t = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        t += 0.1;\n        d = max( d, abs(length(p)-t)-0.05 );\n    }\n    return d;\n}\n\n//-----------------------------------------------------\n\n// 2D rotation\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s, s,c);\n}\n\n//-----------------------------------------------------\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    return texture( iChannel0, x*.01 ).x;\n}\n\n//-----------------------------------------------------\n\n// 2D fBm\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//-----------------------------------------------------\n\n// 2D fBm\nfloat fbm2( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//---------", "\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = 1.0 - abs(f.x - 0.5);\n    float b = 1.0 - abs(f.y - 0.5);\n    float c = 1.0 - max(a, b);\n    col = vec3(a, b, c);\n    return col;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern2( in vec2 uv )\n{\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = 1.0 - abs(f.x - 0.5);\n    float b = 1.0 - abs(f.y - 0.5);\n    float c = 1.0 - max(a, b);\n    col = vec3(a, b, c);\n    return col;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern3( in vec2 uv )\n{\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = 1.0 - abs(f.x - 0.5);\n    float b = 1.0 - abs(f.y - 0.5);\n    float c = 1.0 - max(a, b);\n    col = vec3(a, b, c);\n    return col;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern4( in vec2 uv )\n{\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    return a + ba*h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r )\n{\n    return c + normalize(p-c)*r;\n}\n\n// Closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float th )\n{\n    vec2 pa = p-a, ba = b-a, ca = c-a;\n    vec2 pb = p-b, cb = c-b, ab = a-b;\n    vec2 pc = p-c, ac = a-c, bc = b-c;\n\n    float s = sign(dot(ba,ca));\n    float d = dot(ca,ca);\n    float t = clamp( dot(pa,ca)/d, 0.0, 1.0 );\n    float u = clamp( dot(pb,ca)/d, 0.0, 1.0 );\n    float v = clamp( dot(pc,ca)/d, 0.0, 1.0 );\n\n    vec2 cp = mix( mix( a+ca*t, b+ca*u, step(t,u) ),\n                   mix( b+ca*u, c+ca*v, step(u,v) ),\n                   step(t,u) );\n\n    return cp;\n}\n\n// Closest point on quad\nvec2 cloQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float th )\n{\n    vec", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded rectangle\nfloat sdRRectangle( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 e;\n    vec2 v0, v1, v2;\n    float m, n, aa, bb, t;\n\n    v0 = b - a; v1 = c - b; v2 = a - c;\n    e = a - p; m = dot(e,v0); aa = dot(v0,v0);\n    if( m <= 0.0 ) return length(e);\n    n = dot(e,v1); bb = dot(v1,v1);\n    if( n <= 0.0 ) return length(e-v0);\n    t = dot(e,v2);\n    if( t <= 0.0 ) return length(e-v0-v1);\n    m = m*bb - n*t;\n    if( (m >= 0.0) && (m <= aa*bb) )\n    {\n        n = n*aa - t*m;\n        if( n >= ", "\n    return p - clamp( p, -b, b ) + clamp( abs( p ) - b, -r, r );\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    return length( cloRoundBox( p, b, r ) ) - r;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n    return length( cloRoundBox( p.xy, b.xy, r ) ) - r;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    return length( cloRoundBox( p.xy, b.xy, r.x ) ) - r.x;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 c )\n{\n    return length( cloRoundBox( p.xy, b.xy, r.x ) ) - r.x;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 c, in vec3 t )\n{\n    return length( cloRoundBox( p.xy, b.xy, r.x ) ) - r.x;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 c, in vec3 t, in vec3 s )\n{\n    return length( cloRoundBox( p.xy, b.xy, r.x ) ) - r.x;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r, in vec3 c, in vec3 t, in vec3 s, in vec3 h )\n{\n    return length( cloRoundBox( p.xy, b.xy, r.x ) ) - r.x;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p,", "\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// signed distance function\nfloat sdf(vec2 p) {\n  float d = 1000.0;\n  float r = 0.0;\n  for (int i = 0; i < 10; i++) {\n    float a = float(i) * 0.1;\n    float b = float(i) * 0.1;\n    float c = float(i) * 0.1;\n    float e = float(i) * 0.1;\n    float f = float(i) * 0.1;\n    float g = float(i) * 0.1;\n    float h = float(i) * 0.1;\n    float j = float(i) * 0.1;\n    float k = float(i) * 0.1;\n    float l = float(i) * 0.1;\n    float m = float(i) * 0.1;\n    float n = float(i) * 0.1;\n    float o = float(i) * 0.1;\n    float p = float(i) * 0.1;\n    float q = float(i) * 0.1;\n    float s = float(i) * 0.1;\n    float t = float(i) * 0.1;\n    float u = float(i) * 0.1;\n    float v = float(i) * 0.1;\n    float w = float(i) * 0.1;\n    float x = float(i) * 0.1;\n    float y = float(i) * 0.1;\n    float z = float(i) * 0.1;\n    float aa = float(i) * 0.1;\n    float bb = float(i) * 0.1;\n    float cc = float(i) * 0.1;\n    float dd = float(i) * 0.", "\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in float r )\n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r;\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - max(r.x,r.y);\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - max(r.x,max(r.y,r.z));\n}\n\n// signed distance to rounded box\nfloat sdRoundBox( in vec4", "\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D OpenSimplex Noise\n// by Stefan Gustavson\n//\n// Adapted from Stefan Gustavson's Java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this\n// code works.\n//\n// Sean McCullough ported the code to WebGL, as well as\n// adding the 3D and 4D variants, which are most of\n// what this library is about.\n//\n// License: Public Domain.\n//\n// Up to you not to mess it up.\n\n// Contains all code for 2D, 3D and 4D OpenSimplex Noise.\n\nvec3 simplex3(vec3 p) {\n    const vec3  m = vec3(57, 149, 285);\n    const vec3  n = vec3(1, 2, 3);\n\n    // First corner\n    vec3 i0 = floor(p + dot(p, n));\n    vec3 x0 = p - i0 + dot(i0, n);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xy;\n    //   x1 = x0 - i1  + 1.0 * C.xy;\n    //   x2 = x0 - i2  + 2.0 * C.xy;\n    //   x3 = x0 - 1.0 + 3.0 * C.xy;\n    vec3 x1", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(random(i + vec2(0.0, 0.0)),\n                   random(i + vec2(1.0, 0.0)), u.x),\n               mix(random(i + vec2(0.0, 1.0)),\n                   random(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 p)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 10; ++i)\n    {\n        v += a * noise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat fbm2(vec2 p)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n", "\n  st = vec2( dot(st,vec2(127.1,311.7)),\n            dot(st,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  // Four corners in 2D of a tile\n  float a = dot(random2(i), f);\n  float b = dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float c = dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float d = dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n\n  // Smooth Interpolation\n\n  // Cubic Hermine Curve.  Same as SmoothStep()\n  vec2 u = f*f*(3.0-2.0*f);\n  // u = smoothstep(0.,1.,f);\n\n  // Mix 4 coorners percentages\n  return mix(a, b, u.x) +\n          (c - a)* u.y * (1.0 - u.x) +\n          (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 st) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 0.0;\n  // octaves\n  for (int i = 0; i < 6; i++) {\n    value += amplitude * noise(st);\n    st *= 2.0;\n    amplitude", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float a = triLerp(f,\n                      triGrad(i + vec2(0.0, 0.0)),\n                      triGrad(i + vec2(1.0, 0.0)));\n    float b = triLerp(f,\n                      triGrad(i + vec2(0.0, 1.0)),\n                      triGrad(i + vec2(1.0, 1.0)));\n    return triLerp(f.x, a, b);\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float a = triLerp(f,\n                      triGrad(i + vec3(0.0, 0.0, 0.0)),\n                      triGrad(i + vec3(1.0, 0.0, 0.0)));\n    float b = triLerp(f,\n                      triGrad(i + vec3(0.0, 1.0, 0.0)),\n                      triGrad(i + vec3(1.0, 1.0, 0.0)));\n    float c = triLerp(f,\n                      triGrad(i + vec3(0.0, 0.0, 1.0)),\n                      triGrad(i + vec3(1.0, 0.0, 1.0)));\n    float d = triLerp(f,\n                      triGrad(i + vec3(0.0, 1.0, 1.0)),\n                      triGrad(i + vec3(1.0, 1.0", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 1; i++)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D Perlin Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = dot(i, i);\n    float b = dot(i, i + vec2(1.0, 0.0));\n    float c = dot(i, i + vec2(0.0, 1.0));\n    float d = dot(i, i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat fbm2(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03", "\n    float s = 0.0;\n    float a = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        s += cos(x + a);\n        a += 1.0;\n    }\n    return s;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Create a 2D grid of points\n    vec2 grid = vec2(100.0, 100.0);\n    vec2 cell = floor(uv * grid);\n    vec2 cellCenter = (cell + 0.5) / grid;\n    vec2 cellUV = fract(uv * grid);\n\n    // Calculate the distance to the center of the cell\n    float distance = length(cellUV - 0.5);\n\n    // Calculate the pattern value\n    float pattern = pattern(cell);\n\n    // Calculate the color based on the distance and pattern\n    color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), distance);\n    color = mix(color, vec3(0.0, 1.0, 0.0), pattern);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default fragmentShader;", "\n    float theta = atan(x, y);\n    float phi = acos(y / sin(theta));\n    return (sin(theta) * cos(phi) + sin(theta) * sin(phi) + cos(theta)) / 6.0;\n}\n\nfloat texelSolidAngle(float x, float y, float width, float height)\n{\n    float nextX = x + 1.0;\n    float nextY = y + 1.0;\n    float leftX = x - 0.5;\n    float rightX = nextX - 0.5;\n    float topY = nextY - 0.5;\n    float bottomY = y - 0.5;\n    float a = areaElement(leftX * width, bottomY * height);\n    float b = areaElement(rightX * width, bottomY * height);\n    float c = areaElement(leftX * width, topY * height);\n    float d = areaElement(rightX * width, topY * height);\n    return abs(d + a - b - c);\n}\n\n//\n// This function is adapted from the AMD cubemapgen source code:\n// https://code.google.com/archive/p/cubemapgen/\n//\nvec3 getSphericalCoordinates(vec2 uv)\n{\n    float theta = 2.0 * PI * uv.x;\n    float phi = acos(2.0 * uv.y - 1.0);\n    return vec3(theta, phi, 1.0);\n}\n\n//\n// This function is adapted from the AMD cubemapgen source code:\n// https://code.google.com/archive/p/cubemapgen/\n//\nvec3 getDirection(vec2 uv)\n{\n    vec3 sph = getSphericalCoordinates(uv);\n    float theta = sph.x;\n    float phi = sph.y;\n    return vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n}\n\n//\n// This function is adapted from the AMD cubemapgen source code:\n//", "\n  p3 = fract(p3 * vec3(.1031,.11369,.13787));\n  p3 += dot(p3, p3.yxz + 19.19);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec3 hash33(float p) {\n  return hash33(vec3(p, p + 1.0, p + 2.0));\n}\n\nfloat noise(vec3 p) {\n  vec3 p0 = floor(p);\n  vec3 w = fract(p);\n  vec3 ww = w * w * (3.0 - 2.0 * w);\n  vec3 d0 = hash33(p0);\n  vec3 d1 = hash33(p0 + 1.0);\n  return mix(mix(mix(dot(d0, w), dot(d1, w - vec3(1.0)), ww.x),\n                 mix(dot(d0, w - vec3(0.0, 0.0, 1.0)),\n                      dot(d1, w - vec3(1.0, 0.0, 1.0)), ww.x), ww.y),\n              mix(mix(dot(d0, w - vec3(0.0, 1.0, 0.0)),\n                      dot(d1, w - vec3(1.0, 1.0, 0.0)), ww.x),\n                 mix(dot(d0, w - vec3(0.0, 1.0, 1.0)),\n                      dot(d1, w - vec3(1.0, 1.0, 1.0)), ww.x), ww.y), ww.z);\n}\n\nfloat fbm(vec3 p) {\n  float f = 0.0;\n  float w = 0.5;\n  for (int i = 0; i < 5; i++) {\n    f +=", "\n    vec3 f = floor(p);\n    vec3 s = f + dot(f, vec3(1.0, 3.0, 5.0)) * (1.0 / 9.0);\n    vec3 u = p - f;\n    vec3 v = u - 1.0 + 2.0 * fract(s * vec3(7.0, 15.0, 31.0));\n    vec3 d = abs(v);\n    vec3 g = step(v.yzx, v);\n    vec3 l = 1.0 - g;\n    vec3 h = min(max(g.xzy, g.yzx), 1.0);\n    vec3 m = max(max(g.xzy, g.yzx), 0.0);\n    vec3 i1 = mod289(f + s + g);\n    vec3 i2 = mod289(f + s + l);\n    vec3 i3 = mod289(f + s + h);\n    vec3 i4 = mod289(f + s + m);\n    vec3 j1 = mod7(i1);\n    vec3 j2 = mod7(i2);\n    vec3 j3 = mod7(i3);\n    vec3 j4 = mod7(i4);\n    vec4 x1 = vec4(f.x) + j1 * (1.0 / 7.0);\n    vec4 y1 = vec4(f.y) + j1.yzx * (1.0 / 7.0);\n    vec4 z1 = vec4(f.z) + j1.zxy * (1.0 / 7.0);\n    vec4 x2 = vec4(f.x) + j2 * (1.0 / 7.0);\n    vec4 y2 = vec4(f.y) + j2.yzx * (1.0 / 7.0);\n    vec4 z2 = vec4(f.z) + j2.zxy * (1.0 / 7.0);\n    vec4 x3 = vec4(f.x) + j3", "\n    return fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))));\n}\n\n// a random number between 0 and 1\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// a random number between -1 and 1\nfloat rand2(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453)*2.0-1.0;\n}\n\n// a random number between 0 and 1\nfloat rand3(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// a random number between -1 and 1\nfloat rand4(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453)*2.0-1.0;\n}\n\n// a random number between 0 and 1\nfloat rand5(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// a random number between -1 and 1\nfloat rand6(vec2 co)\n{\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453)*2.0-1.0;\n}\n\n// a random number between 0 and 1\nfloat rand7(", "\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n  vec2 e;\n  vec2 ab = b-a;\n  vec2 cb = b-c;\n  vec2 ca = a-c;\n  vec2 ap = p-a;\n  vec2 bp = p-b;\n  vec2 cp = p-c;\n  float s = sign(dot(cross(ca,cb),cp));\n  float h = dot(ap,ab);\n  float k = dot(ap,ca);\n  float l = dot(bp,cb);\n  float m = dot(bp,ca);\n  float n = dot(cp,ab);\n  float o = dot(cp,cb);\n  float det = ab.x*ca.y-ab.y*ca.x;\n  float t = s*det;\n  float u = s*(h*ca.y-k*ab.y)/t;\n  float v = s*(l*ca.y-m*cb.y)/t;\n  float w = s*(n*cb.y-o*ab.y)/t;\n  if( u>=0.0 && v>=0.0 && w>=0.0 )\n  {\n    e = vec2(0.0);\n  }\n  else\n  {\n    e = vec2(1e10);\n    if( u<0.0 ) e = min(e,abs(ap));\n    if( v<0.0", "\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r.x;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 d = abs(p)-b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0)) - r.x;\n}\n\n//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "\n    vec3 proj_normal = normalize(normal);\n    vec3 proj_center_vec = center - proj_normal * proj_info.x;\n    proj_center = vec2(dot(proj_center_vec, vec3(1.0, 0.0, 0.0)), dot(proj_center_vec, vec3(0.0, 1.0, 0.0)));\n    vec3 proj_major = vec3(0.0, 0.0, 1.0) - proj_normal * proj_info.y;\n    vec3 proj_minor = vec3(0.0, 1.0, 0.0) - proj_normal * proj_info.y;\n    major = vec2(dot(proj_major, vec3(1.0, 0.0, 0.0)), dot(proj_major, vec3(0.0, 1.0, 0.0)));\n    minor = vec2(dot(proj_minor, vec3(1.0, 0.0, 0.0)), dot(proj_minor, vec3(0.0, 1.0, 0.0)));\n}\n\nfloat disk_intersect(\n    vec2 proj_center,\n    vec2 major,\n    vec2 minor,\n    vec2 ray_origin,\n    vec2 ray_dir\n){\n    vec2 ray_origin_rel = ray_origin - proj_center;\n    vec2 ray_dir_rel = ray_dir;\n    vec2 a = ray_origin_rel;\n    vec2 b = ray_dir_rel;\n    vec2 c = proj_center;\n    vec2 d = ray_origin_rel - ray_dir_rel * dot(ray_origin_rel, ray_dir_rel) / dot(ray_dir_rel, ray_dir_rel);\n    vec2 e = proj_center - ray_dir_rel * dot(proj_center, ray_dir_rel) / dot(ray_dir_rel, ray_dir_rel);\n    vec2 f = ray_origin_rel - ray_dir_rel *", "\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash12(i + vec2(0.0, 0.0)),\n                   Hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash12(i + vec2(0.0, 1.0)),\n                   Hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 10; ++i)\n    {\n        v += a * noise(p);\n        p = p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat pattern(vec2 p)\n{\n    return fbm(p * 0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    col += pattern(p * 100.0);\n    fragColor = vec4(col,1.0);\n", "\n    float n = 1.0/bn;\n    float a = an*n;\n    float c = cos(a);\n    float s = sin(a);\n    float c2 = c*c;\n    float s2 = s*s;\n    float c3 = c*c2;\n    float s3 = s*s2;\n    float c4 = c2*c2;\n    float s4 = s2*s2;\n    float c5 = c*c4;\n    float s5 = s*s4;\n    float c6 = c2*c4;\n    float s6 = s2*s4;\n    float c7 = c*c6;\n    float s7 = s*s6;\n    float c8 = c4*c4;\n    float s8 = s4*s4;\n    float c9 = c*c8;\n    float s9 = s*s8;\n    float c10 = c5*c5;\n    float s10 = s5*s5;\n    float c11 = c*c10;\n    float s11 = s*s10;\n    float c12 = c6*c6;\n    float s12 = s6*s6;\n    float c13 = c*c12;\n    float s13 = s*s12;\n    float c14 = c7*c7;\n    float s14 = s7*s7;\n    float c15 = c*c14;\n    float s15 = s*s14;\n    float c16 = c8*c8;\n    float s16 = s8*s8;\n    float c17 = c*c16;\n    float s17 = s*s16;\n    float c18 = c9*c9;\n    float s18 = s9*s9;\n    float c19 = c*c18;\n    float s19 = s*s18;\n    float c20 = c10*c10;\n    float s20 = s10*s10;\n    float", "\n    vec3 e = vec3(0.001,0.0,0.0);\n    return normalize( vec3(\n        map( p+e.xyy )-map( p-e.xyy ),\n        map( p+e.yxy )-map( p-e.yxy ),\n        map( p+e.yyx )-map( p-e.yyx ) ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF sphere normals\nvec3 normal2( vec3 p )\n{\n    vec3 e = vec3(0.001,0.0,0.0);\n    return normalize( vec3(\n        map2( p+e.xyy )-map2( p-e.xyy ),\n        map2( p+e.yxy )-map2( p-e.yxy ),\n        map2( p+e.yyx )-map2( p-e.yyx ) ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF sphere normals\nvec3 normal3( vec3 p )\n{\n    vec3 e = vec3(0.001,0.0,0.0);\n    return normalize( vec3(\n        map3( p+e.xyy )-map3( p-e.xyy ),\n        map3( p+e.yxy )-map3( p-e.yxy ),\n        map3( p+e.yyx )-map3( p-e.yyx ) ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF sphere normals\nvec3 normal4( vec3 p )\n{\n    vec3 e = vec3(0.001,0.0,0.0);\n    return normalize( vec3(\n        map4( p+e.xyy )-map4( p-e.xyy ),\n        map4( p+e.yxy )-map4( p-e.yxy ),\n        map4( p+e.yyx )-map4( p-e.yyx ) ) );", "\n    float res = 1.0;\n    float t = t0;\n    for(int i=0; i<128; i++)\n    {\n        float h = map(ro + rd*t);\n        res = min(res, 4.0*h/t);\n        t += h;\n        if(h<0.001 || t>t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// MAIN\n//----------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    float cr = cos(iTime*0.1);\n    float sr = sin(iTime*0.1);\n    ro.xz += vec2(cr, sr)*0.5;\n    ta.xz += vec2(cr, sr)*0.5;\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy-0.5*iResolution.xy))/iResolution.y;\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for(int i=0; i<128; i++)\n    {\n        vec3 pos", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.11*float(i)/4.0;\n        vec3 aopos = pos + sca*hr*nor;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*hr;\n        sca *= 0.95;\n    }\n    return clamp( 0.5 + occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcLight( in vec3 pos, in vec3 nor, in vec3 lightPos )\n{\n    vec3 lightDir = lightPos-pos;\n    float lightDist = length(lightDir);\n    lightDir /= lightDist;\n\n    float att = 1.0/exp(lightDist*lightDist*0.01);\n\n    float dif = clamp(dot(nor,lightDir),0.0,1.0);\n\n    vec3 hal = normalize(lightDir - reflect(lightDir,nor));\n    float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0);\n\n    float fre = pow( clamp(1.0+dot(nor,lightDir),0.0,1.0), 2.0 );\n\n    return 0.5*(0.2+0.8*dif*att + 0.5*spe*att);\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nvec3 calcColor( in vec3 pos, in vec3 nor, in vec3 lightPos )\n{\n    float occ = calcAO( pos, nor );\n    float amb = 0.5 + 0.5*dot( nor, vec3(0.0,1.0,0.0) );\n    float lig = calcLight( pos, nor, lightPos );\n    ", "\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n    axis.x * axis.x * oc + c,\n    axis.y * axis.x * oc + axis.z * s,\n    axis.z * axis.x * oc - axis.y * s,\n    axis.x * axis.y * oc - axis.z * s,\n    axis.y * axis.y * oc + c,\n    axis.z * axis.y * oc + axis.x * s,\n    axis.x * axis.z * oc + axis.y * s,\n    axis.y * axis.z * oc - axis.x * s,\n    axis.z * axis.z * oc + c\n  );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat4 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    axis.x * axis.x * oc + c,\n    axis.y * axis.x * oc + axis.z * s,\n    axis.z * axis.x * oc - axis.y * s,\n    0.0,\n    axis.x * axis.y * oc - axis.z * s,\n    axis.y * axis.y * oc + c,\n    axis.z * axis.y * oc + axis.x * s,\n    0.0,\n    axis.x * axis.z * oc + axis.y * s,\n    axis.y * axis.z * oc - axis.x * s,\n    axis.z * axis.z * oc + c,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat4 createRotationMatrixAxisAngle(vec3 axis, float angle, vec", "\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse) {\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float zoom) {\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float zoom, float fov) {\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float zoom, float fov, float near) {\n  vec2 uv = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;\n  vec3 ray = normalize(vec3(uv, 1.0));\n  ray.z *= aspect;\n  return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float zoom, float fov, float near, float far) {\n  vec2 uv = (fragCoord.xy / resolution", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 15.787))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233, 15.787, 78.233))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co, float time){\n    return fract(sin(dot(co.xy + vec2(time, time), vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co, float time){\n    return fract(sin(dot(co.xyz + vec3(time, time, time), vec3(12.9898,78.233, 15.787))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4d(vec4 co, float time){\n    return fract(sin(dot(co.xyzw + vec4(time, time, time, time), vec4(12.9898,78.233, 15.787, 78.233))) * 43758.54", "\n    float n = p.x * 12.949 + p.y * 78.233 + p.z * 43758.5453;\n    return fract(sin(n) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    float n = p.x * 12.949 + p.y * 78.233;\n    return fract(sin(n) * 43758.5453);\n}\n\n// Noise function\nfloat noise(vec3 p){\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    pf = pf * pf * (3.0 - 2.0 * pf);\n    vec2 uv = (pi.xy + vec2(37.0, 17.0) * pi.z) + pf.xy;\n    vec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n    return mix(rg.x, rg.y, pf.z);\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec3 p){\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// 3D Perlin Noise\nfloat noise3d(vec3 p){\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n    pf = pf * pf * (3.0 - 2.0 * pf);\n    vec2 uv = (pi.xy + vec2(37.0, 17.", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with periodic boundary conditions\nfloat noise3d_periodic(vec3 x, vec3 period){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    n = mod(n, period.x * period.y * period.z);\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with periodic boundary conditions\nfloat noise3d_periodic_octave(vec3 x, vec3 period, float scale, float oct", "\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * snoise3d(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat superfractalnoise3d(vec3 p){\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * fractalnoise3d(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat superfractalnoise3d2(vec3 p){\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * fractalnoise3d2(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat superfractalnoise3d3(vec3 p){\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * fractalnoise3d3(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat superfractalnoise3d4(vec3 p){\n    float n = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += a * fractalnoise3d4(p);\n        p *= 2.0;\n        a *= 0.5;\n    }", "\n    float amp = 1.0;\n    float freq = 0.0;\n    float total = 0.0;\n    for(int i = 0; i < 8; i++){\n        total += amp * noise(p);\n        freq += 1.0;\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return total;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t, float s){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t, float s, float h){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t, float s, float h, float d){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t, float s, float h, float d, float a){\n    float c = cloudsFBM(p);\n    c = smoothstep(0.6, 0.7, c);\n    return c;\n}\n\n// A simple function to generate clouds\nfloat clouds(vec3 p, float t, float s, float h, float d, float a, float b){\n    float c = cloudsFBM(p);\n    c = smooth", "\n    vec3 p = pos;\n    float density = 0.0;\n    float color = 0.0;\n    float density_sum = 0.0;\n    float color_sum = 0.0;\n    float density_sum_2 = 0.0;\n    float color_sum_2 = 0.0;\n    float density_sum_3 = 0.0;\n    float color_sum_3 = 0.0;\n    float density_sum_4 = 0.0;\n    float color_sum_4 = 0.0;\n    float density_sum_5 = 0.0;\n    float color_sum_5 = 0.0;\n    float density_sum_6 = 0.0;\n    float color_sum_6 = 0.0;\n    float density_sum_7 = 0.0;\n    float color_sum_7 = 0.0;\n    float density_sum_8 = 0.0;\n    float color_sum_8 = 0.0;\n    float density_sum_9 = 0.0;\n    float color_sum_9 = 0.0;\n    float density_sum_10 = 0.0;\n    float color_sum_10 = 0.0;\n    float density_sum_11 = 0.0;\n    float color_sum_11 = 0.0;\n    float density_sum_12 = 0.0;\n    float color_sum_12 = 0.0;\n    float density_sum_13 = 0.0;\n    float color_sum_13 = 0.0;\n    float density_sum_14 = 0.0;\n    float color_sum_14 = 0.0;\n    float density_sum_15 = 0.0;\n    float color_sum_15 = 0.0;\n    float density_sum_16 = 0.0;\n    float color_sum_16 = 0.0;\n    float density_sum_17 = 0.0;\n    float color_sum_17 = ", "\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float light = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float shadow = 1.0;\n    float coverage = 0.0;\n    float coverage2 = 0.0;\n    float coverage3 = 0.0;\n    float coverage4 = 0.0;\n    float coverage5 = 0.0;\n    float coverage6 = 0.0;\n    float coverage7 = 0.0;\n    float coverage8 = 0.0;\n    float coverage9 = 0.0;\n    float coverage10 = 0.0;\n    float coverage11 = 0.0;\n    float coverage12 = 0.0;\n    float coverage13 = 0.0;\n    float coverage14 = 0.0;\n    float coverage15 = 0.0;\n    float coverage16 = 0.0;\n    float coverage17 = 0.0;\n    float coverage18 = 0.0;\n    float coverage19 = 0.0;\n    float coverage20 = 0.0;\n    float coverage21 = 0.0;\n    float coverage22 = 0.0;\n    float coverage23 = 0.0;\n    float coverage24 = 0.0;\n    float coverage25 = 0.0;\n    float coverage26 = 0.0;\n    float coverage27 = 0.0;\n    float coverage28 = 0.0;\n    float coverage29 = 0.0;\n    float coverage30 = 0.0;\n    float coverage31 = 0.0;\n    float coverage32 = 0.0;\n    float coverage33 = 0.0;\n    float coverage34 = 0.0;\n    float coverage35 = 0.0;\n    float coverage3", "\n    vec3 color = vec3(0.0);\n    vec3 dir = normalize(pointEnd - pointStart);\n    vec3 point = pointStart;\n    float step = 0.0;\n    float fog = 0.0;\n    float fogStart = 0.0;\n    float fogEnd = 0.0;\n    float fogDist = 0.0;\n    float fogDensity = 0.0;\n    float fogColor = 0.0;\n    float fogAlpha = 0.0;\n    float fogAlphaStart = 0.0;\n    float fogAlphaEnd = 0.0;\n    float fogAlphaDist = 0.0;\n    float fogAlphaDensity = 0.0;\n    float fogAlphaColor = 0.0;\n    float fogAlphaAlpha = 0.0;\n    float fogAlphaAlphaStart = 0.0;\n    float fogAlphaAlphaEnd = 0.0;\n    float fogAlphaAlphaDist = 0.0;\n    float fogAlphaAlphaDensity = 0.0;\n    float fogAlphaAlphaColor = 0.0;\n    float fogAlphaAlphaAlpha = 0.0;\n    float fogAlphaAlphaAlphaStart = 0.0;\n    float fogAlphaAlphaAlphaEnd = 0.0;\n    float fogAlphaAlphaAlphaDist = 0.0;\n    float fogAlphaAlphaAlphaDensity = 0.0;\n    float fogAlphaAlphaAlphaColor = 0.0;\n    float fogAlphaAlphaAlphaAlpha = 0.0;\n    float fogAlphaAlphaAlphaAlphaStart = 0.0;\n    float fogAlphaAlphaAlphaAlphaEnd = 0.0;\n    float fogAlphaAlphaAlphaAlphaDist = 0.0;\n    float fogAlphaAlphaAlphaAlphaDensity = 0.0;\n    float fogAlphaAlphaAlphaAlphaColor = 0.0;\n    float fogAlphaAlphaAlphaAlphaAlpha = 0.0;\n    float fogAlphaAlphaAlphaAlphaAlphaStart = 0.0;\n    float fogAlphaAlphaAlphaAlphaAlphaEnd = 0.0;\n    float fogAlphaAlphaAlphaAlphaAlphaDist = 0.0;\n    float fogAlphaAlphaAlphaAlphaAlphaDensity = ", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 gamma_correction(vec3 color, float gamma) {\n    return pow(color, vec3(1.0 / gamma));\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 srgb_to_linear(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 linear_to_srgb(vec3 color) {\n    return pow(color, vec3(0.4545));\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 srgb_to_linear(vec3 color, float gamma) {\n    return pow(color, vec3(1.0 / gamma));\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 linear_to_srgb(vec3 color, float gamma) {\n    return pow(color, vec3(gamma));\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 srgb_to_linear(vec3 color, float gamma, float exposure) {\n    return pow(color, vec3(1.0 / gamma)) * exposure;\n}\n\n// From https://www.shadertoy.com/view/XdGfzS\nvec3 linear_to_srgb(vec3 color, float gamma, float exposure) {\n    return pow(color * exposure, vec3(gamma));\n}\n\n// From"]}