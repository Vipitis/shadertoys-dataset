{"generations": ["\n\treturn 0.282095;\n}\n\nfloat", "\n\treturn length( (p-a) / (b-a) );\n}\n\n// distance to a circle\nfloat", "\n\treturn ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Calculate the normal of a triangle\nvec", "\n\treturn ( dot( v, r ) < 0.0 )? v - 2.0 * dot( v, r ) * r : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n\treturn ( dot( v, r ) < 0.0 )? v : vec2( 0.0 );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 cp = mix( a, b, h );\n\tfloat d1 = length( pa - ba*h ) - w1;\n\tfloat d2 = length( pa - ba*h ) - w2;\n\treturn min( max(d1,d2), 0.0 );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\nvec", "\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\treturn 0.5f * (2.0f * p1 + (-p0 + p2) * t + (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 + (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat n = 0.0;\n\tfloat f = 1.0;\n\tfloat s = 1.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\t", "\n\tfloat t0 = floor(t);\n\tfloat t1 = t0 + 1.0;\n\tfloat t2 = t1 + 1.0;\n\tfloat t3 = t2 + 1.0;\n\n\tfloat t00 = t0 * t0;\n\tfloat t01 = t0 * t1;\n\tfloat t02 = t0 * t2;\n\tfloat t03 = t0 * t3;\n\tfloat t10 = t1 * t0;\n\tfloat t11 = t1 * t1;\n\tfloat t12 = t1 * t2;\n\tfloat t13 = t1 * t3;\n\tfloat t20 = t2 * t0;\n\tfloat t21 = t2 * t1;\n\tfloat t22 = t2 * t2;\n\tfloat t23 = t2 * t3;\n\tfloat t30 = t3 * t0;\n\tfloat t31 = t3 * t1;\n\tfloat t32 = t3 * t2;\n\tfloat t33 = t3 * t3;\n\n\tfloat x = t00 * camPos[0] + t01 * camPos[1] + t02 * camPos[2] + t03 * camPos[3];\n\tfloat y = t00 * camPos[4] + t01 * camPos[5] + t02 * camPos[6] + t03 * camPos[7];\n\tfloat z = t00 * camPos[8] + t01 * camPos[9] + t02 * camPos[10] + t03 * camPos[11];\n\tfloat w = t00 * camPos[12] + t01 * camPos[13] + t02 * camPos[14] + t03 * camPos[15];\n\n\treturn vec4(x, y, z, w);\n}\n\n// This is the main function.\n// It is called for each pixel in the screen.\nvoid main()\n{\n\t// Get the pixel's position in the screen.\n\tvec2 pixelPos = gl_FragCoord.xy / screen", "\n\treturn fract(sin(u) * 43758.5453);\n}\n\nfloat", "\n\tfloat n = 0.0;\n\tfloat f = 0.0;\n\tfloat s = 1.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\t", "\n\tfloat d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 envColor = vec3(0.0);\n\tfloat envWeight = 0.0;\n\n\t// Get the ray's intersection with the environment map.\n\tvec3 envPos = GetEnvMapIntersection(rayDir);\n\n\t// Get the environment map's UV coordinates.\n\tvec2 envUV = GetEnvMapUV(envPos);\n\n\t// Get the environment map's normal.\n\tvec3 envNormal = GetEnvMapNormal(envPos);\n\n\t// Get the environment map's color.\n\tvec3 envColor = GetEnvMapColor(envPos);\n\n\t// Get the environment map's weight.\n\tfloat envWeight = GetEnvMapWeight(envPos);\n\n\t// Get the environment map's shadow.\n\tfloat envShadow = GetEnvMapShadow(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the environment map's shadow weight.\n\tfloat envShadowWeight = GetEnvMapShadowWeight(envPos);\n\n\t// Get the environment map's shadow color.\n\tvec3 envShadowColor = GetEnvMapShadowColor(envPos);\n\n\t// Get the", "\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// smooth min (k = 0.1);\nfloat", "\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 diff = pos - spherePos;\n\tfloat a = dot(dirVec, dirVec);\n\tfloat b = 2.0f * dot(dirVec, diff);\n\tfloat c = dot(diff, diff) - rad * rad;\n\tfloat discriminant = b * b - 4.0f * a * c;\n\tif (discriminant < 0.0f)\n\t\treturn -1.0f;\n\tfloat t1 = (-b - sqrt(discriminant)) / (2.0f * a);\n\tfloat t2 = (-b + sqrt(discriminant)) / (2.0f * a);\n\treturn t1 > 0.0f? t1 : t2;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat", "\n\tvec2 d = vec2(0.0);\n\td.x = length(p.xz) - 1.0;\n\td.y = length(p.xy) - 1.0;\n\treturn d;\n}\n\n// Calculate the distance field that defines the object.\nfloat", "\n\tfloat x = t * 2.0 - 1.0;\n\tfloat y = t * 2.0 - 1.0;\n\tfloat z = t * 2.0 - 1.0;\n\tfloat r = sqrt(x * x + y * y + z * z);\n\tfloat a = 1.0 - r;\n\tfloat b = 1.0 - r * r;\n\tfloat c = 1.0 - r * r * r;\n\tfloat d = 1.0 - r * r * r * r;\n\tfloat e = 1.0 - r * r * r * r * r;\n\tfloat f = 1.0 - r * r * r * r * r * r;\n\tfloat g = 1.0 - r * r * r * r * r * r * r;\n\tfloat h = 1.0 - r * r * r * r * r * r * r * r;\n\tfloat i = 1.0 - r * r * r * r * r * r * r * r * r;\n\tfloat j = 1.0 - r * r * r * r * r * r * r * r * r * r;\n\tfloat k = 1.0 - r * r * r * r * r * r * r * r * r * r * r;\n\tfloat l = 1.0 - r * r * r * r * r * r * r * r * r * r * r * r;\n\tfloat m = 1.0 - r * r * r * r * r * r * r * r * r * r * r * r * r;\n\tfloat n = 1.0 - r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n\tfloat o = 1.0 - r * r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n\tfloat p = 1.0 - r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r;\n\tfloat q = 1.0 -", "\n\tvec3 p = map(t);\n\treturn normalize(p - map(t - 0.001));\n}\n\n// curve second derivative (acceleration)\nvec", "\n\tfloat x = t * t;\n\tfloat y = t * t * t;\n\tfloat z = t * t * t * t;\n\treturn vec3(x * (3.0 - 2.0 * t), y * (3.0 - 2.0 * t), z * (3.0 - 2.0 * t));\n}\n\n// curve third derivative (jerk)\nvec", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// signed distance between point and segment\nfloat", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tfloat tca = dot( ao, d );\n\tif ( tca < 0.0 ) return vec2( 0.0 );\n\tfloat d2 = dot( ab, ab );\n\tfloat h = tca * tca / d2;\n\tif ( h > 1.0 ) return vec2( 0.0 );\n\tvec3 closest = a + tca * d;\n\tfloat closest_to_o = dot( ao, ao ) - tca * tca;\n\tfloat closest_to_b = dot( ao - ab, ao - ab );\n\tfloat closest_to_d = dot( d, d );\n\tfloat t = ( closest_to_o - closest_to_b ) / ( closest_to_d - closest_to_b );\n\treturn vec2( t, h );\n}\n\n// signed distance between ray and segment\nfloat", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),max(max(r.x*d.y,r.y*d.x),max(r.z*d.y,r.w*d.x))) + min(max(r.x,r.y),max(r.z,r.w));\n}\n\n// https://www.shadertoy.com/view/4dS3zW\nfloat", "\nfloat", "\n\t// First we need to calculate the direction of the ray.\n\t// This is the vector from the camera to the target.\n\tvec3 rd = normalize( ta - ro );\n\n\t// Now we need to calculate the roll.\n\t// This is the rotation around the z axis.\n\t// We can do this by rotating around the y axis.\n\t// This is because the y axis is perpendicular to the z axis.\n\t// So we can rotate around the y axis and then rotate around the z axis.\n\t// This is the same as rotating around the z axis first and then rotating around the y axis.\n\t// This is the same as rotating around the z axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the amount of the roll.\n\t// This is the same as rotating around the y axis by the", "\n\tfloat dist = 0.0;\n\tfloat radius = 0.005;\n\tfloat thickness = 0.0005;\n\tfloat angle = 0.0;\n\tfloat angleStep = 0.001;\n\tfloat angleStep2 = 0.0001;\n\tfloat angleStep3 = 0.00001;\n\tfloat angleStep4 = 0.000001;\n\tfloat angleStep5 = 0.0000001;\n\tfloat angleStep6 = 0.00000001;\n\tfloat angleStep7 = 0.000000001;\n\tfloat angleStep8 = 0.0000000001;\n\tfloat angleStep9 = 0.00000000001;\n\tfloat angleStep10 = 0.000000000001;\n\tfloat angleStep11 = 0.0000000000001;\n\tfloat angleStep12 = 0.00000000000001;\n\tfloat angleStep13 = 0.000000000000001;\n\tfloat angleStep14 = 0.0000000000000001;\n\tfloat angleStep15 = 0.00000000000000001;\n\tfloat angleStep16 = 0.000000000000000001;\n\tfloat angleStep17 = 0.0000000000000000001;\n\tfloat angleStep18 = 0.00000000000000000001;\n\tfloat angleStep19 = 0.000000000000000000001;\n\tfloat angleStep20 = 0.0000000000", "\n\tfloat distance1 = distance( thing1, mouse );\n\tfloat distance2 = distance( thing2, mouse );\n\tif( distance1 < distance2 ){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec", "\n\tvec2 closest = vec2( 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 normal = vec3( 0.0 );\n\tvec2 delta = vec2( 0.001, 0.0 );\n\tnormal.x = getSDF( positionOfHit + delta.xyy ) - getSDF( positionOfHit - delta.xyy );\n\tnormal.y = getSDF( positionOfHit + delta.yxy ) - getSDF( positionOfHit - delta.yxy );\n\tnormal.z = getSDF( positionOfHit + delta.yyx ) - getSDF( positionOfHit - delta.yyx );\n\treturn normalize( normal );\n}\n\n// This function is used to calculate the color of the\n// surface at a given point.\nvec", "\nreturn vec3(0.0);\n}\n\n// this is the function that actually does the\n// rendering. it takes in a ray, and returns\n// a color.\nvec", "\n\tvec3 color = vec3(0.0);\n\tcolor += 0.5 * normalOfSurface + 0.5;\n\treturn color;\n}\n\n// This is the main function of the shader.\n// It is called for every pixel of the screen.\nvoid main(){\n\t// We get the position of the pixel on the screen\n\t// and the direction of the ray that is going through\n\t// the pixel.\n\tvec3 positionOnScreen = gl_FragCoord.xyz / gl_FragCoord.w;\n\tvec3 directionOfRay = normalize(positionOnScreen);\n\n\t// We get the intersection point of the ray with the scene.\n\t// If there is no intersection, we return black.\n\tvec3 intersectionPoint = intersectRayWithScene(directionOfRay);\n\tif(intersectionPoint == vec3(0.0)){\n\t\tgl_FragColor = vec4(0.0);\n\t\treturn;\n\t}\n\n\t// We get the normal of the surface at the intersection point.\n\t// If there is no intersection, we return black.\n\tvec3 normalOfSurface = getNormalAtIntersection(intersectionPoint);\n\tif(normalOfSurface == vec3(0.0)){\n\t\tgl_FragColor = vec4(0.0);\n\t\treturn;\n\t}\n\n\t// We get the color of the surface at the intersection point.\n\t// If there is no intersection, we return black.\n\tvec3 colorOfSurface = getColorAtIntersection(intersectionPoint);\n\tif(colorOfSurface == vec3(0.0)){\n\t\tgl_FragColor = vec4(0.0);\n\t\treturn;\n\t}\n\n\t// We get the color of the light source.\n\tvec3 colorOfLightSource = getColorOfLightSource();\n\n\t// We get the color of the intersection point.\n\t// If there is no intersection, we return black.\n\tvec3 colorOfIntersectionPoint = doBoxColor(intersectionPoint, normalOfSurface);\n\tif(colorOfIntersectionPoint == vec3(0.0)){\n\t\tgl_FragColor = vec4(0.0);\n\t\treturn;\n\t}\n\n\t// We get the color of the intersection point.\n\t// If there is no intersection, we return black.\n\tvec3 color", "\n\tvec3 color = vec3( 0.0 );\n\tvec3 normal = vec3( 0.0 );\n\tvec3 lightDirection = normalize( vec3( 0.0, 0.0, 1.0 ) );\n\tvec3 lightColor = vec3( 1.0 );\n\tfloat lightIntensity = 1.0;\n\tfloat lightDistance = 1.0;\n\tfloat lightAngle = 0.0;\n\tfloat lightAngleOffset = 0.0;\n\tfloat lightAngleOffset2 = 0.0;\n\tfloat lightAngleOffset3 = 0.0;\n\tfloat lightAngleOffset4 = 0.0;\n\tfloat lightAngleOffset5 = 0.0;\n\tfloat lightAngleOffset6 = 0.0;\n\tfloat lightAngleOffset7 = 0.0;\n\tfloat lightAngleOffset8 = 0.0;\n\tfloat lightAngleOffset9 = 0.0;\n\tfloat lightAngleOffset10 = 0.0;\n\tfloat lightAngleOffset11 = 0.0;\n\tfloat lightAngleOffset12 = 0.0;\n\tfloat lightAngleOffset13 = 0.0;\n\tfloat lightAngleOffset14 = 0.0;\n\tfloat lightAngleOffset15 = 0.0;\n\tfloat lightAngleOffset16 = 0.0;\n\tfloat lightAngleOffset17 = 0.0;\n\tfloat lightAngleOffset18 = 0.0;\n\tfloat lightAngleOffset19 = 0.0;\n\tfloat lightAngleOffset20 = 0.0;\n\tfloat lightAngleOffset21 = 0.0;\n\tfloat lightAngleOffset22 = 0.0;\n\tfloat lightAngleOffset23 = 0.0;\n\tfloat lightAngleOffset24 = 0.0;\n\tfloat lightAngleOffset25 = 0.0;\n\tfloat lightAngleOffset26 = 0.0;\n\tfloat lightAngleOffset27 = 0.0;\n\tfloat lightAngleOffset28 = 0.0;\n\tfloat lightAngleOffset29 = 0.0;\n\tfloat lightAngleOffset30 = 0.", "\n    return (x - 0.5) * b + 0.5;\n}\n\n// smoothstep(x, a, b)\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if x is near a then values near 0.0 are returned\n// if x is near b then values near 1.0 are returned\n// if x is near 0.5 then values near 0.5 are returned\nfloat", "\n\treturn fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat", "\n\treturn fract(sin(dot(p.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0\nfloat", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input b --> is box size\n// input p --> is point\n// pretty simple, just compare point to box size\nfloat", "\n\tvec2 q = vec2(length(p.xz), p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input p --> sphere specs where:\n// \tp.x = sphere radius\n//  \n// think of the sphere as a circle\n// get the distance to the sphere radius\nfloat", "\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/fwidth(d1), 0.0, 1.0 );\n\treturn mix( d1, d2, h );\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n\tfloat blend = smoothstep(0.0, 1.0, d1);\n\treturn mix(d1, d2, blend);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n    float s = sin( yaw );\n    float c = cos( yaw );\n    mat3 m = mat3( c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0 );\n    return m * p;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec", "\n    return (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Union / combine 3 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n\tvec2 res = vec2(1e10, 1e10);\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tvec3 pos = vec3(0.0, 0.0, 0.0);\n\t\tvec3 dir = vec3(0.0, 0.0, 0.0);\n\t\tfloat dist = 0.0;\n\t\tfloat size = 0.0;\n\t\tfloat angle = 0.0;\n\t\tfloat speed = 0.0;\n\t\tfloat time = 0.0;\n\t\tfloat mass = 0.0;\n\t\tfloat radius = 0.0;\n\t\tfloat density = 0.0;\n\t\tfloat friction = 0.0;\n\t\tfloat restitution = 0.0;\n\t\tfloat elasticity = 0.0;\n\t\tfloat viscosity = 0.0;\n\t\tfloat gravity = 0.0;\n\t\tfloat drag = 0.0;\n\t\tfloat lift = 0.0;\n\t\tfloat lift_speed = 0.0;\n\t\tfloat lift_force = 0.0;\n\t\tfloat lift_mass = 0.0;\n\t\tfloat lift_radius = 0.0;\n\t\tfloat lift_density = 0.0;\n\t\tfloat lift_friction = 0.0;\n\t\tfloat lift_restitution = 0.0;\n\t\tfloat lift_elasticity = 0.0;\n\t\tfloat lift_viscosity = 0.0;\n\t\tfloat lift_gravity = 0.0;\n\t\tfloat lift_drag = 0.0;\n\t\tfloat lift_lift = 0.0;\n\t\tfloat lift_lift_speed = 0.0;\n\t\tfloat lift_lift_force = 0.0;\n\t\tfloat lift_lift_mass = 0.0;\n\t\tfloat lift_lift_radius = 0.0;\n\t\tfloat lift_lift_density = 0.0;\n\t\tfloat lift_lift_friction = 0.0;\n\t\tfloat lift_lift_restitution = 0.0;\n\t\tfloat lift_lift_elasticity = 0.0;\n\t\tfloat lift_lift", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat hitID = -1.0;\n\tfloat hitDist = 1000.0;\n\tfloat hitDist2 = 1000.0;\n\tfloat hitDist3 = 1000.0;\n\tfloat hitDist4 = 1000.0;\n\tfloat hitDist5 = 1000.0;\n\tfloat hitDist6 = 1000.0;\n\tfloat hitDist7 = 1000.0;\n\tfloat hitDist8 = 1000.0;\n\tfloat hitDist9 = 1000.0;\n\tfloat hitDist10 = 1000.0;\n\tfloat hitDist11 = 1000.0;\n\tfloat hitDist12 = 1000.0;\n\tfloat hitDist13 = 1000.0;\n\tfloat hitDist14 = 1000.0;\n\tfloat hitDist15 = 1000.0;\n\tfloat hitDist16 = 1000.0;\n\tfloat hitDist17 = 1000.0;\n\tfloat hitDist18 = 1000.0;\n\tfloat hitDist19 = 1000.0;\n\tfloat hitDist20 = 1000.0;\n\tfloat hitDist21 = 1000.0;\n\tfloat hitDist22 = 1000.0;\n\tfloat hitDist23 = 1000.0;\n\tfloat hitDist24 = 1000.0;\n\tfloat hitDist25 = 1000.0;\n\tfloat hitDist26 = 1000.0;\n\tfloat hitDist27 = 1000.0;\n\tfloat hitDist28 = 1000.0;\n\tfloat hitDist29 = 1000.0;\n\tfloat hitDist30 = 100", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        // ~~~~~~~ find closest surface\n        float d = find_closest_surface(ro, rd, t);\n        if (d < 0.001)\n            break;\n        ro += rd * d;\n        // ~~~~~~~ apply color\n        col += get_color(ro, rd, d);\n        // ~~~~~~~ update ray\n        rd = reflect(rd, normal);\n        t += d;\n    }\n    return col;\n}\n\n// ~~~~~~~ main function\nvoid main()\n{\n    // ~~~~~~~ get pixel's ray\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 ro = eye;\n    vec3 rd = normalize(lookat - ro);\n    rd.y += 1.0;\n    rd = normalize(rd);\n    // ~~~~~~~ render pixel\n    vec3 col = render(ro, rd);\n    // ~~~~~~~ output color\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n\tvec3 camDir = normalize( targetPos - camPos );\n\tvec3 camUp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camRight = normalize( cross( camDir, camUp ) );\n\tcamUp = normalize( cross( camRight, camDir ) );\n\n\tmat3 camMat = mat3( camRight, camUp, camDir );\n\n\t// roll camera\n\tcamMat = mat3(\n\t\tvec3( cos( roll ), -sin( roll ), 0.0 ),\n\t\tvec3( sin( roll ), cos( roll ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n\t) * camMat;\n\n\treturn camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// input fov --> field of view\n// input aspect --> aspect ratio\n// output --> camera matrix used to transform\nmat", "\n\tif(id < 0.0)\n\t{\n\t\treturn vec3(0.0);\n\t}\n\telse if(id < 1.0)\n\t{\n\t\treturn vec3(1.0);\n\t}\n\telse if(id < 2.0)\n\t{\n\t\treturn vec3(0.0, 1.0, 0.0);\n\t}\n\telse if(id < 3.0)\n\t{\n\t\treturn vec3(1.0, 0.0, 0.0);\n\t}\n\telse if(id < 4.0)\n\t{\n\t\treturn vec3(0.0, 0.0, 1.0);\n\t}\n\telse if(id < 5.0)\n\t{\n\t\treturn vec3(1.0, 1.0, 0.0);\n\t}\n\telse if(id < 6.0)\n\t{\n\t\treturn vec3(0.0, 1.0, 1.0);\n\t}\n\telse if(id < 7.0)\n\t{\n\t\treturn vec3(1.0, 0.0, 1.0);\n\t}\n\telse if(id < 8.0)\n\t{\n\t\treturn vec3(0.5, 0.5, 0.5);\n\t}\n\telse if(id < 9.0)\n\t{\n\t\treturn vec3(0.5, 0.5, 1.0);\n\t}\n\telse if(id < 10.0)\n\t{\n\t\treturn vec3(0.5, 1.0, 0.5);\n\t}\n\telse if(id < 11.0)\n\t{\n\t\treturn vec3(1.0, 0.5, 0.5);\n\t}\n\telse if(id < 12.0)\n\t{\n\t\treturn vec3(0.5, 0.5, 0.0);\n\t}\n\telse if(id < 13.0)\n\t{\n\t\treturn vec3(0.5, 1.0, 1.0);", "\n    vec2 q = vec2(length(p.xz), p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input t --> sphere specs where:\n//  t.x = sphere radius\n//  \n// think of the sphere as a circle\n// get the distance to the sphere radius\nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n// sphere extends indefinately in x and z, \n// so just return distance from floor (y)\nfloat", "\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( bmin(d1,d2), d2, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n\tfloat d1 = o1.x;\n\tfloat d2 = o2.x;\n\tfloat d = mix(d1, d2, bf);\n\tvec3 c1 = o1.yzw;\n\tvec3 c2 = o2.yzw;\n\tvec3 c = mix(c1, c2, bf);\n\treturn vec4(d, c.r, c.g, c.b);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n  return d1-d2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n\tvec3 lightPos = vec3(0.0);\n\tlightPos.x = sin(uTime) * 10.0;\n\tlightPos.y = cos(uTime) * 10.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec", "\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    // ~~~~~~~ find closest object/shape\n    //", "\n\t// ~~~~~~~ ray marching\n\tfloat t = 0.0;\n\tfloat tMin = 0.0;\n\tfloat tMax = 1000.0;\n\tfloat tHit = 0.0;\n\tfloat tHitID = 0.0;\n\tfloat tHitRatio = 0.0;\n\tfloat tHitRatioPrev = 0.0;\n\tfloat tHitRatioNext = 0.0;\n\tfloat tHitRatioPrevNext = 0.0;\n\tfloat tHitRatioPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n\tfloat tHitRatioPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev", "\n    // ~~~~~~~ get the ray direction\n    vec3 rd = normalize(lp - sp);\n\n    // ~~~~~~~ get the distance to the nearest surface\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 100.0;\n    float tstep = 0.01;\n    float tstep2 = 0.001;\n    float tstep3 = 0.0001;\n    float tstep4 = 0.00001;\n    float tstep5 = 0.000001;\n    float tstep6 = 0.0000001;\n    float tstep7 = 0.00000001;\n    float tstep8 = 0.000000001;\n    float tstep9 = 0.0000000001;\n    float tstep10 = 0.00000000001;\n    float tstep11 = 0.000000000001;\n    float tstep12 = 0.0000000000001;\n    float tstep13 = 0.00000000000001;\n    float tstep14 = 0.000000000000001;\n    float tstep15 = 0.0000000000000001;\n    float tstep16 = 0.00000000000000001;\n    float tstep17 = 0.000000000000000001;\n    float tstep18 = 0.0000000000000000001;\n    float tstep19 = 0.00000000000000000001;\n    float tstep20 = 0.000000000000000000001;\n    float tstep21 =", "\n\tfloat t = 0.0;\n\tfloat tMax = 10.0;\n\tfloat tMin = 0.001;\n\tfloat tStep = 0.001;\n\tfloat tStep2 = 0.002;\n\tfloat tStep3 = 0.003;\n\tfloat tStep4 = 0.004;\n\tfloat tStep5 = 0.005;\n\tfloat tStep6 = 0.006;\n\tfloat tStep7 = 0.007;\n\tfloat tStep8 = 0.008;\n\tfloat tStep9 = 0.009;\n\tfloat tStep10 = 0.01;\n\tfloat tStep11 = 0.011;\n\tfloat tStep12 = 0.012;\n\tfloat tStep13 = 0.013;\n\tfloat tStep14 = 0.014;\n\tfloat tStep15 = 0.015;\n\tfloat tStep16 = 0.016;\n\tfloat tStep17 = 0.017;\n\tfloat tStep18 = 0.018;\n\tfloat tStep19 = 0.019;\n\tfloat tStep20 = 0.02;\n\tfloat tStep21 = 0.021;\n\tfloat tStep22 = 0.022;\n\tfloat tStep23 = 0.023;\n\tfloat tStep24 = 0.024;\n\tfloat tStep25 = 0.025;\n\tfloat tStep26 = 0.026;\n\tfloat tStep27 = 0.027;\n\tfloat tStep28 = 0.028;\n\tfloat tStep29 = 0.029;\n\tfloat tStep30 = 0.03;\n\tfloat tStep31 = 0.031;\n\tfloat tStep32 = 0.032;\n\tfloat tStep33 = 0", "\n\tvec3 n = vec3(0.0);\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tvec3 p1 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i);\n\t\tvec3 p2 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 1);\n\t\tvec3 p3 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 2);\n\t\tvec3 p4 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 3);\n\t\tvec3 p5 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 4);\n\t\tvec3 p6 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 5);\n\t\tvec3 p7 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 6);\n\t\tvec3 p8 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 7);\n\t\tvec3 p9 = p + vec3(0.0, 0.0, 0.0) + vec3(0.0, 0.0, 0.0) * float(i + 8);\n\t\tvec", "\n\treturn pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec", "\nfloat", "\n\tfloat attn = 1.0f;\n\tif (cF > 0.0f)\n\t\tattn = 1.0f / (1.0f + cF * d);\n\tif (lF > 0.0f)\n\t\tattn *= 1.0f / (1.0f + lF * d);\n\tif (qF > 0.0f)\n\t\tattn *= 1.0f / (1.0f + qF * d * d);\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat", "\n\t// ~~~~~~~ calculate ray direction\n\t// ~~~~~~~ ray direction is the same for all fragments in a pixel\n\t// ~~~~~~~ ray direction is the same for all pixels in a screen\n\t// ~~~~~~~ ray direction is the same for all pixels in a view\n\t// ~~~~~~~ ray direction is the same for all pixels in a scene\n\t// ~~~~~~~ ray direction is the same for all pixels in a frame\n\t// ~~~~~~~ ray direction is the same for all pixels in a video\n\t// ~~~~~~~ ray direction is the same for all pixels in a movie\n\t// ~~~~~~~ ray direction is the same for all pixels in a film\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the same for all pixels in a photo\n\t// ~~~~~~~ ray direction is the same for all pixels in a picture\n\t// ~~~~~~~ ray direction is the", "\n    vec3 col=vec3(0.0);\n    float march=0.0;\n    float march_step=0.001;\n    float march_max=100.0;\n    float march_count=0.0;\n    float march_count_max=100.0;\n    float march_count_step=0.001;\n    float march_count_max_step=100.0;\n    float march_count_max_step_step=0.001;\n    float march_count_max_step_max=100.0;\n    float march_count_max_step_max_step=0.001;\n    float march_count_max_step_max_step_step=0.001;\n    float march_count_max_step_max_step_max_step=0.001;\n    float march_count_max_step_max_step_max_step_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step_max_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step_max_step_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step_max_step_max_step=0.001;\n    float march_count_max_step_max_step_max_step_max_step_max_step_max", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    float maxIter = 100.0;\n    float z = 0.0;\n    float c = 0.0;\n    float z_prev = 0.0;\n    float c_prev = 0.0;\n    float z_prev2 = 0.0;\n    float c_prev2 = 0.0;\n    float z_prev3 = 0.0;\n    float c_prev3 = 0.0;\n    float z_prev4 = 0.0;\n    float c_prev4 = 0.0;\n    float z_prev5 = 0.0;\n    float c_prev5 = 0.0;\n    float z_prev6 = 0.0;\n    float c_prev6 = 0.0;\n    float z_prev7 = 0.0;\n    float c_prev7 = 0.0;\n    float z_prev8 = 0.0;\n    float c_prev8 = 0.0;\n    float z_prev9 = 0.0;\n    float c_prev9 = 0.0;\n    float z_prev10 = 0.0;\n    float c_prev10 = 0.0;\n    float z_prev11 = 0.0;\n    float c_prev11 = 0.0;\n    float z_prev12 = 0.0;\n    float c_prev12 = 0.0;\n    float z_prev13 = 0.0;\n    float c_prev13 = 0.0;\n    float z_prev14 = 0.0;\n    float c_prev14 = 0.0;\n    float z_prev15 = 0.0;\n    float c_prev15 = 0.0;\n    float z_prev16 = 0.0;\n    float c_prev16 = 0.0;\n    float z_prev17 = 0.0;\n    float c_prev17 = 0.0;\n    float z", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat", "\n\tfloat d = length(p) - r;\n\treturn max(d, 0.0);\n}\n\n// simple sphere distance field\nfloat", "\n\t// The distance to the nearest surface.\n\tfloat d = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\treturn vec2(pow(c.x, 5.0), pow(c.y, 5.0));\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n\tvec4 color = vec4(0.0);\n\tfloat morph = 0.0;\n\tfloat morph2 = 0.0;\n\tfloat morph3 = 0.0;\n\tfloat morph4 = 0.0;\n\tfloat morph5 = 0.0;\n\tfloat morph6 = 0.0;\n\tfloat morph7 = 0.0;\n\tfloat morph8 = 0.0;\n\tfloat morph9 = 0.0;\n\tfloat morph10 = 0.0;\n\tfloat morph11 = 0.0;\n\tfloat morph12 = 0.0;\n\tfloat morph13 = 0.0;\n\tfloat morph14 = 0.0;\n\tfloat morph15 = 0.0;\n\tfloat morph16 = 0.0;\n\tfloat morph17 = 0.0;\n\tfloat morph18 = 0.0;\n\tfloat morph19 = 0.0;\n\tfloat morph20 = 0.0;\n\tfloat morph21 = 0.0;\n\tfloat morph22 = 0.0;\n\tfloat morph23 = 0.0;\n\tfloat morph24 = 0.0;\n\tfloat morph25 = 0.0;\n\tfloat morph26 = 0.0;\n\tfloat morph27 = 0.0;\n\tfloat morph28 = 0.0;\n\tfloat morph29 = 0.0;\n\tfloat morph30 = 0.0;\n\tfloat morph31 = 0.0;\n\tfloat morph32 = 0.0;\n\tfloat morph33 = 0.0;\n\tfloat morph34 = 0.0;\n\tfloat morph35 = 0.0;\n\tfloat morph36 = 0.0;\n\tfloat morph37 = 0.0;\n\tfloat morph38 = 0.0;\n\tfloat morph39 = 0.0;\n\tfloat morph40 = 0.0;\n\tfloat morph41 = 0.0;\n\tfloat morph42 = 0.0;\n\tfloat morph4", "\n\tvec4 sum = vec4(0.0);\n\tfor(int i = -1; i <= 1; i++)\n\t{\n\t\tfor(int j = -1; j <= 1; j++)\n\t\t{\n\t\t\tsum += texture(tex, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn sum / 9.0;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec4 color = antiAliasedBiomorph(uv, vec2(1.0 / resolution.x, 1.0 / resolution.y));\n\tgl_FragColor = color;\n}\n", "\n\treturn x - floor(x);\n}\n\nfloat", "\n\t// Get the line direction\n\tvec2 dir = pB - pA;\n\t// Get the line length\n\tfloat len = length(dir);\n\t// Get the line direction normalized\n\tdir /= len;\n\t// Get the line thickness\n\tfloat thickLen = length(thick);\n\t// Get the line thickness normalized\n\tthick /= thickLen;\n\t// Get the line thickness along the line\n\tfloat thickAlong = dot(thick, dir);\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp = thickLen - thickAlong;\n\t// Get the line thickness along the line\n\tfloat thickAlong2 = thickAlong * 0.5;\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp2 = thickPerp * 0.5;\n\t// Get the line thickness along the line\n\tfloat thickAlong3 = thickAlong * 0.25;\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp3 = thickPerp * 0.25;\n\t// Get the line thickness along the line\n\tfloat thickAlong4 = thickAlong * 0.125;\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp4 = thickPerp * 0.125;\n\t// Get the line thickness along the line\n\tfloat thickAlong5 = thickAlong * 0.0625;\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp5 = thickPerp * 0.0625;\n\t// Get the line thickness along the line\n\tfloat thickAlong6 = thickAlong * 0.03125;\n\t// Get the line thickness perpendicular to the line\n\tfloat thickPerp6 = thickPerp * 0.03125;\n\t// Get the line thickness along the line\n\tfloat thickAlong7 = thickAlong * 0.015625;\n\t// Get the line thickness perpendicular to the line\n\tfloat", "\n\tfloat d = length(pB - pA);\n\tfloat w = thick.x;\n\tfloat h = thick.y;\n\tfloat r = rounded;\n\tfloat a = atan(pB.y - pA.y, pB.x - pA.x);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat x0 = pA.x + r * c - w * s * 0.5;\n\tfloat y0 = pA.y + r * s + w * c * 0.5;\n\tfloat x1 = pB.x + r * c - w * s * 0.5;\n\tfloat y1 = pB.y + r * s + w * c * 0.5;\n\tfloat x2 = pB.x - r * c - w * s * 0.5;\n\tfloat y2 = pB.y - r * s + w * c * 0.5;\n\tfloat x3 = pA.x - r * c - w * s * 0.5;\n\tfloat y3 = pA.y - r * s + w * c * 0.5;\n\tfloat x4 = pA.x + r * c + w * s * 0.5;\n\tfloat y4 = pA.y + r * s - w * c * 0.5;\n\tfloat x5 = pB.x + r * c + w * s * 0.5;\n\tfloat y5 = pB.y + r * s - w * c * 0.5;\n\tfloat x6 = pB.x - r * c + w * s * 0.5;\n\tfloat y6 = pB.y - r * s - w * c * 0.5;\n\tfloat x7 = pA.x - r * c + w * s * 0.5;\n\tfloat y7 = pA.y - r * s - w * c * 0.5;\n\tfloat x8 = pA.x + r * c - h * s;\n\tfloat y8 = pA.y + r * s + h * c;\n\tfloat x9", "\n\tfloat d = length(pB - pA);\n\tfloat w = thick.x;\n\tfloat h = thick.y;\n\tfloat r = rounded;\n\tfloat o = outlineThick;\n\tfloat a = atan(pB.y - pA.y, pB.x - pA.x);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat x = pA.x + (d * c) - (w * s);\n\tfloat y = pA.y + (d * s) + (w * c);\n\tfloat x2 = pA.x + (d * c) + (w * s);\n\tfloat y2 = pA.y + (d * s) - (w * c);\n\tfloat x3 = pB.x + (d * c) - (h * s);\n\tfloat y3 = pB.y + (d * s) + (h * c);\n\tfloat x4 = pB.x + (d * c) + (h * s);\n\tfloat y4 = pB.y + (d * s) - (h * c);\n\tfloat x5 = pA.x + (d * c) - (h * s);\n\tfloat y5 = pA.y + (d * s) + (h * c);\n\tfloat x6 = pA.x + (d * c) + (h * s);\n\tfloat y6 = pA.y + (d * s) - (h * c);\n\tfloat x7 = pB.x + (d * c) - (w * s);\n\tfloat y7 = pB.y + (d * s) + (w * c);\n\tfloat x8 = pB.x + (d * c) + (w * s);\n\tfloat y8 = pB.y + (d * s) - (w * c);\n\tfloat x9 = pA.x + (d * c) - (w * s);\n\tfloat y9 = pA.y + (d * s) + (w * c);\n\tfloat x10 = pA.x + (d * c) + (w * s);\n", "\n\tfloat d = length(pB - pA);\n\tfloat a = acos(dot(pB - pA, uv - pA) / d);\n\tfloat b = acos(dot(pA - pB, uv - pB) / d);\n\tfloat c = acos(dot(pA - pB, uv - pA) / d);\n\tfloat h = thick.x * 0.5;\n\tfloat w = thick.y * 0.5;\n\tfloat r = rounded * 0.5;\n\tfloat d1 = max(abs(sin(a - w)) * d, abs(sin(b - w)) * d);\n\tfloat d2 = max(abs(sin(a + w)) * d, abs(sin(b + w)) * d);\n\tfloat d3 = max(abs(sin(a - h)) * d, abs(sin(b - h)) * d);\n\tfloat d4 = max(abs(sin(a + h)) * d, abs(sin(b + h)) * d);\n\tfloat d5 = max(abs(sin(a - r)) * d, abs(sin(b - r)) * d);\n\tfloat d6 = max(abs(sin(a + r)) * d, abs(sin(b + r)) * d);\n\tfloat d7 = max(abs(sin(a - c)) * d, abs(sin(b - c)) * d);\n\tfloat d8 = max(abs(sin(a + c)) * d, abs(sin(b + c)) * d);\n\treturn max(max(max(d1, d2), max(d3, d4)), max(max(d5, d6), max(d7, d8)));\n}\n\n// This makes a filled circle in UV units. A 1.0 thick circle will span a whole 0..1 in UV space.\nfloat", "\n\tfloat d = length(pB - pA);\n\tfloat t = thick.x / d;\n\tfloat r = thick.y / d;\n\tfloat a = atan(pB.y - pA.y, pB.x - pA.x);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat x = c * t;\n\tfloat y = s * t;\n\tfloat w = r * c;\n\tfloat h = r * s;\n\tfloat u = uv.x - pA.x;\n\tfloat v = uv.y - pA.y;\n\tfloat d1 = abs(u * c + v * s - x);\n\tfloat d2 = abs(u * s - v * c - y);\n\tfloat d3 = abs(u * c - v * s - w);\n\tfloat d4 = abs(u * s + v * c - h);\n\tfloat d5 = abs(u * c + v * s + x);\n\tfloat d6 = abs(u * s - v * c + y);\n\tfloat d7 = abs(u * c - v * s + w);\n\tfloat d8 = abs(u * s + v * c + h);\n\tfloat d9 = abs(u * c - v * s - x);\n\tfloat d10 = abs(u * s + v * c - y);\n\tfloat d11 = abs(u * c + v * s - w);\n\tfloat d12 = abs(u * s - v * c - h);\n\tfloat d13 = abs(u * c + v * s + x);\n\tfloat d14 = abs(u * s - v * c + y);\n\tfloat d15 = abs(u * c - v * s + w);\n\tfloat d16 = abs(u * s + v * c + h);\n\tfloat d17 = abs(u * c - v * s - x);\n\tfloat d18 = abs(u * s + v * c - y);\n\tfloat d19 = abs(u * c + v * s - w);\n\tfloat d20 = abs(u * s - v", "\n\tfloat d = length(pB - pA);\n\tfloat a = acos(dot(pB - pA, uv - pA) / d);\n\tfloat b = acos(dot(pA - pB, uv - pB) / d);\n\tfloat c = acos(dot(pA - pB, uv - pA) / d);\n\tfloat d = acos(dot(pB - pA, uv - pB) / d);\n\tfloat alpha = max(a, b);\n\tfloat beta = min(c, d);\n\tfloat alpha2 = max(a, c);\n\tfloat beta2 = min(b, d);\n\tfloat alpha3 = max(a, d);\n\tfloat beta3 = min(b, c);\n\tfloat alpha4 = max(c, d);\n\tfloat beta4 = min(a, b);\n\tfloat alpha5 = max(c, a);\n\tfloat beta5 = min(d, b);\n\tfloat alpha6 = max(d, a);\n\tfloat beta6 = min(c, b);\n\tfloat alpha7 = max(d, c);\n\tfloat beta7 = min(a, b);\n\tfloat alpha8 = max(d, b);\n\tfloat beta8 = min(a, c);\n\tfloat alpha9 = max(c, b);\n\tfloat beta9 = min(d, a);\n\tfloat alpha10 = max(c, d);\n\tfloat beta10 = min(b, a);\n\tfloat alpha11 = max(d, c);\n\tfloat beta11 = min(a, b);\n\tfloat alpha12 = max(d, b);\n\tfloat beta12 = min(a, c);\n\tfloat alpha13 = max(c, b);\n\tfloat beta13 = min(d, a);\n\tfloat alpha14 = max(c, a);\n\tfloat beta14 = min(d, b);\n\tfloat alpha15 = max(a, b);\n\tfloat beta15 = min(c, d);\n\tfloat alpha16 = max(a, d);\n\tfloat beta16 = min(b, c);\n\tfloat alpha17 =", "\n\tfloat d = length(p);\n\tfloat r = 0.005;\n\tfloat a = atan(p.y, p.x);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tvec2 p2 = vec2(c * r, s * r);\n\tvec2 p3 = vec2(c * -r, s * -r);\n\tvec2 p4 = vec2(c * -r, s * r);\n\tvec2 p5 = vec2(c * r, s * r);\n\tvec2 p6 = vec2(c * r, s * -r);\n\tvec2 p7 = vec2(c * -r, s * -r);\n\tvec2 p8 = vec2(c * -r, s * r);\n\tvec2 p9 = vec2(c * r, s * r);\n\tvec2 p10 = vec2(c * r, s * -r);\n\tvec2 p11 = vec2(c * -r, s * -r);\n\tvec2 p12 = vec2(c * -r, s * r);\n\tvec2 p13 = vec2(c * r, s * r);\n\tvec2 p14 = vec2(c * r, s * -r);\n\tvec2 p15 = vec2(c * -r, s * -r);\n\tvec2 p16 = vec2(c * -r, s * r);\n\tvec2 p17 = vec2(c * r, s * r);\n\tvec2 p18 = vec2(c * r, s * -r);\n\tvec2 p19 = vec2(c * -r, s * -r);\n\tvec2 p20 = vec2(c * -r, s * r);\n\tvec2 p21 = vec2(c * r, s * r);\n\tvec2 p22 = vec2(c * r, s * -r);\n\tvec2 p23 = vec2(c * -r, s * -r);\n\tvec2 p24 = vec2(c * -r, s * r);\n\tvec2 p2", "\n    vec3 oc = ro - cen;\n    float a = dot(rd,rd);\n    float b = dot(oc,rd);\n    float h = dot(oc,nor);\n    float d = h*h - b*b + rad*rad;\n    if( d<0.0 ) return -1.0;\n    return -b - sqrt(d);\n}\n\n// ray-sphere intersection\nfloat", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen - ro - rad) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\treturn max(t1, t2);\n}\n\n// ray-sphere intersection\nvec", "\n\tfloat d = length(pb-pa);\n\tfloat h = sqrt(ra*ra - d*d*0.25);\n\tfloat w = d*0.5;\n\treturn bound3(pa-vec3(w,h,0),pa+vec3(w,h,0));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tfloat d = length(pb-pa);\n\tfloat h = sqrt(ra*ra - d*d*0.25);\n\tfloat w = d*0.5;\n\treturn bound3(pa-vec3(w,h,0),pa+vec3(w,h,0));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 pa, in float ra )\n{\n\treturn bound3(pa-vec3(ra,ra,ra),pa+vec3(ra,ra,ra));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tfloat d = length(pb-pa);\n\tfloat h = sqrt(ra*ra - d*d*0.25);\n\tfloat w = d*0.5;\n\treturn bound3(pa-vec3(w,h,0),pa+vec3(w,h,0));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tfloat d = length(pb-pa);\n\tfloat h = sqrt(ra*ra - d*d*0.", "\n    vec3 oc = pa - ro;\n    float a = dot(rd,rd);\n    float b = dot(oc,rd);\n    float c = dot(oc,oc) - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(0.0);\n    float t = (-b-sqrt(h)) / a;\n    if( t<0.0 ) t = (-b+sqrt(h)) / a;\n    return vec4(t,normalize(oc+rd*t));\n}\n\n// ray-sphere intersetion (returns t and normal)\nvec", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen - ro - rad) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\treturn vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\n// ray-sphere intersection\nvec", "\n\tvec3 oc = pa - ro;\n\tfloat a = dot(rd,rd);\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - r*r;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt(h);\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n\tvec3 ab = b - a;\n\tvec3 ap = pos - a;\n\tfloat d = dot( ab, ap );\n\tfloat l = length( ab );\n\tfloat h = sqrt( r*r - d*d );\n\treturn normalize( ap - ab*d/l + ab*h/l );\n}\n\n// compute tangent\nvec", "\n\tvec3 tmin = ( -rad - ro ) / rd;\n\tvec3 tmax = ( rad - ro ) / rd;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\treturn vec2( max( t1.x, max( t1.y, t1.z ) ), min( t2.x, min( t2.y, t2.z ) ) );\n}\n\n// ray-sphere intersection in box space\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat h = 0.001;\n\tfloat d = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h2 = 0.0;\n\tfloat h3 = 0.0;\n\tfloat h4 = 0.0;\n\tfloat h5 = 0.0;\n\tfloat h6 = 0.0;\n\tfloat h7 = 0.0;\n\tfloat h8 = 0.0;\n\tfloat h9 = 0.0;\n\tfloat h10 = 0.0;\n\tfloat h11 = 0.0;\n\tfloat h12 = 0.0;\n\tfloat h13 = 0.0;\n\tfloat h14 = 0.0;\n\tfloat h15 = 0.0;\n\tfloat h16 = 0.0;\n\tfloat h17 = 0.0;\n\tfloat h18 = 0.0;\n\tfloat h19 = 0.0;\n\tfloat h20 = 0.0;\n\tfloat h21 = 0.0;\n\tfloat h22 = 0.0;\n\tfloat h23 = 0.0;\n\tfloat h24 = 0.0;\n\tfloat h25 = 0.0;\n\tfloat h26 = 0.0;\n\tfloat h27 = 0.0;\n\tfloat h28 = 0.0;\n\tfloat h29 = 0.0;\n\tfloat h30 = 0.0;\n\tfloat h31 = 0.0;\n\tfloat", "\n\tfloat phi = 2.0 * PI * i / n;\n\tfloat theta = acos(1.0 - 2.0 * i / n);\n\treturn vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\n// spherical fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.00000000000000000000", "\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// Four corners in 2D of a tile\n\tfloat a = dot(i, vec2(1.0,0.0));\n\tfloat b = dot(i, vec2(0.0,1.0));\n\tfloat c = dot(i, vec2(1.0,1.0));\n\tfloat d = dot(i, vec2(0.0,0.0));\n\n\t// Gradients\n\tvec3 g_00 = vec3(0.5) - vec3(dot(i, vec3(0.0)), dot(i, vec3(1.0)), dot(i, vec3(2.0)));\n\tvec3 g_10 = vec3(0.5) - vec3(dot(i, vec3(1.0)), dot(i, vec3(2.0)), dot(i, vec3(3.0)));\n\tvec3 g_01 = vec3(0.5) - vec3(dot(i, vec3(0.0)), dot(i, vec3(2.0)), dot(i, vec3(3.0)));\n\tvec3 g_11 = vec3(0.5) - vec3(dot(i, vec3(1.0)), dot(i, vec3(3.0)), dot(i, vec3(4.0)));\n\n\t// Normalise gradients\n\tvec3 norm = taylorInvSqrt(vec3(dot(g_00, g_00), dot(g_10, g_10), dot(g_01, g_01)));\n\tg_00 *= norm.x;\n\tg_10 *= norm.y;\n\tg_01 *= norm.z;\n\tg_11 *= norm.w;\n\n\t// Mix final noise value\n\tvec3 n_00 = dot(g_00, vec3(f.x, f.y, f.z));\n\tvec3 n_10 = dot(g_10, vec3(f.x-1.0, f.y, f.z));\n\tvec3 n_01 =", "\n\tvec2 d = abs(p) - size;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) + radius;\n}\n\nfloat", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\t", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\t", "\n\tfloat dx = texture2D( gridTexture, p + ddx ).r - texture2D( gridTexture, p - ddx ).r;\n\tfloat dy = texture2D( gridTexture, p + ddy ).r - texture2D( gridTexture, p - ddy ).r;\n\treturn length( vec2( dx, dy ) );\n}\n\n// grid ratio\nfloat", "\n\tvec3 g = vec3( 0.0 );\n\tg.x = map( p + vec3( 1.0, 0.0, 0.0 ) ) - map( p - vec3( 1.0, 0.0, 0.0 ) );\n\tg.y = map( p + vec3( 0.0, 1.0, 0.0 ) ) - map( p - vec3( 0.0, 1.0, 0.0 ) );\n\tg.z = map( p + vec3( 0.0, 0.0, 1.0 ) ) - map( p - vec3( 0.0, 0.0, 1.0 ) );\n\treturn normalize( g );\n}\n\n// normal of map (common factors removed)\nvec", "\n\tv33 c=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.z;\n\tb.y=c.x;\n\tb.z=c.y;\n}\n\n//this is the main function, it's the one that does all the work\nvoid main(){\n\t//this is the ray that we're going to shoot\n\tv33 ray=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray2=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray3=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray4=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray5=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray6=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray7=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray8=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\tv33 ray9=normalize(v33(gl_FragCoord.x,gl_FragCoord.y,1.0));\n\t//this is the ray that we're going to shoot\n\t", "return a-b;}\nv33 mul(v33 a,float b){return a*b;}\nv33 div(v33 a,float b){return a/b;}\nv33 add(v33 a,v33 b){return a+b;}\nv33 cross(v33 a,v33 b){return a^b;}\nv33 normalize(v33 a){return a/a.length();}\nv33 abs(v33 a){return a.abs();}\nv33 min(v33 a,v33 b){return a.min(b);}\nv33 max(v33 a,v33 b){return a.max(b);}\nv33 clamp(v33 a,v33 b,v33 c){return a.clamp(b,c);}\nv33 floor(v33 a){return a.floor();}\nv33 ceil(v33 a){return a.ceil();}\nv33 round(v33 a){return a.round();}\nv33 sign(v33 a){return a.sign();}\nv33 step(v33 a,v33 b){return a.step(b);}\nv33 smoothstep(v33 a,v33 b,v33 c){return a.smoothstep(b,c);}\nv33 pow(v33 a,v33 b){return a.pow(b);}\nv33 exp(v33 a){return a.exp();}\nv33 log(v33 a){return a.log();}\nv33 exp2(v33 a){return a.exp2();}\nv33 log2(v33 a){return a.log2();}\nv33 sqrt(v33 a){return a.sqrt();}\nv33 inversesqrt(v33 a){return a.inversesqrt();}\nv33 length(v33 a){return a.length();}\nv33 distance(v33 a,v33 b){return a.distance(b);}\nv33 dot(v33 a,v33 b){return a.dot(b);}\nv33 cross(v", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c){\n\tv33 d;\n\td.x=a.x-b.x-c.x;\n\td.y=a.y-b.y-c.y;\n\td.z=a.z-b.z-c.z;\n\treturn d;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c,v33 d){\n\tv33 e;\n\te.x=a.x-b.x-c.x-d.x;\n\te.y=a.y-b.y-c.y-d.y;\n\te.z=a.z-b.z-c.z-d.z;\n\treturn e;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c,v33 d,v33 e){\n\tv33 f;\n\tf.x=a.x-b.x-c.x-d.x-e.x;\n\tf.y=a.y-b.y-c.y-d.y-e.y;\n\tf.z=a.z-b.z-c.z-d.z-e.z;\n\treturn f;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is", "return (b-a)/dt(a,b);}\n\n//v33-differentials for AB\nvec", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec", "\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual div\nv33 div(v33 a,vec2 b){\n\treturn v33(a.x/b.x,a.y/b.x,a.z/b.x,a.x/b.y,a.y/b.y,a.z/b.y,a.x/b.z,a.y/b.z,a.z/b.z);\n}\n\n//dual dot\nfloat", "\n\tfloat d=0.;\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\td+=box(p+w*vec3(i,j,k),vec3(0.5));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat", "\n\tfloat a=0.0;\n\tfloat b=0.0;\n\tfloat c=0.0;\n\tfloat d=0.0;\n\tfloat e=0.0;\n\tfloat f=0.0;\n\tfloat g=0.0;\n\tfloat h=0.0;\n\tfloat i=0.0;\n\tfloat j=0.0;\n\tfloat k=0.0;\n\tfloat l=0.0;\n\tfloat m=0.0;\n\tfloat n=0.0;\n\tfloat o=0.0;\n\tfloat p=0.0;\n\tfloat q=0.0;\n\tfloat r=0.0;\n\tfloat s=0.0;\n\tfloat t=0.0;\n\tfloat u=0.0;\n\tfloat v=0.0;\n\tfloat w=0.0;\n\tfloat x=0.0;\n\tfloat y=0.0;\n\tfloat z=0.0;\n\tfloat A=0.0;\n\tfloat B=0.0;\n\tfloat C=0.0;\n\tfloat D=0.0;\n\tfloat E=0.0;\n\tfloat F=0.0;\n\tfloat G=0.0;\n\tfloat H=0.0;\n\tfloat I=0.0;\n\tfloat J=0.0;\n\tfloat K=0.0;\n\tfloat L=0.0;\n\tfloat M=0.0;\n\tfloat N=0.0;\n\tfloat O=0.0;\n\tfloat P=0.0;\n\tfloat Q=0.0;\n\tfloat R=0.0;\n\tfloat S=0.0;\n\tfloat T=0.0;\n\tfloat U=0.0;\n\tfloat V=0.0;\n\tfloat W=0.0;\n\tfloat X=0.0;\n\tfloat Y=0.0;\n\tfloat Z=0.0;\n\tfloat A1=0.0;\n\tfloat B1=0.0;\n\tfloat C1=0.0;\n\tfloat D1=0.0;\n\tfloat E", "\n\tfloat t=0;\n\tfloat d=10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat d=length(u-s.xyz);\n\tfloat r=s.w;\n\treturn 1.0-smoothstep(r-d,r,d);\n}\n\n//plane occlusion\nfloat", "\n\tvec2 p01 = p1 - p0;\n\tvec2 p12 = p2 - p1;\n\tvec2 p012 = p12 - p01;\n\tvec2 p0123 = p012 - p01;\n\tvec2 p01234 = p0123 - p012;\n\tvec2 p012345 = p01234 - p0123;\n\tvec2 p0123456 = p012345 - p01234;\n\tvec2 p01234567 = p0123456 - p012345;\n\tvec2 p012345678 = p01234567 - p0123456;\n\tvec2 p0123456789 = p012345678 - p01234567;\n\tvec2 p012345678910 = p0123456789 - p012345678;\n\tvec2 p01234567891011 = p012345678910 - p0123456789;\n\tvec2 p0123456789101112 = p01234567891011 - p012345678910;\n\tvec2 p012345678910111213 = p0123456789101112 - p01234567891011;\n\tvec2 p01234567891011121314 = p012345678910111213 - p0123456789101112;\n\tvec2 p01234", "\n\tvec2 p01 = p1 - p0;\n\tvec2 p12 = p2 - p1;\n\tvec2 p012 = p12 - p01;\n\tvec2 p0123 = p012 - p01;\n\tvec2 p01234 = p0123 - p012;\n\tvec2 p012345 = p01234 - p0123;\n\tvec2 p0123456 = p012345 - p01234;\n\tvec2 p01234567 = p0123456 - p012345;\n\tvec2 p012345678 = p01234567 - p0123456;\n\tvec2 p0123456789 = p012345678 - p01234567;\n\tvec2 p012345678910 = p0123456789 - p012345678;\n\tvec2 p01234567891011 = p012345678910 - p0123456789;\n\tvec2 p0123456789101112 = p01234567891011 - p012345678910;\n\tvec2 p012345678910111213 = p0123456789101112 - p01234567891011;\n\tvec2 p01234567891011121314 = p012345678910111213 - p0123456789101112;\n\tvec2 p01234", "\n    vec3 t0 = p0;\n    vec3 t1 = p1 - p0;\n    vec3 t2 = p2 - p1;\n    vec3 t3 = p3 - p2;\n\n    vec3 t0t0 = t0 * t0;\n    vec3 t0t1 = t0 * t1;\n    vec3 t0t2 = t0 * t2;\n    vec3 t0t3 = t0 * t3;\n\n    vec3 t1t1 = t1 * t1;\n    vec3 t1t2 = t1 * t2;\n    vec3 t1t3 = t1 * t3;\n\n    vec3 t2t2 = t2 * t2;\n    vec3 t2t3 = t2 * t3;\n\n    vec3 t3t3 = t3 * t3;\n\n    vec3 min = t0t0 + t1t1 + t2t2 + t3t3;\n    vec3 max = t0t0 + t0t1 + t0t2 + t0t3;\n    min = min( min, t1t1 + t1t2 + t1t3 + t2t3 );\n    max = max( max, t2t2 + t2t3 + t3t3 );\n    min = min( min, t3t3 );\n    max = max( max, t3t3 );\n\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    vec3 t0 = p0;\n    vec3 t1 = p1 - p0;\n    vec3 t2 = p2 - p0;\n\n    vec3 t0t0 = t0 * t0;\n    vec3 t0t1 = t0 * t1;\n    vec3 t0t2 = t0 * t2;\n\n    vec3 t1t1 = t1 * t1;\n    vec3 t1t2 = t1 * t2;\n\n    vec3 min = t0t0 + t1t1 + t2t2;\n    vec3 max = t0", "\n\tvec2 p01 = p1 - p0;\n\tvec2 p12 = p2 - p1;\n\tvec2 p23 = p3 - p2;\n\tvec2 p012 = p01 + p12;\n\tvec2 p123 = p12 + p23;\n\tvec2 p0123 = p012 + p123;\n\tvec2 p01234 = p0123 + p123;\n\tvec2 p012345 = p01234 + p123;\n\tvec2 p0123456 = p012345 + p123;\n\tvec2 p01234567 = p0123456 + p123;\n\tvec2 p012345678 = p01234567 + p123;\n\tvec2 p0123456789 = p012345678 + p123;\n\tvec2 p012345678910 = p0123456789 + p123;\n\tvec2 p01234567891011 = p012345678910 + p123;\n\tvec2 p0123456789101112 = p01234567891011 + p123;\n\tvec2 p012345678910111213 = p0123456789101112 + p123;\n\tvec2 p01234567891011121314 = p012345678910111213 + p123;\n\tvec2 p0123456789101112131415 = p0123456789", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p23 = p3 - p2;\n    vec2 p012 = p01 + p12;\n    vec2 p123 = p12 + p23;\n    vec2 p0123 = p012 + p123;\n\n    vec2 t = (pos - p0) / p0123;\n    vec2 tt = t * t;\n    vec2 ttt = tt * t;\n\n    return p0 + (p01 * ttt) + (p12 * tt) + (p23 * t) + (p3 * tt);\n}\n\n// https://www.shadertoy.com/view/4sX3zW\nfloat", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross( rd, e2 );\n\tfloat det = dot( e1, p );\n\n\tif( det == 0.0 )\n\t\treturn vec3( -1.0 );\n\n\tfloat invDet = 1.0 / det;\n\tvec3 tvec = ro - v0;\n\tfloat u = dot( tvec, p ) * invDet;\n\tif( u < 0.0 || u > 1.0 )\n\t\treturn vec3( -1.0 );\n\n\tvec3 q = cross( tvec, e1 );\n\tfloat v = dot( rd, q ) * invDet;\n\tif( v < 0.0 || u + v > 1.0 )\n\t\treturn vec3( -1.0 );\n\n\tfloat t = dot( e2, q ) * invDet;\n\treturn vec3( t, u, v );\n}\n\n// Sphere intersection. Returns { t, u, v }\nvec", "\n\tvec3 edge1 = v1 - v0;\n\tvec3 edge2 = v2 - v0;\n\tvec3 h = normalize( pos - v0 );\n\tfloat dotN = dot( nor, h );\n\tfloat dot1 = dot( edge1, h );\n\tfloat dot2 = dot( edge2, h );\n\tfloat invmax = inversesqrt( max( dot1*dot1, dot2*dot2 ) );\n\treturn ( dotN > 0.0 )? ( 0.5 + 0.5 * dotN * invmax ) : 0.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat", "\n\tvec2 p = pos - A;\n\tvec2 q = pos - B;\n\tvec2 r = pos - C;\n\tfloat a = dot(p,p);\n\tfloat b = dot(p,q);\n\tfloat c = dot(q,q);\n\tfloat d = dot(p,r);\n\tfloat e = dot(q,r);\n\tfloat f = dot(r,r);\n\tfloat det = b*b - a*c;\n\tfloat s = (b*e - c*d) / det;\n\tfloat t = (b*d - a*e) / det;\n\tfloat h = max(0.0, min(s,t));\n\tfloat m = max(h, max(s,t));\n\tfloat u = clamp(m, 0.0, 1.0);\n\tvec2 P = A + u*(B-A);\n\tvec2 Q = B + u*(C-B);\n\treturn length(pos - P) - length(pos - Q);\n}\n\n// signed distance to a cubic bezier\nfloat", "\n\tfloat h = abs(p.y);\n\tfloat d = max(abs(p.x)-r1-r2,0.0);\n\treturn length(max(vec2(h,d),0.0)) - he;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat", "\n\tvec2 d = abs(p.yx-a.yx);\n\tvec2 e = abs(p.yx-b.yx);\n\tfloat f = min(d.x,d.y);\n\tfloat g = min(e.x,e.y);\n\tfloat h = max(d.x,d.y);\n\tfloat i = max(e.x,e.y);\n\tfloat j = max(f,g);\n\tfloat k = min(f,g);\n\tfloat l = max(h,i);\n\tfloat m = min(h,i);\n\tfloat n = max(j,k);\n\tfloat o = min(j,k);\n\tfloat p = max(l,m);\n\tfloat q = min(l,m);\n\tfloat r = max(n,o);\n\tfloat s = min(n,o);\n\tfloat t = max(p,q);\n\tfloat u = min(p,q);\n\tfloat v = max(r,s);\n\tfloat w = min(r,s);\n\tfloat x = max(t,u);\n\tfloat y = min(t,u);\n\tfloat z = max(v,w);\n\tfloat A = min(v,w);\n\tfloat B = max(x,y);\n\tfloat C = min(x,y);\n\tfloat D = max(z,A);\n\tfloat E = min(z,A);\n\tfloat F = max(B,C);\n\tfloat G = min(B,C);\n\tfloat H = max(D,E);\n\tfloat I = min(D,E);\n\tfloat J = max(F,G);\n\tfloat K = min(F,G);\n\tfloat L = max(H,I);\n\tfloat M = min(H,I);\n\tfloat N = max(J,K);\n\tfloat O = min(J,K);\n\tfloat P = max(L,M);\n\tfloat Q = min(L,M);\n\tfloat R = max(N,O);\n\tfloat S = min(N,O);\n\tfloat T = max(P,Q);\n\tfloat U = min(P,Q);\n\t", "\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\treturn normalize( vec3(\n\t\tmap( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n\t\tmap( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n\t\tmap( pos + eps.yyx ).x - map( pos - eps.yyx ).x ) );\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro+rd*t ).x;\n\t\tres = min( res, 8.0*h*k/t );\n\t\tt += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n\treturn fract(sin(dot(q.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random float\nfloat", "\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( x + (x.x+x.y)*K1 );\n\tvec2 a = x - i + (i.x+i.y)*K2;\n\n\tvec2 o = (a.x>a.y)? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)) );\n\n\treturn dot( n, vec3(70.0) );\n}\n\n// 2D simplex noise\nfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat c = 1.0;\n\tfor ( int i = 0; i < p; i++ )\n\t{\n\t\tf += a * noise( x );\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// 2D simplex noise\nfloat", "\n    return length(max(abs(p)-r,0.0)) - min(max(abs(p).x,max(abs(p).y,abs(p).z))-r.x,0.0);\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat", "\n\treturn length(p.xz) - r.x;\n}\n\nfloat", "\n\treturn length(max(abs(p)-r,0.0))-min(max(abs(p).x,max(abs(p).y,abs(p).z))-r.x,0.0);\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat", "\n\treturn length(max(abs(p)-r,0.0))-min(max(abs(p).x,max(abs(p).y,abs(p).z))-r.x,0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat", "\n\tfloat d = 0.0;\n\td += 0.5000 * ( 1.0 - smoothstep( 0.4, 0.5, fract( p.x + p.y ) ) );\n\td += 0.2500 * ( 1.0 - smoothstep( 0.3, 0.4, fract( p.x * 2.0 + p.y ) ) );\n\td += 0.1250 * ( 1.0 - smoothstep( 0.2, 0.3, fract( p.x * 4.0 + p.y ) ) );\n\td += 0.0625 * ( 1.0 - smoothstep( 0.1, 0.2, fract( p.x * 8.0 + p.y ) ) );\n\treturn d;\n}\n\nfloat", "\n\treturn a * x * x * x * ( x * ( x * 6.0 - 15.0 ) + 10.0 );\n}\n\n// Schlick approximation of the Fresnel term, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n\treturn ( 2.0 * x - 1.0 ) * p;\n}\n\n// biased square\nfloat", "\n\tfloat a = 0.15;\n\tfloat b = 0.50;\n\tfloat c = 0.10;\n\tfloat d = 0.20;\n\tfloat e = 0.02;\n\tfloat f = 0.30;\n\tfloat g = 0.20;\n\tfloat k = 1.0 - 0.2 / exp( -h * h );\n\treturn mix( vec3( 1.0 ), vec3( 0.5, 0.7, 1.0 ), k ) * ( a * pow( h, 3.0 ) + b * pow( h, 2.0 ) + c * h + d ) + e * pow( h, f ) + g;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec", "\n\tvec3 oc = pa - ro;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nfloat", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba) / dot(ba, ba);\n\tif (h < 0.0) return length(pa);\n\tvec3 ph = pa - ba * h;\n\tfloat d1 = length(ph) - ra;\n\tfloat d2 = max(length(ph) - rb, 0.0);\n\treturn min(d1, d2);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat res = 1.0;\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 100.0;\n\tfloat eps = 0.0001;\n\tfloat d = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat h = 0.0;\n\tfloat g = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat l = 0.0;\n\tfloat o = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat", "\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r = mix(rad1, rad2, smoothstep(0.0, 1.0, d / th));\n    float s = smoothstep(0.0, 1.0, d / th);\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(r * c, r * s) * s;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0.05, 0.02, 0.01);\n    uv = snake(uv, 0", "\n\tfloat d = length(p-c);\n\treturn max(d-r,0.0);\n}\n\n// c is the center of the circle. r is the radius\nfloat", "\n\treturn 4.0 * pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec", "\n\tfloat d = length(p);\n\tfloat a = acos(clamp(dot(p,sca),-1.0,1.0));\n\tfloat b = acos(clamp(dot(p,scb),-1.0,1.0));\n\tfloat c = acos(clamp(dot(sca,scb),-1.0,1.0));\n\tfloat r = max(ra,rb);\n\tfloat s = min(ra,rb);\n\tfloat t = clamp(d-r,0.0,1.0);\n\tfloat u = clamp(d-s,0.0,1.0);\n\tfloat v = clamp(d-r-s,0.0,1.0);\n\tfloat w = clamp(d-r+s,0.0,1.0);\n\tfloat x = clamp(d+r-s,0.0,1.0);\n\tfloat y = clamp(d+r+s,0.0,1.0);\n\tfloat z = clamp(d+s,0.0,1.0);\n\tfloat A = (a+b-c)*0.5;\n\tfloat B = (a-b+c)*0.5;\n\tfloat C = (a+b+c)*0.5;\n\tfloat D = (a-b-c)*0.5;\n\tfloat E = (a+b)*0.5;\n\tfloat F = (a-b)*0.5;\n\tfloat G = (a+c)*0.5;\n\tfloat H = (a-c)*0.5;\n\tfloat I = (b+c)*0.5;\n\tfloat J = (b-c)*0.5;\n\tfloat K = (a)*0.5;\n\tfloat L = (b)*0.5;\n\tfloat M = (c)*0.5;\n\tfloat N = (r)*0.5;\n\tfloat O = (s)*0.5;\n\tfloat P = (t)*0.5;\n\tfloat Q = (u)*0.5;\n\tfloat R = (v)*0.5;\n\tfloat S = (w)*0.5;\n\tfloat T = (x", "\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<SHADOW_SAMPLES; i++ )\n\t{\n\t\tfloat h = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, 8.0*h*h*h );\n\t\tt += clamp( h*0.125, 0.02, 0.25 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n\tconst float eps = 0.001;\n\tvec3 n = vec3( 0.0 );\n\tn.x += map( pos + vec3( eps, 0.0, 0.0 ) ).x - map( pos - vec3( eps, 0.0, 0.0 ) ).x;\n\tn.y += map( pos + vec3( 0.0, eps, 0.0 ) ).x - map( pos - vec3( 0.0, eps, 0.0 ) ).x;\n\tn.z += map( pos + vec3( 0.0, 0.0, eps ) ).x - map( pos - vec3( 0.0, 0.0, eps ) ).x;\n\treturn normalize( n );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<SHADOW_SAMPLES; i++ )\n\t{\n\t\tfloat h = texture( shadowMap, ro + rd*t ).r;\n\t\tres = min( res, 8.0*h*h*h );\n\t\tt += clamp( h*2.0, 0.02, 0.2 );\n\t\tif( t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n\tvec2 p0 = floor( p );\n\tvec2 p1 = p0 + vec2( 1.0 );\n\tvec2 p2 = p0 + vec2( 2.0 );\n\tvec2 p3 = p0 + vec2( 3.0 );\n\tvec2 p4 = p0 + vec2( 4.0 );\n\tvec2 p5 = p0 + vec2( 5.0 );\n\tvec2 p6 = p0 + vec2( 6.0 );\n\tvec2 p7 = p0 + vec2( 7.0 );\n\tvec2 p8 = p0 + vec2( 8.0 );\n\tvec2 p9 = p0 + vec2( 9.0 );\n\tvec2 p10 = p0 + vec2( 10.0 );\n\tvec2 p11 = p0 + vec2( 11.0 );\n\tvec2 p12 = p0 + vec2( 12.0 );\n\tvec2 p13 = p0 + vec2( 13.0 );\n\tvec2 p14 = p0 + vec2( 14.0 );\n\tvec2 p15 = p0 + vec2( 15.0 );\n\tvec2 p16 = p0 + vec2( 16.0 );\n\tvec2 p17 = p0 + vec2( 17.0 );\n\tvec2 p18 = p0 + vec2( 18.0 );\n\tvec2 p19 = p0 + vec2( 19.0 );\n\tvec2 p20 = p0 + vec2( 20.0 );\n\tvec2 p21 = p0 + vec2( 21.0 );\n\tvec2 p22 = p0 + vec2( 22.0 );\n\tvec2 p23 = p0 + vec2( 23.0 );\n\tvec2 p24 = p0 + vec2( 24.0 );\n\tvec2 p25 = p0 + vec2( 25.0 );\n\tvec2 p26 = p0 + vec2( 26.0", "\n\treturn x * k;\n}\n\n//\n// Sawtooth function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n    vec3 sample_dir = normalize(sample_pos - surface_normal * 0.001);\n    float sample_dist = length(sample_pos - surface_normal * 0.001);\n    float sample_depth = texture(depth_map, sample_pos.xy / sample_pos.z).r;\n    float sample_depth_diff = sample_dist - sample_depth;\n    float sample_depth_diff_squared = sample_depth_diff * sample_depth_diff;\n    float sample_depth_diff_cubed = sample_depth_diff_squared * sample_depth_diff;\n    float sample_depth_diff_fourth = sample_depth_diff_cubed * sample_depth_diff;\n    float sample_depth_diff_fifth = sample_depth_diff_fourth * sample_depth_diff;\n    float sample_depth_diff_sixth = sample_depth_diff_fifth * sample_depth_diff;\n    float sample_depth_diff_seventh = sample_depth_diff_sixth * sample_depth_diff;\n    float sample_depth_diff_eighth = sample_depth_diff_seventh * sample_depth_diff;\n    float sample_depth_diff_ninth = sample_depth_diff_eighth * sample_depth_diff;\n    float sample_depth_diff_tenth = sample_depth_diff_ninth * sample_depth_diff;\n    float sample_depth_diff_eleventh = sample_depth_diff_tenth * sample_depth_diff;\n    float sample_depth_diff_twelfth = sample_depth_diff_eleventh * sample_depth_diff;\n    float sample_depth_diff_thirteenth = sample_depth_diff_twelfth * sample_depth_diff;\n    float sample_depth_diff_fourteenth = sample_depth_diff_thirteenth * sample_depth_diff;\n    float sample_depth_diff_fifteenth = sample_depth_diff_fourteenth * sample_depth_diff;\n    float sample_depth_diff_sixteenth = sample_depth_diff_fifteenth * sample_depth_diff;\n    float sample_depth_diff_seventeenth = sample_depth_diff_sixteenth *", "\n\tvec3 color = vec3(0.0);\n\tfloat distance = 0.0;\n\n\t// raymarching\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\t// get the distance to the surface\n\t\tdistance = get_distance(pos);\n\n\t\t// if the distance is negative, we have hit the ground\n\t\tif (distance < 0.0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// get the normal of the surface\n\t\tvec3 normal = get_normal(pos);\n\n\t\t// get the color of the surface\n\t\tcolor = get_color(pos);\n\n\t\t// get the lighting\n\t\tcolor += get_lighting(pos, normal, light_dir);\n\n\t\t// get the next position\n\t\tpos += normal * distance;\n\t}\n\n\t// return the color and distance\n\treturn vec4(color, distance);\n}\n\n// the main function\nvoid main() {\n\t// get the position of the pixel\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\t// get the direction of the ray\n\tvec3 dir = get_direction(uv);\n\n\t// get the light direction\n\tvec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n\n\t// get the scene color and distance\n\tvec4 scene_color = render_scene(vec3(0.0, 0.0, 0.0), dir, light_dir);\n\n\t// get the color of the atmosphere\n\tvec3 atmosphere_color = get_atmosphere_color(scene_color.w);\n\n\t// get the final color\n\tvec3 color = scene_color.xyz * atmosphere_color;\n\n\t// set the color of the pixel\n\tgl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec2 uv = coord / resolution;\n\tvec3 camera_vector = normalize(vec3(uv, 1.0) - vec3(0.5, 0.5, 0.0));\n\treturn camera_vector;\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec", "\n\tfloat d = length(p);\n\tfloat a = acos(c.x);\n\tfloat b = acos(c.y);\n\tfloat h = sqrt(d*d - ra*ra);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tfloat t = sin(b);\n\tfloat r = cos(b);\n\tfloat x = (h*s*c - r*d)/t;\n\tfloat y = (h*s*s + r*d*c)/t;\n\tfloat z = (h*c - r*d)/t;\n\treturn length(max(vec3(x,y,z),0.0));\n}\n\n// c is the sin/cos of the desired cone angle\nfloat", "\n\tvec3 color = vec3(0.0);\n\tif (material == 0) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 1) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 2) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 3) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 4) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 5) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 6) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 7) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 8) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 9) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 10) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 11) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 12) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 13) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 14) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 15) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 16) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 17) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 18) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 19) {\n\t\tcolor = vec3(0.0);\n\t} else if (material == 20) {\n\t\tcolor = vec3(0.0);\n\t} else if (material", "\n\treturn material_reflectivity[material];\n}\n\n// Get refractive index of a material.\n// 1.0 is not refractive at all.\n// 2.0 is a perfect vacuum.\nfloat", "\n\treturn materials[material].refraction;\n}\n\n// Get color of a material.\nvec", "\n\treturn materials[material].opacity;\n}\n\n// Get ambient color of a material.\nvec", "\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 p = cross(line_b - line_a, line_a - tri_a);\n    float det = dot(e1, p);\n    if (det == 0.0) {\n        return vec3(false, 0.0, 0.0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 s = line_a - tri_a;\n    float u = dot(s, p) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(false, 0.0, 0.0);\n    }\n    vec3 q = cross(s, e1);\n    float v = dot(line_a - tri_a, q) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(false, 0.0, 0.0);\n    }\n    return vec3(true, u, v);\n}\n\n// Determine whether a line intersects a sphere.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec", "\n    vec3 a = tri_b - tri_a;\n    vec3 b = tri_c - tri_a;\n    return normalize(cross(a, b));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec", "\n\tvec3 camera_direction = normalize(camera_target - camera_position);\n\tvec3 camera_up = vec3(0.0, 1.0, 0.0);\n\tvec3 camera_right = normalize(cross(camera_direction, camera_up));\n\tcamera_up = normalize(cross(camera_right, camera_direction));\n\n\treturn mat3(camera_right, camera_up, camera_direction);\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat", "\n    cast_ray_result result;\n    result.hit = false;\n    result.t = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // Find the closest intersection between the ray and the scene's\n    // directional light source.\n    vec3 light_origin = light_position;\n    vec3 light_direction = normalize(light_origin - ray_origin);\n    float t_min = 0.001;\n    float t_max = 1000.0;\n    float t_hit;\n    vec3 hit_point;\n    vec3 hit_normal;\n    bool hit = intersect_ray_sphere(ray_origin, ray_target, sphere_center, sphere_radius, t_min, t_max, t_hit, hit_point, hit_normal);\n    if (!hit) {\n        return 1.0;\n    }\n\n    // Find the closest intersection between the ray and the scene's\n    // sphere.\n    float t_min_sphere = 0.001;\n    float t_max_sphere = 1000.0;\n    float t_hit_sphere;\n    vec3 hit_point_sphere;\n    vec3 hit_normal_sphere;\n    bool hit_sphere = intersect_ray_sphere(ray_origin, ray_target, sphere_center, sphere_radius, t_min_sphere, t_max_sphere, t_hit_sphere, hit_point_sphere, hit_normal_sphere);\n    if (!hit_sphere) {\n        return 1.0;\n    }\n\n    // Find the closest intersection between the ray and the scene's\n    // sphere.\n    float t_min_sphere_2 = 0.001;\n    float t_max_sphere_2 = 1000.0;\n    float t_hit_sphere_2;\n    vec3 hit_point_sphere_2;\n    vec3 hit_normal_sphere_2;\n    bool hit_sphere_2 = intersect_ray_sphere(ray_origin, ray_target, sphere_center_2, sphere_radius_2, t_min_sphere_2, t_max_sphere_2, t_hit_sphere_2, hit_point_sphere_2, hit_normal_sphere_2);\n    if (!hit_sphere_2) {\n        return 1.0;\n    }\n\n    // Find the closest intersection between the ray and the scene's\n    // sphere.\n    float t_min_sphere_3 = 0.", "\n\treturn fract(sin(x)*10000.0);\n}\n\nfloat", "\n\tconst vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\t\t\t\t\t0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t\t-0.577350269189626,  // -1.0 + 2.0 * C.x\n\t\t\t\t\t0.024390243902439  // 1.0 / 41.0\n\t);\n\t// First corner\n\tvec2 i  = floor( p + (p.x+p.y) * C.yy );\n\tvec2 x0 = p -   i + (i.x+i.y) * C.xx;\n\n\t// Other corners\n\tvec2 i1;\n\t//i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n\t//i1.y = 1.0 - i1.x;\n\ti1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\n\t// x1 = x0 - i1 + 1.0 * C.xx ;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(", "\n\tn = (n<<13)^n;\n\tn = n*(n*n*15731+789221)+1376312589;\n\treturn float(n)/4294967296.0;\n}\n\n// 2D hash copied from Hugo Elias\nfloat", "\n\tconst vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\t\t\t\t\t0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t\t-0.577350269189626,  // -1.0 + 2.0 * C.x\n\t\t\t\t\t0.024390243902439  // 1.0 / 41.0\n\t);\n\t// First corner\n\tvec2 i  = floor( p + (p.x+p.y) * C.yy );\n\tvec2 x0 = p -   i + (i.x+i.y) * C.xx;\n\n\t// Other corners\n\tvec2 i1;\n\t//i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n\t//i1.y = 1.0 - i1.x;\n\ti1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\n\t// x1 = x0 - i1 + 1.0 * C.xx ;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289(i); // Avoid truncation effects in permutation\n\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\tvec3 m = max(0.5 - vec3(dot(", "\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat A = 1.0;\n\tfloat B = 1.0;\n\tfloat C = 1.0;\n\tfloat D = 1.0;\n\tfloat E = 1.0;\n\tfloat F = 1.0;\n\tfloat G = 1.0;\n\tfloat H = 1.0;\n\tfloat I = 1.0;\n\tfloat J = 1.0;\n\tfloat K = 1.0;\n\tfloat L = 1.0;\n\tfloat M = 1.0;\n\tfloat N = 1.0;\n\tfloat O = 1.0;\n\tfloat P = 1.0;\n\tfloat Q = 1.0;\n\tfloat R = 1.0;\n\tfloat S = 1.0;\n\tfloat T = 1.0;\n\tfloat U = 1.0;\n\tfloat V = 1.0;\n\tfloat W = 1.0;\n\tfloat X = 1.0;\n\t", "\n\tfloat a = dot(p,p);\n\tfloat b = 2.0 * dot(p,center);\n\tfloat c = dot(center,center) - radius*radius;\n\tfloat discriminant = b*b - 4.0*a*c;\n\tif (discriminant < 0.0)\n\t\treturn vec3(0.0);\n\telse\n\t{\n\t\tfloat t1 = (-b - sqrt(discriminant)) / (2.0*a);\n\t\tfloat t2 = (-b + sqrt(discriminant)) / (2.0*a);\n\t\tif (t1 < 0.0)\n\t\t\treturn getColor(p + t2*dir);\n\t\telse if (t2 < 0.0)\n\t\t\treturn getColor(p + t1*dir);\n\t\telse\n\t\t\treturn mix(getColor(p + t1*dir), getColor(p + t2*dir), 0.5);\n\t}\n}\n\nvoid main()\n{\n\tvec3 p = normalize(vec3(gl_FragCoord.xy, 2.0*radius - gl_FragCoord.z));\n\tvec3 c = getColor(p);\n\tgl_FragColor = vec4(c, 1.0);\n}\n", "\n\tvec3 p = 2.0 * pb - 1.0;\n\tvec3 a = vec3( 1.0, 0.0, 0.0 );\n\tvec3 b = vec3( 0.0, 1.0, 0.0 );\n\tvec3 c = vec3( 0.0, 0.0, 1.0 );\n\tvec3 d = vec3( 0.0, 0.0, 0.0 );\n\tfloat t = 1.0;\n\tfor( int i = 0; i < 3; i++ )\n\t{\n\t\tfloat x = p[i];\n\t\tfloat y = p[ ( i + 1 ) % 3 ];\n\t\tfloat z = p[ ( i + 2 ) % 3 ];\n\t\tfloat t1 = 1.0 - x * x - y * y - z * z;\n\t\tfloat t2 = t1 * t1;\n\t\tfloat t3 = t2 * t1;\n\t\tfloat t4 = t3 * t1;\n\t\tfloat t5 = t4 * t1;\n\t\tfloat t6 = t5 * t1;\n\t\tfloat t7 = t6 * t1;\n\t\tfloat t8 = t7 * t1;\n\t\tfloat t9 = t8 * t1;\n\t\tfloat t10 = t9 * t1;\n\t\tfloat t11 = t10 * t1;\n\t\tfloat t12 = t11 * t1;\n\t\tfloat t13 = t12 * t1;\n\t\tfloat t14 = t13 * t1;\n\t\tfloat t15 = t14 * t1;\n\t\tfloat t16 = t15 * t1;\n\t\tfloat t17 = t16 * t1;\n\t\tfloat t18 = t17 * t1;\n\t\tfloat t19 = t18 * t1;\n\t\tfloat t20 = t19 * t1;\n\t\tfloat t21 = t20 * t1;\n\t\tfloat t22 = t21 * t1;\n\t\tfloat t23 = t22 * t1;\n\t\tfloat t24 = t23", "\n\tvec3 t0 = (cen - ro) / rd;\n\tvec3 t1 = (cen + rad - ro) / rd;\n\tvec3 tmin = min(t0, t1);\n\tvec3 tmax = max(t0, t1);\n\tfloat t = max(max(tmin.x, tmin.y), tmin.z);\n\tfloat t1 = min(min(tmax.x, tmax.y), tmax.z);\n\tif (t > t1) return vec4(0.0);\n\treturn vec4(t, t1, tmin.x, tmin.y);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tstep = 0.01;\n\tfloat tstep2 = 0.001;\n\tfloat tstep3 = 0.0001;\n\tfloat tstep4 = 0.00001;\n\tfloat tstep5 = 0.000001;\n\tfloat tstep6 = 0.0000001;\n\tfloat tstep7 = 0.00000001;\n\tfloat tstep8 = 0.000000001;\n\tfloat tstep9 = 0.0000000001;\n\tfloat tstep10 = 0.00000000001;\n\tfloat tstep11 = 0.000000000001;\n\tfloat tstep12 = 0.0000000000001;\n\tfloat tstep13 = 0.00000000000001;\n\tfloat tstep14 = 0.000000000000001;\n\tfloat tstep15 = 0.0000000000000001;\n\tfloat tstep16 = 0.00000000000000001;\n\tfloat tstep17 = 0.000000000000000001;\n\tfloat tstep18 = 0.0000000000000000001;\n\tfloat tstep19 = 0.00000000000000000001;\n\tfloat tstep20 = 0.000000000000000000001;\n\tfloat tstep21 = 0.000000", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1) * w;\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat", " return fract(sin(seed++) * 43758.5453); }\n\n// ray tracing\nvec", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n\tfloat d1 = abs(p.x) - la;\n\tfloat d2 = abs(p.y) - lb;\n\tfloat d3 = abs(p.z) - h;\n\tfloat d4 = abs(p.x) - ra;\n\tfloat d5 = abs(p.y) - ra;\n\tfloat d6 = abs(p.z) - h;\n\tfloat d = min(min(min(min(min(d1, d2), d3), d4), d5), d6);\n\treturn d;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat", "\n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\tfloat d = dot( ap, ab );\n\tfloat l2 = dot( ab, ab );\n\tfloat t = clamp( d / l2, 0.0, 1.0 );\n\tvec2 pa = a + t * ab;\n\tfloat x = length( pa - p );\n\tfloat y = length( pa - a ) + length( pa - b );\n\tfloat z = y + band;\n\tfloat w = length( pa - p ) - r;\n\treturn vec4( x, y, z, w );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 d = abs(p) - b;\n    vec2 e = step(vec2(0.0),d);\n    vec2 f = min(max(d,vec2(0.0)),vec2(r));\n    vec2 g = step(vec2(0.0),f);\n    vec2 h = min(e+f,vec2(0.0));\n    vec2 i = step(vec2(0.0),h);\n    vec2 j = min(e+g,vec2(0.0));\n    vec2 k = step(vec2(0.0),j);\n    vec2 l = min(h+g,vec2(0.0));\n    vec2 m = step(vec2(0.0),l);\n    vec2 n = min(j+m,vec2(0.0));\n    vec2 o = step(vec2(0.0),n);\n    vec2 q = min(k+m,vec2(0.0));\n    vec2 t = step(vec2(0.0),q);\n    vec2 u = min(k+o,vec2(0.0));\n    vec2 v = step(vec2(0.0),u);\n    vec2 w = min(t+u,vec2(0.0));\n    vec2 x = step(vec2(0.0),w);\n    vec2 y = min(t+v,vec2(0.0));\n    vec2 z = step(vec2(0.0),y);\n    vec2 A = min(x+y,vec2(0.0));\n    vec2 B = step(vec2(0.0),A);\n    vec2 C = min(x+z,vec2(0.0));\n    vec2 D = step(vec2(0.0),C);\n    vec2 E = min(A+D,vec2(0.0));\n    vec2 F = step(vec2(0.0),E);\n    vec2 G = min(B+D,vec2(0.0));\n    vec2 H = step(vec2(0.0),G);\n    vec2 I = min(B+F,vec2(0.0));\n    vec2 J = step(vec2(0.0),I);\n    vec2", "\n\tvec2 d = abs(p)-b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tfloat d = length(p) - r;\n\tfloat d2 = d*d;\n\tfloat d3 = d2*d;\n\tfloat d4 = d3*d;\n\tfloat d5 = d4*d;\n\tfloat d6 = d5*d;\n\tfloat d7 = d6*d;\n\tfloat d8 = d7*d;\n\tfloat d9 = d8*d;\n\tfloat d10 = d9*d;\n\tfloat d11 = d10*d;\n\tfloat d12 = d11*d;\n\tfloat d13 = d12*d;\n\tfloat d14 = d13*d;\n\tfloat d15 = d14*d;\n\tfloat d16 = d15*d;\n\tfloat d17 = d16*d;\n\tfloat d18 = d17*d;\n\tfloat d19 = d18*d;\n\tfloat d20 = d19*d;\n\tfloat d21 = d20*d;\n\tfloat d22 = d21*d;\n\tfloat d23 = d22*d;\n\tfloat d24 = d23*d;\n\tfloat d25 = d24*d;\n\tfloat d26 = d25*d;\n\tfloat d27 = d26*d;\n\tfloat d28 = d27*d;\n\tfloat d29 = d28*d;\n\tfloat d30 = d29*d;\n\tfloat d31 = d30*d;\n\tfloat d32 = d31*d;\n\tfloat d33 = d32*d;\n\tfloat d34 = d33*d;\n\tfloat d35 = d34*d;\n\tfloat d36 = d35*d;\n\tfloat d37 = d36*d;\n\tfloat d38 = d37*d;\n\tfloat d39 = d38*d;\n\tfloat d40 = d39*d;\n\tfloat d41 = d40*", "\n\tfloat d = 1e30;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat a = atan( verts[i].y, verts[i].x );\n\t\tfloat b = atan( verts[(i+1)%5].y, verts[(i+1)%5].x );\n\t\tfloat c = atan( verts[(i+2)%5].y, verts[(i+2)%5].x );\n\t\tfloat h = length( verts[i] - verts[(i+1)%5] );\n\t\tfloat k = length( verts[i] - verts[(i+2)%5] );\n\t\tfloat t = (a+b+c)/3.0;\n\t\tfloat s = (a+b-c)/3.0;\n\t\tfloat x = r*cos(t);\n\t\tfloat y = r*sin(t);\n\t\tfloat dx = r*cos(s);\n\t\tfloat dy = r*sin(s);\n\t\tfloat d1 = length( p - vec2(x,y) );\n\t\tfloat d2 = length( p - vec2(x+dx,y+dy) );\n\t\tfloat d3 = length( p - vec2(x-dx,y-dy) );\n\t\tfloat d4 = length( p - vec2(x+h,y) );\n\t\tfloat d5 = length( p - vec2(x-h,y) );\n\t\tfloat d6 = length( p - vec2(x,y+k) );\n\t\tfloat d7 = length( p - vec2(x,y-k) );\n\t\td = min( d, min( d1, min( d2, min( d3, min( d4, min( d5, min( d6, d7 ) ) ) ) ) ) );\n\t}\n\treturn d;\n}\n\nfloat", "\n\tfloat d = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w1 = 0.0;\n\tfloat w2 = 0.0;\n\tfloat w3 = 0.0;\n\tfloat w4 = 0.0;\n\tfloat w5 = 0.0;\n\tfloat w6 = 0.0;\n\tfloat w7 = 0.0;\n\tfloat w8 = 0.0;\n\tfloat w9 = 0.0;\n\tfloat w10 = 0.0;\n\tfloat w11 = 0.0;\n\tfloat w12 = 0.0;\n\tfloat w13 = 0.0;\n\tfloat w14 = 0.0;\n\tfloat w15 = 0.0;\n\tfloat w16 = 0.0;\n\tfloat w17 = 0.0;\n\tfloat w18 = 0.0;\n\tfloat w19 = 0.0;\n\tfloat w20 = 0.0;\n\tfloat w21 = 0.0;\n\tfloat w22 = 0.0;\n\tfloat w23 = 0.0;\n\tfloat w24 = 0.0;\n\tfloat w25 = 0.0;\n\tfloat w26 = 0.0;\n\tfloat w27 = 0.0;\n\tfloat w28 = 0.0;\n\tfloat w29 = 0.0;\n\tfloat w30 = 0.0;\n\tfloat w31 = 0.0;\n\tfloat w32 = 0.0;\n\tfloat w33 = 0.0;\n\tfloat w3", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn vec3( a + ba * h, ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec3 n = vec3( 0.0 );\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.", "\n    vec3 a = X[0];\n    vec3 b = X[1];\n    vec3 c = X[2];\n    vec3 d = vec3(dot(a, p), dot(b, p), dot(c, p));\n    float det = dot(a, cross(b, c));\n    if (det == 0.0) {\n        return false;\n    }\n    float invdet = 1.0 / det;\n    tan1 = invdet * vec3(dot(b, c), dot(c, a), dot(a, b));\n    tan2 = invdet * vec3(dot(c, a), dot(a, b), dot(b, c));\n    return true;\n}\n\n// Return the intersection of the line from p1 to p2 with the conic X.\n// Return false if no intersection.\nbool intersect(vec3 p1, vec3 p2, mat3 X, out vec3 p) {\n    vec3 a = X[0];\n    vec3 b = X[1];\n    vec3 c = X[2];\n    vec3 d = vec3(dot(a, p1), dot(b, p1), dot(c, p1));\n    vec3 e = vec3(dot(a, p2), dot(b, p2), dot(c, p2));\n    float det = dot(a, cross(b, c));\n    if (det == 0.0) {\n        return false;\n    }\n    float invdet = 1.0 / det;\n    p = invdet * (d * cross(e, c) - e * cross(d, c) + c * cross(d, e));\n    return true;\n}\n\n// Return the intersection of the line from p1 to p2 with the conic X.\n// Return false if no intersection.\nbool intersect(vec3 p1, vec3 p2, mat3 X, out vec3 p, out float t) {\n    vec3 a = X[0];\n    vec3 b = X[1];\n    vec3 c = X[2];\n    vec3 d = vec3(dot(a, p1), dot(b, p1), dot(c, p1));\n    vec3 e = vec3(dot(a, p2), dot(b, p2", "\n\treturn a / (b + vec3(0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec", "\n\treturn 1.0f / (1.0f + x * x / (R * R));\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat", "\n\treturn 1.0f / (1.0f + e * R);\n}\n\n// Computes the falloff function\n// e: energy\n// R: radius\nfloat", "\n\tfloat k = 0.0f;\n\tif (a > b)\n\t{\n\t\tk = (a - b) / (R * R * e);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R * e);\n\t}\n\treturn k;\n}\n\n// Computes the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n\tfloat d = length(p - c);\n\treturn (d < R)? e : 0.0;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n\tfloat d = distance(a, b);\n\tfloat t = clamp((dot(a - c, b - c) + R * R - e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t1 = clamp((dot(a - c, b - c) - R * R - e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t2 = clamp((dot(a - c, b - c) - R * R + e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t3 = clamp((dot(a - c, b - c) + R * R + e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t4 = clamp((dot(a - c, b - c) - R * R - e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t5 = clamp((dot(a - c, b - c) - R * R + e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t6 = clamp((dot(a - c, b - c) + R * R + e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t7 = clamp((dot(a - c, b - c) - R * R - e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t8 = clamp((dot(a - c, b - c) - R * R + e * e) / (2.0 * dot(a - c, b - c)), 0.0, 1.0);\n\tfloat t9 = clamp((dot(a - c, b - c) + R * R + e *", "\n\tfloat d = 0.0;\n\td = min(d, Sphere(p, 0.5, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.25, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.125, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.0625, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.03125, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.015625, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.0078125, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.00390625, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.001953125, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.0009765625, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.00048828125, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.000244140625, 0.0, 0.0, 1.0));\n\td = min(d, Sphere(p, 0.0001220703125, 0.0, 0.0, 1.0));\n\td = min(d,", "\n\treturn dot(a, b);\n}\n\n// K root\nfloat", "\n\treturn normalize(vec3(\n\t\tdFdx(p.x),\n\t\tdFdy(p.y),\n\t\tdFdx(p.z)\n\t));\n}\n\n// Normal evaluation\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.00000000000000000", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.0000000", "\n\tfloat t = 0.5 * (rd.y + 1.0);\n\treturn vec3(1.0 - t, 1.0 - t, 1.0 - t);\n}\n\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = length(ba);\n\tfloat l = length(pa);\n\tfloat t = max(dot(pa, ba) / h, 0.0);\n\tfloat d = h*t - l;\n\treturn length(pa - ba*t) - r - d;\n}\n\n// arbitrary orientation\nfloat", "\n\tvec3 tmin = vec3(0.0);\n\tvec3 tmax = vec3(1.0);\n\tvec3 t = vec3(0.0);\n\tvec3 bmin = ro - rad;\n\tvec3 bmax = ro + rad;\n\tvec3 t1 = (bmin - rd) / rd;\n\tvec3 t2 = (bmax - rd) / rd;\n\tt = min(t1, t2);\n\ttmin = max(tmin, t);\n\tt = max(t1, t2);\n\ttmax = min(tmax, t);\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\treturn coord * 0.5 + 0.5;\n}\n\n// normalized vertex coordinate\nvec", "\n\tvec2 d = p - q;\n\tfloat a = length(d);\n\tfloat b = length(p + d);\n\tfloat c = length(p - d);\n\tfloat s = (a + b + c) / 2.0;\n\tfloat area = sqrt(s * (s - a) * (s - b) * (s - c));\n\tfloat h = 2.0 * area / a;\n\tfloat x = (a * a + h * h - b * b) / (2.0 * a * h);\n\tfloat y = sqrt(1.0 - x * x);\n\tfloat z = sqrt(1.0 - y * y);\n\treturn vec3(x, y, z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    float a = 1.0;\n    float b = 0.5;\n    float c = 0.25;\n    float d2 = d * d;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r;\n    float r40 = r39 * r;\n    float r41 = r40 * r;\n    float r42 = r41 * r;\n   ", "\n\tfloat a = atan( p.y, p.x );\n\tfloat b = length( p );\n\tfloat d = r * ( 1.0 - c.x );\n\tfloat e = r * ( 1.0 - c.y );\n\tfloat f = r * ( 1.0 - c.z );\n\tfloat g = r * ( 1.0 - c.w );\n\tfloat h = r * ( 1.0 - c.x * c.y );\n\tfloat i = r * ( 1.0 - c.x * c.z );\n\tfloat j = r * ( 1.0 - c.x * c.w );\n\tfloat k = r * ( 1.0 - c.y * c.z );\n\tfloat l = r * ( 1.0 - c.y * c.w );\n\tfloat m = r * ( 1.0 - c.z * c.w );\n\tfloat n = r * ( 1.0 - c.x * c.y * c.z );\n\tfloat o = r * ( 1.0 - c.x * c.y * c.w );\n\tfloat p = r * ( 1.0 - c.x * c.z * c.w );\n\tfloat q = r * ( 1.0 - c.y * c.z * c.w );\n\tfloat s = r * ( 1.0 - c.x * c.y * c.z * c.w );\n\tfloat t = d * cos( a ) + e * sin( a );\n\tfloat u = f * cos( a ) + g * sin( a );\n\tfloat v = h * cos( a ) + i * sin( a );\n\tfloat w = j * cos( a ) + k * sin( a );\n\tfloat x = l * cos( a ) + m * sin( a );\n\tfloat y = n * cos( a ) + o * sin( a );\n\tfloat z = p * cos( a ) + q * sin( a );\n\tfloat A = s * cos( a ) + t * sin( a );\n\tfloat B = s * sin( a ) - t * cos( a );\n\treturn", "\n\tvec3 n = vec3( 0.0 );\n\tvec3 f = vec3( 0.0 );\n\tvec3 g = vec3( 0.0 );\n\tvec3 h = vec3( 0.0 );\n\tvec3 i = vec3( 0.0 );\n\tvec3 j = vec3( 0.0 );\n\tvec3 k = vec3( 0.0 );\n\tvec3 l = vec3( 0.0 );\n\tvec3 m = vec3( 0.0 );\n\tvec3 n = vec3( 0.0 );\n\tvec3 o = vec3( 0.0 );\n\tvec3 p = vec3( 0.0 );\n\tvec3 q = vec3( 0.0 );\n\tvec3 r = vec3( 0.0 );\n\tvec3 s = vec3( 0.0 );\n\tvec3 t = vec3( 0.0 );\n\tvec3 u = vec3( 0.0 );\n\tvec3 v = vec3( 0.0 );\n\tvec3 w = vec3( 0.0 );\n\tvec3 x = vec3( 0.0 );\n\tvec3 y = vec3( 0.0 );\n\tvec3 z = vec3( 0.0 );\n\tvec3 a = vec3( 0.0 );\n\tvec3 b = vec3( 0.0 );\n\tvec3 c = vec3( 0.0 );\n\tvec3 d = vec3( 0.0 );\n\tvec3 e = vec3( 0.0 );\n\tvec3 f = vec3( 0.0 );\n\tvec3 g = vec3( 0.0 );\n\tvec3 h = vec3( 0.0 );\n\tvec3 i = vec3( 0.0 );\n\tvec3 j = vec3( 0.0 );\n\tvec3 k = vec3( 0.0 );\n\tvec3 l = vec3( 0.0 );\n\tvec3 m = vec3( 0.0 );\n\tvec3 n = vec3( 0.0 );\n\tvec3 o = vec3", "\n\tfloat a = atan( p.y, p.x );\n\tfloat b = atan( scb.y, scb.x );\n\tfloat c = atan( sca.y, sca.x );\n\tfloat d = atan( scb.y, scb.x );\n\tfloat e = atan( sca.y, sca.x );\n\tfloat f = atan( scb.y, scb.x );\n\tfloat g = atan( sca.y, sca.x );\n\tfloat h = atan( scb.y, scb.x );\n\tfloat i = atan( sca.y, sca.x );\n\tfloat j = atan( scb.y, scb.x );\n\tfloat k = atan( sca.y, sca.x );\n\tfloat l = atan( scb.y, scb.x );\n\tfloat m = atan( sca.y, sca.x );\n\tfloat n = atan( scb.y, scb.x );\n\tfloat o = atan( sca.y, sca.x );\n\tfloat p = atan( scb.y, scb.x );\n\tfloat q = atan( sca.y, sca.x );\n\tfloat r = atan( scb.y, scb.x );\n\tfloat s = atan( sca.y, sca.x );\n\tfloat t = atan( scb.y, scb.x );\n\tfloat u = atan( sca.y, sca.x );\n\tfloat v = atan( scb.y, scb.x );\n\tfloat w = atan( sca.y, sca.x );\n\tfloat x = atan( scb.y, scb.x );\n\tfloat y = atan( sca.y, sca.x );\n\tfloat z = atan( scb.y, scb.x );\n\tfloat aa = atan( sca.y, sca.x );\n\tfloat bb = atan( scb.y, scb.x );\n\tfloat cc = atan( sca.y, sca.x );\n\tfloat dd = atan( scb.y, scb.x );\n\tfloat ee = atan( sca.y, sca.x );\n\tfloat ff = atan( scb.y, scb.x );", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n\tvec2 q = p*2.0 - vec2(1.0);\n\tfloat a = ab.x;\n\tfloat b = ab.y;\n\tfloat c = dot(q,q);\n\tfloat d = dot(q,vec2(a,b));\n\tfloat e = dot(q,vec2(b,a));\n\tfloat f = dot(q,vec2(a*a,b*b));\n\tfloat g = dot(q,vec2(b*b,a*a));\n\tfloat h = dot(q,vec2(a*b,a*b));\n\tfloat i = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat j = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat k = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat l = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat m = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat n = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat o = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat p = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat q = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat r = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat s = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat t = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat u = dot(q,vec2(a*a*b*b,a*a*b*b));\n\tfloat v = dot(q", "\n\tfloat a = atan( p.y, p.x );\n\tfloat b = length( p.xy );\n\tfloat c = sqrt( ra*ra - b*b );\n\tfloat d = sqrt( rb*rb - c*c );\n\tfloat e = sqrt( ra*ra + rb*rb - b*b );\n\tfloat f = sqrt( ra*ra + rb*rb - c*c );\n\tfloat g = sqrt( ra*ra + rb*rb - d*d );\n\tfloat h = sqrt( ra*ra + rb*rb - e*e );\n\tfloat i = sqrt( ra*ra + rb*rb - f*f );\n\tfloat j = sqrt( ra*ra + rb*rb - g*g );\n\tfloat k = sqrt( ra*ra + rb*rb - h*h );\n\tfloat l = sqrt( ra*ra + rb*rb - i*i );\n\tfloat m = sqrt( ra*ra + rb*rb - j*j );\n\tfloat n = sqrt( ra*ra + rb*rb - k*k );\n\tfloat o = sqrt( ra*ra + rb*rb - l*l );\n\tfloat p = sqrt( ra*ra + rb*rb - m*m );\n\tfloat q = sqrt( ra*ra + rb*rb - n*n );\n\tfloat r = sqrt( ra*ra + rb*rb - o*o );\n\tfloat s = sqrt( ra*ra + rb*rb - p*p );\n\tfloat t = sqrt( ra*ra + rb*rb - q*q );\n\tfloat u = sqrt( ra*ra + rb*rb - r*r );\n\tfloat v = sqrt( ra*ra + rb*rb - s*s );\n\tfloat w = sqrt( ra*ra + rb*rb - t*t );\n\tfloat x = sqrt( ra*ra + rb*rb - u*u );\n\tfloat y = sqrt( ra*ra + rb*rb - v*v );\n\tfloat z = sqrt( ra*ra + rb*rb - w*w );\n\tfloat a1 = a + PI;\n\tfloat a2 = a + PI*2.0;\n\tfloat a3 = a + PI*3.0;", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot( pa, ba ) / dot( ba, ba );\n\tvec3 q = a + ba * clamp( h, 0.0, 1.0 );\n\tvec3 d = q - p;\n\tfloat l = length( d );\n\tfloat dl = clamp( l - r, 0.0, 1.0 );\n\tfloat dl2 = dl * dl;\n\tfloat dl3 = dl2 * dl;\n\tfloat dl4 = dl3 * dl;\n\tfloat dl5 = dl4 * dl;\n\tfloat dl6 = dl5 * dl;\n\tfloat dl7 = dl6 * dl;\n\tfloat dl8 = dl7 * dl;\n\tfloat dl9 = dl8 * dl;\n\tfloat dl10 = dl9 * dl;\n\tfloat dl11 = dl10 * dl;\n\tfloat dl12 = dl11 * dl;\n\tfloat dl13 = dl12 * dl;\n\tfloat dl14 = dl13 * dl;\n\tfloat dl15 = dl14 * dl;\n\tfloat dl16 = dl15 * dl;\n\tfloat dl17 = dl16 * dl;\n\tfloat dl18 = dl17 * dl;\n\tfloat dl19 = dl18 * dl;\n\tfloat dl20 = dl19 * dl;\n\tfloat dl21 = dl20 * dl;\n\tfloat dl22 = dl21 * dl;\n\tfloat dl23 = dl22 * dl;\n\tfloat dl24 = dl23 * dl;\n\tfloat dl25 = dl24 * dl;\n\tfloat dl26 = dl25 * dl;\n\tfloat dl27 = dl26 * dl;\n\tfloat dl28 = dl27 * dl;\n\tfloat dl29 = dl28 * dl;\n\tfloat dl30 = dl29 * dl;\n\tfloat dl31 = dl30 * dl;\n\tfloat dl32 = dl31 * dl;\n\tfloat dl33 = dl32 * dl;\n\tfloat dl34 = dl33 * dl", "\n\tvec2 q = vec2(wi,he)*p;\n\tfloat d = max(abs(q.x),abs(q.y));\n\tfloat s = sign(q.x)*sign(q.y);\n\treturn s*min(d,max(abs(q.x)-sk*abs(q.y),abs(q.y)-sk*abs(q.x)));\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n\tvec2 q = p;\n\tfloat a = wi/2.0;\n\tfloat b = he/2.0;\n\tfloat c = sk/2.0;\n\tfloat d = sqrt( a*a + b*b - c*c );\n\tfloat e = sqrt( a*a + c*c - b*b );\n\tfloat f = sqrt( b*b + c*c - a*a );\n\tfloat g = sqrt( a*a + b*b + c*c );\n\tfloat h = sqrt( a*a + b*b - c*c );\n\tfloat i = sqrt( a*a + c*c - b*b );\n\tfloat j = sqrt( b*b + c*c - a*a );\n\tfloat k = sqrt( a*a + b*b + c*c );\n\tfloat l = sqrt( a*a + b*b - c*c );\n\tfloat m = sqrt( a*a + c*c - b*b );\n\tfloat n = sqrt( b*b + c*c - a*a );\n\tfloat o = sqrt( a*a + b*b + c*c );\n\tfloat p = sqrt( a*a + b*b - c*c );\n\tfloat q = sqrt( a*a + c*c - b*b );\n\tfloat r = sqrt( b*b + c*c - a*a );\n\tfloat s = sqrt( a*a + b*b + c*c );\n\tfloat t = sqrt( a*a + b*b - c*c );\n\tfloat u = sqrt( a*a + c*c - b*b );\n\tfloat v = sqrt( b*b + c*c - a*a );\n\tfloat w = sqrt( a*a + b*b + c*c );\n\tfloat x = sqrt( a*a + b*b - c*c );\n\tfloat y = sqrt( a*a + c*c - b*b );\n\tfloat z = sqrt( b*b + c*c - a*a );\n\tfloat A = sqrt( a*a + b*b + c*c );\n\tfloat B = sqrt( a*a + b*b -", "\n\treturn p*c;\n\t}\n\nfloat", "\n\treturn (a < b)? a : (a > b)? b : (a + b) / 2.0f;\n}\n\n// IQ's polynominal max\nfloat", "\n\treturn mod(p, size) - 0.5 * size;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec", "\n\tvec3 oc = ro - s.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - s.w * s.w;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return vec2(-1.0);\n\treturn vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// IQ's ray plane intersection\nvec", "\n\tvec3 tmin = (boxSize - abs(ro)) / rd;\n\tvec3 tmax = (boxSize + abs(ro)) / rd;\n\tvec3 t0 = max(tmin, tmax);\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t = max(t0, t1);\n\toutNormal = t0 - t1;\n\treturn t;\n}\n\n// IQ's ray sphere intersection\nvec", "\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat dx = d.x;\n\tfloat dy = d.y;\n\tfloat x1 = x - dx;\n\tfloat y1 = y - dy;\n\tfloat x2 = x + dx;\n\tfloat y2 = y + dy;\n\te1 = vec2(x1, y1);\n\te2 = vec2(x2, y1);\n\te3 = vec2(x2, y2);\n\te4 = vec2(x1, y2);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat dx = d.x;\n\tfloat dy = d.y;\n\tfloat x1 = x - dx;\n\tfloat y1 = y - dy;\n\tfloat x2 = x + dx;\n\tfloat y2 = y + dy;\n\te1 = vec2(x1, y1);\n\te2 = vec2(x2, y1);\n\te3 = vec2(x2, y2);\n\te4 = vec2(x1, y2);\n\te5 = vec2(x1, y1);\n\te6 = vec2(x1, y2);\n\te7 = vec2(x2, y2);\n\te8 = vec2(x2, y1);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge12(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, in", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h);\n}\n\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 perp = ba - ba*h;\n\tfloat d1 = length( pa - perp*w1 );\n\tfloat d2 = length( pa + perp*w2 );\n\treturn min( d1, d2 );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 p = vec2(length(ro.xz)-tor.x,ro.y);\n    float a = dot(p,p)-tor.y*tor.y;\n    float b = dot(p,rd);\n    float c = dot(rd,rd);\n    float h = b*b-a*c;\n    if(h<0.0) return -1.0;\n    return -b-sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec3 p = pos;\n    vec2 q = vec2(length(p.xz) - tor.x, p.y);\n    return normalize(vec3(q, sqrt(tor.y - dot(q, q))));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    return 2.0f * tanhf(x * 0.5f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\tfloat d = 1.0 - length(q);\n\tfloat f = smoothstep(0.0, 0.005, d);\n\tcol *= f;\n\treturn col;\n}\n\nvoid main() {\n\tvec2 q = gl_FragCoord.xy / resolution.xy;\n\tq = q * 2.0 - 1.0;\n\tq.x *= resolution.x / resolution.y;\n\tvec3 col = texture2D(tDiffuse, q).rgb;\n\tcol = postProcess(col, q);\n\tgl_FragColor = vec4(col, 1.0);\n}\n", "\n\tp = mod(p, size);\n\tp = p - size * 0.5;\n\treturn p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n\tuv = fract(uv);\n\tuv += dot(uv, vec2(12.9898, 78.233));\n\treturn fract(sin(uv.x) * uv.y);\n}\n\nfloat", "\n\treturn length(p-c)-r;\n}\n\n// signed distance to a sphere\nfloat", "\n\treturn length( max(abs(p-a)-b+a,0.0) );\n}\n\n// distance to a circle\nfloat", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 3D triangle\nfloat", "\n\tvec2 d = abs(p) - s + r;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy.com/view/4dS3zW\n// https://www.shadertoy", "\n\treturn (x*(6.2*x+0.5)) / (x*(6.2*x+1.7)+0.06);\n}\n\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3zW\n// https://www.shadertoy.com/view/4sX3z", "\n\treturn 2.0 * (1.0 - x) * x;\n}\n\n// s-curve\nvec", "\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat r = 0.0;\n\tfloat q = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\t", "\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec", "\n\t// Calculate the scattering for the ray.\n\tvec3 scattering = vec3(0.0);\n\tfloat distance = 0.0;\n\tfloat stepSize = 0.001;\n\tfor (float t = 0.0; t < rayLength; t += stepSize)\n\t{\n\t\tvec3 rayEnd = rayStart + rayDir * t;\n\t\tvec3 scatteringStep = Scattering(rayEnd, lightDir);\n\t\tscattering += scatteringStep * stepSize;\n\t\tdistance += stepSize;\n\t}\n\n\t// Calculate the transmittance for the ray.\n\ttransmittance = exp(-distance * extinction);\n\n\t// Return the scattering.\n\treturn scattering;\n}\n\n// Integrate scattering over a ray for a single point light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec", "\n\tfloat r = ra - rb;\n\tfloat h = sqrt( r*r - d*d );\n\tfloat s = sqrt( r*r - h*h );\n\tfloat t = sqrt( d*d - h*h );\n\tfloat a = 0.5*s;\n\tfloat b = 0.5*t;\n\tfloat c = 0.5*h;\n\tfloat d1 = a*a + b*b - c*c;\n\tfloat d2 = 2.0*a*b;\n\tfloat d3 = a*a + b*b;\n\tfloat d4 = 2.0*a*c;\n\tfloat d5 = b*b + c*c;\n\tfloat d6 = 2.0*b*c;\n\tfloat d7 = a*a + c*c;\n\tfloat d8 = 2.0*a*h;\n\tfloat d9 = b*b + h*h;\n\tfloat d10 = 2.0*b*h;\n\tfloat d11 = c*c + h*h;\n\tfloat d12 = 2.0*c*h;\n\tfloat d13 = a*a + h*h;\n\tfloat d14 = 2.0*a*t;\n\tfloat d15 = b*b + t*t;\n\tfloat d16 = 2.0*b*t;\n\tfloat d17 = c*c + t*t;\n\tfloat d18 = 2.0*c*t;\n\tfloat d19 = h*h + t*t;\n\tfloat d20 = 2.0*h*t;\n\tfloat d21 = a*a + t*t;\n\tfloat d22 = 2.0*a*d;\n\tfloat d23 = b*b + d*d;\n\tfloat d24 = 2.0*b*d;\n\tfloat d25 = c*c + d*d;\n\tfloat d26 = 2.0*c*d;\n\tfloat d27 = h*h + d*d;\n\tfloat d28 = 2", "\n\tfloat d = sdSphere( p, r );\n\tfloat d1 = sdSphere( p, r - t );\n\treturn max( d, d1 - h );\n}\n\n// Sphere with cutting plane\n// p = point\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat", "\n\tfloat res = 1.0;\n\tfloat t = tmin;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro+rd*t ).x;\n\t\tres = min( res, 8.0*h*k/t );\n\t\tt += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4dS3zW\nfloat", "\n\treturn length(p) - r - h;\n}\n\n// p is the plane's position, n is the plane's normal\nfloat", "\n\tconst float e = 0.001;\n\treturn normalize( vec3(\n\t\tmap( pos + vec3( e, 0.0, 0.0 ) ) - map( pos - vec3( e, 0.0, 0.0 ) ),\n\t\tmap( pos + vec3( 0.0, e, 0.0 ) ) - map( pos - vec3( 0.0, e, 0.0 ) ),\n\t\tmap( pos + vec3( 0.0, 0.0, e ) ) - map( pos - vec3( 0.0, 0.0, e ) ) ) );\n}\n\n// https://www.shadertoy.com/view/4dS3zW\nfloat", "\n\treturn length(p.xy)-r;\n}\n\n// r=radius, h=height\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                         mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                     mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                         mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// 3d noise function\nfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 1.0;\n\tfor( int i = 0; i < 4; i++ )\n\t{\n\t\tf += amp * noise( p );\n\t\tp *= a;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat", "\n\tp3 = fract(p3 *.1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//perlin noise\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    float t = iTime;\n\n    // 1.\n    // color = vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, 0.0);\n    // color += vec3(0.0, 0.0, ", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n\treturn mod(p, size) - size * 0.5;\n}\n\nfloat", " return fract(sin(co) * 43758.5453); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\treturn t < 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nfloat", "\n    return c * c * (3.0 - 2.0 * c);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return dbuffer;\n    float t = -b - sqrt(h);\n    if (t < 0.0) t = -b + sqrt(h);\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat c = 0.5;\n\tfloat d = 0.5;\n\tfloat e = 0.5;\n\tfloat f = 0.5;\n\tfloat g = 0.5;\n\tfloat h = 0.5;\n\tfloat i = 0.5;\n\tfloat j = 0.5;\n\tfloat k = 0.5;\n\tfloat l = 0.5;\n\tfloat m = 0.5;\n\tfloat n = 0.5;\n\tfloat o = 0.5;\n\tfloat p = 0.5;\n\tfloat q = 0.5;\n\tfloat r = 0.5;\n\tfloat s = 0.5;\n\tfloat t = 0.5;\n\tfloat u = 0.5;\n\tfloat v = 0.5;\n\tfloat w = 0.5;\n\tfloat x = 0.5;\n\tfloat y = 0.5;\n\tfloat z = 0.5;\n\tfloat A = 0.5;\n\tfloat B = 0.5;\n\tfloat C = 0.5;\n\tfloat D = 0.5;\n\tfloat E = 0.5;\n\tfloat F = 0.5;\n\tfloat G = 0.5;\n\tfloat H = 0.5;\n\tfloat I = 0.5;\n\tfloat J = 0.5;\n\tfloat K = 0.5;\n\tfloat L = 0.5;\n\tfloat M = 0.5;\n\tfloat N = 0.5;\n\tfloat O = 0.5;\n\tfloat P = 0.5;\n\tfloat Q = 0.5;\n\tfloat R = 0.5;\n\tfloat S = 0.5;\n\tfloat T = 0.5;\n\tfloat U = 0.5;\n\tfloat V = 0.5;\n\tfloat W = 0.5;\n\tfloat X = 0.5;\n\tfloat Y = 0.5;\n\t", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\treturn back * (1.0 - front.a) + front;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n\treturn mix(back, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec2 q = vec2(cos(p.x),sin(p.x));\n    vec2 e = vec2(1.0,-7.0)*q*r;\n    float f = 1.0-0.5*(q.x*q.x+q.y*q.y);\n    float n = 100.0;\n    float s = 1.0;\n    for(int i=0; i<10; i++) {\n        s += 0.125*pow(2.0,float(i))*exp(-0.5*n*n)*mix(1.0,0.0,step(f,0.0));\n        n *= 2.0;\n    }\n    return s;\n}\n\n// https://www.shadertoy.com/view/4sX3zW\nfloat", "\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (v * (a * v + b)) / (v * (c * v + d) + e);\n}\n\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\tTemp = clamp(Temp, 0.001, 10000.0);\n\treturn vec3(1.0, 1.0, 1.0) * (Temp / (Temp + 273.15)) * (Temp / (Temp + 273.15));\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec", "\n    vec2 q = p * vec2(n, 1.0);\n    float d = length(q) - n;\n    return vec3(d, q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\treturn x - t * floor( x / t );\n}\n\n// generalization of Devil's Staircase\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat", "\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = max(d, length(p) - 0.001);\n        p = fractal(p, idx);\n    }\n    return d;\n}\n\n// raymarching func\nfloat", "\n    float a = atan(y, x);\n    float b = atan(y, x + 1.0);\n    return mix(a, b, smoothstep(0.0, 1.0, abs(x)));\n}\n\n// https://www.shadertoy.com/view/4sS3zD\nfloat", "\n\treturn vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n\treturn vec2(atanh(z.x), atanh(z.y));\n}\n\n// Inverse hyperbolic tangent \nvec", "\n\tfloat x = z.x;\n\tfloat y = z.y;\n\tfloat t = 1.0;\n\tfloat s = 1.0;\n\tfloat c = 1.0;\n\tfloat cs = 1.0;\n\tfloat sn = 0.0;\n\tfloat csn = 1.0;\n\tfloat n = 1.0;\n\tfloat d = 1.0;\n\tfloat dn = 1.0;\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\tfloat x2y2 = x2 + y2;\n\tfloat x2y2_2 = x2y2 * x2y2;\n\tfloat x2y2_3 = x2y2_2 * x2y2;\n\tfloat x2y2_4 = x2y2_3 * x2y2;\n\tfloat x2y2_5 = x2y2_4 * x2y2;\n\tfloat x2y2_6 = x2y2_5 * x2y2;\n\tfloat x2y2_7 = x2y2_6 * x2y2;\n\tfloat x2y2_8 = x2y2_7 * x2y2;\n\tfloat x2y2_9 = x2y2_8 * x2y2;\n\tfloat x2y2_10 = x2y2_9 * x2y2;\n\tfloat x2y2_11 = x2y2_10 * x2y2;\n\tfloat x2y2_12 = x2y2_11 * x2y2;\n\tfloat x2y2_13 = x2y2_12 * x2y2;\n\tfloat x2y2_14 = x2y2_13 * x2y2;\n\tfloat x2y2_15 = x2y2_14 * x2y2;\n\tfloat x2y2_16 = x2y2_15 * x2y2;\n\tfloat x2y2_17 = x2y2_16 * x2y2;\n\tfloat x", "\n\treturn vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n\tfloat x = z.x;\n\tfloat y = z.y;\n\tfloat t = 1.0;\n\tfloat s = 1.0;\n\tfloat c = 1.0;\n\tfloat cs = 1.0;\n\tfloat sn = 0.0;\n\tfloat cs2 = 1.0;\n\tfloat sn2 = 0.0;\n\tfloat cs3 = 1.0;\n\tfloat sn3 = 0.0;\n\tfloat cs4 = 1.0;\n\tfloat sn4 = 0.0;\n\tfloat cs5 = 1.0;\n\tfloat sn5 = 0.0;\n\tfloat cs6 = 1.0;\n\tfloat sn6 = 0.0;\n\tfloat cs7 = 1.0;\n\tfloat sn7 = 0.0;\n\tfloat cs8 = 1.0;\n\tfloat sn8 = 0.0;\n\tfloat cs9 = 1.0;\n\tfloat sn9 = 0.0;\n\tfloat cs10 = 1.0;\n\tfloat sn10 = 0.0;\n\tfloat cs11 = 1.0;\n\tfloat sn11 = 0.0;\n\tfloat cs12 = 1.0;\n\tfloat sn12 = 0.0;\n\tfloat cs13 = 1.0;\n\tfloat sn13 = 0.0;\n\tfloat cs14 = 1.0;\n\tfloat sn14 = 0.0;\n\tfloat cs15 = 1.0;\n\tfloat sn15 = 0.0;\n\tfloat cs16 = 1.0;\n\tfloat sn16 = 0.0;\n\tfloat cs17 = 1.0;\n\tfloat sn17 = 0.0;\n\tfloat cs18 = 1.0;\n\tfloat sn18 = 0.0;\n\tfloat cs19 = 1.0;\n\tfloat sn19 = 0.0;\n\tfloat cs20 = 1.0;\n\tfloat sn20 = 0.0;\n\tfloat cs", "\n  float contrastFactor = 1.0 + contrast;\n  return vec4(alpha.rgb * contrastFactor, alpha.a);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec", "\n\tfloat d = 0.0;\n\td = max(d, length(p.xy) - 0.5);\n\td = max(d, length(p.xz) - 0.5);\n\td = max(d, length(p.yz) - 0.5);\n\treturn d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat", "\n\tfloat a = 1.0;\n\tfloat b = 0.5;\n\tfloat c = 0.25;\n\tfloat d = 0.125;\n\tfloat e = 0.0625;\n\tfloat f = 0.03125;\n\tfloat g = 0.015625;\n\tfloat h = 0.0078125;\n\tfloat i = 0.00390625;\n\tfloat j = 0.001953125;\n\tfloat k = 0.0009765625;\n\tfloat l = 0.00048828125;\n\tfloat m = 0.000244140625;\n\tfloat n = 0.0001220703125;\n\tfloat o = 0.00006103515625;\n\tfloat p = 0.000030517578125;\n\tfloat q = 0.0000152587890625;\n\tfloat r = 0.00000762939453125;\n\tfloat s = 0.000003814697265625;\n\tfloat t = 0.0000019073486328125;\n\tfloat u = 0.00000095367431640625;\n\tfloat v = 0.000000476837158203125;\n\tfloat w = 0.0000002384185791015625;\n\tfloat x = 0.00000011920928955078125;\n\tfloat y = 0.00000005960", "\n\tfloat r = sqrt(dot(uvw, uvw));\n\tfloat a = 2.0 * r * gridRes;\n\tfloat b = 2.0 * r * gridRes;\n\tfloat c = 2.0 * r * gridRes;\n\tfloat d = 2.0 * r * gridRes;\n\tfloat e = 2.0 * r * gridRes;\n\tfloat f = 2.0 * r * gridRes;\n\tfloat g = 2.0 * r * gridRes;\n\tfloat h = 2.0 * r * gridRes;\n\tfloat i = 2.0 * r * gridRes;\n\tfloat j = 2.0 * r * gridRes;\n\tfloat k = 2.0 * r * gridRes;\n\tfloat l = 2.0 * r * gridRes;\n\tfloat m = 2.0 * r * gridRes;\n\tfloat n = 2.0 * r * gridRes;\n\tfloat o = 2.0 * r * gridRes;\n\tfloat p = 2.0 * r * gridRes;\n\tfloat q = 2.0 * r * gridRes;\n\tfloat s = 2.0 * r * gridRes;\n\tfloat t = 2.0 * r * gridRes;\n\tfloat u = 2.0 * r * gridRes;\n\tfloat v = 2.0 * r * gridRes;\n\tfloat w = 2.0 * r * gridRes;\n\tfloat x = 2.0 * r * gridRes;\n\tfloat y = 2.0 * r * gridRes;\n\tfloat z = 2.0 * r * gridRes;\n\tfloat A = 2.0 * r * gridRes;\n\tfloat B = 2.0 * r * gridRes;\n\tfloat C = 2.0 * r * gridRes;\n\tfloat D = 2.0 * r * gridRes;\n\tfloat E = 2.0 * r * gridRes;\n\tfloat F = 2.0 * r * gridRes;\n\tfloat G = 2.0 * r * gridRes;\n\tfloat H = 2.0 * r * gridRes;\n\tfloat", "\n\tfloat grid = 1.0 / gridRes;\n\tfloat grid2 = grid * grid;\n\tfloat grid3 = grid2 * grid;\n\tfloat grid4 = grid3 * grid;\n\tfloat grid5 = grid4 * grid;\n\tfloat grid6 = grid5 * grid;\n\tfloat grid7 = grid6 * grid;\n\tfloat grid8 = grid7 * grid;\n\tfloat grid9 = grid8 * grid;\n\tfloat grid10 = grid9 * grid;\n\tfloat grid11 = grid10 * grid;\n\tfloat grid12 = grid11 * grid;\n\tfloat grid13 = grid12 * grid;\n\tfloat grid14 = grid13 * grid;\n\tfloat grid15 = grid14 * grid;\n\tfloat grid16 = grid15 * grid;\n\tfloat grid17 = grid16 * grid;\n\tfloat grid18 = grid17 * grid;\n\tfloat grid19 = grid18 * grid;\n\tfloat grid20 = grid19 * grid;\n\tfloat grid21 = grid20 * grid;\n\tfloat grid22 = grid21 * grid;\n\tfloat grid23 = grid22 * grid;\n\tfloat grid24 = grid23 * grid;\n\tfloat grid25 = grid24 * grid;\n\tfloat grid26 = grid25 * grid;\n\tfloat grid27 = grid26 * grid;\n\tfloat grid28 = grid27 * grid;\n\tfloat grid29 = grid28 * grid;\n\tfloat grid30 = grid29 * grid;\n\tfloat grid31 = grid30 * grid;\n\tfloat grid32 = grid31 * grid;\n\tfloat grid33 = grid32 * grid;\n\tfloat grid34 = grid33 * grid;\n\tfloat grid35 = grid34 * grid;\n\tfloat grid36 = grid35 * grid;\n\tfloat grid37 = grid36 * grid;\n\tfloat grid38 = grid37 * grid;\n\tfloat grid39 = grid38 * grid;\n\tfloat grid40 = grid39 * grid;\n\tfloat grid41 = grid40", "\n    float d = 0.0;\n    float a = 1.0;\n    float b = 0.5;\n    float c = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float r = 0.0;\n    float q = 0.0;\n    float p = 0.0;\n    float o = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float l = 0.0;\n    float k = 0.0;\n    float j = 0.0;\n    float i = 0.0;\n    float h = 0.0;\n    float g = 0.0;\n    float f = 0.0;\n    float e = 0.0;\n    float d = 0.0;\n    float c = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float q = 0.0;\n    float p = 0.0;\n    float o = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float l = 0.0;\n    float k = 0.0;\n    float j = 0.0;\n    float i = 0.0;\n    float h = 0.0;\n    float g = 0.0;\n    float f = 0.0;\n    float e = 0.0;\n    float d = 0.0;\n    float c = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float q = 0.0;\n    float p = 0.0;\n    float o = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float l = 0.0", "\n\tt = t * 6.0;\n\tfloat r = 1.0 - t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n\tfloat g = t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n\tfloat b = t * t * (30.0 - t * (20.0 * t - 15.0));\n\treturn vec3(r, g, b);\n}\n\n// makes Cool colormap with polynimal 7\nvec", "\n\tfloat s = sin(a.z);\n\tfloat c = cos(a.z);\n\tvec3 x = vec3(1.0, 0.0, 0.0);\n\tvec3 y = cross(a, x);\n\tvec3 z = cross(x, y);\n\treturn v * c + cross(a, v) * s + dot(a, v) * y;\n}\n\n// calculates the normal of a triangle\nvec", "\n  return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    return abs(p.x) + 0.5 * abs(p.y);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat", "\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 g = f * f * (3.0 - 2.0 * f);\n    vec2 r = p + g;\n    return hexParams(r, f - 0.5);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec", "\n\tt = t * 6.0;\n\tfloat i = floor(t);\n\tfloat f = t - i;\n\tfloat p = 1.0 - f;\n\tfloat q = f;\n\tfloat r = 6.0 - q - p;\n\tfloat s = 6.0 - r - p;\n\tfloat t = 6.0 - s - p;\n\tfloat u = 6.0 - t - p;\n\tfloat v = 6.0 - u - p;\n\tfloat w = 6.0 - v - p;\n\tfloat x = 6.0 - w - p;\n\tfloat y = 6.0 - x - p;\n\tfloat z = 6.0 - y - p;\n\tfloat a = 6.0 - z - p;\n\tfloat b = 6.0 - a - p;\n\tfloat c = 6.0 - b - p;\n\tfloat d = 6.0 - c - p;\n\tfloat e = 6.0 - d - p;\n\tfloat f = 6.0 - e - p;\n\tfloat g = 6.0 - f - p;\n\tfloat h = 6.0 - g - p;\n\tfloat i = 6.0 - h - p;\n\tfloat j = 6.0 - i - p;\n\tfloat k = 6.0 - j - p;\n\tfloat l = 6.0 - k - p;\n\tfloat m = 6.0 - l - p;\n\tfloat n = 6.0 - m - p;\n\tfloat o = 6.0 - n - p;\n\tfloat p = 6.0 - o - p;\n\tfloat q = 6.0 - p - p;\n\tfloat r = 6.0 - q - p;\n\tfloat s = 6.0 - r - p;\n\tfloat t = 6.0 - s - p;\n\tfloat u = 6.0 - t - p;\n\tfloat v = 6.0 - u - p;\n\tfloat w = 6.0 - v - p;\n\tfloat x = 6.0 - w - p;\n\t", "\n\treturn (x + 1.0f) / 2.0f;\n}\n\n//returns the value of the given index in the given array\nfloat", "\n\tfloat t = time * 0.0001;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat a1 = 0.0;\n\tfloat b1 = 0.0;\n\tfloat c1 = 0.0;\n\tfloat d1 = 0.0;\n\tfloat e1 = 0.0;\n\tfloat f1 = 0.0;\n\tfloat g1 = 0.0;\n\tfloat h1 = 0.0;\n\tfloat i1 = 0.0;\n\tfloat j1 = 0.0;\n\tfloat k1 = 0.0;\n\tfloat l1 = 0.0;\n\tfloat m1 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat o1 = 0.0;\n\tfloat p1 = 0.0;\n\tfloat q1 = 0.0;\n\tfloat r1 = 0.0;\n\tfloat s1 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat u1 = 0.0;\n\tfloat v1 =", "\n\tfloat flow = 0.0;\n\tfloat step = 1.0 / gridRes;\n\tfloat step2 = step * 2.0;\n\tfloat step3 = step * 3.0;\n\tfloat step4 = step * 4.0;\n\tfloat step5 = step * 5.0;\n\tfloat step6 = step * 6.0;\n\tfloat step7 = step * 7.0;\n\tfloat step8 = step * 8.0;\n\tfloat step9 = step * 9.0;\n\tfloat step10 = step * 10.0;\n\tfloat step11 = step * 11.0;\n\tfloat step12 = step * 12.0;\n\tfloat step13 = step * 13.0;\n\tfloat step14 = step * 14.0;\n\tfloat step15 = step * 15.0;\n\tfloat step16 = step * 16.0;\n\tfloat step17 = step * 17.0;\n\tfloat step18 = step * 18.0;\n\tfloat step19 = step * 19.0;\n\tfloat step20 = step * 20.0;\n\tfloat step21 = step * 21.0;\n\tfloat step22 = step * 22.0;\n\tfloat step23 = step * 23.0;\n\tfloat step24 = step * 24.0;\n\tfloat step25 = step * 25.0;\n\tfloat step26 = step * 26.0;\n\tfloat step27 = step * 27.0;\n\tfloat step28 = step * 28.0;\n\tfloat step29 = step * 29.0;\n\tfloat step30 = step * 30.0;\n\tfloat step31 = step * 31.0;\n\tfloat step32 = step * 32.0;\n\tfloat step33 = step * 33.0;\n\tfloat step34 = step * 34.0;\n\tfloat step35 = step * ", "\n    float angle = atan(point.y, point.x);\n    float speed = 1.0 + sin(time * 0.05) * 0.5;\n    float dist = distance(point, vec2(0.0));\n    float flow = speed * (1.0 - smoothstep(radius, radius + 0.05, dist));\n    return vec2(cos(angle + flow), sin(angle + flow));\n}\n\n// makes a simple flowmap of a cyclone\nvec", "\n    return vec2(floor(pos.x / tileSize), floor(pos.y / tileSize)) * tileSize;\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec2 pos) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec3 pos) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec4 pos) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec2 pos, int tileSize) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec3 pos, int tileSize) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec4 pos, int tileSize) {\n    return ivec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec2 pos, vec2 tileSize) {\n    return ivec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec3 pos, vec2 tileSize) {\n    return ivec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec4 pos, vec2 tileSize) {\n    return ivec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y));\n}\n\n// Computes the tile containing pixel pos\nivec2 arrowTileCoord(vec2 pos, vec", "\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat a = dot(v, v);\n\tfloat b = dot(v, w);\n\tfloat c = dot(w, w) - 1.0;\n\tfloat d = b*b - a*c;\n\tif (d < 0.0) return -1.0;\n\treturn (-b - sqrt(d)) / a;\n}\n\n// Computes the signed distance from a triangle\nfloat", "\n    float d = length(p - arrowTileCenterCoord(p));\n    float arrowLength = 10.0;\n    float arrowWidth = 2.0;\n    float arrowHeadLength = 4.0;\n    float arrowHeadWidth = 2.0;\n    float arrowHeadAngle = 0.5;\n    float arrowHeadAngleCos = cos(arrowHeadAngle);\n    float arrowHeadAngleSin = sin(arrowHeadAngle);\n    float arrowHeadAngleCos2 = arrowHeadAngleCos * arrowHeadAngleCos;\n    float arrowHeadAngleSin2 = arrowHeadAngleSin * arrowHeadAngleSin;\n    float arrowHeadAngleCos3 = arrowHeadAngleCos2 * arrowHeadAngleCos;\n    float arrowHeadAngleSin3 = arrowHeadAngleSin2 * arrowHeadAngleSin;\n    float arrowHeadAngleCos4 = arrowHeadAngleCos3 * arrowHeadAngleCos;\n    float arrowHeadAngleSin4 = arrowHeadAngleSin3 * arrowHeadAngleSin;\n    float arrowHeadAngleCos5 = arrowHeadAngleCos4 * arrowHeadAngleCos;\n    float arrowHeadAngleSin5 = arrowHeadAngleSin4 * arrowHeadAngleSin;\n    float arrowHeadAngleCos6 = arrowHeadAngleCos5 * arrowHeadAngleCos;\n    float arrowHeadAngleSin6 = arrowHeadAngleSin5 * arrowHeadAngleSin;\n    float arrowHeadAngleCos7 = arrowHeadAngleCos6 * arrowHeadAngleCos;\n    float arrowHeadAngleSin7 = arrowHeadAngleSin6 * arrowHeadAngleSin;\n    float arrowHeadAngleCos8 = arrowHeadAngleCos7 * arrowHeadAngleCos;\n    float arrowHeadAngleSin8 = arrowHeadAngleSin7 * arrowHeadAngleSin;\n    float arrowHeadAngleCos9 = arrowHeadAngleCos8 * arrowHeadAngleCos;\n    float arrowHeadAngleSin9 = arrowHeadAngleSin8 * arrowHeadAngleSin;\n    float arrowHeadAngleCos10 = arrowHeadAngleCos9 * arrowHeadAngleCos;\n    float arrowHeadAngleSin10 = arrowHeadAngleSin9 * arrowHeadAngleSin;\n    float arrowHeadAngleCos11 = arrowHeadAngleCos10 * arrowHeadAngleCos;\n    float arrowHeadAngleSin11 = arrowHeadAngleSin10 * arrowHeadAngleSin;\n    float arrowHeadAngleCos12 = arrowHeadAngleCos11 * arrowHeadAngleCos;\n    float arrowHeadAngleSin12 = arrowHeadAngle", "\n\treturn x*0.5+0.5;\n}\n\n//returns the distance between two points\nfloat", "\n\tfloat angle = atan(point.y, point.x);\n\tfloat radius = length(point);\n\tfloat radius2 = radius * radius;\n\tfloat radius3 = radius2 * radius;\n\tfloat radius4 = radius3 * radius;\n\tfloat radius5 = radius4 * radius;\n\tfloat radius6 = radius5 * radius;\n\tfloat radius7 = radius6 * radius;\n\tfloat radius8 = radius7 * radius;\n\tfloat radius9 = radius8 * radius;\n\tfloat radius10 = radius9 * radius;\n\tfloat radius11 = radius10 * radius;\n\tfloat radius12 = radius11 * radius;\n\tfloat radius13 = radius12 * radius;\n\tfloat radius14 = radius13 * radius;\n\tfloat radius15 = radius14 * radius;\n\tfloat radius16 = radius15 * radius;\n\tfloat radius17 = radius16 * radius;\n\tfloat radius18 = radius17 * radius;\n\tfloat radius19 = radius18 * radius;\n\tfloat radius20 = radius19 * radius;\n\tfloat radius21 = radius20 * radius;\n\tfloat radius22 = radius21 * radius;\n\tfloat radius23 = radius22 * radius;\n\tfloat radius24 = radius23 * radius;\n\tfloat radius25 = radius24 * radius;\n\tfloat radius26 = radius25 * radius;\n\tfloat radius27 = radius26 * radius;\n\tfloat radius28 = radius27 * radius;\n\tfloat radius29 = radius28 * radius;\n\tfloat radius30 = radius29 * radius;\n\tfloat radius31 = radius30 * radius;\n\tfloat radius32 = radius31 * radius;\n\tfloat radius33 = radius32 * radius;\n\tfloat radius34 = radius33 * radius;\n\tfloat radius35 = radius34 * radius;\n\tfloat radius36 = radius35 * radius;\n\tfloat radius37 = radius36 * radius;\n\tfloat radius38 = radius37 * radius;\n\tfloat radius39 = radius38 * radius;\n\tfloat radius40 = radius39 * radius", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n\tfloat d = 0.0;\n\tfloat s = 1.0;\n\tfloat t = 0.0;\n\tfloat r = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\t", "\n\tfloat r = length(p);\n\tfloat t = time * sp;\n\tfloat a = atan(p.y,p.x);\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\tfloat x = r * c;\n\tfloat y = r * s;\n\tfloat d = length(vec2(x,y)) - ra;\n\treturn d;\n}\n\n// the point of this shader\nfloat", "\n\treturn max(max(abs(uvw.x), abs(uvw.y)), abs(uvw.z));\n}\n\n//edge distance of a Cone\nfloat", "\n\tvec3 uvw2 = uvw * 2.0;\n\tvec3 uvw3 = uvw2 * 2.0;\n\tvec3 uvw4 = uvw3 * 2.0;\n\tvec3 uvw5 = uvw4 * 2.0;\n\tvec3 uvw6 = uvw5 * 2.0;\n\tvec3 uvw7 = uvw6 * 2.0;\n\tvec3 uvw8 = uvw7 * 2.0;\n\tvec3 uvw9 = uvw8 * 2.0;\n\tvec3 uvw10 = uvw9 * 2.0;\n\tvec3 uvw11 = uvw10 * 2.0;\n\tvec3 uvw12 = uvw11 * 2.0;\n\tvec3 uvw13 = uvw12 * 2.0;\n\tvec3 uvw14 = uvw13 * 2.0;\n\tvec3 uvw15 = uvw14 * 2.0;\n\tvec3 uvw16 = uvw15 * 2.0;\n\tvec3 uvw17 = uvw16 * 2.0;\n\tvec3 uvw18 = uvw17 * 2.0;\n\tvec3 uvw19 = uvw18 * 2.0;\n\tvec3 uvw20 = uvw19 * 2.0;\n\tvec3 uvw21 = uvw20 * 2.0;\n\tvec3 uvw22 = uvw21 * 2.0;\n\tvec3 uvw23 = uvw22 * 2.0;\n\tvec3 uvw24 = uvw23 * 2.0;\n\tvec3 uvw25 = uvw24 * 2.0;\n\tvec3 uvw26 = uvw25 * 2.0;\n\tvec3 uvw27 = uvw26 * 2.0;\n\tvec3 uvw28 = uvw27 * 2.0;\n\tvec3 uvw29 = uvw28 * 2.", "\n\tvec3 cell = floor(uvw * gridRes) + offset;\n\treturn textureCube(cubeMap, cell);\n}\n\n// scaled with offset cube tiling\nvec", "\n\tt = t * 6.0;\n\tfloat b = floor(t);\n\tfloat f = t - b;\n\tfloat x = f * f * (3.0 - 2.0 * f);\n\tfloat r, g, b;\n\tif (b < 1.0) {\n\t\tr = 1.0;\n\t\tg = x;\n\t\tb = 0.0;\n\t} else if (b < 2.0) {\n\t\tr = 4.0 - 2.0 * b;\n\t\tg = 1.0;\n\t\tb = 0.0;\n\t} else if (b < 3.0) {\n\t\tr = 0.0;\n\t\tg = 1.0;\n\t\tb = x;\n\t} else if (b < 4.0) {\n\t\tr = 0.0;\n\t\tg = 4.0 - 2.0 * b;\n\t\tb = 1.0;\n\t} else if (b < 5.0) {\n\t\tr = x;\n\t\tg = 0.0;\n\t\tb = 1.0;\n\t} else {\n\t\tr = 1.0;\n\t\tg = 0.0;\n\t\tb = 4.0 - 2.0 * b;\n\t}\n\treturn vec3(r, g, b);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n\tfloat d = length(p) - 1.0;\n\treturn max(d, 0.0);\n}\n\n//Distance from the Edge of Octahedron\nfloat", "\n\tfloat x = t * 6.283185307179586476925286766559;\n\tfloat y = sin(x);\n\tfloat z = cos(x);\n\treturn vec3(y, y, z);\n}\n\n// makes summer colormap with polynimal 6\nvec", "\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= aspect;\n\treturn vec3(uv, 0.0);\n}\n\n// simple square Tiling\nvec", "\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= 1.0 + uv.y * 0.5;\n\treturn vec3(uv, 0.0);\n}\n\n//rhombic shape form Euclidean distance\nvec", "\n\tvec2 grid = floor(uv * gridRes) / gridRes;\n\tfloat gridX = mod(grid.x, 2.0);\n\tfloat gridY = mod(grid.y, 2.0);\n\treturn mix(vec3(0.0), vec3(1.0), gridX + gridY);\n}\n\n// nakes a checkered pattern\nvec", "\n\tfloat grid = floor(uv.x * gridRes) + floor(uv.y * gridRes);\n\treturn vec3(grid % 2.0);\n}\n\n// nakes a pixelized pattern\nvec", "\n\tfloat d = distance(uv, offset);\n\tfloat t = time * 0.001;\n\tfloat f = smoothstep(0.0, 1.0, d / len);\n\tfloat g = smoothstep(0.0, 1.0, (d - t) / len);\n\treturn f * g;\n}\n\n// generates pixelated directional waves\nfloat", "\n    float t = time * 0.001;\n    float r = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a1 = 0.0;\n    float b1 = 0.0;\n    float c1 = 0.0;\n    float d1 = 0.0;\n    float e1 = 0.0;\n    float f1 = 0.0;\n    float g1 = 0.0;\n    float h1 = 0.0;\n    float i1 = 0.0;\n    float j1 = 0.0;\n    float k1 = 0.0;\n    float l1 = 0.0;\n    float m1 = 0.0;\n    float n1 = 0.0;\n    float o1 = 0.0;\n    float p1 = 0.0;\n    float q1 = 0.0;\n    float r1 = 0.0;\n    float s1 = 0.0;\n    float t1 = 0.0;\n    float u1 = 0.0;\n    float v1 = 0.0;\n    float w1 = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z1 = ", "\n\tfloat res = 0.0;\n\tfloat dx = 1.0 / 1024.0;\n\tfloat dy = 1.0 / 1024.0;\n\tfor( float y = -1.0; y <= 1.0; y += dy )\n\t{\n\t\tfor( float x = -1.0; x <= 1.0; x += dx )\n\t\t{\n\t\t\tvec2 q = p + ddx * x + ddy * y;\n\t\t\tres += texture2D( gridTexture, q ).r;\n\t\t}\n\t}\n\treturn res;\n}\n\nfloat", "\n    vec2 q = abs(p);\n    return max(q.x, q.y) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p.x = p.x * 2.0 - 1.0;\n    p.y = p.y * 2.0 - 1.0;\n    p.x *= 1.0 + p.y * 0.2;\n    return p;\n}\n\n// License: Unknown, author: <NAME>, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec", "\n\treturn 1.0 - 0.5 * ( sin( x ) + 1.0 );\n}\n\n// https://www.shadertoy.com/view/4dS3zW\nfloat", "\n\treturn t * t * (3.0 - 2.0 * t);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    float d = 0.0;\n    float s = 0.5;\n    float c = 0.5;\n    float t = 0.0;\n    float r = 0.0;\n    float f = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float e = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0", "\n\tfloat d = 0.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\td += s * abs(sin(p.x * 10.0 + p.y * 10.0 * float(i)));\n\t\ts *= 0.5;\n\t}\n\treturn d;\n}\n\nfloat", "\n\tvec2 e1 = p1 - p0;\n\tvec2 e2 = p2 - p0;\n\tvec2 d00 = cross( e2, p0 - p );\n\tvec2 d10 = cross( e2, p1 - p );\n\tvec2 d20 = cross( e2, p2 - p );\n\tvec2 d01 = cross( e1, p0 - p );\n\tvec2 d11 = cross( e1, p1 - p );\n\tvec2 d21 = cross( e1, p2 - p );\n\n\tfloat invDenom = 1.0 / ( d00.x * d11.y - d01.x * d10.y + ( d01.x - d00.x ) * d11.y + ( d00.x - d10.x ) * d11.y );\n\treturn ( ( d00.x * d11.y - d01.x * d10.y + ( d01.x - d00.x ) * d11.y + ( d00.x - d10.x ) * d11.y ) * invDenom );\n}\n\n// signed distance to a 3D triangle\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return dbuffer;\n    float t = -b - sqrt(h);\n    if (t < 0.0) t = -b + sqrt(h);\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat", "\n    return length(p.yx) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n\tfloat a = 1.0 - k;\n\tfloat b = k;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat A = 1.0;\n\tfloat B = 1.0;\n\tfloat C = 1.0;\n\tfloat D = 1.0;\n\tfloat E = 1.0;\n\tfloat F = 1.0;\n\tfloat G = 1.0;\n\tfloat H = 1.0;\n\tfloat I = 1.0;\n\tfloat J = 1.0;\n\tfloat K = 1.0;\n\tfloat L = 1.0;\n\tfloat M = 1.0;\n\tfloat N = 1.0;\n\tfloat O = 1.0;\n\tfloat P = 1.0;\n\tfloat Q = 1.0;\n\tfloat R = 1.0;\n\tfloat S = 1.0;\n\tfloat T = 1.0;\n\tfloat U = 1.0;\n\tfloat V = 1.0;\n\tfloat W = 1.0;\n\tfloat X = 1.0;\n\tfloat Y = 1.0;\n\tfloat", "\n\treturn length(p)-1.0;\n}\n\n// distance to y=1/x^2\nfloat", "\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n    return (a < 0.0)? -a * k : a * k;\n}\n\nfloat", "\n    vec2 q = abs(p);\n    return 1.0 - min(max(q.x, q.y), q.x + q.y) * 0.5;\n}\n\n// https://www.shadertoy.com/view/4dS3zW\nfloat", "\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n\tvec2 AB = B - A;\n\tvec2 BC = C - B;\n\tvec2 AC = C - A;\n\tvec2 AB2 = AB * AB;\n\tvec2 BC2 = BC * BC;\n\tvec2 AC2 = AC * AC;\n\tvec2 AB3 = AB2 * AB;\n\tvec2 BC3 = BC2 * BC;\n\tvec2 AC3 = AC2 * AC;\n\tvec2 AB4 = AB3 * AB;\n\tvec2 BC4 = BC3 * BC;\n\tvec2 AC4 = AC3 * AC;\n\tvec2 AB5 = AB4 * AB;\n\tvec2 BC5 = BC4 * BC;\n\tvec2 AC5 = AC4 * AC;\n\tvec2 AB6 = AB5 * AB;\n\tvec2 BC6 = BC5 * BC;\n\tvec2 AC6 = AC5 * AC;\n\tvec2 AB7 = AB6 * AB;\n\tvec2 BC7 = BC6 * BC;\n\tvec2 AC7 = AC6 * AC;\n\tvec2 AB8 = AB7 * AB;\n\tvec2 BC8 = BC7 * BC;\n\tvec2 AC8 = AC7 * AC;\n\tvec2 AB9 = AB8 * AB;\n\tvec2 BC9 = BC8 * BC;\n\tvec2 AC9 = AC8 * AC;\n\tvec2 AB10 = AB9 * AB;\n\tvec2 BC10 = BC9 * BC;\n\tvec2 AC10 = AC9 * AC;\n\tvec2 AB11 = AB10 * AB;\n\tvec2 BC11 = BC10 * BC;\n\tvec2 AC11 = AC10 * AC;\n\tvec2 AB12 = AB11 * AB;\n\tvec2 BC12 = BC11 * BC;\n\tvec2 AC12 = AC11 * AC;\n\tvec2 AB13 = AB12 * AB;\n\tvec2 BC13 = BC12 * BC;\n\tvec2 AC13 = AC12 * AC;\n\tvec2 AB14 = AB13 * AB;\n\tvec2 BC14 = BC13 * BC;\n\tvec2", "\n\tvec2 p = pos;\n\tp.x -= wi;\n\tp.y -= he;\n\tfloat d = length(p);\n\treturn vec3(d, p.x, p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 p = pos;\n\tfloat d = length(p);\n\tfloat r = d - k;\n\treturn vec3( r, 2.0*k*p.x, 2.0*k*p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p;\n    float r = length(q);\n    float a = ra;\n    float b = rb;\n    float c = d;\n    float d = r - a;\n    float e = r - b;\n    float f = r - c;\n    float g = r - d;\n    float h = r - e;\n    float i = r - f;\n    float j = r - g;\n    float k = r - h;\n    float l = r - i;\n    float m = r - j;\n    float n = r - k;\n    float o = r - l;\n    float p = r - m;\n    float q = r - n;\n    float r = r - o;\n    float s = r - p;\n    float t = r - q;\n    float u = r - s;\n    float v = r - t;\n    float w = r - u;\n    float x = r - v;\n    float y = r - w;\n    float z = r - x;\n    float A = r - y;\n    float B = r - z;\n    float C = r - A;\n    float D = r - B;\n    float E = r - C;\n    float F = r - D;\n    float G = r - E;\n    float H = r - F;\n    float I = r - G;\n    float J = r - H;\n    float K = r - I;\n    float L = r - J;\n    float M = r - K;\n    float N = r - L;\n    float O = r - M;\n    float P = r - N;\n    float Q = r - O;\n    float R = r - P;\n    float S = r - Q;\n    float T = r - R;\n    float U = r - S;\n    float V = r - T;\n    float W = r - U;\n    float X = r - V;\n    float Y = r - W;\n    float Z = r - X;\n    float aa = r - Y;\n    float ab = r - Z;\n    float ac = r - aa;\n    float ad = r - ab;\n    float ae = r - ac;\n    float af = r - ad;\n    float ag = r - ae;\n    float ah = r - af;\n    float ai = r - ag;\n    float aj = r - ah;\n    float ak = r - ai", "\n\tv = v * 1664525u + 1013904223u;\n\tv.x += v.y * 1u;\n\tv.y += v.x * 1u;\n\treturn v;\n}\n\nfloat", "\n\tv = v * 1664525 + 1013904223;\n\tv.x += v.y * v.z;\n\tv.y += v.z * v.x;\n\tv.z += v.x * v.y;\n\treturn v;\n}\n\nfloat", "\n\tvec2 p = pos - A;\n\tvec2 q = pos - B;\n\tvec2 r = pos - C;\n\tfloat d1 = dot(p, p) - dot(p, q) + dot(q, q);\n\tfloat d2 = dot(q, q) - dot(q, r) + dot(r, r);\n\tfloat d3 = dot(r, r) - dot(r, p) + dot(p, p);\n\tfloat d = max(d1, max(d2, d3));\n\treturn sqrt(d);\n}\n\n// signed distance to a cubic bezier\nfloat", "\n\tvec2 v = b - a;\n\tvec2 w = p - a;\n\tfloat c = dot(v, w);\n\tfloat d = dot(v, v);\n\treturn sign(c) / sqrt(d);\n}\n\nfloat", "\n\tvec3 p = ro;\n\tvec3 d = rd;\n\tvec3 n = normalize( cross( s.yz, s.zx ) );\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000", "\n\tint n = a * int(b + x);\n\tret_n = n;\n\treturn float(n) - x;\n}\n\n// https://www.shadertoy.com/view/4sf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n\tfloat h = clamp( 0.5 + 0.5*(b.y-a.y)/(b.x-a.x), 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*(1.0-h)*(b-a);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n\tfloat d = length(p-ab);\n\tfloat a = length(ab);\n\tfloat b = length(p-ab.yx);\n\treturn (d-a)*(d-b);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat", "\n\treturn a + b;\n}\n\nfloat", "\n\tvec2 q = p - ab.xy;\n\tfloat d = dot(q,q);\n\tfloat t = clamp( (d-s1)/(s2-s1), 0.0, 1.0 );\n\treturn p + q*t;\n}\n\n//for highlighting individual solutions\nvec", "\n\tvec3 ap = p - a;\n\tvec3 ab = b - a;\n\tfloat d = dot(ap, ab);\n\tfloat h = dot(ab, ab) - d * d;\n\tfloat r = max(ra, rb);\n\tfloat k = r * r - h;\n\tif (k < 0.0)\n\t\treturn vec4(0.0);\n\tfloat t = sqrt(k);\n\tfloat x = d - t;\n\tfloat y = d + t;\n\tfloat z = dot(ap, ab) / dot(ab, ab);\n\treturn vec4(x, y, z, 1.0);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat", "\n\treturn length(p-cen) - rad;\n}\n\nfloat", "\n\tvec3 n = vec3( 0.0 );\n\tfloat d = 0.0;\n\tfloat h = 0.001;\n\tfloat dh = 0.0;\n\tfloat dh2 = 0.0;\n\tfloat dh3 = 0.0;\n\tfloat dh4 = 0.0;\n\tfloat dh5 = 0.0;\n\tfloat dh6 = 0.0;\n\tfloat dh7 = 0.0;\n\tfloat dh8 = 0.0;\n\tfloat dh9 = 0.0;\n\tfloat dh10 = 0.0;\n\tfloat dh11 = 0.0;\n\tfloat dh12 = 0.0;\n\tfloat dh13 = 0.0;\n\tfloat dh14 = 0.0;\n\tfloat dh15 = 0.0;\n\tfloat dh16 = 0.0;\n\tfloat dh17 = 0.0;\n\tfloat dh18 = 0.0;\n\tfloat dh19 = 0.0;\n\tfloat dh20 = 0.0;\n\tfloat dh21 = 0.0;\n\tfloat dh22 = 0.0;\n\tfloat dh23 = 0.0;\n\tfloat dh24 = 0.0;\n\tfloat dh25 = 0.0;\n\tfloat dh26 = 0.0;\n\tfloat dh27 = 0.0;\n\tfloat dh28 = 0.0;\n\tfloat dh29 = 0.0;\n\tfloat dh30 = 0.0;\n\tfloat dh31 = 0.0;\n\tfloat dh32 = 0.0;\n\tfloat dh33 = 0.0;\n\tfloat dh34 = 0.0;\n\tfloat dh35 = 0.0;\n\tfloat dh36 = 0.0;\n\tfloat dh37 = 0.0;\n\tfloat dh38 = 0.0;\n\tfloat dh39 = 0.0;\n\tfloat dh40 = 0.0;\n\tfloat dh41", "\n\tfloat res = 1.0;\n\tfloat t = 0.01;\n\tfloat bias = 0.005;\n\tfloat k = 0.15;\n\tfloat maxDist = 10.0;\n\tfloat dist = 0.0;\n\tfloat occ = 0.0;\n\tfloat soft = 1.0;\n\tfloat softness = 0.0;\n\tfloat softness2 = 0.0;\n\tfloat softness3 = 0.0;\n\tfloat softness4 = 0.0;\n\tfloat softness5 = 0.0;\n\tfloat softness6 = 0.0;\n\tfloat softness7 = 0.0;\n\tfloat softness8 = 0.0;\n\tfloat softness9 = 0.0;\n\tfloat softness10 = 0.0;\n\tfloat softness11 = 0.0;\n\tfloat softness12 = 0.0;\n\tfloat softness13 = 0.0;\n\tfloat softness14 = 0.0;\n\tfloat softness15 = 0.0;\n\tfloat softness16 = 0.0;\n\tfloat softness17 = 0.0;\n\tfloat softness18 = 0.0;\n\tfloat softness19 = 0.0;\n\tfloat softness20 = 0.0;\n\tfloat softness21 = 0.0;\n\tfloat softness22 = 0.0;\n\tfloat softness23 = 0.0;\n\tfloat softness24 = 0.0;\n\tfloat softness25 = 0.0;\n\tfloat softness26 = 0.0;\n\tfloat softness27 = 0.0;\n\tfloat softness28 = 0.0;\n\tfloat softness29 = 0.0;\n\tfloat softness30 = 0.0;\n\tfloat softness31 = 0.0;\n\tfloat softness32 = 0.0;\n\tfloat softness33 = 0.0;\n\tfloat softness34", "\n\tfloat h = he;\n\tfloat r = ra;\n\tfloat r2 = rb;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41 = r40*", "\n\tvec3 q = vec3( length(p.xz), p.y, p.x );\n\tfloat a = length(q) - ra;\n\tfloat b = q.z;\n\tfloat c = sqrt( ra*ra - a*a );\n\tfloat h = max( abs(b)-c, 0.0 );\n\tfloat d = length(vec2(a,b)) - rb;\n\treturn vec4( vec3(a,h,b), d );\n}\n\n//vec4 sdgTorus( vec3 p, float ra, float rb )\n//{\n//\tvec3 q = vec3( length(p.xz), p.y, p.x );\n//\tfloat a = length(q) - ra;\n//\tfloat b = q.z;\n//\tfloat c = sqrt( ra*ra - a*a );\n//\tfloat h = max( abs(b)-c, 0.0 );\n//\tfloat d = length(vec2(a,b)) - rb;\n//\treturn vec4( vec3(a,h,b), d );\n//}\n\n//vec4 sdgTorus( vec3 p, float ra, float rb )\n//{\n//\tvec3 q = vec3( length(p.xz), p.y, p.x );\n//\tfloat a = length(q) - ra;\n//\tfloat b = q.z;\n//\tfloat c = sqrt( ra*ra - a*a );\n//\tfloat h = max( abs(b)-c, 0.0 );\n//\tfloat d = length(vec2(a,b)) - rb;\n//\treturn vec4( vec3(a,h,b), d );\n//}\n\n//vec4 sdgTorus( vec3 p, float ra, float rb )\n//{\n//\tvec3 q = vec3( length(p.xz), p.y, p.x );\n//\tfloat a = length(q) - ra;\n//\tfloat b = q.z;\n//\tfloat c = sqrt( ra*ra - a*a );\n//\tfloat h = max( abs(b)-c, 0.0 );\n//\tfloat d = length(", "\n    return length(max(abs(p-a)-b+a,0.0));\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat", " return dot(v, v); }\nfloat", "\n\tvec2 d = abs(p - minCorner);\n\tvec2 e = abs(p - maxCorner);\n\tvec2 f = min(d, e);\n\treturn min(f.x, f.y) * min(f.x, f.y);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat n = 0.0;\n\tfloat m = 0.0;\n\tfloat l = 0.0;\n\tfloat k = 0.0;\n\tfloat j = 0.0;\n\tfloat i = 0.0;\n\tfloat h = 0.0;\n\tfloat g = 0.0;\n\tfloat f = 0.0;\n\tfloat e = 0.0;\n\tfloat d = 0.0;\n\tfloat c = 0.0;\n\tfloat b = 0.0;\n\tfloat a = 0.0;\n\tfloat z = 0.0;\n\tfloat y = 0.0;\n\tfloat x = 0.0;\n\tfloat w = 0.0;\n\tfloat v = 0.0;\n\tfloat u = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat q = 0.0;\n\tfloat p = 0.0;\n\tfloat o = 0.0;\n\tfloat n = 0.0;\n\tfloat m = 0.0;\n\tfloat l = 0.0;\n\tfloat k = 0.0;\n\tfloat j = 0.0;\n\tfloat i = 0.0;\n\tfloat h = 0.0;\n\tfloat g = 0.0;\n\tfloat f = 0.0;\n\tfloat e = 0.0;\n\tfloat d = 0.0;\n\tfloat c = 0.0;\n\tfloat b = 0.0;\n\tfloat a = 0.0;\n\tfloat z = 0.0;\n\tfloat y = 0.0;\n\tfloat x = 0.0;\n\tfloat w = 0.0;\n\tfloat v = 0.0;\n\t", "\n\tvec3 ray = vec3(uv, 1.0);\n\tray.xy *= iResolution.xy / iResolution.y;\n\tray.z = -1.0;\n\treturn ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec", "\n\tvec3 uv = cross(q.xyz, v);\n\tvec3 uuv = cross(q.xyz, uv);\n\treturn v + 2.0 * (q.w * uv + dot(q.xyz, v) * uuv);\n}\n\n// Quaternion-vector multiplication\nvec", "\n\treturn length(p-c)-r;\n}\n\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat", "\n\treturn ( d < m.x )? vec2( d, a ) : m;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec", "\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat d = b*b - c;\n\tif( d < 0.0 ) discard;\n\td = sqrt( d );\n\tp1.x = b - d;\n\tp2.x = b + d;\n\tp1.y = p2.y = 0.0;\n\tp1.z = p2.z = 1.0;\n}\n\nvoid intersectSphere( in vec3 ro, in vec3 rd, float rad, out vec4 p1, out vec4 p2 )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat d = b*b - c;\n\tif( d < 0.0 ) discard;\n\td = sqrt( d );\n\tp1.x = b - d;\n\tp2.x = b + d;\n\tp1.y = p2.y = 0.0;\n\tp1.z = p2.z = 1.0;\n}\n\nvoid intersectBox( in vec3 ro, in vec3 rd, in vec3 bmin, in vec3 bmax, out vec4 p1, out vec4 p2 )\n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (bmin - ro) * invdir;\n\tvec3 tmax = (bmax - ro) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\tp1.x = max( t1.x, max( t1.y, t1.z ) );\n\tp2.x = min( t2.x, min( t2.y, t2.z ) );\n\tif( p1.x > p2.x ) discard;\n}\n\nvoid intersectPlane( in vec3 ro, in vec3 rd, in vec3 n, float d, out vec4 p1, out vec4 p2 )\n{\n\tfloat t = (d - dot( ro, n )) /", "\n\tvec2 q = p - c;\n\treturn vec3( length(q) - r, q / length(q) );\n}\n\nvec", "\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec", "\n\tvec3 c = vec3( 0.0 );\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat yz = 0.0;\n\tfloat xy = 0.0;\n\tfloat xz = 0.0;\n\tfloat yz2 = 0.0;\n\tfloat xy2 = 0.0;\n\tfloat xz2 = 0.0;\n\tfloat yz3 = 0.0;\n\tfloat xy3 = 0.0;\n\tfloat xz3 = 0.0;\n\tfloat yz4 = 0.0;\n\tfloat xy4 = 0.0;\n\tfloat xz4 = 0.0;\n\tfloat yz5 = 0.0;\n\tfloat xy5 = 0.0;\n\tfloat xz5 = 0.0;\n\tfloat yz6 = 0.0;\n\tfloat xy6 = 0.0;\n\tfloat xz6 = 0.0;\n\tfloat yz7 = 0.0;\n\tfloat xy7 = 0.0;\n\tfloat xz7 = 0.0;\n\tfloat yz8 = 0.0;\n\tfloat xy8 = 0.0;\n\tfloat xz8 = 0.0;\n\tfloat yz9 = 0.0;\n\tfloat xy9 = 0.0;\n\tfloat xz9 = 0.0;\n\tfloat yz10 = 0.0;\n\tfloat xy10 = 0.0;\n\tfloat xz10 = 0.0;\n\tfloat yz11 = 0.0;\n\tfloat xy11 = 0.0;\n\tfloat", "\n  return (a1 * x + b1) * (a2 * x + b2);\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/53222322x\nfloat", "\n  float y = sin(x);\n  float z = pow(abs(y), n);\n  return a * z + b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                uv *= 10.;\n                uv += time * 0.001;\n                float n = 0.;\n                for(int i = 0; i < 10; i++){\n                    n += sin(length(uv) * 100. + i * 0.1) * 0.001;\n                }\n                return n;\n            }\n\n            float noise(vec2 uv){\n                uv *= 10.;\n                uv += time * 0.001;\n                float n = 0.;\n                for(int i = 0; i < 10; i++){\n                    n += sin(length(uv) * 100. + i * 0.1) * 0.001;\n                }\n                return n;\n            }\n\n            float fbm(vec2 uv){\n                float n = 0.;\n                float a = 0.5;\n                for(int i = 0; i < 10; i++){\n                    n += a * noise(uv);\n                    uv *= 2.;\n                    a *= 0.5;\n                }\n                return n;\n            }\n\n            float fbm2(vec2 uv){\n                float n = 0.;\n                float a = 0.5;\n                for(int i = 0; i < 10; i++){\n                    n += a * noise(uv);\n                    uv *= 2.;\n                    a *= 0.5;\n                }\n                return n;\n            }\n\n            float fbm3(vec2 uv){\n                float n = 0.;\n                float a = 0.5;\n                for(int i = 0; i < 10; i++){\n                    n += a * noise(uv);\n                    uv *= 2.;\n                    a *= 0.5;\n                }\n                return n;\n            }\n\n            float fbm4(vec2 uv){\n                float n = 0.;\n                float a = 0.5;\n                for(int i = 0; i < 10; i++){\n                    n += a * noise(uv);\n                    uv *= 2.;\n                    a *= 0.5;\n                }\n                return n;\n            }\n\n            float fbm5(vec2 uv){\n                float n = 0.;\n                float a = 0.5;\n                for(int i = 0; i < 10; i++){\n                    n", "\n\tvec3 c = vec3( 0.0 );\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tfor ( int j = 0; j < 4; j++ )\n\t\t{\n\t\t\tc += texture( tNoise, ( vec2( x, y ) + vec2( i, j ) ) / 16.0 ).xyz;\n\t\t}\n\t}\n\treturn c / 16.0;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec3 c = compute( int( uv.x * 1024.0 ), int( uv.y * 1024.0 ) );\n\tgl_FragColor = vec4( c, 1.0 );\n}\n", "\n\treturn length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    vec2 d = abs(p) - c;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - b.x * b.y;\n}\n\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat d2 = dot(pa,ba);\n\tfloat d2max = dot(ba,ba);\n\tfloat d2min2 = d2min*d2min;\n\tfloat d2max2 = d2max - d2min2;\n\tfloat t = clamp( (d2-h2)/d2max2, 0.0, 1.0 );\n\tvec2 q = mix( a, b, t );\n\tfloat d2q = dot(q-p,q-p);\n\treturn vec2( sqrt(d2q), d2q );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n\tfloat d = 0.0;\n\tfor( int i = 0; i < 7; i++ )\n\t{\n\t\tif( kType[i] == 0 )\n\t\t{\n\t\t\td += sdLine( p, kPath[i*2], kPath[i*2+1] );\n\t\t}\n\t\telse if( kType[i] == 1 )\n\t\t{\n\t\t\td += sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3] );\n\t\t}\n\t}\n\treturn d;\n}\n\n// SDF of a shape made of a set of line and arc segments\nfloat", "\n\tfloat d = sdBox( p, vec2( 1.0 ) );\n\tfloat d2 = sdBox( p, vec2( 0.5 ) );\n\treturn max( d, d2 );\n}\n\n// correct inside, incorrect outside\nfloat", "\n\tfloat d = sdBox( p, vec2( 0.5 ) );\n\treturn d;\n}\n\n// correct inside, incorrect outside\nfloat", "\n\tvec2 i = floor( uv * 100.0 );\n\tvec2 f = fract( uv * 100.0 );\n\tf = f * f * (3.0 - 2.0 * f);\n\tfloat n = mix( mix( i.x + i.y, i.x, f.x ), i.y, f.y );\n\treturn vec3( n );\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec", "\n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\tfloat h = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n\tvec2 proj = a + ab * h;\n\tfloat d = length( proj - p );\n\tfloat t = th - acos( clamp( dot( ab, ap ) / dot( ab, ab ), -1.0, 1.0 ) );\n\tvec2 dir = normalize( cross( ab, vec2( sin( t ), cos( t ) ) ) );\n\treturn proj + dir * d;\n}\n\n// Closest point on circle\nvec", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 hp = a + ba*h;\n\tfloat d = length( pa - ba*h );\n\tfloat dh = length( hp - p );\n\treturn min( d, dh ) - th;\n}\n\n// distance to circle\nfloat", "\n\tvec2 q = abs(p)-b;\n\treturn sign(p)*max(q,vec2(0.0)) + min(max(q,vec2(0.0)),vec2(r));\n}\n\n// closest point on rounded box\nvec", "\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat", "\n\tvec2 d = abs(p)-b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to sphere\nfloat", "\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n\treturn fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// The main function\nvoid main()\n{\n\t// Get the texture coordinates\n\tvec2 texCoord = gl_FragCoord.xy / iResolution.xy;\n\n\t// Get the random number\n\tfloat rand = random(texCoord);\n\n\t// Get the color\n\tvec3 color = vec3(rand);\n\n\t// Set the output color\n\tgl_FragColor = vec4(color, 1.0);\n}\n```", "\n\treturn fract(sin(vec2(dot(st.xy,vec2(12.9898,78.233)),dot(st.xy,vec2(12.9898,78.233))*2.0))*43758.5453);\n}\n\n// From iq\nfloat", "\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = dot(i, vec2(1.0, 0.0));\n\tfloat b = dot(i, vec2(0.0, 1.0));\n\tfloat c = dot(i + vec2(1.0, 1.0), vec2(1.0, 0.0));\n\tfloat d = dot(i + vec2(1.0, 0.0), vec2(0.0, 1.0));\n\n\t// Smooth Interpolation\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\t// Mixing\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tf += amp * noise(x);\n\t\tx *= 2.0;\n\t\tamp *= a;\n\t}\n\treturn f;\n}\n\n// Function to calculate the noise value at a given position\nfloat", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(mix(mix(mix(mix(mix(0.5, 0.2, f.x), 0.3, f.y), 0.3, f.x*f.y), 0.2, f.x*f.x), 0.2, f.y*f.y), 0.3, f.x*f.y*f.x), 0.5, f.y*f.y*f.y);\n    return 1.0-res;\n}\n\n// A checkerboard pattern\nfloat", "\n    float a = 1.0 - x;\n    float b = 1.0 - y;\n    float c = 1.0 - (a + b);\n    return 0.25 * (a * b + a * c + b * c);\n}\n\nfloat", "\n\tp3 = fract(p3 * vec3(.1031,.1136,.0719));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat", "\n\tvec3 i = floor(p + dot(p, vec3(f3)));\n\tvec3 x0 = p - i + dot(i, vec3(f3));\n\n\tvec3 g3 = vec3(0.57735026918962576450914878050196, 0.57735026918962576450914878050196, 0.57735026918962576450914878050196);\n\n\tvec3 n0 = vec3(0.6, -0.8, 0.0);\n\tvec3 n1 = vec3(-0.8, 0.6, 0.0);\n\tvec3 n2 = vec3(0.0, 0.0, 1.0);\n\n\tvec3 t0 = perlin3d(i + n0);\n\tvec3 t1 = perlin3d(i + n1);\n\tvec3 t2 = perlin3d(i + n2);\n\n\tvec3 x1 = x0 - i + g3;\n\tvec3 x2 = x0 - i + 2.0 * g3;\n\n\tvec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), 0.0), 0.0);\n\tm = m * m;\n\n\tvec3 r = m * m * vec3(dot(x0, t0), dot(x1, t1), dot(x2, t2));\n\n\treturn dot(vec3(0.211324865405187, 0.366025403784439, 0.366025403784439), r);\n}\n\nfloat", "\n    x = vec2( dot(x,vec2(127.1,311.7)),\n              dot(x,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(x)*43758.5453123);\n}\n\n// this is a simple noise function, which is used to\n// generate the displacement for the terrain.\nfloat", "\n\treturn length(max(abs(p-a)-b+a,0.0));\n}\n\nfloat", "\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// This is the final form\nfloat", "\n    float a = proj_info.x;\n    float b = proj_info.y;\n    float c = dot(center, normal);\n    float d = dot(normal, normal);\n    float e = c*c - radius*radius*d;\n    float f = b*b - a*a*d;\n    float g = a*a*c*c - b*b*radius*radius*d*d;\n    float h = b*b*radius*radius*d*d - a*a*c*c;\n    float k = b*b*radius*radius*d*d - a*a*c*c;\n    float l = b*b*radius*radius*d*d - a*a*c*c;\n    float m = b*b*radius*radius*d*d - a*a*c*c;\n    float n = b*b*radius*radius*d*d - a*a*c*c;\n    float o = b*b*radius*radius*d*d - a*a*c*c;\n    float p = b*b*radius*radius*d*d - a*a*c*c;\n    float q = b*b*radius*radius*d*d - a*a*c*c;\n    float r = b*b*radius*radius*d*d - a*a*c*c;\n    float s = b*b*radius*radius*d*d - a*a*c*c;\n    float t = b*b*radius*radius*d*d - a*a*c*c;\n    float u = b*b*radius*radius*d*d - a*a*c*c;\n    float v = b*b*radius*radius*d*d - a*a*c*c;\n    float w = b*b*radius*radius*d*d - a*a*c*c;\n    float x = b*b*radius*radius*d*d - a*a*c*c;\n    float y = b*b*radius*radius*d*d - a*a*c*c;\n    float z = b*b*radius*radius*d*d - a*a*c*c;\n    float aa = a*a;\n    float bb =", "\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat", "\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat a = an;\n\tfloat b = bn;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.", "\n\tvec3 e = dFdx( p );\n\tvec3 f = dFdy( p );\n\tvec2 g = cross( e, f );\n\treturn normalize( g );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float res = 1.0;\n    float t = t0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, h);\n        t += h;\n        if (h < 0.001 || t > t1)\n            break;\n    }\n    return res;\n}\n\n// Raymarching\nvec", "\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12 * float( i ) / 4.0;\n\t\tvec3 aopos = pos + hr * nor;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -( dd - hr ) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/4sfGz8\nfloat", "\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Helper function generating a rotation matrix around the x-axis by the angle\nmat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rayDir = normalize(vec3(uv, 1.0) - vec3(0.5));\n    vec3 camPos = vec3(0.0);\n    return normalize(rayDir);\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec", "\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat", "\n\treturn fract(sin(dot(p,vec3(12.9898,78.233,151.7182)))*43758.5453);\n}\n\n// Hash for 4d vectors\nfloat", "\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix(hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\tmix(mix(hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\tmix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise\nfloat", "\n\tvec3 Pi0 = floor(p); // Integer part for indexing\n\tvec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n\tPi0 = mod(Pi0, 289.0);\n\tPi1 = mod(Pi1, 289.0);\n\tvec3 Pf0 = fract(p); // Fractional part for interpolation\n\tvec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\tvec4 iy = vec4(Pi0.yy, Pi1.yy);\n\tvec4 iz0 = Pi0.zzzz;\n\tvec4 iz1 = Pi1.zzzz;\n\n\tvec4 ixy = permute(permute(ix) + iy);\n\tvec4 ixy0 = permute(ixy + iz0);\n\tvec4 ixy1 = permute(ixy + iz1);\n\n\tvec4 gx0 = ixy0 * (1.0 / 7.0);\n\tvec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\tgx0 = fract(gx0);\n\tvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\tvec4 sz0 = step(gz0, vec4(0.0));\n\tgx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\tgy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\tvec4 gx1 = ixy1 * (1.0 / 7.0);\n\tvec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\tgx1 = fract(gx1);\n\tvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\tvec4 sz1 = step(gz1, vec4(0.0));\n\t", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat amp = 1.0;\n\tfor(int i = 0; i < 10; i++){\n\t\tf += amp * cloudsNoise(p);\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn f;\n}\n\n// This is the main function that is called by the vertex shader\nvoid main(){\n\t// Get the position of the vertex\n\tvec3 pos = vec3(aPos, 0.0);\n\t// Get the normal of the vertex\n\tvec3 norm = vec3(aNorm, 0.0);\n\t// Get the tangent of the vertex\n\tvec3 tan = vec3(aTan, 0.0);\n\t// Get the bitangent of the vertex\n\tvec3 bit = vec3(aBit, 0.0);\n\t// Get the UV coordinates of the vertex\n\tvec2 uv = vec2(aUV, 0.0);\n\t// Get the color of the vertex\n\tvec3 col = vec3(aCol, 1.0);\n\t// Get the tangent of the vertex\n\tvec3 tan = vec3(aTan, 0.0);\n\t// Get the bitangent of the vertex\n\tvec3 bit = vec3(aBit, 0.0);\n\t// Get the UV coordinates of the vertex\n\tvec2 uv = vec2(aUV, 0.0);\n\t// Get the color of the vertex\n\tvec3 col = vec3(aCol, 1.0);\n\t// Get the tangent of the vertex\n\tvec3 tan = vec3(aTan, 0.0);\n\t// Get the bitangent of the vertex\n\tvec3 bit = vec3(aBit, 0.0);\n\t// Get the UV coordinates of the vertex\n\tvec2 uv = vec2(aUV, 0.0);\n\t// Get the color of the vertex\n\tvec3 col = vec3(aCol, 1.0);\n\t// Get the tangent of the vertex\n\tvec3 tan = vec3(aTan, 0.0);\n\t// Get the bitang", "\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tvec3 p1 = p;\n\tp0.y += 0.001;\n\tp1.y -= 0.001;\n\tvec2 d0 = cloudsDensity2D(p0);\n\tvec2 d1 = cloudsDensity2D(p1);\n\tfloat d = (d0.x + d1.x) * 0.5;\n\tfloat c = (d0.y + d1.y) * 0.5;\n\treturn vec2(d,c);\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec", "\n\tfloat cloudCoverage = 0.0;\n\tfloat cloudCoverageSmooth = 0.0;\n\tfloat cloudCoverageSmooth2 = 0.0;\n\tfloat cloudCoverageSmooth3 = 0.0;\n\tfloat cloudCoverageSmooth4 = 0.0;\n\tfloat cloudCoverageSmooth5 = 0.0;\n\tfloat cloudCoverageSmooth6 = 0.0;\n\tfloat cloudCoverageSmooth7 = 0.0;\n\tfloat cloudCoverageSmooth8 = 0.0;\n\tfloat cloudCoverageSmooth9 = 0.0;\n\tfloat cloudCoverageSmooth10 = 0.0;\n\tfloat cloudCoverageSmooth11 = 0.0;\n\tfloat cloudCoverageSmooth12 = 0.0;\n\tfloat cloudCoverageSmooth13 = 0.0;\n\tfloat cloudCoverageSmooth14 = 0.0;\n\tfloat cloudCoverageSmooth15 = 0.0;\n\tfloat cloudCoverageSmooth16 = 0.0;\n\tfloat cloudCoverageSmooth17 = 0.0;\n\tfloat cloudCoverageSmooth18 = 0.0;\n\tfloat cloudCoverageSmooth19 = 0.0;\n\tfloat cloudCoverageSmooth20 = 0.0;\n\tfloat cloudCoverageSmooth21 = 0.0;\n\tfloat cloudCoverageSmooth22 = 0.0;\n\tfloat cloudCoverageSmooth23 = 0.0;\n\tfloat cloudCoverageSmooth24 = 0.0;\n\tfloat cloudCoverageSmooth25 = 0.0;\n\tfloat cloudCoverageSmooth26 = 0.0;\n\tfloat cloudCoverageSmooth27 = 0.0;\n\tfloat cloudCoverageSmooth28 = 0.0;\n\tfloat cloudCoverageSmooth29 = 0.0;\n\tfloat cloudCoverageSmooth30 = 0.0;\n\tfloat cloudCoverageSmooth31 = 0.0;\n\tfloat cloudCoverageSmooth32 = 0.0;\n\tfloat cloudCoverageSmooth33 = 0.0;\n\tfloat cloudCoverageSmooth34 = 0.0;\n\tfloat cloudCoverageSmooth35 = 0.0;\n\tfloat cloudCoverageSmooth36 = 0.0;\n\tfloat cloudCoverageSmooth3", "\n\tfloat t = 0.0;\n\tfloat tMax = 100.0;\n\tfloat tStep = 0.001;\n\tfloat tStep2 = 0.0001;\n\tfloat tStep3 = 0.00001;\n\tfloat tStep4 = 0.000001;\n\tfloat tStep5 = 0.0000001;\n\tfloat tStep6 = 0.00000001;\n\tfloat tStep7 = 0.000000001;\n\tfloat tStep8 = 0.0000000001;\n\tfloat tStep9 = 0.00000000001;\n\tfloat tStep10 = 0.000000000001;\n\tfloat tStep11 = 0.0000000000001;\n\tfloat tStep12 = 0.00000000000001;\n\tfloat tStep13 = 0.000000000000001;\n\tfloat tStep14 = 0.0000000000000001;\n\tfloat tStep15 = 0.00000000000000001;\n\tfloat tStep16 = 0.000000000000000001;\n\tfloat tStep17 = 0.0000000000000000001;\n\tfloat tStep18 = 0.00000000000000000001;\n\tfloat tStep19 = 0.000000000000000000001;\n\tfloat tStep20 = 0.0000000000000000000001;\n\tfloat tStep21 = ", "\n\tconst float A = 2.51;\n\tconst float B = 0.03;\n\tconst float C = 2.43;\n\tconst float D = 0.59;\n\tconst float E = 0.14;\n\treturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec3 color = texture2D(tDiffuse, uv).rgb;\n\tcolor = aces_tonemap(color);\n\tgl_FragColor = vec4(color, 1.0);\n}\n"]}