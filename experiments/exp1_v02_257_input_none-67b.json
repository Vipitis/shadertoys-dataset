{"input_none": ["\n\tfloat a2 = a * a;\n\tfloat a4 = a2 * a2;\n\tfloat a6 = a4 * a2;\n\tfloat a8 = a6 * a2;\n\tfloat a10 = a8 * a2;\n\tfloat a12 = a10 * a2;\n\tfloat a14 = a12 * a2;\n\tfloat a16 = a14 * a2;\n\tfloat a18 = a16 * a2;\n\tfloat a20 = a18 * a2;\n\tfloat a22 = a20 * a2;\n\tfloat a24 = a22 * a2;\n\tfloat a26 = a24 * a2;\n\tfloat a28 = a26 * a2;\n\tfloat a30 = a28 * a2;\n\tfloat a32 = a30 * a2;\n\tfloat a34 = a32 * a2;\n\tfloat a36 = a34 * a2;\n\tfloat a38 = a36 * a2;\n\tfloat a40 = a38 * a2;\n\tfloat a42 = a40 * a2;\n\tfloat a44 = a42 * a2;\n\tfloat a46 = a44 * a2;\n\tfloat a48 = a46 * a2;\n\tfloat a50 = a48 * a2;\n\tfloat a52 = a50 * a2;\n\tfloat a54 = a52 * a2;\n\tfloat a56 = a54 * a2;\n\tfloat a58 = a56 * a2;\n\tfloat a60 = a58 * a2;\n\tfloat a62 = a60 * a2;\n\tfloat a64 = a62 * a2;\n\tfloat a66 = a64 * a2;\n\tfloat a68 = a66 * a2;\n\tfloat a70 = a68 * a2;\n\tfloat a72 = a70 * a2;\n\tfloat a74 = a72 * a2;\n\tfloat a7", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    return d;\n}\n\nvec", "\n    float d = length(p) - 1.0;\n    return d;\n}\n\nfloat", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    P = q;\n    return vec2(d, 0.0);\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 color = vec4(0.0);\n    if (x < 0.0)\n    {\n        color.r = 0.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    else if (x < 0.2)\n    {\n        color.r = 0.0;\n        color.g = 0.0;\n        color.b = 1.0;\n    }\n    else if (x < 0.4)\n    {\n        color.r = 0.0;\n        color.g = 1.0;\n        color.b = 1.0;\n    }\n    else if (x < 0.6)\n    {\n        color.r = 0.0;\n        color.g = 1.0;\n        color.b = 0.0;\n    }\n    else if (x < 0.8)\n    {\n        color.r = 1.0;\n        color.g = 1.0;\n        color.b = 0.0;\n    }\n    else if (x < 1.0)\n    {\n        color.r = 1.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    else\n    {\n        color.r = 1.0;\n        color.g = 0.0;\n        color.b = 1.0;\n    }\n    return color;\n}\n\nvoid main()\n{\n    vec4 color = gradient(v_color);\n    gl_FragColor = color;\n}\n", "\n    float f = clamp(1.0 - d, 0.0, 1.0);\n    return vec4(f, f, f, 1.0);\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy / resolution.xy, 0.0);\n    vec3 dir = normalize(p - vec3(0.5, 0.5, 1.0));\n    float d = raymarch(dir);\n    gl_FragColor = shade(d);\n}\n", "\n\tvec3 color = vec3(0.0);\n\tvec3 sunColor = vec3(1.0);\n\tvec3 sunColor2 = vec3(1.0);\n\tvec3 sunColor3 = vec3(1.0);\n\tvec3 sunColor4 = vec3(1.0);\n\tvec3 sunColor5 = vec3(1.0);\n\tvec3 sunColor6 = vec3(1.0);\n\tvec3 sunColor7 = vec3(1.0);\n\tvec3 sunColor8 = vec3(1.0);\n\tvec3 sunColor9 = vec3(1.0);\n\tvec3 sunColor10 = vec3(1.0);\n\tvec3 sunColor11 = vec3(1.0);\n\tvec3 sunColor12 = vec3(1.0);\n\tvec3 sunColor13 = vec3(1.0);\n\tvec3 sunColor14 = vec3(1.0);\n\tvec3 sunColor15 = vec3(1.0);\n\tvec3 sunColor16 = vec3(1.0);\n\tvec3 sunColor17 = vec3(1.0);\n\tvec3 sunColor18 = vec3(1.0);\n\tvec3 sunColor19 = vec3(1.0);\n\tvec3 sunColor20 = vec3(1.0);\n\tvec3 sunColor21 = vec3(1.0);\n\tvec3 sunColor22 = vec3(1.0);\n\tvec3 sunColor23 = vec3(1.0);\n\tvec3 sunColor24 = vec3(1.0);\n\tvec3 sunColor25 = vec3(1.0);\n\tvec3 sunColor26 = vec3(1.0);\n\tvec3 sunColor27 = vec3(1.0);\n\tvec3 sunColor28 = vec3(1.0);\n\tvec3 sunColor29 = vec3(1.0);\n\tvec3 sunColor30 = vec3(1.", "\n    float x = coords.x;\n    float y = coords.y;\n    float r = sqrt ( x * x + y * y );\n    float theta = atan ( y, x );\n    float f = sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r", "\n    float x = coords.x;\n    float y = coords.y;\n    float r = sqrt ( x * x + y * y );\n    float theta = atan ( y, x );\n    float f = sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r", "\n    float x = coords.x;\n    float y = coords.y;\n    float r = sqrt ( x * x + y * y );\n    float theta = atan ( y, x );\n    float f = sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r ) * sin ( 2.0 * r", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    float n = 0.0;\n    float f = 1.0;\n    float s = 1.0;\n    for (int i = 0; i < 8; i++) {\n        n += s * noise(p);\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return n;\n}\n\nfloat", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n    vec2 p1 = floor(p);\n    vec2 p2 = p1 + vec2(1.0, 0.0);\n    vec2 p3 = p1 + vec2(0.0, 1.0);\n    vec2 p4 = p1 + vec2(1.0, 1.0);\n\n    vec2 d1 = p - p1;\n    vec2 d2 = p - p2;\n    vec2 d3 = p - p3;\n    vec2 d4 = p - p4;\n\n    float d1_len = length(d1);\n    float d2_len = length(d2);\n    float d3_len = length(d3);\n    float d4_len = length(d4);\n\n    float min_len = min(d1_len, d2_len);\n    min_len = min(min_len, d3_len);\n    min_len = min(min_len, d4_len);\n\n    return min_len;\n}\n\nfloat", "\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.0;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 b = vec2(x, y);\n            vec2 r = vec2(b) - f + rand(g + b);\n            float d = dot(r, r);\n            res = min(res, d);\n        }\n    }\n    return sqrt(res);\n}\n\nfloat", "\n\n    vec3 color = vec3(0.0);\n    vec3 normal = getNormal( rayHitInfo );\n    vec3 position = getPosition( rayHitInfo );\n    vec3 lightPosition = vec3( 0.0, 0.0, 10.0 );\n    vec3 lightDirection = normalize( lightPosition - position );\n    float diffuse = max( dot( normal, lightDirection ), 0.0 );\n    vec3 diffuseColor = vec3( 1.0, 1.0, 1.0 );\n    color += diffuse * diffuseColor;\n    return color;\n}\n\nvoid main(){\n    vec2 rayHitInfo = getRayHitInfo( gl_FragCoord.xy );\n    vec3 color = colorTheWorld( rayHitInfo, eyePosition, rayDirection );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    float r = length(q.xz);\n    float a = atan(q.x, q.z);\n    float phi = acos(q.y / r);\n    float theta = atan(r, q.y);\n    float s = sin(phi);\n    float c = cos(phi);\n    float z = (r * s + c * tan(theta)) / r;\n    float w = (r * c - s * tan(theta)) / r;\n    float v = (1.0 - z * z) / (w * w);\n    float b = (2.0 * z * w) / (w * w + z * z);\n    float h = b * b + 1.0 - v;\n    float g = sqrt(max(h, 0.0));\n    float l = g - b;\n    float m = max(l, 0.0);\n    float n = (1.0 - g) / (g + b);\n    float j = sqrt(max(n, 0.0));\n    float k = j - n;\n    float f = max(k, 0.0);\n    float x = (m * sin(a) - f * cos(a)) / r;\n    float y = (m * cos(a) + f * sin(a)) / r;\n    float u = atan(y, x);\n    float t = (u - a) / (2.0 * PI);\n    float e = mod(t, 1.0);\n    float o = e < 0.0? e + 1.0 : e;\n    float i = o < 0.5? o * o : 1.0 - pow(1.0 - o, 2.0);\n    float h2 = r - 1.0;\n    float g2 = r + 1.0;\n    float j2 = r * r;\n    float k2 = j2 * j2;\n    float l2 = k2 * k2;\n    float m2 = l2 * l2;\n    float n2", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = intersectBox(ro, rd, vec3(-1.0), vec3(1.0), tmin, tmax);\n\n    if (t < tmax)\n    {\n        return vec2(t, 1.0);\n    }\n\n    return vec2(-1.0);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    vec2 t = castRay(ro, rd);\n\n    if (t.x > 0.0)\n    {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    float r = length(q.xz);\n    float a = atan(q.x, q.z);\n    float f = cos(a * 10.0) * r;\n    float g = sin(a * 10.0) * r;\n    float h = sin(a * 10.0) * r;\n    float j = cos(a * 10.0) * r;\n    float k = sin(a * 10.0) * r;\n    float l = cos(a * 10.0) * r;\n    float m = sin(a * 10.0) * r;\n    float n = cos(a * 10.0) * r;\n    float o = sin(a * 10.0) * r;\n    float p = cos(a * 10.0) * r;\n    float q = sin(a * 10.0) * r;\n    float r = cos(a * 10.0) * r;\n    float s = sin(a * 10.0) * r;\n    float t = cos(a * 10.0) * r;\n    float u = sin(a * 10.0) * r;\n    float v = cos(a * 10.0) * r;\n    float w = sin(a * 10.0) * r;\n    float x = cos(a * 10.0) * r;\n    float y = sin(a * 10.0) * r;\n    float z = cos(a * 10.0) * r;\n    float A = sin(a * 10.0) * r;\n    float B = cos(a * 10.0) * r;\n    float C = sin(a * 10.0) * r;\n    float D = cos(a * 10.0) * r;\n    float E = sin(a * 10.0) * r;\n    float F = cos(a * ", "\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tstep = 0.01;\n    float m = -1.0;\n    float d = 0.0;\n    float precis = 0.001;\n    for( int i=0; i<100; i++ )\n    {\n        if( t>tmax ) break;\n        t += tstep;\n        vec3 p = ro + rd*t;\n        d = map(p);\n        if( d<precis )\n        {\n            m = t;\n            break;\n        }\n    }\n    if( m>-0.5 )\n    {\n        itterRatio = t/tmax;\n        return vec4(p,1.0);\n    }\n    else\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n}\n\nvec", "\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 8; i++) {\n        n += snoise(p + vec3(i, i, i) * 0.1) * oN;\n    }\n    return n;\n}\n\nvec", "\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float d00 = dot(random3(ip), fp);\n    float d01 = dot(random3(ip + vec3(0.0, 1.0, 0.0)), fp - vec3(0.0, 1.0, 0.0));\n    float d02 = dot(random3(ip + vec3(0.0, 0.0, 1.0)), fp - vec3(0.0, 0.0, 1.0));\n    float d10 = dot(random3(ip + vec3(1.0, 0.0, 0.0)), fp - vec3(1.0, 0.0, 0.0));\n    float d11 = dot(random3(ip + vec3(1.0, 1.0, 0.0)), fp - vec3(1.0, 1.0, 0.0));\n    float d12 = dot(random3(ip + vec3(1.0, 0.0, 1.0)), fp - vec3(1.0, 0.0, 1.0));\n    float d20 = dot(random3(ip + vec3(0.0, 1.0, 1.0)), fp - vec3(0.0, 1.0, 1.0));\n    float d21 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n    float d22 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n\n    float d0 = mix(d00, d01, fp.y);\n    float d1 = mix(d10, d11, fp.y);\n    float d", "\n    vec3 color = vec3(0.0);\n    float weight = 1.0;\n    float weightSum = 0.0;\n    float weightSum2 = 0.0;\n    float weightSum3 = 0.0;\n    float weightSum4 = 0.0;\n    float weightSum5 = 0.0;\n    float weightSum6 = 0.0;\n    float weightSum7 = 0.0;\n    float weightSum8 = 0.0;\n    float weightSum9 = 0.0;\n    float weightSum10 = 0.0;\n    float weightSum11 = 0.0;\n    float weightSum12 = 0.0;\n    float weightSum13 = 0.0;\n    float weightSum14 = 0.0;\n    float weightSum15 = 0.0;\n    float weightSum16 = 0.0;\n    float weightSum17 = 0.0;\n    float weightSum18 = 0.0;\n    float weightSum19 = 0.0;\n    float weightSum20 = 0.0;\n    float weightSum21 = 0.0;\n    float weightSum22 = 0.0;\n    float weightSum23 = 0.0;\n    float weightSum24 = 0.0;\n    float weightSum25 = 0.0;\n    float weightSum26 = 0.0;\n    float weightSum27 = 0.0;\n    float weightSum28 = 0.0;\n    float weightSum29 = 0.0;\n    float weightSum30 = 0.0;\n    float weightSum31 = 0.0;\n    float weightSum32 = 0.0;\n    float weightSum33 = 0.0;\n    float weightSum34 = 0.0;\n    float weightSum35 = 0.0;\n    float weightSum36 = 0.0;\n    float weightSum37 = 0.0;\n    float weightSum38 = 0.0;\n    float weightSum39 = 0.0;\n    float weightSum40 = 0.0;\n    float weightSum41 = 0.0;\n    float weightSum4", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    float t = dot(AC, AB) / dot(AB, AB);\n    if (t < 0.0)\n        return length(AC);\n    if (t > 1.0)\n        return length(coords - B);\n    vec2 P = A + t * AB;\n    return length(P - coords);\n}\n\nfloat", "\n    float dot = dot(start, end);\n    float theta = acos(dot) * percent;\n    vec2 v2 = normalize(end - start * dot);\n    return (start * cos(theta)) + (v2 * sin(theta));\n}\n\nvoid main()\n{\n    vec2 start = vec2(0.0, 1.0);\n    vec2 end = vec2(1.0, 0.0);\n    vec2 result = slerp(start, end, 0.5);\n    gl_FragColor = vec4(result, 0.0, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat", "\n\tvec3 color = vec3(0.0);\n\tvec3 rayDir2 = rayDir;\n\tfloat dist = 0.0;\n\tfloat dist2 = 0.0;\n\tfloat dist3 = 0.0;\n\tfloat dist4 = 0.0;\n\tfloat dist5 = 0.0;\n\tfloat dist6 = 0.0;\n\tfloat dist7 = 0.0;\n\tfloat dist8 = 0.0;\n\tfloat dist9 = 0.0;\n\tfloat dist10 = 0.0;\n\tfloat dist11 = 0.0;\n\tfloat dist12 = 0.0;\n\tfloat dist13 = 0.0;\n\tfloat dist14 = 0.0;\n\tfloat dist15 = 0.0;\n\tfloat dist16 = 0.0;\n\tfloat dist17 = 0.0;\n\tfloat dist18 = 0.0;\n\tfloat dist19 = 0.0;\n\tfloat dist20 = 0.0;\n\tfloat dist21 = 0.0;\n\tfloat dist22 = 0.0;\n\tfloat dist23 = 0.0;\n\tfloat dist24 = 0.0;\n\tfloat dist25 = 0.0;\n\tfloat dist26 = 0.0;\n\tfloat dist27 = 0.0;\n\tfloat dist28 = 0.0;\n\tfloat dist29 = 0.0;\n\tfloat dist30 = 0.0;\n\tfloat dist31 = 0.0;\n\tfloat dist32 = 0.0;\n\tfloat dist33 = 0.0;\n\tfloat dist34 = 0.0;\n\tfloat dist35 = 0.0;\n\tfloat dist36 = 0.0;\n\tfloat dist37 = 0.0;\n\tfloat dist38 = 0.0;\n\tfloat dist39 = 0.0;\n\tfloat dist40 = 0.0;\n\tfloat dist41 = 0.0;\n\tfloat dist42 = 0.0;\n\tfloat dist43 = 0.0;\n\tfloat dist44 = 0.0;\n\tfloat dist45 = 0.0;\n\t", "\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q) - 1.0;\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    float t = (-b - sqrt(d)) / (2.0 * a);\n    if (t < 0.0) return false;\n    near = t;\n    t = (-b + sqrt(d)) / (2.0 * a);\n    if (t < 0.0) return false;\n    far = t;\n    return true;\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    float t = (-b - sqrt(d)) / (2.0 * a);\n    if (t < 0.0) return false;\n    near = t;\n    t = (-b + sqrt(d)) / (2.0 * a);\n    if (t < 0.0) return false;\n    far = t;\n    return true;\n}\n\nbool plane(vec3 org, vec3 dir, out float near, out float far)\n{\n    float d = dot(org, vec3(0.0, 1.0, 0.0));\n    if (d == 0.0) return false;\n    near = -d / dot(dir, vec3(0.0, 1.0, 0.0));\n    far = -d / dot(dir, vec3(0.0, 1.0, 0.0));\n    return true;\n}\n\nbool box(vec3 org, vec3 dir, out float near, out float far)\n{\n    vec3 t1 = (vec3(-1.0", "\n    float k = s.w;\n    vec3 q = p - s.xyz;\n    float b = dot(q, r);\n    float c = dot(q, q) - s.w * s.w;\n    float d = b * b - c;\n    float t = -b - sign(r.z) * sqrt(abs(d));\n    float h = t * t / (b + sign(r.z) * sqrt(abs(d)));\n    return sqrt(h);\n}\n\nfloat", "\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float d00 = dot(random3(ip), fp);\n    float d01 = dot(random3(ip + vec3(0.0, 1.0, 0.0)), fp - vec3(0.0, 1.0, 0.0));\n    float d02 = dot(random3(ip + vec3(0.0, 0.0, 1.0)), fp - vec3(0.0, 0.0, 1.0));\n    float d10 = dot(random3(ip + vec3(1.0, 0.0, 0.0)), fp - vec3(1.0, 0.0, 0.0));\n    float d11 = dot(random3(ip + vec3(1.0, 1.0, 0.0)), fp - vec3(1.0, 1.0, 0.0));\n    float d12 = dot(random3(ip + vec3(1.0, 0.0, 1.0)), fp - vec3(1.0, 0.0, 1.0));\n    float d20 = dot(random3(ip + vec3(0.0, 1.0, 1.0)), fp - vec3(0.0, 1.0, 1.0));\n    float d21 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n    float d22 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n\n    float d0 = mix(d00, d01, fp.y);\n    float d1 = mix(d10, d11, fp.y);\n    float d", "\n    float d = length(p);\n    float a = atan(p.y,p.x);\n    float r = abs(cos(a*10.0))*0.1;\n    return d-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;\n    float d = drawShape(uv);\n    vec3 col = vec3(1.0-smoothstep(0.0,0.01,d));\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 bump = normalize(sn);\n    bump = normalize(bump + sp);\n    bump *= bumpFactor;\n    return bump;\n}\n\nvoid main() {\n    vec3 sp = normalize(v_sp);\n    vec3 sn = normalize(v_sn);\n    vec3 bump = bump(sp, sn, 0.05);\n    vec3 bump2 = bump(sp, sn, 0.02);\n    vec3 bump3 = bump(sp, sn, 0.01);\n    vec3 bump4 = bump(sp, sn, 0.005);\n    vec3 bump5 = bump(sp, sn, 0.002);\n    vec3 bump6 = bump(sp, sn, 0.001);\n    vec3 bump7 = bump(sp, sn, 0.0005);\n    vec3 bump8 = bump(sp, sn, 0.0002);\n    vec3 bump9 = bump(sp, sn, 0.0001);\n    vec3 bump10 = bump(sp, sn, 0.00005);\n    vec3 bump11 = bump(sp, sn, 0.00002);\n    vec3 bump12 = bump(sp, sn, 0.00001);\n    vec3 bump13 = bump(sp, sn, 0.000005);\n    vec3 bump14 = bump(sp, sn, 0.000002);\n    vec3 bump15 = bump(sp, sn, 0.000001);\n    vec3 bump16 = bump(sp, sn, 0.0000005);\n    vec3 bump17 = bump(sp, sn, 0.0000002);\n    vec3 bump18 = bump", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n    vec3 l = normalize(lightPos - p);\n    float diffuse = max(dot(n, l), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n\n    vec3 v = normalize(cameraPos - p);\n    vec3 r = reflect(-l, n);\n    float specular = pow(max(dot(r, v), 0.0), 16.0);\n    vec3 specularColor = specular * lightColor;\n\n    return diffuseColor + specularColor;\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy / resolution, 0.0);\n    vec3 n = normalize(p - vec3(0.0, 0.0, 0.0));\n    vec3 color = shade(p, n);\n    fragColor = vec4(color, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    float t = (rd.y + 1.0) * 0.5;\n    return mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), t);\n}\n\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(ro + rd * t);\n        if (d < 0.001) {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    return length(p)-rad;\n}\n\nfloat", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = (r - param.x) * (r - param.x) / (param.y * param.y) + a * a;\n    return sqrt(d) - param.z;\n}\n\nfloat", "\n    float d = DE(p, param);\n    float l = length(p);\n    float ld = l - 1.0;\n    float ld2 = ld * ld;\n    float ld3 = ld2 * ld;\n    float ld4 = ld2 * ld2;\n    float ld5 = ld4 * ld;\n    float ld6 = ld5 * ld;\n    float ld7 = ld6 * ld;\n    float ld8 = ld7 * ld;\n    float ld9 = ld8 * ld;\n    float ld10 = ld9 * ld;\n    float ld11 = ld10 * ld;\n    float ld12 = ld11 * ld;\n    float ld13 = ld12 * ld;\n    float ld14 = ld13 * ld;\n    float ld15 = ld14 * ld;\n    float ld16 = ld15 * ld;\n    float ld17 = ld16 * ld;\n    float ld18 = ld17 * ld;\n    float ld19 = ld18 * ld;\n    float ld20 = ld19 * ld;\n    float ld21 = ld20 * ld;\n    float ld22 = ld21 * ld;\n    float ld23 = ld22 * ld;\n    float ld24 = ld23 * ld;\n    float ld25 = ld24 * ld;\n    float ld26 = ld25 * ld;\n    float ld27 = ld26 * ld;\n    float ld28 = ld27 * ld;\n    float ld29 = ld28 * ld;\n    float ld30 = ld29 * ld;\n    float ld31 = ld30 * ld;\n    float ld32 = ld31 * ld;", "\n    vec3 col = vec3(0.0);\n    float t = intersect(ro, rd);\n    if (t > 0.0)\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = normalize(pos);\n        vec3 ref = reflect(rd, nor);\n        float sun = max(dot(nor, sunDir), 0.0);\n        float sky = max(dot(nor, skyDir), 0.0);\n        float sky2 = max(dot(nor, skyDir2), 0.0);\n        float sky3 = max(dot(nor, skyDir3), 0.0);\n        float sky4 = max(dot(nor, skyDir4), 0.0);\n        float sky5 = max(dot(nor, skyDir5), 0.0);\n        float sky6 = max(dot(nor, skyDir6), 0.0);\n        float sky7 = max(dot(nor, skyDir7), 0.0);\n        float sky8 = max(dot(nor, skyDir8), 0.0);\n        float sky9 = max(dot(nor, skyDir9), 0.0);\n        float sky10 = max(dot(nor, skyDir10), 0.0);\n        float sky11 = max(dot(nor, skyDir11), 0.0);\n        float sky12 = max(dot(nor, skyDir12), 0.0);\n        float sky13 = max(dot(nor, skyDir13), 0.0);\n        float sky14 = max(dot(nor, skyDir14), 0.0);\n        float sky15 = max(dot(nor, skyDir15), 0.0);\n        float sky16 = max(dot(nor, skyDir16), 0.0);\n        float sky17 = max(dot(nor, skyDir17), 0.0);\n        float sky18 = max(dot(nor, skyDir18), 0.0);\n        float sky19 = max(dot(nor, skyDir19), 0", "\n    vec3 col = vec3(0.0);\n    float t = ti;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if (d < 0.001) {\n            col = vec3(1.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd, 0.0);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    p = abs(p);\n    p -= 2.0 * min(diamond.x, diamond.y);\n    vec2 q = abs(p + diamond.zw);\n    return max(q.x, q.y) - diamond.z;\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float r = atan(uv.y, uv.x);\n    float g = d;\n    float b = r;\n    col = vec3(r, g, b);\n    return col;\n}\n\nvoid main(){\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = pattern(uv);\n    fragColor = vec4(col, 1.0);\n}", "\n  float d = length( pos ) - 1.0;\n  return d;\n}\n\nfloat", "\n    vec3 l = normalize( vec3( 1.0, 1.0, 1.0 ) );\n    vec3 h = normalize( l + eye );\n    float ndotl = max( dot( n, l ), 0.0 );\n    float ndoth = max( dot( n, h ), 0.0 );\n    float spec = pow( ndoth, 10.0 );\n    return vec3( 0.5, 0.5, 0.5 ) + vec3( 0.5, 0.5, 0.5 ) * ndotl + vec3( 1.0, 1.0, 1.0 ) * spec;\n}\n\nvoid main() {\n    vec3 v = normalize( vec3( gl_FragCoord.xy - u_resolution.xy / 2.0, u_resolution.y ) );\n    vec3 n = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 eye = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    gl_FragColor = vec4( shading( v, n, eye ), 1.0 );\n}\n", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n    return length(p) - offset;\n}\n\nfloat", "\n    float xm = x.x;\n    float xn = x.y;\n    float xp = x.z;\n    float xm2 = xm * xm;\n    float xn2 = xn * xn;\n    float xp2 = xp * xp;\n    float xmn = xm * xn;\n    float xmp = xm * xp;\n    float xnp = xn * xp;\n    float xm2n2 = xm2 + xn2;\n    float xm2p2 = xm2 + xp2;\n    float xmn2 = xmn + xnp;\n    float xmp2 = xmp + xnp;\n    float xm2n2p2 = xm2n2 + xp2;\n    float xm2n2p22 = xm2n2p2 * xm2n2p2;\n    float xm2n2p222 = xm2n2p22 * xm2n2p2;\n    float xm2n2p2222 = xm2n2p222 * xm2n2p2;\n    float xm2n2p22222 = xm2n2p2222 * xm2n2p2;\n    float xm2n2p222222 = xm2n2p22222 * xm2n2p2;\n    float xm2n2p2222222 = xm2n2p222222 * xm2n2p2;\n    float xm2n2p22222222 = xm2n2p2222222 * xm2n2p2;\n    float xm2n2p222222222 = xm2n2p22222222 * xm2n2p2;\n    float xm2n2p2222222222 = xm2n2p222222222 * xm2n2p2;\n   ", "\n    vec2 d = vec2(length(p.xz) - r, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    return d;\n}\n\nvec", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat", "\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n    n = mod(n, 8.0);\n    return fract(n / 8.0);\n}\n\nfloat", "\n    vec2 uv = coord;\n    float t = time * 0.001;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n    float t4 = t * 0.125;\n    float t5 = t * 0.0625;\n    float t6 = t * 0.03125;\n    float t7 = t * 0.015625;\n    float t8 = t * 0.0078125;\n    float t9 = t * 0.00390625;\n    float t10 = t * 0.001953125;\n    float t11 = t * 0.0009765625;\n    float t12 = t * 0.00048828125;\n    float t13 = t * 0.000244140625;\n    float t14 = t * 0.0001220703125;\n    float t15 = t * 0.00006103515625;\n    float t16 = t * 0.000030517578125;\n    float t17 = t * 0.0000152587890625;\n    float t18 = t * 0.00000762939453125;\n    float t19 = t * 0.000003814697265625;\n    float t20 = t * 0.0000019073486328125;\n    float t21 = t * 0.00000095367431640625;\n    float t22 = t * 0.00000047683715", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat", "\n    float d = length(p);\n    float b = exp(-d*d*0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec4 pt = vec4(scr_pt, 0.0, 1.0);\n    pt = viewp_inv * pt;\n    pt.xyz /= pt.w;\n    pt = proj_inv * pt;\n    pt.xyz /= pt.w;\n    pt = view_inv * pt;\n    return pt;\n}\n\nvec", "\n    vec2 paToP = pA - uv;\n    vec2 paToPx = paToP;\n    paToPx.x = paToP.x > 0.0? paToP.x : -paToP.x;\n    vec2 paToPy = paToP;\n    paToPy.y = paToP.y > 0.0? paToP.y : -paToP.y;\n    vec2 paToPd = paToPx - paToPy;\n    paToPd.x = paToPd.x > 0.0? paToPd.x : -paToPd.x;\n    paToPd.y = paToPd.y > 0.0? paToPd.y : -paToPd.y;\n    vec2 paToPd2 = paToPd;\n    paToPd2.x = paToPd.x > 0.0? paToPd.x : -paToPd.x;\n    paToPd2.y = paToPd.y > 0.0? paToPd.y : -paToPd.y;\n    vec2 paToPd3 = paToPd2;\n    paToPd3.x = paToPd2.x > 0.0? paToPd2.x : -paToPd2.x;\n    paToPd3.y = paToPd2.y > 0.0? paToPd2.y : -paToPd2.y;\n    vec2 paToPd4 = paToPd3;\n    paToPd4.x = paToPd3.x > 0.0? paToPd3.x : -paToPd3.x;\n    paToPd4.y = paToPd3.y > 0.0? paToPd3.y : -paToPd3.y;\n    vec2 paToPd5 = paToPd4;\n    paToPd5.x = paToPd4.x > 0.0? pa", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diffuse = max(dot(n, lightDir), 0.0);\n    color += diffuse * vec3(1.0);\n    return color;\n}\n\nvoid main()\n{\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float d = Raymarch(p, n);\n    if (d < MAX_DIST)\n    {\n        vec3 color = Shade(p, n);\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}\n", "\n    vec3 m = vec3(1.0) - sign(rd);\n    vec3 n = m*ro + sign(rd)*cen - rad;\n    float s = sign(rd.x)*rad.x - n.x;\n    float t = sign(rd.y)*rad.y - n.y;\n    float p = sign(rd.z)*rad.z - n.z;\n    float code = step(max(max(s,t),p),0.0);\n    float dist = max(max(s,t),p);\n    float y = (code==1.0)? length(max(vec2(dist,0.0),n.xy)) : length(max(vec2(0.0),n.xy));\n    float z = (code==2.0)? length(max(vec2(dist,0.0),n.zx)) : length(max(vec2(0.0),n.zx));\n    float x = (code==3.0)? length(max(vec2(dist,0.0),n.yz)) : length(max(vec2(0.0),n.yz));\n    return vec2(min(x,min(y,z)), code);\n}\n\nvec", "\n    return a * sin(x * b);\n}\n\nfloat", "\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*rdoa*rdoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        h = sqrt(h);\n        float t1 = (-b - h)/a;\n        float t2 = (-b + h)/a;\n        if( t1>0.0 )\n        {\n            if( t2>0.0 )\n                return vec4( (t1<t2)? t1 : t2, 1.0, 0.0, 0.0 );\n            else\n                return vec4( t1, 1.0, 0.0, 0.0 );\n        }\n        else\n        {\n            if( t2>0.0 )\n                return vec4( t2, 1.0, 0.0, 0.0 );\n        }\n    }\n    return vec4(-1.0);\n}\n\nvec", "\n    float d = length(P) - r;\n    if (d < 0.) {\n        O = vec4(C, 1.);\n    }\n}\n\nvoid main() {\n    vec2 U = gl_FragCoord.xy / iResolution.xy;\n    vec2 P = (2. * U - 1.) * iResolution.xy / iResolution.y;\n\n    vec4 O = vec4(0.);\n    sphere(O, U, P, 0.5, vec3(1.));\n\n    gl_FragColor = O;\n}\n", "\n    float d = length(p) - 1.0;\n    return d;\n}\n\nvec", "\n    float scale = 1.0;\n    for(float i = 0.0; i < layerID; i++){\n        scale *= 0.9;\n    }\n    return vec3(p, scale);\n}\n\nvoid main(){\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n    float layerID = 0.0;\n    for(float i = 0.0; i < 10.0; i++){\n        vec3 scaleDec = scaleDec(p, i);\n        p = scaleDec.xy;\n        float scale = scaleDec.z;\n        float r = length(p);\n        float a = atan(p.y, p.x);\n        float f = abs(cos(a * 10.0 - iTime * 10.0) * 0.5);\n        float n = f * (1.0 - smoothstep(0.0, fwidth(f) * 2.0, r - 0.25));\n        color += vec3(n * scale);\n        layerID += 1.0;\n    }\n    fragColor = vec4(color, 1.0);\n}", "\n    vec2 tile = floor(p);\n    vec2 pos = p - tile;\n    return vec3(pos, tile);\n}\n\nvec", "\n    float flame = 0.0;\n    float flame_scale = 1.0;\n    float flame_speed = 0.001;\n    float flame_intensity = 0.001;\n    float flame_offset = 0.0;\n    float flame_noise = 0.0;\n    float flame_noise_scale = 1.0;\n    float flame_noise_speed = 0.001;\n    float flame_noise_intensity = 0.001;\n    float flame_noise_offset = 0.0;\n    float flame_noise_scale_2 = 1.0;\n    float flame_noise_speed_2 = 0.001;\n    float flame_noise_intensity_2 = 0.001;\n    float flame_noise_offset_2 = 0.0;\n    float flame_noise_scale_3 = 1.0;\n    float flame_noise_speed_3 = 0.001;\n    float flame_noise_intensity_3 = 0.001;\n    float flame_noise_offset_3 = 0.0;\n    float flame_noise_scale_4 = 1.0;\n    float flame_noise_speed_4 = 0.001;\n    float flame_noise_intensity_4 = 0.001;\n    float flame_noise_offset_4 = 0.0;\n    float flame_noise_scale_5 = 1.0;\n    float flame_noise_speed_5 = 0.001;\n    float flame_noise_intensity_5 = 0.001;\n    float flame_noise_offset_5 = 0.0;\n    float flame_noise_scale_6 = 1.0;\n    float flame_noise_speed_6 = 0.001;\n    float flame_noise_intensity_6 = 0.001;\n    float flame_noise_offset_6 = 0.0;\n    float flame_noise_scale_7 = 1.0;\n    float flame_noise_speed_7 = 0.001;\n    float flame_noise_intensity_7 = 0.001;\n    float flame_noise_offset_7 = ", "\n    float distance = sdSphere(currentRayPosition, vec3(0.0, 0.0, 0.0), 1.0);\n    return distance;\n}\n\nvec", "\n    return x - floor(x/sm)*sm;\n}\n\nfloat", "\n    vec3 q = vec3(dot(p, vec3(1.0, 57.0, 21.0)),\n                  dot(p, vec3(57.0, 21.0, 1.0)),\n                  dot(p, vec3(21.0, 1.0, 57.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\nfloat", "\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float A = 1.0;\n    float B = 1.0;\n    float C = 1.0;\n    float D = 1.0;\n    float E = 1.0;\n    float F = 1.0;\n    float G = 1.0;\n    float H = 1.0;\n    float I = 1.0;\n    float J = 1.0;\n    float K = 1.0;\n    float L = 1.0;\n    float M = 1.0;\n    float N = 1.0;\n    float O = 1.0;\n    float P = 1.0;\n    float Q = 1.0;\n    float R = 1.0;\n    float S = 1.0;\n    float T = 1.0;\n    float U = 1.0;\n    float V = 1.0;\n    float W = 1.0;\n    float X = 1.0;\n    float Y = 1.0;\n    float Z = 1.0;\n    float aa = 1.0;\n    float bb = 1.0;\n    float cc = 1.0;\n    float dd = 1.0;\n    float ee", "\n    float d = length(p);\n    float a = atan(p.y,p.x);\n    float r = d*d*d*d;\n    float f = r*a;\n    return sin(f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float t = iGlobalTime;\n    float a = t*0.5;\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c,-s,s,c);\n    p *= m;\n    float f = func(p);\n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n    vec3 balloonSize = vec3(0.5, 0.5, 0.5);\n    vec3 balloonDirection = vec3(0.0, 1.0, 0.0);\n    float balloonRadius = 0.5;\n    float balloonHeight = 1.0;\n    float balloonAngle = 0.0;\n    float balloonSpeed = 0.01;\n    float balloonRotationSpeed = 0.01;\n    float balloonRotationAngle = 0.0;\n    float balloonRotationAngleSpeed = 0.01;\n    float balloonRotationAngleSpeed2 = 0.01;\n    float balloonRotationAngleSpeed3 = 0.01;\n    float balloonRotationAngleSpeed4 = 0.01;\n    float balloonRotationAngleSpeed5 = 0.01;\n    float balloonRotationAngleSpeed6 = 0.01;\n    float balloonRotationAngleSpeed7 = 0.01;\n    float balloonRotationAngleSpeed8 = 0.01;\n    float balloonRotationAngleSpeed9 = 0.01;\n    float balloonRotationAngleSpeed10 = 0.01;\n    float balloonRotationAngleSpeed11 = 0.01;\n    float balloonRotationAngleSpeed12 = 0.01;\n    float balloonRotationAngleSpeed13 = 0.01;\n    float balloonRotationAngleSpeed14 = 0.01;\n    float balloonRotationAngleSpeed15 = 0.01;\n    float balloonRotationAngleSpeed16 = 0.01;\n    float balloonRotationAngleSpeed17 = 0.01;\n    float balloonRotationAngleSpeed18 = 0.01;\n    float balloonRotationAngleSpeed19 = 0.01;\n    float balloonRotationAngleSpeed20 = 0.01;\n    float balloonRot", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec4( tN, tF, tN > tF? -1.0 : 1.0, tF > tN? 1.0 : -1.0 );\n}\n\nvec", "\n    float a = 1.0;\n    float d = 0.0;\n    float s = 1.0;\n    for(int i = 0; i < 8; i++){\n        d += a * (1.0 - abs(p.x) - abs(p.y) - abs(p.z));\n        a *= 0.5;\n        s *= 2.0;\n        p *= 2.0;\n    }\n    return d * s;\n}\n\nfloat", "\n    vec2 pa=p-a, ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return c*(1.0-h)+vec3(1.0,1.0,1.0)*h;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= u_resolution.x / u_resolution.y;\n\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(0.0, 1.0);\n    vec2 c = vec2(1.0, 1.0);\n    vec2 d = vec2(1.0, 0.0);\n\n    col = lineAOc(p, a, b, vec3(1.0, 0.0, 0.0));\n    col = lineAOc(p, b, c, col);\n    col = lineAOc(p, c, d, col);\n    col = lineAOc(p, d, a, col);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float r = length(z);\n    if(r > 2.0) return r;\n    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n    return mandelbrot(c, z);\n}\n\nvoid main() {\n    vec2 c = vec2(gl_FragCoord.x/1000.0, gl_FragCoord.y/1000.0);\n    vec2 z = vec2(0.0, 0.0);\n    float r = mandelbrot(c, z);\n    gl_FragColor = vec4(r, r, r, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return mat4(\n        x.x, x.y, x.z, 0.0,\n        y.x, y.y, y.z, 0.0,\n        z.x, z.y, z.z, 0.0,\n        cam.x, cam.y, cam.z, 1.0\n    );\n}\n\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec3 color = vec3(0.0);\n\n    float t = u_time * 0.5;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n\n    float f = cos(a * 10.0 - t * 10.0) * 0.5 + 0.5;\n    f *= smoothstep(0.0, 0.01, r * 0.5);\n\n    vec3 c = hsv2rgb(vec3(f, 1.0, 1.0));\n    color = mix(color, c, f);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float d = length(p) - w;\n    float a = atan(p.y, p.x) + dir;\n    float r = length(p) * sin(a);\n    float s = cos(a * 10.0);\n    float f = mod(a * 10.0, 2.0 * PI);\n    float g = smoothstep(0.0, 0.01, f);\n    float t = s * g;\n    return max(d, r) - t * 0.5;\n}\n\nfloat", "\n    return a + x * (b - a);\n}\n\nfloat", "\n    float d = length(xy);\n    float a = atan(xy.y, xy.x);\n    float r = d * 0.5;\n    float s = sin(a * 10.0);\n    float c = cos(a * 10.0);\n    float f = pow(1.0 - d, 2.0);\n    float g = pow(1.0 - d, 1.0);\n    float b = pow(1.0 - d, 0.5);\n    float h = pow(1.0 - d, 0.25);\n    float i = pow(1.0 - d, 0.125);\n    float j = pow(1.0 - d, 0.0625);\n    float k = pow(1.0 - d, 0.03125);\n    float l = pow(1.0 - d, 0.015625);\n    float m = pow(1.0 - d, 0.0078125);\n    float n = pow(1.0 - d, 0.00390625);\n    float o = pow(1.0 - d, 0.001953125);\n    float p = pow(1.0 - d, 0.0009765625);\n    float q = pow(1.0 - d, 0.00048828125);\n    float r = pow(1.0 - d, 0.000244140625);\n    float s = pow(1.0 - d, 0.0001220703125);\n    float t = pow(1.0 - d, 0.00006103515625);\n    float u = pow(1.0 - d, 0.000030517578125);\n    float v = pow(1.0 - d, 0.0000152587890625);", "\n    float d=0.;\n    float a=0.;\n    float b=0.;\n    float c=0.;\n    float d1=0.;\n    float d2=0.;\n    float d3=0.;\n    float d4=0.;\n    float d5=0.;\n    float d6=0.;\n    float d7=0.;\n    float d8=0.;\n    float d9=0.;\n    float d10=0.;\n    float d11=0.;\n    float d12=0.;\n    float d13=0.;\n    float d14=0.;\n    float d15=0.;\n    float d16=0.;\n    float d17=0.;\n    float d18=0.;\n    float d19=0.;\n    float d20=0.;\n    float d21=0.;\n    float d22=0.;\n    float d23=0.;\n    float d24=0.;\n    float d25=0.;\n    float d26=0.;\n    float d27=0.;\n    float d28=0.;\n    float d29=0.;\n    float d30=0.;\n    float d31=0.;\n    float d32=0.;\n    float d33=0.;\n    float d34=0.;\n    float d35=0.;\n    float d36=0.;\n    float d37=0.;\n    float d38=0.;\n    float d39=0.;\n    float d40=0.;\n    float d41=0.;\n    float d42=0.;\n    float d43=0.;\n    float d44=0.;\n    float d45=0.;\n    float d46=0.;\n    float d47=0.;\n    float d48=0.;\n    float d49=0.;\n    float d50=0.;\n    float d51=0.;\n    float d52=0.;\n    float d53=0.;\n    float d54=0.;\n    float d55=", "\n\treturn f*f*f;\n}\n\nfloat", "\n    return c;\n}\n\nvec", "\n    vec3 d = abs(p) - s;\n    return vec4(min(max(d.x,max(d.y,d.z)),0.0),\n                (d.x<0.0?1.0:0.0)+(d.y<0.0?2.0:0.0)+(d.z<0.0?4.0:0.0),\n                length(max(d,0.0)),\n                length(p-s));\n}\n\nvec", "\n    float d = sdSuperprim(p, s);\n    return vec4(d, r);\n}\n\nvec", "\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    return mat;\n}\n\nMaterial matScene(vec3 pos, float depth, int steps, vec3 color)\n{\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    mat.color = color;\n    return mat;\n}\n\nMaterial matScene(vec3 pos, float depth, int steps, vec3 color, float reflectivity)\n{\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    mat.color = color;\n    mat.reflectivity = reflectivity;\n    return mat;\n}\n\nMaterial matScene(vec3 pos, float depth, int steps, vec3 color, float reflectivity, float refractivity)\n{\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    mat.color = color;\n    mat.reflectivity = reflectivity;\n    mat.refractivity = refractivity;\n    return mat;\n}\n\nMaterial matScene(vec3 pos, float depth, int steps, vec3 color, float reflectivity, float refractivity, float refractIndex)\n{\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    mat.color = color;\n    mat.reflectivity = reflectivity;\n    mat.refractivity = refractivity;\n    mat.refractIndex = refractIndex;\n    return mat;\n}\n\nMaterial matScene(vec3 pos, float depth, int steps, vec3 color, float reflectivity, float refractivity, float refractIndex, float specularity)\n{\n    Material mat;\n    mat.pos = pos;\n    mat.depth = depth;\n    mat.steps = steps;\n    mat.color = color;\n    mat.reflectivity = reflectivity;\n    mat.refractivity = refractivity;\n    mat.refractIndex = ref", "\n    return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n}\n\nvec", "\n    float d=length(p)-1.0;\n    d=max(d,-p.y);\n    return d;\n}\n\nvec", "\n    float t = time * 0.5;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = length(p - vec3(cos(a + t) * r, sin(a + t) * r, 0.0));\n    float f = exp(-d * 0.5);\n    return mat(vec3(0.0), vec3(0.0), vec3(f));\n}\n\nmat", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat", "\n  float t = iTime;\n  float r = length(p);\n  float a = atan(p.y, p.x);\n  float d = r - a * t;\n  float c = cos(d);\n  float s = sin(d);\n  p = vec2(c, s);\n  float f = fract(t);\n  float g = (1.0 - f) * c + f * s;\n  float b = (1.0 - f) * s - f * c;\n  p = vec2(g, b);\n  float h = length(p);\n  float i = atan(p.y, p.x);\n  float j = h - i * t;\n  float k = cos(j);\n  float l = sin(j);\n  p = vec2(k, l);\n  float m = length(p);\n  float n = atan(p.y, p.x);\n  float o = m - n * t;\n  float q = cos(o);\n  float r = sin(o);\n  p = vec2(q, r);\n  float s = length(p);\n  float t = atan(p.y, p.x);\n  float u = s - t * t;\n  float v = cos(u);\n  float w = sin(u);\n  p = vec2(v, w);\n  float x = length(p);\n  float y = atan(p.y, p.x);\n  float z = x - y * t;\n  float A = cos(z);\n  float B = sin(z);\n  p = vec2(A, B);\n  float C = length(p);\n  float D = atan(p.y, p.x);\n  float E = C - D * t;\n  float F = cos(E);\n  float G = sin(E);\n  p = vec2(F, G);\n  float H = length(p);\n  float I = atan(p.y, p.x);\n  float J = H - I * t;\n  float K = cos(J);\n  float L", "\n    return dot(u,m);\n}\n\nfloat", "\n  float a=u.x-m.x;\n  float b=u.y-m.y;\n  return sqrt(a*a+b*b);\n}\n\nfloat", "\n    return dot(u,m.xy)+m.w;\n}\n\nfloat", "\n    v2 c(v1 U){\n        v2 c(v1 U){\n            v2 c(v1 U){\n                v2 c(v1 U){\n                    v2 c(v1 U){\n                        v2 c(v1 U){\n                            v2 c(v1 U){\n                                v2 c(v1 U){\n                                    v2 c(v1 U){\n                                        v2 c(v1 U){\n                                            v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                    v2 c(v1 U){\n                                                                                                        v2 c(v1 U){\n                                                                                                            v2 c(v1 U){\n                                                                                                                v2 c(v1 U){\n                                                                                                                    v2 c(v1 U){\n                                                                                                                        v2 c(v1 U){\n                                                                                                                            v2 c(v1 U){\n                                                                                                                                v2 c(v1 U){\n                                                                                                                                    v2 c(v1 U){\n                                                                                                                                        v2 c(v1 U){\n                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                                        v2 c(v1", "\n    v2 c(v1 U){\n        v2 c(v1 U){\n            v2 c(v1 U){\n                v2 c(v1 U){\n                    v2 c(v1 U){\n                        v2 c(v1 U){\n                            v2 c(v1 U){\n                                v2 c(v1 U){\n                                    v2 c(v1 U){\n                                        v2 c(v1 U){\n                                            v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                    v2 c(v1 U){\n                                                                                                        v2 c(v1 U){\n                                                                                                            v2 c(v1 U){\n                                                                                                                v2 c(v1 U){\n                                                                                                                    v2 c(v1 U){\n                                                                                                                        v2 c(v1 U){\n                                                                                                                            v2 c(v1 U){\n                                                                                                                                v2 c(v1 U){\n                                                                                                                                    v2 c(v1 U){\n                                                                                                                                        v2 c(v1 U){\n                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                                        v2 c(v1", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n    float a = sqrt(Xi1);\n    float b = (1.0 - a) * Xi2;\n    float c = 1.0 - a - b;\n    w = a * A + b * B + c * C;\n    wPdf = 1.0 / (2.0 * PI);\n}\n\nvec", "\n    v2 c(v1 U){\n        v2 c(v1 U){\n            v2 c(v1 U){\n                v2 c(v1 U){\n                    v2 c(v1 U){\n                        v2 c(v1 U){\n                            v2 c(v1 U){\n                                v2 c(v1 U){\n                                    v2 c(v1 U){\n                                        v2 c(v1 U){\n                                            v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                    v2 c(v1 U){\n                                                                                                        v2 c(v1 U){\n                                                                                                            v2 c(v1 U){\n                                                                                                                v2 c(v1 U){\n                                                                                                                    v2 c(v1 U){\n                                                                                                                        v2 c(v1 U){\n                                                                                                                            v2 c(v1 U){\n                                                                                                                                v2 c(v1 U){\n                                                                                                                                    v2 c(v1 U){\n                                                                                                                                        v2 c(v1 U){\n                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                        v2 c(v1 U){\n                                                                                                                                                                            v2 c(v1 U){\n                                                                                                                                                                                v2 c(v1 U){\n                                                                                                                                                                                    v2 c(v1 U){\n                                                                                                                                                                                        v2 c(v1", "\n    float d = length(p)-1.0;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float n =.1/r;\n    d = max(d,abs(sin(8.0*a))-n);\n    return d;\n}\n\nfloat", "\n    float d = length(p.xy)-1.0;\n    float r = length(p.xy)-1.0;\n    float h = abs(p.z)-0.5;\n    float d1 = max(d,h);\n    float d2 = max(r,h);\n    float d3 = max(d,r);\n    float d4 = max(d1,d2);\n    float d5 = max(d4,d3);\n    return vec4(d5,1.0,0.0,0.0);\n}\n\nvec", "\n    float t = iTime;\n    float l = length(p);\n    float d = l - 0.5;\n    float f = smoothstep(0.0, 0.01, d);\n    float r = f * (1.0 - f) * 10.0;\n    float s = sin(t * r + l * 10.0);\n    float b = s * 0.5 + 0.5;\n    return b;\n}\n\nfloat", "\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            return t;\n        }\n        t += d;\n    }\n    return 1000.0;\n}\n\nvec", "\n    float d = dot(ro, lp);\n    float s = d * d - k;\n    if(s < 0.0) return 1.0;\n    return s / (d + sqrt(s));\n}\n\nfloat", "\n    vec3 e1 = dFdx(p);\n    vec3 e2 = dFdy(p);\n    edge = dot(e1, e1) + dot(e2, e2);\n    crv = dot(e1, e2);\n    return normalize(cross(e1, e2));\n}\n\nvoid main() {\n    float edge, crv;\n    vec3 n = nrm(pos, edge, crv, 0.0);\n    float d = dot(n, n);\n    float a = acos(d);\n    float b = a * 2.0;\n    float c = b * 2.0;\n    float s = sin(a);\n    float t = tan(a);\n    float r = s / a;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r2 * r2;\n    float r5 = r4 * r;\n    float r6 = r4 * r2;\n    float r7 = r6 * r;\n    float r8 = r4 * r4;\n    float r9 = r8 * r;\n    float r10 = r8 * r2;\n    float r11 = r10 * r;\n    float r12 = r8 * r4;\n    float r13 = r12 * r;\n    float r14 = r12 * r2;\n    float r15 = r14 * r;\n    float r16 = r12 * r4;\n    float r17 = r16 * r;\n    float r18 = r16 * r2;\n    float r19 = r18 * r;\n    float r20 = r16 * r4;\n    float r21 = r20 * r;\n    float r22 = r20 * r2;\n    float r23 = r22 * r;\n    float r24 = r20 * r4;\n    float r25 = r24 * r;\n    float r26 = r24 * r2;\n    float r27 = r", "\n    vec3 p = m * (p3 - t);\n    return vec4(p.x, p.y, p.z, 1.0 - (p.x + p.y + p.z));\n}\n\nvec", "\n    vec2 hex = floor(p/1.0);\n    vec2 hex_fract = fract(p/1.0);\n    vec2 hex_fract_rounded = round(hex_fract);\n    vec2 hex_fract_diff = abs(hex_fract - hex_fract_rounded);\n    vec2 hex_fract_diff_rounded = round(hex_fract_diff);\n    vec2 hex_fract_diff_rounded_diff = abs(hex_fract_diff - hex_fract_diff_rounded);\n    vec2 hex_fract_diff_rounded_diff_rounded = round(hex_fract_diff_rounded_diff);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff = abs(hex_fract_diff_rounded_diff - hex_fract_diff_rounded_diff_rounded);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff_rounded = round(hex_fract_diff_rounded_diff_rounded_diff);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff_rounded_diff = abs(hex_fract_diff_rounded_diff_rounded_diff - hex_fract_diff_rounded_diff_rounded_diff_rounded);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff_rounded_diff_rounded = round(hex_fract_diff_rounded_diff_rounded_diff_rounded_diff);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff_rounded_diff_rounded_diff = abs(hex_fract_diff_rounded_diff_rounded_diff_rounded_diff - hex_fract_diff_rounded_diff_rounded_diff_rounded_diff_rounded);\n    vec2 hex_fract_diff_rounded_diff_rounded_diff_rounded_diff_rounded_diff_rounded = round(hex_fract_", "\n    float d = dot(p,p);\n    return d*d*d*d - d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*", "\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float a2 = a + dir;\n    return r * cos(a2);\n}\n\nvec", "\n    vec3 v0 = n[1] - n[0];\n    vec3 v1 = n[2] - n[0];\n    vec3 v2 = p3 - n[0];\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0 - v - w;\n    return vec4(u, v, w, 1.0);\n}\n\nvec", "\n    vec4 v = q - p;\n    vec4 w = r - p;\n    float c = dot(v, w);\n    if (c <= 0.0) return 0.0;\n    float b = dot(v, v);\n    if (b >= c) return 0.0;\n    float a = dot(w, w);\n    if (a >= c) return 0.0;\n    float d = a * b - c * c;\n    float e = a * c - b * b;\n    float s = e / d;\n    float t = (c - e) / d;\n    if (s < 0.0) return 0.0;\n    if (s > 1.0) return 0.0;\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    return 1.0;\n}\n\nfloat", "\n    float d = length(p);\n    return 1.0 - smoothstep(lW, lW + 0.01, d);\n}\n\nfloat", "\n    vec2 grid = fract( p );\n    vec2 dxy = vec2( dFdx( p.x ), dFdy( p.y ) );\n    vec2 scale = vec2( length( ddx ), length( ddy ) );\n    vec2 offset = 0.5 * ( dxy / scale + 1.0 );\n    vec2 blend = smoothstep( vec2( 0.0 ), vec2( 1.0 ), offset );\n    return mix( mix( dot( grid, ddx ), dot( grid, ddy ), blend.x ),\n                mix( dot( 1.0 - grid, ddx ), dot( 1.0 - grid, ddy ), blend.x ),\n                blend.y );\n}\n\nfloat", "\n    float d = dot( n, n );\n    float e = dot( f, f );\n    float g = dot( n, f );\n    float h = d - e;\n    float t = 1.0 - g / ( sqrt( d * e ) + 0.00001 );\n    t = clamp( t, 0.0, 1.0 );\n    float s = max( h, 0.0 );\n    s = ( s * s ) / ( ( s * s ) + ( t * t ) * ( 1.0 - t ) * 0.09 );\n    mr = n + s * ( f - n * g );\n    float z = sqrt( d * e ) * ( 1.0 - t );\n    mg = vec2( -n.y, n.x ) * z;\n    return s;\n}\n\nfloat", "\n    return vec2(lerp(0.0, 1.0, t), 0.0);\n}\n\nvec", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n  vec3 p3 = fract(vec3(p.xyx) *.1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat", "\n    vec2 v0 = p1 - p0;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p0 - p2;\n    float d0 = dot(v0, v0);\n    float d1 = dot(v1, v1);\n    float d2 = dot(v2, v2);\n    float u = d0 * (d1 + d2 - d0) * (d1 + d2 - d0);\n    float v = d1 * (d2 + d0 - d1) * (d2 + d0 - d1);\n    float w = d2 * (d0 + d1 - d2) * (d0 + d1 - d2);\n    float denom = 4.0 * (u + v + w);\n    float u2 = u / denom;\n    float v2 = v / denom;\n    float w2 = w / denom;\n    return p0 * u2 + p1 * v2 + p2 * w2;\n}\n\nvoid main(){\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    vec2 p3 = vec2(1.0, 1.0);\n    vec2 p4 = vec2(0.5, 0.5);\n    vec2 p5 = vec2(0.5, 0.0);\n    vec2 p6 = vec2(0.0, 0.5);\n    vec2 p7 = vec2(1.0, 0.5);\n    vec2 p8 = vec2(0.5, 1.0);\n    vec2 p9 = vec2(0.0, 0.0);\n    vec2 p10 = vec2(1.0, 0.0);\n    vec2 p11 = vec2(0.0, 1.0);\n    vec2 p12 =", "\n    vec2 v0 = p1 - p0;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p0 - p2;\n    float a = length(v0);\n    float b = length(v1);\n    float c = length(v2);\n    float p = (a + b + c) / 2.0;\n    float s = sqrt(p * (p - a) * (p - b) * (p - c));\n    return s / p;\n}\n\nfloat", "\n    vec2 v1 = h2 - h1;\n    vec2 v2 = h3 - h2;\n    float d = dot(v1, v2);\n    float l1 = length(v1);\n    float l2 = length(v2);\n    float l = l1 * l2;\n    float dd = d / l;\n    float dd2 = dd * dd;\n    float dd3 = dd2 * dd;\n    float dd4 = dd2 * dd2;\n    float dd5 = dd4 * dd;\n    float dd6 = dd4 * dd2;\n    float dd7 = dd6 * dd;\n    float dd8 = dd6 * dd2;\n    float dd9 = dd8 * dd;\n    float dd10 = dd8 * dd2;\n    float dd11 = dd10 * dd;\n    float dd12 = dd10 * dd2;\n    float dd13 = dd12 * dd;\n    float dd14 = dd12 * dd2;\n    float dd15 = dd14 * dd;\n    float dd16 = dd14 * dd2;\n    float dd17 = dd16 * dd;\n    float dd18 = dd16 * dd2;\n    float dd19 = dd18 * dd;\n    float dd20 = dd18 * dd2;\n    float dd21 = dd20 * dd;\n    float dd22 = dd20 * dd2;\n    float dd23 = dd22 * dd;\n    float dd24 = dd22 * dd2;\n    float dd25 = dd24 * dd;\n    float dd26 = dd24 * dd2;\n    float dd27 = dd26 * dd;\n    float dd28 = dd26 * dd2;\n", "\n    triObj t;\n    t.p0 = p;\n    t.p1 = p + vec2(1.0, 0.0);\n    t.p2 = p + vec2(0.0, 1.0);\n    return t;\n}\n\ntriObj triangulate(in vec3 p){\n    triObj t;\n    t.p0 = p.xy;\n    t.p1 = p.xy + vec2(1.0, 0.0);\n    t.p2 = p.xy + vec2(0.0, 1.0);\n    return t;\n}\n\ntriObj triangulate(in vec4 p){\n    triObj t;\n    t.p0 = p.xy;\n    t.p1 = p.xy + vec2(1.0, 0.0);\n    t.p2 = p.xy + vec2(0.0, 1.0);\n    return t;\n}\n\ntriObj triangulate(in vec2 p, in vec2 s){\n    triObj t;\n    t.p0 = p;\n    t.p1 = p + vec2(s.x, 0.0);\n    t.p2 = p + vec2(0.0, s.y);\n    return t;\n}\n\ntriObj triangulate(in vec3 p, in vec2 s){\n    triObj t;\n    t.p0 = p.xy;\n    t.p1 = p.xy + vec2(s.x, 0.0);\n    t.p2 = p.xy + vec2(0.0, s.y);\n    return t;\n}\n\ntriObj triangulate(in vec4 p, in vec2 s){\n    triObj t;\n    t.p0 = p.xy;\n    t.p1 = p.xy + vec2(s.x, 0.0);\n    t.p2 = p.xy + vec2(0.0, s.y);\n    return t;\n}\n\ntriObj triangulate", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 ) \n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectPlane( in Plane_t plane, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    float denom = dot( plane.normal, ray.direction );\n    if ( abs( denom ) > 0.0001 ) \n    {\n        float temp = dot( plane.normal, plane.point - ray.origin ) / denom;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = plane.normal;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax,\n                        out float t, out vec3 hitPos, out vec3 hitNormal ) ", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t )\n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 normal )\n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray", "\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    float t = INFINITY;\n    float t_min = INFINITY;\n    int id_min = -1;\n\n    for( int i = 0; i < NUM_SPHERES; i++ )\n    {\n        t = SphereIntersect( ray, spheres[i] );\n        if( t > 0.0 )\n        {\n            if( t < t_min )\n            {\n                t_min = t;\n                id_min = i;\n            }\n        }\n    }\n\n    if( id_min >= 0 )\n    {\n        hasHit = true;\n        hitPos = ray.origin + t_min * ray.direction;\n        hitNormal = normalize( hitPos - spheres[id_min].center );\n        k_rg = spheres[id_min].k_rg;\n    }\n\n    return k_rg;\n}\n\nvoid main()\n{\n    vec3 color = vec3(0.0);\n    vec3 hitPos = vec3(0.0);\n    vec3 hitNormal = vec3(0.0);\n    vec3 k_rg = vec3(0.0);\n    bool hasHit = false;\n\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ray_dir = normalize( vec3( uv.x, uv.y, 1.0 ) );\n    Ray_t ray = Ray_t( u_cameraPos, ray_dir );\n\n    color = CastRay( ray, hasHit, hitPos, hitNormal, k_rg );\n\n    if( hasHit )\n    {\n        color = k_rg;\n    }\n\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p0122 = mix(p012, p12, 0.5);\n    vec2 p01222 = mix(p0122, p12, 0.5);\n    vec2 p012222 = mix(p01222, p12, 0.5);\n    vec2 p0122222 = mix(p012222, p12, 0.5);\n    vec2 p01222222 = mix(p0122222, p12, 0.5);\n    vec2 p012222222 = mix(p01222222, p12, 0.5);\n    vec2 p0122222222 = mix(p012222222, p12, 0.5);\n    vec2 p01222222222 = mix(p0122222222, p12, 0.5);\n    vec2 p012222222222 = mix(p01222222222, p12, 0.5);\n    vec2 p0122222222222 = mix(p012222222222, p12, 0.5);\n    vec2 p01222222222222 = mix(p0122222222222, p12, 0.5);\n    vec2 p012222222222222 = mix(p01222222222", "\n    vec3 p01 = p1 - p0;\n    vec3 p12 = p2 - p1;\n    vec3 p23 = p3 - p2;\n\n    vec3 p012 = p12 - p01;\n    vec3 p123 = p23 - p12;\n\n    vec3 p0123 = p123 - p012;\n\n    vec3 p0123_abs = abs( p0123 );\n\n    vec3 p01_abs = abs( p01 );\n    vec3 p12_abs = abs( p12 );\n    vec3 p23_abs = abs( p23 );\n\n    vec3 p012_abs = abs( p012 );\n    vec3 p123_abs = abs( p123 );\n\n    vec3 p012_abs_sum = p012_abs + p12_abs;\n    vec3 p123_abs_sum = p123_abs + p23_abs;\n\n    vec3 p0123_abs_sum = p0123_abs + p012_abs_sum + p123_abs_sum;\n\n    vec3 p0123_abs_sum_sum = p0123_abs_sum + p01_abs + p123_abs_sum + p23_abs;\n\n    vec3 p0123_abs_sum_sum_sum = p0123_abs_sum_sum + p012_abs + p123_abs;\n\n    vec3 p0123_abs_sum_sum_sum_sum = p0123_abs_sum_sum_sum + p0123_abs;\n\n    vec3 p0123_abs_sum_sum_sum_sum_sum = p0123_abs_sum_sum_sum_sum + p0123_abs_sum_sum_sum;\n\n    vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    return 1.0 - (1.0 - k) * (1.0 - k);\n}\n\nvec", "\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  +", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec2 uv = coord / res;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = space(iResolution.xy, gl_FragCoord.xy);\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float f = floor(a / 0.1) * 0.1;\n    float s = sin(f + t);\n    float c = cos(f + t);\n    uv = vec2(c, s) * r;\n    col = vec3(uv, 0.0);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float c = 0.0;\n    c += sin(p.x*10.0)*sin(p.y*10.0);\n    c += sin(p.x*10.0+10.0)*sin(p.y*10.0+10.0);\n    c += sin(p.x*10.0+20.0)*sin(p.y*10.0+20.0);\n    c += sin(p.x*10.0+30.0)*sin(p.y*10.0+30.0);\n    c += sin(p.x*10.0+40.0)*sin(p.y*10.0+40.0);\n    c += sin(p.x*10.0+50.0)*sin(p.y*10.0+50.0);\n    c += sin(p.x*10.0+60.0)*sin(p.y*10.0+60.0);\n    c += sin(p.x*10.0+70.0)*sin(p.y*10.0+70.0);\n    c += sin(p.x*10.0+80.0)*sin(p.y*10.0+80.0);\n    c += sin(p.x*10.0+90.0)*sin(p.y*10.0+90.0);\n    c += sin(p.x*10.0+100.0)*sin(p.y*10.0+100.0);\n    c += sin(p.x*10.0+110.0)*sin(p.y*10.0+110.0);\n    c += sin(p.x*10.0+120.0)*sin(p.y*10.0+120.0);\n    c += sin(p.x*10.0+130.0)*sin(p.y*10.0+130.0);\n", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec", "\n    vec2 e = vec2( 1.0, -1.0 ) * 0.0005;\n    return normalize( e.xyy * map( p + e.xyy ) + \n\t\t\t\t\t  e.yyx * map( p + e.yyx ) + \n\t\t\t\t\t  e.yxy * map( p + e.yxy ) + \n\t\t\t\t\t  e.xxx * map( p + e.xxx ) );\n}\n\nfloat", "\n    return fract(sin(dot(q.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat", "\n\tfloat d = length(pos);\n\tfloat a = atan(pos.y, pos.x);\n\tfloat w = width * 0.5;\n\tfloat r = radius * 0.5;\n\tfloat t = smoothstep(r, r - w, d);\n\tfloat s = smoothstep(r, r + w, d);\n\treturn t * s;\n}\n\nfloat", "\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  +", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float d00 = dot(random3(ip), fp);\n    float d01 = dot(random3(ip + vec3(0.0, 1.0, 0.0)), fp - vec3(0.0, 1.0, 0.0));\n    float d02 = dot(random3(ip + vec3(0.0, 0.0, 1.0)), fp - vec3(0.0, 0.0, 1.0));\n    float d10 = dot(random3(ip + vec3(1.0, 0.0, 0.0)), fp - vec3(1.0, 0.0, 0.0));\n    float d11 = dot(random3(ip + vec3(1.0, 1.0, 0.0)), fp - vec3(1.0, 1.0, 0.0));\n    float d12 = dot(random3(ip + vec3(1.0, 0.0, 1.0)), fp - vec3(1.0, 0.0, 1.0));\n    float d20 = dot(random3(ip + vec3(0.0, 1.0, 1.0)), fp - vec3(0.0, 1.0, 1.0));\n    float d21 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n    float d22 = dot(random3(ip + vec3(1.0, 1.0, 1.0)), fp - vec3(1.0, 1.0, 1.0));\n\n    float d0 = mix(d00, d01, fp.y);\n    float d1 = mix(d10, d11, fp.y);\n    float d", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n\n    if (p.x > 0.0) {\n        sp.x = -p.x;\n        tp.x = p.x;\n        rp.x = -p.x;\n        mul *= -1.0;\n    }\n\n    if (p.y > 0.0) {\n        sp.y = -p.y;\n        tp.y = p.y;\n        rp.y = -p.y;\n        mul *= -1.0;\n    }\n\n    if (p.z > 0.0) {\n        sp.z = -p.z;\n        tp.z = p.z;\n        rp.z = -p.z;\n        mul *= -1.0;\n    }\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp)\n{\n    float mul;\n    tile(p, sp, tp, rp, mul);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp)\n{\n    vec3 rp;\n    float mul;\n    tile(p, sp, tp, rp, mul);\n}\n\nvoid tile(in vec3 p, out vec3 sp)\n{\n    vec3 tp, rp;\n    float mul;\n    tile(p, sp, tp, rp, mul);\n}\n\nvoid tile(in vec3 p, out float mul)\n{\n    vec3 sp, tp, rp;\n    tile(p, sp, tp, rp, mul);\n}\n\nvoid tile(in vec3 p)\n{\n    vec3 sp, tp, rp;\n    float mul;\n    tile(p, sp, tp, rp, mul);\n}\n", "\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q) - 1.0;\n    return vec2(d, 0.0);\n}\n\nvec", "\n\treturn vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float s = sin(a);\n    float c = cos(a);\n    float t = tan(a);\n    float d = (1.0 - r) / (1.0 + r);\n    float d2 = d * d;\n    float d4 = d2 * d2;\n    float d6 = d4 * d2;\n    float d8 = d6 * d2;\n    float d10 = d8 * d2;\n    float d12 = d10 * d2;\n    float d14 = d12 * d2;\n    float d16 = d14 * d2;\n    float d18 = d16 * d2;\n    float d20 = d18 * d2;\n    float d22 = d20 * d2;\n    float d24 = d22 * d2;\n    float d26 = d24 * d2;\n    float d28 = d26 * d2;\n    float d30 = d28 * d2;\n    float d32 = d30 * d2;\n    float d34 = d32 * d2;\n    float d36 = d34 * d2;\n    float d38 = d36 * d2;\n    float d40 = d38 * d2;\n    float d42 = d40 * d2;\n    float d44 = d42 * d2;\n    float d46 = d44 * d2;\n    float d48 = d46 * d2;\n    float d50 = d48 * d2;\n    float d52 = d50 * d2;\n    float d54 = d52 * d2;\n    float d56 = d54 * d2;\n    float d58 = d56 * d2;\n    float d60 = d58 * d2;\n    float d62 = d60 * d2;\n    float d64 = d62 * d2;\n    float", "\n    vec2 box = vec2(0.0);\n    box.x = length(pos.xz) - 0.5;\n    box.y = pos.y;\n    return box;\n}\n\nvoid main() {\n    vec2 box = ourBox(position);\n    float dist = length(box);\n    float diff = dist - 0.5;\n    float edge = smoothstep(0.0, 0.01, diff);\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    color = mix(color, vec3(0.0, 0.0, 1.0), edge);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float r = length(pos);\n    float theta = acos(pos.z/r);\n    float phi = atan(pos.y, pos.x);\n    return vec2(theta, phi);\n}\n\nvec", "\n    vec3 p = pos;\n    float d = sdBox(p, vec3(1.0));\n    for (int i = 0; i < 5; i++) {\n        vec3 newp = p;\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *= rot(0.785398);\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *= rot(0.785398);\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *= rot(0.785398);\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *= rot(0.785398);\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *= rot(0.785398);\n        newp.xz *= rot(0.785398);\n        newp.xy *= rot(0.785398);\n        newp.zy *= rot(0.785398);\n        newp.yz *=", "\n    vec3 rayDir = normalize(camDir + fragCoord.x * camRight + fragCoord.y * camUp);\n    vec3 rayPos = camPos;\n    float dist = 0.0;\n    float totalDist = 0.0;\n    float t = 0.0;\n    float tMax = 100.0;\n    float tMin = 0.001;\n    float tStep = 0.0;\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specularColor = vec3(0.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 ambientColor = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n    vec3 diffuseLight = vec3(0.0);\n    vec3 ambientLight = vec3(0.0);\n    vec3 specularColorLight = vec3(0.0);\n    vec3 diffuseColorLight = vec3(0.0);\n    vec3 ambientColorLight = vec3(0.0);\n    vec3 specularColorLight2 = vec3(0.0);\n    vec3 diffuseColorLight2 = vec3(0.0);\n    vec3 ambientColorLight2 = vec3(0.0);\n    vec3 specularColorLight3 = vec3(0.0);\n    vec3 diffuseColorLight3 = vec3(0.0);\n    vec3 ambientColorLight3 = vec3(0.0);\n    vec3 specularColorLight4 = vec3(0.0);\n    vec3 diffuseColorLight4 = vec3(0.0);\n    vec3 ambientColorLight4 = vec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    return dot(pos, plane.normal) - plane.distance;\n}\n\nfloat", "\n\tvec3 p = vec3(ix);\n\tvec3 f = fract(fx);\n\tvec3 w = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy + p.z*vec2(157.0, 113.0);\n\tfloat n = dot(vec4(0.0, 1.0, 57.0, 29.0), sin(uv.xyxy*mat4(127.1, 311.7, 409.7, 831.3, 269.5, 489.5, 399.5, 603.5)));\n\treturn mix(mix(mix(n, n+1.0, w.x), mix(n+2.0, n+3.0, w.x), w.y), mix(mix(n+4.0, n+5.0, w.x), mix(n+6.0, n+7.0, w.x), w.y), w.z);\n}\n\nfloat", "\n    float f=0.0;\n    float a=0.0;\n    float b=0.0;\n    float c=0.0;\n    float d=0.0;\n    float e=0.0;\n    float g=0.0;\n    float h=0.0;\n    float i=0.0;\n    float j=0.0;\n    float k=0.0;\n    float l=0.0;\n    float m=0.0;\n    float n=0.0;\n    float o=0.0;\n    float p=0.0;\n    float q=0.0;\n    float r=0.0;\n    float s=0.0;\n    float t=0.0;\n    float u=0.0;\n    float v=0.0;\n    float w=0.0;\n    float x=0.0;\n    float y=0.0;\n    float z=0.0;\n    float A=0.0;\n    float B=0.0;\n    float C=0.0;\n    float D=0.0;\n    float E=0.0;\n    float F=0.0;\n    float G=0.0;\n    float H=0.0;\n    float I=0.0;\n    float J=0.0;\n    float K=0.0;\n    float L=0.0;\n    float M=0.0;\n    float N=0.0;\n    float O=0.0;\n    float P=0.0;\n    float Q=0.0;\n    float R=0.0;\n    float S=0.0;\n    float T=0.0;\n    float U=0.0;\n    float V=0.0;\n    float W=0.0;\n    float X=0.0;\n    float Y=0.0;\n    float Z=0.0;\n    float aa=0.0;\n    float bb=0.0;\n    float cc=0.0;\n    float dd=0.0;\n    float ee", "\n    p.xz = abs(p.xz);\n    p.x -= r;\n    vec2 d = vec2( length(p.xz) - r, p.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n    float d = length(p)-1.0;\n    return d;\n}\n\nvec", "\n    float d = map(p);\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat", "\n\treturn max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra * ra;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if( t1 < 0.0 ) return t2;\n    return t1;\n}\n\nfloat", "\n    vec2 dp = dpdx + dpdy;\n    float d = dot(dp,dp);\n    return 1.0 - smoothstep(0.0, 0.0001, d);\n}\n\nfloat", "\n\tInitScene_0();\n\tInitScene_1();\n\tInitScene_2();\n\tInitScene_3();\n\tInitScene_4();\n\tInitScene_5();\n\tInitScene_6();\n\tInitScene_7();\n\tInitScene_8();\n\tInitScene_9();\n\tInitScene_10();\n\tInitScene_11();\n\tInitScene_12();\n\tInitScene_13();\n\tInitScene_14();\n\tInitScene_15();\n\tInitScene_16();\n\tInitScene_17();\n\tInitScene_18();\n\tInitScene_19();\n\tInitScene_20();\n\tInitScene_21();\n\tInitScene_22();\n\tInitScene_23();\n\tInitScene_24();\n\tInitScene_25();\n\tInitScene_26();\n\tInitScene_27();\n\tInitScene_28();\n\tInitScene_29();\n\tInitScene_30();\n\tInitScene_31();\n\tInitScene_32();\n\tInitScene_33();\n\tInitScene_34();\n\tInitScene_35();\n\tInitScene_36();\n\tInitScene_37();\n\tInitScene_38();\n\tInitScene_39();\n\tInitScene_40();\n\tInitScene_41();\n\tInitScene_42();\n\tInitScene_43();\n\tInitScene_44();\n\tInitScene_45();\n\tInitScene_46();\n\tInitScene_47();\n\tInitScene_48();\n\tInitScene_49();\n\tInitScene_50();\n\tInitScene_51();\n\tInitScene_52();\n\tInitScene_53();\n\tInitScene_54();\n\tInitScene_55();\n\tInitScene_56();\n\tInitScene_57();", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 ) \n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectPlane( in Plane_t plane, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    float denom = dot( plane.normal, ray.direction );\n    if ( abs( denom ) > 0.0001 ) \n    {\n        float temp = dot( plane.normal, plane.point - ray.origin ) / denom;\n        if ( temp < tmax && temp > tmin ) \n        {\n            t = temp;\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = plane.normal;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax,\n                        out float t, out vec3 hitPos, out vec3 hitNormal ) ", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t )\n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = ( -b - sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n        temp = ( -b + sqrt( discriminant ) ) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 normal )\n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray", "\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    float t = INFINITY;\n    float t_min = INFINITY;\n    int id_min = -1;\n\n    for( int i = 0; i < NUM_SPHERES; i++ )\n    {\n        t = SphereIntersect( ray, spheres[i] );\n        if( t > 0.0 )\n        {\n            if( t < t_min )\n            {\n                t_min = t;\n                id_min = i;\n            }\n        }\n    }\n\n    if( id_min >= 0 )\n    {\n        hasHit = true;\n        hitPos = ray.origin + t_min * ray.direction;\n        hitNormal = normalize( hitPos - spheres[id_min].center );\n        k_rg = spheres[id_min].k_rg;\n    }\n\n    return k_rg;\n}\n\nvoid main()\n{\n    vec3 color = vec3(0.0);\n    vec3 hitPos = vec3(0.0);\n    vec3 hitNormal = vec3(0.0);\n    vec3 k_rg = vec3(0.0);\n    bool hasHit = false;\n\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ray_dir = normalize( vec3( uv.x, uv.y, 1.0 ) );\n    Ray_t ray = Ray_t( u_cameraPos, ray_dir );\n\n    color = CastRay( ray, hasHit, hitPos, hitNormal, k_rg );\n\n    if( hasHit )\n    {\n        color = k_rg;\n    }\n\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat", "\n    // the color of the atmosphere\n    vec3 color = vec3(0.0);\n\n    // the distance the ray has traveled\n    float dist = 0.0;\n\n    // the distance the light ray has traveled\n    float dist_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i = 0.0;\n\n    // the distance the light ray has traveled along the primary ray\n    float dist_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l_i_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l_i_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l_i_l_i_l = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i_l_i_l_i_l_i_l_i_l_i = 0.0;\n\n    // the distance the ray has traveled along the primary ray\n    float dist_i", "\n    float sun_intensity = max(dot(light_dir, surface_normal), 0.0);\n    vec3 sun_col = vec3(1.0, 0.9, 0.8) * sun_intensity;\n\n    float sky_intensity = max(dot(sample_pos, surface_normal), 0.0);\n    vec3 sky_col = vec3(0.5, 0.6, 1.0) * sky_intensity;\n\n    return sun_col + sky_col + background_col;\n}\n\nvoid main() {\n    vec3 surface_normal = normalize(v_normal);\n    vec3 light_dir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 background_col = vec3(0.0, 0.0, 0.0);\n\n    vec3 sample_pos = v_pos;\n    vec3 col = skylight(sample_pos, surface_normal, light_dir, background_col);\n\n    out_color = vec4(col, 1.0);\n}\n", "\n    vec3 color = vec3(0.0);\n    float dist = -1.0;\n    float t = 0.0;\n    for (int i = 0; i < NUM_OBJECTS; i++) {\n        float d = scene_distance(pos + dir * t);\n        if (d < EPSILON) {\n            vec3 p = pos + dir * t;\n            vec3 n = scene_normal(p);\n            vec3 c = scene_color(p);\n            color = c * max(dot(n, light_dir), 0.0);\n            dist = t;\n            break;\n        }\n        t += d;\n    }\n    if (dist < 0.0) {\n        return vec4(0.0);\n    }\n    return vec4(color, dist);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 pos = u_camera_pos;\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 light_dir = normalize(vec3(1.0, 1.0, 1.0));\n    vec4 result = render_scene(pos, dir, light_dir);\n    gl_FragColor = vec4(result.rgb, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float d = abs(a - 0.5);\n    float s = sin(d * 10.0 + t);\n    float f = smoothstep(0.0, 0.01, s);\n    col = vec3(f);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - sr * sr;\n    float b2_ac = b * b - c;\n    if (b2_ac > 0.0) {\n        float t = -b - sqrt(b2_ac);\n        if (t > 0.0) {\n            return t;\n        }\n    }\n    return -1.0;\n}\n\nvec", "\n\tvec3 rayPos = cameraPos;\n\tvec3 rayDir = cameraRayDir;\n\tvec3 rayStep = rayDir * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA = rayStep * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA2 = rayStepAA * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA3 = rayStepAA2 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA4 = rayStepAA3 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA5 = rayStepAA4 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA6 = rayStepAA5 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA7 = rayStepAA6 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA8 = rayStepAA7 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA9 = rayStepAA8 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA10 = rayStepAA9 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA11 = rayStepAA10 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA12 = rayStepAA11 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA13 = rayStepAA12 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA14 = rayStepAA13 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA15 = rayStepAA14 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA16 = rayStepAA15 * (1.0 / float(AA_SAMPLES));\n\tvec3 rayStepAA17 = rayStepAA16 * (1.0 / float(AA_S", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float t = intersect_sphere(ray_origin, ray_direction);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 intersection_point = ray_origin + ray_direction * t;\n    vec3 normal = normalize(intersection_point - sphere_center);\n    return normal;\n}\n\nvoid main() {\n    vec3 ray_origin = vec3(0.0, 0.0, 0.0);\n    vec3 ray_target = vec3(0.0, 0.0, 1.0);\n    vec3 normal = sample_ray(ray_origin, ray_target);\n    gl_FragColor = vec4(normal, 1.0);\n}\n", "\n    float t = iTime;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 m = mat2(c,s,-s,c);\n    p *= m;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.0/1.0;\n    p *= 1.", "\n    float d = sdBox(p, vec3(1.0));\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 1.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 2.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 3.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 4.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 5.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 6.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 7.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 8.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 9.0), vec3(1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 10.0), vec3(1.0)), 0.1);\n   ", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    vec3 w = vec3( 0.0, 1.0, 0.0 );\n    vec3 u = vec3( 0.0, 0.0, 1.0 );\n    vec3 v = cross( w, u );\n\n    vec3 N = vec3( 0.0, 0.0, 1.0 );\n\n    float k0 = dot( N, hash33( Pi ) );\n    float k1 = dot( N, hash33( Pi + u ) );\n    float k2 = dot( N, hash33( Pi + u + v ) );\n    float k3 = dot( N, hash33( Pi + v ) );\n\n    vec2 Pf_01 = Pf.xy * Pf.yz;\n\n    float k4 = dot( N, hash33( Pi + w ) );\n    float k5 = dot( N, hash33( Pi + w + u ) );\n    float k6 = dot( N, hash33( Pi + w + u + v ) );\n    float k7 = dot( N, hash33( Pi + w + v ) );\n\n    float k8 = dot( N, hash33( Pi + 2.0 * u ) );\n    float k9 = dot( N, hash33( Pi + 2.0 * u + v ) );\n    float k10 = dot( N, hash33( Pi + 2.0 * v ) );\n\n    float k11 = dot( N, hash33( Pi + 3.0 * u ) );\n    float k12 = dot( N, hash33( Pi + 3.0 * u + v ) );\n    float k13 = dot( N, hash33( Pi + 3.0 * v ) );\n\n    float k14 = dot( N, hash33( Pi + 4.0 * u ) );\n    float k15 = dot( N, hash33( Pi + 4.0 * u + v ) );\n    float k16 = dot( N, hash", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.0-2.0*f);\n    return mix( bnoise(i), bnoise(i+1.0), u);\n}\n\nfloat", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    float r = length(q.xz);\n    float a = atan(q.x, q.z);\n    float phi = acos(q.y / r);\n    float theta = atan(r, q.y);\n    float s = sin(phi);\n    float c = cos(phi);\n    float z = (r * s + c * tan(theta)) / r;\n    float w = (r * c - s * tan(theta)) / r;\n    float v = (1.0 - z * z) / (w * w);\n    float b = (2.0 * z * w) / (w * w + z * z);\n    float h = b * b + 1.0 - v;\n    float g = sqrt(max(h, 0.0));\n    float l = g - b;\n    float m = max(l, 0.0);\n    float n = (1.0 - g) / (g + b);\n    float j = sqrt(max(n, 0.0));\n    float k = j - n;\n    float f = max(k, 0.0);\n    float x = (m * sin(a) - f * cos(a)) / r;\n    float y = (m * cos(a) + f * sin(a)) / r;\n    float u = atan(y, x);\n    float t = (u - a) / (2.0 * PI);\n    float e = mod(t, 1.0);\n    float o = e < 0.0? e + 1.0 : e;\n    float i = o < 0.5? o * o : 1.0 - pow(1.0 - o, 2.0);\n    float h2 = r - 1.0;\n    float g2 = r + 1.0;\n    float j2 = r * r;\n    float k2 = j2 * j2;\n    float l2 = k2 * k2;\n    float m2 = l2 * l2;\n    float n2", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    float r = length(q.xz);\n    float a = atan(q.x, q.z);\n    float phi = acos(q.y / r);\n    float theta = atan(r, q.y);\n    float s = sin(phi);\n    float c = cos(phi);\n    float z = (r * s + c * tan(theta)) / r;\n    float w = (r * c - s * tan(theta)) / r;\n    float v = (1.0 - z * z) / (w * w);\n    float b = (2.0 * z * w) / (w * w + z * z);\n    float h = b * b + 1.0 - v;\n    float g = sqrt(max(h, 0.0));\n    float l = g - b;\n    float m = max(l, 0.0);\n    float n = (1.0 - g) / (g + b);\n    float j = sqrt(max(n, 0.0));\n    float k = j - n;\n    float f = max(k, 0.0);\n    float x = (m * sin(a) - f * cos(a)) / r;\n    float y = (m * cos(a) + f * sin(a)) / r;\n    float u = atan(y, x);\n    float t = (u - a) / (2.0 * PI);\n    float e = mod(t, 1.0);\n    float o = e < 0.0? e + 1.0 : e;\n    float i = o < 0.5? o * o : 1.0 - pow(1.0 - o, 2.0);\n    float h2 = r - 1.0;\n    float g2 = r + 1.0;\n    float j2 = r * r;\n    float k2 = j2 * j2;\n    float l2 = k2 * k2;\n    float m2 = l2 * l2;\n    float n2", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float h = r*cos(a);\n    float s = r*sin(a);\n    float v = r;\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    float h = getHex(p);\n    vec3 col = vec3(h,h,h);\n    fragColor = vec4(col,1.0);\n}", "\n    float x = ix;\n    float y = iy;\n    float z = 0.0;\n    float w = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float ww = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float z1 = 0.0;\n    float w1 = 0.0;\n    float a1 = 0.0;\n    float b1 = 0.0;\n    float c1 = 0.0;\n    float d1 = 0.0;\n    float e1 = 0.0;\n    float f1 = 0.0;\n    float g1 = 0.0;\n    float h1 = 0.0;\n    float k1 = 0.0;\n    float l1 = 0.0;\n    float m1 = 0.0;\n    float n1 = 0.0;\n    float o1 = 0.0;\n    float p1 = 0.0;\n    float q1 = 0.0;\n    float r1 = 0.0;\n    float s1 = 0.0;\n    float t1 = 0.0;\n    float u1 = 0.0;\n    float v1 = 0.0;\n    float ww1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z2 = 0.0;\n    float w2 = 0", "\n    vec3 col = vec3(0.0);\n    float d = sdBox(p, vec3(1.0));\n    if (d < 0.0)\n    {\n        col = vec3(1.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = sdBox(p, vec3(1.0));\n        if (d < 0.001)\n        {\n            col = getColor(p);\n            break;\n        }\n        t += d;\n    }\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n  return p * p * p * p;\n}\n\nfloat", "\n    return vec2(atan(z.y, z.x), length(z));\n}\n\nvec", "\n\treturn vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n    float d = 0.0;\n    for (int i = 0; i < 3; i++) {\n        float n = dot(p, g3[i]);\n        vec3 r = p - n * g3[i];\n        d += -n + dot(r, g3[i]);\n    }\n    return d;\n}\n\nfloat", "\n    float f;\n    f  = 0.5000*noise( p, vec3(10.0, 10.0, 10.0) ); p = p*2.02;\n    f += 0.2500*noise( p, vec3(20.0, 20.0, 20.0) ); p = p*2.03;\n    f += 0.1250*noise( p, vec3(40.0, 40.0, 40.0) ); p = p*2.01;\n    f += 0.0625*noise( p, vec3(80.0, 80.0, 80.0) ); p = p*2.04;\n    f += 0.03125*noise( p, vec3(160.0, 160.0, 160.0) );\n    return f;\n}\n\nfloat", "\n  float d = length( p ) - 1.0;\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  vec3 ro = vec3( 0.0, 0.0, 0.0 );\n  vec3 rd = normalize( vec3( uv, 1.0 ) );\n  float t = 0.0;\n  float d = 0.0;\n  for( int i = 0; i < 100; i++ ) {\n    d = map( ro + rd * t );\n    t += d;\n  }\n  vec3 col = vec3( 1.0, 0.0, 0.0 );\n  if( d < 0.001 ) {\n    col = vec3( 0.0, 1.0, 0.0 );\n  }\n  fragColor = vec4( col, 1.0 );\n}", "\n    float d = length(rp);\n    float a = atan(rp.y, rp.x);\n    float s = sin(a*10.0);\n    float c = cos(a*10.0);\n    float r = d*s;\n    float g = d*c;\n    float b = d*d;\n    return r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*", "\n    return 1.0 - clamp((end - d) / (end - start), 0.0, 1.0);\n}\n\nvec", "\n    vec2 q = p;\n    q.x = fract(q.x * 0.5) * 2.0 - 1.0;\n    q.y = fract(q.y * 0.5) * 2.0 - 1.0;\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float h = r * 0.57735027;\n    float t = h * 3.0;\n    float s = floor(t);\n    t = fract(t);\n    float u = t * t * (3.0 - 2.0 * t);\n    vec4 c = vec4(a, s, t, u);\n    return c;\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0, 1.0, 1.0));\n    d = opS(d, sdBox(p + vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0)));\n    d = opS(d, sdBox(p + vec3(0.0, 0.0, -1.0), vec3(1.0, 1.0, 1.0)));\n    d = opS(d, sdBox(p + vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0)));\n    d = opS(d, sdBox(p + vec3(0.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0)));\n    d = opS(d, sdBox(p + vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)));\n    d = opS(d, sdBox(p + vec3(-1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0)));\n    return vec2(d, 1.0);\n}\n\nvec", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0.0);\n\t\n\tcol.r = uv.x;\n\tcol.g = uv.y;\n\tcol.b = 0.5;\n\t\n\tfragColor = vec4(col, 1.0);\n}", "\n    float r = a/b;\n    float x = pc.x;\n    float y = pc.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float x4 = x2*x2;\n    float y4 = y2*y2;\n    float x6 = x4*x2;\n    float y6 = y4*y2;\n    float x8 = x6*x2;\n    float y8 = y6*y2;\n    float x10 = x8*x2;\n    float y10 = y8*y2;\n    float x12 = x10*x2;\n    float y12 = y10*y2;\n    float x14 = x12*x2;\n    float y14 = y12*y2;\n    float x16 = x14*x2;\n    float y16 = y14*y2;\n    float x18 = x16*x2;\n    float y18 = y16*y2;\n    float x20 = x18*x2;\n    float y20 = y18*y2;\n    float x22 = x20*x2;\n    float y22 = y20*y2;\n    float x24 = x22*x2;\n    float y24 = y22*y2;\n    float x26 = x24*x2;\n    float y26 = y24*y2;\n    float x28 = x26*x2;\n    float y28 = y26*y2;\n    float x30 = x28*x2;\n    float y30 = y28*y2;\n    float x32 = x30*x2;\n    float y32 = y30*y2;\n    float x34 = x32*x2;\n    float y34 = y32*y2;\n    float x36 = x34*x2;\n    float y36 = y34*y2;\n    float", "\n    return smoothstep(pct-0.02, pct, st.y) - smoothstep(pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    color = vec3(st.x,st.y,0.0);\n    color = (1.0-st.x) * color + st.x * vec3(0.0,0.33,0.66);\n    color = (1.0-st.y) * color + st.y * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.x) * color + st.x * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.y) * color + st.y * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.x) * color + st.x * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.y) * color + st.y * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.x) * color + st.x * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.y) * color + st.y * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.x) * color + st.x * vec3(0.0,0.33,0.66);\n    color = vec3(1.0-st.y) * color + st.y * vec3(0.0", "\n    vec3 domain = vec3(0.0);\n    domain.x = (float(gl_FragCoord.x) / float(u_resolution.x)) * 2.0 - 1.0;\n    domain.y = (float(gl_FragCoord.y) / float(u_resolution.y)) * 2.0 - 1.0;\n    domain.z = (float(gl_FragCoord.z) / float(u_resolution.z)) * 2.0 - 1.0;\n    return domain;\n}\n\nvoid main(){\n    vec3 domain = initDomain();\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float eps = 0.001;\n    float k = 0.0;\n    float kmax = 100.0;\n    float kmin = 0.001;\n    float kstep = 0.001;\n    float kmax2 = kmax * kmax;\n    float kmin2 = kmin * kmin;\n    float kstep2 = kstep * kstep;\n    float k2 = 0.0;\n    float k2max = kmax2 * kmax2;\n    float k2min = kmin2 * kmin2;\n    float k2step = kstep2 * kstep2;\n    float k2step2 = k2step * k2step;\n    float k2step3 = k2step2 * k2step;\n    float k2step4 = k2step3 * k2step;\n    float k2step5 = k2step4 * k2step;\n    float k2step6 = k2step5 * k2step;\n    float k2step7 = k2step6 * k2step;\n    float k2step8 = k2step7 * k2step;\n    float k2step9 = k2step8 * k2step;\n    float k2step10 = k2step9 * k2step;", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = a - circ.z;\n    float s = sin(d);\n    float c = cos(d);\n    float r2 = r * circ.x;\n    float a2 = a * circ.y;\n    float s2 = sin(a2);\n    float c2 = cos(a2);\n    return vec2(r2 * c - r * s2, r2 * s + r * c2);\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec2 p2 = transform(p, vec3(1.0, 1.0, 0.0));\n    vec2 p3 = transform(p2, vec3(1.0, 1.0, 0.0));\n    vec2 p4 = transform(p3, vec3(1.0, 1.0, 0.0));\n    vec2 p5 = transform(p4, vec3(1.0, 1.0, 0.0));\n    vec2 p6 = transform(p5, vec3(1.0, 1.0, 0.0));\n    vec2 p7 = transform(p6, vec3(1.0, 1.0, 0.0));\n    vec2 p8 = transform(p7, vec3(1.0, 1.0, 0.0));\n    vec2 p9 = transform(p8, vec3(1.0, 1.0, 0.0));\n    vec2 p10 = transform(p9, vec3(1.0, 1.0, 0.0));\n    vec2 p11 = transform(p10, vec3(1.0, 1.0, 0.0));\n    vec2 p12 = transform(p11, vec3(1.0, 1.0, 0", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 normal = normalize(march);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    float diffuse = max(dot(normal, light), 0.0);\n    color += diffuse * vec3(1.0, 1.0, 1.0);\n    return color;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec3 march = marching(uv);\n    vec3 color = shade(march);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "  // Input pixel coordinates (x, y)\n  // Set the background color to black\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n  // Set the pixel color to white\n  fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}", "\n    return vec3(hash, hash, hash);\n}\n\nfloat", "\n    return bccNoise_PlaneFirst(X, 0.0);\n}\n\nvec", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    return d;\n}\n\nvec", "\n\tvec3 rayDir = normalize( ray.direction );\n\tvec3 rayOrigin = ray.origin;\n\tvec3 targetDir = targetPos - rayOrigin;\n\tfloat t = dot( targetDir, rayDir );\n\tvec3 closestPoint = rayOrigin + t * rayDir;\n\treturn closestPoint;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec3 q = p;\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot(iTime * 0.5);\n    q.yz *= rot(iTime * 0.5);\n    q.xz *= rot(iTime * 0.5);\n    q.xy *= rot", "\n    float t = length( targetPos - ray.origin );\n    float r = lightDiameter * 0.5;\n    float b = blur;\n    float k = r / t;\n    float d = r * r - t * t;\n    float p = k * k * d + b * b;\n    float q = k * ( -2.0 * d + b * b );\n    float D = q * q + 4.0 * p * p * p;\n    float result = 0.0;\n    if ( D > 0.0 ) {\n        float u1 = ( -q + sqrt( D ) ) / ( 2.0 * p * p );\n        float u2 = ( -q - sqrt( D ) ) / ( 2.0 * p * p );\n        float t1 = u1 * u1 * b + 2.0 * u1 * k + k * k * d;\n        float t2 = u2 * u2 * b + 2.0 * u2 * k + k * k * d;\n        if ( t1 > 0.0 ) result += exp( -0.5 * t1 * t1 );\n        if ( t2 > 0.0 ) result += exp( -0.5 * t2 * t2 );\n    }\n    return result;\n}\n\nvec", "\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q) - 1.0;\n    return vec2(d, 0.0);\n}\n\nvec", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(hash(i + dot(i, vec2(127.1, 311.7))),\n            hash(i + 1.0 + dot(i, vec2(127.1, 311.7))),\n            u),\n        mix(hash(i + vec2(127.1, 311.7)),\n            hash(i + 1.0 + vec2(127.1, 311.7)),\n            u),\n        u);\n}\n\nfloat", "\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float inverDeno = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * inverDeno;\n    float v = (dot00 * dot12 - dot01 * dot02) * inverDeno;\n\n    return (u >= 0.0) && (v >= 0.0) && (u + v <= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p1 = vec2(0.2, 0.2);\n    vec2 p2 = vec2(0.8, 0.2);\n    vec2 p3 = vec2(0.5, 0.8);\n\n    if(in_triangle(p1, p2, p3, uv)){\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }else{\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "\n    float radius = start_radius;\n    float angle = atan(uv.y, uv.x);\n    float angle_step = radians(30.0);\n    float angle_offset = mod(angle, angle_step);\n    float angle_diff = abs(angle_offset - angle_step/2.0);\n    float angle_dir = angle_offset > angle_step/2.0? 1.0 : -1.0;\n    float angle_adj = angle_diff > angle_step/4.0? angle_step/2.0 - angle_diff : 0.0;\n    float angle_final = angle + angle_dir * (angle_adj + angle_step/2.0);\n    vec2 uv_final = vec2(cos(angle_final), sin(angle_final));\n    return int(round(length(uv_final) * radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float radius = closest_hex(uv, 1.0);\n    fragColor = vec4(vec3(radius), 1.0);\n}", "\n    float r = circumradius;\n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    float d_rot = d * cos(a - rotation);\n    float d_rot_sq = d_rot * d_rot;\n    float r_sq = r * r;\n    float d_sq = d * d;\n    float d_sq_rot = d_rot_sq + r_sq;\n    float d_sq_rot_sq = d_sq_rot * d_sq_rot;\n    float d_sq_rot_sq_r_sq = d_sq_rot_sq - r_sq * d_sq;\n    float d_sq_rot_sq_r_sq_r_sq = d_sq_rot_sq_r_sq * d_sq_rot_sq_r_sq;\n    float d_sq_rot_sq_r_sq_r_sq_r_sq = d_sq_rot_sq_r_sq_r_sq * d_sq_rot_sq_r_sq_r_sq;\n    float d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq = d_sq_rot_sq_r_sq_r_sq_r_sq * d_sq_rot_sq_r_sq_r_sq_r_sq;\n    float d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq_r_sq = d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq * d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq;\n    float d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq_r_sq_r_sq = d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq_r_sq * d_sq_rot_sq_r_sq_r_sq_r_sq_r_sq_r_sq;\n    float d_sq_rot_sq_r_sq_r", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float d = abs(a - rotation);\n    float s = sin(d);\n    float c = cos(d);\n    float r2 = r * c;\n    float r3 = r2 * c;\n    float r4 = r2 * s;\n    float r5 = r3 * s;\n    float r6 = r4 * s;\n    float r7 = r5 * s;\n    float r8 = r6 * s;\n    float r9 = r7 * s;\n    float r10 = r8 * s;\n    float r11 = r9 * s;\n    float r12 = r10 * s;\n    float r13 = r11 * s;\n    float r14 = r12 * s;\n    float r15 = r13 * s;\n    float r16 = r14 * s;\n    float r17 = r15 * s;\n    float r18 = r16 * s;\n    float r19 = r17 * s;\n    float r20 = r18 * s;\n    float r21 = r19 * s;\n    float r22 = r20 * s;\n    float r23 = r21 * s;\n    float r24 = r22 * s;\n    float r25 = r23 * s;\n    float r26 = r24 * s;\n    float r27 = r25 * s;\n    float r28 = r26 * s;\n    float r29 = r27 * s;\n    float r30 = r28 * s;\n    float r31 = r29 * s;\n    float r32 = r30 * s;\n    float r33 = r31 * s;\n    float r34 = r32 * s;\n    float r35 = r33 * s;\n    float r36 = r34 * s;\n    float r37 = r35 * s;\n    float r38 = r", "\n    float r = length(U);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r12 = r6*r6;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r14*r2;\n    float r20 = r14*r4;\n    float r22 = r16*r2;\n    float r24 = r16*r4;\n    float r26 = r18*r2;\n    float r28 = r18*r4;\n    float r30 = r20*r2;\n    float r32 = r20*r4;\n    float r34 = r22*r2;\n    float r36 = r22*r4;\n    float r38 = r24*r2;\n    float r40 = r24*r4;\n    float r42 = r26*r2;\n    float r44 = r26*r4;\n    float r46 = r28*r2;\n    float r48 = r28*r4;\n    float r50 = r30*r2;\n    float r52 = r30*r4;\n    float r54 = r32*r2;\n    float r56 = r32*r4;\n    float r58 = r34*r2;\n    float r60 = r34*r4;\n    float r62 = r36*r2;\n    float r64 = r36*r4;\n    float r66 = r38*r2;\n    float r68 = r38*r4;\n    float r70 = r40*r2;\n    float r72 = r40*r4;\n    float r74 = r42*r2;\n    float r76 = r42", "\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000007);\n    }\n    return hash;\n}\n\nuint hash2(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000009);\n    }\n    return hash;\n}\n\nuint hash3(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000001);\n    }\n    return hash;\n}\n\nuint hash4(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000003);\n    }\n    return hash;\n}\n\nuint hash5(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000007);\n    }\n    return hash;\n}\n\nuint hash6(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000009);\n    }\n    return hash;\n}\n\nuint hash7(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash += (uint) (i * 1000000001);\n    }\n    return hash;\n}\n\nuint hash8(uint n)\n{\n    uint hash = 0;\n    for (uint i = 0; i < n; i++)\n    {\n        hash", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec2 res = map(ro + rd * t);\n        if (res.x < EPS) {\n            col = vec3(1.0);\n            break;\n        }\n        t += res.x;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec2 res = map(ro + rd * t);\n        if (res.x < EPS) {\n            col = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n        t += res.x;\n        if (t > 100.0) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    return normalize(vec3(\n        texture(tex, p.xy + vec2(1.0 / texSize.x, 0.0)).x - texture(tex, p.xy - vec2(1.0 / texSize.x, 0.0)).x,\n        texture(tex, p.xy + vec2(0.0, 1.0 / texSize.y)).x - texture(tex, p.xy - vec2(0.0, 1.0 / texSize.y)).x,\n        texture(tex, p.xy + vec2(1.0 / texSize.x, 1.0 / texSize.y)).x - texture(tex, p.xy - vec2(1.0 / texSize.x, 1.0 / texSize.y)).x\n    ));\n}\n\nvoid main() {\n    vec3 p = vec3(gl_FragCoord.xy / texSize, 0.0);\n    vec3 n = estimateNormal(p);\n    vec3 l = normalize(lightPos - p);\n    float diffuse = max(dot(n, l), 0.0);\n    float specular = pow(max(dot(reflect(-l, n), normalize(camPos - p)), 0.0), 16.0);\n    float ambient = 0.1;\n    vec3 color = texture(tex, p.xy).xyz * (diffuse + specular + ambient);\n    fragColor = vec4(color, 1.0);\n}\n", "\n    return fract(sin(dot(q.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat", "\n    if ( i == 0 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 1 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 2 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 3 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 4 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 5 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 6 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 7 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 8 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 9 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 10 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 11 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return true;\n    }\n    if ( i == 12 ) {\n        color = vec3( 0.0, 0.0, 0", "\n    vec3 ret;\n    p = p*2.0/ab;\n    float k0 = length(p);\n    float k1 = k0*k0/2.0;\n    float k2 = k1/k0;\n    float k3 = k2/k0;\n    ret.x = sqrt(k0)*sqrt(1.0-k3);\n    ret.y = atan(p.y,p.x);\n    ret.z = k1*(1.0-k2);\n    return ret;\n}\n\nvec", "\n    vec3 q = vec3(fract(p *.1031), fract(p *.1033), fract(p *.1037));\n    q = q*q*(3. - 2. * q);\n    return q;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    float r = 1.0;\n    float d = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 10; i++){\n        d = length(raypos) - r;\n        if(d < 0.001){\n            break;\n        }\n        t += d;\n        raypos.xyz *= (r / length(raypos));\n        raypos.w += t;\n    }\n    return t;\n}\n\nvoid main(){\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec4 raypos = vec4(ro, 0.0);\n    float t = hyperspheres(raypos);\n    vec3 col = vec3(1.0 - t);\n    gl_FragColor = vec4(col, 1.0);\n}", "\n    float c1 = cos(rotation.x);\n    float c2 = cos(rotation.y);\n    float c3 = cos(rotation.z);\n    float s1 = sin(rotation.x);\n    float s2 = sin(rotation.y);\n    float s3 = sin(rotation.z);\n    return mat3(\n        c2*c3, c2*s3, -s2,\n        c1*s3+c3*s1*s2, c1*c3-s1*s2*s3, c2*s1,\n        s1*s3-c1*c3*s2, c3*s1+c1*s2*s3, c1*c2\n    );\n}\n\nvec", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map4D(rayori + raydir * t);\n        if(d < EPSILON){\n            break;\n        }\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\nvec", "\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        d = map(rayori + raydir * t);\n        if(d < EPS){\n            return vec3(t, 0.0, 0.0);\n        }\n        t += d;\n        if(t > MAX_DIST){\n            return vec3(t, 0.0, 0.0);\n        }\n    }\n    return vec3(t, 0.0, 0.0);\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col, 1.0);\n}", "\n    float value = sin(coord.x * frequency + travelRate * time) * maxStrength;\n    return value;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    e1 = p + d;\n    e2 = p + vec2(d.y, -d.x);\n    e3 = p - d;\n    e4 = p + vec2(-d.y, d.x);\n}\n\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n    e1 = p + d;\n    e2 = p + vec2(d.y, -d.x);\n    e3 = p - d;\n    e4 = p + vec2(-d.y, d.x);\n    e5 = p + vec2(d.x, d.y);\n    e6 = p + vec2(-d.x, d.y);\n    e7 = p + vec2(-d.x, -d.y);\n    e8 = p + vec2(d.x, -d.y);\n}\n\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8, inout vec2 e9, inout vec2 e10, inout vec2 e11, inout vec2 e12, inout vec2 e13, inout vec2 e14, inout vec2 e15, inout vec2 e16) {\n    e1 = p + d;\n    e2 = p + vec2(d.y, -d.x);\n    e3 = p - d;\n    e4 = p + vec2(-d.y, d.x);\n    e5 = p + vec2(d.x, d.y);\n    e6 = p + vec", "\n    color = max(vec3(0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\nvoid main() {\n    vec3 color = texture(tex, texCoord).rgb;\n    color = filmic(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}\n", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2*h;\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y,uv.x);\n    float r = length(uv-p);\n    float f = exp(-r*r*10.0);\n    col.r = f*sin(a*10.0+d*10.0);\n    col.g = f*sin(a*10.0+d*10.0+2.094);\n    col.b = f*sin(a*10.0+d*10.0+4.188);\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec2 p = vec2(0.0);\n    float t = iGlobalTime;\n    p.x = sin(t*0.1)*0.5;\n    p.y = cos(t*0.1)*0.5;\n    col = blob(uv,p);\n    gl_FragColor = vec4(col,1.0);\n}\n", "\n    return vec3( 1.0 ) - smoothstep( falloff, falloff + 0.01, rnd );\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= u_resolution.x / u_resolution.y;\n\n    float a = atan( p.y, p.x );\n    float r = length( p );\n\n    float n = u_time * 0.1;\n\n    vec3 col = vec3( 0.0 );\n    vec3 rnd = vec3( 0.0 );\n\n    for( int i = 0; i < 3; i++ )\n    {\n        float t = n + float( i ) * 0.2;\n        float f = mod( t, 1.0 );\n        t = floor( t );\n        vec3 pulse = pulse( 0.05, hash3( vec3( f, t, 1.0 ) ) );\n        float d = length( p + vec2( sin( t ), cos( t ) ) );\n        float w = exp( -d * d * 10.0 );\n        rnd += w * pulse;\n    }\n\n    col = rnd;\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 q = vec3(fract(p *.1031), fract(p *.1033), fract(p *.1037));\n    q = q*q*(3. - 2. * q);\n    return q;\n}\n\nvec", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\nfloat", "\n    col = pow(col, vec3(0.4545));\n    col *= 0.6 + 0.4 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n    col = pow(col, vec3(1.0 / 2.2));\n    return col;\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= u_resolution.x / u_resolution.y;\n\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n\n    for (int i = 0; i < 10; i++) {\n        vec3 p3 = vec3(p, 0.0);\n        p3 = p3 + vec3(0.0, 0.0, t);\n        p3 = p3 * (1.0 + 0.5 * t);\n\n        // float rz = dot(p3, p3);\n        // float r = length(p3);\n        // float a = atan(p3.y, p3.x);\n        // float z = a + t;\n\n        // vec3 backBufferPos = vec3(r * cos(z), r * sin(z), rz);\n        // col += 0.07 * vec3(1.0, 0.3, 0.0) / rz;\n        // col += 0.07 * vec3(0.14, 0.14, 1.0) / r;\n        // col += 0.07 * vec3(0.7, 0.7, 0.7) / r * sin(3.0 * r + t);\n\n        // p3 = backBufferPos;\n\n        float rz = dot(p3, p3);\n        float r = length(p3);\n        float a = atan(p3.y, p3", "\n    p = abs(p);\n    return max(p.x, max(p.y, p.z)) - 1.0;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col.r = uv.x;\n    col.g = uv.y;\n    col.b = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(col,1.0);\n}"]}