{"generations": ["\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return 0.282095;\n}\n\n// unrolled version of the above\nfloat SH_1_0( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return -0.488603 * y;\n}\n\n// unrolled version of the above\nfloat SH_1_1( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return 0.488603 * x * z;\n}\n\n// unrolled version of the above\nfloat SH_2_0( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return 1.092548 * z * y;\n}\n\n// unrolled version of the above\nfloat SH_2_1( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return -1.092548 * x * z;\n}\n\n// unrolled version of the above\nfloat SH_2_2( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return 0.315392 * (3.0 * z * z - 1.0);\n}\n\n// unrolled version of the above\nfloat SH_3_0( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.z;\n  return -1.092548 * y * z;\n}\n\n// unrolled version of the above\nfloat SH_3_1( in vec3 s ) {\n  float x = s.x;\n  float y = s.y;\n  float z = s.", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a circle\nfloat circle( in vec2 p, in vec2 o, in float r )\n{\n    return length(p-o)-r;\n}\n\n// distance to a box\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// distance to a rounded box\nfloat roundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) - r + min(max(d.x,d.y),0.0);\n}\n\n// distance to a polygon\nfloat poly( in vec2 p, in vec2[4] pts )\n{\n    float d = dot(p-pts[0],p-pts[0]);\n    for( int i=1; i<4; i++ )\n        d = min(d,dot(p-pts[i],p-pts[i]));\n    return sqrt(d);\n}\n\n// distance to a polygon with rounded corners\nfloat roundPoly( in vec2 p, in vec2[4] pts, in float r )\n{\n    float d = dot(p-pts[0],p-pts[0]);\n    for( int i=1; i<4; i++ )\n        d = min(d,dot(p-pts[i],p-pts[i]));\n    return sqrt(d)-r;\n}\n\n// distance to a polygon with rounded corners\nfloat roundPoly( in vec2 p, in vec2[4] pts, in float r, in float t )\n{\n    float d = dot(p-pts[0],p-pts[0]);\n    for( int i=1;", "\n    return mix( v, -v, vec2( step( r, vec2( 0.0 ) ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return mix( v, -v, vec3( step( r, vec3( 0.0 ) ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return mix( v, -v, vec4( step( r, vec4( 0.0 ) ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in float r )\n{\n    return mix( v, -v, vec2( step( r, 0.0 ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in float r )\n{\n    return mix( v, -v, vec3( step( r, 0.0 ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in float r )\n{\n    return mix( v, -v, vec4( step( r, 0.0 ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in vec2 r2 )\n{\n    return mix( v, -v, vec2( step( r, r2 ) ) );\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in vec3 r", "\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec3 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec3 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec4 r )\n{\n    return mix( v, -v, float( dot( r, v ) < 0.0 ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec4 r )\n{\n    return mix( v, -", "\n    return mix( v, -r, vec2( step( r, vec2( 0.0 ) ) ) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return mix( v, r, vec2( step( vec2( 0.0 ), r ) ) );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    return mix( v, -r, vec3( step( r, vec3( 0.0 ) ) ) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return mix( v, r, vec3( step( vec3( 0.0 ), r ) ) );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    return mix( v, -r, vec4( step( r, vec4( 0.0 ) ) ) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return mix( v, r, vec4( step( vec4( 0.0 ), r ) ) );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in float r )\n{\n    return mix( v, -vec2( r ), vec2( step( r, 0.0 ) ) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in float r )\n{\n    return mix( v,", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * mix( w1, w2, h );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow( p, a, b, 0.1, 0.1 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float w = mix( w1, w2, h ) * mix( w3, w4, 1.0-h );\n    return length( pa - ba*h ) * w;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n    return sdArrow( p, a, b, w1, w2, w3, w3 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    return sdArrow( p, a, b, w1, w2, w1, w2 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w, w, w );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3, float w4, float w5, float w6 )\n{\n    vec2 pa = p -", "\n\tfloat sunDot = dot(sunDir, rayDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot3 = sunDot2 * sunDot;\n\tfloat sunDot4 = sunDot3 * sunDot;\n\tfloat sunDot5 = sunDot4 * sunDot;\n\tfloat sunDot6 = sunDot5 * sunDot;\n\tfloat sunDot7 = sunDot6 * sunDot;\n\tfloat sunDot8 = sunDot7 * sunDot;\n\tfloat sunDot9 = sunDot8 * sunDot;\n\tfloat sunDot10 = sunDot9 * sunDot;\n\tfloat sunDot11 = sunDot10 * sunDot;\n\tfloat sunDot12 = sunDot11 * sunDot;\n\tfloat sunDot13 = sunDot12 * sunDot;\n\tfloat sunDot14 = sunDot13 * sunDot;\n\tfloat sunDot15 = sunDot14 * sunDot;\n\tfloat sunDot16 = sunDot15 * sunDot;\n\tfloat sunDot17 = sunDot16 * sunDot;\n\tfloat sunDot18 = sunDot17 * sunDot;\n\tfloat sunDot19 = sunDot18 * sunDot;\n\tfloat sunDot20 = sunDot19 * sunDot;\n\tfloat sunDot21 = sunDot20 * sunDot;\n\tfloat sunDot22 = sunDot21 * sunDot;\n\tfloat sunDot23 = sunDot22 * sunDot;\n\tfloat sunDot24 = sunDot23 * sunDot;\n\tfloat sunDot25 = sunDot24 * sunDot;\n\tfloat sunDot26 = sunDot25 * sunDot;\n\tfloat sunDot27 = sunDot26 * sunDot;\n\tfloat sunDot28 = sunDot27 * sunDot;\n\t", "\n    vec4 B = p1 - p0;\n    vec4 C = p2 - p1;\n    vec4 D = p3 - p2;\n\n    vec4 A = 2.0 * B;\n    vec4 b = 3.0 * C - D - D;\n    vec4 c = D - B - B;\n\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return p1 + 0.5 * (A + b * t + c * t2 + D * t3);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension)\n{\n    vec4 B = p1 - p0;\n    vec4 C = p2 - p1;\n    vec4 D = p3 - p2;\n\n    vec4 A = 2.0 * B;\n    vec4 b = 3.0 * C - D - D;\n    vec4 c = D - B - B;\n\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return p1 + 0.5 * (A + b * t + c * t2 + D * t3);\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension, float bias)\n{\n    vec4 B = p1 - p0;\n    vec4 C = p2 - p1;\n    vec4 D = p3 - p2;\n\n    vec4 A = 2.0 * B;\n    vec4 b = 3.0 * C - D - D;\n    vec4 c = D - B - B;\n\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return p1 + 0.5 * (A + b * t + c * t2 + D * t3);\n}\n\n// This is a spline used for the", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tn += amp * sin(freq * p.x + p.y) * sin(freq * p.y + p.z) * sin(freq * p.z + p.x);\n\t\tp = p * 2.0 + vec3(nudge, nudge, nudge);\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D noise function based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// This is a 3D noise function based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat Noise3D_F(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + 0.5) / 2", "\n\tvec4 p0 = vec4(camPath[0].xyz, 1.0);\n\tvec4 p1 = vec4(camPath[1].xyz, 1.0);\n\tvec4 p2 = vec4(camPath[2].xyz, 1.0);\n\tvec4 p3 = vec4(camPath[3].xyz, 1.0);\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p2 - p0;\n\tvec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n\tvec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\treturn a + b * t + c * t2 + d * t3;\n}\n\nvec4 CamDir(float t)\n{\n\tvec4 p0 = vec4(camPath[0].xyz, 1.0);\n\tvec4 p1 = vec4(camPath[1].xyz, 1.0);\n\tvec4 p2 = vec4(camPath[2].xyz, 1.0);\n\tvec4 p3 = vec4(camPath[3].xyz, 1.0);\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p2 - p0;\n\tvec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n\tvec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\treturn b + 2.0 * c * t + 3.0 * d * t2;\n}\n\nvec4 CamUp(float t)\n{\n\tvec4 p0 = vec4(camPath[0].xyz, 1.0);\n\tvec4 p1 = vec4(camPath[1].xyz, 1", "\n    return frac(sin(u) * 1e4);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    return frac(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 uv)\n{\n    return frac(sin(dot(uv, vec3(12.9898, 78.233, 56.837))) * 43758.5453);\n}\n\nfloat Noise1d(float u)\n{\n    float fl = floor(u);\n    float fc = frac(u);\n    return mix(Hash1d(fl), Hash1d(fl + 1.0), fc);\n}\n\nfloat Noise2d(vec2 uv)\n{\n    vec2 fl = floor(uv);\n    vec2 fc = frac(uv);\n    vec2 uv00 = vec2(fl.x, fl.y);\n    vec2 uv10 = vec2(fl.x + 1.0, fl.y);\n    vec2 uv01 = vec2(fl.x, fl.y + 1.0);\n    vec2 uv11 = vec2(fl.x + 1.0, fl.y + 1.0);\n    vec2 uv_0 = mix(uv00, uv10, fc.x);\n    vec2 uv_1 = mix(uv01, uv11, fc.x);\n    return mix(Hash2d(uv_0), Hash2d(uv_1), fc.y);\n}\n\nfloat Noise3d(vec3 uv)\n{\n    vec3 fl = floor(uv);\n    vec3 fc = frac(uv);\n    vec3 uv000 = vec3(fl.x, fl.y, fl.z);\n    vec3 uv100 = vec3(fl.x + 1.0, fl.y, fl.z", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tn += amp * sin(freq * p.x + p.y + p.z);\n\t\tp = vec3(p.y - nudge * p.z, p.z + nudge * p.x, p.x);\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D noise function that I found on Shadertoy.\n// It's not as good as the spiral noise, but it's a lot faster.\nfloat Noise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// This is a 3D noise function that I found on Shadertoy.\n// It's not as good as the spiral noise, but it's a lot faster.\nfloat Noise3D2(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n", "\n    float d = 1.0;\n    float d2 = 1.0;\n    float d3 = 1.0;\n    float d4 = 1.0;\n    float d5 = 1.0;\n    float d6 = 1.0;\n    float d7 = 1.0;\n    float d8 = 1.0;\n    float d9 = 1.0;\n    float d10 = 1.0;\n    float d11 = 1.0;\n    float d12 = 1.0;\n    float d13 = 1.0;\n    float d14 = 1.0;\n    float d15 = 1.0;\n    float d16 = 1.0;\n    float d17 = 1.0;\n    float d18 = 1.0;\n    float d19 = 1.0;\n    float d20 = 1.0;\n    float d21 = 1.0;\n    float d22 = 1.0;\n    float d23 = 1.0;\n    float d24 = 1.0;\n    float d25 = 1.0;\n    float d26 = 1.0;\n    float d27 = 1.0;\n    float d28 = 1.0;\n    float d29 = 1.0;\n    float d30 = 1.0;\n    float d31 = 1.0;\n    float d32 = 1.0;\n    float d33 = 1.0;\n    float d34 = 1.0;\n    float d35 = 1.0;\n    float d36 = 1.0;\n    float d37 = 1.0;\n    float d38 = 1.0;\n    float d39 = 1.0;\n    float d40 = 1.0;\n    float d41 = 1.0;\n    float d42 = 1.0;\n    float d43 = 1.0;\n    float d44", "\n    vec3 col = vec3(0.0);\n\n    // The sun\n    col += GetSunColor(rayDir, sunDir);\n\n    // The lights\n    col += GetLightColor(rayDir, vec3(0.0, 0.0, 1.0), 0.0);\n    col += GetLightColor(rayDir, vec3(0.0, 1.0, 0.0), 0.0);\n    col += GetLightColor(rayDir, vec3(1.0, 0.0, 0.0), 0.0);\n    col += GetLightColor(rayDir, vec3(1.0, 1.0, 0.0), 0.0);\n\n    // The fade\n    col *= 1.0 - exp(-rayDir.y * 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, vec2(h,h) ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec2 smax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(a.x-b.x)/k, 0.0, 1.0 );\n    return mix( a, b, vec2(h,h) ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec3 smin( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, vec3(h,h,h) ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(a.x-b.x)/k, 0.0, ", "\n    vec3 m = dirVecPLZNormalizeMeFirst;\n    vec3 s = pos - spherePos;\n    float b = dot(s, m);\n    float c = dot(s, s) - rad * rad;\n    float d = b * b - c;\n    if (d < 0.0)\n        return -1.0;\n    return -b - sqrt(d);\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat CapsuleIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 capsuleStart, vec3 capsuleEnd, float rad)\n{\n    vec3 m = dirVecPLZNormalizeMeFirst;\n    vec3 s = pos - capsuleStart;\n    vec3 e = pos - capsuleEnd;\n    vec3 v = capsuleEnd - capsuleStart;\n    float b = dot(s, m) * 2.0;\n    float c = dot(s, s) - dot(e, e);\n    float d = b * b - 4.0 * c;\n    if (d < 0.0)\n        return -1.0;\n    d = sqrt(d);\n    float t1 = (-b - d) * 0.5;\n    float t2 = (-b + d) * 0.5;\n    float t = t1;\n    if (t < 0.0)\n        t = t2;\n    if (t < 0.0)\n        return -1.0;\n    vec3 p = pos + t * m;\n    vec3 q = p - capsuleStart;\n    float w = dot(q, v);\n    if (w < 0.0)\n        return t;\n    if (w > dot(v, v))\n        return t2;\n    return t1;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat CylinderIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 cylinderStart, vec3 cylinderEnd, float rad)\n{\n    vec3 m = dirVecPLZ", "\n    vec2 d = vec2(length(p.xy) - 1.0, p.z);\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p, out vec3 normal)\n{\n    vec2 d = vec2(length(p.xy) - 1.0, p.z);\n    normal = vec3(p.xy, 0.0);\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p, out vec3 normal, out vec3 color)\n{\n    vec2 d = vec2(length(p.xy) - 1.0, p.z);\n    normal = vec3(p.xy, 0.0);\n    color = vec3(0.0, 0.0, 1.0);\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p, out vec3 normal, out vec3 color, out float specular)\n{\n    vec2 d = vec2(length(p.xy) - 1.0, p.z);\n    normal = vec3(p.xy, 0.0);\n    color = vec3(0.0, 0.0, 1.0);\n    specular = 0.0;\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p, out vec3 normal, out vec3 color, out float specular, out float gloss)\n{\n    vec2 d = vec2(length(p.xy) - 1.0, p.z);\n    normal = vec3(p.xy, 0.0);\n    color = vec3(0.0, 0.0, 1.0);\n    specular = 0.0;\n    gloss = 0.0;\n    return d;\n}\n\n// Calculate the distance field that defines the object.\nvec2 DistanceToObject(vec3 p, out vec3 normal, out vec3 color, out float", "\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD15(float t)\n{\n    return vec3(t, 0.", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (jerk)\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (snap)\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (crackle)\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (pop)\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (buzz)\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (static)\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (hum)\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (blip)\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (warble)\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (squeak)\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// curve derivative (woosh)\nvec3 map", "\n    float x = t;\n    float y = 0.0;\n    float z = 0.0;\n    float r = 1.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float s = 0.0;\n    float tt = t;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float ss = 0.0;\n    float ttt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww = 0.0;\n    float aaa = 0.0;\n    float bbb = 0.0;\n    float c", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    return vec2( dot( ap, ap ) - t * dot( ab, ab ), t );\n}\n\n// signed squared distance between point and segment\nvec2 ssqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 usqd = usqdPointSegment( p, a, b );\n    return vec2( usqd.x, usqd.y * sign( usqd.y ) );\n}\n\n// signed distance between point and segment\nfloat ssdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    return sqrt( ssqdPointSegment( p, a, b ).x );\n}\n\n// signed distance between point and triangle\nfloat ssdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 cb = c - b;\n    vec3 pb = p - b;\n    vec3 ac = a - c;\n    vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    float d = dot( nor, pa );\n    float e = dot( nor, pb );\n    float f = dot( nor, pc );\n\n    if( d <= 0.0 && e <= 0.0 ) return min( 0.0, min( d, e ) );\n    if( f <= 0.0 && e >= 0.0 ) return min( 0.0, min( f, e ) );\n    if( d >= 0.0 && f >= 0.0 ) return max( 0.0, max( d, f ) );\n\n    vec3 nor1 = cross( ba, nor );\n    vec3 nor2 = cross( cb, nor );\n    vec3 nor3", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    vec3 abPerp = cross( ab, d );\n    vec3 aoPerp = cross( abPerp, ab );\n    float t = dot( aoPerp, abPerp ) / dot( abPerp, abPerp );\n    return vec2( dot( aoPerp, aoPerp ), t );\n}\n\n// signed squared distance between ray and segment\nvec2 ssqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    return vec2( usqd.x, usqd.y < 0.0? -usqd.y : usqd.y );\n}\n\n// signed distance between ray and segment\nfloat ssdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    return sqrt( ssqdLineSegment( a, b, o, d ).x );\n}\n\n// signed distance between ray and segment\nfloat ssdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out float t )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    t = usqd.y;\n    return sqrt( usqd.x );\n}\n\n// signed distance between ray and segment\nfloat ssdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out vec3 p )\n{\n    float t = 0.0;\n    float ssd = ssdLineSegment( a, b, o, d, t );\n    p = o + t * d;\n    return ssd;\n}\n\n// signed distance between ray and segment\nfloat ssdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d, out vec3 p, out float t )\n{\n    vec2 usqd = usqdLineSegment( a, b, o, d );\n    t = usqd.y;\n    p", "\n    vec2 q = abs(p)-b+r.zw;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.x;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n    vec3 q = abs(p)-b+r.xyz;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.w;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b+vec2(r);\n    return length(max(q,0.0)) - r;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p)-b+vec3(r);\n    return length(max(q,0.0)) - r;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in", "\n\tfloat sunDot = dot(sunDir, rayDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot3 = sunDot2 * sunDot;\n\tfloat sunDot4 = sunDot3 * sunDot;\n\tfloat sunDot5 = sunDot4 * sunDot;\n\tfloat sunDot6 = sunDot5 * sunDot;\n\tfloat sunDot7 = sunDot6 * sunDot;\n\tfloat sunDot8 = sunDot7 * sunDot;\n\tfloat sunDot9 = sunDot8 * sunDot;\n\tfloat sunDot10 = sunDot9 * sunDot;\n\tfloat sunDot11 = sunDot10 * sunDot;\n\tfloat sunDot12 = sunDot11 * sunDot;\n\tfloat sunDot13 = sunDot12 * sunDot;\n\tfloat sunDot14 = sunDot13 * sunDot;\n\tfloat sunDot15 = sunDot14 * sunDot;\n\tfloat sunDot16 = sunDot15 * sunDot;\n\tfloat sunDot17 = sunDot16 * sunDot;\n\tfloat sunDot18 = sunDot17 * sunDot;\n\tfloat sunDot19 = sunDot18 * sunDot;\n\tfloat sunDot20 = sunDot19 * sunDot;\n\tfloat sunDot21 = sunDot20 * sunDot;\n\tfloat sunDot22 = sunDot21 * sunDot;\n\tfloat sunDot23 = sunDot22 * sunDot;\n\tfloat sunDot24 = sunDot23 * sunDot;\n\tfloat sunDot25 = sunDot24 * sunDot;\n\tfloat sunDot26 = sunDot25 * sunDot;\n\tfloat sunDot27 = sunDot26 * sunDot;\n\tfloat sunDot28 = sunDot27 * sunDot;\n\t", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    return mat3( uu, vv, ww );\n}\n\n// This is the main function that calculates the rays that we will use to trace\n// the scene.\nvec3 calculateEyeRay( in vec2 fragCoord, in vec3 ro, in vec3 ta, in float roll )\n{\n    // Calculate the transformation matrix\n    mat3 m = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    \n    // Calculate the UV coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Transform the UV coordinates into a ray\n    vec3 rd = m * normalize( vec3( uv, 2.0 ) );\n    \n    return rd;\n}\n\n// This is the main function that calculates the rays that we will use to trace\n// the scene.\nvec3 calculateEyeRay( in vec2 fragCoord, in vec3 ro, in vec3 ta, in float roll, in vec2 uv )\n{\n    // Calculate the transformation matrix\n    mat3 m = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    \n    // Transform the UV coordinates into a ray\n    vec3 rd = m * normalize( vec3( uv, 2.0 ) );\n    \n    return rd;\n}\n\n// This is the main function that calculates the rays that we will use to trace\n// the scene.\nvec3 calculateEyeRay( in vec2 fragCoord, in vec3 ro, in vec3 ta, in float roll, in vec2 uv, in float aspect )\n{\n    // Calculate the transformation matrix\n    mat3 m = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    \n", "\n\n  vec2 balloon = vec2( 10000.0, 0.0 );\n\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale = vec3( 0.5, 0.5, 0.5 );\n  vec3 balloonRotation = vec3( 0.0, 0.0, 0.0 );\n\n  vec3 balloonPosition2 = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale2 = vec3( 0.5, 0.5, 0.5 );\n  vec3 balloonRotation2 = vec3( 0.0, 0.0, 0.0 );\n\n  vec3 balloonPosition3 = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale3 = vec3( 0.5, 0.5, 0.5 );\n  vec3 balloonRotation3 = vec3( 0.0, 0.0, 0.0 );\n\n  vec3 balloonPosition4 = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale4 = vec3( 0.5, 0.5, 0.5 );\n  vec3 balloonRotation4 = vec3( 0.0, 0.0, 0.0 );\n\n  vec3 balloonPosition5 = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale5 = vec3( 0.5, 0.5, 0.5 );\n  vec3 balloonRotation5 = vec3( 0.0, 0.0, 0.0 );\n\n  vec3 balloonPosition6 = vec3( 0.0, 0.0, 0.0 );\n  vec3 balloonScale6 = vec3( 0.5, 0.5, 0.5 );\n ", "\n\n  // get the distance to each thing\n  float distanceToThing1 = distance( thing1, vec2( 0.0 ) );\n  float distanceToThing2 = distance( thing2, vec2( 0.0 ) );\n\n  // if the distance to thing1 is less than the distance to thing2\n  if( distanceToThing1 < distanceToThing2 ){\n\n    // return thing1\n    return thing1;\n\n  }\n\n  // otherwise\n  else{\n\n    // return thing2\n    return thing2;\n\n  }\n\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec3 whichThingAmICloserTo( vec3 thing1, vec3 thing2 ){\n\n  // get the distance to each thing\n  float distanceToThing1 = distance( thing1, vec3( 0.0 ) );\n  float distanceToThing2 = distance( thing2, vec3( 0.0 ) );\n\n  // if the distance to thing1 is less than the distance to thing2\n  if( distanceToThing1 < distanceToThing2 ){\n\n    // return thing1\n    return thing1;\n\n  }\n\n  // otherwise\n  else{\n\n    // return thing2\n    return thing2;\n\n  }\n\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec4 whichThingAmICloserTo( vec4 thing1, vec4 thing2 ){\n\n  // get the distance to each thing\n  float distanceToThing1 = distance( thing1, vec4( 0.0 ) );\n  float distanceToThing2 = distance( thing2, vec4( 0.0 ) );\n\n  // if the distance to thing1 is less than the distance to thing2\n  if( distanceToThing1 < distanceToThing", "\n\n  // The distance to the closest object\n  float distanceToClosestObject = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObject = 100000.0;\n\n  // The object that is closest to the ray\n  int closestObject = -1;\n\n  // The object that is second closest to the ray\n  int secondClosestObject = -1;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectSquared = 100000.0;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared2 = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectSquared2 = 100000.0;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared3 = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectSquared3 = 100000.0;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared4 = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectSquared4 = 100000.0;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared5 = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectSquared5 = 100000.0;\n\n  // The distance to the closest object\n  float distanceToClosestObjectSquared6 = 100000.0;\n\n  // The distance to the second closest object\n  float distanceToSecondClosestObjectS", "\n\n    // We are going to use the gradient of the SDF to find the normal\n    // of the surface. \n    // The gradient is the change in the SDF in each direction.\n    // So, we are going to take the SDF at the position of the hit,\n    // and then take the SDF at the position of the hit + a small amount\n    // in each direction. \n    // Then, we are going to subtract the SDF at the position of the hit\n    // from the SDF at the position of the hit + a small amount in each direction.\n    // This will give us the change in the SDF in each direction.\n    // Then, we are going to normalize this vector to get the normal of the surface.\n\n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    // in each direction. \n    // We are going to use the SDF at the position of the hit + a small amount\n    //", "\n    return vec3(0.0);\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color){\n    return color;\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color, vec3 backgroundColor){\n    return color + backgroundColor;\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color, vec3 backgroundColor, float backgroundAlpha){\n    return mix(color, backgroundColor, backgroundAlpha);\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color, vec3 backgroundColor, float backgroundAlpha, float backgroundAlphaFalloff){\n    return mix(color, backgroundColor, backgroundAlpha * backgroundAlphaFalloff);\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color, vec3 backgroundColor, float backgroundAlpha, float backgroundAlphaFalloff, float backgroundAlphaFalloffPower){\n    return mix(color, backgroundColor, pow(backgroundAlpha * backgroundAlphaFalloff, backgroundAlphaFalloffPower));\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(vec3 color, vec3 backgroundColor, float backgroundAlpha, float backgroundAlphaFalloff, float backgroundAlphaFalloffPower, float backgroundAlphaFalloffPowerFactor){\n    return mix(color, backgroundColor, pow(backgroundAlpha * backgroundAlphaFalloff, backgroundAlphaFalloffPower * backgroundAlphaFalloffPowerFactor));\n}\n\n// the background color is the only thing that\n// is not affected by the lighting.\n// so we can just return it here.\nvec3 doBackgroundColor(", "\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    vec3 color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n    // and mapping it to color, to show you just how cool\n    // normals can be!\n    color = normalOfSurface;\n\n    // We are using the normal of the surface,\n   ", "\n\n  // We'll use this to decide\n  // if we're in the sky or not.\n  float skyFactor = 1.0 - rayHitInfo.y;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterFactor = 1.0 - rayHitInfo.x;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterDepthFactor = 1.0 - rayHitInfo.z;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterNormalFactor = 1.0 - rayHitInfo.w;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterReflectionFactor = 1.0 - rayHitInfo.y;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionFactor = 1.0 - rayHitInfo.z;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionDepthFactor = 1.0 - rayHitInfo.w;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionNormalFactor = 1.0 - rayHitInfo.x;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionReflectionFactor = 1.0 - rayHitInfo.y;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionRefractionFactor = 1.0 - rayHitInfo.z;\n\n  // We'll use this to decide\n  // if we're in the water or not.\n  float waterRefractionRefractionDepthFactor = 1.0 - rayHitInfo.w;\n\n  // We'll use this to decide", "\n  return x / ((1.0 - b) * x + b);\n}\n\n// https://www.desmos.com/calculator/gxvvxw2kxz\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b, float c) {\n  return x / ((1.0 - b) * x + b * c);\n}\n\n// https://www.desmos.com/calculator/gxvvxw2kxz\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec2 bias(vec2 x, float b) {\n  return x / ((1.0 - b) * x + b);\n}\n\n// https://www.desmos.com/calculator/gxvvxw2kxz\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec2 bias(vec2 x, float b, float c) {\n  return x / ((1.0 - b) * x + b * c);\n}\n\n// https://www.desmos.com/calculator/gxvvxw2kxz\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec3 bias(vec3 x, float b) {\n  return x / ((1.0 - b) * x + b);\n}\n\n// https://www.desmos.com/calculator/gx", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 56.837))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 56.837, 99.123))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(int p){\n    return fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(uint p){\n    return fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(bool p){\n    return fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(bvec2 p){\n    return fract(sin(float(p)) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))* 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 56.837)))* 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 56.837, 12.9898)))* 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p)* 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(int p){\n    return fract(sin(float(p))* 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(ivec2 p){\n    return fract(sin(dot(p, ivec2(12, 78)))*", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input bb --> is the bounding box\n// pretty simple, just compare point to bounding box\nfloat sdBox(vec3 p, vec3 bb)\n{\n    vec3 d = abs(p) - bb;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a torus\n// input t --> is the torus radius\n// input r --> is the radius of the tube\n// pretty simple, just compare point to torus\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a capsule\n// input a --> is the start point of the capsule\n// input b --> is the end point of the capsule\n// input r --> is the radius of the capsule\n// pretty simple, just compare point to capsule\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input a --> is the start point of the cylinder\n// input b --> is the end point of the cylinder\n// input r --> is the radius of the cylinder\n// pretty simple, just compare point to cylinder\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) -", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\treturn max(length(p.xz) - c.x, abs(p.y) - c.y);\n}\n\n// ~~~~~~~ signed distance function for a capsule\n// input c --> capsule specs where:\n// \tc.x = capsule radius\n//\tc.y = capsule height\nfloat sdCapsule(vec3 p, vec2 c)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - c;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input c --> cone specs where:\n// \tc.x = cone radius\n//\tc.y = cone height\nfloat sdCone(vec3 p, vec2 c)\n{\n\t// c.x = sin(coneAngle);\n\t// c.y = cos(coneAngle);", "\n    float k = 0.1;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.1;\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (power version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.1;\n    float h = pow( clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 ), 2.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (power version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.1;\n    float h = pow( clamp( 0.", "\n    return min(d1, d2);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float n)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow(h,n) ) + k*pow(h,n-1.0)*(1.0-pow(h,n));\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float n, float p)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, pow(h,n) ) + k*pow(h,n-1.0)*(1.0-pow(h,n))*p;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k", "\n    float c = cos(yaw);\n    float s = sin(yaw);\n    float sc = s * c;\n    float ss = s * s;\n    float cc = c * c;\n\n    vec2 q = vec2(\n        (cc + ss) * p.x + (sc - ss) * p.y,\n        (sc + ss) * p.x + (cc - ss) * p.y\n    );\n\n    return vec3(q.x, q.y, p.z);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t )\n{\n    float c = cos(t);\n    float s = sin(t);\n    float sc = s * c;\n    float ss = s * s;\n    float cc = c * c;\n\n    vec2 q = vec2(\n        (cc + ss) * p.x + (sc - ss) * p.y,\n        (sc + ss) * p.x + (cc - ss) * p.y\n    );\n\n    return vec3(q.x, q.y, p.z);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n    float c = cos(yaw);\n    float s = sin(yaw);\n    float sc = s * c;\n    float ss = s * s;\n    float cc = c * c;\n\n    vec2 q = vec2(\n        (cc + ss) * p.x + (sc - ss) * p.y,\n        (sc + ss) * p.x + (cc - ss) * p.y\n    );\n\n", "\n    if (o1.x < o2.x) return o1;\n    return o2;\n}\n\n// ~~~~~~~ do Union / combine 3 sd objects\n// input vec3 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec3 opU(vec3 o1, vec3 o2, vec3 o3)\n{\n    if (o1.x < o2.x) return o1;\n    if (o2.x < o3.x) return o2;\n    return o3;\n}\n\n// ~~~~~~~ do Union / combine 4 sd objects\n// input vec4 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec4 opU(vec4 o1, vec4 o2, vec4 o3, vec4 o4)\n{\n    if (o1.x < o2.x) return o1;\n    if (o2.x < o3.x) return o2;\n    if (o3.x < o4.x) return o3;\n    return o4;\n}\n\n// ~~~~~~~ do Union / combine 5 sd objects\n// input vec5 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec5 opU(vec5 o1, vec5 o2, vec5 o3, vec5 o4, vec5 o5)\n{\n    if (o1.x < o2.x) return o1;\n    if (o2.x < o3.x) return o2;\n    if (o3.x < o4.x) return o3;\n    if (o4.x < o5.x) return o4;\n    return o5;\n}\n\n// ~~~~~~~ do Union / combine 6 sd objects\n// input vec6 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec6 opU(vec6 o1, vec", "\n    // ~~~~~~~~ sphere\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + 0.001;\n    // float d = length(p) - 1.0;\n\n    // ~~~~~~~~ cube\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + 0.001;\n    // float d = length(max(abs(p) - vec3(1.0), 0.0));\n\n    // ~~~~~~~~ torus\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + 0.001;\n    // float d = length(vec2(length(p.xz) - 1.0, p.y)) - 0.2;\n\n    // ~~~~~~~~ cylinder\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + 0.001;\n    // float d = length(vec2(length(p.xz) - 1.0, p.y)) - 0.2;\n\n    // ~~~~~~~~ cone\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + 0.001;\n    // float d = length(vec2(length(p.xz), p.y)) - 1.0;\n\n    // ~~~~~~~~ plane\n    // p.x = p.x + 0.001;\n    // p.y = p.y + 0.001;\n    // p.z = p.z + ", "\n\t// ~~~~~~~ march the ray forward\n\t//\n\tfloat t = 0.0;\n\tfloat maxT = 100.0;\n\tfloat precis = 0.001;\n\tfloat h = 0.0;\n\tfloat tMax = 0.0;\n\tfloat id = -1.0;\n\t\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( t > maxT ) break;\n\t\t\n\t\t// ~~~~~~~ get the distance to the closest surface\n\t\t//\n\t\th = map( ro+rd*t );\n\t\t\n\t\t// ~~~~~~~ if we hit something, get its normal\n\t\t//\n\t\tif( h < precis )\n\t\t{\n\t\t\tid = getId( ro+rd*t );\n\t\t\ttMax = t;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tt += h;\n\t}\n\t\n\treturn vec2( tMax, id );\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd, float maxT )\n{\n\t// ~~~~~~~ march the ray forward\n\t//\n\tfloat t = 0.0;\n\tfloat precis = 0.001;\n\tfloat h = 0.0;\n\tfloat tMax = 0.0;\n\tfloat id = -1.0;\n\t\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( t > maxT ) break;\n\t\t\n\t\t// ~~~~~~~ get the distance to the closest surface\n\t\t//\n\t\th = map( ro+rd*t );\n\t\t\n\t\t// ~~~~~~~ if we hit something, get its normal\n\t\t//\n\t\tif( h < precis )\n\t\t{\n\t\t\tid = get", "\n    // ~~~~~~~ find closest surface\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 c = vec3(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        p = ro + rd * t;\n        d = map(p);\n        if (d < 0.001)\n        {\n            n = normal(p);\n            c = vec3(0.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n\n    // ~~~~~~~ apply color\n    if (d > 0.001)\n    {\n        // background\n        c = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        // surface\n        vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n        vec3 h = normalize(l + rd);\n        vec3 r = reflect(rd, n);\n        float diff = clamp(dot(n, l), 0.0, 1.0);\n        float spec = pow(clamp(dot(n, h), 0.0, 1.0), 100.0);\n        c = vec3(0.0, 0.0, 0.0);\n        c += vec3(0.5, 0.5, 0.5) * diff;\n        c += vec3(1.0, 1.0, 1.0) * spec;\n        c += vec3(0.5, 0.5, 0.5) * 0.2;\n    }\n\n    return c;\n}\n\n// ~~~~~~~ main function\nvoid main()\n{\n    // ~~~~~~~ camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, ", "\n    vec3 forward = normalize( targetPos - camPos );\n    vec3 right = normalize( cross( forward, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 up = cross( right, forward );\n\n    return mat3( right, up, forward );\n}\n\n// ~~~~~~~ creates ray direction\n// input camMat --> camera matrix\n// input uv --> screen position\n// output --> ray direction\nvec3 getRayDir( in mat3 camMat, in vec2 uv )\n{\n    vec3 dir = camMat * vec3( uv, 1.0 );\n    return normalize( dir );\n}\n\n// ~~~~~~~ creates ray direction\n// input camMat --> camera matrix\n// input uv --> screen position\n// output --> ray direction\nvec3 getRayDir( in mat3 camMat, in vec2 uv, in float roll )\n{\n    vec3 dir = camMat * vec3( uv, 1.0 );\n    vec3 right = normalize( cross( dir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 up = cross( right, dir );\n    vec3 forward = normalize( dir );\n\n    mat3 rotMat = mat3( right, up, forward );\n    vec3 rotDir = rotMat * vec3( 0.0, 0.0, 1.0 );\n\n    return normalize( rotDir );\n}\n\n// ~~~~~~~ creates ray direction\n// input camMat --> camera matrix\n// input uv --> screen position\n// output --> ray direction\nvec3 getRayDir( in mat3 camMat, in vec2 uv, in float roll, in float pitch )\n{\n    vec3 dir = camMat * vec3( uv, 1.0 );\n    vec3 right = normalize( cross( dir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 up = cross( right, dir );\n    vec3 forward = normalize( dir );\n\n    mat3 rotMat = mat3( right, up, forward );\n    vec3 rotDir = rotMat *", "\n    if (id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (id == 7.0)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if (id == 8.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (id == 9.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id == 10.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id == 11.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id == 12.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (id == 13.0)\n    {", "\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for a box\n// input b --> box specs where:\n//  b.x = box width\n//  b.y = box height\n//  b.z = box depth\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a sphere\n// input r --> sphere radius\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for a capsule\n// input c --> capsule specs where:\n//  c.x = capsule radius\n//  c.y = capsule height\nfloat sdCapsule(vec3 p, vec2 c)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - c;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for a cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\nfloat sdCylinder(vec3 p, vec2 c)\n{\n    return max(length(p.xz) - c.x, abs(p.y) - c.y);\n}\n\n// ~~~~~~~ signed distance function for a cone\n// input c --> cone specs where:\n//  c.x = cone radius\n//  c.y = cone height\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c.x = radius\n    // c.y = height\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\nfloat sdBox(vec3 p, vec3 ps)\n{\n    vec3 d = abs(p) - ps;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed distance function for rounded box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\n//        r --> radius of corners\nfloat sdRoundBox(vec3 p, vec3 ps, float r)\n{\n    vec3 d = abs(p) - ps;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\nfloat sdCylinder(vec3 p, vec2 ps)\n{\n    return length(p.xz) - ps.x + abs(p.y) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for rounded cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n//        r --> radius of caps\nfloat sdRoundCylinder(vec3 p, vec2 ps, float r)\n{\n    vec2 d = vec2(length(p.xz) - ps.x, abs(p.y) - ps.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (power version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*h*(3.0-2.0*h);\n}\n\n// ~~~~~~~ smooth minimum function (power version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-", "\n    vec4 res = vec4(0.0);\n    res.a = o1.a + o2.a * (1.0 - o1.a);\n    res.rgb = mix(o1.rgb, o2.rgb, bf);\n    return res;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2)\n{\n    vec4 res = vec4(0.0);\n    res.a = o1.a + o2.a * (1.0 - o1.a);\n    res.rgb = mix(o1.rgb, o2.rgb, bf);\n    return res;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2, float bf3)\n{\n    vec4 res = vec4(0.0);\n    res.a = o1.a + o2.a * (1.0 - o1.a);\n    res.rgb = mix(o1.rgb, o2.rgb, bf);\n    return res;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material", "\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape union, combines d1 and d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> combined distance\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// ~~~~~~~ do shape intersection, combines d1 and d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> combined distance\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// ~~~~~~~ do shape difference, combines d1 and -d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> combined distance\nfloat opDifference(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape smooth union, combines d1 and d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// input k --> smooth factor\n// output --> combined distance\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape smooth intersection, combines d1 and d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// input k --> smooth factor\n// output --> combined distance\nfloat opSmoothIntersection(float d1,float d2,float k)\n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k,0.0,1.0);\n    return mix(d2,d1,h) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape smooth difference", "\n    float x = rand(vec2(0.0, 0.0));\n    float y = rand(vec2(x, 0.0));\n    float z = rand(vec2(x, y));\n    return vec3(x, y, z);\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir()\n{\n    float x = rand(vec2(0.0, 0.0));\n    float y = rand(vec2(x, 0.0));\n    float z = rand(vec2(x, y));\n    return normalize(vec3(x, y, z));\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir(vec3 normal)\n{\n    vec3 randomDir = generateRandomDir();\n    return reflect(randomDir, normal);\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir(vec3 normal, vec3 tangent, vec3 bitangent)\n{\n    vec3 randomDir = generateRandomDir();\n    return normalize(tangent * randomDir.x + bitangent * randomDir.y + normal * randomDir.z);\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir(vec3 normal, vec3 tangent, vec3 bitangent, vec3 randomDir)\n{\n    return normalize(tangent * randomDir.x + bitangent * randomDir.y + normal * randomDir.z);\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir(vec3 normal, vec3 tangent, vec3 bitangent, vec3 randomDir, float roughness)\n{\n    return normalize(tangent * randomDir.x + bitangent * randomDir.y + normal * randomDir.z);\n}\n\n// ~~~~~~~~ generates random direction\n// output --> random direction\nvec3 generateRandomDir(vec3 normal, vec3 tangent, vec3 bitangent, vec3 randomDir, float roughness, float NdotV)\n{\n    return normalize(", "\n    // ~~~~~~~~ sphere\n    // float d = length(p) - 1.0;\n\n    // ~~~~~~~~ cube\n    // float d = max(abs(p.x), max(abs(p.y), abs(p.z))) - 1.0;\n\n    // ~~~~~~~~ torus\n    // float d = length(vec2(length(p.xz) - 1.0, p.y)) - 1.0;\n\n    // ~~~~~~~~ cylinder\n    // float d = length(vec2(length(p.xz), p.y)) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) - 1.0;\n\n    // ~~~~~~~~ cone\n    // float d = max(length(p.xz) - 1.0, -p.y) -", "\n    float t = 0.0;\n    float maxT = 1000.0;\n    float id = 0.0;\n    float dist = 0.0;\n    float distTravelled = 0.0;\n    float distTravelledPrev = 0.0;\n    float distTravelledPrevPrev = 0.0;\n    float distTravelledPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrevPrev = 0.0;\n    float distTravelledPrevPrevPrevPrevPrevPrevPre", "\n    float res = 1.0;\n    float t = 0.001;\n    float h = 0.0;\n    float dist = 0.0;\n    float k = 10.0;\n    for (int i = 0; i < 32; i++)\n    {\n        h = map(sp + lp * t);\n        dist += h;\n        res = min(res, k * h / dist);\n        t += h;\n        if (h < 0.0001 || t > 20.0)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp, float k)\n{\n    float res = 1.0;\n    float t = 0.001;\n    float h = 0.0;\n    float dist = 0.0;\n    for (int i = 0; i < 32; i++)\n    {\n        h = map(sp + lp * t);\n        dist += h;\n        res = min(res, k * h / dist);\n        t += h;\n        if (h < 0.0001 || t > 20.0)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are", "\n    float occ = 0.0;\n    float d = 0.0;\n    float t = 0.0;\n    float maxT = 1.0;\n    float stepSize = 0.01;\n    float dist = 0.0;\n    float distStep = 0.0;\n    float distTravelled = 0.0;\n    float distTravelledStep = 0.0;\n    float distTravelledMax = 0.0;\n    float distTravelledMaxStep = 0.0;\n    float distTravelledMaxStep2 = 0.0;\n    float distTravelledMaxStep3 = 0.0;\n    float distTravelledMaxStep4 = 0.0;\n    float distTravelledMaxStep5 = 0.0;\n    float distTravelledMaxStep6 = 0.0;\n    float distTravelledMaxStep7 = 0.0;\n    float distTravelledMaxStep8 = 0.0;\n    float distTravelledMaxStep9 = 0.0;\n    float distTravelledMaxStep10 = 0.0;\n    float distTravelledMaxStep11 = 0.0;\n    float distTravelledMaxStep12 = 0.0;\n    float distTravelledMaxStep13 = 0.0;\n    float distTravelledMaxStep14 = 0.0;\n    float distTravelledMaxStep15 = 0.0;\n    float distTravelledMaxStep16 = 0.0;\n    float distTravelledMaxStep17 = 0.0;\n    float distTravelledMaxStep18 = 0.0;\n    float distTravelledMaxStep19 = 0.0;\n    float distTravelledMaxStep20 = 0.0;\n    float distTravelledMaxStep21 = 0.0;\n    float distTravelledMaxStep22 = 0.0;\n    float distTravelledMaxStep23 = 0.0;\n    float distTravelledMaxStep24 = 0.0", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dAvg = 0.0;\n    float dAvgSum = 0.0;\n    float dAvgCount = 0.0;\n    float dAvgMax = 0.0;\n    float dAvgMin = 1000000.0;\n    float dAvgDiff = 0.0;\n    float dAvgDiffSum = 0.0;\n    float dAvgDiffCount = 0.0;\n    float dAvgDiffMax = 0.0;\n    float dAvgDiffMin = 1000000.0;\n    float dAvgDiffAvg = 0.0;\n    float dAvgDiffAvgSum = 0.0;\n    float dAvgDiffAvgCount = 0.0;\n    float dAvgDiffAvgMax = 0.0;\n    float dAvgDiffAvgMin = 1000000.0;\n    float dAvgDiffAvgAvg = 0.0;\n    float dAvgDiffAvgAvgSum = 0.0;\n    float dAvgDiffAvgAvgCount = 0.0;\n    float dAvgDiffAvgAvgMax = 0.0;\n    float dAvgDiffAvgAvgMin = 1000000.0;\n    float dAvgDiffAvgAvgAvg = 0.0;\n    float dAvgDiffAvgAvgAvgSum = 0.0;\n    float dAvgDiffAvgAvgAvgCount = 0.0;\n    float dAvgDiffAvgAvgAvgMax = 0.0;\n    float dAvgDiffAvgAvgAvgMin = 1000000.0", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyInverseGammaCorrection(vec3 c)\n{\n    return pow(c, vec3(2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n    return pow(c, vec3(1.0/gamma));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyInverseGammaCorrection(vec3 c, float gamma)\n{\n    return pow(c, vec3(gamma));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gammaR, float gammaG, float gammaB)\n{\n    return pow(c, vec3(1.0/gammaR, 1.0/gammaG, 1.0/gammaB));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting", "\n    float f=exp2(-fs.x*d*d);\n    float fog=clamp(f,0.0,1.0);\n    vec3 fc=mix(fc1,fc2,fog);\n    vec3 cf=mix(c,fc,fog);\n    return cf;\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD,float fogAmount)\n{\n    float f=exp2(-fs.x*d*d);\n    float fog=clamp(f,0.0,1.0);\n    vec3 fc=mix(fc1,fc2,fog);\n    vec3 cf=mix(c,fc,fog);\n    return mix(c,cf,fogAmount);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float", "\n\treturn 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float dMax)\n{\n\treturn 1.0 / (cF + lF * d + qF * d * d) * (1.0 - d / dMax);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float dMin, float dMax)\n{\n\treturn 1.0 / (cF + lF * d + qF * d * d) * (1.0 - d / dMax) * (1.0 - d / dMin);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float dMin, float dMax, float dMin2, float dMax2)\n{\n\treturn 1.0 / (cF + lF * d + qF *", "\n    vec3 rayDir = vec3(cMatrix * vec3(fCoord, 1.0));\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ calculate the color of the pixel\n// input rayDir --> ray direction\n// input cPos --> camera position\n// input sPos --> sphere position\n// input sRad --> sphere radius\n// output --> color of the pixel\nvec3 calculateColor(vec3 rayDir, vec3 cPos, vec3 sPos, float sRad)\n{\n    // calculate the distance between the camera and the sphere\n    float dist = distance(cPos, sPos);\n\n    // calculate the intersection point\n    vec3 intersection = cPos + rayDir * dist;\n\n    // calculate the normal vector\n    vec3 normal = normalize(intersection - sPos);\n\n    // calculate the color\n    vec3 color = vec3(0.0);\n    if (dist < sRad)\n    {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n\n    return color;\n}\n\n// ~~~~~~~ calculate the color of the pixel\n// input rayDir --> ray direction\n// input cPos --> camera position\n// input sPos --> sphere position\n// input sRad --> sphere radius\n// output --> color of the pixel\nvec3 calculateColor(vec3 rayDir, vec3 cPos, vec3 sPos, float sRad, vec3 lightPos)\n{\n    // calculate the distance between the camera and the sphere\n    float dist = distance(cPos, sPos);\n\n    // calculate the intersection point\n    vec3 intersection = cPos + rayDir * dist;\n\n    // calculate the normal vector\n    vec3 normal = normalize(intersection - sPos);\n\n    // calculate the color\n    vec3 color = vec3(0.0);\n    if (dist < sRad)\n    {\n        // calculate the light direction\n        vec3 lightDir = normalize(lightPos - intersection);\n\n        // calculate the diffuse color\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        vec3 diffuseColor = vec3(1.0, 1.", "\n    vec3 cColor = vec3(0.0);\n    vec3 cDir = normalize(cMat * vec3(fCoord,1.0));\n    vec3 cRay = cPos + cDir;\n    vec3 cStep = cDir * 0.01;\n    vec3 cPos2 = cPos + cStep;\n    vec3 cRay2 = cPos2 + cDir;\n    vec3 cStep2 = cDir * 0.02;\n    vec3 cPos3 = cPos + cStep2;\n    vec3 cRay3 = cPos3 + cDir;\n    vec3 cStep3 = cDir * 0.03;\n    vec3 cPos4 = cPos + cStep3;\n    vec3 cRay4 = cPos4 + cDir;\n    vec3 cStep4 = cDir * 0.04;\n    vec3 cPos5 = cPos + cStep4;\n    vec3 cRay5 = cPos5 + cDir;\n    vec3 cStep5 = cDir * 0.05;\n    vec3 cPos6 = cPos + cStep5;\n    vec3 cRay6 = cPos6 + cDir;\n    vec3 cStep6 = cDir * 0.06;\n    vec3 cPos7 = cPos + cStep6;\n    vec3 cRay7 = cPos7 + cDir;\n    vec3 cStep7 = cDir * 0.07;\n    vec3 cPos8 = cPos + cStep7;\n    vec3 cRay8 = cPos8 + cDir;\n    vec3 cStep8 = cDir * 0.08;\n    vec3 cPos9 = cPos + cStep8;\n    vec3 cRay9 = cPos9 + cDir;\n    vec3 cStep9 = cDir * 0.09;\n    vec3 cPos10 = cPos + cStep9;\n    vec3 cRay10 = cPos10 + cDir;\n    vec3 cStep10 = cDir * 0.10;\n    vec3 cPos11 =", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\n// rounded box distance field\nfloat sdRoundBox(vec3 p, vec3 radius, float roundness)\n{\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - roundness;\n}\n\n// rounded cylinder distance field\nfloat sdRoundCylinder(vec3 p, float radius, float roundness)\n{\n    float", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) - r + min(max(d.x, d.y), 0.0);\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r, float e)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) - r + min(max(d.x, d.y), 0.0) - e;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r, float e, float f)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) - r + min(max(d.x, d.y), 0.0) - e + f;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r, float e, float f, float g)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) - r + min(max(d.x, d.y), 0.0) - e + f - g;\n}\n\n// simple rounded box distance field\nfloat roundBox(vec2 p, vec2 b, float r, float e, float f, float g, float h)\n{\n    vec2 d = abs(p) - b;\n    return length(max", "\n    // The distance to the nearest surface is the distance to the nearest\n    // of the objects in the scene.\n    vec2 d = vec2(1000000.0, 0.0);\n\n    // The material number is the material number of the nearest object.\n    // The material number is used to determine the color of the object.\n    int m = 0;\n\n    // The distance to the nearest surface is the distance to the nearest\n    // of the objects in the scene.\n    // The material number is the material number of the nearest object.\n    // The material number is used to determine the color of the object.\n    return vec2(d.x, m);\n}\n\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    // The distance to the nearest surface is the distance to the nearest\n    // of the objects in the scene.\n    vec2 d = vec2(1000000.0, 0.0);\n\n    // The material number is the material number of the nearest object.\n    // The material number is used to determine the color of the object.\n    int m = 0;\n\n    // The distance to the nearest surface is the distance to the nearest\n    // of the objects in the scene.\n    // The material number is the material number of the nearest object.\n    // The material number is used to determine the color of the object.\n    return vec2(d.x, m);\n}\n\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    // The distance to the nearest surface is the distance to the nearest\n    // of the objects in the scene.\n    vec2 d = vec2(1000000.0, 0.0);\n\n    // The material number is the material number of the nearest object.\n    // The material number is used to determine the color of the object.\n    int m = 0;\n", "\n    vec2 z = vec2(0.0, 0.0);\n    z = c * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    return z;\n}\n\n//Function that returns a complex number to power of 10\nvec2 complexPower10(vec2 c)\n{\n    vec2 z = vec2(0.0, 0.0);\n    z = c * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    return z;\n}\n\n//Function that returns a complex number to power of 15\nvec2 complexPower15(vec2 c)\n{\n    vec2 z = vec2(0.0, 0.0);\n    z = c * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    return z;\n}\n\n//Function that returns a complex number to power of 20\nvec2 complexPower20(vec2 c)\n{\n    vec2 z = vec2(0.0, 0.0);\n    z = c * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    z = z * c;\n    return z;\n}\n\n//Function that", "\n    vec2 morphCoord = coord * morphConstant;\n    vec2 morphCoord2 = morphCoord * morphCoord;\n    vec2 morphCoord3 = morphCoord2 * morphCoord;\n    vec2 morphCoord4 = morphCoord2 * morphCoord2;\n    vec2 morphCoord5 = morphCoord4 * morphCoord;\n    vec2 morphCoord6 = morphCoord3 * morphCoord3;\n    vec2 morphCoord7 = morphCoord6 * morphCoord;\n    vec2 morphCoord8 = morphCoord4 * morphCoord4;\n    vec2 morphCoord9 = morphCoord8 * morphCoord;\n    vec2 morphCoord10 = morphCoord5 * morphCoord5;\n    vec2 morphCoord11 = morphCoord10 * morphCoord;\n    vec2 morphCoord12 = morphCoord6 * morphCoord6;\n    vec2 morphCoord13 = morphCoord12 * morphCoord;\n    vec2 morphCoord14 = morphCoord7 * morphCoord7;\n    vec2 morphCoord15 = morphCoord14 * morphCoord;\n    vec2 morphCoord16 = morphCoord8 * morphCoord8;\n    vec2 morphCoord17 = morphCoord16 * morphCoord;\n    vec2 morphCoord18 = morphCoord9 * morphCoord9;\n    vec2 morphCoord19 = morphCoord18 * morphCoord;\n    vec2 morphCoord20 = morphCoord10 * morphCoord10;\n    vec2 morphCoord21 = morphCoord20 * morphCoord;\n    vec2 morphCoord22 = morphCoord11 * morphCoord11;\n    vec2 morphCoord23 = morphCoord22 * morphCoord;\n    vec2 morphCoord24 = morphCoord12 * morphCoord12;\n    vec2 morphCoord25 = morphCoord24 * morphCoord;\n    vec2 morphCoord26 = morphCoord13 * morphCoord13;\n    vec2", "\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 offset = vec2(i, j) * 0.25;\n\t\t\tcolor += biomorph(uv + offset, constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, vec2 offset)\n{\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 offset = vec2(i, j) * 0.25;\n\t\t\tcolor += biomorph(uv + offset, constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, vec2 offset, float scale)\n{\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 offset = vec2(i, j) * 0.25;\n\t\t\tcolor += biomorph(uv + offset, constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, vec2 offset, float scale, float time)\n", "\n  return fract(x);\n}\n\n// Basically a sawtooth wave\nfloat repeat(float x, float y) {\n  return fract(x / y);\n}\n\n// Basically a square wave\nfloat repeat(float x, float y, float z) {\n  return step(z, fract(x / y));\n}\n\n// Basically a sine wave\nfloat repeat(float x, float y, float z, float w) {\n  return sin(fract(x / y) * w);\n}\n\n// Basically a cosine wave\nfloat repeat(float x, float y, float z, float w, float u) {\n  return cos(fract(x / y) * w);\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float y, float z, float w, float u, float v) {\n  return fract(x / y + z / w + u / v);\n}\n\n// Basically a sawtooth wave\nfloat repeat(float x, float y, float z, float w, float u, float v, float t) {\n  return fract(x / y + z / w + u / v + t);\n}\n\n// Basically a square wave\nfloat repeat(float x, float y, float z, float w, float u, float v, float t, float s) {\n  return step(s, fract(x / y + z / w + u / v + t));\n}\n\n// Basically a sine wave\nfloat repeat(float x, float y, float z, float w, float u, float v, float t, float s, float r) {\n  return sin(fract(x / y + z / w + u / v + t) * r);\n}\n\n// Basically a cosine wave\nfloat repeat(float x, float y, float z, float w, float u, float v, float t, float s, float r, float q) {\n  return cos(fract(x / y + z / w + u / v + t) * r);\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float y, float z, float w, float u, float v, float t, float s, float r, float q", "\n    // First, we need to find the distance from the line.\n    // We do this by finding the distance from the line segment,\n    // then subtracting the distance from the rounded end caps.\n    // This is a bit of a hack, but it works.\n    vec2 dir = pB - pA;\n    vec2 dirN = normalize(dir);\n    vec2 dirPerp = vec2(dirN.y, -dirN.x);\n    vec2 dirPerpN = normalize(dirPerp);\n    vec2 p = uv - pA;\n    float dist = dot(p, dirN);\n    float distPerp = dot(p, dirPerp);\n    float distFromLine = abs(dist);\n    float distFromCap = abs(distPerp);\n    float distFromRoundedCap = distFromCap - rounded;\n    float distFromLineAndCap = max(distFromLine, distFromRoundedCap);\n    float distFromLineAndCapSquared = distFromLineAndCap * distFromLineAndCap;\n    float distFromLineSquared = dist * dist;\n    float distFromCapSquared = distPerp * distPerp;\n    float distFromRoundedCapSquared = distFromCapSquared - rounded * rounded;\n    float distFromLineAndCapSquaredSquared = distFromLineAndCapSquared * distFromLineAndCapSquared;\n    float distFromLineSquaredSquared = distFromLineSquared * distFromLineSquared;\n    float distFromCapSquaredSquared = distFromCapSquared * distFromCapSquared;\n    float distFromRoundedCapSquaredSquared = distFromRoundedCapSquared * distFromRoundedCapSquared;\n    float distFromLineAndCapSquaredSquaredSquared = distFromLineAndCapSquaredSquared * distFromLineAndCapSquaredSquared;\n    float distFromLineSquaredSquaredSquared = distFromLineSquaredSquared * distFromLineSquaredSquared;\n    float distFromCapSquaredSquaredSquared", "\n    vec2 dir = normalize(pB - pA);\n    vec2 normal = vec2(-dir.y, dir.x);\n    vec2 dA = pA + normal * thick * rounded;\n    vec2 dB = pB + normal * thick * rounded;\n    vec2 dC = pB - normal * thick * rounded;\n    vec2 dD = pA - normal * thick * rounded;\n    float dist = min(distance(uv, dA), distance(uv, dB));\n    dist = min(dist, distance(uv, dC));\n    dist = min(dist, distance(uv, dD));\n    return dist;\n}\n\n// This makes a filled line in normalized units. A 1.0 thick line will be 1/2 pixel thick.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 dir = normalize(pB - pA);\n    vec2 normal = vec2(-dir.y, dir.x);\n    vec2 dA = pA + normal * thick * rounded;\n    vec2 dB = pB + normal * thick * rounded;\n    vec2 dC = pB - normal * thick * rounded;\n    vec2 dD = pA - normal * thick * rounded;\n    float dist = min(distance(uv, dA), distance(uv, dB));\n    dist = min(dist, distance(uv, dC));\n    dist = min(dist, distance(uv, dD));\n    return dist;\n}\n\n// This makes a filled line in normalized units. A 1.0 thick line will be 1/2 pixel thick.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    vec2 dir = normalize(pB - pA);\n    vec2 normal = vec2(-dir.y, dir.x);\n    vec2 dA = pA + normal * thick * rounded;\n    vec2 dB = pB + normal * thick * rounded;\n    vec2 dC = pB - normal * thick * rounded;\n    vec2 dD = pA", "\n    float dist = DistanceToLine(uv, pA, pB);\n    float outline = smoothstep(thick.x, thick.y, dist);\n    float outlineRounded = smoothstep(rounded, rounded + outlineThick, dist);\n    return outline - outlineRounded;\n}\n\n// This makes an outlined line in normalized units. A 1.0 thick outline will be 1/255 of a pixel thick.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float dist = DistanceToLine(uv, pA, pB);\n    float outline = smoothstep(thick.x, thick.y, dist);\n    float outlineRounded = smoothstep(rounded, rounded + outlineThick, dist);\n    return outline - outlineRounded;\n}\n\n// This makes a line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat DrawLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    float dist = DistanceToLine(uv, pA, pB);\n    return smoothstep(thick.x, thick.y, dist);\n}\n\n// This makes a line in normalized units. A 1.0 thick line will be 1/255 of a pixel thick.\nfloat DrawLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    float dist = DistanceToLine(uv, pA, pB);\n    return smoothstep(thick.x, thick.y, dist);\n}\n\n// This makes a line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat DrawLinePix(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    float dist = DistanceToLine(uv, pA, pB);\n    return smoothstep(thick, thick, dist);\n}\n\n// This makes a line in normalized units. A 1.0 thick line will be 1/255 of a pixel thick.\nfloat DrawLine(vec2 uv, vec2", "\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 dir2 = vec2(dir.x, -dir.y);\n    vec2 perp2 = vec2(-dir2.y, dir2.x);\n\n    float d = dot(uv - pA, dir);\n    float d2 = dot(uv - pA, dir2);\n\n    float w = thick.x;\n    float h = thick.y;\n\n    float r = rounded;\n\n    float sdf = 0.0;\n\n    // Cap the ends\n    if (d < 0.0) {\n        sdf = length(uv - pA) - r;\n    } else if (d > 1.0) {\n        sdf = length(uv - pB) - r;\n    } else {\n        // The line body\n        float l = length(uv - pA - dir * d);\n        sdf = max(abs(l) - w, abs(d2) - h);\n\n        // Round the ends\n        if (r > 0.0) {\n            float l2 = length(uv - pA - dir * d);\n            float l3 = length(uv - pA - dir2 * d2);\n            float l4 = length(uv - pB - dir * d);\n            float l5 = length(uv - pB - dir2 * d2);\n\n            float r2 = r * r;\n            float r4 = r2 * r2;\n\n            float d3 = dot(uv - pA, perp);\n            float d4 = dot(uv - pB, perp);\n\n            float d5 = dot(uv - pA, perp2);\n            float d6 = dot(uv - pB, perp2);\n\n            float d7 = dot(uv - pA, dir);\n            float d8 = dot(uv - pB, dir);\n\n            float d9 = dot(uv - pA, dir2);\n            float d10 = dot(uv - pB, dir2);\n\n            float d11 = dot(", "\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 pA1 = pA + perp * thick * 0.5;\n    vec2 pA2 = pA - perp * thick * 0.5;\n    vec2 pB1 = pB + perp * thick * 0.5;\n    vec2 pB2 = pB - perp * thick * 0.5;\n    float d = min(distance(uv, pA1), distance(uv, pA2));\n    d = min(d, min(distance(uv, pB1), distance(uv, pB2)));\n    return smoothstep(rounded, rounded + 0.01, d);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 pA1 = pA + perp * thick * 0.5;\n    vec2 pA2 = pA - perp * thick * 0.5;\n    vec2 pB1 = pB + perp * thick * 0.5;\n    vec2 pB2 = pB - perp * thick * 0.5;\n    float d = min(distance(uv, pA1), distance(uv, pA2));\n    d = min(d, min(distance(uv, pB1), distance(uv, pB2)));\n    return smoothstep(rounded, rounded + 0.01, d);\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    vec2 dir = normalize(pB - pA);", "\n    float dist = distance(uv, pA);\n    dist = min(dist, distance(uv, pB));\n    dist = min(dist, distance(uv, pA + pB - pA));\n    dist = min(dist, distance(uv, pA + pB - pB));\n    dist = min(dist, distance(uv, pA + pA - pB));\n    dist = min(dist, distance(uv, pB + pB - pA));\n    dist = min(dist, distance(uv, pB + pA - pB));\n    dist = min(dist, distance(uv, pA + pA - pA));\n    dist = min(dist, distance(uv, pB + pB - pB));\n    dist = min(dist, distance(uv, pA + pB - pA));\n    dist = min(dist, distance(uv, pA + pB - pB));\n    dist = min(dist, distance(uv, pA + pA - pB));\n    dist = min(dist, distance(uv, pB + pB - pA));\n    dist = min(dist, distance(uv, pB + pA - pB));\n    dist = min(dist, distance(uv, pA + pA - pA));\n    dist = min(dist, distance(uv, pB + pB - pB));\n    dist = min(dist, distance(uv, pA + pB - pA));\n    dist = min(dist, distance(uv, pA + pB - pB));\n    dist = min(dist, distance(uv, pA + pA - pB));\n    dist = min(dist, distance(uv, pB + pB - pA));\n    dist = min(dist, distance(uv, pB + pA - pB));\n    dist = min(dist, distance(uv, pA + pA - pA));\n    dist = min(dist, distance(uv, pB + pB - pB));\n    dist = min(dist, distance(uv, pA + pB - pA));\n    dist = min(dist, distance(uv, pA + pB - pB));\n   ", "\n    float d = distance(uv, p);\n    if (d < 0.005) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n}\n\n// This is the main function that renders the scene.\nvoid main() {\n    // Get the UV coordinates of the pixel.\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Get the current time.\n    float t = iGlobalTime;\n\n    // Get the current mouse position.\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the current mouse state.\n    vec2 ms = iMouse.xy;\n\n    // Get the", "\n    float res = 0.0;\n    vec3  q = ro - cen;\n    float b = dot(nor, rd);\n    float c = dot(nor, q);\n    float h = b*b - c*c + rad*rad;\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        float t = -b - h;\n        if( t > 0.0 )\n        {\n            res = t;\n        }\n        t = -b + h;\n        if( t > 0.0 && t < res )\n        {\n            res = t;\n        }\n    }\n    return res;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3  rc = ro - sph.xyz;\n    float c  = dot( rc, rc ) - sph.w*sph.w;\n    float b  = dot( rd, rc );\n    float d  = b*b - c;\n    if( d < 0.0 ) return 0.0;\n    d = -b - sqrt( d );\n    if( d < 0.0 ) return 0.0;\n    return d;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return -dot(pla.xyz, ro) + pla.w;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1 - v0;\n    vec3  e2 = v2 - v0;\n    vec3  pv = cross( rd, e2 );\n    float det = dot( e1, pv );\n    if( det > -0.0001 && det < 0.0001 ) return 0.0;\n    float inv_det = 1.0 / det;\n", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*rd;\n    vec3 k = abs(m)*cen - ro;\n    vec3 t1 = -n*k - sqrt( dot(k,k) - dot(n*abs(k),n) );\n    vec3 t2 = -n*k + sqrt( dot(k,k) - dot(n*abs(k),n) );\n    return vec2( min( t1.x, t2.x ), max( t1.y, t2.y ) );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return -( dot(pla.xyz,ro) + pla.w ) / dot(pla.xyz,rd);\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 pv = cross( rd, e2 );\n    float det = dot( e1, pv );\n    if( det==0.0 ) return -1.0;\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, pv ) / det;\n    if( u<0.0 || u>1.0 ) return -1.0;\n    vec3 qvec = cross( tvec, e1 );\n    float v = dot( rd, qvec ) / det;\n   ", "\n    vec3 ba = pb - pa;\n    vec3 a = (pa + pb) * 0.5;\n    vec3 d = normalize( ba );\n    vec3 k = abs( d.y ) > 0.1? vec3( 1, d.xz * d.y / d.y ) : vec3( d.zx * d.x / d.x, 1, d.xy * d.y / d.y );\n    vec3 b = a + k * ra;\n    vec3 c = a - k * ra;\n    return bound3( min( c, b ), max( c, b ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 ba = pb - pa;\n    vec3 a = (pa + pb) * 0.5;\n    vec3 d = normalize( ba );\n    vec3 k = abs( d.y ) > 0.1? vec3( 1, d.xz * d.y / d.y ) : vec3( d.zx * d.x / d.x, 1, d.xy * d.y / d.y );\n    vec3 b = a + k * ra;\n    vec3 c = a - k * ra;\n    return bound3( min( c, b ), max( c, b ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a torus (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 TorusAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3 ba = pb - pa;\n    vec3 a = (pa + pb) * 0.5;\n    vec3 d = normalize( ba );\n    vec3 k = abs(", "\n    vec3  ba = pb - pa;\n    float baba = dot(ba,ba);\n    float t = dot( pa - ro, ba ) / baba;\n    vec3  n = ( ro + t*rd - pa ) / ra;\n    float m = dot( n, n );\n    if( m > 1.0 ) return vec4( -1.0, 0.0, 0.0, 0.0 );\n    return vec4( t, n, m );\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 sph, in float rad )\n{\n    vec3  rc = ro - sph;\n    float b = dot( rd, rc );\n    float c = dot( rc, rc ) - ( rad * rad );\n    float h = b*b - c;\n    if( h<0.0 ) return vec4( -1.0, 0.0, 0.0, 0.0 );\n    h = sqrt( h );\n    return vec4( -b-h, b-h, 0.0, 0.0 );\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float h )\n{\n    float d = dot( n, ro ) + h;\n    return vec4( -d / dot( n, rd ), n, 0.0 );\n}\n\n// ray-triangle intersection (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1 - v0;\n    vec3  e2 = v2 - v0;\n    vec3  pv = cross( rd, e2 );\n    float det = dot( e1, pv );\n    if( det==0.0 ) return vec4( -1.0, 0.0, 0.0, 0.0", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*rd;\n    vec3 k = abs(m)*cen - ro;\n    vec3 t1 = -n*k - sqrt( dot(k,k) - dot(n*abs(k),n) );\n    vec3 t2 = -n*k + sqrt( dot(k,k) - dot(n*abs(k),n) );\n    return vec2( min( t1.x, t2.x ), max( t1.y, t2.y ) );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return -( dot(pla.xyz,ro) + pla.w ) / dot(pla.xyz,rd);\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 pv = cross( rd, e2 );\n    float det = dot( e1, pv );\n    if( det==0.0 ) return -1.0;\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, pv ) / det;\n    if( u<0.0 || u>1.0 ) return -1.0;\n    vec3 qvec = cross( tvec, e1 );\n    float v = dot( rd, qvec ) / det;\n   ", "\n    vec3  ba = pb - pa;\n    float h  = clamp( dot(rd,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  pa_ = pa + ba*h;\n    vec3  ma = pa - ro;\n    vec3  mb = pa_ - ro;\n    float a = dot(ma,ma);\n    float b = dot(ma,mb);\n    float c = dot(mb,mb) - r*r;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = -b - sqrt(d);\n    if( d<0.0 ) return -1.0;\n    return d/a;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 sph, in float rad )\n{\n    vec3 oc = ro - sph;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// intersect plane : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat planeIntersect( in vec3 ro, in vec3 rd, in vec3 n, in float h )\n{\n    // n must be normalized\n    return dot(n,ro)*(1.0-h*sign(dot(n,rd)))/dot(n,rd);\n}\n\n// intersect box : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 boxSize, in vec3 boxCenter )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k =", "\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(ba,pa) / dot(ba,ba), 0.0, 1.0 );\n    return normalize( cross( ba, cross( ba, pa ) + ba * h ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float t )\n{\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(ba,pa) / dot(ba,ba), 0.0, 1.0 );\n    return normalize( cross( ba, cross( ba, pa ) + ba * h ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float t, in float s )\n{\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(ba,pa) / dot(ba,ba), 0.0, 1.0 );\n    return normalize( cross( ba, cross( ba, pa ) + ba * h ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float t, in float s, in float d )\n{\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(ba,pa) / dot(ba,ba), 0.0, 1.0 );\n    return normalize( cross( ba, cross( ba, pa ) + ba * h ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float t, in float s, in float d, in float e )\n{\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(ba,pa) / dot(ba,ba), 0.", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3  rc = ro - sph.xyz;\n    float B  = dot( rd, rc );\n    float C  = dot( rc, rc ) - sph.w*sph.w;\n    float D  = B*B - C;\n    return D>0.0? -B - sqrt(D) : 1e5;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return -dot(pla.xyz,ro) + pla.w;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1 - v0;\n    vec3  e2 = v2 - v0;\n    vec3  pv = cross( rd, e2 );\n    float det = dot( e1, pv );\n    if( det == 0.0 ) return 1e5;\n    float invDet = 1.0 / det;\n    vec3  tvec = ro - v0;\n    float u = dot( tvec, pv ) * invDet;\n    if( u < 0.0 || u > 1.0 ) return 1e5;\n    vec3  qvec = cross( tvec, e1 );\n    float v = dot( rd, qvec", "\n    float t = 0.0;\n    float d = 0.0;\n    vec3  p = ro;\n    vec4  res = vec4( 0.0 );\n    for( int i=0; i<128; i++ )\n    {\n        d = map( p );\n        if( d < 0.001 )\n        {\n            res.xyz = p;\n            res.w = 1.0;\n            break;\n        }\n        t += d;\n        p = ro + rd * t;\n    }\n    return res;\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        map( pos + eps.xyy ) - map( pos - eps.xyy ),\n        map( pos + eps.yxy ) - map( pos - eps.yxy ),\n        map( pos + eps.yyx ) - map( pos - eps.yyx ) ) );\n}\n\n// lighting\nvec3 doLighting( in vec3 pos, in vec3 nor )\n{\n    vec3  lig = normalize( vec3( 0.5, 0.5, 0.5 ) );\n    vec3  col = vec3( 0.0 );\n    float amb = 0.5 + 0.5 * nor.y;\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0, -lig.z ) ) ), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0 );\n    col += 0.35 * dif * vec3( 1.0, 0.8, 0.5 );\n    col += 0.40 * bac * vec3( 0.6, 0.4, 0.3 );\n    col", "\n    float phi = 2.0 * PI * (i / n);\n    float theta = acos(1.0 - 2.0 * (i / n));\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\n// inverse of forwardSF\nfloat inverseSF(vec3 p)\n{\n    float theta = acos(p.z);\n    float phi = atan(p.y, p.x);\n    return (theta / PI) * 0.5 + 0.5;\n}\n\n// forward mapping of a point on a sphere to a point on a hemisphere\nvec3 forwardHemisphere(vec3 p)\n{\n    return normalize(p);\n}\n\n// inverse of forwardHemisphere\nvec3 inverseHemisphere(vec3 p)\n{\n    return normalize(p);\n}\n\n// forward mapping of a point on a sphere to a point on a hemisphere\nvec3 forwardHemisphere(vec3 p, float n)\n{\n    float phi = 2.0 * PI * (n / (n + 1.0));\n    float theta = acos(1.0 - 2.0 * (n / (n + 1.0)));\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\n// inverse of forwardHemisphere\nvec3 inverseHemisphere(vec3 p, float n)\n{\n    float theta = acos(p.z);\n    float phi = atan(p.y, p.x);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\n// forward mapping of a point on a sphere to a point on a hemisphere\nvec3 forwardHemisphere(float i, float n)\n{\n    float phi = 2.0 * PI * (i / n);\n    float theta = acos(1.0 - 2.0 * (i / n));\n    return vec", "\n    float t = 0.0;\n    float d = 0.0;\n    vec3  p = ro;\n    vec3  n = vec3(0.0);\n    vec3  c = vec3(0.0);\n    vec3  s = vec3(0.0);\n    vec3  e = vec3(0.0);\n    vec3  f = vec3(0.0);\n    vec3  res = vec3(0.0);\n    mat3  resS = mat3(0.0);\n    float resD = 0.0;\n    float resC = 0.0;\n    float resE = 0.0;\n    float resF = 0.0;\n    float resT = 0.0;\n    float resSDF = 0.0;\n    float resSDF2 = 0.0;\n    float resSDF3 = 0.0;\n    float resSDF4 = 0.0;\n    float resSDF5 = 0.0;\n    float resSDF6 = 0.0;\n    float resSDF7 = 0.0;\n    float resSDF8 = 0.0;\n    float resSDF9 = 0.0;\n    float resSDF10 = 0.0;\n    float resSDF11 = 0.0;\n    float resSDF12 = 0.0;\n    float resSDF13 = 0.0;\n    float resSDF14 = 0.0;\n    float resSDF15 = 0.0;\n    float resSDF16 = 0.0;\n    float resSDF17 = 0.0;\n    float resSDF18 = 0.0;\n    float resSDF19 = 0.0;\n    float resSDF20 = 0.0;\n    float resSDF21 = 0.0;\n    float resSDF22 = 0.0;\n    float resSDF23 = 0.0;\n    float resSDF24 = 0.0;\n    float", "\n    // permute and scale the coordinate space\n    vec3 x = p.xyx * vec3( 12.9898, 78.233, 151.7182 );\n\n    // calculate the gradients\n    vec2 ip = floor( x.xy );\n    vec2 u = fract( x.xy );\n    u = u*u*( 3.0 - 2.0*u );\n\n    // work out the hashed gradient indices\n    vec2 g = vec2( ip.x + ip.y*57.0, ip.x + ip.y*97.0 );\n\n    // apply 1D gradient to each of the coordinates\n    vec3  n = vec3( dot( g, vec2( 0.0, 1.0 ) ),\n                    dot( g, vec2( -1.0, 0.0 ) ),\n                    dot( g, vec2( 0.0, -1.0 ) ) );\n\n    // add contributions from each of the corners\n    vec3  d = vec3( dot( u, u ), dot( u, u*u ), dot( u, u*u*u ) );\n    return 2.20 * mix( mix( n.xxx, n.yyy, u.y ), mix( n.zzz, n.xyx, u.y ), u.x );\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    // permute and scale the coordinate space\n    vec3 x = p.xyz * vec3( 12.9898, 78.233, 151.7182 );\n\n    // calculate the gradients\n    vec2 ip = floor( x.xy );\n    vec2 u = fract( x.xy );\n    u = u*u*( 3.0 - 2.0*u );\n\n    // work out the hashed gradient indices\n    vec2 g = vec2( ip.x + ip.y*57.0, ip.x + ip.y*97.0 );\n\n   ", "\n    vec2 d = abs(p) - size;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat boxDist(vec3 p, vec3 size, float radius)\n{\n    vec3 d = abs(p) - size;\n    return length(max(d, vec3(0))) + min(max(d.x, max(d.y, d.z)), 0.0) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size)\n{\n    vec2 d = abs(p) - size;\n    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat boxDist(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return length(max(d, vec3(0))) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sphereDist(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sphereDist(vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat torusDist(vec3 p, vec2 size)\n{\n    vec2 q = vec2(length(p.xz) - size.x, p.y);\n    return length(q) - size.y;\n}\n\nfloat torusDist(vec2 p, vec2 size)\n{\n    vec2 q = vec2(length(p) - size.x, p.y);\n    return length(q) - size.y;\n}\n\nfloat capsuleDist(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat capsule", "\n    vec2 p = fract(uv * orient);\n    return vec3(p, 0.0);\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.x, p.y, 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.x, 0.0, p.y);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(0.0, p.x, p.y);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.y, 0.0, p.x);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.y, p.x, 0.0);\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(0.0, p.y, p.x);\n}\n\n// Pattern 8\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.x, p.y, p.x);\n}\n\n// Pattern 9\nvec3 pat9(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    return vec3(p.x, p.x, p.y);\n}\n\n// Pattern 10\nvec3 pat10(vec2 uv, vec2 orient)\n{\n    vec2 p = f", "\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec3(r, a, 0.0);\n}\n\n// Pattern 8\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    vec2 p = fract(uv * orient);\n", "\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 c = a - 1.0*w;\n    vec2 f = smoothstep(vec2(0.0), 1.0, fract(a));\n    return mix( mix( dot( b, b ), dot( c, c ), f.x ),\n                mix( dot( a, a ), dot( p, p ), f.x ),\n                f.y);\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 c = a - 1.0*w;\n    vec2 f = smoothstep(vec2(0.0), 1.0, fract(a));\n    return mix( mix( length(b), length(c), f.x ),\n                mix( length(a), length(p), f.x ),\n                f.y);\n}\n\n// grid ratio\nfloat gridTexture( in vec2 p )\n{\n    vec2 w = fwidth(p) + 0.0001;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 c = a - 1.0*w;\n    vec2 f = smoothstep(vec2(0.0), 1.0, fract(a));\n    return mix( mix( length(b), length(c), f.x ),\n                mix( length(a), length(p), f.x ),\n                f.y);\n}\n\n// grid ratio\nfloat gridTextureBox( in vec2 p )\n{\n    vec2 w = fwidth(p) + 0.0001;\n    vec2 a = p + 0.5*w;\n    vec2 b =", "\n    return vec3(\n        dFdx(p.x),\n        dFdy(p.y),\n        dFdz(p.z)\n    );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n )\n{\n    return vec3(\n        dFdx(p.x) * n.x + dFdy(p.y) * n.y + dFdz(p.z) * n.z,\n        dFdx(p.x) * n.y + dFdy(p.y) * n.z + dFdz(p.z) * n.x,\n        dFdx(p.x) * n.z + dFdy(p.y) * n.x + dFdz(p.z) * n.y\n    );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 dpdx, in vec3 dpdy )\n{\n    return vec3(\n        dFdx(p.x) * n.x + dFdy(p.y) * n.y + dFdz(p.z) * n.z +\n        dpdx.x * n.x + dpdy.x * n.y,\n        dFdx(p.x) * n.y + dFdy(p.y) * n.z + dFdz(p.z) * n.x +\n        dpdx.y * n.y + dpdy.y * n.z,\n        dFdx(p.x) * n.z + dFdy(p.y) * n.x + dFdz(p.z) * n.y +\n        dpdx.z * n.z + dpdy.z * n.x\n    );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 dpdx, in vec3 dpdy, in vec3 dpdz )\n{\n    return vec3", "\n\tv33 c=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.x;\n\tb.y=c.y;\n\tb.z=c.z;\n}\n\n//and this is the function that does the actual work:\nvoid rayRotate(inout v33 a,inout v33 b,inout v33 c){\n\tv33 d=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.x;\n\tb.y=c.y;\n\tb.z=c.z;\n\tc.x=d.x;\n\tc.y=d.y;\n\tc.z=d.z;\n}\n\n//and this is the function that does the actual work:\nvoid rayRotate(inout v33 a,inout v33 b,inout v33 c,inout v33 d){\n\tv33 e=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.x;\n\tb.y=c.y;\n\tb.z=c.z;\n\tc.x=d.x;\n\tc.y=d.y;\n\tc.z=d.z;\n\td.x=e.x;\n\td.y=e.y;\n\td.z=e.z;\n}\n\n//and this is the function that does the actual work:\nvoid rayRotate(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e){\n\tv33 f=a;\n\ta.x=b.x;\n\ta.y=b.y;\n\ta.z=b.z;\n\tb.x=c.x;\n\tb.y=c.y;\n\tb.z=", "\n\treturn vec3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 add(v33 a,vec3 b){\n\treturn vec3(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n\treturn vec3(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n\treturn vec3(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mod(v33 a,vec3 b){\n\treturn vec3(a.x%b.x,a.y%b.y,a.z%b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 pow(v33 a,vec3 b){\n\treturn vec3(pow(a.x,b.x),pow(a.y,b.y),pow(a.z,b.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sqrt(v33 a,vec3 b){\n\treturn vec3(sqrt(a.x),sqrt(a.y),sqrt(a.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sin(v33 a,vec3 b){\n\treturn vec3(sin(a.x),sin(a.y),sin(a.z));\n}\n\n//swap direction(.b)of", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33", "\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for AB\nvec2 dt(v33 a,v33 b,v33 c){\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for ABC\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for ABCD\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for ABCDE\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for ABCDEF\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n    return vec2(dot(a,b),dot(a,a)*dot(b,b)-dot(a,b)*dot(a,b));\n}\n\n//v33-differentials for ABCDEFG\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n    return vec2(dot(a,b),", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotproduct on v33s\nvec3 dt(v33 a,v33 b){\n    return vec3(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z));\n}\n\n//dual dotproduct on v33s\nvec4 dt(v33 a,v33 b,v33 c){\n    return vec4(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z),dot(a.x,c.x)+dot(a.y,c.y)+dot(a.z,c.z));\n}\n\n//dual dotproduct on v33s\nvec4 dt(v33 a,v33 b,v33 c,v33 d){\n    return vec4(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z),dot(a.x,c.x)+dot(a.y,c.y)+dot(a.z,c.z)+dot(a.x,d.x)+dot(a.y,d.y)+dot(a.z,d.z));\n}\n\n//dual dotproduct on v33s\nvec4 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return vec4(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z),dot(a.x,c.x)+dot(a.y,c.y)+dot(a.z,c.z)+dot(a.x,d.x)+dot(a.y,d.y)+dot(a.z,d.z)+dot(a.x,e.x)+dot(a.y,e.y)+dot(a.z,e.z));\n}\n\n//dual dotproduct on v33s\nvec4 dt(v", "\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y);\n}\n\nv33 mul(vec2 a,v33 b){\n    return v33(a.x*b.x,a.y*b.x,a.x*b.y,a.y*b.y,a.x*b.z,a.y*b.z);\n}\n\nv33 mul(v33 a,v33 b){\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\nv33 mul(v33 a,float b){\n    return v33(a.x*b,a.y*b,a.z*b);\n}\n\nv33 mul(float a,v33 b){\n    return v33(a*b.x,a*b.y,a*b.z);\n}\n\nv33 mul(v33 a,vec3 b){\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\nv33 mul(vec3 a,v33 b){\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\nv33 mul", "\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF3(vec3 p,vec3 w){\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF4(vec3 p,vec3 w){\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF5(vec3 p,vec3 w){\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF6(vec3 p,vec3 w){\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation", "\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y+w.z*p.z);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF2(vec2 p,vec2 w){\n    return 0.5+0.5*sin(w.x*p.x+w.y*p.y);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF1(float p,float w){\n    return 0.5+0.5*sin(w*p);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF1(float p,float w,float w2){\n    return 0.5+0.5*sin(w*p+w2*p);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF1(float p,float w,float w2,float w3){\n    return 0.5+0.5*sin(w*p+w2*p+w3*p);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF1(float p,float w,float w2,float w3,float w4){\n    return 0.5+0.5*sin(w*p+w2*p+w3*p+w4*p);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri", "\n    v33 r0=r.xyz-s.xyz;\n    float c=dot(r0,r0)-s.w*s.w;\n    if(c<0.)return 1.;\n    float d=sqrt(c);\n    return d-r0.z;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k){\n    v33 r0=r.xyz-s.xyz;\n    float c=dot(r0,r0)-s.w*s.w;\n    if(c<0.)return 1.;\n    float d=sqrt(c);\n    return smoothstep(0.,1.,(d-r0.z)/k);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float e){\n    v33 r0=r.xyz-s.xyz;\n    float c=dot(r0,r0)-s.w*s.w;\n    if(c<0.)return 1.;\n    float d=sqrt(c);\n    return smoothstep(0.,1.,(d-r0.z)/k)*(1.-smoothstep(0.,e,d));\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float e,float f){\n    v33 r0=r.xyz-s.xyz;\n    float c=dot(r0,r0)-s.w*s.w;\n    if(c<0.)return 1.;\n    float d=sqrt(c);\n    return smoothstep(0.,1.,(d-r0.z)/k)*(1.-smoothstep(0.,e,d))*f;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float e,float f,float g){\n    v33 r0=r.xyz-s.xyz;\n    float c=dot(", "\n    vec3 d=u-s.xyz;\n    float l=length(d);\n    return step(l,s.w);\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;\n    return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 s){\n    return dot(u-s.xyz,n)+s.w;\n}\n\n//pyramid occlusion\nfloat occPyramid(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;\n    return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\n//hexagon occlusion\nfloat occHexagon(vec3 u,vec3 n,vec4 s){\n    vec3 d=abs(u-s.xyz)-s.w;", "\n    vec4 bbox;\n    bbox.xy = min(p0, p2);\n    bbox.zw = max(p0, p2);\n    vec2 d = (p1 - p0) * 0.5;\n    vec2 c = (p2 - p1) * 0.5;\n    vec2 minVertex = bbox.xy - abs(d) - abs(c);\n    vec2 maxVertex = bbox.zw + abs(d) + abs(c);\n    bbox.xy = min(minVertex, bbox.xy);\n    bbox.zw = max(maxVertex, bbox.zw);\n    return bbox;\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec4 bbox;\n    bbox.xy = min(p0, p3);\n    bbox.zw = max(p0, p3);\n    vec2 d = (p1 - p0) * 0.5;\n    vec2 c = (p2 - p1) * 0.5;\n    vec2 b = (p3 - p2) * 0.5;\n    vec2 a = (p1 - p0) * 0.5;\n    vec2 minVertex = bbox.xy - abs(d) - abs(c) - abs(b) - abs(a);\n    vec2 maxVertex = bbox.zw + abs(d) + abs(c) + abs(b) + abs(a);\n    bbox.xy = min(minVertex, bbox.xy);\n    bbox.zw = max(maxVertex, bbox.zw);\n    return bbox;\n}\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n    vec4 bbox;\n    bbox.xy = min(p0, p4);\n    bbox.zw = max(p0, p", "\n    vec2 minP = min(p0, p2);\n    vec2 maxP = max(p0, p2);\n    vec2 midP = (p0 + p2) * 0.5;\n    vec2 dir = normalize(p1 - midP);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 minE = min(p1, midP + perp * 0.5);\n    vec2 maxE = max(p1, midP + perp * 0.5);\n    return vec4(min(minP, minE), max(maxP, maxE));\n}\n\n// Approximated BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 minP = min(p0, p3);\n    vec2 maxP = max(p0, p3);\n    vec2 midP = (p0 + p3) * 0.5;\n    vec2 dir = normalize(p1 - midP);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 minE = min(p1, midP + perp * 0.5);\n    vec2 maxE = max(p1, midP + perp * 0.5);\n    vec2 midE = (p1 + p2) * 0.5;\n    vec2 dirE = normalize(midE - midP);\n    vec2 perpE = vec2(-dirE.y, dirE.x);\n    vec2 minC = min(p2, midP + perpE * 0.5);\n    vec2 maxC = max(p2, midP + perpE * 0.5);\n    return vec4(min(minP, min(minE, minC)), max(maxP, max(maxE, maxC)));\n}\n\n// Approximated BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in", "\n    vec3 a = p0 - p1;\n    vec3 b = p2 - p1;\n    vec3 c = p0 - p2;\n    vec3 d = p3 - p0;\n\n    vec3 aabb_min = min( min( min( p0, p1 ), p2 ), p3 );\n    vec3 aabb_max = max( max( max( p0, p1 ), p2 ), p3 );\n\n    vec3 bbx_min = aabb_min;\n    vec3 bbx_max = aabb_max;\n\n    if( dot(a,a) > 0.0 )\n    {\n        vec3 p_tmp = p0 + a * clamp( -dot(a,c)/dot(a,a), 0.0, 1.0 );\n        bbx_min = min( bbx_min, p_tmp );\n        bbx_max = max( bbx_max, p_tmp );\n    }\n\n    if( dot(b,b) > 0.0 )\n    {\n        vec3 p_tmp = p3 + b * clamp( -dot(b,d)/dot(b,b), 0.0, 1.0 );\n        bbx_min = min( bbx_min, p_tmp );\n        bbx_max = max( bbx_max, p_tmp );\n    }\n\n    if( dot(c,c) > 0.0 )\n    {\n        vec3 p_tmp = p0 + c * clamp( -dot(c,a)/dot(c,c), 0.0, 1.0 );\n        bbx_min = min( bbx_min, p_tmp );\n        bbx_max = max( bbx_max, p_tmp );\n    }\n\n    if( dot(d,d) > 0.0 )\n    {\n        vec3 p_tmp = p3 + d * clamp( -dot(d,b)/dot(d,d), 0.0, 1.0 );\n        bbx_min = min( bbx", "\n    vec4 bbox;\n    bbox.xy = min(min(p0, p1), min(p2, p3));\n    bbox.zw = max(max(p0, p1), max(p2, p3));\n    return bbox;\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec4 bbox;\n    bbox.xy = min(min(p0, p1), min(p2, p3));\n    bbox.zw = max(max(p0, p1), max(p2, p3));\n    vec2 d = bbox.zw - bbox.xy;\n    vec2 c = (p0 + p1 + p2 + p3) * 0.25;\n    vec2 d2 = d * 0.5;\n    vec2 d3 = d * 0.3333333333333333;\n    vec2 d6 = d * 0.16666666666666666;\n    vec2 mid = c - d2;\n    vec2 mid2 = c - d3;\n    vec2 mid3 = c - d6;\n    vec2 mid4 = c + d6;\n    vec2 mid5 = c + d3;\n    vec2 mid6 = c + d2;\n    bbox.xy = min(min(bbox.xy, mid), min(min(mid2, mid3), min(mid4, mid5)));\n    bbox.zw = max(max(bbox.zw, mid), max(max(mid2, mid3), max(mid4, mid5)));\n    bbox.xy = min(min(bbox.xy, mid6), min(min(mid2, mid3), min(mid4, mid5)));\n    bbox.zw = max(max(bbox.zw, mid6), max(max(mid2, mid3), max(mid4, mid5)));\n    return bbox;\n", "\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.x);\n    vec2 p123 = mix(p12, p23, pos.x);\n    return mix(p012, p123, pos.x);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    return udBezier(p0, p1, p2, p3, vec2(t, t));\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t0, float t1)\n{\n    return udBezier(p0, p1, p2, p3, vec2(t0, t1));\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t0, float t1, float t2)\n{\n    return udBezier(p0, p1, p2, p3, vec2(t0, t1), t2);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t0, float t1, float t2, float t3)\n{\n    return udBezier(p0, p1, p2, p3, vec2(t0, t1), t2, t3);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t0, float t1, float t2, float t3, float t4)\n{\n    return udBezier(p0, p1, p2, p3, vec2(t0, t1), t2, t3, t4);\n}", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    float a = dot( e1, p );\n    if( a > -0.00001 && a < 0.00001 )\n        return vec3( -1.0, 0.0, 0.0 );\n    float f = 1.0/a;\n    vec3 s = ro - v0;\n    float u = f * dot( s, p );\n    if( u < 0.0 || u > 1.0 )\n        return vec3( -1.0, 0.0, 0.0 );\n    vec3 q = cross( s, e1 );\n    float v = f * dot( rd, q );\n    if( v < 0.0 || u + v > 1.0 )\n        return vec3( -1.0, 0.0, 0.0 );\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    float t = f * dot( e2, q );\n    if( t > 0.00001 ) // ray intersection\n    {\n        return vec3( t, u, v );\n    }\n    else // This means that there is a line intersection but not a ray intersection.\n    {\n        return vec3( -1.0, 0.0, 0.0 );\n    }\n}\n\n// Calculate the normal of a triangle.\nvec3 triNormal( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    return normalize( cross( e1, e2 ) );\n}\n\n// Calculate the normal of a triangle.\nvec3 triNormal( in vec3 v0, in vec3 v1, in vec3 v2, in vec2 uv0, in vec2 uv1, in vec2 uv2 )\n{\n    vec3 e1 = v1 - v0;", "\n    vec3 v10 = v1 - v0;\n    vec3 v20 = v2 - v0;\n    vec3 v01 = v0 - v1;\n    vec3 v21 = v2 - v1;\n    vec3 v12 = v1 - v2;\n    vec3 nor0 = cross( v10, v20 );\n    vec3 nor1 = cross( v21, v01 );\n    vec3 nor2 = cross( v02, v12 );\n    float d = dot( nor, nor0 ) + dot( nor, nor1 ) + dot( nor, nor2 );\n    return d * inversesqrt( 3.0 );\n}\n\n//--------------------------------------------------------------------------------------------------\n//\n// 2D Noise\n//\n//--------------------------------------------------------------------------------------------------\n\n//\n// Description : 2D Noise based on Morgan McGuire @morgan3d\n//               https://www.shadertoy.com/view/4dS3Wd\n//\nfloat noise( in vec2 st )\n{\n    vec2 i = floor( st );\n    vec2 f = fract( st );\n\n    // Four corners in 2D of a tile\n    float a = random( i );\n    float b = random( i + vec2( 1.0, 0.0 ) );\n    float c = random( i + vec2( 0.0, 1.0 ) );\n    float d = random( i + vec2( 1.0, 1.0 ) );\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(a,d);\n\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot( vec2(kx-t,ky-t*t), d );\n    }\n    else\n    {\n        float z = sqrt(-p3);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot( t, d ), res );\n    }\n\n    return res;\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2", "\n    p.x = abs(p.x);\n    float t = clamp( (p.x-r2)/(r1-r2), 0.0, 1.0 );\n    return max( abs(p.y)-he, r1-r2*t );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidX( in vec2 p, in float r1, float r2, float he )\n{\n    p.y = abs(p.y);\n    float t = clamp( (p.y-r2)/(r1-r2), 0.0, 1.0 );\n    return max( abs(p.x)-he, r1-r2*t );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidY( in vec2 p, in float r1, float r2, float he )\n{\n    p.x = abs(p.x);\n    float t = clamp( (p.x-r2)/(r1-r2), 0.0, 1.0 );\n    return max( abs(p.y)-he, r1-r2*t );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidZ( in vec2 p, in float r1, float r2, float he )\n{\n    p.y = abs(p.y);\n    float t = clamp( (p.y-r2)/(r1-r2), 0.0, 1.0 );\n    return max( abs(p.x)-he, r1-r2*t );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoidW( in vec2 p, in float r1, float r2, float he )\n{\n    p.x = abs(p.x);\n    float t = clamp( (p.x-r2)/(r1-r2), 0.0, 1.0 );\n    return max( abs(p.y)-he, r1", "\n    p.x = abs(p.x);\n    float k = ( (a.y-b.y) / (a.x-b.x) );\n    float c = b.y - k*b.x;\n    float q = p.y - k*p.x;\n    float d = abs( q - c );\n    float r = ra + rb;\n    float w = ( r - k*p.x ) * sqrt( 1.0 + k*k );\n    return sign( q - c ) * d - r > 0.0? r - d : w;\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb, in float rc )\n{\n    p.x = abs(p.x);\n    float k = ( (a.y-b.y) / (a.x-b.x) );\n    float c = b.y - k*b.x;\n    float q = p.y - k*p.x;\n    float d = abs( q - c );\n    float r = ra + rb + rc;\n    float w = ( r - k*p.x ) * sqrt( 1.0 + k*k );\n    return sign( q - c ) * d - r > 0.0? r - d : w;\n}\n\n// trapezoid / capped cone\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb, in float rc, in float rd )\n{\n    p.x = abs(p.x);\n    float k = ( (a.y-b.y) / (a.x-b.x) );\n    float c = b.y - k*b.x;\n    float q = p.y - k*p.x;\n    float d = abs( q - c );\n    float r = ra + rb + rc + rd;\n    float w = ( r - k*p.x ) * sqrt( 1.0 +", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    return calcSoftshadow( ro, rd, mint, tmax, 8.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    return calcSoftshadow( ro, rd, 0.02, 20.0, 8.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmax )\n{", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const int n )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<n; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k, const int n, const float p )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<n; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, exp( -k*h*h ) );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.", "\n    return fract( 1e4 + 1e4 * sin( 17.0 * float( q.x ) + 0.1 * float( q.y ) ) );\n}\n\n// 2D noise\nfloat noise( in ivec2 q )\n{\n    ivec2 i = floor( q );\n    ivec2 f = fract( q );\n\n    float a = hash( i + ivec2( 0, 0 ) );\n    float b = hash( i + ivec2( 1, 0 ) );\n    float c = hash( i + ivec2( 0, 1 ) );\n    float d = hash( i + ivec2( 1, 1 ) );\n\n    float u = smoothstep( 0.0, 1.0, f.x );\n    float v = smoothstep( 0.0, 1.0, f.y );\n\n    return mix( mix( a, b, u ), mix( c, d, u ), v );\n}\n\n// 2D fractal noise\nfloat fbm( in ivec2 q )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( q ); q = q * 2.02;\n    f += 0.2500 * noise( q ); q = q * 2.03;\n    f += 0.1250 * noise( q ); q = q * 2.01;\n    f += 0.0625 * noise( q ); q = q * 2.04;\n    f += 0.0312 * noise( q ); q = q * 2.01;\n    f += 0.0156 * noise( q ); q = q * 2.04;\n    f += 0.0078 * noise( q ); q = q * 2.01;\n    f += 0.0039 * noise( q ); q = q * 2.04;\n    f += 0.0019 * noise( q ); q = q * 2.01;\n    f += ", "\n    vec2 p2 = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p2.x + p2.y*57.0;\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.5453123);\n    n += dot(p2, vec2(57.0, 21.0));\n    n = fract(sin(n)*43758.545", "\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    float n = 0.0;\n    for( int i=0; i<p; i++ )\n    {\n        n += a * noise( x );\n        a *= b;\n        b *= 2.0;\n        x *= 2.0;\n    }\n    return n;\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 1D noise\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p;\n    return mix( hash(n+  0.0), hash(n+  1.0),f);\n}\n\n// 2D hash\nfloat hash( in vec2 p )\n{\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\n// 1D hash\nfloat hash( in float n )\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D value noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldfSWr\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldfSWr\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldfSWr\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldfSWr\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldfSWr\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//", "\n    p.y = 0.0;\n    float k0 = length(p/r);\n    float k1 = length(p.xz/r.xx);\n    return k0*(k0-1.0)/k1;\n}\n\n// symmetric ellipsoid - SDF\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// rounded box\nfloat sdRoundBox2( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) - r;\n}\n\n// plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n// half-space\nfloat udRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    return max(sdRoundBox(p,b,r),-p.y);\n}\n\n// capsule\nfloat sdCapsule( in vec3 p,", "\n    float k0 = length( p/r );\n    float k1 = length( p/(r*r) );\n    return k0*(k0-1.0)/k1;\n}\n\n// ellipsoid with correct distance\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length( p/r );\n    float k1 = length( p/(r*r) );\n    return k0*(k0-1.0)/k1;\n}\n\n// ellipsoid with correct distance and rotation\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float a )\n{\n    p = abs(p);\n    p = (p.x<p.y)? p.yxz : p.xyz;\n    p = (p.x<p.z)? p.zxy : p.xyz;\n    float k0 = length( p/r );\n    float k1 = length( p/(r*r) );\n    return k0*(k0-1.0)/k1;\n}\n\n// ellipsoid with correct distance and rotation\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 ax )\n{\n    p = abs(p);\n    p = (p.x<p.y)? p.yxz : p.xyz;\n    p = (p.x<p.z)? p.zxy : p.xyz;\n    float k0 = length( p/r );\n    float k1 = length( p/(r*r) );\n    return k0*(k0-1.0)/k1;\n}\n\n// ellipsoid with correct distance and rotation\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 ax, in float a )\n{\n    p = abs(p);\n    p = (p.x<p.y)? p.yxz : p.xyz;\n    p = (p.x<p.z)? p.zxy : p.xyz;\n    float k0 = length( p/r );\n    float k1 = length( p/(r*r) );", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 q ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    q = p + 2.0*k0*(k0-1.0)/k1*r;\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 q, out float k0, out float k1 ) \n{\n    k0 = length(p/r);\n    k1 = length(p/(r*r));\n    q = p + 2.0*k0*(k0-1.0)/k1*r;\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 q, out float k0, out float k1, out float k2 ) \n{\n    k0 = length(p/r);\n    k1 = length(p/(r*r));\n    k2 = length(p/(r*r*r));\n    q = p + 2.0*k0*(k0-1.0)/k1*r + 2.0*k0*k0*(k0-1.0)*(k0-1.0)/k2*r*r;\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, out vec3 q, out float k0, out float k1, out float k2, out float k3 ) \n{\n    k0 = length(p/r);\n    k1 = length", "\n    // filter kernel\n    vec2 w = vec2( 0.02, 0.02 );\n\n    // analytical integral (box filter)\n    return smoothstep( 0.1, 0.15, sin( 1.5707963267948966 * fract( 1.0 - fract( p ) / w ) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w )\n{\n    // filter kernel\n    // vec2 w = vec2( 0.02, 0.02 );\n\n    // analytical integral (box filter)\n    return smoothstep( 0.1, 0.15, sin( 1.5707963267948966 * fract( 1.0 - fract( p ) / w ) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float feather )\n{\n    // filter kernel\n    // vec2 w = vec2( 0.02, 0.02 );\n\n    // analytical integral (box filter)\n    return smoothstep( 0.1 - feather, 0.15 + feather, sin( 1.5707963267948966 * fract( 1.0 - fract( p ) / w ) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float feather, in float featherWidth )\n{\n    // filter kernel\n    // vec2 w = vec2( 0.02, 0.02 );\n\n    // analytical integral (box filter)\n    return smoothstep( 0.1 - feather, 0.15 + feather, sin( 1.5707963267948966 * fract( 1.0 - fract( p ) / w ) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float feather, in float featherWidth, in float featherFalloff )", "\n    return a + ( 1.0 - a ) * pow( 1.0 - x, 5.0 );\n}\n\n// Schlick fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz.\nvec3 fresnel( float a, vec3 f0, vec3 f90, vec3 n, vec3 v )\n{\n    return f0 + ( f90 - f0 ) * pow( 1.0 - dot( n, v ), 5.0 );\n}\n\n// Schlick fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz.\nvec3 fresnel( float a, vec3 f0, vec3 f90, vec3 n, vec3 v, vec3 l )\n{\n    return f0 + ( f90 - f0 ) * pow( 1.0 - dot( n, l ), 5.0 );\n}\n\n// Schlick fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz.\nvec3 fresnel( float a, vec3 f0, vec3 f90, vec3 n, vec3 v, vec3 l, vec3 h )\n{\n    return f0 + ( f90 - f0 ) * pow( 1.0 - dot( n, h ), 5.0 );\n}\n\n// Schlick fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz.\nvec3 fresnel( float a, vec3 f0, vec3 f90, vec3 n, vec3 v, vec3 l, vec3 h, vec3 e )\n{\n    return f0 + ( f90 - f0 ) * pow( 1.0 - dot( n, e ), 5.0 );\n}\n\n// Schlick fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.", "\n    return (x + p) - floor( (x + p) );\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return abs( my_saw( x, p ) * 2.0 - 1.0 );\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return ( my_saw( x, p ) > 0.5 )? 1.0 : -1.0;\n}\n\n// biased sine\nfloat my_sin( float x, float p )\n{\n    return sin( x * 3.1415926535897932384626433832795 * 2.0 );\n}\n\n// biased noise\nfloat my_noi( float x, float p )\n{\n    return fract( sin( x * 12.9898 + p ) * 43758.5453 );\n}\n\n// biased impulse\nfloat my_imp( float x, float p )\n{\n    return ( floor( x + p ) == x )? 1.0 : 0.0;\n}\n\n// biased exponential\nfloat my_exp( float x, float p )\n{\n    return pow( 2.0, floor( x + p ) );\n}\n\n// biased reverse exponential\nfloat my_rexp( float x, float p )\n{\n    return pow( 2.0, -floor( x + p ) );\n}\n\n// biased exponential\nfloat my_expo( float x, float p )\n{\n    return exp( -abs( x - p ) );\n}\n\n// biased reverse exponential\nfloat my_rexpo( float x, float p )\n{\n    return exp( -abs( x - p ) );\n}\n\n// biased exponential\nfloat my_expo2( float x, float p )\n{\n    return exp( -abs( x - p ) * abs( x - p ) );\n}\n\n// biased reverse exponential\nfloat my_rexpo2( float x, float", "\n    float h2 = h*h;\n    float h3 = h2*h;\n    float h4 = h2*h2;\n    float h5 = h3*h2;\n    float h6 = h3*h3;\n    float h7 = h4*h3;\n    float h8 = h4*h4;\n    float h9 = h5*h4;\n    float h10 = h5*h5;\n    float h11 = h6*h5;\n    float h12 = h6*h6;\n    float h13 = h7*h6;\n    float h14 = h7*h7;\n    float h15 = h8*h7;\n    float h16 = h8*h8;\n    float h17 = h9*h8;\n    float h18 = h9*h9;\n    float h19 = h10*h9;\n    float h20 = h10*h10;\n    float h21 = h11*h10;\n    float h22 = h11*h11;\n    float h23 = h12*h11;\n    float h24 = h12*h12;\n    float h25 = h13*h12;\n    float h26 = h13*h13;\n    float h27 = h14*h13;\n    float h28 = h14*h14;\n    float h29 = h15*h14;\n    float h30 = h15*h15;\n    float h31 = h16*h15;\n    float h32 = h16*h16;\n    float h33 = h17*h16;\n    float h34 = h17*h17;\n    float h35 = h18*h17;\n    float h36 = h18*h18;\n    float h37 = h19*h18;\n    float h38 = h19*h19;\n    float", "\n    vec3 ab = pb - pa;\n    vec3 roa = ro - pa;\n    vec3 rdab = rd - ab;\n    float t = dot( roa, rdab ) / dot( rdab, rdab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 roa2 = roa - t * rdab;\n    float d = length( roa2 ) - r;\n    return d;\n}\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3 ab = pb - pa;\n    vec3 roa = ro - pa;\n    vec3 rdab = rd - ab;\n    float t = dot( roa, rdab ) / dot( rdab, rdab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 roa2 = roa - t * rdab;\n    float d = length( roa2 ) - ra - rb;\n    return d;\n}\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb, out vec3 n )\n{\n    vec3 ab = pb - pa;\n    vec3 roa = ro - pa;\n    vec3 rdab = rd - ab;\n    float t = dot( roa, rdab ) / dot( rdab, rdab );\n    t = clamp( t, 0.0, 1.0 );\n    vec3 roa2 = roa - t * rdab;\n    float d = length( roa2 ) - ra - rb;\n    n = normalize( roa2 );\n    return d;\n}\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb, out vec3 n, out float t )\n{\n    vec3 ab = p", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) * mix(rb, ra, h) / length(ba);\n}\n\nfloat sdConeSection(vec3 p, vec2 c, float h, float r1, float r2)\n{\n    float d1 = -p.y - h;\n    float q = p.y - c.x * h;\n    float si = 0.5 * (r1 - r2) / h;\n    float d2 = max(abs(q) - c.y * h, q * q / (c.x * h) - si * si);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdCylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    return max(abs(p.y) - h.y, abs(p.xz) - h.x);\n}\n\nfloat sdCylinder(vec3 p, vec2 h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\nfloat sdCylinder(vec3 p, float ra, float rb, float h)\n{\n    return max(length(p.xz) - ra, abs", "\n    vec3 p = ro + rd * r;\n    vec3 n = normalize( cross( b - a, rd ) );\n    vec3 q = p - a;\n    float f = dot( q, n );\n    float g = dot( q, rd );\n    float h = dot( q, q ) - r * r;\n    float c = f * f - g * g + h;\n    float d = sqrt( c );\n    float s = sign( c );\n    float t = s * ( f - d );\n    float u = s * ( f + d );\n    float v = s * ( g - t );\n    float w = s * ( g + t );\n    float x = s * ( u - v );\n    float y = s * ( u + v );\n    float z = s * ( w - x );\n    float A = atan( v, u );\n    float B = atan( w, x );\n    float C = atan( y, z );\n    float D = atan( v, w );\n    float E = atan( y, u );\n    float F = atan( z, x );\n    float G = atan( v, z );\n    float H = atan( w, y );\n    float I = atan( x, u );\n    float J = atan( z, w );\n    float K = atan( y, x );\n    float L = atan( u, v );\n    float M = atan( z, y );\n    float N = atan( x, w );\n    float O = atan( u, z );\n    float P = atan( v, x );\n    float Q = atan( w, y );\n    float R = atan( u, y );\n    float S = atan( v, w );\n    float T = atan( w, x );\n    float U = atan( x, u );\n    float V = atan( y, z );\n    float W = atan( z, v );\n    float X = atan( x, z );\n    float Y = atan( y, u );\n    float Z = atan( z, w );\n", "\n    float d = length(uv);\n    float s = sin(acos(d / rad1));\n    float c = cos(acos(d / rad1));\n    float a = atan(uv.y, uv.x);\n    float r = rad2 + th * s;\n    return vec2(r * c, r * s) + vec2(a, 0.0);\n}\n\nvoid main()\n{\n    vec2 uv = snake(vUv, 0.5, 0.2, 0.05);\n    vec4 color = texture2D(tDiffuse, uv);\n    gl_FragColor = vec4(color.rgb, 1.0);\n}\n`;\n\nconst snakeFrag = `\nprecision highp float;\n\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\n    float d = length(uv);\n    float s = sin(acos(d / rad1));\n    float c = cos(acos(d / rad1));\n    float a = atan(uv.y, uv.x);\n    float r = rad2 + th * s;\n    return vec2(r * c, r * s) + vec2(a, 0.0);\n}\n\nvoid main()\n{\n    vec2 uv = snake(vUv, 0.5, 0.2, 0.05);\n    vec4 color = texture2D(tDiffuse, uv);\n    gl_FragColor = vec4(color.rgb, 1.0);\n}\n`;\n\nconst snakeFrag2 = `\nprecision highp float;\n\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n\n/**\n", "\n    float l = length(p);\n    float m = length(p*c);\n    return l - r*m;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w )\n{\n    float l = length(p);\n    float m = length(p*c);\n    return l - r*m - w*max(0.0, abs(m) - 1.0);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h )\n{\n    float l = length(p);\n    float m = length(p*c);\n    return l - r*m - w*max(0.0, abs(m) - 1.0) - h*max(0.0, abs(l) - 1.0);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h, in float d )\n{\n    float l = length(p);\n    float m = length(p*c);\n    return l - r*m - w*max(0.0, abs(m) - 1.0) - h*max(0.0, abs(l) - 1.0) - d*max(0.0, abs(l*m) - 1.0);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float w, in float h, in float d, in float e )\n{\n    float l = length(p);\n    float m = length(p*c);\n    return l - r*m - w*max(0.0, abs(m) - 1.0) - h*max(0.0, abs(l) - 1.0) - d*max(0.0, abs(l*", "\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z );\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z ) * (1.0/ra);\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in vec3 rd )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z ) * (1.0/ra) * rd;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in vec3 rd, in float t )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z ) * (1.0/ra) * rd * t;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float ra, in vec3 rd, in float t, in float t2 )\n{\n    return vec3( 4.0*pos.x, 4.0*pos.y, 4.0*pos.z ) * (1.0/ra) * rd * t * t2;\n}\n\n// df/dx,df/dy,df/dz for f(x,y,z)", "\n    p = abs(p);\n    p -= 2.0*sca*(p.x*sca.x + p.y*sca.y);\n    p -= vec2(clamp( (p.x*sca.x + p.y*sca.y)*rb/ra, -ra, rb ));\n    p *= scb;\n    return length(p) - rb;\n}\n\n//-------------------------------------------------------------------------------------------\n// 2D offset\n//-------------------------------------------------------------------------------------------\n\n// Offset in the normal direction\nfloat sdOffset( in vec2 p, in float offset )\n{\n    float offset_x = offset* ( (p.y > 0.0)? 1.0 : -1.0 );\n    return sdLine( p + vec2(offset_x, 0.0), vec2(0.0, 0.0), vec2(0.0, 1.0) );\n}\n\n//-------------------------------------------------------------------------------------------\n// 2D functions\n//-------------------------------------------------------------------------------------------\n\n// 2D distance functions\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0) - r;\n}\n\nfloat sdTriangle( in vec2 p, in float r )\n{\n    p = abs(p);\n    return max(p.x*0.866025 + p.y*0.5,-p.y) - r*0.5;\n}\n\nfloat sdEquilateralTriangle( in vec2 p", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k, in float res )\n{\n    float shade = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        shade = min( shade, res*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( shade, 0.0, 1", "\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(\n        map( pos + e.xyy, time ) - map( pos - e.xyy, time ),\n        map( pos + e.yxy, time ) - map( pos - e.yxy, time ),\n        map( pos + e.yyx, time ) - map( pos - e.yyx, time )\n    ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0)? -1.0 : 1.0;\n    return s*sqrt(", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time, float res )\n{\n    float sh = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        sh = min( sh, res*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time, float res, float dist )\n{\n    float sh = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        sh = min( sh, res*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return sh;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmsh", "\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy));\n\n    // analytical integral (box filter)\n    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\n    // xor pattern\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    return checkersGradBox( p, dFdx(p), dFdy(p) );\n}\n\nfloat checkersGradBox( in vec3 p )\n{\n    return checkersGradBox( p.xy, dFdx(p.xy), dFdy(p.xy) );\n}\n\nfloat checkersGradBox( in vec4 p )\n{\n    return checkersGradBox( p.xy, dFdx(p.xy), dFdy(p.xy) );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float scale )\n{\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy)) * scale;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\n    // xor pattern\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nfloat checkersGradBox( in vec2 p, in float scale )\n{\n    return checkersGradBox( p, dFdx(p), dFdy(p), scale );\n}\n\nfloat checkersGradBox( in", "\n    return floor( x*k )/k;\n}\n\n// Inverse staircase function y=f^-1(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\nfloat staircase_inv( in float x, in float k )\n{\n    return staircase( x, 1/k );\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 x, in float k )\n{\n    return floor( x*k )/k;\n}\n\n// Inverse staircase function y=f^-1(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\nvec2 staircase_inv( in vec2 x, in float k )\n{\n    return staircase( x, 1/k );\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec3 staircase( in vec3 x, in float k )\n{\n    return floor( x*k )/k;\n}\n\n// Inverse staircase function y=f^-1(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\nvec3 staircase_inv( in vec3 x, in float k )\n{\n    return staircase( x, 1/k );\n}\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec4 staircase( in vec4", "\n    vec3 sky_col = vec3(0.0);\n    vec3 sky_col_2 = vec3(0.0);\n    vec3 sky_col_3 = vec3(0.0);\n    vec3 sky_col_4 = vec3(0.0);\n    vec3 sky_col_5 = vec3(0.0);\n    vec3 sky_col_6 = vec3(0.0);\n    vec3 sky_col_7 = vec3(0.0);\n    vec3 sky_col_8 = vec3(0.0);\n    vec3 sky_col_9 = vec3(0.0);\n    vec3 sky_col_10 = vec3(0.0);\n    vec3 sky_col_11 = vec3(0.0);\n    vec3 sky_col_12 = vec3(0.0);\n    vec3 sky_col_13 = vec3(0.0);\n    vec3 sky_col_14 = vec3(0.0);\n    vec3 sky_col_15 = vec3(0.0);\n    vec3 sky_col_16 = vec3(0.0);\n    vec3 sky_col_17 = vec3(0.0);\n    vec3 sky_col_18 = vec3(0.0);\n    vec3 sky_col_19 = vec3(0.0);\n    vec3 sky_col_20 = vec3(0.0);\n    vec3 sky_col_21 = vec3(0.0);\n    vec3 sky_col_22 = vec3(0.0);\n    vec3 sky_col_23 = vec3(0.0);\n    vec3 sky_col_24 = vec3(0.0);\n    vec3 sky_col_25 = vec3(0.0);\n    vec3 sky_col_26 = vec3(0.0);\n    vec3 sky_col_27 = vec3(0.0);\n    vec3 sky_col_28 = vec3(0.0);\n    vec3 sky_col_29 = vec3(0.0);\n", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    float dist_prev = 0.0;\n    float dist_prev_prev = 0.0;\n    float dist_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float dist_prev_prev_prev_prev_prev_prev_prev_", "\n    vec2 xy = coord - resolution.xy / 2.0;\n    float z = resolution.z * 2.0;\n    return normalize(vec3(xy, -z));\n}\n\n/*\nthis function calculates the ray direction for a given pixel\n*/\nvec3 get_ray_direction(vec3 camera_vector, vec2 coord) {\n    vec3 camera_right = normalize(cross(vec3(0.0, 1.0, 0.0), camera_vector));\n    vec3 camera_up = normalize(cross(camera_vector, camera_right));\n    return normalize(camera_vector + gl_FragCoord.x * camera_right + gl_FragCoord.y * camera_up);\n}\n\n/*\nthis function calculates the color of a given pixel\n*/\nvec3 get_color(vec3 ray_direction, vec3 camera_position) {\n    vec3 ray_origin = camera_position;\n    vec3 ray_direction_normalized = normalize(ray_direction);\n    float t = 0.0;\n    float distance = 0.0;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ray_origin + ray_direction_normalized * t;\n        distance = distance_to_surface(p);\n        if (distance < 0.001) {\n            color = get_surface_color(p);\n            break;\n        }\n        t += distance;\n    }\n    return color;\n}\n\nvoid main() {\n    vec3 camera_position = vec3(0.0, 0.0, 5.0);\n    vec3 camera_vector = get_camera_vector(vec3(1024.0, 768.0, 1024.0), gl_FragCoord.xy);\n    vec3 ray_direction = get_ray_direction(camera_vector, gl_FragCoord.xy);\n    vec3 color = get_color(ray_direction, camera_position);\n    gl_FragColor = vec", "\n    float r = length(p.xy);\n    float a = atan(r, p.z);\n    float t = r * c.y - a * c.x;\n    return clamp(t, -ra, ra);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb)\n{\n    float r = length(p.xy);\n    float a = atan(r, p.z);\n    float t = r * c.y - a * c.x;\n    return clamp(t, -ra, rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc)\n{\n    float r = length(p.xy);\n    float a = atan(r, p.z);\n    float t = r * c.y - a * c.x;\n    return clamp(t, -ra, rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd)\n{\n    float r = length(p.xy);\n    float a = atan(r, p.z);\n    float t = r * c.y - a * c.x;\n    return clamp(t, -ra, rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd, float re)\n{\n    float r = length(p.xy);\n    float a = atan(r, p.z);\n    float t = r * c.y - a * c.x;\n    return clamp(t, -ra, rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd, float re, float", "\n    vec3 color = vec3(0.0);\n\n    if (material == 0) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        color = vec3(0.0, 0.0, 1.0);\n    } else if (material == 2) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else if (material == 3) {\n        color = vec3(0.0, 1.0, 0.0);\n    } else if (material == 4) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 5) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else if (material == 6) {\n        color = vec3(0.0, 1.0, 1.0);\n    } else if (material == 7) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 8) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 9) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 10) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 11) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 12) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 13) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 14) {\n        color = vec3(0.0, 0.0, 0.0);", "\n    return 0.0;\n}\n\n// Get refractivity of a material.\n// 0.0 is not refractive at all.\n// 1.0 is maximally refractive, a perfect glass.\nfloat get_material_refractivity(int material) {\n    return 0.0;\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_emission(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_absorption(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_scattering(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_anisotropy(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_roughness(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_ior(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_attenuation(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_thickness(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_glow(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_metallic(int material) {\n    return vec3(0.0);\n}\n\n// Get the color of a material.\nvec3 get_material_specular(int material) {\n    return vec3(0.0);\n}", "\n    return material_refraction[material];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec3 material) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec4 material) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec2 material) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(float material) {\n    return material_refraction[int(material)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material, float index) {\n    return material_refraction[material];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec3 material, float index) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec4 material, float index) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec2 material, float index) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(float material, float index) {\n    return material_refraction[int(material)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material, vec3 index) {\n    return material_refraction[material];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec3 material, vec3 index) {\n    return material_refraction[int(material.x)];\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(vec4 material, vec3 index) {\n", "\n    return material_opacity[material];\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return material_color[material];\n}\n\n// Get the color of a material.\nvec3 get_material_emission(int material) {\n    return material_emission[material];\n}\n\n// Get the color of a material.\nvec3 get_material_specular(int material) {\n    return material_specular[material];\n}\n\n// Get the color of a material.\nvec3 get_material_diffuse(int material) {\n    return material_diffuse[material];\n}\n\n// Get the color of a material.\nvec3 get_material_ambient(int material) {\n    return material_ambient[material];\n}\n\n// Get the color of a material.\nvec3 get_material_shininess(int material) {\n    return material_shininess[material];\n}\n\n// Get the color of a material.\nvec3 get_material_reflectivity(int material) {\n    return material_reflectivity[material];\n}\n\n// Get the color of a material.\nvec3 get_material_transparency(int material) {\n    return material_transparency[material];\n}\n\n// Get the color of a material.\nvec3 get_material_refraction(int material) {\n    return material_refraction[material];\n}\n\n// Get the color of a material.\nvec3 get_material_refraction_index(int material) {\n    return material_refraction_index[material];\n}\n\n// Get the color of a material.\nvec3 get_material_normal(int material) {\n    return material_normal[material];\n}\n\n// Get the color of a material.\nvec3 get_material_bump(int material) {\n    return material_bump[material];\n}\n\n// Get the color of a material.\nvec3 get_material_displacement(int material) {\n    return material_displacement[material];\n}\n\n// Get the color of a material.\nvec3 get_material_alpha(int material) {\n    return material", "\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 h = line_b - line_a;\n    vec3 s = line_a - tri_a;\n    vec3 q = cross(s, e2);\n    vec3 r = cross(h, e1);\n    float a = dot(e1, r);\n    float f = dot(s, q);\n    float u = f / a;\n    float v = dot(s, r) / a;\n    float t = dot(e2, q) / a;\n    return vec3(t >= 0.0 && u >= 0.0 && v >= 0.0 && (u + v) <= 1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c, out float t) {\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 h = line_b - line_a;\n    vec3 s = line_a - tri_a;\n    vec3 q = cross(s, e2);\n    vec3 r = cross(h, e1);\n    float a = dot(e1, r);\n    float f = dot(s, q);\n    float u = f / a;\n    float v = dot(s, r) / a;\n    t = dot(e2, q) / a;\n    return vec3(t >= 0.0 && u >= 0.0 && v >= 0.0 && (u + v) <= 1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://", "\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    vec3 w = tri_d - tri_a;\n    return normalize(cross(u, v) + cross(v, w) + cross(w, u));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d, vec3 tri_e) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    vec3 w = tri_d - tri_a;\n    vec3 x = tri_e - tri_a;\n    return normalize(cross(u, v) + cross(v, w) + cross(w, x) + cross(x, u));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n\n    return mat3(\n        x_axis.x, y_axis.x, z_axis.x,\n        x_axis.y, y_axis.y, z_axis.y,\n        x_axis.z, y_axis.z, z_axis.z\n    );\n}\n\n// Generate a perspective projection matrix based on a camera\n// position, view target, and field of view.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/perspective-and-orthographic-projection-matrix\nmat4 perspective_matrix(vec3 camera_position, vec3 camera_target, float fov) {\n    float aspect_ratio = u_resolution.x / u_resolution.y;\n    float fov_radians = radians(fov);\n    float f = 1.0 / tan(fov_radians / 2.0);\n    float d = distance(camera_position, camera_target);\n\n    return mat4(\n        f / aspect_ratio, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, -(d + 1.0) / (d - 1.0), -1.0,\n        0.0, 0.0, -2.0 * d * (d - 1.0) / (d + 1.0), 0.0\n    );\n}\n\n// Generate a view matrix based on a camera position and view target.\nmat4 view_matrix(vec3 camera_position, vec3 camera_target) {\n    mat3 look_at = look_at_matrix(camera_position, camera_target);\n    mat4 perspective = perspective_matrix(camera_position, camera_target, 4", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = INFINITY;\n    result.normal = vec3(0.0, 0.0, 0.0);\n    result.position = vec3(0.0, 0.0, 0.0);\n    result.color = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < num_triangles; i++) {\n        vec3 v0 = triangle_vertices[i * 3 + 0];\n        vec3 v1 = triangle_vertices[i * 3 + 1];\n        vec3 v2 = triangle_vertices[i * 3 + 2];\n\n        vec3 e1 = v1 - v0;\n        vec3 e2 = v2 - v0;\n        vec3 p = cross(ray_target - ray_origin, e2);\n        float a = dot(e1, p);\n\n        if (a > -EPSILON && a < EPSILON) {\n            continue;\n        }\n\n        float f = 1.0 / a;\n        vec3 s = ray_origin - v0;\n        float u = f * dot(s, p);\n\n        if (u < 0.0 || u > 1.0) {\n            continue;\n        }\n\n        vec3 q = cross(s, e1);\n        float v = f * dot(ray_target - ray_origin, q);\n\n        if (v < 0.0 || u + v > 1.0) {\n            continue;\n        }\n\n        float t = f * dot(e2, q);\n\n        if (t > EPSILON && t < result.distance) {\n            result.hit = true;\n            result.distance = t;\n            result.normal = normalize(cross(e1, e2));\n            result.position = ray_origin + ray_target * t;\n            result.color = triangle_colors[i];\n        }\n    }\n\n    return result;\n}\n\n// Return the color of the pixel at (", "\n    float shadow_factor = 1.0;\n\n    // Find the distance to the nearest object.\n    float t = ray_march(ray_origin, ray_target);\n\n    // If the ray hit something, determine how much in shadow the surface is.\n    if (t < MAX_DISTANCE) {\n        // Find the point of intersection.\n        vec3 intersection = ray_origin + t * ray_target;\n\n        // Find the normal at the point of intersection.\n        vec3 normal = get_normal(intersection);\n\n        // Find the distance to the light source.\n        float light_distance = distance(intersection, light_position);\n\n        // Find the direction from the intersection to the light source.\n        vec3 light_direction = normalize(light_position - intersection);\n\n        // Find the distance to the nearest object between the intersection\n        // and the light source.\n        float light_t = ray_march(intersection, light_direction);\n\n        // If the ray hit something between the intersection and the light\n        // source, the surface is in shadow.\n        if (light_t < light_distance) {\n            shadow_factor = 0.0;\n        }\n    }\n\n    return shadow_factor;\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity and refraction.\nfloat cast_shadow_ray_refraction(vec3 ray_origin, vec3 ray_target, float refraction_index) {\n    float shadow_factor = 1.0;\n\n    // Find the distance to the nearest object.\n    float t = ray_march(ray_origin, ray_target);\n\n    // If the ray hit something, determine how much in shadow the surface is.\n    if (t < MAX_DISTANCE) {\n        // Find the point of intersection.\n        vec3 intersection = ray_origin + t * ray_target;\n\n        // Find the normal at the point of intersection.\n        vec3 normal = get_normal(intersection);\n\n        // Find the distance to the light source.\n        float light_distance = distance(intersection, light_", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\n// 2D noise\nfloat bnoise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 3D noise\nfloat bnoise( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float a = rand(i);\n    float b = rand(i + vec3(1.0, 0.0, 0.0));\n    float c = rand(i + vec3(0.0, 1.0, 0.0));\n    float d = rand(i + vec3(1.0, 1.0, 0.0));\n    float e = rand(i + vec3(0.0, 0.0, 1.0));\n    float f = rand(i + vec3(1.0, 0.0, 1.0));\n    float g = rand(i + vec3(0.0, 1.0, 1.0));\n    float h = rand(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(a,", "\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, vec2( p + 0.00, 0.0 ) ).x;\n    f += 0.2500*texture2D( iChannel0, vec2( p + 0.25, 0.0 ) ).x;\n    f += 0.1250*texture2D( iChannel0, vec2( p + 0.28, 0.0 ) ).x;\n    f += 0.0625*texture2D( iChannel0, vec2( p + 0.39, 0.0 ) ).x;\n    f += 0.0312*texture2D( iChannel0, vec2( p + 0.48, 0.0 ) ).x;\n    f += 0.0156*texture2D( iChannel0, vec2( p + 0.63, 0.0 ) ).x;\n    f += 0.0078*texture2D( iChannel0, vec2( p + 0.76, 0.0 ) ).x;\n    f += 0.0039*texture2D( iChannel0, vec2( p + 0.84, 0.0 ) ).x;\n    f += 0.0019*texture2D( iChannel0, vec2( p + 0.99, 0.0 ) ).x;\n    return f;\n}\n\n// 2D gradient noise\nfloat gnoise( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, vec2( p + vec2( 0.00, 0.00 ), 0.0 ) ).x;\n    f += 0.2500*texture2D( iChannel0, vec2( p + vec2( 0.25, 0.00 ), 0.0 ) ).x;\n    f += 0", "\n    return fract(sin(float(n))*43758.5453123);\n}\n\n// 2D noise copied from Hugo Elias\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n// 2D fractal noise copied from Hugo Elias\nfloat fbm( in vec2 x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 4; i++)\n    {\n        v += a*noise(x);\n        x = x*2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D fractal noise copied from Hugo Elias\nfloat fbm( in vec2 x, int octaves )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < octaves; i++)\n    {\n        v += a*noise(x);\n        x = x*2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D fractal noise copied from Hugo Elias\nfloat fbm( in vec2 x, int octaves, float lacunarity )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for", "\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, vec2( p + 0.00, 0.0 ) ).x;\n    f += 0.2500*texture2D( iChannel0, vec2( p + 1.00, 0.33 ) ).x;\n    f += 0.1250*texture2D( iChannel0, vec2( p + 2.00, 0.66 ) ).x;\n    f += 0.0625*texture2D( iChannel0, vec2( p + 3.00, 1.00 ) ).x;\n    f += 0.0312*texture2D( iChannel0, vec2( p + 4.00, 1.33 ) ).x;\n    f += 0.0156*texture2D( iChannel0, vec2( p + 5.00, 1.66 ) ).x;\n    f += 0.0078*texture2D( iChannel0, vec2( p + 6.00, 2.00 ) ).x;\n    return f;\n}\n\n// 2D random\nfloat rand( in vec2 p )\n{\n    return fract( sin( dot( p, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\n// 2D noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // 4 corners of a rectangle surrounding our point of interest\n    float a = rand( i );\n    float b = rand( i + vec2( 1.0, 0.0 ) );\n    float c = rand( i + vec2( 0.0, 1.0 ) );\n    float d = rand( i + vec2( 1.0, 1.0 ) );\n\n    // simple 2D ler", "\n    float sum = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        sum += amp * noise( x * freq );\n        amp *= G;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm\nvec2 fbm( in vec2 x, in float G )\n{\n    vec2 sum = vec2( 0.0 );\n    float amp = 0.5;\n    float freq = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        sum += amp * vec2( noise( x * freq ), noise( x * freq + 100.0 ) );\n        amp *= G;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm\nvec3 fbm( in vec3 x, in float G )\n{\n    vec3 sum = vec3( 0.0 );\n    float amp = 0.5;\n    float freq = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        sum += amp * vec3( noise( x * freq ), noise( x * freq + 100.0 ), noise( x * freq + 200.0 ) );\n        amp *= G;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\n// fbm\nvec4 fbm( in vec4 x, in float G )\n{\n    vec4 sum = vec4( 0.0 );\n    float amp = 0.5;\n    float freq = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        sum += amp * vec4( noise( x * freq ), noise( x * freq + 100.0 ), noise( x * freq + 200.0 ), noise( x * freq + 300.0", "\n    vec3 color = vec3( 0.0 );\n\n    // Solve the quadratic equation\n    float a = dot( p, p );\n    float b = 2.0 * dot( p, vec3( 1.0 ) );\n    float c = 1.0;\n    float d = b * b - 4.0 * a * c;\n\n    // If the solutions are real, return the color\n    if ( d > 0.0 )\n    {\n        float t = -b / ( 2.0 * a );\n        color = vec3( t );\n    }\n\n    return color;\n}\n\n// The main function\nvoid main()\n{\n    // Get the coordinates of the pixel in the window\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Map the coordinates to the sphere\n    vec3 p = vec3( uv, 1.0 );\n    p = normalize( p ) * 2.0;\n\n    // Get the color\n    vec3 color = getColor( p );\n\n    // Output the color\n    gl_FragColor = vec4( color, 1.0 );\n}\n\\end{code}\n\nComment: I'm not sure what you mean by \"the solutions of the associate quadratic polynomial\".\n\nComment: @NicolBolas I mean the solutions of the quadratic equation `ax^2 + bx + c = 0`.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @NicolBolas I've added a link to the Wikipedia page for the quadratic equation.\n\nComment: @", "\n    vec3 p = pb * 2.0 - 1.0;\n    vec3 p2 = p * p;\n    vec3 p3 = p2 * p;\n    vec3 p4 = p3 * p;\n    vec3 p5 = p4 * p;\n    vec3 p6 = p5 * p;\n    vec3 p7 = p6 * p;\n    vec3 p8 = p7 * p;\n    vec3 p9 = p8 * p;\n    vec3 p10 = p9 * p;\n    vec3 p11 = p10 * p;\n    vec3 p12 = p11 * p;\n    vec3 p13 = p12 * p;\n    vec3 p14 = p13 * p;\n    vec3 p15 = p14 * p;\n    vec3 p16 = p15 * p;\n    vec3 p17 = p16 * p;\n    vec3 p18 = p17 * p;\n    vec3 p19 = p18 * p;\n    vec3 p20 = p19 * p;\n    vec3 p21 = p20 * p;\n    vec3 p22 = p21 * p;\n    vec3 p23 = p22 * p;\n    vec3 p24 = p23 * p;\n    vec3 p25 = p24 * p;\n    vec3 p26 = p25 * p;\n    vec3 p27 = p26 * p;\n    vec3 p28 = p27 * p;\n    vec3 p29 = p28 * p;\n    vec3 p30 = p29 * p;\n    vec3 p31 = p30 * p;\n    vec3 p32 = p31 * p;\n    vec3 p33 = p32 * p;\n    vec3 p34 = p33 * p;\n    vec3 p35 = p34 * p;\n    vec3 p36 = p35 * p;\n    vec3 p37 = p36 * p;\n    vec3 p38", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec4( tN, tF, t1, t2 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return -1.0;\n    return tN;\n}\n\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, out vec3 res ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return -1.0;\n    res = ro + tN*rd;\n    return tN;\n}\n\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, out vec3 res, out vec3 nor ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return -1.0;\n    res = ro + t", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        float s = clamp(8.0 * h / t, 0.0, 1.0);\n        res = min(res, s * s * (3.0 - 2.0 * s));\n        t += clamp(h, 0.02, 0.2);\n        if (res < 0.004 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        float s = clamp(8.0 * h / t, 0.0, 1.0);\n        res = min(res, s * s * (3.0 - 2.0 * s));\n        t += clamp(h, 0.02, 0.2);\n        if (res < 0.004 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//", "\n    seed *= 123.4567;\n    seed += 1.0;\n    return fract(sin(seed) * 43758.5453);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co) {\n    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 56.8875))) * 43758.5453);\n}\n\nfloat rand(vec4 co) {\n    return fract(sin(dot(co.xyzw, vec4(12.9898, 78.233, 56.8875, 98.5453))) * 43758.5453);\n}\n\nfloat rand(float co) {\n    return fract(sin(co * 12.9898) * 43758.5453);\n}\n\nfloat rand(int co) {\n    return fract(sin(float(co) * 12.9898) * 43758.5453);\n}\n\nfloat rand(ivec2 co) {\n    return fract(sin(float(co.x * 12.9898 + co.y * 78.233)) * 43758.5453);\n}\n\nfloat rand(ivec3 co) {\n    return fract(sin(float(co.x * 12.9898 + co.y * 78.233 + co.z * 56.8875)) * 43758.5453);\n}\n\nfloat rand(ivec4 co) {\n    return fract(sin(float(co.x * 12.9898 + co.y", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c )\n{\n    return a + b*cos( 6.28318*(c*t) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b )\n{\n    return a + b*cos( 6.28318*t );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t )\n{\n    return vec3( fract(sin(t*0.123)*758.5453), fract(sin(t*0.123+1.0)*758.5453), fract(sin(t*0.123+2.0)*758.5453) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in float s )\n{\n    return vec3( fract(sin(t*0.123)*758.5453+s), fract(sin(t*0.123+1.0)*758.5453+s), fract(sin(t*0.123+2.0)*758.5453+s) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in float s, in float b )\n{\n    return vec3( fract(", "\n    float d = abs(p.x) + abs(p.y);\n    return max(d - la - lb, abs(p.z) - h) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, out vec3 res)\n{\n    float d = abs(p.x) + abs(p.y);\n    float d1 = max(d - la - lb, abs(p.z) - h);\n    float d2 = abs(d1) - ra;\n    res = vec3(d1, d2, 0.0);\n    return d2;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, out vec3 res, out float d)\n{\n    float d1 = abs(p.x) + abs(p.y);\n    float d2 = max(d1 - la - lb, abs(p.z) - h);\n    float d3 = abs(d2) - ra;\n    res = vec3(d1, d2, d3);\n    d = d3;\n    return d3;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, out vec3 res, out float d, out float d1, out float d2)\n{\n    d1 = abs(p.x) + abs(p.y);\n    d2 = max(d1 - la - lb, abs(p.z) - h);\n    d3 = abs(d2) - ra;\n    res = vec3(d1, d2, d3);\n    d = d3;\n    return d3;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, out vec3 res", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, h, 1.0 - h, dot( pa, ba ) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, h, 1.0 - h, dot( pa, ba ) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ), h, 1.0 - h, dot( pa, ba ) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band, float t ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length( pa - ba*h ) - r, h, 1.0 - h, dot( pa, ba ) );\n}\n\n// x = local dist\n// y =", "\n    vec2 d = abs(p)-b;\n    vec2 q = max(d,0.0);\n    float c = length(max(d,0.0)) - r;\n    float h = s-r;\n    float k = s-length(q);\n    return vec4(c,k,h,k);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float e )\n{\n    vec2 d = abs(p)-b;\n    vec2 q = max(d,0.0);\n    float c = length(max(d,0.0)) - r;\n    float h = s-r;\n    float k = s-length(q);\n    return vec4(c,k,h,k);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float e, in float f )\n{\n    vec2 d = abs(p)-b;\n    vec2 q = max(d,0.0);\n    float c = length(max(d,0.0)) - r;\n    float h = s-r;\n    float k = s-length(q);\n    return vec4(c,k,h,k);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s, in float e, in float f, in float g )\n{\n    vec2 d = abs(p)-b;\n    vec2 q = max(d,0.0);\n    float c = length(max(d,0.0)) - r;\n    float h = s-r;", "\n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0))+min(max(d.x,d.y),0.0),\n                -sign(max(d.x,d.y)));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( ab.x > ab.y ){ p.y /= ab.x; p.x *= ab.y/ab.x; } else { p.x /= ab.y; p.y *= ab.x/ab.y; }\n    float l = length(p);\n    return vec3( l - ab.y, -p.x/l, -p.y/l );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b+r;\n    return vec3( length(max(q,0.0))+min(max(q.x,q.y),0.0)-r,\n                -sign(max(q.x,q.y)) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundEllipse( in vec2 p, in vec2 ab, in float r )\n{\n    p = abs(p); if( ab.x > ab.y ){ p.y /= ab.x; p.x *=", "\n    vec2 q = vec2( length(p) - r, atan(p.y,p.x) );\n    return vec4( q.x, q.x+q.y, q.x+q.y+band, q.x+q.y+band );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r ) \n{\n    vec2 q = vec2( length(p) - r, atan(p.y,p.x) );\n    return vec4( q.x, q.x+q.y, q.x+q.y, q.x+q.y );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float thickness ) \n{\n    vec2 q = vec2( length(p) - r, atan(p.y,p.x) );\n    return vec4( q.x, q.x+q.y, q.x+q.y+band, q.x+q.y+band );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float thickness, float thickness2 ) \n{\n    vec2 q = vec2( length(p) - r, atan(p.y,p.x) );\n    return vec4( q.x, q.x+q.y, q.x+q.y+band, q.x+q.y+band );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float thickness, float thickness2, float thickness3 ) \n{\n    vec2", "\n    float d = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 vert = verts[i];\n        vec2 vert_next = verts[(i+1)%5];\n        d = max( d, abs(dot(vert_next-vert, p-vert)) );\n    }\n    return d - r;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5] ) \n{\n    float d = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 vert = verts[i];\n        vec2 vert_next = verts[(i+1)%5];\n        d = max( d, abs(dot(vert_next-vert, p-vert)) );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float d ) \n{\n    float d_ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 vert = verts[i];\n        vec2 vert_next = verts[(i+1)%5];\n        d_ = max( d_, abs(dot(vert_next-vert, p-vert)) );\n    }\n    return max(d_, d) - r;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float d, in float d2 ) \n{\n    float d_ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 vert = verts[i];\n        vec2 vert_next = verts[(i+1)%5];\n        d_ = max( d_, abs(dot(vert_next-vert, p-vert)) );\n    }\n    return max(max(d_, d), d2) - r;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float d, in float d2, in float d", "\n    vec2 v[5];\n    for( int i=0; i<5; i++ )\n        v[i] = verts[i] - p;\n\n    vec2 e[5];\n    for( int i=0; i<5; i++ )\n        e[i] = v[(i+1)%5] - v[i];\n\n    vec2 n[5];\n    for( int i=0; i<5; i++ )\n        n[i] = vec2( -e[i].y, e[i].x );\n\n    vec2 pv[5];\n    for( int i=0; i<5; i++ )\n        pv[i] = v[i] - dot(v[i],n[i])*n[i];\n\n    vec2 d[5];\n    for( int i=0; i<5; i++ )\n        d[i] = abs(pv[i]) - r;\n\n    vec2 x = clamp(d[0],d[1],d[2]);\n    vec2 y = clamp(d[1],d[2],d[3]);\n    vec2 z = clamp(d[2],d[3],d[4]);\n\n    vec2 w = clamp(x,y,z);\n    vec2 vv = clamp(z,y,x);\n\n    float dist = length(w);\n    float perim = length(vv);\n    float total = perim + band;\n\n    return vec4( dist, perim, total, length(pv[0]) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, vec2 verts[6], float r, float band ) \n{\n    vec2 v[6];\n    for( int i=0; i<6; i++ )\n        v[i] = verts[i] - p;\n\n    vec2 e[6];\n    for( int i=0; i<6; i++ )\n        e[i] =", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa - ba*h),\n                      -ba.y, ba.x );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length(pa - ba*h),\n                      -ba.y, ba.x,\n                      -ba.z, ba.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSegment( in vec4 p, in vec4 a, in vec4 b )\n{\n    vec4 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length(pa - ba*h),\n                      -ba.y, ba.x,\n                      -ba.z, ba.y,\n                      -ba.w, ba.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p)", "\n    vec2 q = abs(p);\n    float d = max(q.x+r*0.57735,q.y);\n    return vec3(d,q.x-r*0.57735,q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgOctagon( in vec2 p, in float r ) \n{\n    vec2 q = abs(p);\n    float d = (q.x+r*0.57735)*(q.x+r*0.57735) + q.y*q.y;\n    return vec3(d,q.x-r*0.57735,q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgStar( in vec2 p, in float r ) \n{\n    vec2 q = abs(p);\n    float d = max(q.x+r*0.38268,q.y*1.1547);\n    return vec3(d,q.x-r*0.38268,q.y*1.1547);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica( in vec2 p, in float r ) \n{\n    vec2 q = abs(p);\n    float d = pow( pow(q.x,4.0)+pow(q.y,4.0),0.25 );\n    return vec3(d,q.x", "\n    vec3 d = vec3(X[0][0], X[1][0], X[2][0]) * p.x +\n             vec3(X[0][1], X[1][1], X[2][1]) * p.y +\n             vec3(X[0][2], X[1][2], X[2][2]) * p.z +\n             vec3(X[0][3], X[1][3], X[2][3]);\n    float d2 = dot(d, d);\n    if (d2 < 1e-10) {\n        return false;\n    }\n    float d2_1 = 1.0 / d2;\n    vec3 n = vec3(X[0][0], X[1][0], X[2][0]) * p.y +\n             vec3(X[0][1], X[1][1], X[2][1]) * p.z +\n             vec3(X[0][2], X[1][2], X[2][2]) * p.x +\n             vec3(X[0][3], X[1][3], X[2][3]);\n    vec3 t1 = n * d2_1;\n    vec3 t2 = d * d2_1;\n    tan1 = normalize(t1 - t2);\n    tan2 = normalize(t1 + t2);\n    return true;\n}\n\n// Return the intersection of the line from p to p+d with the conic X.\n// Return false if no intersection.\nbool intersect(vec3 p, vec3 d, mat3 X, out vec3 q) {\n    vec3 tan1, tan2;\n    if (!tangents(p, X, tan1, tan2)) {\n        return false;\n    }\n    vec3 n = cross(tan1, tan2);\n    float dn = dot(d, n);\n    if (abs(dn) < 1e-10) {\n        return false;\n    }\n    float t = dot(p - X[3], n) / dn;\n    q = p + d * t;\n    return true;\n}\n", "\n    return a / (b + 0.0000001);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsl(vec3 c) {\n    vec3 rgb = c;\n    float minc = min(rgb.r, min(rgb.g, rgb.b));\n    float maxc = max(rgb.r, max(rgb.g, rgb.b));\n    float delta = maxc - minc;\n    float l = (minc + maxc) / 2.0;\n    float s = 0.0;\n    float h = 0.0;\n    if (delta > 0.0) {\n        if (l < 0.5) {\n            s = delta / (maxc + minc);", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 r)\n{\n    return RotateX(RotateY(RotateZ(p, r.z), r.y), r.x);\n}\n\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p + t;\n}\n\nvec3 Scale(vec3 p, vec3 s)\n{\n    return p * s;\n}\n\n// Primitives\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Cylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat Cone(vec3 p, float r1, float r2, float h)\n{\n    float d1 = max(length(p.xz) - r1, abs(p.y) - h);\n    float d2 = max(length(p.xz) - r2, abs", "\n    return 1.0 - clamp(x / R, 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p, float q)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p, float q, float w)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p, float q, float w, float t)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p, float q, float w, float t, float u)\n{\n    return clamp(1.0 - (x / R), 0.0, 1.0);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float s, float p, float q, float w, float t, float u, float v)\n{\n    return clamp(1.0 - (x / R), 0.0, 1", "\n    return 1.0 / (4.0 * PI * R * R * e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R_min)\n{\n    return 1.0 / (4.0 * PI * R * R * e) + 1.0 / (4.0 * PI * R_min * R_min * e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R_min, float R_max)\n{\n    return 1.0 / (4.0 * PI * R * R * e) + 1.0 / (4.0 * PI * R_min * R_min * e) + 1.0 / (4.0 * PI * R_max * R_max * e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R_min, float R_max, float R_min2, float R_max2)\n{\n    return 1.0 / (4.0 * PI * R * R * e) + 1.0 / (4.0 * PI * R_min * R_min * e) + 1.0 / (4.0 * PI * R_max * R_max * e) + 1.0 / (4.0 * PI * R_min2 * R_min2 * e) + 1.0 / (4.0 * PI * R_max2 * R_max2 * e);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R_min, float R_max, float R_min2, float R_max2, float R_min3, float R_max3)\n{\n    return 1", "\n    float k = 0.0;\n    if (e > 0.0)\n    {\n        float d = a - b;\n        float r = R * R;\n        float e2 = e * e;\n        float d2 = d * d;\n        float r2 = r * r;\n        float e2r2 = e2 * r2;\n        float d2r2 = d2 * r2;\n        float e2r2d2 = e2r2 * d2;\n        float e2r2d2_1 = e2r2d2 + 1.0;\n        float e2r2d2_1_2 = e2r2d2_1 * e2r2d2_1;\n        float e2r2d2_1_2_2 = e2r2d2_1_2 * e2r2d2_1_2;\n        float e2r2d2_1_2_2_2 = e2r2d2_1_2_2 * e2r2d2_1_2_2;\n        float e2r2d2_1_2_2_2_2 = e2r2d2_1_2_2_2 * e2r2d2_1_2_2_2;\n        float e2r2d2_1_2_2_2_2_2 = e2r2d2_1_2_2_2_2 * e2r2d2_1_2_2_2_2;\n        float e2r2d2_1_2_2_2_2_2_2 = e2r2d2_1_2_2_2_2_2 * e2r2d2_1_2_2_2_2_2;\n        float e2r2d2_1_2_2_2_2_2_2_2 = e2r2d2_1_2_2_2_2_2_2 * e2r2d2_1_2_2_2_2_2_2;\n        float e2r2d2_1_2_2_2_2_", "\n    return e * exp(-length(p - c) / R);\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Plane primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Capsule primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Capsule(vec3 p, vec3 c, float R, float e)\n{\n    return e * exp(-length(p - c) / R);\n}\n\n// Cylinder primitive field function\n// p: world point\n", "\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    float t = dot(ac, ab) / dot(ab, ab);\n    vec3 p = a + t * ab;\n    float d = length(p - c);\n    return d / R;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a triangle [a, b, c]\n// c: center\n// R: radius\n// e: energy\n// a: triangle vertex 1\n// b: triangle vertex 2\n// c: triangle vertex 3\nfloat VertexKTriangle(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 bc = c - b;\n    vec3 n = cross(ab, ac);\n    float d = dot(n, c - a);\n    float t = d / dot(n, ab);\n    vec3 p = a + t * ab;\n    d = length(p - c);\n    return d / R;\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a tetrahedron [a, b, c, d]\n// c: center\n// R: radius\n// e: energy\n// a: tetrahedron vertex 1\n// b: tetrahedron vertex 2\n// c: tetrahedron vertex 3\n// d: tetrahedron vertex 4\nfloat VertexKTetrahedron(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    vec3 bc = c - b;\n    vec3 bd = d - b;\n    vec3 cd = d - c;\n    vec3 n = cross(ab, ac);\n    float d1 = dot(n, c - a);\n    float t1 = d1 / dot(n, ab);\n    vec3 p1 = a + t1 * ab;", "\n    return length(p) - 1.0;\n}\n\n// Distance to the scene\nfloat DistanceToScene(vec3 p)\n{\n    return Object(p);\n}\n\n// Distance to the scene with normal\nvec2 DistanceToScene(vec3 p, out vec3 n)\n{\n    float d = Object(p);\n    n = normalize(vec3(d - Object(p + vec3(EPSILON, 0.0, 0.0)),\n                       d - Object(p + vec3(0.0, EPSILON, 0.0)),\n                       d - Object(p + vec3(0.0, 0.0, EPSILON))));\n    return vec2(d, d);\n}\n\n// Ray marching\nvec3 RayMarching(vec3 ro, vec3 rd, out float d)\n{\n    float t = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        vec2 d_ = DistanceToScene(p);\n        d = d_.x;\n        t += d_.y;\n        p = ro + rd * t;\n        if (d < EPSILON)\n        {\n            break;\n        }\n    }\n    return p;\n}\n\n// Normal\nvec3 Normal(vec3 p)\n{\n    vec3 n;\n    DistanceToScene(p, n);\n    return n;\n}\n\n// Lighting\nvec3 Lighting(vec3 p, vec3 n, vec3 rd)\n{\n    vec3 ld = vec3(0.0);\n    vec3 lp = vec3(0.0, 0.0, 0.0);\n    vec3 ln = vec3(0.0);\n    vec3 lc = vec3(1.0, 1.0, 1.0);\n    vec3 h = normalize(lp - p);\n    float diffuse = clamp(dot(n, ln), 0.0, 1.0);\n    float specular = pow(cl", "\n    vec3 ab = b - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, ab) / l;\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b)\n{\n    vec2 ab = b - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, ab) / l;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, cross(ab, ac)) / l;\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c)\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, cross(ab, ac)) / l;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, cross(ab, cross(ac, ad))) / l;\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ad = d - a;\n    float l = length(ab);\n    return l == 0.0? 0.0 : dot(a, cross(ab, cross(ac, ad))) / l;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3", "\n    return normalize( vec3(\n        map_detailed(vec3(p.x + EPSILON, p.y, p.z)).x - map_detailed(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map_detailed(vec3(p.x, p.y + EPSILON, p.z)).x - map_detailed(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map_detailed(vec3(p.x, p.y, p.z  + EPSILON)).x - map_detailed(vec3(p.x, p.y, p.z - EPSILON)).x ) );\n}\n\n// Raymarching\nfloat SceneIntersect( in vec3 ro, in vec3 rd, out vec3 normal, out vec3 position )\n{\n    float t = 0.0;\n    float precis = 0.0005;\n    float h = 0.0;\n    float dist = 0.0;\n    const int maxIter = 100;\n    for( int i = 0; i < maxIter; i++ )\n    {\n        if( abs(h) < precis || t > MAX_DIST ) break;\n        t += h;\n        position = ro + t * rd;\n        h = map_detailed( position );\n    }\n\n    if( t > MAX_DIST )\n    {\n        return -1.0;\n    }\n\n    normal = ObjectNormal( position );\n    return t;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map_detailed(pos+eps.xyy).x - map_detailed(pos-eps.xyy).x,\n        map_detailed(pos+eps.yxy).x - map_d", "\n    float t = 0.0;\n    float d = 0.0;\n    vec3 p = o;\n    vec3 c = vec3(0.0);\n    float r = 0.0;\n    float dmin = 1000000.0;\n    float dmax = 0.0;\n    float dmin2 = 1000000.0;\n    float dmax2 = 0.0;\n    float dmin3 = 1000000.0;\n    float dmax3 = 0.0;\n    float dmin4 = 1000000.0;\n    float dmax4 = 0.0;\n    float dmin5 = 1000000.0;\n    float dmax5 = 0.0;\n    float dmin6 = 1000000.0;\n    float dmax6 = 0.0;\n    float dmin7 = 1000000.0;\n    float dmax7 = 0.0;\n    float dmin8 = 1000000.0;\n    float dmax8 = 0.0;\n    float dmin9 = 1000000.0;\n    float dmax9 = 0.0;\n    float dmin10 = 1000000.0;\n    float dmax10 = 0.0;\n    float dmin11 = 1000000.0;\n    float dmax11 = 0.0;\n    float dmin12 = 1000000.0;\n    float dmax12 = 0.0;\n    float dmin13 = 1000000.0;\n    float dmax13 = 0.0;\n    float dmin14 = 1000000.0;\n    float dmax14 = 0.0;\n    float dmin15 = 1000000.0;\n    float dmax15 = 0.0;\n", "\n    float t = 0.0;\n    float d = 0.0;\n    float d_prev = 0.0;\n    float d_next = 0.0;\n    float d_prev_prev = 0.0;\n    float d_next_next = 0.0;\n    float d_prev_prev_prev = 0.0;\n    float d_next_next_next = 0.0;\n    float d_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next_next_next_next_next = 0.0;\n    float d_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    float d_next_next_next_next_next_next_next_next_next_next_next = 0.0;\n    float d_prev_prev", "\n    vec3 col = vec3(0.0);\n    float t = 0.5 * (rd.y + 1.0);\n    col = mix(vec3(0.2, 0.7, 0.8), vec3(0.8, 0.9, 1.0), t);\n    return col;\n}\n\nvec3 Shade(vec3 p, vec3 n, vec3 rd, vec3 light_pos, vec3 light_col, vec3 cam_pos)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(light_pos - p);\n    vec3 ref = reflect(-ld, n);\n    float diff = max(dot(n, ld), 0.0);\n    float spec = pow(max(dot(ref, rd), 0.0), 16.0);\n    float shadow = Shadow(p, ld);\n    col = (1.0 - shadow) * (diff * light_col + spec * vec3(1.0));\n    return col;\n}\n\nvec3 Shade(vec3 p, vec3 n, vec3 rd, vec3 light_pos, vec3 light_col, vec3 cam_pos, float spec_exp)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(light_pos - p);\n    vec3 ref = reflect(-ld, n);\n    float diff = max(dot(n, ld), 0.0);\n    float spec = pow(max(dot(ref, rd), 0.0), spec_exp);\n    float shadow = Shadow(p, ld);\n    col = (1.0 - shadow) * (diff * light_col + spec * vec3(1.0));\n    return col;\n}\n\nvec3 Shade(vec3 p, vec3 n, vec3 rd, vec3 light_pos, vec3 light_col, vec3 cam_pos, float spec_exp, float spec_int)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(light_pos -", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 apPerp = ab * dot(ab, ap) / dot(ab, ab);\n    vec3 dir = ap - apPerp;\n    float dist = length(dir);\n    return dist - r;\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 apPerp = ab * dot(ab, ap) / dot(ab, ab);\n    vec3 dir = ap - apPerp;\n    float dist = length(dir);\n    float r = mix(r1, r2, dot(ab, ap) / dot(ab, ab));\n    return dist - r;\n}\n\n// arbitrary orientation\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 apPerp = ab * dot(ab, ap) / dot(ab, ab);\n    vec3 dir = ap - apPerp;\n    float dist = length(dir);\n    float r = mix(r1, r2, dot(ab, ap) / dot(ab, ab));\n    return max(dist - r, -length(apPerp));\n}\n\n// arbitrary orientation\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float r)\n{\n    return sdCappedCone(p, a, b, r, r);\n}\n\n// returns distance and orientation\nvec2 sdCappedCone(vec3 p, vec3 a, vec3 b, float r1, float r2, out vec3 orientation)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 apPerp = ab * dot(ab, ap) / dot(ab, ab);\n    vec3 dir = ap - apPerp;\n    float dist = length(dir);\n    float r = mix", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ), min( min( t2.x, t2.y ), t2.z ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n    return length(ro-rd)-rad;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 h )\n{\n    vec2 d = vec2( length(rd.xz), rd.y );\n    vec2 c = (vec2(length(ro.xz),ro.y) - h)/d;\n    return max(abs(c.x),abs(c.y)) - c.y*c.y/(d.x*d.x + d.y*d.y);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 n )\n{\n    return dot(rd,n.xyz) + n.w;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 c )\n{\n    // c must be normalized\n    float q = length(rd.xy);\n    return sign(rd.y)*(q*q/(c.x*c.x) - c.y*c.y + 2.0*rd.z*rd.y/c.x);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iC", "\n    return (coord + 1.0) / 2.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return (coord + 1.0) / 2.0 * size;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return (coord + 1.0) / 2.0 * size + offset;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord + 1.0) / 2.0 * size * scale + offset;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation) {\n    vec2 uv = (coord + 1.0) / 2.0 * size * scale + offset;\n    float s = sin(rotation);\n    float c = cos(rotation);\n    mat2 rotation_matrix = mat2(c, -s, s, c);\n    return rotation_matrix * uv;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation, vec2 origin) {\n    vec2 uv = (coord + 1.0) / 2.0 * size * scale + offset;\n    float s = sin(rotation);\n    float c = cos(rotation);\n    mat2 rotation_matrix = mat2(c, -s, s, c);\n    return rotation_matrix * (uv - origin) + origin;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation, vec2 origin, vec2 origin_offset) {\n    vec2 uv = (coord + 1.0) / 2.0 * size * scale + offset;\n    float s = sin(rotation);\n    float c = cos(rot", "\n    vec2 pq = q - p;\n    vec2 pp = p - p;\n    vec2 v = vec2( pq.y, -pq.x );\n    float c = dot( v, pp );\n    float b = dot( v, pq );\n    float a = length( pq ) * length( pp ) - b * b;\n    float k = sign( a ) * ( 1.0 + sqrt( abs( a / ( b * b ) ) ) );\n    vec2 r = vec2( k * b, k * ( k * b - a ) ) / length( pq );\n    return vec3( r.x, r.y, r.y / r.x );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleEquilateral( in vec2 p, in vec2 q, in vec2 r )\n{\n    vec2 pq = q - p;\n    vec2 pr = r - p;\n    vec2 v = vec2( pq.y, -pq.x );\n    float c = dot( v, pr );\n    float b = dot( v, pq );\n    float a = length( pq ) * length( pr ) - b * b;\n    float k = sign( a ) * ( 1.0 + sqrt( abs( a / ( b * b ) ) ) );\n    vec2 rr = vec2( k * b, k * ( k * b - a ) ) / length( pq );\n    return vec3( rr.x, rr.y, rr.y / rr.x );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 q, in vec2 r )\n", "\n    float f = length(p) - r;\n    float dfdx = p.x / length(p);\n    float dfdy = p.y / length(p);\n    return vec3(f, dfdx, dfdy);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipsoid(vec2 p, vec2 r)\n{\n    float f = length(p / r) - 1.0;\n    float dfdx = p.x / r.x / length(p / r);\n    float dfdy = p.y / r.y / length(p / r);\n    return vec3(f, dfdx, dfdy);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHyperbola(vec2 p, float a, float b)\n{\n    float f = (a * a - b * b) / (a * a + b * b) * (p.x * p.x + p.y * p.y) - a * a * p.x * p.y / (a * a + b * b);\n    float dfdx = 2.0 * p.x * (a * a - b * b) / (a * a + b * b) * p.x - a * a * p.y / (a * a + b * b);\n    float dfdy = 2.0 * p.y * (a * a - b * b) / (a * a + b * b) * p.y - a * a * p.x / (a * a + b * b);\n    return vec3(f, dfdx, dfdy);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec2 q = p*c.yx;\n    float d = length( q ) - r*c.x;\n    float g = sqrt( 1.0 - c.x*c.x );\n    vec2  n = q/abs( d )*g;\n    return vec3( d, n );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float d )\n{\n    vec2 q = p*c.yx;\n    float d2 = length( q ) - r*c.x;\n    float g = sqrt( 1.0 - c.x*c.x );\n    vec2  n = q/abs( d2 )*g;\n    return vec3( d2, n );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float d, in float e )\n{\n    vec2 q = p*c.yx;\n    float d2 = length( q ) - r*c.x;\n    float g = sqrt( 1.0 - c.x*c.x );\n    vec2  n = q/abs( d2 )*g;\n    return vec3( d2, n );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c", "\n    vec3 b = vec3( v[1].x - v[0].x, v[2].x - v[0].x, v[0].x - p.x );\n    vec3 d = vec3( v[1].y - v[0].y, v[2].y - v[0].y, v[0].y - p.y );\n    vec3 f = vec3( 1.0, 1.0, -1.0 );\n    vec3 a = cross( b, d ) * f;\n    return vec3( dot( a, vec3( v[0].xy, 1.0 ) ),\n                 dot( a, vec3( v[1].xy, 1.0 ) ),\n                 dot( a, vec3( v[2].xy, 1.0 ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTriangle( in vec3 p, in vec3 v[3] )\n{\n    vec3 b = vec3( v[1].x - v[0].x, v[2].x - v[0].x, v[0].x - p.x );\n    vec3 d = vec3( v[1].y - v[0].y, v[2].y - v[0].y, v[0].y - p.y );\n    vec3 f = vec3( 1.0, 1.0, -1.0 );\n    vec3 a = cross( b, d ) * f;\n    return vec4( dot( a, vec3( v[0].xy, 1.0 ) ),\n                 dot( a, vec3( v[1].xy, 1.0 ) ),\n                 dot( a, vec3( v[2].xy, 1.0 ) ),\n                 dot( a, vec3( p.xy, 1.0 ) ) );\n}\n\n//.x = f(", "\n    vec2 q = p*sca;\n    float d = length(q);\n    float s = (d<ra+rb && d>fabs(ra-rb));\n    float a = atan(q.x,q.y);\n    float b = atan(rb*q.y,rb*q.x);\n    float c = atan(ra*q.y,ra*q.x);\n    float t = abs(a-b);\n    float u = abs(a-c);\n    float v = abs(b-c);\n    float w = abs(t-u);\n    float x = abs(t-v);\n    float y = abs(u-v);\n    float z = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(", "\n  return a.x * b.y - a.y * b.x;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cros( in vec3 a, in vec3 b ) {\n  return a.x * b.y - a.y * b.x + a.z * b.w - a.w * b.z;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cros( in vec4 a, in vec4 b ) {\n  return a.x * b.y - a.y * b.x + a.z * b.w - a.w * b.z;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cros( in vec4 a, in vec3 b ) {\n  return a.x * b.y - a.y * b.x + a.z * b.z - a.w * b.y;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cros( in vec3 a, in vec4 b ) {\n  return a.x * b.y - a.y * b.x + a.z * b.w - a", "\n    vec2 q = p / ab;\n    float l = length(q);\n    return vec3( l, q * (l - 1.0), 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipticParaboloid( vec2 p, in vec2 ab )\n{\n    vec2 q = p / ab;\n    float l = length(q);\n    return vec3( l * l, q * (2.0 * l - 1.0), 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHyperbolicParaboloid( vec2 p, in vec2 ab )\n{\n    vec2 q = p / ab;\n    float l = length(q);\n    return vec3( l * l, q * (2.0 * l + 1.0), 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHyperbolicParaboloid( vec2 p, in vec2 ab, in float c )\n{\n    vec2 q = p / ab;\n    float l = length(q);\n    return vec3( l * l - c * c, q * (2.0 * l + 1.0), 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3", "\n    vec4 d;\n    d.x = length( vec2( length( p.xz ) - ra, p.y ) ) - rb;\n    d.y = length( vec2( length( p.xz ) - ra, p.y ) ) - rb;\n    d.z = length( vec2( length( p.xz ) - ra, p.y ) ) - rb;\n    d.w = length( vec2( length( p.xz ) - ra, p.y ) ) - rb;\n    return d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n    vec4 d;\n    d.x = length( vec2( p.x, p.z ) ) - ra;\n    d.y = p.x;\n    d.z = p.z;\n    d.w = length( vec2( p.x, p.z ) ) - rb;\n    return d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n    vec4 d;\n    d.x = length( vec2( p.x, p.z ) ) - ra;\n    d.y = p.x;\n    d.z = p.z;\n    d.w = length( vec2( p.x, p.z ) ) - rb;\n    return d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( length(pa - ba*h) - r,\n                length(vec3(h,h,h) - vec3(1.0,1.0,1.0)) - 1.0,\n                dot(pa - ba*h, ba) - r,\n                dot(pa - ba*h, ba) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( length(p) - r,\n                length(vec3(1.0,1.0,1.0)) - 1.0,\n                dot(p, vec3(1.0,1.0,1.0)) - r,\n                dot(p, vec3(1.0,1.0,1.0)) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return vec4( length(q) - t.y,\n                length(vec2(1.0,1.0)) - 1.0,\n                dot(vec2(q.x,q.y), vec2(1.0,1.0)) - t.y,\n                dot(vec2(q.x,q.y), vec2(1.0,1.0", "\n    float wi2 = wi/2.0;\n    float he2 = he/2.0;\n    float k = (wi2 + he2*sk)/wi;\n    vec2 q = vec2(wi*p.x, k*p.x*p.y);\n    return max(abs(q.x)-wi2, abs(q.y)-he2*sk);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    float wi2 = wi/2.0;\n    float he2 = he/2.0;\n    float k = (wi2 + he2*sk)/wi;\n    vec2 q = vec2(wi*p.x, k*p.x*p.y);\n    return max(abs(q.x)-wi2, abs(q.y)-he2*sk);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    float wi2 = wi/2.0;\n    float he2 = he/2.0;\n    float k = (wi2 + he2*sk)/wi;\n    vec2 q = vec2(wi*p.x, k*p.x*p.y);\n    return max(abs(q.x)-wi2, abs(q.y)-he2*sk);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{\n    float wi2 = wi/2.0;\n    float he2 = he/2.0;\n    float k = (wi2 + he2*sk)/wi;\n    vec2 q = vec2(wi*p.x, k*p.x*p.y);\n    return max(abs(q.x)-wi2, abs(", "\n    vec2 q = p - vec2( 0.5, 0.5 );\n    float d = length( q );\n    float a = atan( q.y, q.x );\n    float f = a - sk * d;\n    float g = ( 1.0 - cos( f ) ) / 2.0;\n    return vec3( f, g * q.x, -g * q.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs( p );\n    q.x -= 0.5;\n    float d = ( q.y + 0.866025 * q.x );\n    float a = atan( q.y, q.x );\n    float f = a - sk * d;\n    float g = ( 1.0 - cos( f ) ) / 2.0;\n    return vec3( f, g * q.x, -g * q.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgOctagon( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = abs( p );\n    q.x -= 0.5;\n    float d = ( q.y + 0.57735 * q.x );\n    float a = atan( q.y, q.x );\n    float f = a - sk * d;\n    float g = ( 1.0 - cos( f ) ) / 2.0;\n    return vec3( f, g * q.x, -g * q.y );\n}\n\n//.x = f(", "\n\tfloat r = 0.0;\n\tfor( int i=0; i<c; i++ )\n\t\t{\n\t\tr += p;\n\t\t}\n\treturn r;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\tvec2 r = vec2( 0.0 );\n\tfor( int i=0; i<c.x; i++ )\n\t\t{\n\t\tfor( int j=0; j<c.y; j++ )\n\t\t\t{\n\t\t\tr += p;\n\t\t\t}\n\t\t}\n\treturn r.x + r.y;\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\tvec3 r = vec3( 0.0 );\n\tfor( int i=0; i<c.x; i++ )\n\t\t{\n\t\tfor( int j=0; j<c.y; j++ )\n\t\t\t{\n\t\t\tfor( int k=0; k<c.z; k++ )\n\t\t\t\t{\n\t\t\t\tr += p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn r.x + r.y + r.z;\n\t}\n\n//----------oPeraciones de Rotacion\nvec2 opRot2D( vec2 p, float a )\n\t{\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn vec2( p.x*c - p.y*s, p.x*s + p.y*c );\n\t}\n\nvec3 opRot3D( vec3 p, float a )\n\t{\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn vec3( p.x*c - p.y*s, p.x*s + p.y*c, p.z );\n\t}\n\n//----------oPeraciones de Translacion\nvec2 opTrans2D( vec2 p, vec2 t )\n\t{\n\treturn p + t;\n\t}\n\nvec3 opTrans3D( vec3 p,", "\n    return -a * pow(k, 3.0) + 2.0 * b * pow(k, 2.0) - k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return -a * pow(k, 3.0) + b * pow(k, 2.0) + k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float k) {\n    return a * pow(k, 3.0) - b * pow(k, 2.0) + c * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float k) {\n    return -a * pow(k, 3.0) + b * pow(k, 2.0) - c * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float k) {\n    return a * pow(k, 4.0) - b * pow(k, 3.0) + c * pow(k, 2.0) - d * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float k) {\n    return -a * pow(k, 4.0) + b * pow(k, 3.0) - c * pow(k, 2.0) + d * k;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float c, float d, float e, float k) {\n    return a * pow(k, 5.0) - b * pow(k, 4.0) + c * pow(k, 3.0) - d * pow(k, 2.0) + e * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float c, float d, float e, float k) {\n    return", "\n  vec2 c = floor(p / size) * size;\n  p = mod(p, size) - size * 0.5;\n  return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size * 0.5;\n  vec2 c = floor((p + halfsize) / size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c, vec2(2.)) * 2. - vec2(1.);\n  return c;\n}\n\nvec2 modGrid2(inout vec2 p, vec2 size) {\n  vec2 c = floor(p / size);\n  p = mod(p, size) - size * 0.5;\n  return c;\n}\n\nvec2 modPolar2(inout vec2 p, float size) {\n  float angle = 2. * PI / size;\n  float a = atan(p.y, p.x) + angle / 2.;\n  float r = length(p);\n  float c = floor(a / angle);\n  a = mod(a, angle) - angle / 2.;\n  p = vec2(cos(a), sin(a)) * r;\n  return c;\n}\n\nvec2 modHex2(inout vec2 p, float size) {\n  float angle = 2. * PI / 3.;\n  float a = atan(p.y, p.x) + angle / 2.;\n  float r = length(p);\n  float c = floor(a / angle);\n  a = mod(a, angle) - angle / 2.;\n  p = vec2(cos(a), sin(a)) * r;\n  return c;\n}\n\nvec2 modTile2(inout vec2 p, vec2 size) {\n  vec2 c = floor(p / size);\n  p = mod(p, size);\n  return c;\n}\n\nvec2 modTile2(inout vec2 p, vec2 size, float offset) {\n  vec2 c = floor(p /", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c, float s, float v) {\n    return hsv2rgb(vec3(c.x, c.y * s, c.z * v));\n}\n\nvec3 rgb2hsv(vec3 c, float s, float v) {\n    return rgb2hsv(vec3(c.x, c.y * s, c.z * v));\n}\n\nvec3 hsv2rgb(vec3 c, float s) {\n    return hsv2rgb(vec3(c.x, c.y * s, c.z));\n}\n\nvec3 rgb2hsv(vec3", "\n  vec3 oc = ro - s.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - s.w * s.w;\n  float h = b * b - c;\n  if (h < 0.0) return vec2(-1.0);\n  return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, vec3 boxCenter) {\n  vec3 m = 1.0 / rd;\n  vec3 n = m * ro;\n  vec3 k = abs(m) * boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n  if (tN > tF || tF < 0.0) return vec2(-1.0);\n  return vec2(tN, tF);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize) {\n  vec3 m = 1.0 / rd;\n  vec3 n = m * ro;\n  vec3 k = abs(m) * boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max(max(t1.x, t1.y), t1.z);\n  float tF = min(min(t2.x, t2.y), t2.z);\n  if (tN > tF || tF < 0.0) return vec2(-1.0);\n  return vec2(tN, tF);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, vec3 boxCenter, out vec3 normal) {\n  vec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    outNormal = -sign(rd) * step(t1.yzx, t1) * step(t1.zxy, t1);\n    return vec2(tN, tF);\n}\n\n// IQ's ray sphere intersection\nfloat raySphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRadius) {\n    vec3 oc = ro - sphPos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sphRadius * sphRadius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec3 planePos, vec3 planeNormal) {\n    return dot(planeNormal, (ro - planePos)) / dot(planeNormal, rd);\n}\n\n// IQ's ray triangle intersection\nfloat rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 outNormal) {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float a = dot(e1, p);\n    if (a > -0.00001 && a < 0.00001) return -1.0;\n    float f = 1.0 / a;\n", "\n    vec2 d2 = d * 0.5;\n    vec2 p2 = p * 0.5;\n    vec2 p3 = p - d2;\n    vec2 p4 = p + d2;\n    e1 = vec2(p3.x, p2.y);\n    e2 = vec2(p4.x, p2.y);\n    e3 = vec2(p4.x, p4.y);\n    e4 = vec2(p3.x, p4.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n    vec2 d2 = d * 0.5;\n    vec2 p2 = p * 0.5;\n    vec2 p3 = p - d2;\n    vec2 p4 = p + d2;\n    e1 = vec2(p3.x, p2.y);\n    e2 = vec2(p4.x, p2.y);\n    e3 = vec2(p4.x, p4.y);\n    e4 = vec2(p3.x, p4.y);\n    e5 = vec2(p3.x, p3.y);\n    e6 = vec2(p4.x, p3.y);\n    e7 = vec2(p4.x, p4.y);\n    e8 = vec2(p3.x, p4.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge16(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, c);\n    float d3 = linedist(p, c, d);\n    float d4 = linedist(p, d, a);\n    return min(min(min(d1, d2), d3), d4);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, c);\n    float d3 = linedist(p, c, d);\n    float d4 = linedist(p, d, e);\n    float d5 = linedist(p, e, f);\n    float d6 = linedist(p, f, a);\n    return min(min(min(min(min(d1, d2), d3), d4), d5), d6);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h) {\n    float d1 = linedist(p, a, b);\n    float d2 = linedist(p, b, c);\n    float d3 = linedist(p, c, d);\n    float d4 = linedist(p, d, e);\n    float d5 = linedist(p, e, f);\n    float d6 = linedist(p, f, g);\n    float d7 = linedist(p, g, h);\n    float d8 = linedist(p, h, a);", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( h ) - w1*h*h*h;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec3 p, vec3 a, vec3 b, float w1, float w2 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( h ) - w1*h*h*h;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float t )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( h ) - w1*h*h*h + t*w2*h*h*h;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec3 p, vec3 a, vec3 b, float w1, float w2, float t )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( h ) - w1*h*h*h + t*w2*h*h*h;\n}\n\n", "\n    vec3 oc = ro - vec3(0.0, 0.0, 0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - tor.x * tor.x;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return (-b - h) / length(rd);\n}\n\nfloat raySphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return (-b - h) / length(rd);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n    return (-dot(n, ro) - d) / dot(n, rd);\n}\n\nfloat rayBox(vec3 ro, vec3 rd, vec3 boxSize) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return -1.0;\n    return tN;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float maxDist, float minDist, float maxSteps, float minSteps, float stepSize, float epsilon, float epsilon2, float epsilon3, float epsilon4, float epsilon5, float epsilon6, float epsilon7, float epsilon8, float epsilon9, float epsilon10, float epsilon", "\n    vec3 e = vec3(pos.x, pos.y - tor.y * 2.0, pos.z);\n    vec3 n = e - vec3(tor.x * cos(pos.z * 6.28318530718), tor.y * 2.0, tor.x * sin(pos.z * 6.28318530718));\n    return normalize(n);\n}\n\nvec3 torus(vec3 pos, vec2 tor) {\n    vec3 p = pos;\n    p.xz = mod(p.xz, tor) - tor * 0.5;\n    return p;\n}\n\nfloat torusDist(vec3 pos, vec2 tor) {\n    return length(pos.xz) - tor.x;\n}\n\nfloat torusDist(vec3 pos, vec2 tor, out vec3 normal) {\n    normal = torusNormal(pos, tor);\n    return torusDist(pos, tor);\n}\n\nfloat torusDist(vec3 pos, vec2 tor, out vec3 normal, out vec2 uv) {\n    normal = torusNormal(pos, tor);\n    uv = vec2(atan(pos.x, pos.z), pos.y);\n    return torusDist(pos, tor);\n}\n\nfloat torusDist(vec3 pos, vec2 tor, out vec3 normal, out vec2 uv, out vec3 pos2) {\n    normal = torusNormal(pos, tor);\n    uv = vec2(atan(pos.x, pos.z), pos.y);\n    pos2 = torus(pos, tor);\n    return torusDist(pos, tor);\n}\n\nfloat torusDist(vec3 pos, vec2 tor, out vec3 normal, out vec2 uv, out vec3 pos2, out vec3 pos3) {\n    normal = torusNormal(pos, tor);\n    uv = vec2(atan(pos.x, pos.z), pos.y);\n    pos2 = torus(pos, tor);\n    pos3 = pos;\n    return torusDist(pos, tor", "\n    return (exp(2.0*x) - 1.0) / (exp(2.0*x) + 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_prime(float x) {\n    return sigmoid(x) * (1.0 - sigmoid(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu(float x) {\n    return max(0.0, x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu_prime(float x) {\n    return float(x > 0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu(float x) {\n    return max(0.01*x, x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu_prime(float x) {\n    return float(x > 0.0) + float(x <= 0.0) * 0.01;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat elu(float x) {\n    return x >= 0.0? x : exp(x) - 1.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat elu_prime(float x) {\n    return x >= 0.0? 1.0 : exp(x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat selu(float x) {\n    return 1.0507 * (x >= 0.0? x : exp(x) - 1.0);\n}\n\n// License: Unknown, author: Unknown, found", "\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 uv = p;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = 0.5 * (sin(1.5 * a) + sin(1.5 * a + PI));\n    col = mix(col, vec3(f), 0.5);\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 uv = p;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = 0.5 * (sin(1.5 * a) + sin(1.5 * a + PI));\n    col = mix(col, vec3(f), 0.5);\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 uv = p;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = 0.5 * (sin(1.5 * a) + sin(1.5 * a + PI));\n    col = mix(col, vec3(f), 0.5);\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.", "\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  if (c.x + c.y > 1.0) {\n    p.y = -p.y;\n    c.y = 1.0 - c.y;\n  }\n  return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  p *= mod2(c, vec2(2.0));\n  return c;\n}\n\nvec2 modGrid2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  p *= mod2(c, vec2(2.0));\n  return c;\n}\n\nvec2 modHex2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  p *= mod2(c, vec2(1.7320508075688772935274463415059));\n  return c;\n}\n\nvec2 modTri2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  p *= mod2(c, vec2(1.7320508075688772935274463415059));\n  return c;\n}\n\nvec2 modQuad2(inout vec2 p, vec2 size", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 2; ++i) {\n        v += a * noise(uv);\n        uv = rot * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec3 uv) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(uv.xy);\n        uv = uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec2 uv, float", "\n    return length(p-c) - r;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 c, in vec2 s )\n{\n    vec2 d = abs(p - c) - s;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 c, in vec2 s, in float r )\n{\n    vec2 d = abs(p - c) - s;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// signed distance to a polygon\nfloat sdPolygon( in vec2 p, in vec2 c, in float r, in int n )\n{\n    float a = atan(p.x, p.y) + PI;\n    float da = PI * 2.0 / float(n);\n    return sdCircle(p, c, r) * cos(floor(0.5 + a / da) * da - a);\n}\n\n// signed distance to a star\nfloat sdStar( in vec2 p, in vec2 c, in float r1, in float r2, in int n )\n{\n    float a = atan(p.x, p.y) + PI;\n    float da = PI * 2.0 / float(n);\n    return sdCircle(p, c, r2) * cos(floor(0.5 + a / da) * da - a) - r1;\n}\n\n// signed distance to a heart\nfloat sdHeart( in vec2 p, in vec2 c, in float r )\n{\n    p = p - c;\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    p = mat2", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 m )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    m = a + ba*h;\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b, out vec3 m )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    m = a + ba*h;\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out float m )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    m = h;\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b, out float m )\n{\n    vec3 pa = p-a, ba = b-a;\n   ", "\n    return max(dot(a, b), 0.0);\n}\n\nfloat cros(in vec2 a, in vec2 b ) {\n    return max(dot(a, b), 0.0) * sign(b.x * a.y - b.y * a.x);\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    vec2 cb = c - b;\n    vec2 pb = p - b;\n    vec2 ac = a - c;\n    vec2 pc = p - c;\n    vec2 nor = cross(ba, ac);\n\n    return sqrt(\n        (signed(cros(ba, nor) * pa.x + cros(cb, nor) * pb.x + cros(ac, nor) * pc.x) * signed(cros(ba, nor))) /\n        (dot(ba, ba) * dot(ac, ac))\n    ) * sign(cros(ba, nor));\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r) {\n    return max(\n        sdTriangle(p, a, b, c),\n        -r\n    );\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float d) {\n    return max(\n        sdTriangle(p, a, b, c),\n        -r - d\n    );\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float d, in float e) {\n    return max(\n        sdTriangle(p, a, b, c),\n        -r - d - e\n    );\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r, in float d, in float e, in float f) {\n    return max(\n", "\n    p = abs(p);\n    p = (p.x>p.y)? p.yx : p.xy;\n    p -= r;\n    p = (p.x>p.y)? p.yx : p.xy;\n    p = (p.x>p.y)? p.yx : p.xy;\n    return length(p)-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float d ) \n{\n    p = abs(p);\n    p = (p.x>p.y)? p.yx : p.xy;\n    p -= r;\n    p = (p.x>p.y)? p.yx : p.xy;\n    p = (p.x>p.y)? p.yx : p.xy;\n    return length(p)-r+d;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float d, in float e ) \n{\n    p = abs(p);\n    p = (p.x>p.y)? p.yx : p.xy;\n    p -= r;\n    p = (p.x>p.y)? p.yx : p.xy;\n    p = (p.x>p.y)? p.yx : p.xy;\n    return length(p)-r+d+e;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float d, in float e, in float f ) \n{\n    p = abs(p);\n    p = (p.x>p.y)? p.yx : p.xy;\n    p -= r;\n    p = (p.x>p.y)? p.yx : p.xy;\n    p = (p.x>p.y)? p.yx : p.xy;\n    return length(p", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 s_curve_oetf(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 s_curve_eotf(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvec3 reinhard_tone_mapping(vec3 x)\n{\n    return x / (1.0 + x);\n}\n\nvec3 reinhard_tone_mapping_oetf(vec3 x)\n{\n    return x / (1.0 + x);\n}\n\nvec3 reinhard_tone_mapping_eotf(vec3 x)\n{\n    return x / (1.0 + x);\n}\n\nvec3 reinhard_tone_mapping_extended(vec3 x, float white_scale)\n{\n    return (x * (1.0 + (x / white_scale))) / (1.0 + x);\n}\n\nvec3 reinhard_tone_mapping_extended_oetf(vec3 x, float white", "\n    return vec3(x.y, x.z, x.x);\n}\n\n// derivative of t-curve\nvec3 d_t_curve(vec3 x)\n{\n    return vec3(x.z, x.x, x.y);\n}\n\n// derivative of h-curve\nvec3 d_h_curve(vec3 x)\n{\n    return vec3(x.x, x.y, x.z);\n}\n\n// derivative of v-curve\nvec3 d_v_curve(vec3 x)\n{\n    return vec3(x.y, x.z, x.x);\n}\n\n// derivative of h-curve\nvec3 d_h_curve(vec3 x)\n{\n    return vec3(x.x, x.y, x.z);\n}\n\n// derivative of v-curve\nvec3 d_v_curve(vec3 x)\n{\n    return vec3(x.y, x.z, x.x);\n}\n\n// derivative of h-curve\nvec3 d_h_curve(vec3 x)\n{\n    return vec3(x.x, x.y, x.z);\n}\n\n// derivative of v-curve\nvec3 d_v_curve(vec3 x)\n{\n    return vec3(x.y, x.z, x.x);\n}\n\n// derivative of h-curve\nvec3 d_h_curve(vec3 x)\n{\n    return vec3(x.x, x.y, x.z);\n}\n\n// derivative of v-curve\nvec3 d_v_curve(vec3 x)\n{\n    return vec3(x.y, x.z, x.x);\n}\n\n// derivative of h-curve\nvec3 d_h_curve(vec3 x)\n{\n    return vec3(x.x, x.y, x.z);\n}\n\n// derivative of v-curve\nvec3 d_v_curve(vec3 x)\n{\n    return vec3(x.y, x.z, x.x", "\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral2( in vec2 p, float w, in float k )\n{\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral3( in vec2 p, float w, in float k )\n{\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral4( in vec2 p, float w, in float k )\n{\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral5( in vec2 p, float w, in float k )\n{\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral6( in vec2 p, float w, in float k )\n{\n    float a = atan(p.x,p.y) + PI;\n    float r = length(p);\n    return r * cos(a * k) - w * a;\n}\n\n// w is the width / distance from center to tip\n//", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float maxTransmittance)\n{\n    return min(exp(-opticalDepth), maxTransmittance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance)\n{\n    return min(exp(-opticalDepth), maxTransmittance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance, float maxTransmittanceScale)\n{\n    return min(exp(-opticalDepth), maxTransmittance * maxTransmittanceScale);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance, vec3 maxTransmittanceScale)\n{\n    return min(exp(-opticalDepth), maxTransmittance * maxTransmittanceScale);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance, vec3 maxTransmittanceScale, float maxTransmittanceScaleFactor)\n{\n    return min(exp(-opticalDepth), maxTransmittance * maxTransmittanceScale * maxTransmittanceScaleFactor);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance, vec3 maxTransmittanceScale, vec3 maxTransmittanceScaleFactor)\n{\n    return min(exp(-opticalDepth), maxTransmittance * maxTransmittanceScale * maxTransmittanceScaleFactor);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 maxTransmittance, vec3 maxTransmittanceScale, vec3 maxTransmittanceScaleFactor, float maxTransmittanceScaleFactorFactor)\n{\n   ", "\n    // Calculate the optical depth for the ray.\n    // This is the amount of light that is scattered along the ray.\n    float opticalDepth = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        // Calculate the current position along the ray.\n        vec3 rayPos = rayStart + rayDir * t;\n\n        // Calculate the distance to the next scattering point.\n        float scatteringDistance = GetScatteringDistance(rayPos, lightDir);\n\n        // If we are past the end of the ray, we can stop.\n        if (t + scatteringDistance > rayLength)\n        {\n            break;\n        }\n\n        // Calculate the optical depth for the current step.\n        opticalDepth += scatteringDistance * GetScattering(rayPos, lightDir);\n\n        // Move along the ray.\n        t += scatteringDistance;\n    }\n\n    // Calculate the transmittance for the ray.\n    transmittance = exp(-opticalDepth * lightColor);\n\n    // Calculate the scattering for the ray.\n    return opticalDepth * lightColor;\n}\n\n// Integrate scattering over a ray for a single directional light source.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor)\n{\n    vec3 transmittance;\n    return IntegrateScattering(rayStart, rayDir, rayLength, lightDir, lightColor, transmittance);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance, out vec3 scattering)\n{\n    // Calculate the optical depth for the ray.\n    // This is the amount of light that is scattered along the ray.\n    float opticalDepth = 0.0;\n    float t = 0.0", "\n    vec3 p = p2;\n    p.y -= d;\n    float r = ra - rb;\n    float a = dot(p,p);\n    float b = 2.0*dot(p,p2);\n    float c = dot(p2,p2) - r*r;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-b - h)/(2.0*a);\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d, out vec3 p )\n{\n    p = p2;\n    p.y -= d;\n    float r = ra - rb;\n    float a = dot(p,p);\n    float b = 2.0*dot(p,p2);\n    float c = dot(p2,p2) - r*r;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-b - h)/(2.0*a);\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d, out vec3 p, out vec3 n )\n{\n    p = p2;\n    p.y -= d;\n    float r = ra - rb;\n    float a = dot(p,p);\n    float b = 2.0*dot(p,p2);\n    float c = dot(p2,p2) - r*r;\n    float h = b*b - 4.0*a*c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t =", "\n    float d = length( p ) - r;\n    return max( d, abs( p.y ) - h ) - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, out float d )\n{\n    d = length( p ) - r;\n    return max( d, abs( p.y ) - h ) - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, out float d, out vec3 n )\n{\n    d = length( p ) - r;\n    n = normalize( p );\n    return max( d, abs( p.y ) - h ) - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, out float d, out vec3 n, out float m )\n{\n    d = length( p ) - r;\n    n = normalize( p );\n    m = max( d, abs( p.y ) - h );\n    return m - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, out float d, out vec3 n, out float m, out float a )\n{\n    d = length( p ) - r;\n    n = normalize( p );\n    m = max( d, abs( p.y ) - h );\n    a = m - t;\n    return a;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t, out float d, out vec3 n, out float m", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\n// https://www.shadertoy.com/view/4tK3z2\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n// https://www.shadertoy.com/view/4tK3z2\nvec3 calcNormal_fast( in vec3 pos )\n{\n    vec3 nor = vec3", "\n    return length( p ) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in float d )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 d )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 d, in float e )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 d, in vec3 e )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 d, in vec3 e, in float f )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 d, in vec3 e, in vec3 f )\n{\n    return length( p ) - r - h.y;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r,", "\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0)", "\n    float d = length(p) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\n    float d = length(p) - r;\n    d = max(d, p.y - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec2 p, in float r, in float h )\n{\n    float d = length(p) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec3 p, in float r, in float h )\n{\n    float d = length(p.xy) - r;\n    d = max(d, p.z - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec3 p, in float r, in float h )\n{\n    float d = length(p.xy) - r;\n    d = max(d, abs(p.z) - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec3 p, in float r, in float h, in float c )\n{\n    float d = length(p.xy) - r;\n    d = max(d, p.z - h);\n    d = max(d, -p.z - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec3 p, in float r, in float h, in float c )\n{\n    float d = length(p.xy) - r;\n    d = max(d, abs(p.z) - h);\n    d = max(d, -abs(p.z) - h);\n    return d;\n}\n\n// r=radius, h=height\nfloat sdCutCone( in", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 3d fractal noise function\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3d fractal noise function\nfloat fbm( vec3 p, int octaves )\n{\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < octaves; i++) {\n        f += amp*noise( p );\n        amp *= 0.5;\n        p = p*2.02;\n    }\n    return f;\n}\n\n// 3d fractal noise function\nfloat fbm( vec3 p, float lacunarity, float gain )\n{\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0;", "\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p * 2.02;\n    f += 0.2500 * noise( p ); p = p * 2.03;\n    f += 0.1250 * noise( p ); p = p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float lacunarity, float gain )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p * lacunarity;\n    f += 0.2500 * noise( p ); p = p * lacunarity;\n    f += 0.1250 * noise( p ); p = p * lacunarity;\n    f += 0.0625 * noise( p );\n    return f * gain;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float lacunarity, float gain, int octaves )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p * lacunarity;\n    f += 0.2500 * noise( p ); p = p * lacunarity;\n    f += 0.1250 * noise( p ); p = p * lacunarity;\n    f += 0.0625 * noise( p );\n    return f * gain;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float lacunarity, float gain, int octaves, float offset )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p + offset ); p = p * lacunarity;\n    f += 0.2500", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash21(vec2 p2)\n{\n    p2 = fract(p2 * vec2(.1031,.1030));\n    p2 += dot(p2, p2.yx+19.19);\n    return fract((p2.x + p2.y) * p2.y);\n}\n\n//value noise hash\nfloat hash11(float p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p);\n    return fract(p * p);\n}\n\n//value noise hash\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\n//value noise hash\nvec2 hash22(vec2 p2)\n{\n    p2 = fract(p2 * vec2(.1031,.1030));\n    p2 += dot(p2, p2.yx+19.19);\n    return fract((p2.xx + p2.yx) * p2.xy);\n}\n\n//value noise hash\nvec2 hash23(vec2 p2)\n{\n    p2 = fract(p2 * vec2(.1031,.1030));\n    p2 += dot(p2, p2.yx+19.19);\n    return fract((p2.xx + p2.yx) * p2.yx);\n}\n\n//value", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// https://www.shadertoy.com/view/MdX3zr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This shader is a port of the original GLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n// This shader is a port of the original HLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n// This shader is a port of the original C shader by Inigo Quilez\n// https://www.iquilezles.org/apps/shadertoy/\n\n// This shader is a port of the original GLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n// This shader is a port of the original HLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n// This shader is a port of the original C shader by Inigo Quilez\n// https://www.iquilezles.org/apps/shadertoy/\n\n// This shader is a port of the original GLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n// This shader is a port of the original HLSL shader by Inigo Quilez\n// https://www.shadertoy.com/view/MdX3zr\n\n", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c, float saturation) {\n    return hsv2rgb(vec3(c.x, c.y * saturation, c.z));\n}\n\nvec3 rgb2hsv(vec3 c, float saturation) {\n    return rgb2hsv(vec3(c.x, c.y * saturation, c.z));\n}\n\nvec3 hsv2rgb(vec3 c, float saturation, float value) {\n    return hsv2rgb(vec3(c.x, c.y * saturation, c.z * value));\n}\n\nvec3 rgb2hsv(vec3 c", "\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return abs(c);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n       ", "\n    return fract(sin(co * 123.123) * 43758.5453);\n}\n\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    float a = hash(i.x + hash(i.y));\n    float b = hash(i.x + i.y + 1.0);\n    float c = hash(i.x + 1.0 + hash(i.y));\n    float d = hash(i.x + 1.0 + i.y + 1.0);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 co) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 4; i++) {\n        value += noise(co) * scale;\n        co *= 2.0;\n        scale *= 0.5;\n    }\n    return value;\n}\n\nfloat fbm(vec3 co) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 4; i++) {\n        value += noise(co.xy) * scale;\n        co *= 2.0;\n        scale *= 0.5;\n    }\n    return value;\n}\n\nfloat fbm(vec2 co, float lacunarity, float gain) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 4; i++) {\n        value += noise(co) * scale;\n        co *= lacunarity;\n        scale *= gain;\n    }\n    return value;\n}\n\nfloat", "\n    return t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec3 sRGB(vec3 c) {\n    return vec3(sRGB(c.r), sRGB(c.g), sRGB(c.b));\n}\n\nvec3 sRGB(vec4 c) {\n    return vec3(sRGB(c.r), sRGB(c.g), sRGB(c.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linearizeDepth(float depth, float zNear, float zFar) {\n    return 2.0 * zNear * zFar / (zFar + zNear - (2.0 * depth - 1.0) * (zFar - zNear));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linearDepth(float depth, float zNear, float zFar) {\n    return (2.0 * zNear * zFar) / (zFar + zNear - (2.0 * depth - 1.0) * (zFar - zNear));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linearDepth(vec2 depth, float zNear, float zFar) {\n    return (2.0 * zNear * zFar) / (zFar + zNear - (2.0 * depth.x - 1.0) * (zFar - zNear));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/Ndf", "\n    vec3 a = c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n    return mix(a, c * 12.92, step(vec3(0.0031308), c));\n}\n\nvec3 linearToSRGB(in vec3 c) {\n    vec3 a = c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n    return mix(a, c * 12.92, step(vec3(0.0031308), c));\n}\n\nvec3 sRGBToLinear(in vec3 c) {\n    vec3 a = c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n    return mix(a, c * 12.92, step(vec3(0.0031308), c));\n}\n\nvec3 sRGBToLinear(in vec3 c, in float gamma) {\n    return pow(c, vec3(gamma));\n}\n\nvec3 linearToSRGB(in vec3 c, in float gamma) {\n    return pow(c, vec3(1.0 / gamma));\n}\n\nvec3 sRGBToLinear(in vec3 c, in float gamma, in float gamma2) {\n    return pow(c, vec3(gamma2 / gamma));\n}\n\nvec3 linearToSRGB(in vec3 c, in float gamma, in float gamma2) {\n    return pow(c, vec3(gamma / gamma2));\n}\n\nvec3 sRGBToLinear(in vec3 c, in float gamma, in float gamma2, in float gamma3) {\n    return pow(c, vec3(gamma3 / gamma2 / gamma));\n}", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin/\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin/\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin/\nfloat pmax(float a, float b, float k, out float h) {\n    h = clamp(0.5 - 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iqu", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph, float dbuffer) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - dbuffer * dbuffer;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph) {\n    vec3 oc = ro - sph;\n    float b = dot(oc, rd);\n   ", "\n    vec4 z = p;\n    float r2 = dot(z, z);\n    float r4 = r2 * r2;\n    float r8 = r4 * r4;\n    float r16 = r8 * r8;\n    float r32 = r16 * r16;\n    float r64 = r32 * r32;\n    float r128 = r64 * r64;\n    float r256 = r128 * r128;\n    float r512 = r256 * r256;\n    float r1024 = r512 * r512;\n    float r2048 = r1024 * r1024;\n    float r4096 = r2048 * r2048;\n    float r8192 = r4096 * r4096;\n    float r16384 = r8192 * r8192;\n    float r32768 = r16384 * r16384;\n    float r65536 = r32768 * r32768;\n    float r131072 = r65536 * r65536;\n    float r262144 = r131072 * r131072;\n    float r524288 = r262144 * r262144;\n    float r1048576 = r524288 * r524288;\n    float r2097152 = r1048576 * r1048576;\n    float r4194304 = r2097152 * r2097152;\n    float r8388608 = r4194304 * r4194304;\n    float r16777216 = r8388608 * r8", "\n    vec3 q = abs(p) - r;\n    return vec4( length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),\n                q.x < 0.0? -p.x : p.x,\n                q.y < 0.0? -p.y : p.y,\n                q.z < 0.0? -p.z : p.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec2 r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - r;\n    return vec4( length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                d.x < 0.0? -p.x : p.x,\n                d.y < 0.0? -p.y : p.y,\n                p.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float r1, float r2 )\n{\n    float d1 = -p.y - r1;\n    float d2 = p.y - r2;\n    float r = r2 - r1;\n    float a = r1 * r1 - r2 * r2;\n    float b = p.x * p.x + p.z * p.z;\n    float c = p.x * p.x * r1 * r1 - 2.0 * p.x * p", "\n    return front * front.a + back * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return front * alpha + back * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5, float alpha6) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5, float alpha6, float alpha7) {\n    return front * alpha + back * (1.0 - alpha2);\n}\n\n// License: Unknown,", "\n    return (back * (1.0 - front.a)) + front.rgb * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return (back * (1.0 - front.a)) + front.rgb * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3, float alpha4) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2, float alpha3, float alpha4, float alpha5, float alpha6) {\n    return (back * (1.0 - alpha)) + front.rgb * alpha;\n}\n\n// License:", "\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y);\n}\n\nfloat hex(vec2 p, float r, float d) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d;\n}\n\nfloat hex(vec2 p, float r, float d, float e) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d - e;\n}\n\nfloat hex(vec2 p, float r, float d, float e, float f) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d - e - f;\n}\n\nfloat hex(vec2 p, float r, float d, float e, float f, float g) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d - e - f - g;\n}\n\nfloat hex(vec2 p, float r, float d, float e, float f, float g, float h) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d - e - f - g - h;\n}\n\nfloat hex(vec2 p, float r, float d, float e, float f, float g, float h, float i) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y) - r + d - e - f - g - h - i;\n}\n\nfloat hex(vec2 p, float r, float d, float e, float f, float g, float h, float i, float j) {\n    p =", "\n    v *= 0.6;\n    return clamp((v * (v + 0.0245786) - 0.000090537) / (v * (0.983729) + 0.4329510), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_tonemap(vec3 v) {\n    v *= 0.6;\n    return clamp((v * (v + 0.0245786) / (v * (0.983729) + 0.4329510)) - 0.0245786, 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_filmic(vec3 v) {\n    v *= 0.6;\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_unreal(vec3 v) {\n    v *= 0.6;\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v * (a *", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n            dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n        mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.", "\n    float lambda = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float t = Temp;\n    float t2 = t * t;\n    float t4 = t2 * t2;\n    float t8 = t4 * t4;\n    float t16 = t8 * t8;\n    float t32 = t16 * t16;\n    float t64 = t32 * t32;\n    float t128 = t64 * t64;\n    float t256 = t128 * t128;\n    float t512 = t256 * t256;\n    float t1024 = t512 * t512;\n    float t2048 = t1024 * t1024;\n    float t4096 = t2048 * t2048;\n    float t8192 = t4096 * t4096;\n    float t16384 = t8192 * t8192;\n    float t32768 = t16384 * t16384;\n    float t65536 = t32768 * t32768;\n    float t131072 = t65536 * t65536;\n    float t262144 = t131072 * t131072;\n    float t524288 = t262144 * t262144;\n    float t1048576 = t524288 * t524288;\n    float t2097152 = t1048576 * t1048576;\n    float t4194304 = t2097152 * t2097152;\n    float t8388608 = t4194", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float a = texture(iChannel0, (i+vec2(0.0,0.0))/256.0).x;\n    float b = texture(iChannel0, (i+vec2(1.0,0.0))/256.0).x;\n    float c = texture(iChannel0, (i+vec2(0.0,1.0))/256.0).x;\n    float d = texture(iChannel0, (i+vec2(1.0,1.0))/256.0).x;\n\n    return mix(a, b, u.x) +\n           (c-a)* u.y * (1.0-u.x) +\n           (d-b)* u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f/0.9375;\n}\n\nvec3 color(vec2 p) {\n    float f = fbm(p);\n    return vec3(f*0.5+0.5, f*f*0.5, f*f*f*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*4.0-2.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 col = color(p);\n    fragColor = vec4", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereNormal(vec3 p, vec4 sph) {\n    return (p - sph.xyz) / sph.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereUV(vec3 p, vec4 sph) {\n    return vec3(\n        atan(p.z, p.x) / TWO_PI + 0.5,\n        asin(p.y) / PI + 0.5,\n        0.0\n    );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereUV(vec3 p, vec4 sph, float scale) {\n    return vec3(\n        atan(p.z, p.x) / TWO_PI + 0.5,\n        asin(p.y) / PI + 0.5,\n        scale\n    );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 sphereUV(vec3 p, vec4 sph, float scale, float offset) {\n    return vec3(\n        atan(p.z, p.x) / TWO_PI + 0.5,\n        asin(p.y) / PI + 0.5,\n        scale * offset\n    );\n}\n\n// License: MIT, author: Inigo Quile", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float t = r * pow(abs(sin(a * n)), 1.0 / n);\n    return vec3(t, t * cos(a), t * sin(a));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r)\n{\n    float a = atan(p.y, p.x);\n    float t = pow(abs(sin(a * n)), 1.0 / n);\n    return vec3(r * t, r * t * cos(a), r * t * sin(a));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float w)\n{\n    float a = atan(p.y, p.x);\n    float t = pow(abs(sin(a * n)), 1.0 / n);\n    return vec3(r * t, r * t * cos(a), r * t * sin(a));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSquircle(vec2 p, float n, float r, float w, float h)\n{\n    float a = atan(p.y, p.x);\n    float t = pow(abs(sin(a * n)), 1.0 / n);\n    return vec3(r * t, r * t * cos(a), r * t *", "\n    float y = 0.0;\n    float z = 1.0;\n    float w = 1.0;\n    float n = 1.0;\n    float m = 1.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m2 = 0.0;\n    float n2 = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t2 = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w2 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float z2 = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = ", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross(ba, ac);\n\n    return sign(dot(cross(ba, nor), pa)) +\n           sign(dot(cross(cb, nor), pb)) +\n           sign(dot(cross(ac, nor), pc)) < 2.0?\n           -length(nor) :\n           min( min(\n               dot(ba, pa),\n               dot(cb, pb) ),\n               dot(ac, pc) );\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = 1.7320508075688772935274463415059;\n    p.x = abs(p.x) - r;\n    p.y = p.y + 2.0*r*k/3.0;\n\n    if( p.", "\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdSphere(p, 0.5));\n        p = fractalRotate(p, idx);\n    }\n    return d;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx, out vec3 color) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdSphere(p, 0.5));\n        p = fractalRotate(p, idx);\n    }\n    color = vec3(0.0, 0.0, 1.0);\n    return d;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx, out vec3 color, out float alpha) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdSphere(p, 0.5));\n        p = fractalRotate(p, idx);\n    }\n    color = vec3(0.0, 0.0, 1.0);\n    alpha = 1.0;\n    return d;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx, out vec3 color, out float alpha, out float spec) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, sdSphere(p, 0.5));\n        p = fractalRotate(p, idx);\n    }\n    color = vec3(0.0, 0.0, 1.0);\n    alpha = 1.0;\n    spec = 1.0;\n    return d;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx, out vec3 color, out float alpha, out float spec, out float emit) {\n    float d = ", "\n    float s = (y > 0.0)? 1.0 : -1.0;\n    float a = abs(y) + abs(x);\n    float m = a - abs(x);\n    float n = a - abs(y);\n    float o = m + n;\n    float p = m - n;\n    float q = o / p;\n    float r = 0.187293 * q * q;\n    float atan = q * (1.0 + r * (0.374445 + r * (0.091104 + r * (0.039556))));\n    return s * atan;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(float y, float x) {\n    float s = (y > 0.0)? 1.0 : -1.0;\n    float a = abs(y) + abs(x);\n    float m = a - abs(x);\n    float n = a - abs(y);\n    float o = m + n;\n    float p = m - n;\n    float q = o / p;\n    float r = 0.187293 * q * q;\n    float atan = q * (1.0 + r * (0.374445 + r * (0.091104 + r * (0.039556))));\n    return s * atan;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(vec2 v) {\n    return atan2_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec2 v) {\n    return atan_approx(v.y, v.x);\n}\n", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2((z.x * w.x + z.y * w.y) / (w.x * w.x + w.y * w.y),\n                (z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt((z.x + abs(z.x)) * 0.5),\n                z.y < 0? -sqrt((-z.x + abs(z.x)) * 0.5) : sqrt((-z.x + abs(z.x)) * 0.5));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return cexp(cmul(w, clog(z)));\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\n\nvec2 catan(vec2 z) {\n    return cdiv(z, csqrt(vec2(1.0, 1.0) - cmul(z, z)));\n}", "\n  return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Inverse hyperbolic sine\nvec2 casinh(vec2 z) {\n  return log(z + sqrt(1.0 + z * z));\n}\n\n// Inverse hyperbolic cosine\nvec2 cacosh(vec2 z) {\n  return log(z + sqrt(z + 1.0) * sqrt(z - 1.0));\n}\n\n// Inverse hyperbolic secant\nvec2 casech(vec2 z) {\n  return acosh(1.0 / z);\n}\n\n// Inverse hyperbolic cosecant\nvec2 cacsch(vec2 z) {\n  return asinh(1.0 / z);\n}\n\n// Inverse hyperbolic cotangent\nvec2 catan", "\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(sin(2.0 * z.x) / (cos(2.0 * z.x) * cosh(2.0 * z.y)),\n                sinh(2.0 * z.y) / (cos(2.0 * z.x) * cosh(2.0 * z.y)));\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n    return cexp(clog(z) * p);\n}\n\nvec2 csqrt(vec2 z) {\n    return cpow(z, vec2(0.5, 0.0));\n}\n\nvec2 cdiv(vec2 z, vec2 p) {\n    return cpow(z, vec2(-1.0, 0.0)) * cpow(p, vec2(-1.0, 0.0));\n}\n\nvec2 cdiv(vec2 z, float p) {\n    return cpow(z, vec2(-1.0, ", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2((z.x * w.x + z.y * w.y) / (w.x * w.x + w.y * w.y),\n                (z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt((z.x + abs(z.x)) * 0.5),\n                z.y / sqrt((z.x + abs(z.x)) * 0.5));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return csqrt(cmul(z, z)) * exp(cmul(w, log(z)));\n}\n\nvec2 cexp(vec2 z) {\n    return exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 catanh(vec2 z) {\n    return vec2(0.5, 0.5) * log(z + 1.0 / (z - 1.0));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(0.5, -0.5) * log(z + sqrt(z * z + 1.0));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(0.5, 0.5) * log(z + sqrt(z * z - 1.0));\n}\n\nvec2 ctanh(vec2 z) {\n    return (exp(z) - exp(-z)) / (exp(z) + exp(-z));\n}\n\nvec2 csin(vec2 z) {\n    return", "\n    return vec2(cosh(z.x), sinh(z.x) * vec2(cos(z.y), sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 ctanh(vec2 z) {\n    return (cexp(2.0 * z) - 1.0) / (cexp(2.0 * z) + 1.0);\n}\n\nvec2 csinh(vec2 z) {\n    return (cexp(z) - cexp(-z)) / 2.0;\n}\n\nvec2 ccosh(vec2 z) {\n    return (cexp(z) + cexp(-z)) / 2.0;\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(sin(2.0 * z.x) / (cos(2.0 * z.x) + cosh(2.0 * z.y)),\n                sinh(2.0 * z.y) / (cos(2.0 * z.x) + cosh(2.0 * z.y)));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(0.5 * (z.x + length(z))),\n                sign(z.y) * sqrt(0.5 * (abs(z.y) + length(z))));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return cexp(w * clog(z));\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return cpow(z, vec2(-w.x", "\n  float sum = alpha.r + alpha.g + alpha.b + alpha.a;\n  float factor = 1.0 / (1.0 - contrast);\n  return vec4(\n    alpha.r * factor,\n    alpha.g * factor,\n    alpha.b * factor,\n    alpha.a * factor\n  ) / sum;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n  float sum = alpha.r + alpha.g + alpha.b;\n  float factor = 1.0 / (1.0 - contrast);\n  return vec3(\n    alpha.r * factor,\n    alpha.g * factor,\n    alpha.b * factor\n  ) / sum;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec2 smoothContrast(vec2 alpha, float contrast) {\n  float sum = alpha.r + alpha.g;\n  float factor = 1.0 / (1.0 - contrast);\n  return vec2(\n    alpha.r * factor,\n    alpha.g * factor\n  ) / sum;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n  float sum = alpha;\n  float factor = 1.0 / (1.0 - contrast);\n  return alpha * factor / sum;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContr", "\n  p = abs(p);\n  float d = max(max(p.x, p.y), p.z);\n  p -= 0.5;\n  d = max(d, rhombicDodecahedron(p));\n  return d;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r) {\n  p = abs(p);\n  float d = max(max(p.x, p.y), p.z);\n  p -= 0.5;\n  d = max(d, rhombicDodecahedron(p));\n  return d - r;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r, float d) {\n  p = abs(p);\n  float d1 = max(max(p.x, p.y), p.z);\n  p -= 0.5;\n  float d2 = rhombicDodecahedron(p);\n  return max(d1 - r, d2 - d);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r, float d, float e) {\n  p = abs(p);\n  float d1 = max(max(p.x, p.y), p.z);\n  p -= 0.5;\n  float d2 = rhombicDodecahedron(p);\n  return max(max(d1 - r, d2 - d), e);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p, float r, float d, float e, float f) {\n  p = abs(p);\n  float d1 = max(max(p.x, p.y), p.z);\n  p -= 0.5;\n  float d2 = rhombicDodecahedron(p);\n  return max(max(max(d1 - r, d2 - d), e), f);\n}\n\n//Distance", "\n    vec3 uvw2 = uvw;\n    vec3 uvw3 = uvw;\n    vec3 uvw4 = uvw;\n    vec3 uvw5 = uvw;\n    vec3 uvw6 = uvw;\n    vec3 uvw7 = uvw;\n    vec3 uvw8 = uvw;\n    vec3 uvw9 = uvw;\n    vec3 uvw10 = uvw;\n    vec3 uvw11 = uvw;\n    vec3 uvw12 = uvw;\n    vec3 uvw13 = uvw;\n    vec3 uvw14 = uvw;\n    vec3 uvw15 = uvw;\n    vec3 uvw16 = uvw;\n    vec3 uvw17 = uvw;\n    vec3 uvw18 = uvw;\n    vec3 uvw19 = uvw;\n    vec3 uvw20 = uvw;\n    vec3 uvw21 = uvw;\n    vec3 uvw22 = uvw;\n    vec3 uvw23 = uvw;\n    vec3 uvw24 = uvw;\n    vec3 uvw25 = uvw;\n    vec3 uvw26 = uvw;\n    vec3 uvw27 = uvw;\n    vec3 uvw28 = uvw;\n    vec3 uvw29 = uvw;\n    vec3 uvw30 = uvw;\n    vec3 uvw31 = uvw;\n    vec3 uvw32 = uvw;\n    vec3 uvw33 = uvw;\n    vec3 uvw34 = uvw;\n    vec3 uvw35 = uvw;\n    vec3 uvw36 = uvw;\n    vec3 uvw37 = uvw;\n    vec3 uvw38 = uvw;\n   ", "\n    vec3 uvw2 = uvw;\n    vec3 offset2 = offset;\n    vec3 uvw3 = uvw;\n    vec3 offset3 = offset;\n    vec3 uvw4 = uvw;\n    vec3 offset4 = offset;\n    vec3 uvw5 = uvw;\n    vec3 offset5 = offset;\n    vec3 uvw6 = uvw;\n    vec3 offset6 = offset;\n    vec3 uvw7 = uvw;\n    vec3 offset7 = offset;\n    vec3 uvw8 = uvw;\n    vec3 offset8 = offset;\n    vec3 uvw9 = uvw;\n    vec3 offset9 = offset;\n    vec3 uvw10 = uvw;\n    vec3 offset10 = offset;\n    vec3 uvw11 = uvw;\n    vec3 offset11 = offset;\n    vec3 uvw12 = uvw;\n    vec3 offset12 = offset;\n    vec3 uvw13 = uvw;\n    vec3 offset13 = offset;\n    vec3 uvw14 = uvw;\n    vec3 offset14 = offset;\n    vec3 uvw15 = uvw;\n    vec3 offset15 = offset;\n    vec3 uvw16 = uvw;\n    vec3 offset16 = offset;\n    vec3 uvw17 = uvw;\n    vec3 offset17 = offset;\n    vec3 uvw18 = uvw;\n    vec3 offset18 = offset;\n    vec3 uvw19 = uvw;\n    vec3 offset19 = offset;\n    vec3 uvw20 = uvw;\n    vec3 offset20 = offset;\n    vec3 uvw21 = uvw;\n    vec3 offset21 = offset;\n    vec3 uvw22 = uvw;\n    vec3 offset22 = offset;\n    vec3 uvw23 = uvw;\n    vec3 offset23 = offset;", "\n    vec3 uvw2 = uvw;\n    uvw2.xz = abs(uvw2.xz);\n    uvw2.xz = (uvw2.x > uvw2.z)? uvw2.xz : uvw2.zx;\n    uvw2.yz = abs(uvw2.yz);\n    uvw2.yz = (uvw2.y > uvw2.z)? uvw2.yz : uvw2.zy;\n    uvw2.xy = abs(uvw2.xy);\n    uvw2.xy = (uvw2.x > uvw2.y)? uvw2.xy : uvw2.yx;\n    vec3 uvw3 = uvw2;\n    uvw3.xz = abs(uvw3.xz);\n    uvw3.xz = (uvw3.x > uvw3.z)? uvw3.xz : uvw3.zx;\n    uvw3.yz = abs(uvw3.yz);\n    uvw3.yz = (uvw3.y > uvw3.z)? uvw3.yz : uvw3.zy;\n    uvw3.xy = abs(uvw3.xy);\n    uvw3.xy = (uvw3.x > uvw3.y)? uvw3.xy : uvw3.yx;\n    vec3 uvw4 = uvw3;\n    uvw4.xz = abs(uvw4.xz);\n    uvw4.xz = (uvw4.x > uvw4.z)? uvw4.xz : uvw4.zx;\n    uvw4.yz = abs(uvw4.yz);\n    uvw4.yz = (uvw4.y > uvw4.z)? uvw4.yz : uvw4.zy;\n    uvw4.xy = abs(uvw4", "\n    float t = 0.552284749831;\n    p = abs(p);\n    p -= 2.0 * min(dot(p, vec3(t, t, t)), 0.0) * vec3(t, t, t);\n    p -= vec3(t + t, t, 0.0);\n    p -= vec3(0.0, t + t, t);\n    p -= vec3(t, t + t, 0.0);\n    p -= vec3(0.0, t, t + t);\n    p -= vec3(t, 0.0, t + t);\n    return length(p);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r) {\n    float t = 0.552284749831;\n    p = abs(p);\n    p -= 2.0 * min(dot(p, vec3(t, t, t)), 0.0) * vec3(t, t, t);\n    p -= vec3(t + t, t, 0.0);\n    p -= vec3(0.0, t + t, t);\n    p -= vec3(t, t + t, 0.0);\n    p -= vec3(0.0, t, t + t);\n    p -= vec3(t, 0.0, t + t);\n    return length(p) - r;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float d) {\n    float t = 0.552284749831;\n    p = abs(p);\n    p -= 2.0 * min(dot(p, vec3(t, t, t)), 0.0) * vec3(t, t, t);\n    p -= vec3(t + t, t, 0.0);\n    p -= vec3(0.0, t + t, t);\n    p -= vec3(t, t + t, 0.0);\n    p", "\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t);\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow(float t) {\n    return mix(Warm(t), Cool(t), t);\n}\n\n// makes Gray colormap with polynimal 6\nvec3 Gray(float t) {\n    return vec3(t);\n}\n\n// makes Hot colormap with polynimal 6\nvec3 Hot(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), t);\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t);\n}\n\n// makes Rainbow colormap with polynimal 6\nvec3 Rainbow(float t) {\n    return mix(Warm(t), Cool(t), t);\n}\n\n// makes Gray colormap with polynimal 6\nvec3 Gray(float t) {\n    return vec3(t);\n}\n\n// makes Hot colormap with polynimal 6\nvec3 Hot(float t) {\n    return mix(vec3(1.0, 0.0, 0.0),", "\n    return v * cos(a) + cross(a, v) * sin(a) + a * dot(a, v) * (1.0 - cos(a));\n}\n\n// returns a random number between 0 and 1\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// returns a random number between -1 and 1\nfloat rand2(vec2 co)\n{\n    return rand(co) * 2.0 - 1.0;\n}\n\n// returns a random number between 0 and 1\nfloat rand3(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// returns a random number between -1 and 1\nfloat rand4(vec2 co)\n{\n    return rand3(co) * 2.0 - 1.0;\n}\n\n// returns a random number between 0 and 1\nfloat rand5(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// returns a random number between -1 and 1\nfloat rand6(vec2 co)\n{\n    return rand5(co) * 2.0 - 1.0;\n}\n\n// returns a random number between 0 and 1\nfloat rand7(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// returns a random number between -1 and 1\nfloat rand8(vec2 co)\n{\n    return rand7(co) * 2.0 - 1.0;\n}\n\n// returns", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 co) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 4; i++) {\n        value += noise(co) * scale;\n        co *= 2.0;\n        scale *= 0.5;\n    }\n\n    return value;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec3 co) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 4; i++) {\n        value += noise(co.xy) * scale;\n        co *= 2.0;\n        scale *= 0.5;\n    }\n\n    return value;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec4 co) {\n    float value = 0.0;\n    float", "\n  p = abs(p);\n  return max(p.x + p.y * 0.5, p.y);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, p.y + p.z * 0.5);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, max(p.y + p.z * 0.5, p.z + p.w * 0.5));\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float r) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, p.y) - r;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p, float r) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, max(p.y + p.z * 0.5, p.z)) - r;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p, float r) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, max(p.y + p.z * 0.5, p.z + p.w * 0.5)) - r;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 r) {\n  p = abs(p);\n  return max(p.x + p.y * 0.5, p.y) - r.x;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hex", "\n    vec2 p = uv;\n    float a = 0.8660254037844386;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.25;\n    float e = 0.25;\n    float f = 0.25;\n    float g = 0.25;\n    float h = 0.25;\n    float i = 0.25;\n    float j = 0.25;\n    float k = 0.25;\n    float l = 0.25;\n    float m = 0.25;\n    float n = 0.25;\n    float o = 0.25;\n    float p1 = 0.25;\n    float q = 0.25;\n    float r = 0.25;\n    float s = 0.25;\n    float t = 0.25;\n    float u = 0.25;\n    float v = 0.25;\n    float w = 0.25;\n    float x = 0.25;\n    float y = 0.25;\n    float z = 0.25;\n    float aa = 0.25;\n    float ab = 0.25;\n    float ac = 0.25;\n    float ad = 0.25;\n    float ae = 0.25;\n    float af = 0.25;\n    float ag = 0.25;\n    float ah = 0.25;\n    float ai = 0.25;\n    float aj = 0.25;\n    float ak = 0.25;\n    float al = 0.25;\n    float am = 0.25;\n    float an = 0.25;\n    float ao = 0.25;\n    float ap = 0.25;\n    float aq = 0.25;\n    float ar = 0.25;\n    float as", "\n    return clamp(\n        abs(\n            mod(\n                t * 6.0 - 3.0,\n                6.0\n            ) - 3.0\n        ) - 1.0,\n        0.0,\n        1.0\n    );\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a) {\n    return clamp(\n        abs(\n            mod(\n                t * 6.0 - 3.0,\n                6.0\n            ) - 3.0\n        ) - 1.0,\n        0.0,\n        1.0\n    ) * a;\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b) {\n    return clamp(\n        abs(\n            mod(\n                t * 6.0 - 3.0,\n                6.0\n            ) - 3.0\n        ) - 1.0,\n        0.0,\n        1.0\n    ) * a + b;\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b, float c) {\n    return clamp(\n        abs(\n            mod(\n                t * 6.0 - 3.0,\n                6.0\n            ) - 3.0\n        ) - 1.0,\n        0.0,\n        1.0\n    ) * a + b + c;\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float a, float b, float c, float d) {\n    return clamp(\n        abs(\n            mod(\n                t * ", "\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x) {\n  return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x, float y) {\n  return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x, float y, float z) {\n  return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x, float y, float z, float w) {\n  return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(vec2 xy) {\n  return xy * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 xy, float z) {\n  return xy * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make1to1(vec2 xy, float z, float w) {\n  return vec3(xy * 2.0 - 1.0, z * 2.0 - 1.0);\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make1to1(vec3 xyz) {\n  return xyz * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 make1to1(vec3 xyz, float w) {\n  return vec4(xyz * 2.0 - 1.0, w * 2.0 - 1.0);\n}\n\n//shifts value range from 0-", "\n    vec2 id = floor(uv * gridRes);\n    vec2 p = fract(uv * gridRes);\n    vec2 p0 = vec2(0.5, 0.5);\n    vec2 p1 = vec2(0.5, 0.5);\n    vec2 p2 = vec2(0.5, 0.5);\n    vec2 p3 = vec2(0.5, 0.5);\n    vec2 p4 = vec2(0.5, 0.5);\n    vec2 p5 = vec2(0.5, 0.5);\n    vec2 p6 = vec2(0.5, 0.5);\n    vec2 p7 = vec2(0.5, 0.5);\n    vec2 p8 = vec2(0.5, 0.5);\n    vec2 p9 = vec2(0.5, 0.5);\n    vec2 p10 = vec2(0.5, 0.5);\n    vec2 p11 = vec2(0.5, 0.5);\n    vec2 p12 = vec2(0.5, 0.5);\n    vec2 p13 = vec2(0.5, 0.5);\n    vec2 p14 = vec2(0.5, 0.5);\n    vec2 p15 = vec2(0.5, 0.5);\n    vec2 p16 = vec2(0.5, 0.5);\n    vec2 p17 = vec2(0.5, 0.5);\n    vec2 p18 = vec2(0.5, 0.5);\n    vec2 p19 = vec2(0.5, 0.5);\n    vec2 p20 = vec2(0.5, 0.5);\n    vec2 p21 = vec2(0.5, 0.5);\n    vec2 p22 = vec2(0.5, 0.5);\n    vec2 p23 = vec2(0.5, 0.5);\n    vec2 p24 = vec2(0.5,", "\n    float t = time * 0.5;\n    float t2 = time * 0.25;\n    float t3 = time * 0.125;\n    float t4 = time * 0.0625;\n    float t5 = time * 0.03125;\n    float t6 = time * 0.015625;\n    float t7 = time * 0.0078125;\n    float t8 = time * 0.00390625;\n    float t9 = time * 0.001953125;\n    float t10 = time * 0.0009765625;\n    float t11 = time * 0.00048828125;\n    float t12 = time * 0.000244140625;\n    float t13 = time * 0.0001220703125;\n    float t14 = time * 0.00006103515625;\n    float t15 = time * 0.000030517578125;\n    float t16 = time * 0.0000152587890625;\n    float t17 = time * 0.00000762939453125;\n    float t18 = time * 0.000003814697265625;\n    float t19 = time * 0.0000019073486328125;\n    float t20 = time * 0.00000095367431640625;\n    float t21 = time * 0.000000476837158203125;\n    float t22 = time * 0.000000", "\n    float angle = atan(point.y, point.x);\n    float distance = length(point);\n    float speed = 0.05;\n    float offset = time * speed;\n    float newAngle = angle + offset;\n    float newDistance = distance + offset;\n    return vec2(newDistance * cos(newAngle), newDistance * sin(newAngle));\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed) {\n    float angle = atan(point.y, point.x);\n    float distance = length(point);\n    float offset = time * speed;\n    float newAngle = angle + offset;\n    float newDistance = distance + offset;\n    return vec2(newDistance * cos(newAngle), newDistance * sin(newAngle));\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed, float offset) {\n    float angle = atan(point.y, point.x);\n    float distance = length(point);\n    float offset = time * speed + offset;\n    float newAngle = angle + offset;\n    float newDistance = distance + offset;\n    return vec2(newDistance * cos(newAngle), newDistance * sin(newAngle));\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed, float offset, float angle) {\n    float angle = atan(point.y, point.x);\n    float distance = length(point);\n    float offset = time * speed + offset;\n    float newAngle = angle + offset;\n    float newDistance = distance + offset;\n    return vec2(newDistance * cos(newAngle), newDistance * sin(newAngle));\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float speed, float offset, float angle, float distance) {\n    float angle = atan(point.y, point.x);\n    float distance = length(point);\n    float offset = time * speed + offset", "\n    return floor(pos / vec2(TILE_SIZE)) * vec2(TILE_SIZE) + vec2(TILE_SIZE / 2.0);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSize2) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSize2, vec2 tileOffset2) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSize2, vec2 tileOffset2, vec2 tileSize3) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileSize2, vec2 tileOffset2, vec2 tileSize3, vec2 tileOffset3) {\n    return floor(pos / tileSize) * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(", "\n  vec2 v = p2 - p1;\n  vec2 w = p - p1;\n  float c1 = dot(w, v);\n  float c2 = dot(v, v);\n  float b = c1 / c2;\n  vec2 pb = p1 + b * v;\n  return length(p - pb);\n}\n\n// Computes the signed distance from a rectangle\nfloat rect(vec2 p, vec2 p1, vec2 p2) {\n  vec2 v = p2 - p1;\n  vec2 w = p - p1;\n  vec2 vw = vec2(dot(v, w), dot(v, w));\n  vec2 vw1 = vec2(clamp(vw.x, 0.0, v.x), clamp(vw.y, 0.0, v.y));\n  vec2 vw2 = vec2(clamp(vw.x, -v.x, 0.0), clamp(vw.y, -v.y, 0.0));\n  float d = length(vw1 - vw2);\n  return d;\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 p1, float r) {\n  return length(p - p1) - r;\n}\n\n// Computes the signed distance from a polygon\nfloat poly(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n  float d1 = rect(p, p1, p2);\n  float d2 = rect(p, p2, p3);\n  float d3 = rect(p, p3, p4);\n  float d4 = rect(p, p4, p1);\n  return min(min(min(d1, d2), d3), d4);\n}\n\n// Computes the signed distance from a polygon\nfloat poly(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec2 p5, vec2 p6, vec2 p7, vec2 p8) {\n  float d1 = poly(p", "\n  float d = length(v);\n  if (d < 0.0001) return 0.0;\n  v /= d;\n  float w = 0.005 * d;\n  float l = 0.15 * d;\n  float r = 0.05 * d;\n  float a = atan(v.y, v.x);\n  float x = p.x - v.x * l - v.y * r;\n  float y = p.y - v.y * l + v.x * r;\n  float m = length(vec2(x, y));\n  float n = length(vec2(x - v.y * w, y + v.x * w));\n  float o = length(vec2(x + v.y * w, y - v.x * w));\n  float d1 = m - l;\n  float d2 = max(abs(n - r) - w, abs(o - r) - w);\n  return max(d1, d2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v, float w, float l, float r) {\n  float d = length(v);\n  if (d < 0.0001) return 0.0;\n  v /= d;\n  float a = atan(v.y, v.x);\n  float x = p.x - v.x * l - v.y * r;\n  float y = p.y - v.y * l + v.x * r;\n  float m = length(vec2(x, y));\n  float n = length(vec2(x - v.y * w, y + v.x * w));\n  float o = length(vec2(x + v.y * w, y - v.x * w));\n  float d1 = m - l;\n  float d2 = max(abs(n - r) - w, abs(o - r) - w);\n  return max(", "\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z, vec2 w) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z, vec2 w, vec2 u) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z, vec2 w, vec2 u, vec2 v) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z, vec2 w, vec2 u, vec2 v, vec2 a) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to1(vec2 x, vec2 y, vec2 z, vec2 w, vec2 u, vec2 v, vec2 a, vec2 b) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float dist = radius * (1.0 - smoothstep(0.0, 1.0, radius));\n    float r = angle + offset;\n    float x = dist * cos(r);\n    float y = dist * sin(r);\n    return vec2(x, y);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius)\n{\n    float angle = atan(point.y, point.x);\n    float dist = length(point);\n    float r = angle + offset;\n    float x = dist * cos(r);\n    float y = dist * sin(r);\n    return vec2(x, y);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float radius2)\n{\n    float angle = atan(point.y, point.x);\n    float dist = length(point);\n    float r = angle + offset;\n    float x = dist * cos(r);\n    float y = dist * sin(r);\n    return vec2(x, y);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float radius2, float radius3)\n{\n    float angle = atan(point.y, point.x);\n    float dist = length(point);\n    float r = angle + offset;\n    float x = dist * cos(r);\n    float y = dist * sin(r);\n    return vec2(x, y);\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset, float radius, float radius2, float radius3, float radius4)\n{\n    float angle = atan(point.y, point.x);\n    float dist = length(point);\n", "\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n  vec3 d = abs(p)-b;\n  return length(max(d,vec3(0))) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,vec3(0))) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n  p = abs(p); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n  float l = ab.y*ab.y - ab.x*ab.x;\n  float m = ab.x*p.x/ab.y;\n  float m2 = m*m;\n  float n = p.y - m*p.x/ab.y;\n  float n2 = n*n*l/(ab.x*ab.x);\n  float c = (m2 + n2 - 1.0)/3.0;\n  float c3 = c*c*c;\n  float q = c3 + m2*n2;\n  float d = c3 + m2*n2;\n  float g = m + m*sqrt( max( 0.0, q ) );\n  return sqrt( max(q,0.0) ) * sign( d ) * sign( g );\n", "\n    float s = 0.0;\n    float t = 0.0;\n    float r = 0.0;\n    float a = 0.0;\n    float d = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p1 = 0.0;\n    float p2 = 0.0;\n    float p3 = 0.0;\n    float p4 = 0.0;\n    float p5 = 0.0;\n    float p6 = 0.0;\n    float p7 = 0.0;\n    float p8 = 0.0;\n    float p9 = 0.0;\n    float p10 = 0.0;\n    float p11 = 0.0;\n    float p12 = 0.0;\n    float p13 = 0.0;\n    float p14 = 0.0;\n    float p15 = 0.0;\n    float p16 = 0.0;\n    float p17 = 0.0;\n    float p18 = 0.0;\n    float p19 = 0.0;\n    float p20 = 0.0;\n    float p21 = 0.0;\n    float p22 = 0.0;\n    float p23 = 0.0;\n    float p24 = 0.0;\n    float p25 = 0.0;\n    float p26 = 0.0;\n    float p27 = 0.0;\n    float p28 = 0.0;\n    float p29 = 0.0;\n    float p30 = 0.0;\n    float p31 = 0.0", "\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = time*sp;\n    float d = abs(r - ra) - fract(a - t + 0.5);\n    return d;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = 0.5;\n    float d = abs(r - ra) - fract(a - t + 0.5);\n    return d;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = 0.5;\n    float d = abs(r - ra) - fract(a - t + 0.5);\n    return d;\n}\n\nfloat sdCircularRepetition( in vec2 p )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = 0.5;\n    float d = abs(r - 1.0) - fract(a - t + 0.5);\n    return d;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r )\n{\n    float r2 = length(p);\n    float a = atan(p.y,p.x);\n    float t = time*sp;\n    float d = abs(r2 - ra) - fract(a - t + 0.5);\n    return d;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float r = length(p);\n    float a = atan(p.y,p.x);\n    float t = time*sp;\n    float d = abs(r - ra) - fract(a - t + 0.5);\n    return d;\n", "\n    return max(abs(uvw.x), max(abs(uvw.y), abs(uvw.z)));\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw);\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    return length(uvw.xz) - uvw.y;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float d = length(uvw.xz);\n    return d - uvw.y;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    vec2 q = vec2(length(uvw.xz) - uvw.y, uvw.y);\n    return length(q) - uvw.x;\n}\n\n//edge distance of a Capsule\nfloat capsuleDist(vec3 uvw) {\n    float d = length(uvw.xz);\n    return mix(length(uvw.y), d, step(uvw.y, 0.0));\n}\n\n//edge distance of a Pyramid\nfloat pyramidDist(vec3 uvw) {\n    return max(abs(uvw.x), max(abs(uvw.y), abs(uvw.z)));\n}\n\n//edge distance of a Octahedron\nfloat octahedronDist(vec3 uvw) {\n    return (length(uvw) - 1.0) * sign(uvw.x + uvw.y + uvw.z);\n}\n\n//edge distance of a Dodecahedron\nfloat dodecahedronDist(vec3 uvw) {\n    float d = 0.0;\n    d += abs(uvw.x + uvw.y);\n    d += abs(uvw.y + uvw.z);\n    d += abs(uvw.z + uvw.x);\n    d += abs(uvw.x - uvw.y);\n    d +=", "\n  vec3 p = abs(uvw);\n  vec3 m = max(p.xyx, p.yxx);\n  vec3 a = min(m, p);\n  vec3 b = a.xzy * a.yxz;\n  return vec4(a.x, b.x, b.y, b.z);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, vec3 offset) {\n  vec3 p = abs(uvw + offset);\n  vec3 m = max(p.xyx, p.yxx);\n  vec3 a = min(m, p);\n  vec3 b = a.xzy * a.yxz;\n  return vec4(a.x, b.x, b.y, b.z);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, vec3 offset, vec3 scale) {\n  vec3 p = abs(uvw + offset) * scale;\n  vec3 m = max(p.xyx, p.yxx);\n  vec3 a = min(m, p);\n  vec3 b = a.xzy * a.yxz;\n  return vec4(a.x, b.x, b.y, b.z);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, vec3 offset, vec3 scale, vec3 rotation) {\n  vec3 p = abs(uvw + offset) * scale;\n  vec3 m = max(p.xyx, p.yxx);\n  vec3 a = min(m, p);\n  vec3 b = a.xzy * a.yxz;\n  return vec4(a.x, b.x, b.y, b.z);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, vec3 offset, vec3 scale, vec3 rotation, vec3 skew) {\n  vec3 p = abs(uvw + offset) * scale;\n  vec3 m = max(p.xyx, p.yxx);\n  vec3 a = min(m, p);\n", "\n    vec3 uvw2 = uvw + offset;\n    vec3 cell = floor(uvw2 * gridRes);\n    vec3 cellOffset = fract(uvw2 * gridRes);\n    vec3 cellOffset2 = cellOffset * cellOffset * (3.0 - 2.0 * cellOffset);\n    return vec4(cell, cellOffset2.x + cellOffset2.y + cellOffset2.z);\n}\n\n// scaled with offset hex tiling\nvec4 hexCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec3 uvw2 = uvw + offset;\n    vec3 cell = floor(uvw2 * gridRes);\n    vec3 cellOffset = fract(uvw2 * gridRes);\n    vec3 cellOffset2 = cellOffset * cellOffset * (3.0 - 2.0 * cellOffset);\n    return vec4(cell, cellOffset2.x + cellOffset2.y + cellOffset2.z);\n}\n\n// scaled with offset triangular tiling\nvec4 triCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec3 uvw2 = uvw + offset;\n    vec3 cell = floor(uvw2 * gridRes);\n    vec3 cellOffset = fract(uvw2 * gridRes);\n    vec3 cellOffset2 = cellOffset * cellOffset * (3.0 - 2.0 * cellOffset);\n    return vec4(cell, cellOffset2.x + cellOffset2.y + cellOffset2.z);\n}\n\n// scaled with offset triangular tiling\nvec4 triCell(vec3 uvw, vec3 offset, float gridRes, float gridRes2) {\n    vec3 uvw2 = uvw + offset;\n    vec3 cell = floor(uvw2 * gridRes);\n    vec3 cellOffset = fract(uvw2 * gridRes);\n    vec3 cellOffset2 = cellOffset * cellOffset * (3.0 - 2.0 * cellOffset);\n    return vec4(cell, cellOffset2.x + cellOffset2.y + cellOffset2.z);\n}\n\n// scale", "\n    return clamp(\n        (1. + sin( 6.28318*(\n            (t*=2.) > 1.? 2.-t : t\n        ) )) *.5,\n    0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a) {\n    return clamp(\n        (1. + sin( 6.28318*(\n            (t*=2.) > 1.? 2.-t : t\n        ) )) *.5,\n    0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a, float b) {\n    return clamp(\n        (1. + sin( 6.28318*(\n            (t*=2.) > 1.? 2.-t : t\n        ) )) *.5,\n    0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a, float b, float c) {\n    return clamp(\n        (1. + sin( 6.28318*(\n            (t*=2.) > 1.? 2.-t : t\n        ) )) *.5,\n    0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a, float b, float c, float d) {\n    return clamp(\n        (1", "\n    p = abs(p);\n    p -= 2.0 * min(p.x, min(p.y, p.z));\n    return length(p);\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    p = abs(p);\n    float dist = p.x + p.y + p.z - 1.4142135623730950488016887242097;\n    return max(dist, 0.0);\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {\n    p = abs(p);\n    float dist = p.x + p.y + p.z - 1.0;\n    return max(dist, 0.0);\n}\n\n//Distance from the Edge of Hexahedron\nfloat hexaDist(vec3 p) {\n    p = abs(p);\n    float dist = p.x + p.y + p.z - 1.0;\n    return max(dist, 0.0);\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    float t = 0.5 * (1.0 + sqrt(5.0));\n    p = abs(p);\n    p -= 2.0 * min(p.x, min(p.y, p.z));\n    p -= vec3(t, t, t);\n    return length(p);\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n    float t = 0.5 * (1.0 + sqrt(5.0));\n    p = abs(p);\n    p -= 2.0 * min(p.x, min(p.y, p.z));\n    p -= vec3(t, t, t);\n    return length(p);\n}\n\n//Distance from the Edge of Rhombicuboctahedron\nfloat rcubDist(vec3 p) {\n    p = abs(", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float tt = t;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt2 = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww = 0.0;\n    float xx = 0.0;\n", "\n    vec2 t = fract(uv);\n    vec2 i = floor(uv);\n    return mix(mix(vec3(0.0), vec3(1.0), t.x), mix(vec3(1.0), vec3(0.0), t.x), t.y);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 tileSize) {\n    vec2 t = fract(uv * tileSize);\n    vec2 i = floor(uv * tileSize);\n    return mix(mix(vec3(0.0), vec3(1.0), t.x), mix(vec3(1.0), vec3(0.0), t.x), t.y);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 tileSize, vec2 tileCount) {\n    vec2 t = fract(uv * tileSize);\n    vec2 i = floor(uv * tileSize);\n    return mix(mix(vec3(0.0), vec3(1.0), t.x), mix(vec3(1.0), vec3(0.0), t.x), t.y);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 tileSize, vec2 tileCount, vec2 offset) {\n    vec2 t = fract(uv * tileSize);\n    vec2 i = floor(uv * tileSize);\n    return mix(mix(vec3(0.0), vec3(1.0), t.x), mix(vec3(1.0), vec3(0.0), t.x), t.y);\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv, vec2 tileSize, vec2 tileCount, vec2 offset, vec2 repeat) {\n    vec2 t = fract(uv * tileSize);\n    vec2 i = floor(uv * tileSize);\n    return mix(mix(vec3(0.0), vec3(1.0), t.x), mix(vec3(1.0), vec3(0.0), t.x), t.y);\n}\n", "\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = max(q.x, q.y);\n    return vec3(d, q.yx);\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTileEuclid(vec2 uv) {\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = (q.x + q.y) * sqrt(0.5);\n    return vec3(d, q.yx);\n}\n\n//rhombic shape form Chebyshev distance\nvec3 rhomTileCheb(vec2 uv) {\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = max(q.x, q.y);\n    return vec3(d, q.yx);\n}\n\n//rhombic shape form Minkowski distance\nvec3 rhomTileMink(vec2 uv) {\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = pow(pow(q.x, 8.0) + pow(q.y, 8.0), 1.0 / 8.0);\n    return vec3(d, q.yx);\n}\n\n//rhombic shape form Hamming distance\nvec3 rhomTileHam(vec2 uv) {\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = (q.x + q.y) / 2.0;\n    return vec3(d, q.yx);\n}\n\n//rhombic shape form Jaccard distance\nvec3 rhomTileJacc(vec2 uv) {\n    vec2 p = fract(uv.xy) - 0.5;\n    vec2 q = abs(p);\n    float d = (q.x", "\n  vec2 gridUV = fract(uv * gridRes);\n  vec2 gridUV2 = fract(uv * gridRes + offset);\n  vec2 gridUV3 = fract(uv * gridRes - offset);\n  vec2 gridUV4 = fract(uv * gridRes + vec2(offset.x, -offset.y));\n  vec2 gridUV5 = fract(uv * gridRes + vec2(-offset.x, offset.y));\n  vec2 gridUV6 = fract(uv * gridRes + vec2(-offset.x, -offset.y));\n  vec2 gridUV7 = fract(uv * gridRes + vec2(offset.x, offset.y));\n  vec2 gridUV8 = fract(uv * gridRes + vec2(-offset.x, offset.y));\n  vec2 gridUV9 = fract(uv * gridRes + vec2(offset.x, -offset.y));\n  vec2 gridUV10 = fract(uv * gridRes + vec2(-offset.x, -offset.y));\n  vec2 gridUV11 = fract(uv * gridRes + vec2(offset.x, offset.y));\n  vec2 gridUV12 = fract(uv * gridRes + vec2(-offset.x, offset.y));\n  vec2 gridUV13 = fract(uv * gridRes + vec2(offset.x, -offset.y));\n  vec2 gridUV14 = fract(uv * gridRes + vec2(-offset.x, -offset.y));\n  vec2 gridUV15 = fract(uv * gridRes + vec2(offset.x, offset.y));\n  vec2 gridUV16 = fract(uv * gridRes + vec2(-offset.x, offset.y));\n  vec2 gridUV17 = fract(uv * gridRes + vec2(offset.x, -offset.y));\n  vec2 gridUV18 = fract(uv * gridRes + vec2(-offset.x, -offset.y));\n  vec2 gridUV19 = fract(uv * gridRes + vec2(", "\n  vec2 grid = floor(uv * gridRes);\n  vec2 gridFract = fract(uv * gridRes);\n  vec2 gridFract2 = gridFract * gridFract;\n  vec2 gridFract3 = gridFract2 * gridFract;\n  vec2 gridFract4 = gridFract3 * gridFract;\n  vec2 gridFract5 = gridFract4 * gridFract;\n  vec2 gridFract6 = gridFract5 * gridFract;\n  vec2 gridFract7 = gridFract6 * gridFract;\n  vec2 gridFract8 = gridFract7 * gridFract;\n  vec2 gridFract9 = gridFract8 * gridFract;\n  vec2 gridFract10 = gridFract9 * gridFract;\n  vec2 gridFract11 = gridFract10 * gridFract;\n  vec2 gridFract12 = gridFract11 * gridFract;\n  vec2 gridFract13 = gridFract12 * gridFract;\n  vec2 gridFract14 = gridFract13 * gridFract;\n  vec2 gridFract15 = gridFract14 * gridFract;\n  vec2 gridFract16 = gridFract15 * gridFract;\n  vec2 gridFract17 = gridFract16 * gridFract;\n  vec2 gridFract18 = gridFract17 * gridFract;\n  vec2 gridFract19 = gridFract18 * gridFract;\n  vec2 gridFract20 = gridFract19 * gridFract;\n  vec2 gridFract21 = gridFract20 * gridFract;\n  vec2 gridFract22 = gridFract21 * gridFract;\n  vec2 gridFract23 = gridFract22 * gridFract;\n  vec2 gridFract24 = gridFract23 * gridFract;\n  vec2 gridFract25 = gridFract24 * gridFract;\n  vec2 gridFract26 = gridFract25 * gridFract;\n", "\n    vec2 id = floor(uv * gridRes);\n    vec2 cell = fract(uv * gridRes);\n    vec2 cellOffset = fract(offset * gridRes);\n    vec2 cellId = id + cellOffset;\n    vec2 cellUv = cell * len;\n    return flowSquare(cellUv, cellId, time);\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 id, float time) {\n    float x = id.x + sin(id.y * 0.5 + time * 0.5) * 0.5;\n    float y = id.y + cos(id.x * 0.5 + time * 0.5) * 0.5;\n    return flowSquare(uv, vec2(x, y), time);\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 id, float time) {\n    float x = id.x + sin(id.y * 0.5 + time * 0.5) * 0.5;\n    float y = id.y + cos(id.x * 0.5 + time * 0.5) * 0.5;\n    return flowSquare(uv, vec2(x, y), time);\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 id, float time) {\n    float x = id.x + sin(id.y * 0.5 + time * 0.5) * 0.5;\n    float y = id.y + cos(id.x * 0.5 + time * 0.5) * 0.5;\n    return flowSquare(uv, vec2(x, y), time);\n}\n\n// generates pixelated directional waves\nfloat flowSquare(vec2 uv, vec2 id, float time) {\n    float x = id.x + sin(id.y * 0.5 + time * 0.5) * 0.5;\n    float y = id.y + cos(id.x * 0.5 + time * 0.", "\n    float t = time * 0.001;\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x1 = floor(x);\n    float y1 = floor(y);\n    float x2 = x1 + 1.0;\n    float y2 = y1 + 1.0;\n    float xd = x - x1;\n    float yd = y - y1;\n    float xd2 = xd * xd;\n    float yd2 = yd * yd;\n    float xm = xd * (x2 - x1);\n    float ym = yd * (y2 - y1);\n    float xmd = xm * xd;\n    float ymd = ym * yd;\n    float xmd2 = xmd * xd2;\n    float ymd2 = ymd * yd2;\n    float xmdyd = xmd * yd;\n    float ymdxd = ymd * xd;\n    float xmd2yd = xmd2 * yd;\n    float ymd2xd = ymd2 * xd;\n    float xmdyd2 = xmd * yd2;\n    float ymdxd2 = ymd * xd2;\n    float xmd2yd2 = xmd2 * yd2;\n    float ymd2xd2 = ymd2 * xd2;\n    float xmd2yd2xd = xmd2yd2 * xd;\n    float ymd2xd2yd = ymd2xd2 * yd;\n    float xmd2yd2xd2 = xmd2yd2 * xd2;\n    float ymd2xd2yd2 = ymd2xd2 * yd2;\n    float xmd2yd2xd2yd = xmd2yd2xd2 * yd;\n    float ymd2xd2yd2xd = ymd2xd2yd2 * xd;\n    float xmd2yd2xd2yd2 = xmd2yd2xd2yd * yd2;\n    float", "\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy));\n\n    // analytical integral (box filter)\n    vec2 i = 2.0 * (w - 0.5);\n    vec2 a = exp( -i * i );\n    vec2 b = 1.0 - a;\n\n    // x offset\n    vec2 ip = floor(p + 0.5);\n    p -= ip;\n\n    // analytical integral (box filter)\n    vec2 ipp = 2.0 * (w - 0.5);\n    vec2 ap = exp( -ipp * ipp );\n    vec2 bp = 1.0 - ap;\n\n    // mix\n    return mix( dot( a, b ), dot( ap, bp ), mix( 1.0, 1.0 - smoothstep( 1.0, 0.0, length( p ) ), length( p ) ) );\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy));\n\n    // analytical integral (box filter)\n    vec2 i = 2.0 * (w - 0.5);\n    vec2 a = exp( -i * i );\n    vec2 b = 1.0 - a;\n\n    // x offset\n    vec2 ip = floor(p + 0.5);\n    p -= ip;\n\n    // analytical integral (box filter)\n    vec2 ipp = 2.0 * (w - 0.5);\n    vec2 ap = exp( -ipp * ipp );\n    vec2 bp = 1.0 - ap;\n\n    // mix\n    return mix( dot( a, b ), dot( ap, bp ), smoothstep( 1.0, 0.0, length( p ) ) );\n}\n\nfloat gridTexture( in vec2 p )\n{\n    // filter kernel\n    vec2 w = vec2( 0.5, 0.5 );\n\n    // analytical integral (box filter)\n    vec2", "\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r;\n}\n\nfloat hexagon(vec2 p, float r, float d) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r + d;\n}\n\nfloat hexagon(vec2 p, float r, float d, float e) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r + d + e;\n}\n\nfloat hexagon(vec2 p, float r, float d, float e, float f) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r + d + e + f;\n}\n\nfloat hexagon(vec2 p, float r, float d, float e, float f, float g) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r + d + e + f + g;\n}\n\nfloat hexagon(vec2 p, float r, float d, float e, float f, float g, float h) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.y * 1.1547) - r + d + e + f + g + h;\n}\n\nfloat hexagon(vec2 p, float r, float d, float e, float f, float g, float h, float i) {\n    p = abs(p);\n    return max(abs(p.x) + p.y * 0.57735, p.", "\n    vec2 q = floor(p);\n    p = fract(p);\n    if (mod(q.x + q.y, 2.0) == 1.0) {\n        p = 1.0 - p;\n    }\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hex(inout vec2 p) {\n    p = hextile(p);\n    p = hextile(p);\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hex(inout vec2 p, float size) {\n    p = hextile(p);\n    p = hextile(p);\n    p *= size;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hex(inout vec2 p, float size, float offset) {\n    p = hextile(p);\n    p = hextile(p);\n    p *= size;\n    p += offset;\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hex(inout vec2 p, float size, float offset, float angle) {\n    p = hextile(p);\n    p = hextile(p);\n    p *= size;\n    p += offset;\n    p = rotate(p, angle);\n    return p;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hex(inout vec2 p, float size, float offset, float angle, float skew) {\n    p = hextile(p", "\n    return 0.5000*sin( 6.28318*x ) +\n           0.2500*sin( 6.28318*x*2.0 ) +\n           0.1250*sin( 6.28318*x*4.0 ) +\n           0.0625*sin( 6.28318*x*8.0 ) +\n           0.0312*sin( 6.28318*x*16.0 ) +\n           0.0156*sin( 6.28318*x*32.0 ) +\n           0.0078*sin( 6.28318*x*64.0 ) +\n           0.0039*sin( 6.28318*x*128.0 ) +\n           0.0019*sin( 6.28318*x*256.0 ) +\n           0.0009*sin( 6.28318*x*512.0 ) +\n           0.0004*sin( 6.28318*x*1024.0 ) +\n           0.0002*sin( 6.28318*x*2048.0 ) +\n           0.0001*sin( 6.28318*x*4096.0 ) +\n           0.0000*sin( 6.28318*x*8192.0 );\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix( mix( fun(n+  0.0), fun(", "\n    return mix(\n        pow(t, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        t * 12.92,\n        lessThan(t, vec3(0.0031308))\n    );\n}\n\nvec3 linearRGB(vec3 t) {\n    return mix(\n        pow((t + 0.055) / 1.055, vec3(2.4)),\n        t / 12.92,\n        lessThan(t, vec3(0.04045))\n    );\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return mix(\n        pow(t, vec3(1.0 / gamma)) * 1.055 - 0.055,\n        t * 12.92,\n        lessThan(t, vec3(0.0031308))\n    );\n}\n\nvec3 linearRGB(vec3 t, float gamma) {\n    return mix(\n        pow((t + 0.055) / 1.055, vec3(gamma)),\n        t / 12.92,\n        lessThan(t, vec3(0.04045))\n    );\n}\n\nvec3 sRGB(vec3 t, float gamma, float gamma2) {\n    return mix(\n        pow(t, vec3(1.0 / gamma)) * 1.055 - 0.055,\n        t * 12.92,\n        lessThan(t, vec3(0.0031308))\n    ) * gamma2;\n}\n\nvec3 linearRGB(vec3 t, float gamma, float gamma2) {\n    return mix(\n        pow((t + 0.055) / 1.055, vec3(gamma)) * gamma2,\n        t / 12.92,\n        lessThan(t, vec3(0.04045))", "\n    return fract(p.x + p.y * 0.5);\n}\n\n// Repeat pattern\nfloat df1(vec2 p) {\n    return fract(p.x + p.y * 0.5);\n}\n\n// Checkerboard pattern\nfloat df2(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Squares\nfloat df3(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Hexagons\nfloat df4(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Triangles\nfloat df5(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Circles\nfloat df6(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Diamonds\nfloat df7(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Crosses\nfloat df8(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Lines\nfloat df9(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Squares\nfloat df10(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Hexagons\nfloat df11(vec2 p) {\n    return mod(floor(p.x + p.y * 0.5), 2.0);\n}\n\n// Triangles\nfloat df12(vec2 p) {\n    return mod(floor(p", "\n  float d = 1e10;\n  float r = 0.0;\n  float a = 0.0;\n  float f = 0.0;\n  float t = 0.0;\n  float s = 0.0;\n  float n = 0.0;\n  float m = 0.0;\n  float w = 0.0;\n  float h = 0.0;\n  float o = 0.0;\n  float q = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float c = 0.0;\n  float d1 = 0.0;\n  float d2 = 0.0;\n  float d3 = 0.0;\n  float d4 = 0.0;\n  float d5 = 0.0;\n  float d6 = 0.0;\n  float d7 = 0.0;\n  float d8 = 0.0;\n  float d9 = 0.0;\n  float d10 = 0.0;\n  float d11 = 0.0;\n  float d12 = 0.0;\n  float d13 = 0.0;\n  float d14 = 0.0;\n  float d15 = 0.0;\n  float d16 = 0.0;\n  float d17 = 0.0;\n  float d18 = 0.0;\n  float d19 = 0.0;\n  float d20 = 0.0;\n  float d21 = 0.0;\n  float d22 = 0.0;\n  float d23 = 0.0;\n  float d24 = 0.0;\n  float d25 = 0.0;\n  float d26 = 0.0;\n  float d27 = 0.0;\n  float d28 = 0.0;\n  float d", "\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2( dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x) ),\n                   vec2( dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x) )),\n                   vec2( dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x) ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in float r )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 p", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spherei(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphereo(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    if (h < 0.0) return -1.0;\n    return h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spherep(", "\n    return length(max(abs(p) - vec2(w, r), 0.0)) - r;\n}\n\nfloat roundedY(vec2 p, float h, float r) {\n    return length(max(abs(p) - vec2(r, h), 0.0)) - r;\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2, float r3, float r4) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2, float r3, float r4, float r5, float r6) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2, float r3, float r4, float r5, float r6, float r7, float r8) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2, float r3, float r4, float r5, float r6, float r7, float r8, float r9, float r10) {\n    return max(roundedX(p, size.x, r), roundedY(p, size.y, r2));\n}\n\nfloat roundedRect(vec2 p, vec2 size, float r, float r2, float r3, float r4, float r5, float r6, float r7, float r", "\n    float x = p.x / p.y;\n    return (abs(x) * (1.0 - k) + k) * p.y;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n    float x = p.x / p.y;\n    return (abs(x) * (1.0 - k) + k) * p.y;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, in vec2 q, float k )\n{\n    float x = p.x / p.y;\n    float y = q.x / q.y;\n    return (abs(x) * (1.0 - k) + k) * p.y * (abs(y) * (1.0 - k) + k) * q.y;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, in vec3 q, float k )\n{\n    float x = p.x / p.y;\n    float y = q.x / q.y;\n    return (abs(x) * (1.0 - k) + k) * p.y * (abs(y) * (1.0 - k) + k) * q.y;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, in vec2 q, in vec2 r, float k )\n{\n    float x = p.x / p.y;\n    float y = q.x / q.y;\n    float z = r.x / r.y;\n    return (abs(x) * (1.0 - k) + k) * p.y * (abs(y) * (1.0 - k) + k) * q.y * (abs(z) * (1.0 - k) + k) * r.y;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, in vec3 q, in vec3 r, float", "\n    return abs(p.x) - abs(p.y);\n}\n\n// distance to y=1/x^2\nfloat sdOOXX( in vec2 p )\n{\n    return pow(abs(p.x), 2.0) - abs(p.y);\n}\n\n// distance to y=1/x^3\nfloat sdOOXXX( in vec2 p )\n{\n    return pow(abs(p.x), 3.0) - abs(p.y);\n}\n\n// distance to y=1/x^4\nfloat sdOOXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 4.0) - abs(p.y);\n}\n\n// distance to y=1/x^5\nfloat sdOOXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 5.0) - abs(p.y);\n}\n\n// distance to y=1/x^6\nfloat sdOOXXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 6.0) - abs(p.y);\n}\n\n// distance to y=1/x^7\nfloat sdOOXXXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 7.0) - abs(p.y);\n}\n\n// distance to y=1/x^8\nfloat sdOOXXXXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 8.0) - abs(p.y);\n}\n\n// distance to y=1/x^9\nfloat sdOOXXXXXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 9.0) - abs(p.y);\n}\n\n// distance to y=1/x^10\nfloat sdOOXXXXXXXXXX( in vec2 p )\n{\n    return pow(abs(p.x), 10.0) - abs(p.y);\n}\n\n// distance to y=1/x^11\nfloat sdOOXXXXXXXXXXX( in vec2", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\nfloat smax(float a, float b) {\n    return max(a, b) - abs(min(a, b));\n}\n\nfloat smin(float a, float b) {\n    return min(a, b) - abs(max(a, b));\n}\n\nfloat smin(float a, float b, float k, float l) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h) + l;\n}\n\nfloat smax(float a, float b, float k, float l) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h) + l;\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.", "\n    return pow(abs(a), k);\n}\n\nfloat pabs(float a) {\n    return pabs(a, 1.0);\n}\n\nvec2 pabs(vec2 a, float k) {\n    return pow(abs(a), vec2(k));\n}\n\nvec2 pabs(vec2 a) {\n    return pabs(a, 1.0);\n}\n\nvec3 pabs(vec3 a, float k) {\n    return pow(abs(a), vec3(k));\n}\n\nvec3 pabs(vec3 a) {\n    return pabs(a, 1.0);\n}\n\nvec4 pabs(vec4 a, float k) {\n    return pow(abs(a), vec4(k));\n}\n\nvec4 pabs(vec4 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n    return pow(min(a, b), k);\n}\n\nfloat pmin(float a, float b) {\n    return pmin(a, b, 1.0);\n}\n\nvec2 pmin(vec2 a, vec2 b, float k) {\n    return pow(min(a, b), vec2(k));\n}\n\nvec2 pmin(vec2 a, vec2 b) {\n    return pmin(a, b, 1.0);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n    return pow(min(a, b), vec3(k));\n}\n\nvec3 pmin(vec3 a, vec3 b) {\n    return pmin(a, b, 1.0);\n}\n\nvec4 pmin(vec4 a, vec4 b, float k) {\n    return pow(min(a, b), vec4(k));\n}\n\nvec4 pmin(vec4 a, vec4 b) {\n    return pmin(a, b, 1.0);\n}\n\nfloat pmax(float a, float b, float k) {\n    return pow(max(a, b), k);", "\n    float a = 0.15;\n    float b = 0.25;\n    float c = 0.28;\n    float d = 0.27;\n    p = p*mat2(cos(a),sin(a),-sin(a),cos(a));\n    p.x -= 0.25;\n    p.x = abs(p.x);\n    p.x -= 0.25;\n    p = p*mat2(cos(b),sin(b),-sin(b),cos(b));\n    p.x -= 0.25;\n    p.x = abs(p.x);\n    p.x -= 0.25;\n    p = p*mat2(cos(c),sin(c),-sin(c),cos(c));\n    p.x -= 0.25;\n    p.x = abs(p.x);\n    p.x -= 0.25;\n    p = p*mat2(cos(d),sin(d),-sin(d),cos(d));\n    p.x -= 0.25;\n    p.x = abs(p.x);\n    p.x -= 0.25;\n    return length(p)-0.01;\n}\n\nfloat scene(vec2 p) {\n    return heart(p);\n}\n\nvec3 normal(vec2 p) {\n    const float d = 0.0001;\n    return normalize(vec3(\n        scene(p + vec2(d, 0)) - scene(p - vec2(d, 0)),\n        scene(p + vec2(0, d)) - scene(p - vec2(0, d)),\n        1.0\n    ));\n}\n\nvec3 lighting(vec3 p, vec3 n) {\n    vec3 light = normalize(vec3(0.5, 0.8, 0.3));\n    vec3 color = vec3(0.9, 0.9, 0.9);\n    float diff = clamp(dot(n, light), 0.0, 1.0);\n", "\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash without Sine\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\nfloat hash12(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash without Sine\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\nfloat hash12(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash without Sine\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\nfloat hash12(vec2 p) {\n    float h = dot(p, vec2(12", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / (c.x*c.y - b.x*b.y);\n    vec2 p1 = (c*d.y - b*c.y)*kk;\n    vec2 p2 = (b*d.x - a*b.x)*kk;\n    vec2 der = (6.0*c*p1 + 2.0*b*p2)*kk;\n\n    return vec3( dot(d,p1), dot(d,p2), length(der) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec4 sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C )\n{\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / (c.x*c.y*c.z - b.x*b.y*c.z - b.x*c.y*b.z - b.y*c.x*b.z + b.y*b.x*c.z + b.z*b.x*b.y);\n    vec3 p1 = (c*d.y*d.z - b*c.y*d.z - b*d.y*c.z + c*b.y*b.z)*kk;\n    vec3 p2 = (b*d.x*d.z - a*c.y*d.z - a*d.y*c.z + b*a.y*b", "\n    vec2 p = pos.xy;\n    float k = (wi + he) / wi;\n    float f = k * p.x;\n    return vec3( f * f - k * p.y, 2.0 * f, -k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float hf )\n{\n    vec2 p = pos.xy;\n    float k = (wi + he) / wi;\n    float f = k * p.x;\n    return vec3( f * f - k * p.y + hf, 2.0 * f, -k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float hf, in float hg )\n{\n    vec2 p = pos.xy;\n    float k = (wi + he) / wi;\n    float f = k * p.x;\n    return vec3( f * f - k * p.y + hf, 2.0 * f, -k + hg );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float hf, in float hg, in float hh )\n{\n    vec2 p = pos.xy;\n    float k = (wi + he) / wi;\n    float f = k * p.x;", "\n    return vec3( pos.x*pos.x - k*pos.y, 2.0*pos.x, -k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in vec2 k )\n{\n    return vec3( pos.x*pos.x - k.x*pos.y, 2.0*pos.x, -k.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float k, in float h )\n{\n    return vec3( (pos.x*pos.x - k*pos.y) - h*pos.y, 2.0*pos.x, -k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in vec2 k, in float h )\n{\n    return vec3( (pos.x*pos.x - k.x*pos.y) - h*pos.y, 2.0*pos.x, -k.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float k, in vec2 h )\n{\n    return vec3( (pos.x*pos.x - k*pos.y) - h.x", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = r - d;\n    float g = r - (ra + rb * cos(a * 3.0));\n    return vec3(f, g * cos(a), g * sin(a));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdSphere(vec2 p, float r)\n{\n    return vec3(length(p) - r, p.x, p.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTorus(vec2 p, float ra, float rb)\n{\n    vec2 q = vec2(length(p) - ra, atan(p.y, p.x));\n    return vec3(length(q) - rb, q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return vec3(length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0), d.x, d.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTriangle(vec2 p, vec", "\n    v = v * 1664525 + 1013904223;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 c)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += c.x;\n    v.y += c.y;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 c, ivec2 d)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += c.x;\n    v.y += c.y;\n    v.x += d.x;\n    v.y += d.y;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 c, ivec2 d, ivec2 e)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += c.x;\n    v.y += c.y;\n    v.x += d.x;\n    v.y += d.y;\n    v.x += e.x;\n    v.y += e.y;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 c, ivec2 d, ivec2 e, ivec2 f)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += c.x;\n    v.y += c.y;\n    v.x += d.x;\n    v.y += d.y;\n    v.x += e.x;\n    v.y += e.y;\n    v.x += f.x;\n    v.y += f.y;\n    return v;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 c, ivec2 d", "\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nuvec3 Pcg3(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nfloat Pcg1(float v)\n{\n    v = v * 1664525.0f + 1013904223.0f;\n    v += v * v;\n    v ^= v >> 16;\n    v += v * v;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nvec2 Pcg2(vec2 v)\n{\n    v = v * 166", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(a,d);\n\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0 ) {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else {\n        float z = sqrt(-p3);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*sqrt(k", "\n    return (a.x - p.x) * (b.y - p.y) - (a.y - p.y) * (b.x - p.x);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) + winding_sign(p, c, d, a) + winding_sign(p, d, a, b);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) + winding_sign(p, d, e, a) + winding_sign(p, e, a, b) + winding_sign(p, b, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) + winding_sign(p, e, f, a) + winding_sign(p, f, a, b) + winding_sign(p, b, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b, c, d, e, f) + winding_sign(p, f, g, a) + winding_sign(p, g, a, b) + winding_sign(p, b, c", "\n    // wedge is centered at the origin\n    // and aligned with the xz plane\n    // s.x = wedge length\n    // s.y = wedge height\n    // s.z = wedge width\n\n    // rotate the ray into the wedge's coordinate system\n    // and translate it to the origin\n    vec3 rd2 = rotateX( rd, -PI/2.0 );\n    rd2.xz = rd2.xz - ro.xz;\n\n    // compute the intersection of the ray with the wedge\n    // the ray intersects the wedge if:\n    //  rd2.x > 0\n    //  rd2.x < s.x\n    //  rd2.z > -s.y\n    //  rd2.z < s.y + s.z\n    //  rd2.y > 0\n    //  rd2.y < s.y\n    //\n    //  rd2.x > 0\n    //  rd2.x < s.x\n    //  rd2.z > -s.y\n    //  rd2.z < s.y + s.z\n    //  rd2.y > 0\n    //  rd2.y < s.y\n    //\n    //  rd2.x > 0\n    //  rd2.x < s.x\n    //  rd2.z > -s.y\n    //  rd2.z < s.y + s.z\n    //  rd2.y > 0\n    //  rd2.y < s.y\n    //\n    //  rd2.x > 0\n    //  rd2.x < s.x\n    //  rd2.z > -s.y\n    //  rd2.z < s.y + s.z\n    //  rd2.y > 0\n    //  rd2.y < s.y\n    //\n    //  rd2.x > 0\n    //  rd2.x < s.x\n    //  rd2.z", "\n    float a_f = float(a);\n    float ret = fract(a_f*b+x);\n    ret_n = int(floor(a_f*b+x));\n    return ret;\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_i24 (out int ret_n, int a, int b, int x) {\n    float a_f = float(a);\n    float b_f = float(b);\n    float ret = fract(a_f*b_f+float(x));\n    ret_n = int(floor(a_f*b_f+float(x)));\n    return ret;\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_i24 (out int ret_n, int a, int b, float x) {\n    float a_f = float(a);\n    float b_f = float(b);\n    float ret = fract(a_f*b_f+x);\n    ret_n = int(floor(a_f*b_f+x));\n    return ret;\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_i24 (out int ret_n, float a, int b, float x", "\n    float h = clamp( 0.5 + 0.5*(b.x - a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h)*vec3(1.0-h);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    float h = clamp( 0.5 + 0.5*(a.x - b.x)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h)*vec3(1.0-h);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMinMax( in vec3 a, in vec3 b, in float k )\n{\n    float h = clamp( 0.5 - 0.5*(b.x - a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h)*vec3(1.0-h);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMinMax( in vec3 a, in vec3 b, in float k, in float l )\n{\n    float h = clamp( 0.5 - 0.5*(b.x - a.x)/k, 0.0", "\n    return (pow(p.x,2)/pow(ab.x,2))-(pow(p.y,2)/pow(ab.y,2));\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c){\n    return (pow(p.x-c.x,2)/pow(ab.x,2))-(pow(p.y-c.y,2)/pow(ab.y,2));\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c, in vec2 d){\n    return (pow(p.x-c.x,2)/pow(ab.x,2))-(pow(p.y-c.y,2)/pow(ab.y,2))-(pow(d.x-c.x,2)/pow(ab.x,2))+(pow(d.y-c.y,2)/pow(ab.y,2));\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c, in vec2 d, in vec2 e){\n    return (pow(p.x-c.x,2)/pow(ab.x,2))-(pow(p.y-c.y,2)/pow(ab.y,2))-(pow(d.x-c.x,2)/pow(ab.x,2))+(pow(d.y-c.y,2)/pow(ab.y,2))-(pow(e.x-c.x,2)/pow(ab.x,2))+(pow(e.y-c.y,2)/pow(ab.y,2));\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 c, in vec2 d, in vec2 e, in vec2 f){\n    return (pow(p.x-c.", "\n    return a + b;\n}\n\n//precision loss testing\nvec2 add_ploss(in vec2 a, in vec2 b){\n    return a + b;\n}\n\n//precision loss testing\nvec3 add_ploss(in vec3 a, in vec3 b){\n    return a + b;\n}\n\n//precision loss testing\nvec4 add_ploss(in vec4 a, in vec4 b){\n    return a + b;\n}\n\n//precision loss testing\nivec2 add_ploss(in ivec2 a, in ivec2 b){\n    return a + b;\n}\n\n//precision loss testing\nivec3 add_ploss(in ivec3 a, in ivec3 b){\n    return a + b;\n}\n\n//precision loss testing\nivec4 add_ploss(in ivec4 a, in ivec4 b){\n    return a + b;\n}\n\n//precision loss testing\nuvec2 add_ploss(in uvec2 a, in uvec2 b){\n    return a + b;\n}\n\n//precision loss testing\nuvec3 add_ploss(in uvec3 a, in uvec3 b){\n    return a + b;\n}\n\n//precision loss testing\nuvec4 add_ploss(in uvec4 a, in uvec4 b){\n    return a + b;\n}\n\n//precision loss testing\nbvec2 add_ploss(in bvec2 a, in bvec2 b){\n    return a + b;\n}\n\n//precision loss testing\nbvec3 add_ploss(in bvec3 a, in bvec3 b){\n    return a + b;\n}\n\n//precision loss testing\nbvec4 add_ploss(in bvec4 a, in bvec4 b){\n    return a + b;\n}\n\n//precision loss testing\nmat2 add_ploss(in mat2 a, in mat2 b){\n    return a + b;\n}\n\n//precision loss testing\nmat3 add_ploss(in mat3 a, in mat3 b){\n    return a + b;\n}", "\n    vec2 a = ab;\n    vec2 b = vec2(a.y, -a.x);\n    vec2 c = vec2(0.0, 0.0);\n    vec2 d = vec2(0.0, 0.0);\n    vec2 e = vec2(0.0, 0.0);\n    vec2 f = vec2(0.0, 0.0);\n    vec2 g = vec2(0.0, 0.0);\n    vec2 h = vec2(0.0, 0.0);\n    vec2 i = vec2(0.0, 0.0);\n    vec2 j = vec2(0.0, 0.0);\n    vec2 k = vec2(0.0, 0.0);\n    vec2 l = vec2(0.0, 0.0);\n    vec2 m = vec2(0.0, 0.0);\n    vec2 n = vec2(0.0, 0.0);\n    vec2 o = vec2(0.0, 0.0);\n    vec2 p1 = vec2(0.0, 0.0);\n    vec2 p2 = vec2(0.0, 0.0);\n    vec2 p3 = vec2(0.0, 0.0);\n    vec2 p4 = vec2(0.0, 0.0);\n    vec2 p5 = vec2(0.0, 0.0);\n    vec2 p6 = vec2(0.0, 0.0);\n    vec2 p7 = vec2(0.0, 0.0);\n    vec2 p8 = vec2(0.0, 0.0);\n    vec2 p9 = vec2(0.0, 0.0);\n    vec2 p10 = vec2(0.0, 0.0);\n    vec2 p11 = vec2(0.0, 0.0);\n    vec2 p12 = vec2(0.0, 0.0);\n    vec2 p13 = vec2(0.0, 0.0);\n", "\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 apPerp = ap - dot(ab, ap) * ab;\n    float r = (rb - ra) * clamp(dot(ab, apPerp) / dot(ab, ab), 0.0, 1.0) + ra;\n    float d = length(apPerp);\n    return vec4(d - r, apPerp);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCone(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    vec3 apPerp = ap - t * ab;\n    float d = length(apPerp);\n    return vec4(d - r, apPerp);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec4 sdcCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 apPerp = ap - t * ab;\n    float d = length(apPerp);\n    return vec4(d - r, apPerp);\n}\n\n//.x   distance to the sphere\n//.yzw closest point\nvec4 sdcSphere(vec3 p, vec3 c, float r)\n{\n    return vec4(length(p - c) - r, p - c);\n}\n\n//.x   distance to the box\n//.yzw closest point\nvec4 sdcBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return vec4(length(max(d, vec3(0.0))) + min(max(d.x, max(d.y, d.z)), 0.", "\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - mix( r1, r2, h );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2, out float h )\n{\n  vec3 pa = p - a, ba = b - a;\n  h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - mix( r1, r2, h );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2, out float h, out vec3 pos )\n{\n  vec3 pa = p - a, ba = b - a;\n  h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  pos = a + ba*h;\n  return length( pa - ba*h ) - mix( r1, r2, h );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2, out float h, out vec3 pos, out vec3 normal )\n{\n  vec3 pa = p - a, ba = b - a;\n  h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  pos = a + ba*h;\n  normal = normalize( ba );\n  return length( pa - ba*h ) - mix( r1, r2, h", "\n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h )\n{\n  return sdCappedCylinder(p,vec2(h,h));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec3(q,q,p.z));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p,", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n        map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n        map( pos + eps.yyx ).x - map( pos - eps.yyx ).x );\n    return normalize( nor );\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCylinder( vec3 p, float r, float h )\n{\n    vec2 d = abs( vec2( length( p.xz ), p.y ) ) - vec2( r, h );\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length( p.xz ), p.y );\n    vec2 k1 = vec2( r2, h );\n    vec2 k2 = vec2( r2 - r1, 2.0 * h );\n    vec2 ca = vec2( q.x - min( q.x, ( q.y < 0.0 )? r1 : r2 ), abs( q.y ) - h );\n    vec2 cb = q - k1 + k2 * clamp( dot( k1 - q, k2 ) / dot2( k2 ), 0.0, 1.0 );\n    float s", "\n    float res = 1.0;\n    float t = 0.001;\n    float h;\n    for( int i=0; i<16; i++ )\n    {\n        h = DE( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.005 || t>20.0 ) break;\n    }\n    if( showSurface )\n    {\n        float h = DE( samplePoint );\n        res = min( res, 8.0*h/t );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = DE( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\n// https://www.shadertoy.com/view/4tK3z2\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize( vec3(\n           DE(pos+eps.xyy) - DE(pos-eps.xyy),\n           DE(pos+eps.yxy) - DE(pos-eps.yxy),\n           DE(pos+eps.yyx) - DE(pos-eps.yyx) ) );\n}\n\n// https", "\n    vec2 p2 = p;\n    p2.x = abs(p2.x);\n    p2.y = abs(p2.y);\n    float d = max( p2.x - ra, p2.y - he );\n    float e = min( p2.x - rb, p2.y - he );\n    ocl = vec2( d, e );\n    return vec3( max(d,e), d - e, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundBox( in vec2 p, in vec2 b, in float r, out vec2 ocl )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    float e = length(q) - r;\n    ocl = vec2( d, e );\n    return vec3( max(d,e), d - e, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRoundBox2( in vec2 p, in vec2 b, in float r, out vec2 ocl )\n{\n    vec2 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    float e = length(q) - r;\n    ocl = vec2( d, e );\n    return vec3( max(d,e), d - e, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(", "\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( length( q ) - rb, q );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor radius?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc )\n{\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( length( q ) - rb, q, rc );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor radius?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd )\n{\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( length( q ) - rb, q, rc, rd );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor radius?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re )\n{\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( length( q ) - rb, q, rc, rd, re );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor radius?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re, float rf )\n{\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( length( q ) - rb, q, rc, rd, re, rf );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor radius?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re, float rf, float rg )\n{\n    vec", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat udTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross(ba, ac);\n\n    return sqrt(\n        (sign(nor.x) + sign(nor.y) - 2.0*sign(dot(ba, nor))) *\n        min(min(\n            dot2(ba*clamp(dot(ba, pa)/dot2(ba), 0.0, 1.0)-pa),\n            dot2(cb*clamp(dot(cb, pb)/dot2(cb), 0.0, 1.0)-pb)),\n            dot2(ac*clamp(dot(ac, pc)/dot2(ac), 0.0, 1.0)-pc))/\n        dot2(nor));\n}\n\nfloat udEquilateralTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a; vec2 pa = p - a;\n    vec2 cb = c - b; vec2 pb = p - b;\n    vec2 ac = a - c; vec2 pc = p - c;\n    vec2 nor = cross", " return dot(v, v); }\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab * t + a) - p) - r;\n}\n\n// Cylinder https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder(in vec3 p, in vec3 c) {\n    return length(p.xz - c.xy) - c.z;\n}\n\n// Cone https://iquilezles.org/articles/distfunctions/\nfloat sdCone(in vec3 p, in float c, in float h) {\n    // c is the cone radius and h is the height\n    // Alternatively: float c = cos(cone_angle); float h = sin(cone_angle);\n    float q = length(p.xz);\n    return dot(c / q, vec2(q, p.y)) - h;\n}\n\n// Torus https://iquilezles.org/articles/distfunctions/\nfloat sdTorus(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Box https://iquilezles.org/articles/distfunctions/\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Sphere https://iquilezles.org/articles/distfunctions/\nfloat sdSphere(in vec3 p, in float s) {\n    return length(p) - s;\n}\n\n// Plane https://iquilezles.org/articles/distfunctions/\nfloat sdPlane(in vec3 p, in vec4 n) {\n    // n must be normalized", "\n    vec2 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float epsilon ) \n{\n    vec2 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d) + epsilon;\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in float epsilon ) \n{\n    vec3 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d) + epsilon;\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner, in float epsilon ) \n{\n    vec4 d = max(abs(p - minCorner), abs(p - maxCorner));\n    return dot(d, d) + epsilon;\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqA", "\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    vec3 p = vec3(uv, 0.0);\n    vec3 r = normalize(reflect(cdir, n));\n    vec3 v = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 h = normalize(l + v);\n\n    float fresnel = clamp(1.0 + dot(n, v), 0.0, 1.0);\n    fresnel = pow(fresnel, 5.0);\n\n    float spec = clamp(dot(n, h), 0.0, 1.0);\n    spec = pow(spec, 100.0);\n\n    float dist = length(p);\n    float height = 0.0;\n    float noise = 0.0;\n    float noise2 = 0.0;\n    float noise3 = 0.0;\n    float noise4 = 0.0;\n    float noise5 = 0.0;\n    float noise6 = 0.0;\n    float noise7 = 0.0;\n    float noise8 = 0.0;\n    float noise9 = 0.0;\n    float noise10 = 0.0;\n    float noise11 = 0.0;\n    float noise12 = 0.0;\n    float noise13 = 0.0;\n    float noise14 = 0.0;\n    float noise15 = 0.0;\n    float noise16 = 0.0;\n    float noise17 = 0.0;\n    float noise18 = 0.0;\n    float noise19 = 0.0;\n    float noise20 = 0.0;\n    float noise21 = 0.0;\n    float noise22 = 0.0;\n    float noise23 = 0.0;\n    float noise24 =", "\n    vec2 xy = 2.0 * uv - 1.0;\n    float z = -sqrt(1.0 - dot(xy, xy));\n    return normalize(vec3(xy, z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov)\n{\n    vec2 xy = 2.0 * uv - 1.0;\n    float z = -sqrt(1.0 - dot(xy, xy)) * tan(fov * 0.5);\n    return normalize(vec3(xy, z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, vec2 aspect)\n{\n    vec2 xy = 2.0 * uv - 1.0;\n    float z = -sqrt(1.0 - dot(xy, xy)) * tan(fov * 0.5) / aspect.y;\n    return normalize(vec3(xy, z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, vec2 aspect, vec2 nearFar)\n{\n    vec2 xy = 2.0 * uv - 1.0;\n    float z = -sqrt(1.0 - dot(xy, xy)) * tan(fov * 0.5) / aspect.y;\n    return normalize(vec3(xy, mix(nearFar.x, nearFar.y, z)));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float fov, vec2 aspect, vec2 nearFar, vec2 lens)\n{\n    vec2 xy = 2.0 * uv - 1.0;\n    float z = -sqrt(1.0 - dot(xy, xy)) * tan(fov * 0.5) / aspect.y;\n    return normalize(vec3(xy, mix(nearFar.x, nearFar.", "\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, float w)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v) + q.w * w * q.xyz;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 w)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v) + cross(q.xyz, w);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 w, float t)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v) + cross(q.xyz, w) * t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 w, vec3 t)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v) + cross(q.xyz, w) * t.x + cross(q.xyz, t) * q.w;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 w, vec3 t, float u)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v) + cross(q.xyz, w) * t.x + cross(q.xyz, t) * q.w + q.xyz * u;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v, vec3 w, vec3 t, vec3 u)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz", "\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i, in float o )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i + o;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i, in float o, in float a )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i + o - a;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    return length(max(vec2(0.0),abs(vec2(length(p-a),p.y-a.y)-vec2(length(p-b),b.y-a.y))-vec2(r,r)))-r;\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b )\n{\n    return sdCapsule(p, a, b, 0.01);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdCapsule(p, a, b, r);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sd", "\n    return vec2( d, a );\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opSmoothSubtraction( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opSmoothIntersection( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opRepeat( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opTwist( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opTorus( vec2 m, float d, float a )\n{\n    return vec2( d, a );\n}\n\nvec2 opUnion( vec2 m1, vec2 m2 )\n{\n    return vec2( min( m1.x, m2.x ), max( m1.y, m2.y ) );\n}\n\nvec2 opSubtraction( vec2 m1, vec2 m2 )\n{\n    return vec2( max( m1.x, -m2.x ), max( m1.y, -m2.y ) );\n}\n\nvec2 opIntersection( vec2 m1, vec2 m2 )\n{\n    return vec2( max( m1.x, m2.x ), min( m1.y, m2.y ) );\n}\n\nvec2 opSmoothUnion( vec2 m1, vec2 m2, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( m2.x - m1.x ) / k, 0.0, 1.0 );\n    return vec2(", "\n    vec2 oc = ro - vec2(0.0,0.0);\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) {\n        p1 = vec4(0.0,0.0,0.0,0.0);\n        p2 = vec4(0.0,0.0,0.0,0.0);\n    } else {\n        h = sqrt( h );\n        p1 = vec4( -b-h, 0.0, 0.0, 1.0 );\n        p2 = vec4( -b+h, 0.0, 0.0, 1.0 );\n    }\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    // camera\n    vec3 ro = vec3( 0.0, 0.0, 2.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 z = normalize( ta - ro );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    vec3 x = normalize( cross( z, up ) );\n    vec3 y = normalize( cross( x, z ) );\n    vec3 rd = normalize( p.x*x + p.y*y + 1.5*z );\n\n    // raymarch\n    vec4 p1, p2;\n    intersectCircle( ro, rd, 0.5, p1, p2 );\n    float t = p1.x;\n    if( t>0.0 ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = normalize( pos - vec3(0.0,0.0,0.0) );\n        vec", "\n    return vec3( length(p-c)-r, (p-c)/length(p-c) );\n}\n\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r ) \n{\n    return vec3( length(p-c)/r-1.0, (p-c)/length(p-c) );\n}\n\nvec3 sdgRect( in vec2 p, in vec2 c, in vec2 s ) \n{\n    return vec3( max(abs(p-c)-s,0.0)/length(max(abs(p-c)-s,0.0)), \n                 sign(max(abs(p-c)-s,0.0)) );\n}\n\nvec3 sdgRoundRect( in vec2 p, in vec2 c, in vec2 s, in float r ) \n{\n    return vec3( length(max(abs(p-c)-s,0.0))-r, \n                 (p-c)/length(max(abs(p-c)-s,0.0)) );\n}\n\nvec3 sdgPolygon( in vec2 p, in vec2 c, in float r, in int n ) \n{\n    float a = atan(p.x-c.x,p.y-c.y)+PI;\n    float b = TWO_PI/float(n);\n    return vec3( cos(floor(.5+a/b)*b-a)*length(p-c)-r, \n                 normalize(p-c) );\n}\n\nvec3 sdgStar( in vec2 p, in vec2 c, in float r1, in float r2, in int n ) \n{\n    float a = atan(p.x-c.x,p.y-c.y)+PI;\n    float b = TWO_PI/float(n);\n    return vec3( cos(floor(.5+a/b)*b-a)*length(p-c)-r2, \n                 normalize(p-c) );\n}\n\nvec3 sdgHeart( in vec2 p, in vec2 c, in float r1, in float r", "\n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0))+min(max(d.x,d.y),0.0),\n                -sign(max(d.x,d.y)));\n}\n\nvec3 sdgEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if (p.x > p.y) { p=p.yx; ab=ab.yx; }\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/ab.y; float m2 = m*m;\n    float n = ab.y*p.y/ab.x; float n2 = n*n;\n    float c = (m2+n2-l)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    if (d<0.0) return vec3(0.0);\n    float a = pow(abs(q/2.0+sqrt(d)),1.0/3.0);\n    a = (a-c)/a;\n    vec2 p1 = vec2(g*a+m*n2/(a*ab.x), p.y);\n    vec2 p2 = vec2(m-g*a+n2/(a*ab.y), p.x);\n    return vec3(length(p-p1)+length(p-p2), normalize(p-p1));\n}\n\nvec3 sdgRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b+r;\n    return vec3(length(max(q,0.0))+min(max(q.x,q.y),0.0)-r,\n                -sign(max(q.x,q.y)));\n}\n\nvec3 sdgRoundEllipse( in vec2 p,", "\n    float x = p.x;\n    float y = p.y;\n    float z = 0.0;\n    float r = sqrt(x*x + y*y);\n    float a = 1.0;\n    float b = 0.15;\n    float c = 0.28;\n    float d = 0.85;\n    float e = 0.05;\n    float f = 0.05;\n    float g = 0.4;\n    float h = 0.04;\n    float i = 0.1;\n    float j = 0.5;\n    float k = 0.5;\n    float l = 0.1;\n    float m = 0.005;\n    float n = 0.01;\n    float o = 0.02;\n    float p2 = 0.2;\n    float q = 0.01;\n    float r2 = 0.2;\n    float s = 0.02;\n    float t = 0.02;\n    float u = 0.02;\n    float v = 0.02;\n    float w = 0.02;\n    float x2 = 0.02;\n    float y2 = 0.02;\n    float z2 = 0.02;\n    float aa = 0.02;\n    float ab = 0.02;\n    float ac = 0.02;\n    float ad = 0.02;\n    float ae = 0.02;\n    float af = 0.02;\n    float ag = 0.02;\n    float ah = 0.02;\n    float ai = 0.02;\n    float aj = 0.02;\n    float ak = 0.02;\n    float al = 0.02;\n    float am = 0.02;\n    float an = 0.02;\n    float ao = 0.02;\n    float ap = 0.02;\n    float aq = ", "\n  return (a1 * pow(x, b1)) + (a2 * pow(x, b2));\n}\n\nfloat wobble(float x) {\n  float a1 = 1.0;\n  float b1 = 1.0;\n  float a2 = 1.0;\n  float b2 = 1.0;\n  float y = g(a1, b1, a2, b2, x);\n  return y;\n}\n\nfloat wobble(float x, float a1, float b1, float a2, float b2) {\n  float y = g(a1, b1, a2, b2, x);\n  return y;\n}\n\nfloat wobble(float x, float a1, float b1, float a2, float b2, float a3, float b3) {\n  float y = g(a1, b1, a2, b2, x);\n  y = g(a3, b3, a2, b2, y);\n  return y;\n}\n\nfloat wobble(float x, float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4) {\n  float y = g(a1, b1, a2, b2, x);\n  y = g(a3, b3, a2, b2, y);\n  y = g(a4, b4, a2, b2, y);\n  return y;\n}\n\nfloat wobble(float x, float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4, float a5, float b5) {\n  float y = g(a1, b1, a2, b2, x);\n  y = g(a3, b3, a2, b2, y);\n  y = g(a4, b4, a2, b2, y);\n  y = g(a5, b5, a2, b2, y);\n  return y;\n}\n\nfloat wobble(float x, float a1, float b1, float", "\n  return pow(abs(x), n) * sin(a * x + b);\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h2(float a, float b, float n, float x) {\n  return pow(abs(x), n) * sin(a * x + b);\n}\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h3(float a, float b, float n, float x) {\n  return pow(abs(x), n) * sin(a * x + b);\n}\n\n// Slow push -> wobble (yellow)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h4(float a, float b, float n, float x) {\n  return pow(abs(x), n) * sin(a * x + b);\n}\n\n// Slow push -> wobble (orange)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h5(float a, float b, float n, float x) {\n  return pow(abs(x), n) * sin(a * x + b);\n}\n\n// Slow push -> wobble (purple)", "\n                float noise = 0.0;\n                float freq = 1.0;\n                float amp = 0.05;\n                for(int i = 0; i < 4; i++){\n                    float n = rand(uv * freq);\n                    noise += n * amp;\n                    amp *= 0.5;\n                    freq *= 2.0;\n                }\n                return noise;\n            }\n\n            void main() {\n                vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n                vec2 p = uv * 10.0;\n                float noise = paperNoise(p);\n                vec3 color = vec3(noise);\n                gl_FragColor = vec4(color, 1.0);\n            }\n        `,\n        {\n            u_resolution: [width, height],\n        },\n    );\n\n    const render = () => {\n        shader.uniforms.u_resolution = [width, height];\n        shader.draw();\n    };\n\n    return {\n        render,\n    };\n};\n\nconst createShader = (gl, { vertex, fragment, uniforms }) => {\n    const program = createProgram(gl, vertex, fragment);\n    const uniformSetters = getUniformSetters(gl, program);\n    const attributes = getAttributes(gl, program);\n\n    const setUniforms = (uniforms) => {\n        Object.entries(uniforms).forEach(([name, value]) => {\n            const setter = uniformSetters[name];\n            if (setter) {\n                setter(value);\n            }\n        });\n    };\n\n    const draw = () => {\n        gl.useProgram(program);\n        setUniforms(uniforms);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n\n    return {\n        program,\n        uniforms: uniformSetters,\n        attributes,\n        draw,\n    };\n};\n\nconst createProgram = (gl, vertex, fragment) => {\n    const vertexShader = createShader(gl", "\n    vec3 sum = vec3(0.0);\n    for( int i = 0; i < 3; i++ )\n    {\n        for( int j = 0; j < 3; j++ )\n        {\n            sum += texture2D(u_texture, vec2(x + i - 1, y + j - 1)).rgb;\n        }\n    }\n    return sum / 9.0;\n}\n\nvoid main()\n{\n    vec2 uv = v_texCoord;\n    vec3 color = texture2D(u_texture, uv).rgb;\n    vec3 blur = compute(int(uv.x), int(uv.y));\n    gl_FragColor = vec4(color + blur, 1.0);\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 sum = vec3(0.0);\n    for( int i = 0; i < 3; i++ )\n    {\n        for( int j = 0; j < 3; j++ )\n        {\n            sum += texture2D(u_texture, vec2(x + i - 1, y + j - 1)).rgb;\n        }\n    }\n    return sum / 9.0;\n}\n\nvoid main()\n{\n    vec2 uv = v_texCoord;\n    vec3 color = texture2D(u_texture, uv).rgb;\n    vec3 blur = compute(int(uv.x), int(uv.y));\n    gl_FragColor = vec4(color + blur, 1.0);\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec3 compute( int x, int y )\n{\n    vec3 sum = vec3(0.0);\n    for( int i = 0; i < 3; i++ )\n    {\n        for( int j = 0; j < 3; j++ )\n        {\n            sum += texture2D(u_texture, vec2", "\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i, in float o )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i + o;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float i, in float o, in float a )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0) - r + e - i + o - a;\n}\n\nfloat sdRoundedBox( in", "\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) - min(max(d.x,d.y),0.0) + length(max(r,vec2(0))) - min(max(r.x,r.y),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) - min(max(d.x,d.y),0.0) + r - min(max(r,0.0),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 c, in float r, in float e )\n{\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) - min(max(d.x,d.y),0.0) + r - min(max(r,0.0),0.0) - e;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 c, in vec2 r, in float e )\n{\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) - min(max(d.x,d.y),0.0) + length(max(r,vec2(0))) - min(max(r.x,r.y),0.0) - e;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 c, in vec2 r, in vec2 e )\n{\n    vec2 d = abs(p)-c;\n    return length(max(d,vec2(0))) - min(max(d.x,d.y),0.0) + length(max(r,vec2(", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( ba.y*pa.x - ba.x*pa.y );\n}\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*sign( ba.y*pa.x - ba.x*pa.y );\n}\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*sign( ba.y*pa.x - ba.x*pa.y ) - w*h;\n}\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float d )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*sign( ba.y*pa.x - ba.x*pa.y ) - w*h - d*h*(1.0-h);\n}\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float d, in float e )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float hba = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 proj = a + ba*hba;\n    vec2 d = pa - ba*hba;\n    float l = length(d);\n    float v = abs(l - h);\n    float d2 = l*l + v*v;\n    return d2 < d2min? vec2(d2, l) : vec2(d2min, l);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float hba = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 proj = a + ba*hba;\n    vec2 d = pa - ba*hba;\n    float l = length(d);\n    float v = abs(l - h);\n    return l - h + v * 0.57735;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, in float d2min )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float hba = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 proj = a + ba*hba;\n    vec2 d = pa - ba*hba;\n    float l = length(d);\n    float v = abs(l - h);\n    float d2 = l*l + v*v;\n    return d2 < d2min? l - h + v * 0.57735 : d2min;\n}\n\n// https://iquile", "\n    float d = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, vec2( kPath[i*2], kPath[i*2+1] ),\n                                vec2( kPath[i*2+2], kPath[i*2+3] ) ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, vec2( kPath[i*2], kPath[i*2+1] ),\n                               vec2( kPath[i*2+2], kPath[i*2+3] ),\n                               kPath[i*2+4] ) );\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius )\n{\n    float d = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, vec2( kPath[i*2], kPath[i*2+1] ),\n                                vec2( kPath[i*2+2], kPath[i*2+3] ) ) );\n        }\n        else if( kType[i] == 1 )\n        {\n            d = min( d, sdArc( p, vec2( kPath[i*2], kPath[i*2+1] ),\n                               vec2( kPath[i*2+2], kPath[i*2+3] ),\n                               kPath[i*2+4] ) );\n        }\n    }\n    return d - kRadius;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius", "\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        d = max(d, abs(p.x) - p.y*k);\n        p = 2.0*p + vec2(-0.5, 0.15);\n        k *= 0.5;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        d = max(d, p.x - p.y*k);\n        p = 2.0*p + vec2(-0.5, 0.15);\n        k *= 0.5;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        d = max(d, abs(p.x) - p.y*k);\n        p = 2.0*p + vec2(-0.5, 0.15);\n        k *= 0.5;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<10; i++ )\n    {\n        d = max(d, p.x - p.y*k);\n        p = 2.0*p + vec2(-0.5, 0.15);\n        k *= 0.5;\n    }\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n    float k = 1.0;\n    float d = 0.", "\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    p = abs(p);\n    float k = max(p.x, p.y);\n    p = min(p, p.yx);\n    return length(p) - k + 0.001;\n}\n\n// correct inside, incorrect", "\n    // The grid size.\n    const float gridSize = 1.0;\n\n    // The grid spacing.\n    const float gridSpacing = 0.1;\n\n    // The grid line width.\n    const float gridLineWidth = 0.01;\n\n    // The grid line color.\n    const vec3 gridLineColor = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line color.\n    const vec3 gridLineColor2 = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor2 = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line color.\n    const vec3 gridLineColor3 = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor3 = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line color.\n    const vec3 gridLineColor4 = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor4 = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line color.\n    const vec3 gridLineColor5 = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor5 = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line color.\n    const vec3 gridLineColor6 = vec3( 0.2, 0.2, 0.2 );\n\n    // The grid background color.\n    const vec3 gridBackgroundColor6 = vec3( 0.0, 0.0, 0.0 );\n\n    // The grid line", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th, in float th2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th, in float th2, in float th3 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - length(ba)*0.5;\n}\n\n// distance to line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th, in float th2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line segment\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b, in float th, in float th2, in float th3 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h", "\n    vec2 d = abs(p) - b;\n    return (d.x>d.y)?vec2(d.x,p.y):vec2(d.y,p.x);\n}\n\n// closest point on box\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    return abs(p)-b;\n}\n\n// closest point on circle\nfloat cloCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// closest point on line segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h )*sign( ba.x*pa.y - ba.y*pa.x );\n}\n\n// closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a, pa = p - a, bc = b - c, pc = p - c, ca = c - a, ap = p - a;\n    float d1 = clamp( dot(ba, ap)/dot(ba, ba), 0.0, 1.0 );\n    float d2 = clamp( dot(bc, pc)/dot(bc, bc), 0.0, 1.0 );\n    float d3 = clamp( dot(ca, ap)/dot(ca, ca), 0.0, 1.0 );\n    vec2  bp = pa - ba*d1, cp = pc - bc*d2;\n    return length( bp ) < length( cp )? bp : cp;\n}\n\n// closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n    vec2 ba = b - a, pa = p - a, bc = b - c, pc =", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b", "\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n  return length(p)-r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n  p = abs(p); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n  float l = ab.y*ab.y - ab.x*ab.x;\n  float m = ab.x*p.x/ab.y;\n  float n = ab.y*p.y/ab.x;\n  float m2 = m*m;\n  float n2 = n*n;\n\n  float c = (m2 + n2 - 1.0)/3.0;\n  float c3 = c*c*c;\n\n  float q = c3 + m2*n2*2.0;\n  float d = c3 + m2*n2;\n  float g = m + m*n2;\n\n  float co;\n  if( d<0.0 )\n  {\n    float p = acos(q/c3)/3.0;\n    float s = cos(p);\n    float t = sin(p)*sqrt(3.0);\n    float rx = sqrt( -c*(s + t + 2.0) + m2 );\n    float ry = sqrt( -c*(s - t + 2.0) + m2 );\n    co = (ry+sign(l)*rx+abs(g)/(rx*ry)-m)/2", "\n\tvec3 p3  = fract(p.xyx * vec3(443.8975,397.2973, 491.1871));\n\tp3 += dot(p3, p3.yxz+19.19);\n\treturn fract((p3.x + p3.y)*p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(p.xyx * vec3(443.8975,397.2973, 491.1871));\n\tp3 += dot(p3, p3.yxz+19.19);\n\treturn fract((p3.x + p3.y)*p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(p.xyx * vec3(443.8975,397.2973, 491.1871));\n\tp3 += dot(p3, p3.yxz+19.19);\n\treturn fract((p3.x + p3.y)*p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(p.xyx * vec3(443.8975,397.2973, 491.1871));\n\tp3 += dot(p3, p3", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 56.837))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 56.837, 99.234))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y)\n{\n    return fract(sin(x + y) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z)\n{\n    return fract(sin(x + y + z) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w)\n{\n    return fract(sin(x + y + z + w) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w, float u)\n{\n    return fract(sin(x + y + z + w + u) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// From iq\nfloat fbm(vec2 st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise(st);\n        st = st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// From iq\nfloat fbm2(vec2 st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise(st);\n        st = st * 2.0 + shift;", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float a = rand(p);\n    float b = rand(p + vec2(1.0, 0.0));\n    float c = rand(p + vec2(0.0, 1.0));\n    float d = rand(p + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = rand(p);\n    float b = rand(p + vec3(1.0, 0.0, 0.0));\n    float c = rand(p + vec3(0.0, 1.0, 0.0));\n    float d = rand(p + vec3(1.0, 1.0, 0.0));\n    float e = rand(p + vec3(0.0, 0.0, 1.0));\n    float f = rand(p + vec3(1.0, 0.0, 1.0));\n    float g = rand(p + vec3(0.0, 1.0, 1.0));\n    float h = rand(p + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u", "\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 6; ++i)\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D noise function\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0;\n    float res = mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n    return res;\n}\n\n// 1D noise function\nfloat noise(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p;\n    return mix(hash(n), hash(n + 1.0), f);\n}\n\n// 1D noise function\nfloat noise(float x, float y)\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p + y * 57.0;\n    return mix(hash(n), hash(n + 1.0), f);\n}\n\n// 2D noise function\nfloat noise(vec2 x, vec2 y)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57", "\n    float f = 0.0;\n    f += 0.5000*texture(iChannel0, x + vec2(0.0, 0.0)).x;\n    f += 0.2500*texture(iChannel0, x + vec2(1.0, 0.0)).x;\n    f += 0.1250*texture(iChannel0, x + vec2(0.0, 1.0)).x;\n    f += 0.0625*texture(iChannel0, x + vec2(1.0, 1.0)).x;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 10.0;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Warp the space\n    vec2 warp = vec2(0.0);\n    warp.x = pattern(i + vec2(0.0, 0.0));\n    warp.y = pattern(i + vec2(0.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 r = mix(vec2(i.x + warp.x, i.y), vec2(i.x + 1.0 + warp.y, i.y + 1.0), f.x);\n\n    // Sample the texture\n    vec3 col = texture(iChannel0, r).xyz;\n\n    // Apply vignetting\n    col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_Frag", "\n    float a = 1.0 / (1.0 + x * x + y * y);\n    return a * a;\n}\n\nfloat texelSolidAngle(float x, float y, float width, float height)\n{\n    float a = areaElement(x, y);\n    float b = areaElement(x + 1.0, y);\n    float c = areaElement(x, y + 1.0);\n    float d = areaElement(x + 1.0, y + 1.0);\n    float e = (a + b + c + d) * 0.25;\n    return e * (width * height);\n}\n\nfloat texelSolidAngle(float u, float v, float width, float height, float lod)\n{\n    float x = (u * 2.0 - 1.0) * pow(2.0, lod);\n    float y = (v * 2.0 - 1.0) * pow(2.0, lod);\n    return texelSolidAngle(x, y, width, height);\n}\n\nfloat texelSolidAngle(float u, float v, float lod)\n{\n    float x = (u * 2.0 - 1.0) * pow(2.0, lod);\n    float y = (v * 2.0 - 1.0) * pow(2.0, lod);\n    return texelSolidAngle(x, y, 1.0, 1.0);\n}\n\nfloat texelSolidAngle(float u, float v)\n{\n    float x = (u * 2.0 - 1.0);\n    float y = (v * 2.0 - 1.0);\n    return texelSolidAngle(x, y, 1.0, 1.0);\n}\n\nfloat texelSolidAngle(float u, float v, float width, float height)\n{\n    float x = (u * 2.0 - 1.0);\n    float y = (v * 2.0 - 1.0);\n    return texelSolidAngle(x, y, width, height);\n}\n\n", "\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.103", "\n    const float K = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 s = floor(p + dot(p, vec3(K2)));\n    vec3 x = p - s + dot(s, vec3(K));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 e12 = e*(1.0 - e.zxy);\n    vec3 e13 = e12*(1.0 - e12.yxz);\n    vec3 e23 = e12.yzx*e12.zxy;\n\n    vec3 t = 1.0 - e123 = vec3(e.x, e12.y, e12.z);\n    vec3 n = t - 0.166666667*e123.zxy;\n\n    vec3 q = vec3(dot(n, n), dot(n.yz, n.yz), dot(n.zxy, n.zxy));\n    vec3 c = vec3(0.886226925, 0.247708434, -0.144582225);\n    vec3 d = vec3(0.939574992, 0.315215996, -0.356675222);\n    vec3 d2 = d*d;\n\n    vec3 o = q*(c.x + q.x*(c.y + q.y*c.z));\n    vec3 a = o.x + o.y + o.z;\n    vec3 b = o.y*d.x + o.z*d.y;\n    vec3 v = o.z*d.z + o.x*d2.x;\n    vec3 w = o.x*d.y + o.y*d2.y;\n    vec3 u = o.x*d2.z + o.z*d.x", "\n    return vec2( dot( x, vec2( 127.1, 311.7 ) ),\n                 dot( x, vec2( 269.5, 183.3 ) ) );\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = hash(p);\n    float b = hash(p + vec2(1.0, 0.0));\n    float c = hash(p + vec2(0.0, 1.0));\n    float d = hash(p + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D fBm\nfloat fbm( in vec2 x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 100.0 );\n    // Rotate to reduce axial bias\n    mat2 rot = mat2( cos(0.5), sin(0.5), -sin(0.5), cos(0.50) );\n    for (int i = 0; i < 2; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D fBm\nfloat fbm( in vec2 x, int octaves )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - r + e;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float w )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - r + e - w;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float e, in float w, in float h )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,vec2(0.0))) + min(max(d.x,d.y),0.0) - r + e - w + h;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r", "\n  vec2 d = abs(p)-b+r;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b+vec2(r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-r;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in float b )\n{\n  vec2 d = abs(p)-vec2(b);\n  return length(max(d,0.0))-b;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p )\n{\n  vec2 d = abs(p);\n  return length(max(d,0.0))-min(max(d.x,d.y),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in float b )\n{\n  vec3 d = abs(p)-vec3(b);\n  return length(max(d,0.0))-b;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p )\n{\n  vec3 d = abs(p);\n  return length(max(d,0.0))-min(max(d.x,max(d.y,d.z)),0.0", "\n    // proj_info.x = 1 / tan(fov / 2)\n    // proj_info.y = 1 / tan(fov / 2) * aspect\n    vec3 view_dir = normalize(center - vec3(0, 0, 0));\n    vec3 right = normalize(cross(normal, view_dir));\n    vec3 up = cross(right, normal);\n    vec3 proj_center_3d = center + normal * radius;\n    proj_center = vec2(dot(proj_center_3d, right), dot(proj_center_3d, up));\n    vec3 major_3d = right * radius;\n    vec3 minor_3d = up * radius;\n    major = vec2(dot(major_3d, right), dot(major_3d, up)) * proj_info;\n    minor = vec2(dot(minor_3d, right), dot(minor_3d, up)) * proj_info;\n}\n\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic", "\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix(\n        mix(Hash12(i + vec2(0.0, 0.0)), Hash12(i + vec2(1.0, 0.0)), u.x),\n        mix(Hash12(i + vec2(0.0, 1.0)), Hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n\n    return n;\n}\n\nfloat Fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*Noise(p); p = p*2.02;\n    f += 0.2500*Noise(p); p = p*2.03;\n    f += 0.1250*Noise(p); p = p*2.01;\n    f += 0.0625*Noise(p);\n    return f/0.9375;\n}\n\nfloat Fbm2(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*Noise(p); p = p*2.02;\n    f += 0.2500*Noise(p); p = p*2.03;\n    f += 0.1250*Noise(p); p = p*2.01;\n    f += 0.0625*Noise(p);\n    return f/0.9375;\n}\n\nfloat Fbm3(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*No", "\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float n = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float q = 0.0;\n    float rr = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww = 0.0;\n    float xx = 0.0;\n    float yy = 0.0;\n    float zz = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff =", "\n    const float d = 0.0001;\n    return normalize( vec3(\n        map( p + vec3(  d,0.0,0.0) ) - map( p - vec3(  d,0.0,0.0) ),\n        map( p + vec3(0.0,  d,0.0) ) - map( p - vec3(0.0,  d,0.0) ),\n        map( p + vec3(0.0,0.0,  d) ) - map( p - vec3(0.0,0.0,  d) ) ) );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    vec3 cb = c - b;\n    vec3 dc = d - c;\n    vec3 pd = p - d;\n    vec3 ac = a - c;\n    vec3 bd = b - d;\n\n    float pab = dot( pa, ba );\n    float pbc = dot( pb, cb );\n    float pcd = dot( pc, dc );\n    float pda = dot( pd, da );\n    float pabab = pab * pab;\n    float pbcpc = pbc * pbc;\n    float pcdcd = pcd * pcd;\n    float pda pd = pda * pda;\n    float d1 = pabab - pab * ( pab + pbc );\n    float d2 = pbcpc - pbc * ( pbc + pcd );\n    float d3 = pcdcd - pcd * ( pcd + pda );\n    float d4 = pda pd - pda * ( pda + pab );\n\n    return sqrt( min( min( min( d1, d2 ), d3 ), d4 ) ) * sign( max( max( max( d1, d2 ), d3 ), d4 ) );\n}\n\nfloat sd", "\n    float t = t0;\n    float res = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat ambientOcclusion(vec3 ro, vec3 rd, float t0, float t1)\n{\n    float t = t0;\n    float res = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res += h;\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > t1) break;\n    }\n    return clamp(1.0 - 0.75 * res / t, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------\n\nvec3 normal(vec3 p)\n{\n    const float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n        map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n        map(p + vec3(0.0,", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor, float sca )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor, float sca, float ao )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    return mat3(\n        t * axis.x * axis.x + c,\n        t * axis.x * axis.y - s * axis.z,\n        t * axis.x * axis.z + s * axis.y,\n        t * axis.x * axis.y + s * axis.z,\n        t * axis.y * axis.y + c,\n        t * axis.y * axis.z - s * axis.x,\n        t * axis.x * axis.z - s * axis.y,\n        t * axis.y * axis.z + s * axis.x,\n        t * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the X axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the Y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Helper function generating a rotation matrix around the Z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Helper function generating a rotation matrix around the X axis by the angle\nmat3 createRotationMatrixX(float angle, vec3 axis)", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera up vector\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    // Camera lookat\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    // Camera position\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n\n    // Camera matrix\n    vec3 camVec = normalize(lookAt - camPos);\n    vec3 sideVec = cross(camUp, camVec);\n    vec3 upVec = cross(camVec, sideVec);\n\n    // Create view ray\n    vec3 viewRay = normalize(p.x * sideVec + p.y * upVec + camVec * 2.0);\n\n    return viewRay;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec3 camPos, vec3 lookAt) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera up vector\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    // Camera lookat\n    // vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    // Camera position\n    // vec3 camPos = vec3(0.0, 0.0, 2.0);\n\n    // Camera matrix\n    vec3 camVec = normalize(lookAt - camPos);\n    vec3 sideVec = cross(camUp, camVec);\n    vec3 upVec = cross(camVec, sideVec);\n\n    // Create view ray\n    vec3 viewRay = normalize(p.x *", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2d noise\nfloat noise2d(vec2 co){\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    float a = rand2dTime(i);\n    float b = rand2dTime(i + vec2(1.0, 0.0));\n    float c = rand2dTime(i + vec2(0.0, 1.0));\n    float d = rand2dTime(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 3d noise\nfloat noise3d(vec3 co){\n    vec3 i = floor(co);\n    vec3 f = fract(co);\n\n    float a = rand2dTime(i.xy);\n    float b = rand2dTime(i.xy + vec2(1.0, 0.0));\n    float c = rand2dTime(i.xy + vec2(0.0, 1.0));\n    float d = rand2dTime(i.xy + vec2(1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 4d noise\nfloat noise4d(vec4 co){\n    vec4 i = floor(co);\n    vec4 f = fract(co);\n\n    float a = rand2dTime(i.xy);\n   ", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 12.9898))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p, float seed){\n    return fract(sin(p + seed) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p, float seed){\n    return fract(sin(dot(p, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p, float seed){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 12.9898)) + seed) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p, float seed){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 12.9898, 78.23", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix(rand(n+0.0),rand(n+1.0),f.x),\n                   mix(rand(n+57.0),rand(n+58.0),f.x),f.y),\n               mix(mix(rand(n+113.0),rand(n+114.0),f.x),\n                   mix(rand(n+170.0),rand(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with a scale factor\nfloat noise3d(vec3 x, float scale){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix(rand(n+0.0),rand(n+1.0),f.x),\n                   mix(rand(n+57.0),rand(n+58.0),f.x),f.y),\n               mix(mix(rand(n+113.0),rand(n+114.0),f.x),\n                   mix(rand(n+170.0),rand(n+171.0),f.x),f.y),f.z);\n}\n\n// 3D value noise with a scale factor and a seed\nfloat noise3d(vec3 x, float scale, float seed){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57", "\n    float n = 0.0;\n    float scale = 1.0;\n    for(int i = 0; i < 3; i++){\n        n += (sin(p.x*scale)+sin(p.y*scale)+sin(p.z*scale))/3.0;\n        scale *= 2.0;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale){\n    float n = 0.0;\n    for(int i = 0; i < 3; i++){\n        n += (sin(p.x*scale)+sin(p.y*scale)+sin(p.z*scale))/3.0;\n        scale *= 2.0;\n    }\n    return n;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale, float persistence){\n    float n = 0.0;\n    float totalAmplitude = 0.0;\n    for(int i = 0; i < 3; i++){\n        n += (sin(p.x*scale)+sin(p.y*scale)+sin(p.z*scale))/3.0;\n        totalAmplitude += 1.0;\n        scale *= 2.0;\n    }\n    return n/totalAmplitude;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p, float scale, float persistence, float lacunarity){\n    float n = 0.0;\n    float totalAmplitude = 0.0;\n    for(int i = 0; i < 3; i++){\n        n += (sin(p.x*scale)+sin(p.y*scale)+sin(p.z*scale))/3.0;\n        totalAmplitude += 1.0;\n        scale *= lacunarity;\n    }\n    return n/totalAmplitude;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM2(vec3 p){\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM3(vec3 p){\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM4(vec3 p){\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.", "\n    vec2 res = vec2(0.0);\n    vec3 p = pos;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p.xz -= 1.0;\n    p.xz *= 0.5;\n    p.xz += 0.5;\n    p.xz *= 2.0;\n    p", "\n    vec3 color = vec3(0.0);\n    float coverage = 0.0;\n    float coverage2 = 0.0;\n    float coverage3 = 0.0;\n    float coverage4 = 0.0;\n    float coverage5 = 0.0;\n    float coverage6 = 0.0;\n    float coverage7 = 0.0;\n    float coverage8 = 0.0;\n    float coverage9 = 0.0;\n    float coverage10 = 0.0;\n    float coverage11 = 0.0;\n    float coverage12 = 0.0;\n    float coverage13 = 0.0;\n    float coverage14 = 0.0;\n    float coverage15 = 0.0;\n    float coverage16 = 0.0;\n    float coverage17 = 0.0;\n    float coverage18 = 0.0;\n    float coverage19 = 0.0;\n    float coverage20 = 0.0;\n    float coverage21 = 0.0;\n    float coverage22 = 0.0;\n    float coverage23 = 0.0;\n    float coverage24 = 0.0;\n    float coverage25 = 0.0;\n    float coverage26 = 0.0;\n    float coverage27 = 0.0;\n    float coverage28 = 0.0;\n    float coverage29 = 0.0;\n    float coverage30 = 0.0;\n    float coverage31 = 0.0;\n    float coverage32 = 0.0;\n    float coverage33 = 0.0;\n    float coverage34 = 0.0;\n    float coverage35 = 0.0;\n    float coverage36 = 0.0;\n    float coverage37 = 0.0;\n    float coverage38 = 0.0;\n    float coverage39 = 0.0;\n    float coverage40 = 0.0;\n    float coverage41 = 0.0;\n    float coverage42 = 0.0;\n    float coverage4", "\n    vec3 color = vec3(0.0);\n    float alpha = 0.0;\n    float fog = 0.0;\n    float fogAlpha = 0.0;\n    float fogFactor = 0.0;\n    float fogFactor2 = 0.0;\n    float fogFactor3 = 0.0;\n    float fogFactor4 = 0.0;\n    float fogFactor5 = 0.0;\n    float fogFactor6 = 0.0;\n    float fogFactor7 = 0.0;\n    float fogFactor8 = 0.0;\n    float fogFactor9 = 0.0;\n    float fogFactor10 = 0.0;\n    float fogFactor11 = 0.0;\n    float fogFactor12 = 0.0;\n    float fogFactor13 = 0.0;\n    float fogFactor14 = 0.0;\n    float fogFactor15 = 0.0;\n    float fogFactor16 = 0.0;\n    float fogFactor17 = 0.0;\n    float fogFactor18 = 0.0;\n    float fogFactor19 = 0.0;\n    float fogFactor20 = 0.0;\n    float fogFactor21 = 0.0;\n    float fogFactor22 = 0.0;\n    float fogFactor23 = 0.0;\n    float fogFactor24 = 0.0;\n    float fogFactor25 = 0.0;\n    float fogFactor26 = 0.0;\n    float fogFactor27 = 0.0;\n    float fogFactor28 = 0.0;\n    float fogFactor29 = 0.0;\n    float fogFactor30 = 0.0;\n    float fogFactor31 = 0.0;\n    float fogFactor32 = 0.0;\n    float fogFactor33 = 0.0;\n    float fogFactor34 = 0.0;\n   ", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 uncharted2_tonemap(vec3 x) {\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 uncharted2_filmic(vec3 x) {\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 uncharted2_filmic_tone_mapping(vec3 x) {\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n"]}