{"generations": [" return 0.282095f; }\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment (can't get simpler than this)\nfloat", "\n\treturn mix( v, -v, step( 0.0, dot( v, r ) ) );\n}\n\n// Returns the distance from a point to a line\nfloat", "\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec", "\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - ((w1+w2)*0.5 - abs(w1-w2)*0.5)*h;\n}\n\n// https://www.shadertoy.com/view/4sf3zW\nfloat", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn sunCol * sunDot;\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is the same as the GetSunColorReflection function, but it is used for the skybox.\nvec", "\n\tvec4 a = p2;\n\tvec4 b = p0;\n\tvec4 c = p1 - p0;\n\tvec4 d = p3 - p2;\n\tvec4 ab = b + c * t;\n\tvec4 cd = d * t;\n\treturn (a + ab + ab + cd) * 0.5;\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat phase = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tsum += amp * sin(freq * p.x + phase);\n\t\tsum += amp * sin(freq * p.y + phase);\n\t\tsum += amp * sin(freq * p.z + phase);\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t\tphase += 0.123456789;\n\t}\n\treturn sum * normalizer;\n}\n\n// This is a 3D version of the 2D simplex noise.\n// It's a bit slower than the 2D version, but it's a lot more interesting.\n// It's also a lot more complex, so it's a good idea to start with the 2D version.\nfloat", "\n\tvec4 p0 = camPath[0];\n\tvec4 p1 = camPath[1];\n\tvec4 p2 = camPath[2];\n\tvec4 p3 = camPath[3];\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p2 - p0;\n\tvec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n\tvec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n\tvec4 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n\n\treturn pos;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec", "\n\treturn fract(sin(u) * 43758.5453123);\n}\n\nfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tf += 0.5 * sin(p.x * scale + a) + 0.5 * cos(p.y * scale + a) + 0.5 * sin(p.z * scale + a);\n\t\ta += 0.1;\n\t\tscale *= 2.0;\n\t}\n\treturn f * normalizer;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td += pow(abs(p.x), 0.5) + pow(abs(p.y), 0.5) + pow(abs(p.z), 0.5);\n\t\tp = vec3(pow(abs(p.x), 0.5), pow(abs(p.y), 0.5), pow(abs(p.z), 0.5));\n\t}\n\treturn d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = normalize(rayDir);\n\tvec3 lightDir = normalize(sunDir);\n\tvec3 lightDir2 = normalize(sunDir + vec3(0.0, 0.0, -1.0));\n\tvec3 lightDir3 = normalize(sunDir + vec3(0.0, 0.0, 1.0));\n\tvec3 lightDir4 = normalize(sunDir + vec3(0.0, -1.0, 0.0));\n\tvec3 lightDir5 = normalize(sunDir + vec3(0.0, 1.0, 0.0));\n\tvec3 lightDir6 = normalize(sunDir + vec3(-1.0, 0.0, 0.0));\n\tvec3 lightDir7 = normalize(sunDir + vec3(1.0, 0.0, 0.0));\n\tvec3 lightDir8 = normalize(sunDir + vec3(0.0, 0.0, -2.0));\n\tvec3 lightDir9 = normalize(sunDir + vec3(0.0, 0.0, 2.0));\n\tvec3 lightDir10 = normalize(sunDir + vec3(0.0, -2.0, 0.0));\n\tvec3 lightDir11 = normalize(sunDir + vec3(0.0, 2.0, 0.0));\n\tvec3 lightDir12 = normalize(sunDir + vec3(-2.0, 0.0, 0.0));\n\tvec3 lightDir13 = normalize(sunDir + vec3(2.0, 0.0, 0.0));\n\tvec3 lightDir14 = normalize(sunDir + vec3(0.0, 0.0, -3.0));\n\tvec3 lightDir15 = normalize(sunDir + vec3(0.0, 0.0, 3.0));\n\tvec3 lightDir16 = normalize(sunDir + vec3(0.0, -3.0, 0.0));\n\tvec3 lightDir17 = normalize(sunDir + vec3(0.", "\n\tfloat h = clamp( 0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f );\n\tfloat res = a + h * k * (b - a);\n\treturn res;\n}\n\n// polynomial smooth max (k = 0.1);\nfloat", "\n\tfloat a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n\tfloat b = 2 * dot(dirVecPLZNormalizeMeFirst, (pos - spherePos));\n\tfloat c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n\tfloat discriminant = b * b - 4 * a * c;\n\tif (discriminant < 0)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\treturn (-b - sqrt(discriminant)) / (2 * a);\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat", "\nvec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve\nvec", "\n\treturn 3.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (acceleration)\nvec", "\n\treturn 6.0f * (1.0f - t) * (1.0f - t) * p0 + 12.0f * (1.0f - t) * t * p1 + 6.0f * t * t * p2;\n}\n\n// curve third derivative (jerk)\nvec", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// unsigned squared distance between point and triangle\nfloat", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tfloat t = dot( ao, ab ) / dot( ad, ab );\n\tvec3 p = a + t * ab;\n\tvec3 v = p - o;\n\treturn vec2( length( v ), t );\n}\n\n// unsigned squared distance between ray and triangle\nfloat", "\n\tvec2 d = abs(p) - b;\n\tvec2 a = vec2(0.0);\n\ta.x = max(d.x, d.y);\n\ta.y = max(a.x, d.z);\n\ta.y = max(a.y, d.w);\n\treturn length(max(a, 0.0)) + min(max(d.x, d.y), 0.0) + min(max(d.z, d.w), 0.0);\n}\n\n// 2D Round Box\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn sunCol * sunDot;\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is the same as the GetSunColorReflection function, but it is used for the skybox.\nvec", "\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// normalized\n\tvec3 eyeToScreenNormalized = normalize( eyeToScreen );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\tvec3 eyeToScreenRotated = rotate( eyeToScreenNormalized, roll );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\t// normalized\n\tvec3 eyeToScreenRotatedNormalized = normalize( eyeToScreenRotated );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\t// normalized\n\t// rotated by 90 degrees\n\tvec3 eyeToScreenRotatedNormalizedRotated = rotate( eyeToScreenRotatedNormalized, radians( 90.0 ) );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\t// normalized\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\tvec3 eyeToScreenRotatedNormalizedRotatedRotated = rotate( eyeToScreenRotatedNormalizedRotated, radians( 90.0 ) );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\t// normalized\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\tvec3 eyeToScreenRotatedNormalizedRotatedRotatedRotated = rotate( eyeToScreenRotatedNormalizedRotated, radians( 90.0 ) );\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\t// rotated by the roll angle\n\t// normalized\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\t// rotated by 90 degrees\n\tvec3 eyeToScreenRotatedNormalizedRotatedRotated", "\n\tvec3 center = vec3( 0.0, 0.0, 0.0 );\n\tfloat radius = 0.5;\n\tfloat height = 0.5;\n\tfloat thickness = 0.1;\n\tfloat falloff = 0.1;\n\tfloat heightFalloff = 0.1;\n\tfloat heightFalloff2 = 0.1;\n\tfloat heightFalloff3 = 0.1;\n\tfloat heightFalloff4 = 0.1;\n\tfloat heightFalloff5 = 0.1;\n\tfloat heightFalloff6 = 0.1;\n\tfloat heightFalloff7 = 0.1;\n\tfloat heightFalloff8 = 0.1;\n\tfloat heightFalloff9 = 0.1;\n\tfloat heightFalloff10 = 0.1;\n\tfloat heightFalloff11 = 0.1;\n\tfloat heightFalloff12 = 0.1;\n\tfloat heightFalloff13 = 0.1;\n\tfloat heightFalloff14 = 0.1;\n\tfloat heightFalloff15 = 0.1;\n\tfloat heightFalloff16 = 0.1;\n\tfloat heightFalloff17 = 0.1;\n\tfloat heightFalloff18 = 0.1;\n\tfloat heightFalloff19 = 0.1;\n\tfloat heightFalloff20 = 0.1;\n\tfloat heightFalloff21 = 0.1;\n\tfloat heightFalloff22 = 0.1;\n\tfloat heightFalloff23 = 0.1;\n\tfloat heightFalloff24 = 0.1;\n\tfloat heightFalloff25 = 0.1;\n\tfloat heightFalloff26 = 0.1;\n\tfloat heightFalloff27 = 0.1;\n\tfloat heightFalloff28 = 0.1;\n\tfloat heightFalloff29 = 0.1;\n\tfloat heightFalloff30 = 0.1;\n\tfloat heightFalloff", "\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH", "\n\tvec2 closestThing = vec2( 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 normal = vec3(\n\t\tsdf(positionOfHit + vec3(0.001, 0.0, 0.0)) - sdf(positionOfHit - vec3(0.001, 0.0, 0.0)),\n\t\tsdf(positionOfHit + vec3(0.0, 0.001, 0.0)) - sdf(positionOfHit - vec3(0.0, 0.001, 0.0)),\n\t\tsdf(positionOfHit + vec3(0.0, 0.0, 0.001)) - sdf(positionOfHit - vec3(0.0, 0.0, 0.001))\n\t);\n\treturn normalize(normal);\n}\n\n// This is the main function that is called by the shader\n// to calculate the color of a pixel.\nvec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// this is the function that does the actual\n// lighting. it takes in the normal of the\n// surface, the direction of the light, and\n// the color of the light.\nvec", "\n\tvec3 color = vec3(0.0,0.0,0.0);\n\tcolor = normalOfSurface;\n\treturn color;\n}\n\n// This is the function that is called to draw the\n// scene.  It is called every time the screen is\n// redrawn.\nvoid drawScene(){\n\t// Clear the screen\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t// Set the camera\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\tgluLookAt(0.0, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\t// Draw the box\n\tglPushMatrix();\n\tglTranslatef(0.0, 0.0, -5.0);\n\tglRotatef(angle, 0.0, 1.0, 0.0);\n\tglCallList(box);\n\tglPopMatrix();\n\n\t// Swap the buffers\n\tglutSwapBuffers();\n}\n\n// This function is called when the window is resized.\n// It sets up the projection matrix for the new window\n// size.\nvoid reshape(int w, int h){\n\tglViewport(0, 0, (GLsizei)w, (GLsizei)h);\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\tgluPerspective(60.0, (GLfloat)w / (GLfloat)h, 1.0, 20.0);\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n}\n\n// This function is called when a key is pressed.\n// It is passed the key that was pressed and the\n// x and y location of the mouse.\nvoid keyboard(unsigned char key, int x, int y){\n\tswitch (key) {\n\tcase 27:\n\t\texit(0);\n\t\tbreak;\n\t}\n}\n\n// This function is called when the mouse is moved.\n// It is passed the x and y location of the mouse.\nvoid mouse(int x, int y){\n\t// Do nothing\n}\n\n// This function", "\n\t// This is the color of the world\n\t// we will return at the end of this function\n\tvec3 worldColor = vec3(0.0);\n\n\t// This is the color of the object\n\t// we will return at the end of this function\n\tvec3 objectColor = vec3(0.0);\n\n\t// This is the color of the light\n\t// we will return at the end of this function\n\tvec3 lightColor = vec3(0.0);\n\n\t// This is the color of the reflection\n\t// we will return at the end of this function\n\tvec3 reflectionColor = vec3(0.0);\n\n\t// This is the color of the refraction\n\t// we will return at the end of this function\n\tvec3 refractionColor = vec3(0.0);\n\n\t// This is the color of the shadow\n\t// we will return at the end of this function\n\tvec3 shadowColor = vec3(0.0);\n\n\t// This is the color of the sky\n\t// we will return at the end of this function\n\tvec3 skyColor = vec3(0.0);\n\n\t// This is the color of the ground\n\t// we will return at the end of this function\n\tvec3 groundColor = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor2 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor3 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor4 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor5 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor6 = vec3(0.0);\n\n", "\n  return pow(x, log(b) / log(0.5));\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(dot(i,i+vec2(1.0)),dot(i+vec2(1.0),i+vec2(1.0)),u.x),mix(dot(i,i+vec2(1.0)),dot(i+vec2(1.0),i+vec2(1.0)),u.y),u.y);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat", "\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat", "\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input r --> is box radius\n// pretty simple, just compare point to radius of box\nfloat", "\n\tp.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t.x;\n\treturn length(p.xz) - t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n// \tt.x = sphere radius\n//  \n// think of the sphere as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat", "\n\tfloat d = d1 - d2;\n\treturn d1 - d*d*d*(d*(-2.0f*d - 6.0f) + 3.0f);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat", "\n\treturn d1 * d2;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat", "\n\tvec3 q = p;\n\tq.x += t * cos( yaw );\n\tq.y += t * sin( yaw );\n\treturn q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec", "\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n\t// ~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\tvec2 uv = vec2(0.0);\n\tfloat min_dist = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tnear = 0.0;\n\tfloat tfar = 1000000.0;\n\tvec3 p = vec3(0.0);\n\tvec3 n = vec3(0.0);\n\tint id = 0;\n\tint hit = 0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint ii = 0;\n\tint jj = 0;\n\tint kk = 0;\n\tint ll = 0;\n\tint mm = 0;\n\tint nn = 0;\n\tint oo = 0;\n\tint pp = 0;\n\tint qq = 0;\n\tint rr = 0;\n\tint ss = 0;\n\tint tt = 0;\n\tint uu = 0;\n\tint vv = 0;\n\tint ww = 0;\n\tint xx = 0;\n\tint yy = 0;\n\tint zz = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint cc = 0;\n\tint dd = 0;\n\tint ee =", "\n\t// find closest surface\n\tfloat t = 1e30;\n\tint id = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfloat tt = surfaces[i].intersect(ro, rd);\n\t\tif (tt > 0 && tt < t)\n\t\t{\n\t\t\tt = tt;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\t// if no surface is hit, return background color\n\tif (id == -1)\n\t\treturn vec3(0.0, 0.0, 0.0);\n\n\t// if surface is hit, return surface color\n\treturn surfaces[id].color;\n}\n\n// ~~~~~~~ main\nint", "\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera", "\n\tif(id == 0) return vec3(1,0,0);\n\tif(id == 1) return vec3(0,1,0);\n\tif(id == 2) return vec3(0,0,1);\n\tif(id == 3) return vec3(1,1,0);\n\tif(id == 4) return vec3(1,0,1);\n\tif(id == 5) return vec3(0,1,1);\n\tif(id == 6) return vec3(1,1,1);\n\tif(id == 7) return vec3(0.5,0.5,0.5);\n\tif(id == 8) return vec3(0.5,0,0);\n\tif(id == 9) return vec3(0,0.5,0);\n\tif(id == 10) return vec3(0,0,0.5);\n\tif(id == 11) return vec3(0.5,0.5,0);\n\tif(id == 12) return vec3(0.5,0,0.5);\n\tif(id == 13) return vec3(0,0.5,0.5);\n\tif(id == 14) return vec3(0.5,0.5,0.5);\n\tif(id == 15) return vec3(0.5,0.5,0.5);\n\tif(id == 16) return vec3(0.5,0.5,0.5);\n\tif(id == 17) return vec3(0.5,0.5,0.5);\n\tif(id == 18) return vec3(0.5,0.5,0.5);\n\tif(id == 19) return vec3(0.5,0.5,0.5);\n\tif(id == 20) return vec3(0.5,0.5,0.5);\n\tif(id == 21) return vec3(0.5,0.5,0.5);\n\tif(id == 22)", "\n    p.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t.x;\n    float d = length(p.xz) - t.x;\n    return min(d, abs(p.y) - t.y);\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n//  t.x = sphere radius\n//  \n// think of the sphere as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\nfloat", "\n\tfloat h = clamp( 0.5f + 0.5f*d2/k, 0.0f, 1.0f);\n\treturn mix( d2, d1, h) - k*h*(1.0f-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n\tvec4 o = vec4(0.0);\n\to.xyz = mix(o1.xyz, o2.xyz, bf);\n\to.w = mix(o1.w, o2.w, bf);\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n  return d1-d2;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec", "\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ and return the color of that object\n\t// ~~~~~~~ and the distance to that object\n\t// ~~~~~~~ and the blended color of that object\n\t// ~~~~~~~ and the normal of that object\n\t// ~~~~~~~ and the texture of that object\n\t// ~~~~~~~ and the material of that object\n\t// ~~~~~~~ and the lighting of that object\n\t// ~~~~~~~ and the reflection of that object\n\t// ~~~~~~~ and the refraction of that object\n\t// ~~~~~~~ and the fresnel of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel color of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel color of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel color of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel color of that object\n\t// ~~~~~~~ and the fresnel power of that", "\n\t// ~~~~~~~ cast/march ray through the word and see what it hits\n\t// input ro --> ray origin point/position\n\t// input rd --> ray direction\n\t// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n\t// output is vec3 where\n\t// .x = distance travelled by ray\n\t// .y = hit object's ID\n\t// .z = itteration ratio\n\tvec4 hit = vec4(0.0,0.0,0.0,0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tnear = 0.0;\n\tfloat tfar = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 =", "\n    float shadow = 1.0;\n    float bias = 0.000001;\n    float step = 0.00001;\n    float maxDist = 1000.0;\n    float dist = 0.0;\n    vec3 dir = normalize(lp - sp);\n    for (float i = 0.0; i < maxDist; i += step)\n    {\n        dist += step;\n        vec3 p = sp + dir * dist;\n        if (any(greaterThan(p, vec3(0.0))))\n        {\n            if (any(greaterThan(p, vec3(1.0))))\n            {\n                break;\n            }\n            if (texture(tex, p).a < 0.5)\n            {\n                break;\n            }\n        }\n        shadow = min(shadow, 0.5 + 0.5 * dist / maxDist);\n    }\n    return shadow;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat", "\n\tfloat t = 0.0;\n\tfloat step = 0.01;\n\tfloat maxDist = 10.0;\n\tfloat dist = 0.0;\n\tvec3 dir = nor;\n\tvec3 pos = sp;\n\twhile (dist < maxDist)\n\t{\n\t\tdist += step;\n\t\tpos += dir * step;\n\t\tt += step;\n\t\tif (dist > maxDist)\n\t\t\tbreak;\n\t\tif (dist > 0.0)\n\t\t{\n\t\t\tfloat d = distanceField(pos);\n\t\t\tif (d < 0.001)\n\t\t\t{\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0.0;\n}\n\n// ~~~~~~~ distanceField\n// distance field function\nfloat", "\n\tvec3 n = oN;\n\tvec3 n1 = oN;\n\tvec3 n2 = oN;\n\tvec3 n3 = oN;\n\tvec3 n4 = oN;\n\tvec3 n5 = oN;\n\tvec3 n6 = oN;\n\tvec3 n7 = oN;\n\tvec3 n8 = oN;\n\tvec3 n9 = oN;\n\tvec3 n10 = oN;\n\tvec3 n11 = oN;\n\tvec3 n12 = oN;\n\tvec3 n13 = oN;\n\tvec3 n14 = oN;\n\tvec3 n15 = oN;\n\tvec3 n16 = oN;\n\tvec3 n17 = oN;\n\tvec3 n18 = oN;\n\tvec3 n19 = oN;\n\tvec3 n20 = oN;\n\tvec3 n21 = oN;\n\tvec3 n22 = oN;\n\tvec3 n23 = oN;\n\tvec3 n24 = oN;\n\tvec3 n25 = oN;\n\tvec3 n26 = oN;\n\tvec3 n27 = oN;\n\tvec3 n28 = oN;\n\tvec3 n29 = oN;\n\tvec3 n30 = oN;\n\tvec3 n31 = oN;\n\tvec3 n32 = oN;\n\tvec3 n33 = oN;\n\tvec3 n34 = oN;\n\tvec3 n35 = oN;\n\tvec3 n36 = oN;\n\tvec3 n37 = oN;\n\tvec3 n38 = oN;\n\tvec3 n39 = oN;\n\tvec3 n40 = oN;\n\tvec3 n41 = oN;\n\tvec3 n42 = oN;\n\tvec3 n43 = oN;\n\tvec3 n44 = oN;\n\tvec3 n45 = oN;\n\tvec3 n46 = oN;\n\tvec3 n4", "\n\treturn vec3(\n\t\tpow(c.r, 1.0/2.2),\n\t\tpow(c.g, 1.0/2.2),\n\t\tpow(c.b, 1.0/2.2)\n\t);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec", "\n\tfloat f = 1.0 - exp(-fs.x*d);\n\treturn mix(fc1,fc2,f);\n}\n\n// ~~~~~~~ do lighting\n// from iq's pageon lighting:\n// http://www.iquilezles.org/www/articles/lighting/lighting.htm\n// input c --> original color\n// input n --> normal\n// input l --> light direction\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// output --> color with lighting applied\nvec", "\n\treturn 1.0f / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat", "\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayDir = normalize(vec3(cMatrix * vec4(ndc, 1.0, 0.0)));\n\treturn rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 fPos = vec3(fCoord,0.0);\n    vec3 fDir = normalize(fPos-cPos);\n    vec3 fNorm = normalize(vec3(cMat*vec3(fDir.xy,0.0)));\n    vec3 fCol = vec3(0.0);\n    float fDist = 0.0;\n    float fMarch = 0.0;\n    float fItter = 0.0;\n    float fMaxItter = 100.0;\n    float fMaxMarch = 100.0;\n    float fMaxDist = 100.0;\n    float fMinDist = 0.001;\n    float fStep = 0.001;\n    float fStepItter = 0.001;\n    float fStepMarch = 0.001;\n    float fStepDist = 0.001;\n    float fStepAA = 0.001;\n    float fAA = 0.0;\n    float fAAItter = 0.0;\n    float fAAMarch = 0.0;\n    float fAADist = 0.0;\n    float fAAStep = 0.0;\n    float fAAStepItter = 0.0;\n    float fAAStepMarch = 0.0;\n    float fAAStepDist = 0.0;\n    float fAAStepAA = 0.0;\n    float fAAStepAAItter = 0.0;\n    float fAAStepAAMarch = 0.0;\n    float fAAStepAADist = 0.0;\n    float fAAStepAAStep = 0.0;\n    float fAAStepAAStepItter = 0.0;\n    float fAAStepAAStepMarch = 0.0;\n    float fAAStepAAStepDist = 0.0;\n    float fAAStepAAStepAA = 0.0;\n    float fAAStepAAStepAAItter = 0.0;\n    float fAAStepAAStepAAMarch = 0.0;\n    float fAAStepAAStepAADist = 0.0;\n    float fAAStepAAStepAAStep = 0.0;\n    float fAAStepAAStep", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 z = vec2( 0.0 );\n\tvec2 c = vec2( uv.x * 2.0, uv.y * 2.0 );\n\tfloat i = 0.0;\n\n\tfor( i = 0.0; i < 100.0; i++ )\n\t{\n\t\tz = vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n\t\tif( length( z ) > 10.0 )\n\t\t\tbreak;\n\t}\n\n\tfloat t = i / 100.0;\n\tt = 1.0 - t;\n\tt = t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n\tfragColor = vec4( vec3( t ), 1.0 );\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 z = vec2( 0.0 );\n\tvec2 c = vec2( uv.x * 2.0, uv.y * 2.0 );\n\tfloat i = 0.0;\n\n\tfor( i = 0.0; i < 100.0; i++ )\n\t{\n\t\tz = vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n\t\tif( length( z ) > 10.0 )\n\t\t\tbreak;\n\t}\n\n\tfloat t = i / 100.0;\n\tt = 1.0 - t;\n\tt = t * t * t * ( t * ( t * 6.0 - 15.0 )", "\n\tvec3 d = abs(p) - radius;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat", "\n\tfloat d = length(p) - r;\n\treturn d;\n}\n\n// simple sphere distance field\nfloat", "\n\t// The distance to the nearest surface\n\tfloat d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec2 temp = c;\n\tc.x = c.x * c.x * c.x * c.x * c.x;\n\tc.y = c.y * c.y * c.y * c.y * c.y;\n\tc.x = c.x - c.y;\n\tc.y = 2.0 * temp.x * c.y + temp.y * temp.y * temp.y * temp.y * temp.y;\n\treturn c;\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 tempCoord = coord;\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\ttempCoord = biomorph(tempCoord, morphConstant);\n\t}\n\tcolor = vec4(tempCoord, 0.0, 1.0);\n\treturn color;\n}\n\n//Returns the color of a biomorph at position coord\nvec", "\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 offset = vec2(i, j) / 4.0;\n\t\t\tcolor += texture(iChannel0, uv + offset * constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec", "\n\treturn x - floor(x);\n}\n\n// Basically a triangle wave\nfloat", "\n\t// This is the distance from the line to the point\n\tfloat dist = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist2 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist3 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist4 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist5 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist6 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist7 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist8 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist9 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist10 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist11 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist12 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist13 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist14 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist15 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist16 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist17 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist18 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist19 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist20 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist21 = 0", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tvec2 n = normalize(d);\n\tvec2 t = vec2(n.y, -n.x);\n\tvec2 p = pA + t * thick.x * 0.5;\n\tfloat tlen = length(pB - pA);\n\tfloat tlen2 = tlen - thick.x;\n\tfloat tlen3 = tlen + thick.x;\n\tfloat tlen4 = tlen2 + thick.x;\n\tfloat tlen5 = tlen3 + thick.x;\n\tfloat tlen6 = tlen4 + thick.x;\n\tfloat tlen7 = tlen5 + thick.x;\n\tfloat tlen8 = tlen6 + thick.x;\n\tfloat tlen9 = tlen7 + thick.x;\n\tfloat tlen10 = tlen8 + thick.x;\n\tfloat tlen11 = tlen9 + thick.x;\n\tfloat tlen12 = tlen10 + thick.x;\n\tfloat tlen13 = tlen11 + thick.x;\n\tfloat tlen14 = tlen12 + thick.x;\n\tfloat tlen15 = tlen13 + thick.x;\n\tfloat tlen16 = tlen14 + thick.x;\n\tfloat tlen17 = tlen15 + thick.x;\n\tfloat tlen18 = tlen16 + thick.x;\n\tfloat tlen19 = tlen17 + thick.x;\n\tfloat tlen20 = tlen18 + thick.x;\n\tfloat tlen21 = tlen19 + thick.x;\n\tfloat tlen22 = tlen20 + thick.x;\n\tfloat tlen23 = tlen21 + thick.x;\n\tfloat tlen24 = tlen22 + thick.x;\n\tfloat tlen25 = tlen23 + thick.x;\n\tfloat tlen26 = tlen24 + thick.", "\n\tfloat dist = distance(pA, pB);\n\tfloat outline = outlineThick * dist;\n\tfloat outlineDist = outline / 2.0;\n\tfloat outlineDistRounded = outlineDist * rounded;\n\tfloat outlineDistRounded2 = outlineDistRounded * rounded;\n\tfloat outlineDistRounded3 = outlineDistRounded2 * rounded;\n\tfloat outlineDistRounded4 = outlineDistRounded3 * rounded;\n\tfloat outlineDistRounded5 = outlineDistRounded4 * rounded;\n\tfloat outlineDistRounded6 = outlineDistRounded5 * rounded;\n\tfloat outlineDistRounded7 = outlineDistRounded6 * rounded;\n\tfloat outlineDistRounded8 = outlineDistRounded7 * rounded;\n\tfloat outlineDistRounded9 = outlineDistRounded8 * rounded;\n\tfloat outlineDistRounded10 = outlineDistRounded9 * rounded;\n\tfloat outlineDistRounded11 = outlineDistRounded10 * rounded;\n\tfloat outlineDistRounded12 = outlineDistRounded11 * rounded;\n\tfloat outlineDistRounded13 = outlineDistRounded12 * rounded;\n\tfloat outlineDistRounded14 = outlineDistRounded13 * rounded;\n\tfloat outlineDistRounded15 = outlineDistRounded14 * rounded;\n\tfloat outlineDistRounded16 = outlineDistRounded15 * rounded;\n\tfloat outlineDistRounded17 = outlineDistRounded16 * rounded;\n\tfloat outlineDistRounded18 = outlineDistRounded17 * rounded;\n\tfloat outlineDistRounded19 = outlineDistRounded18 * rounded;\n\tfloat outlineDistRounded20 = outlineDistRounded19 * rounded;\n\tfloat outlineDistRounded21 = outlineDistRounded20 * rounded;\n\tfloat outlineDistRounded22 = outlineDistRounded21 * rounded;\n\tfloat outlineDistRounded23 = outlineDistRounded22 * rounded;\n\tfloat outlineDistRounded24 = outlineDistRounded23 * rounded;\n\tfloat outlineDistRounded25 = outlineDistRounded24 * rounded;\n\tfloat outlineDistRounded26 = outlineDistRounded25 * rounded;\n\tfloat outlineDistRounded27 = outlineDistRounded26 * rounded;\n\tfloat outlineDistRounded28 = outlineDistRounded27 * rounded;\n\tfloat outlineDistRounded29 = outlineDistRounded28 * rounded;\n\tfloat outlineDist", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\td /= len;\n\tvec2 n = vec2(-d.y, d.x);\n\tvec2 p = pA + d * 0.5;\n\tvec2 t = p + n * thick.x * 0.5;\n\tvec2 b = p - n * thick.x * 0.5;\n\tfloat tlen = length(t - b);\n\tfloat tlen2 = tlen * tlen;\n\tfloat tlen4 = tlen2 * tlen2;\n\tfloat tlen6 = tlen4 * tlen2;\n\tfloat tlen8 = tlen4 * tlen4;\n\tfloat tlen10 = tlen8 * tlen2;\n\tfloat tlen12 = tlen8 * tlen4;\n\tfloat tlen14 = tlen12 * tlen2;\n\tfloat tlen16 = tlen12 * tlen4;\n\tfloat tlen18 = tlen16 * tlen2;\n\tfloat tlen20 = tlen16 * tlen4;\n\tfloat tlen22 = tlen20 * tlen2;\n\tfloat tlen24 = tlen20 * tlen4;\n\tfloat tlen26 = tlen24 * tlen2;\n\tfloat tlen28 = tlen24 * tlen4;\n\tfloat tlen30 = tlen28 * tlen2;\n\tfloat tlen32 = tlen28 * tlen4;\n\tfloat tlen34 = tlen32 * tlen2;\n\tfloat tlen36 = tlen32 * tlen4;\n\tfloat tlen38 = tlen36 * tlen2;\n\tfloat tlen40 = tlen36 * tlen4;\n\tfloat tlen42 = tlen40 * tlen2;\n\tfloat tlen44 = tlen40 * tlen4;\n\tfloat tlen46 = tlen44 * tlen2;\n\tfloat tlen48 = tlen44 * tlen4;\n\tfloat t", "\n\tfloat dist = length(pB - pA);\n\tfloat dash = thick.x;\n\tfloat gap = thick.y;\n\tfloat dashCount = floor(dist / dash);\n\tfloat gapCount = dashCount;\n\tfloat dashOffset = mod(uv.x * dist, dash);\n\tfloat gapOffset = mod(uv.x * dist, gap);\n\tfloat dashPhase = step(dashOffset, dash) - step(dashOffset - dash, dash);\n\tfloat gapPhase = step(gapOffset, gap) - step(gapOffset - gap, gap);\n\tfloat dashPhaseRounded = step(dashOffset, dash) - step(dashOffset - rounded, dash);\n\tfloat gapPhaseRounded = step(gapOffset, gap) - step(gapOffset - rounded, gap);\n\tfloat dashPhaseRounded2 = step(dashOffset, dash) - step(dashOffset - rounded * 2.0, dash);\n\tfloat gapPhaseRounded2 = step(gapOffset, gap) - step(gapOffset - rounded * 2.0, gap);\n\tfloat dashPhaseRounded3 = step(dashOffset, dash) - step(dashOffset - rounded * 3.0, dash);\n\tfloat gapPhaseRounded3 = step(gapOffset, gap) - step(gapOffset - rounded * 3.0, gap);\n\tfloat dashPhaseRounded4 = step(dashOffset, dash) - step(dashOffset - rounded * 4.0, dash);\n\tfloat gapPhaseRounded4 = step(gapOffset, gap) - step(gapOffset - rounded * 4.0, gap);\n\tfloat dashPhaseRounded5 = step(dashOffset, dash) - step(dashOffset - rounded * 5.0, dash);\n\tfloat gapPhaseRounded5 = step(gapOffset, gap) - step(gapOffset - rounded * 5.0, gap);\n\tfloat dashPhaseRounded6 = step(dashOffset, dash) - step(dashOffset - rounded * 6.0, dash);\n\tfloat gapPhaseRounded6 = step(gapOffset, gap) - step(gapOffset - rounded * 6.0, gap);\n\tfloat dashPhaseRounded7 = step(dashOffset, dash) - step(dashOffset - rounded * 7.0, dash);\n\t", "\n\tfloat dist = distance(pA, pB);\n\tfloat outline = outlineThick * dist;\n\tfloat outlineUV = outline / thick.x;\n\tfloat outlineUV2 = outlineUV * 2.0;\n\tfloat outlineUV3 = outlineUV * 3.0;\n\tfloat outlineUV4 = outlineUV * 4.0;\n\tfloat outlineUV5 = outlineUV * 5.0;\n\tfloat outlineUV6 = outlineUV * 6.0;\n\tfloat outlineUV7 = outlineUV * 7.0;\n\tfloat outlineUV8 = outlineUV * 8.0;\n\tfloat outlineUV9 = outlineUV * 9.0;\n\tfloat outlineUV10 = outlineUV * 10.0;\n\tfloat outlineUV11 = outlineUV * 11.0;\n\tfloat outlineUV12 = outlineUV * 12.0;\n\tfloat outlineUV13 = outlineUV * 13.0;\n\tfloat outlineUV14 = outlineUV * 14.0;\n\tfloat outlineUV15 = outlineUV * 15.0;\n\tfloat outlineUV16 = outlineUV * 16.0;\n\tfloat outlineUV17 = outlineUV * 17.0;\n\tfloat outlineUV18 = outlineUV * 18.0;\n\tfloat outlineUV19 = outlineUV * 19.0;\n\tfloat outlineUV20 = outlineUV * 20.0;\n\tfloat outlineUV21 = outlineUV * 21.0;\n\tfloat outlineUV22 = outlineUV * 22.0;\n\tfloat outlineUV23 = outlineUV * 23.0;\n\tfloat outlineUV24 = outlineUV * 24.0;\n\tfloat outlineUV25 = outlineUV * 25.0;\n\tfloat outlineUV26 = outlineUV * 26.0;\n\tfloat outlineUV27 = outlineUV * 27.0;\n\tfloat outlineUV28 = outlineUV * 28.0;\n\tfloat outlineUV29 = outlineUV * 29.0;\n\tfloat outlineUV30 = outlineUV * 30.", "\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}\n\n// This is the main fragment shader.\nvoid main() {\n\t// Get the UV coordinates of the fragment.\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\t// Get the color of the fragment.\n\tvec3 col = vec3(0.0);\n\n\t// Draw the point.\n\tDrawPoint(uv, uv, col);\n\n\t// Output the color.\n\tgl_FragColor = vec4(col, 1.0);\n}\n```\n\n## 3.2.2. \u7ed8\u5236\u4e00\u4e2a\u70b9\n\n\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 `DrawPoint` \u51fd\u6570\u6765\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n```glsl\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}\n```\n\n\u8fd9\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u662f\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u5b83\u63a5\u6536\u4e09\u4e2a\u53c2\u6570\uff1a\n\n- `uv`\uff1a\u7247\u6bb5\u7684 UV \u5750\u6807\u3002\n- `p`\uff1a\u7247\u6bb5\u7684\u4f4d\u7f6e\u3002\n- `col`\uff1a\u7247\u6bb5\u7684\u989c\u8272\u3002\n\n\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u5b83\u5c06 `col` \u8bbe\u7f6e\u4e3a\u7ea2\u8272\uff0c\u7136\u540e\u5c06 `gl_Position` \u8bbe\u7f6e\u4e3a `p`\u3002\n\n## 3.2.3. \u7ed8\u5236\u4e00\u4e2a\u70b9\u7684\u7247\u6bb5\u7740\u8272\u5668\n\n\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 `DrawPoint` \u51fd\u6570\u6765\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n```glsl\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}", "\n    float t = -dot( ro-cen, nor ) / dot( rd, nor );\n    vec3 p = ro + t*rd;\n    if( t < 0.0 ) return -1.0;\n    if( length( p-cen ) > rad ) return -1.0;\n    return t;\n}\n\n// ray-sphere intersection\nfloat", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (cen - ro) * invdir;\n\tvec3 tmax = (cen + rad - ro) * invdir;\n\tif (tmin.x > tmax.x) swap(tmin.x, tmax.x);\n\tif (tmin.y > tmax.y) swap(tmin.y, tmax.y);\n\tif (tmin.z > tmax.z) swap(tmin.z, tmax.z);\n\tfloat t0 = max(tmin.x, max(tmin.y, tmin.z));\n\tfloat t1 = min(tmax.x, min(tmax.y, tmax.z));\n\tif (t0 <= t1) return vec2(t0,t1); else return vec2(0.0);\n}\n\n// ray-sphere intersection\nvec", "\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tvec3 c = pa + d * 0.5;\n\tvec3 n = normalize(d);\n\tfloat r = ra;\n\tfloat r2 = r * r;\n\tfloat h2 = h * h;\n\tfloat d2 = dot(d,d);\n\tfloat q = 0.25f / r2;\n\tfloat s = 0.5f * sqrt(max(0.0, 1.0 + q * (d2 - h2)));\n\tvec3 e = vec3(s * r, s * r, h * 0.5);\n\tvec3 b = c + n * e.z;\n\tvec3 a = b - n * e.y;\n\tvec3 x = c - n * e.z;\n\tvec3 y = x + n * e.y;\n\treturn bound3(a - e.x, b + e.x);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tvec3 c = pa + d * 0.5;\n\tvec3 n = normalize(d);\n\tfloat r = ra;\n\tfloat r2 = r * r;\n\tfloat h2 = h * h;\n\tfloat d2 = dot(d,d);\n\tfloat q = 0.25f / r2;\n\tfloat s = 0.5f * sqrt(max(0.0, 1.0 + q * (d2 - h2)));\n\tvec3 e = vec3(s * r, s * r, h * 0.5);\n\tvec3 b = c + n * e.z;\n\tvec3 a = b - n * e.y;\n\tvec3 x = c - n * e.z;\n\tvec3 y = x + n * e.y;\n\treturn bound3(a - e", "\n    vec3 v = pa - ro;\n    float b = dot(v, rd);\n    float c = dot(v, v) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 n = normalize(pa + t*rd - ro);\n    return vec4(t, n.x, n.y, n.z);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen + rad - ro) / rd;\n\n\tif (tmin.x > tmax.x) swap(tmin.x, tmax.x);\n\tif (tmin.y > tmax.y) swap(tmin.y, tmax.y);\n\tif (tmin.z > tmax.z) swap(tmin.z, tmax.z);\n\n\tfloat t0 = max(max(tmin.x, tmin.y), tmin.z);\n\tfloat t1 = min(min(tmax.x, tmax.y), tmax.z);\n\n\treturn vec2(t0, t1);\n}\n\n// ray-sphere intersection\nvec", "\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat c = length( p - ( d * h ) );\n\tfloat l = length( d );\n\tfloat r2 = r * r;\n\tfloat D = h * h - c * c + r2;\n\tif ( D < 0.0 ) return -1.0;\n\tD = sqrt( D );\n\tfloat s0 = -h - D;\n\tfloat s1 = -h + D;\n\tif ( s1 < 0.0 ) return s0;\n\tif ( s0 < 0.0 ) return s1;\n\treturn min( s0, s1 ) / l;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n = normalize( cross( ab, ac ) );\n\tif ( dot( n, ab ) < 0.0 ) n = -n;\n\treturn n;\n}\n\n// compute tangent\nvec", "\n\tvec3 invDir = 1.0 / rd;\n\tvec3 tmin = ( -rad - ro ) * invDir;\n\tvec3 tmax = (  rad - ro ) * invDir;\n\tif ( tmin.x > tmax.x ) swap( tmin.x, tmax.x );\n\tif ( tmin.y > tmax.y ) swap( tmin.y, tmax.y );\n\tif ( tmin.z > tmax.z ) swap( tmin.z, tmax.z );\n\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\treturn vec2( t0, t1 );\n}\n\n// ray-box intersection\nbool rayBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec2 t ) \n{\n\tvec2 t0 = iBox( ro, rd, rad );\n\treturn ( t0.x < t.y ) && ( t0.y > t.x );\n}\n\n// ray-sphere intersection\nbool raySphere( in vec3 ro, in vec3 rd, in vec3 rs, float r, in vec2 t ) \n{\n\tvec3 l = ro - rs;\n\tfloat tca = dot( l, rd );\n\tif ( tca < 0.0 ) return false;\n\tfloat d2 = dot( l, l ) - tca * tca;\n\tif ( d2 > r * r ) return false;\n\tfloat thc = sqrt( r * r - d2 );\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\treturn ( t0 < t.y ) && ( t1 > t.x );\n}\n\n// ray-triangle intersection\nbool rayTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec2 t ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 10000.0;\n\tvec3 p = vec3(0.0);\n\tvec3 n = vec3(0.0);\n\tvec3 c = vec3(0.0);\n\tvec3 l = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tvec3 h = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\tvec3 w = vec3(0.0);\n\tvec3 u = vec3(0.0);\n\tvec3 q = vec3(0.0);\n\tvec3 s = vec3(0.0);\n\tvec3 r = vec3(0.0);\n\tvec3 f = vec3(0.0);\n\tvec3 g = vec3(0.0);\n\tvec3 b = vec3(0.0);\n\tvec3 i = vec3(0.0);\n\tvec3 j = vec3(0.0);\n\tvec3 k = vec3(0.0);\n\tvec3 m = vec3(0.0);\n\tvec3 o = vec3(0.0);\n\tvec3 x = vec3(0.0);\n\tvec3 y = vec3(0.0);\n\tvec3 z = vec3(0.0);\n\tvec3 a = vec3(0.0);\n\tvec3 p1 = vec3(0.0);\n\tvec3 p2 = vec3(0.0);\n\tvec3 p3 = vec3(0.0);\n\tvec3 p4 = vec3(0.0);\n\tvec3 p5 = vec3(0.0);\n\tvec3 p6 = vec3(0.0);\n\tvec3 p7 = vec3(0.0);\n\tvec3 p8 = vec3(0.0);\n\tvec3 p9 = vec3(0.0);\n\tvec3 p10 = vec3(0.0);\n\tvec3 p11 = vec3(0.", "\n\tfloat phi = 2.0 * M_PI * i / n;\n\tfloat theta = M_PI * (3.0 - sqrt(5.0)) * i / n;\n\tfloat x = sin(theta) * cos(phi);\n\tfloat y = cos(theta);\n\tfloat z = sin(theta) * sin(phi);\n\treturn vec3(x, y, z);\n}\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec", "\n\tvec3 p = ro;\n\tvec3 d = rd;\n\tvec3 n = vec3(0.0);\n\tvec3 c = vec3(0.0);\n\tvec3 f = vec3(0.0);\n\tvec3 t = vec3(0.0);\n\tvec3 s = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\tvec3 u = vec3(0.0);\n\tvec3 w = vec3(0.0);\n\tvec3 q = vec3(0.0);\n\tvec3 r = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tvec3 g = vec3(0.0);\n\tvec3 h = vec3(0.0);\n\tvec3 i = vec3(0.0);\n\tvec3 j = vec3(0.0);\n\tvec3 k = vec3(0.0);\n\tvec3 l = vec3(0.0);\n\tvec3 m = vec3(0.0);\n\tvec3 o = vec3(0.0);\n\tvec3 p = vec3(0.0);\n\tvec3 q = vec3(0.0);\n\tvec3 r = vec3(0.0);\n\tvec3 s = vec3(0.0);\n\tvec3 t = vec3(0.0);\n\tvec3 u = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\tvec3 w = vec3(0.0);\n\tvec3 x = vec3(0.0);\n\tvec3 y = vec3(0.0);\n\tvec3 z = vec3(0.0);\n\tvec3 aa = vec3(0.0);\n\tvec3 ab = vec3(0.0);\n\tvec3 ac = vec3(0.0);\n\tvec3 ad = vec3(0.0);\n\tvec3 ae = vec3(0.0);\n\tvec3 af = vec3(0.0);\n\tvec3 ag = vec3(0.0);\n\tvec3 ah = vec3(0.0);\n\t", "\n\tvec3  grad = vec3( 0.0 );\n\tvec2  r = mod( p, 2.0 );\n\tp = ( p - r ) / 2.0;\n\tvec2  i = floor( p );\n\tvec2  f = fract( p );\n\tvec2  u = f * f * ( 3.0 - 2.0 * f );\n\tvec2  a = i;\n\tvec2  b = i + 1.0;\n\tvec2  c = a + 1.0;\n\tvec2  d = b + 1.0;\n\tvec2  e = a + 2.0;\n\tvec2  f = b + 2.0;\n\tvec2  g = c + 2.0;\n\tvec2  h = d + 2.0;\n\tvec2  i = e + 2.0;\n\tvec2  j = f + 2.0;\n\tvec2  k = g + 2.0;\n\tvec2  l = h + 2.0;\n\tvec2  m = i + 2.0;\n\tvec2  n = j + 2.0;\n\tvec2  o = k + 2.0;\n\tvec2  p = l + 2.0;\n\tvec2  q = m + 2.0;\n\tvec2  r = n + 2.0;\n\tvec2  s = o + 2.0;\n\tvec2  t = p + 2.0;\n\tvec2  u = q + 2.0;\n\tvec2  v = r + 2.0;\n\tvec2  w = s + 2.0;\n\tvec2  x = t + 2.0;\n\tvec2  y = u + 2.0;\n\tvec2  z = v + 2.0;\n\tvec2  A = w + 2.0;\n\tvec2  B = x + 2.0;\n\tvec2  C = y + 2.0;\n\tvec2  D = z + 2.0;\n\tvec2", "\n\tvec2 d = abs(p) - size;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat", "\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 2\nvec", "\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat aa = 1.0;\n\tfloat ab = 1.0;\n\tfloat ac = 1.0;\n\tfloat ad = 1.0;\n\tfloat ae = 1.0;\n\tfloat af = 1.0;\n\tfloat ag = 1.0;\n\tfloat ah = 1.0;\n\tfloat ai = 1.0;\n\tfloat aj = 1.0;\n\tfloat ak = 1.0;\n\tfloat al = 1.0;\n\tfloat am = 1.0;\n\tfloat an = 1.0;\n\tfloat ao = 1.0;\n\tfloat ap = 1.0;\n\tfloat aq = 1.0;\n\tfloat ar = 1.0;\n\tfloat as = 1.0;\n\tfloat at = 1.0;\n\tfloat au = 1.0;\n\tfloat av = 1.0;\n\tfloat aw = 1.0;\n\tfloat ax = 1.0;\n\tfloat ay = 1.0;\n", "\n\tvec2 g = 2.0 * ddx * ddy;\n\tvec2 h = 2.0 * ddx * ddy;\n\tvec2 f = 2.0 * ddx * ddy;\n\tvec2 e = 2.0 * ddx * ddy;\n\tvec2 c = 2.0 * ddx * ddy;\n\tvec2 b = 2.0 * ddx * ddy;\n\tvec2 a = 2.0 * ddx * ddy;\n\tvec2 i = 2.0 * ddx * ddy;\n\tvec2 j = 2.0 * ddx * ddy;\n\tvec2 k = 2.0 * ddx * ddy;\n\tvec2 l = 2.0 * ddx * ddy;\n\tvec2 m = 2.0 * ddx * ddy;\n\tvec2 n = 2.0 * ddx * ddy;\n\tvec2 o = 2.0 * ddx * ddy;\n\tvec2 p = 2.0 * ddx * ddy;\n\tvec2 q = 2.0 * ddx * ddy;\n\tvec2 r = 2.0 * ddx * ddy;\n\tvec2 s = 2.0 * ddx * ddy;\n\tvec2 t = 2.0 * ddx * ddy;\n\tvec2 u = 2.0 * ddx * ddy;\n\tvec2 v = 2.0 * ddx * ddy;\n\tvec2 w = 2.0 * ddx * ddy;\n\tvec2 x = 2.0 * ddx * ddy;\n\tvec2 y = 2.0 * ddx * ddy;\n\tvec2 z = 2.0 * ddx * ddy;\n\tvec2 A = 2.0 * ddx * ddy;\n\tvec2 B = 2.0 * ddx * ddy;\n\tvec2 C = 2.0 * ddx * ddy;\n\tvec2 D = 2.0 * ddx * ddy;\n\tvec2 E = 2.0 * ddx * ddy;\n\t", "\n\tvec3 u = dFdx( p );\n\tvec3 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec", "\n\tv33 c;\n\tc.x = a.x;\n\tc.y = a.y;\n\tc.z = a.z;\n\ta.x = c.x;\n\ta.y = c.y;\n\ta.z = c.z;\n\tb.x = c.x;\n\tb.y = c.y;\n\tb.z = c.z;\n}\n\n//this is the function that actually does the ray-tracing\n//it takes a ray, a starting point, and a direction\n//it returns the distance to the closest object, and the color of the object\n//it also returns the normal of the object\n//it also returns the material of the object\n//it also returns the texture of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates of the object\n//it also returns the texture coordinates", "return v33(a.x-b.x,a.y-b.y,a.z-b.z);}\nv33 add(v33 a,vec3 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 mul(v33 a,vec3 b){return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 div(v33 a,vec3 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 sub(v33 a,v33 b){return v33(a.x-b.x,a.y-b.y,a.z-b.z);}\nv33 add(v33 a,v33 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 mul(v33 a,v33 b){return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 div(v33 a,v33 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 sub(v33 a,float b){return v33(a.x-b,a.y-b,a.z-b);}\nv33 add(v33 a,float b){return v33(a.x+b,a.y+b,a.z+b);}\nv33 mul(v33 a,float b){return v33(a.x*b,a.y*b,a.z*b);}\nv33 div(v33 a,float b){return v33(a.x/b,a.y/b,a.z/b);}\nv33 sub(float a,v33 b){return v33(a-b.", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction", "\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BB\nvec", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(vec2 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual div\nv33 div(v33 a,vec2 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 div(vec2 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 div(v33 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//dual dot\nfloat", "\n\tfloat d=abs(dot(w,p));\n\tfloat s=0.5;\n\tfloat t=0.5;\n\tfloat u=0.5;\n\tfloat v=0.5;\n\tfloat x=fract(d*s);\n\tfloat y=fract(d*t);\n\tfloat z=fract(d*u);\n\tfloat w=fract(d*v);\n\tfloat c=step(x,0.5)-step(x-1.0,0.5);\n\tfloat d=step(y,0.5)-step(y-1.0,0.5);\n\tfloat e=step(z,0.5)-step(z-1.0,0.5);\n\tfloat f=step(w,0.5)-step(w-1.0,0.5);\n\treturn c*d*e*f;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat", "\n\tfloat d=dot(p,w);\n\tfloat s=sign(d);\n\tfloat a=abs(d);\n\tfloat b=a-s;\n\tfloat c=a+s;\n\tfloat Fb=b*b*b;\n\tfloat Fa=a*a*a;\n\tfloat Fc=c*c*c;\n\tfloat F=Fa*Fb*Fc;\n\treturn F;\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat", "\n\tfloat t=0;\n\tfloat d=0;\n\tfloat t1=0;\n\tfloat t2=0;\n\tfloat t3=0;\n\tfloat t4=0;\n\tfloat t5=0;\n\tfloat t6=0;\n\tfloat t7=0;\n\tfloat t8=0;\n\tfloat t9=0;\n\tfloat t10=0;\n\tfloat t11=0;\n\tfloat t12=0;\n\tfloat t13=0;\n\tfloat t14=0;\n\tfloat t15=0;\n\tfloat t16=0;\n\tfloat t17=0;\n\tfloat t18=0;\n\tfloat t19=0;\n\tfloat t20=0;\n\tfloat t21=0;\n\tfloat t22=0;\n\tfloat t23=0;\n\tfloat t24=0;\n\tfloat t25=0;\n\tfloat t26=0;\n\tfloat t27=0;\n\tfloat t28=0;\n\tfloat t29=0;\n\tfloat t30=0;\n\tfloat t31=0;\n\tfloat t32=0;\n\tfloat t33=0;\n\tfloat t34=0;\n\tfloat t35=0;\n\tfloat t36=0;\n\tfloat t37=0;\n\tfloat t38=0;\n\tfloat t39=0;\n\tfloat t40=0;\n\tfloat t41=0;\n\tfloat t42=0;\n\tfloat t43=0;\n\tfloat t44=0;\n\tfloat t45=0;\n\tfloat t46=0;\n\tfloat t47=0;\n\tfloat t48=0;\n\tfloat t49=0;\n\tfloat t50=0;\n\tfloat t51=0;\n\tfloat t52=0;\n\tfloat t53=0;\n\tfloat t54=0;\n\tfloat t55=0;\n\tfloat t56=0;\n\tfloat", "\n\tfloat r = s.w;\n\tfloat d = dot(u,n);\n\tfloat c = length(u-n*d);\n\treturn 1.0-clamp(1.0-r*r/(r*r+c*c-d*d),0.0,1.0);\n}\n\n//plane occlusion\nfloat", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p012, p012);\n}\n\n// Quadratic bezier to cubic bezier\nvec", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p012, p012);\n}\n\n// Approximated BBox to a quadratic bezier\nvec", "\n\tvec3 v0 = p0 - p1;\n\tvec3 v1 = p2 - p1;\n\tvec3 v2 = p3 - p1;\n\tvec3 v3 = cross( v1, v2 );\n\tvec3 v4 = cross( v2, v0 );\n\tvec3 v5 = cross( v0, v1 );\n\tvec3 v6 = cross( v3, v4 );\n\tvec3 v7 = cross( v4, v5 );\n\tvec3 v8 = cross( v5, v6 );\n\tvec3 v9 = cross( v6, v7 );\n\tvec3 v10 = cross( v7, v8 );\n\tvec3 v11 = cross( v8, v9 );\n\tvec3 v12 = cross( v9, v10 );\n\tvec3 v13 = cross( v10, v11 );\n\tvec3 v14 = cross( v11, v12 );\n\tvec3 v15 = cross( v12, v13 );\n\tvec3 v16 = cross( v13, v14 );\n\tvec3 v17 = cross( v14, v15 );\n\tvec3 v18 = cross( v15, v16 );\n\tvec3 v19 = cross( v16, v17 );\n\tvec3 v20 = cross( v17, v18 );\n\tvec3 v21 = cross( v18, v19 );\n\tvec3 v22 = cross( v19, v20 );\n\tvec3 v23 = cross( v20, v21 );\n\tvec3 v24 = cross( v21, v22 );\n\tvec3 v25 = cross( v22, v23 );\n\tvec3 v26 = cross( v23, v24 );\n\tvec3 v27 = cross( v24, v25 );\n\tvec3 v28 = cross( v25, v26 );\n\tvec3 v29 = cross( v26, v27 );\n\tvec3 v30 = cross( v27", "\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\tvec2 p01234 = mix(p0123, p0123, 0.5);\n\treturn vec4(p01234, 0.0, 1.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec", "\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\tvec2 d = p3;\n\tvec2 t = pos;\n\tvec2 ab = mix(a, b, t);\n\tvec2 bc = mix(b, c, t);\n\tvec2 cd = mix(c, d, t);\n\tvec2 abbc = mix(ab, bc, t);\n\tvec2 bccd = mix(bc, cd, t);\n\tvec2 abbcccd = mix(abbc, bccd, t);\n\treturn abbcccd;\n}\n\n// Bezier curve with 4 control points.\nvec", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross( rd, e2 );\n\tfloat a = dot( e1, p );\n\tif ( a > -EPSILON && a < EPSILON )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot( s, p );\n\tif ( u < 0.0 || u > 1.0 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tvec3 q = cross( s, e1 );\n\tfloat v = f * dot( rd, q );\n\tif ( v < 0.0 || u + v > 1.0 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat t = f * dot( e2, q );\n\tif ( t > EPSILON )\n\t\treturn vec3( t, u, v );\n\telse\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n}\n\n// Sphere intersection. Returns { t, u, v }\nvec", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 s = cross( e2, e1 );\n\tvec3 p = cross( pos - v0, e1 );\n\tfloat d = dot( s, e2 );\n\tfloat t = dot( s, p ) / d;\n\tif( t < 0.0 || t > 1.0 ) return 0.0;\n\tvec3 q = cross( p, e2 );\n\tfloat u = dot( q, e1 ) / d;\n\tif( u < 0.0 || u > 1.0 ) return 0.0;\n\tfloat v = 1.0 - t - u;\n\tif( v < 0.0 || v > 1.0 ) return 0.0;\n\treturn 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat", "\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tfloat ab2 = dot( ab, ab );\n\tfloat ac2 = dot( ac, ac );\n\tfloat bc2 = dot( bc, bc );\n\tfloat abc = dot( ab, ac );\n\tfloat bca = dot( bc, ac );\n\tfloat bac = dot( bc, ab );\n\tfloat a2 = dot( p - a, p - a );\n\tfloat b2 = dot( p - b, p - b );\n\tfloat c2 = dot( p - c, p - c );\n\tfloat a3 = a2 * a2;\n\tfloat b3 = b2 * b2;\n\tfloat c3 = c2 * c2;\n\tfloat a2b = a2 * b2;\n\tfloat a2c = a2 * c2;\n\tfloat b2c = b2 * c2;\n\tfloat a2bc = a2b * c2;\n\tfloat a2b2 = a2b * b2;\n\tfloat a2c2 = a2c * c2;\n\tfloat b2c2 = b2c * c2;\n\tfloat a2bc2 = a2bc * c2;\n\tfloat a2b2c = a2b2 * c2;\n\tfloat a2b2c2 = a2b2c * c2;\n\tfloat a2b2c3 = a2b2c2 * c2;\n\tfloat a2b2c2b = a2b2c2 * b2;\n\tfloat a2b2c2c = a2b2c2 * c2;\n\tfloat a2b2c2bc = a2b2c2 * bc2;\n\tfloat a2b2c2b2 = a2b2c2 * b2;\n\tfloat a2b2c2b2c = a2b2c2 * c2;\n\tfloat a2b2c2b2c2 = a2b2", "\n\tfloat h = p.y;\n\tfloat d = length( p.xy );\n\tif( d < r1 ) return h - he;\n\tif( d > r2 ) return h;\n\tfloat a = acos( d / r2 );\n\tfloat x = r1 * sin( a );\n\tfloat y = r1 * cos( a );\n\treturn h - he + ( r2 - d ) * ( y - x ) / ( r2 - r1 );\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat", "\n\tvec2 w = p - a;\n\tvec2 h = b - a;\n\tfloat hw = dot( w, h );\n\tfloat hh = dot( h, h );\n\tfloat aw = dot( w, w );\n\tfloat ah = dot( a, h );\n\tfloat ab = dot( a, b );\n\tfloat bh = dot( b, h );\n\tfloat d = hw * hw * hh - hh * aw * ah + 2.0 * hw * hh * ab - hh * aw * ab - 2.0 * hw * hh * bh + hh * aw * bh;\n\tfloat s = sqrt( d );\n\tfloat r = ( hw * aw - hh * ab ) / s;\n\tfloat t = ( hw * ah - hh * ab ) / s;\n\tfloat u = ( hw * bh - hh * ab ) / s;\n\tfloat v = ( hw * aw - hh * ab ) / s;\n\tfloat r2 = ra * ra;\n\tfloat r3 = rb * rb;\n\tfloat r4 = r2 * r3;\n\tfloat r5 = r2 * r4;\n\tfloat r6 = r3 * r4;\n\tfloat r7 = r3 * r5;\n\tfloat r8 = r4 * r5;\n\tfloat r9 = r4 * r6;\n\tfloat r10 = r5 * r6;\n\tfloat r11 = r6 * r7;\n\tfloat r12 = r7 * r8;\n\tfloat r13 = r8 * r9;\n\tfloat r14 = r9 * r10;\n\tfloat r15 = r10 * r11;\n\tfloat r16 = r11 * r12;\n\tfloat r17 = r12 * r13;\n\tfloat r18 = r13 * r14;\n\tfloat r19 = r14 * r15;\n\tfloat r20 = r15 * r16;\n\tfloat r21 = r16 * r17;\n\tfloat r22 = r17 * r18;\n\tfloat r23 = r18 * r19;\n\tfloat r2", "\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( 0.001, 0.0, 0.0 ) ) - sdf( pos - vec3( 0.001, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.001, 0.0 ) ) - sdf( pos - vec3( 0.0, 0.001, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.0, 0.001 ) ) - sdf( pos - vec3( 0.0, 0.0, 0.001 ) )\n\t);\n\treturn normalize( n );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat t = tmin;\n\tfloat dt = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat f = 0.0;\n\tfloat bias = 0.0;\n\tfloat shadow = 1.0;\n\tfloat bias_shadow = 1.0;\n\tfloat bias_shadow_soft = 1.0;\n\tfloat bias_shadow_soft_max = 1.0;\n\tfloat bias_shadow_soft_min = 1.0;\n\tfloat bias_shadow_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min = 1.0;\n\tfloat bias_shadow_soft_min_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft", "\n    return fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453123);\n}\n\n// 2D simplex noise\nfloat", "\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\n\tvec2 p0 = vec2( p, p + 1 );\n\tvec2 p1 = vec2( p + 1, p );\n\n\tvec4 h = mix( mix( gradient( noise( p0, i ), gradient( noise( p1, i ), f.x ) ),\n\t\t\t\t\t\tgradient( noise( p0, i + vec2( 0.0, 1.0 ) ), gradient( noise( p1, i + vec2( 0.0, 1.0 ) ), f.x ) ),\n\t\t\t\t\t\tmix( gradient( noise( p0, i + vec2( 1.0, 0.0 ) ), gradient( noise( p1, i + vec2( 1.0, 0.0 ) ), f.x ) ),\n\t\t\t\t\t\tgradient( noise( p0, i + vec2( 1.0, 1.0 ) ), gradient( noise( p1, i + vec2( 1.0, 1.0 ) ), f.x ) ) ), u.y );\n\n\treturn mix( h.x, h.z, u.x );\n}\n\nfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2( 100.0 );\n\tfor( int i = 0; i < p; ++i )\n\t{\n\t\tf += a * noise( x );\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// turbulence\nfloat", "\n\tvec3 q = abs(p)-r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,0.0)) + length(max(q.y,0.0)) + length(max(q.z,0.0));\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat", "\n\tvec3 q = abs(p)-r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ellipsoid - more accurate distance\nfloat", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat", "\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\tf = f * f * ( 3.0 - 2.0 * f );\n\tfloat c = ( i.x + i.y ) & 1;\n\treturn mix( c, 1.0 - c, f.x * f.y );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n\treturn x * x * (3.0f - 2.0f * x);\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n\treturn ( x + p ) * 0.5f;\n}\n\n// biased square\nfloat", "\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec", "\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat l = length( p - ( d * clamp( h, 0.0, 1.0 ) ) );\n\tif ( l > r ) return -1.0;\n\tfloat m2 = dot( d, d );\n\tfloat mm = m2 - h * h;\n\tif ( mm == 0.0 ) return -1.0;\n\tfloat b = dot( p, d ) - h;\n\tfloat c = dot( p, p ) - r * r - h * h;\n\tfloat D = b * b - mm * c;\n\tif ( D < 0.0 ) return -1.0;\n\tfloat sD = sqrt( D );\n\tfloat s = ( -b - sD ) / mm;\n\tif ( s < 0.0 || s > 1.0 ) return -1.0;\n\treturn s;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n\tfloat d = length(p - a);\n\tfloat t = clamp(dot(normalize(p - a), normalize(b - a)), 0.0, 1.0);\n\tfloat h = length(p - (a + t * (b - a)));\n\tfloat r = ra * (1.0 - t) + rb * t;\n\treturn max(d - r, h - r);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tvec3 p = a + rd * k;\n\tvec3 q = b + rd * k;\n\tvec3 d = q - p;\n\tfloat t = length( d );\n\td = normalize( d );\n\tfloat h = clamp( dot( d, normalize( p - ro ) ), 0.0, 1.0 );\n\tfloat c = clamp( dot( d, normalize( q - ro ) ), 0.0, 1.0 );\n\tfloat s = clamp( dot( d, normalize( p - q ) ), 0.0, 1.0 );\n\tfloat d1 = length( p - ro );\n\tfloat d2 = length( q - ro );\n\tfloat d3 = length( p - q );\n\tfloat d4 = length( p - q ) - r;\n\tfloat d5 = length( p - q ) + r;\n\tfloat d6 = length( p - q ) - r * 2.0;\n\tfloat d7 = length( p - q ) + r * 2.0;\n\tfloat d8 = length( p - q ) - r * 3.0;\n\tfloat d9 = length( p - q ) + r * 3.0;\n\tfloat d10 = length( p - q ) - r * 4.0;\n\tfloat d11 = length( p - q ) + r * 4.0;\n\tfloat d12 = length( p - q ) - r * 5.0;\n\tfloat d13 = length( p - q ) + r * 5.0;\n\tfloat d14 = length( p - q ) - r * 6.0;\n\tfloat d15 = length( p - q ) + r * 6.0;\n\tfloat d16 = length( p - q ) - r * 7.0;\n\tfloat d17 = length( p - q ) + r * 7.0;\n\tfloat d18 = length( p - q ) - r * 8.0;\n\tfloat d19 = length( p - q ) + r * 8.0;\n\tfloat d20 = length( p - q ) - r * 9.0;", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float t = a / (2.0 * PI);\n    float s = sin(t * 2.0 * PI);\n    float c = cos(t * 2.0 * PI);\n    float r1 = rad1 + s * th;\n    float r2 = rad2 + s * th;\n    float r3 = r1 + (r2 - r1) * smoothstep(0.0, 1.0, r);\n    float r4 = r3 + (r2 - r3) * smoothstep(0.0, 1.0, r);\n    float r5 = r4 + (r2 - r4) * smoothstep(0.0, 1.0, r);\n    float r6 = r5 + (r2 - r5) * smoothstep(0.0, 1.0, r);\n    float r7 = r6 + (r2 - r6) * smoothstep(0.0, 1.0, r);\n    float r8 = r7 + (r2 - r7) * smoothstep(0.0, 1.0, r);\n    float r9 = r8 + (r2 - r8) * smoothstep(0.0, 1.0, r);\n    float r10 = r9 + (r2 - r9) * smoothstep(0.0, 1.0, r);\n    float r11 = r10 + (r2 - r10) * smoothstep(0.0, 1.0, r);\n    float r12 = r11 + (r2 - r11) * smoothstep(0.0, 1.0, r);\n    float r13 = r12 + (r2 - r12) * smoothstep(0.0, 1.0, r);\n    float r14 = r13 + (r2 - r13) * smoothstep(0.0, 1.0, r);\n    float r15 = r14 + (r2 - r14) * smoothstep(0.0, 1.0, r);\n    float r16 = r15 + (r2 - r15", "\n\tvec2 q = p - c;\n\tfloat d = length( q );\n\tif( d > r ) return 1.0;\n\tfloat t = atan( q.y, q.x );\n\tfloat a = t - c.x;\n\tfloat b = c.y - r;\n\tfloat s = sign( a );\n\tfloat h = abs( a ) - b;\n\treturn s * h;\n}\n\n// c is the center of the circle. r is the radius\nfloat", "\n\tvec3 n = vec3( 4.0 * pos.x * pos.x, 4.0 * pos.y * pos.y, 4.0 * pos.z * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2 - ra^2\nvec", "\n\tvec2 q = p - 0.5;\n\tvec2 d = q * sca;\n\tfloat r = length( d );\n\tfloat t = atan( d.y, d.x );\n\tfloat a = t * ra;\n\tfloat b = t * rb;\n\tfloat c = r * scb.x;\n\tfloat s = r * scb.y;\n\treturn c + s * cos( a + b );\n}\n\n// sdArcRound\n//\n// sdArcRound is the signed distance function for an arc with rounded\n// corners.\n//\n// p is the point\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\n// ra is the radius of the arc\n// rb is the radius of the rounded corners\n// r is the radius of the rounded corners\nfloat", "\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat f = 0.0;\n\tfloat bias = 0.0001;\n\tfloat step = 0.001;\n\tfloat maxstep = 0.01;\n\tfloat maxdist = 1000.0;\n\tfloat maxh = 1000.0;\n\tfloat maxs = 1000.0;\n\tfloat maxp = 1000.0;\n\tfloat maxf = 1000.0;\n\tfloat maxbias = 0.001;\n\tfloat maxstep2 = 0.001;\n\tfloat maxdist2 = 1000.0;\n\tfloat maxh2 = 1000.0;\n\tfloat maxs2 = 1000.0;\n\tfloat maxp2 = 1000.0;\n\tfloat maxf2 = 1000.0;\n\tfloat maxbias2 = 0.001;\n\tfloat maxstep3 = 0.001;\n\tfloat maxdist3 = 1000.0;\n\tfloat maxh3 = 1000.0;\n\tfloat maxs3 = 1000.0;\n\tfloat maxp3 = 1000.0;\n\tfloat maxf3 = 1000.0;\n\tfloat maxbias3 = 0.001;\n\tfloat maxstep4 = 0.001;\n\tfloat maxdist4 = 1000.0;\n\tfloat maxh4 = 1000.0;\n\tfloat maxs4 = 1000.0;\n\tfloat maxp4 = 1000.0;\n\tfloat maxf4 = 1000.0;\n\tfloat maxbias4 = 0.001;\n\tfloat maxstep5 = 0.001;\n\tfloat maxdist5 = 1000", "\n\tvec3 n = vec3( 0.0 );\n\tn.x = sdF( pos + vec3( 0.001, 0.0, 0.0 ), time );\n\tn.y = sdF( pos + vec3( 0.0, 0.001, 0.0 ), time );\n\tn.z = sdF( pos + vec3( 0.0, 0.0, 0.001 ), time );\n\treturn normalize( n );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\tfloat t = mint;\n\tfloat dt = 0.001;\n\tfloat t0 = t;\n\tfloat t1 = t + dt;\n\tfloat t2 = t + dt * 2.0;\n\tfloat t3 = t + dt * 3.0;\n\tfloat t4 = t + dt * 4.0;\n\tfloat t5 = t + dt * 5.0;\n\tfloat t6 = t + dt * 6.0;\n\tfloat t7 = t + dt * 7.0;\n\tfloat t8 = t + dt * 8.0;\n\tfloat t9 = t + dt * 9.0;\n\tfloat t10 = t + dt * 10.0;\n\tfloat t11 = t + dt * 11.0;\n\tfloat t12 = t + dt * 12.0;\n\tfloat t13 = t + dt * 13.0;\n\tfloat t14 = t + dt * 14.0;\n\tfloat t15 = t + dt * 15.0;\n\tfloat t16 = t + dt * 16.0;\n\tfloat t17 = t + dt * 17.0;\n\tfloat t18 = t + dt * 18.0;\n\tfloat t19 = t + dt * 19.0;\n\tfloat t20 = t + dt * 20.0;\n\tfloat t21 = t + dt * 21.0;\n\tfloat t22 = t + dt * 22.0;\n\tfloat t23 = t + dt * 23.0;\n\tfloat t24 = t + dt * 24.0;\n\tfloat t25 = t + dt * 25.0;\n\tfloat t26 = t + dt * 26.0;\n\tfloat t27 = t + dt * 27.0;\n\tfloat t28 = t + dt * 28.0;\n\tfloat t29 = t + dt * 29.0;\n\tfloat t30 = t + dt * 30.", "\n\tvec2 dp = dpdx + dpdy;\n\tvec2 dpdz = dpdx - dpdy;\n\tfloat d = dot( dp, dpdz );\n\treturn d;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n\treturn k*x;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n\tvec3 sample_dir = normalize(light_dir - sample_pos);\n\tvec3 sample_col = texture(sky_texture, sample_dir).rgb;\n\treturn mix(background_col, sample_col, 0.5);\n}\n\n/*\nThis is the main function that actually renders the planet.\n\nIt takes in the position of the camera, the position of the light, the radius of the planet,\nthe radius of the atmosphere, the color of the planet, the color of the atmosphere, the\ncolor of the sky, the color of the background, and the number of samples to take.\n\nThe number of samples is the number of rays that are cast from the camera to the atmosphere\nand the surface of the planet.\n\nThe more samples, the more accurate the rendering, but the slower it is.\n*/\nvec", "\n\tvec3 color = vec3(0.0);\n\tfloat distance = 1000000.0;\n\tfloat radius = 1.0;\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\tfloat d = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat t = 0.0;\n\tfloat t_min = 0.0;\n\tfloat t_max = 0.0;\n\tfloat t_hit = 0.0;\n\tfloat t_hit_min = 0.0;\n\tfloat t_hit_max = 0.0;\n\tfloat t_hit_min_x = 0.0;\n\tfloat t_hit_min_y = 0.0;\n\tfloat t_hit_min_z = 0.0;\n\tfloat t_hit_max_x = 0.0;\n\tfloat t_hit_max_y = 0.0;\n\tfloat t_hit_max_z = 0.0;\n\tfloat t_hit_min_x_y = 0.0;\n\tfloat t_hit_min_x_z = 0.0;\n\tfloat t_hit_min_y_z = 0.0;\n\tfloat t_hit_max_x_y = 0.0;\n\tfloat t_hit_max_x_z = 0.0;\n\tfloat t_hit_max_y_z = 0.0;\n\tfloat t_hit_min_x_y_z = 0.0;\n\tfloat t_hit_max_x_y_z = 0.0;\n\tfloat t_hit_min_x_y_z_x = 0.0;\n\tfloat t_hit_min_x_y_z_y = 0.0;\n\tfloat t_hit_min_x_y_z_z = 0.0;\n\tfloat t_hit_max_x_y_z_x = 0", "\n\tvec3 camera_vector;\n\tcamera_vector.x = (2.0 * (coord.x + 0.5) / resolution.x) - 1.0;\n\tcamera_vector.y = 1.0 - (2.0 * (coord.y + 0.5) / resolution.y);\n\tcamera_vector.z = -1.0;\n\treturn camera_vector;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec", "\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (material == 1) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 2) {\n        color = vec3(0.5, 0.5, 0.0);\n    } else if (material == 3) {\n        color = vec3(0.0, 0.5, 0.5);\n    } else if (material == 4) {\n        color = vec3(0.5, 0.0, 0.5);\n    } else if (material == 5) {\n        color = vec3(0.0, 0.0, 0.5);\n    } else if (material == 6) {\n        color = vec3(0.5, 0.0, 0.0);\n    } else if (material == 7) {\n        color = vec3(0.0, 0.5, 0.0);\n    } else if (material == 8) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 9) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 10) {\n        color = vec3(0.5, 0.5, 0.0);\n    } else if (material == 11) {\n        color = vec3(0.0, 0.5, 0.5);\n    } else if (material == 12) {\n        color = vec3(0.5, 0.0, 0.5);\n    } else if (material == 13) {\n        color = vec3(0.0, 0.0, 0.5);\n    } else if (material == 14) {\n        color = vec3(0.5, 0.0, 0.0);\n    } else if (material == 15) {\n        color = vec3(0.0, 0.5, 0.0);\n    } else if (material == 16) {\n        color = vec3(0.0", "\n\tswitch (material) {\n\t\tcase 0:\n\t\t\treturn 0.0;\n\t\tcase 1:\n\t\t\treturn 0.0;\n\t\tcase 2:\n\t\t\treturn 0.0;\n\t\tcase 3:\n\t\t\treturn 0.0;\n\t\tcase 4:\n\t\t\treturn 0.0;\n\t\tcase 5:\n\t\t\treturn 0.0;\n\t\tcase 6:\n\t\t\treturn 0.0;\n\t\tcase 7:\n\t\t\treturn 0.0;\n\t\tcase 8:\n\t\t\treturn 0.0;\n\t\tcase 9:\n\t\t\treturn 0.0;\n\t\tcase 10:\n\t\t\treturn 0.0;\n\t\tcase 11:\n\t\t\treturn 0.0;\n\t\tcase 12:\n\t\t\treturn 0.0;\n\t\tcase 13:\n\t\t\treturn 0.0;\n\t\tcase 14:\n\t\t\treturn 0.0;\n\t\tcase 15:\n\t\t\treturn 0.0;\n\t\tcase 16:\n\t\t\treturn 0.0;\n\t\tcase 17:\n\t\t\treturn 0.0;\n\t\tcase 18:\n\t\t\treturn 0.0;\n\t\tcase 19:\n\t\t\treturn 0.0;\n\t\tcase 20:\n\t\t\treturn 0.0;\n\t\tcase 21:\n\t\t\treturn 0.0;\n\t\tcase 22:\n\t\t\treturn 0.0;\n\t\tcase 23:\n\t\t\treturn 0.0;\n\t\tcase 24:\n\t\t\treturn 0.0;\n\t\tcase 25:\n\t\t\treturn 0.0;\n\t\tcase 26:\n\t\t\treturn 0.0;\n\t\tcase 27:\n\t\t\treturn 0.0;\n\t\tcase 28:\n\t\t\treturn 0.0;\n\t\tcase 29:\n\t\t\treturn 0.0;\n\t\tcase 30:\n\t\t\treturn 0.0;\n\t\tcase 31:\n\t\t\treturn 0.0;\n\t\tcase 32:\n\t\t\treturn 0.0;\n\t\tcase 33:\n\t\t\treturn 0.0;\n\t\tcase 3", "\n\treturn materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat", "\n\treturn materials[material].opacity;\n}\n\n// Get the ambient color of a material.\n// The ambient color is the color that the material reflects\n// when there is no light.\n// The color is specified as a 3-tuple of floats in the range [0.0, 1.0].\n// The default ambient color is (0.2, 0.2, 0.2).\nfloat", "\n    vec3 edge_a = tri_b - tri_a;\n    vec3 edge_b = tri_c - tri_a;\n    vec3 pvec = cross(line_b - line_a, edge_b);\n    float det = dot(edge_a, pvec);\n    if (det == 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 tvec = line_a - tri_a;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 qvec = cross(tvec, edge_a);\n    float v = dot(line_b - line_a, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float t = dot(edge_b, qvec) * inv_det;\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a plane.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n\n    mat3 rotation_matrix = mat3(\n        x_axis.x, y_axis.x, z_axis.x,\n        x_axis.y, y_axis.y, z_axis.y,\n        x_axis.z, y_axis.z, z_axis.z\n    );\n\n    return rotation_matrix;\n}\n\n// Generate a perspective projection matrix based on a field of view\n// and aspect ratio.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/perspective-projection-matrix\nmat", "\n    cast_ray_result result;\n    result.distance = std::numeric_limits<float>::max();\n    for (auto &triangle : triangles) {\n        cast_ray_result temp_result = triangle.cast_ray(ray_origin, ray_target);\n        if (temp_result.distance < result.distance) {\n            result = temp_result;\n        }\n    }\n    return result;\n}\n\n// Cast a ray from the camera through the center of the screen,\n// and return the color of the pixel that the ray intersects with.\nvec", "\n    float t = 0.0;\n    float t_min = 0.0;\n    float t_max = 1000000.0;\n    float t_hit = 1000000.0;\n    vec3 hit_point;\n    vec3 hit_normal;\n    vec3 hit_color;\n    vec3 hit_tex_coord;\n    vec3 hit_tex_color;\n    int hit_material_index = -1;\n    int hit_object_index = -1;\n    int hit_light_index = -1;\n    int hit_light_type = -1;\n    int hit_light_num_samples = -1;\n    int hit_light_num_samples_remaining = -1;\n    int hit_light_num_samples_total = -1;\n    int hit_light_num_samples_done = -1;\n    int hit_light_num_samples_done_total = -1;\n    int hit_light_num_samples_done_remaining = -1;\n    int hit_light_num_samples_done_this_frame = -1;\n    int hit_light_num_samples_done_this_frame_total = -1;\n    int hit_light_num_samples_done_this_frame_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max = -1;\n    int hit_light_num_samples_done_this_frame_max_total = -1;\n    int hit_light_num_samples_done_this_frame_max_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_total = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_max = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_max_total = -1;\n    int hit_light_num_samples_done_this_frame_max_this_", "\n\treturn fract( sin( x ) * 43758.5453123 );\n}\n\n// 2D noise\nfloat", "\n\tfloat f = fract( p );\n\tf = f * f * ( 3.0 - 2.0 * f );\n\treturn f;\n}\n\n// Simplex gradient noise\nfloat", "\n    n = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return (float) n / 1073741824.0;\n}\n\n// float hash copied from Hugo Elias\nfloat", "\n\tfloat f = fract( p * 0.1136 );\n\tf = f * f + f * 0.344;\n\treturn f * f * f * f * f;\n}\n\n// gradient noise\nfloat", "\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfloat n = 1.0;\n\tfor( float i = 0.0; i < n; i++ )\n\t{\n\t\tsum += amp * noise( x * freq );\n\t\tamp *= G;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// fbm\nfloat", "\n\t// Compute the quadratic polynomial coefficients\n\tvec3 a = vec3( 1.0, 4.0 * p.y, 2.0 * p.y * p.y + 4.0 * p.x * p.x );\n\tvec3 b = vec3( 0.0, 2.0 * p.x, 8.0 * p.x * p.y );\n\tvec3 c = vec3( 2.0 * p.x * p.x + 2.0 * p.y * p.y, 4.0 * p.x * p.y, p.x * p.x + p.y * p.y );\n\n\t// Solve the quadratic equation\n\tvec3 d = b * b - 4.0 * a * c;\n\tvec3 x = ( -b - sqrt( d ) ) / ( 2.0 * a );\n\tvec3 y = ( -b + sqrt( d ) ) / ( 2.0 * a );\n\n\t// Return the color of the closest solution\n\treturn ( length( x ) < length( y ) )? x : y;\n}\n\nvoid main()\n{\n\t// Compute the point on the sphere's surface\n\tvec3 p = normalize( vec3( gl_FragCoord.xy * 2.0 - iResolution.xy, 0.0 ) );\n\n\t// Compute the color of the point\n\tvec3 color = getColor( p );\n\n\t// Output the result\n\tgl_FragColor = vec4( color, 1.0 );\n}\n```\n\n## 2. \u5149\u7ebf\u8ffd\u8e2a\n\n### 2.1 \u5149\u7ebf\u8ffd\u8e2a\u7684\u57fa\u672c\u539f\u7406\n\n\u5149\u7ebf\u8ffd\u8e2a\u7684\u57fa\u672c\u539f\u7406\u662f\uff1a\n\n- \u5149\u7ebf\u662f\u4ece\u5149\u6e90\u53d1\u51fa\u7684\uff0c\u4ece\u5149\u6e90\u5230\u573a\u666f\u4e2d\u7684\u67d0\u4e00\u70b9\uff0c\u53ef\u4ee5\u7528\u4e00\u6761\u5c04\u7ebf\u6765\u8868\u793a\u3002\n- \u5149\u7ebf\u5728\u573a\u666f\u4e2d\u7a7f\u8fc7\u7269\u4f53\uff0c\u4f1a\u9047\u5230\u5404\u79cd\u5404\u6837\u7684\u7269\u4f53\uff0c\u8fd9\u4e9b\u7269\u4f53\u4f1a\u53cd\u5c04\u5149\u7ebf\uff0c\u6216\u8005\u6298\u5c04\u5149\u7ebf\u3002\n- \u5149\u7ebf\u5728\u573a\u666f\u4e2d\u7a7f\u8fc7\u7269\u4f53\uff0c\u4f1a\u9047\u5230\u5404\u79cd\u5404\u6837\u7684\u7269\u4f53\uff0c\u8fd9\u4e9b\u7269\u4f53\u4f1a\u53cd\u5c04\u5149\u7ebf\uff0c\u6216\u8005\u6298\u5c04\u5149\u7ebf", "\n\tvec3 p = pb;\n\tp.x = p.x * 2.0 - 1.0;\n\tp.y = p.y * 2.0 - 1.0;\n\tp.z = p.z * 2.0 - 1.0;\n\tvec3 c = vec3(0.0);\n\tc.x = p.x * p.x * p.x;\n\tc.y = p.y * p.y * p.y;\n\tc.z = p.z * p.z * p.z;\n\tvec3 d = vec3(0.0);\n\td.x = p.x * p.x;\n\td.y = p.y * p.y;\n\td.z = p.z * p.z;\n\tvec3 e = vec3(0.0);\n\te.x = p.x * p.y;\n\te.y = p.y * p.z;\n\te.z = p.z * p.x;\n\tvec3 f = vec3(0.0);\n\tf.x = p.x * p.y * p.z;\n\tf.y = p.x * p.z * p.y;\n\tf.z = p.y * p.x * p.z;\n\tvec3 g = vec3(0.0);\n\tg.x = p.x * p.y * p.z;\n\tg.y = p.x * p.z * p.y;\n\tg.z = p.y * p.x * p.z;\n\tvec3 h = vec3(0.0);\n\th.x = p.x * p.y * p.z;\n\th.y = p.x * p.z * p.y;\n\th.z = p.y * p.x * p.z;\n\tvec3 a = vec3(0.0);\n\ta.x = c.x + d.x + e.x + f.x + g.x + h.x;\n\ta.y = c.y + d.y + e.y + f.y + g", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (cen - ro) * invdir;\n\tvec3 tmax = (cen + rad - ro) * invdir;\n\tif (all(lessThan(tmin, tmax))) {\n\t\tfloat t1 = max(max(tmin.x, tmin.y), tmin.z);\n\t\tfloat t2 = min(min(tmax.x, tmax.y), tmax.z);\n\t\treturn vec4(t1, t2);\n\t} else {\n\t\treturn vec4(0.0);\n\t}\n}\n\n// http://iquilezles.org/www/articles/rayboxintersect/rayboxintersect.htm\nvec", "\n\tvec3 p = abs(rd) - cen;\n\tvec3 b = clamp( p, 0.0, rad );\n\treturn min( max( b.x, max( b.y, b.z ) ), 0.0 ) + length( max( p - rad, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n    float t = mint;\n    float d = 0.0;\n    float s = 0.0;\n    float f = 0.0;\n    float p = 0.0;\n    float m = 0.0;\n    float e = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40", " seed = (seed * 1664525 + 1013904223) % 2147483647; return seed / 2147483647.0; }\nfloat", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n\tfloat d = length(p);\n\tfloat a = length(vec2(p.x,p.y));\n\tfloat b = length(vec2(p.x,p.z));\n\tfloat c = length(vec2(p.y,p.z));\n\tfloat s = (a+b+c)/2.0;\n\tfloat A = sqrt(s*(s-a)*(s-b)*(s-c));\n\tfloat R = A/s;\n\tfloat r = sqrt(a*a+b*b-2*a*b*cos(ra));\n\tfloat h2 = h*h;\n\tfloat d2 = d*d;\n\tfloat r2 = r*r;\n\tfloat R2 = R*R;\n\tfloat la2 = la*la;\n\tfloat lb2 = lb*lb;\n\tfloat h2la2 = h2+la2;\n\tfloat h2lb2 = h2+lb2;\n\tfloat d2la2 = d2+la2;\n\tfloat d2lb2 = d2+lb2;\n\tfloat r2la2 = r2+la2;\n\tfloat r2lb2 = r2+lb2;\n\tfloat R2la2 = R2+la2;\n\tfloat R2lb2 = R2+lb2;\n\tfloat h2la2lb2 = h2la2+lb2;\n\tfloat h2la2lb2r2 = h2la2lb2+r2;\n\tfloat h2la2lb2r2R2 = h2la2lb2r2+R2;\n\tfloat h2la2lb2r2R2d2 = h2la2lb2r2R2+d2;\n\tfloat h2la2lb2r2R2d2la2 = h2la2lb2r2R2d2+la2;\n\tfloat h2la2lb2r2R2d2la2lb2 = h2la2lb2r2R2d2la2+lb2;\n\tfloat h2la2lb2r2R2d2la2lb2r2 = h2la2lb2r2R2d2la2lb2", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 ap = a + ba * h - p;\n\tfloat d = length( ap );\n\tfloat x = d - r;\n\tfloat y = length( ap + band * normalize( ba ) );\n\tfloat z = length( ba );\n\tfloat w = length( p - a );\n\treturn vec4( x, y, z, w );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 d = abs(p) - b;\n    vec2 q = clamp(d, 0.0, r);\n    float c = length(d - q);\n    float h = clamp(s - c, 0.0, r);\n    return vec4(q, h, c, 0.0);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\nvec", "\n\tvec2 d = abs(p) - r;\n\tfloat x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\tfloat y = length(max(d,0.0));\n\tfloat z = y + band;\n\tfloat w = length(p);\n\treturn vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n\tfloat h = 0.0;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tfloat d = sdLine( p, verts[i], verts[(i+1)%5] );\n\t\th = max( h, d );\n\t}\n\treturn h - r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat", "\n\tvec4 res = vec4(0.0);\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat w = 0.0;\n\tfloat d = 0.0;\n\tfloat l = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.", "\nvec", "\n\tvec3 q = vec3( p, 0.0 );\n\tfloat d = length( q );\n\tfloat t = atan( q.y, q.x );\n\tfloat s = sign( q.x );\n\tfloat a = s * ( 1.0 - r ) * t;\n\tfloat b = s * ( 1.0 - r ) * ( 1.0 - t );\n\tfloat c = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat d = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat e = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat f = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat g = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat h = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat i = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat j = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat k = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat l = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat m = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat n = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat o = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat p = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat q = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat r = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat s = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat t = s * ( 1.", "\n\t// Find the two tangents to the conic X from point p.\n\t// The conic is a quadratic in the form\n\t//   X = (x^2 + y^2 + z^2) + (a*x + b*y + c*z) + d\n\t// The tangents are the two solutions to the quadratic\n\t//   (x^2 + y^2 + z^2) + (a*x + b*y + c*z) + d = 0\n\t// which are\n\t//   x^2 + y^2 + z^2 + (a*x + b*y + c*z) + d = 0\n\t//   x^2 + y^2 + z^2 + (a*x + b*y + c*z) + d = 0\n\t// which are\n\t//   x^2 + (a*x + b*y + c*z) + d = 0\n\t//   y^2 + (a*x + b*y + c*z) + d = 0\n\t// which are\n\t//   x^2 + a*x + b*y + c*z + d = 0\n\t//   y^2 + a*x + b*y + c*z + d = 0\n\t// which are\n\t//   x^2 + a*x + b*y + c*z + d = 0\n\t//   y^2 + a*x + b*y + c*z + d = 0\n\t// which are\n\t//   x^2 + a*x + b*y + c*z + d = 0\n\t//   y^2 + a*x + b*y + c*z + d = 0\n\t// which are\n\t//   x^2 + a*x + b*y + c*z + d = 0\n\t//   y^2 + a*x + b*y + c*z + d = 0\n\t// which are\n\t//   x^2 + a*x + b*y + c*z + d = 0\n\t//   y^2 + a*x + b*y + c*z + d = 0\n\t", "\n\tif (b.x == 0) b.x += 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec", "\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\treturn 1.0f - 0.5f * (x - R) / R;\n\telse\n\t\treturn 0.0f;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat", "\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat", "\n\tfloat k = 0.0f;\n\tfloat d = b - a;\n\tfloat r = R * R;\n\tfloat e2 = e * e;\n\tif (d!= 0.0f)\n\t{\n\t\tk = (d * d) / (4.0f * r * e2);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n    return e * (1.0 - length(p - c) / R);\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n    float d = length(a - b);\n    float l = length(c - a);\n    float r = length(c - b);\n    float L = length(c - e);\n    float D = length(a - e);\n    float F = length(b - e);\n    float G = length(c - e);\n    float H = length(a - c);\n    float I = length(b - c);\n    float J = length(a - b);\n    float K = length(c - a);\n    float M = length(c - b);\n    float N = length(a - c);\n    float O = length(b - c);\n    float P = length(a - b);\n    float Q = length(c - a);\n    float S = length(c - b);\n    float T = length(a - c);\n    float U = length(b - c);\n    float V = length(a - b);\n    float W = length(c - a);\n    float X = length(c - b);\n    float Y = length(a - c);\n    float Z = length(b - c);\n    float A = length(a - b);\n    float B = length(c - a);\n    float C = length(c - b);\n    float D = length(a - c);\n    float E = length(b - c);\n    float F = length(a - b);\n    float G = length(c - a);\n    float H = length(c - b);\n    float I = length(a - c);\n    float J = length(b - c);\n    float K = length(a - b);\n    float L = length(c - a);\n    float M = length(c - b);\n    float N = length(a - c);\n    float O = length(b - c);\n    float P = length(a - b);\n    float Q = length(c - a);\n    float R = length(c - b);\n    float S = length(a - c);\n    float T = length(b - c);\n    float U = length(a - b);\n    float V = length(c - a);\n    float W = length(c - b);\n    float X = length(a - c);\n    float Y = length(b - c);\n    float Z = length(a - b);\n    float A = length(c - a);\n    float", "\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat A = 1.0;\n\tfloat B = 1.0;\n\tfloat C = 1.0;\n\tfloat D = 1.0;\n\tfloat E = 1.0;\n\tfloat F = 1.0;\n\tfloat G = 1.0;\n\tfloat H = 1.0;\n\tfloat I = 1.0;\n\tfloat J = 1.0;\n\tfloat K = 1.0;\n\tfloat L = 1.0;\n\tfloat M = 1.0;\n\tfloat N = 1.0;\n\tfloat O = 1.0;\n\tfloat P = 1.0;\n\tfloat Q = 1.0;\n\tfloat R = 1.0;\n\tfloat S = 1.0;\n\tfloat T = 1.0;\n\tfloat U = 1.0;\n\tfloat V = 1.0;\n\tfloat W = 1.0;\n\tfloat X = 1.0;\n\tfloat Y = 1.0;\n\t", "\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// K root\nfloat", "\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec", "\n\t// Sphere tracing\n\tfloat t = 0.0;\n\tvec3 p = o;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t// Check if we hit the sphere\n\t\tfloat d = length(p - sphere.position);\n\t\tif (d < sphere.radius)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\n\t\t// Move along the ray\n\t\tt += d / length(u);\n\t\tp += u * d;\n\t}\n\n\t// We didn't hit the sphere\n\th = false;\n\ts = 0;\n\treturn t;\n}\n\n// Trace ray using ray tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\twhile (s < 1000)\n\t{\n\t\tt += 0.001;\n\t\tvec3 p = o + t * u;\n\t\tif (p.x < -1.0 || p.x > 1.0 || p.y < -1.0 || p.y > 1.0)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h * ba;\n\tvec3 d = p - q;\n\treturn length(d) - r;\n}\n\n// cylinder with arbitrary orientation\nfloat", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\tvec3 t = min( t1, t2 );\n\tvec3 tmax_ = max( t1, t2 );\n\tvec3 tmin_ = min( t1, t2 );\n\tvec3 tmax__ = max( tmax, tmax_ );\n\tvec3 tmin__ = min( tmin, tmin_ );\n\treturn vec2( max( tmax__, tmin__ ), min( tmax__, tmin__ ) );\n}\n\n// http://iquilezles.org/www/articles/rayboxintersect/rayboxintersect.htm\nbool iBoxIntersect( in vec3 ro, in vec3 rd, in vec3 rad, in vec2 t )\n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\tvec3 tmin_ = min( t1, t2 );\n\tvec3 tmax_ = max( t1, t2 );\n\tvec3 tmin__ = min( tmin_, t );\n\tvec3 tmax__ = max( tmax_, t );\n\treturn ( tmax__ >= tmin__ );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat", "\n\treturn coord * 0.5 + 0.5;\n}\n\n// texture lookup\nvec", "\nvec", "\n\tfloat a = 1.0 - p.x * p.x - p.y * p.y;\n\tfloat b = 2.0 * p.x * p.y;\n\tfloat c = 2.0 * p.x * p.y;\n\tfloat d = p.x * p.x + p.y * p.y - r * r;\n\tfloat e = 2.0 * p.x;\n\tfloat f = 2.0 * p.y;\n\tfloat g = 1.0;\n\tfloat h = 2.0 * p.x * p.x + 2.0 * p.y * p.y - d;\n\tfloat i = 2.0 * p.x * p.y;\n\tfloat j = 2.0 * p.x * p.y;\n\tfloat k = 2.0 * p.x * p.y;\n\tfloat l = 2.0 * p.x * p.y;\n\tfloat m = 2.0 * p.x * p.y;\n\tfloat n = 2.0 * p.x * p.y;\n\tfloat o = 2.0 * p.x * p.y;\n\tfloat p = 2.0 * p.x * p.y;\n\tfloat q = 2.0 * p.x * p.y;\n\tfloat r1 = a * d - b * c;\n\tfloat s = a * e - b * f;\n\tfloat t = a * g - b * h;\n\tfloat u = a * i - b * j;\n\tfloat v = a * k - b * l;\n\tfloat w = a * m - b * n;\n\tfloat x = a * o - b * p;\n\tfloat y = a * q - b * r;\n\tfloat z = a * s - b * t;\n\tfloat A = a * u - b * v;\n\tfloat B = a * w - b * x;\n\tfloat C = a * y - b * z;\n\tfloat D = c * e - b * g;\n\tfloat E = c * f - b * h;\n\tfloat F = c * i -", "\n\tvec3 v = vec3( p, 0.0 );\n\tv.xy = cos( c.x * v.x + c.y * v.y ) * r;\n\tv.z = sin( c.x * v.x + c.y * v.y );\n\tv.yz = normalize( v.yz );\n\treturn v;\n}\n\n// 2D SDF of a circle\nfloat", "\nvec", "\n\tvec2 q = p * sca;\n\tvec2 r = q * scb;\n\tfloat t = atan( r.y, r.x );\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * c;\n\tfloat b = rb * s;\n\tfloat x = a + b;\n\tfloat y = b - a;\n\tfloat z = 1.0 - x - y;\n\treturn vec3( x, y, z );\n}\n\n//\n// sdgCircle\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 2D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\nvec", "\n\tvec2 q = vec2( length(p.xz) - ra, p.y );\n\tfloat d = length(q) - rb;\n\tfloat g = dot(q,q) - ra*ra;\n\tfloat h = d*d + g*g;\n\tfloat s = sqrt( max( 0.0, 1.0 - h/ra/ra ) );\n\tfloat t = sqrt( max( 0.0, 1.0 - h/rb/rb ) );\n\tvec3 n = normalize( cross( p.xyz, q ) );\n\tvec3 x = normalize( cross( n, q ) );\n\tvec3 y = cross( x, n );\n\tvec3 z = cross( y, x );\n\tvec3 w = cross( z, y );\n\tvec3 v = vec3( s, t, d );\n\tvec3 u = vec3( g, 0.0, 0.0 );\n\tvec3 yzw = vec3( y.z, z.z, w.z );\n\treturn vec4( v, u ) * vec4( yzw, 1.0 );\n}\n\n// Torus\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 q = a + h * ba;\n\tvec3 d = p - q;\n\tfloat s = clamp( length( d ) / r, 0.0, 1.0 );\n\treturn vec4( s, d.x, d.y, d.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tfloat h = abs(p.x*sin(sk) + p.y*cos(sk));\n\tfloat d = length(p - vec2(wi*0.5, he*0.5)) - wi*0.5;\n\treturn min(h, d);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset)\nfloat", "\n\tvec2 q = p - vec2( wi, he );\n\tvec2 r = p + vec2( wi, he );\n\tvec2 s = p + vec2( wi, -he );\n\tvec2 t = p - vec2( wi, -he );\n\tvec2 u = p + vec2( -wi, he );\n\tvec2 v = p - vec2( -wi, he );\n\tvec2 w = p + vec2( -wi, -he );\n\tvec2 x = p - vec2( -wi, -he );\n\tvec2 y = p + vec2( sk, 0.0 );\n\tvec2 z = p - vec2( sk, 0.0 );\n\tvec2 a = p + vec2( 0.0, sk );\n\tvec2 b = p - vec2( 0.0, sk );\n\tvec2 c = p + vec2( sk, sk );\n\tvec2 d = p - vec2( sk, sk );\n\tvec2 e = p + vec2( sk, -sk );\n\tvec2 f = p - vec2( sk, -sk );\n\tvec2 g = p + vec2( -sk, sk );\n\tvec2 h = p - vec2( -sk, sk );\n\tvec2 i = p + vec2( -sk, -sk );\n\tvec2 j = p - vec2( -sk, -sk );\n\tvec2 k = p + vec2( sk, sk );\n\tvec2 l = p - vec2( sk, sk );\n\tvec2 m = p + vec2( sk, -sk );\n\tvec2 n = p - vec2( sk, -sk );\n\tvec2 o = p + vec2( -sk, sk );\n\tvec2 p = p - vec2( -sk, sk );\n\tvec2 q = p + vec2( -sk, -sk );\n\tvec2 r = p - vec2( -sk, -sk );\n\tvec2 s = p + vec2( sk, sk );\n\tvec2 t = p - vec2( sk, sk );\n\tvec2 u = p + vec2( sk, -sk );\n\tvec2 v = p - vec2", "\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tr += c;\n\treturn r;\n\t}\n\nfloat", "\n\tfloat diff = fabs(a - b);\n\tif (diff < k) {\n\t\treturn a;\n\t}\n\treturn (a + b) / 2.0f;\n}\n\n// IQ's polynominal max\nfloat", "\n\treturn mod(p, size) - 0.5 * size;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec", "\n\tvec3 c = vec3(s.x, s.y, s.z);\n\tfloat r = s.w;\n\tvec3 oc = ro - c;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(oc, rd);\n\tfloat c = dot(oc, oc) - r * r;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) {\n\t\treturn vec2(-1.0, -1.0);\n\t}\n\tfloat s0 = (-b - sqrt(d)) / (2.0 * a);\n\tfloat s1 = (-b + sqrt(d)) / (2.0 * a);\n\tif (s0 > 0.0 && s1 > 0.0) {\n\t\treturn vec2(s0, s1);\n\t} else if (s0 > 0.0) {\n\t\treturn vec2(s0, -1.0);\n\t} else if (s1 > 0.0) {\n\t\treturn vec2(s1, -1.0);\n\t} else {\n\t\treturn vec2(-1.0, -1.0);\n\t}\n}\n\n// IQ's ray triangle intersection\nvec", "\n\tvec3 invDir = 1.0 / rd;\n\tvec3 tmin = (boxSize - ro) * invDir;\n\tvec3 tmax = (-boxSize - ro) * invDir;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat tnear = max(max(t1.x, t1.y), t1.z);\n\tfloat tfar = min(min(t2.x, t2.y), t2.z);\n\tif (tnear > tfar) return vec2(1e10);\n\toutNormal = vec3(0.0);\n\tif (tnear < 0.0) {\n\t\ttnear = tfar;\n\t\toutNormal = (tnear > 0.0)? rd : -rd;\n\t}\n\treturn vec2(tnear, tfar);\n}\n\n// IQ's ray sphere intersection\nvec", "\n\te1 = vec2(d.x, 0);\n\te2 = vec2(0, d.y);\n\te3 = vec2(-d.x, 0);\n\te4 = vec2(0, -d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n\te1 = vec3(d.x, 0, 0);\n\te2 = vec3(0, d.y, 0);\n\te3 = vec3(0, 0, d.z);\n\te4 = vec3(-d.x, 0, 0);\n\te5 = vec3(0, -d.y, 0);\n\te6 = vec3(0, 0, -d.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\te1 = vec2(d.x, 0);\n\te2 = vec2(0, d.y);\n\te3 = vec2(-d.x, 0);\n\te4 = vec2(0, -d.y);\n\te5 = vec2(d.x, d.y);\n\te6 = vec2(-d.x, d.y);\n\te7 = vec2(-d.x, -d.y);\n\te8 = vec2(d.x, -d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\tif ( h < 0.0 ) return length(pa);\n\tif ( h > 1.0 ) return length(p-b);\n\treturn length( pa - h*ba ) - w2;\n}\n\n// The distance from a point to a line segment.\nfloat", "\n    vec2 p = vec2(dot(ro, rd), dot(ro, ro));\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, ro);\n    float c = dot(ro, ro) - tor.x * tor.x;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return -1.0;\n    float e = sqrt(d);\n    float u1 = (-b - e) / (2.0 * a);\n    float u2 = (-b + e) / (2.0 * a);\n    if (u1 > u2) swap(u1, u2);\n    if (u1 > 0.0) return u1;\n    if (u2 > 0.0) return u2;\n    return -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec2 p = vec2(length(pos.xz) - tor.x, pos.y);\n    return normalize(vec3(p, dot(p, p) - tor.y * tor.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec", "\n    float x2 = x * x;\n    float x4 = x2 * x2;\n    float x6 = x4 * x2;\n    float x8 = x4 * x4;\n    float x10 = x6 * x4;\n    float x12 = x6 * x6;\n    float x14 = x8 * x6;\n    float x16 = x8 * x8;\n    float x18 = x10 * x8;\n    float x20 = x10 * x10;\n    float x22 = x12 * x10;\n    float x24 = x12 * x12;\n    float x26 = x14 * x12;\n    float x28 = x14 * x14;\n    float x30 = x16 * x14;\n    float x32 = x16 * x16;\n    float x34 = x18 * x16;\n    float x36 = x18 * x18;\n    float x38 = x20 * x18;\n    float x40 = x20 * x20;\n    float x42 = x22 * x20;\n    float x44 = x22 * x22;\n    float x46 = x24 * x22;\n    float x48 = x24 * x24;\n    float x50 = x26 * x24;\n    float x52 = x26 * x26;\n    float x54 = x28 * x26;\n    float x56 = x28 * x28;\n    float x58 = x30 * x28;\n    float x60 = x30 * x30;\n    float x62 = x32 * x30;\n    float x64 = x32 * x32;\n    float x66 = x34 * x32;\n    float x68 = x34 * x34;\n    float x70 = x36 * x34;\n    float x72 = x36 * x36;\n    float x74 = x38 * x36;\n    float x76 = x38 * x38;\n    float x", "\n    vec3 c = col;\n    c.x = 1.0 - exp(-c.x * 0.00001);\n    c.y = 1.0 - exp(-c.y * 0.00001);\n    c.z = 1.0 - exp(-c.z * 0.00001);\n    return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec", "\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec", "\n\tuv = uv * 2.0 - 1.0;\n\tvec4 p = vec4(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5, 183.3)), dot(uv, vec2(419.2, 371.9)), dot(uv, vec2(987.2, 374.2)));\n\treturn fract(sin(dot(p, vec4(12.9898, 78.233, 151.7182, 24.715))) * 43758.5453);\n}\n\nfloat", "\n\treturn length( p - c ) - r;\n}\n\n// signed distance to a rectangle\nfloat", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// distance to a circle\nfloat", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 2D triangle\nfloat", "\n\tvec2 q = abs(p) - vec2(s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + length(max(vec2(length(q)-r),0.0));\n}\n\n// s = side length\n// r = corner radius\nfloat", "\n\treturn x * (x * (3.0 - 2.0 * x));\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec", "\n\tvec3 y;\n\ty.x = 3.0 * x.x * (1.0 - x.x) * (1.0 - 2.0 * x.x);\n\ty.y = 3.0 * x.y * (1.0 - x.y) * (1.0 - 2.0 * x.y);\n\ty.z = 3.0 * x.z * (1.0 - x.z) * (1.0 - 2.0 * x.z);\n\treturn y;\n}\n\n// derivative of s-curve\nvec", "\n\tfloat a = 2.0 * PI * k;\n\tfloat r = length( p ) / a;\n\tfloat t = atan( p.y, p.x ) / a;\n\treturn r * cos( t ) + w * sin( t );\n}\n\n// Spiral\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat", "\nreturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec", "\n\t// Integrate the scattering along the ray.\n\tvec3 scatteredColor = vec3(0.0);\n\tfloat opticalDepth = 0.0;\n\tfloat stepSize = 0.01;\n\tfloat stepCount = rayLength / stepSize;\n\tfor (int i = 0; i < stepCount; i++)\n\t{\n\t\tfloat t = float(i) * stepSize;\n\t\tvec3 pos = rayStart + rayDir * t;\n\t\tvec3 normal = GetNormal(pos);\n\t\tvec3 color = GetColor(pos);\n\t\tfloat attenuation = 1.0;\n\t\tif (i > 0)\n\t\t{\n\t\t\t// Calculate the attenuation due to the optical depth.\n\t\t\tattenuation = exp(-opticalDepth);\n\t\t}\n\t\t// Calculate the scattering.\n\t\tvec3 scattering = GetScattering(pos, normal, lightDir, lightColor);\n\t\t// Add the scattering to the total.\n\t\tscatteredColor += attenuation * scattering;\n\t\t// Add the optical depth.\n\t\topticalDepth += GetOpticalDepth(pos, normal);\n\t}\n\t// Calculate the transmittance.\n\ttransmittance = exp(-opticalDepth);\n\t// Return the scattered color.\n\treturn scatteredColor;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec", "\n\tvec3 d2 = p2 - p;\n\tfloat h = length( d2 ) - d;\n\treturn max( h, ra - rb );\n}\n\n//\n// \n//\n\nfloat", "\n\tfloat d = length( p - vec3( 0, h, 0 ) );\n\treturn max( d - r - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat", "\n\tfloat t = tmin;\n\tfloat dt = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat f = 0.0;\n\tfloat bias = 0.0;\n\tfloat shadow = 1.0;\n\tfloat bias_shadow = 1.0;\n\tfloat bias_shadow_soft = 1.0;\n\tfloat bias_shadow_soft_max = 1.0;\n\tfloat bias_shadow_soft_min = 1.0;\n\tfloat bias_shadow_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min = 1.0;\n\tfloat bias_shadow_soft_min_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_soft_soft_soft_soft_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_soft_soft_soft_soft_soft", "\n\tfloat d = p.y - h;\n\tif ( d < 0.0 ) return length( p ) - r;\n\telse return length( p - vec3( 0.0, h, 0.0 ) ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat", "\n\tvec3 eps = vec3( 0.001, 0.001, 0.001 );\n\treturn normalize( vec3(\n\t\tsdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n\t\tsdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n\t\tsdf( pos + eps.yyx ) - sdf( pos - eps.yyx )\n\t) );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n\tvec2 q = abs(p) - vec2(r,h);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// r=radius, h=height\nfloat", "\n\tvec3 p = floor( x );\n\tvec3 f = fract( x );\n\n\tf = f * f * ( 3.0 - 2.0 * f );\n\n\tvec4 ix = vec4( p.x, p.y, p.z, p.x + p.y );\n\tvec4 iy = vec4( ix.y, ix.z, ix.x, ix.y );\n\tvec4 iz0 = vec4( ix.z, ix.w, iy.x, iy.y );\n\tvec4 iz1 = vec4( ix.w, ix.x, iy.y, iy.z );\n\n\tvec4 ixy = permute( permute( ix ) + iy.z );\n\tvec4 ixy0 = permute( ixy + iz0.x );\n\tvec4 ixy1 = permute( ixy + iz1.x );\n\n\tvec4 ixy00 = permute( ixy0 + iz0.y );\n\tvec4 ixy01 = permute( ixy0 + iz1.y );\n\tvec4 ixy10 = permute( ixy1 + iz0.y );\n\tvec4 ixy11 = permute( ixy1 + iz1.y );\n\n\tvec4 gx00 = ixy00 * ( 1.0 / 7.0 );\n\tvec4 gx01 = ixy01 * ( 1.0 / 7.0 );\n\tvec4 gx10 = ixy10 * ( 1.0 / 7.0 );\n\tvec4 gx11 = ixy11 * ( 1.0 / 7.0 );\n\n\tgx00 = fract( gx00 ) - 0.5;\n\tgx01 = fract( gx01 ) - 0.5;\n\tgx10 = fract( gx10 ) - 0.5;\n\tgx11 = fract( gx11 ) - 0.5;\n\n\tvec4 norm00 = taylorInvSqrt( vec4( dot( gx00, gx00 ), dot( gx01, gx01 ), dot( gx10, gx10 ), dot( gx1", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 2.0;\n\tfloat c = 0.5;\n\tfloat d = 2.0;\n\tfloat e = 0.5;\n\tfloat f = 2.0;\n\tfloat g = 0.5;\n\tfloat h = 2.0;\n\tfloat i = 0.5;\n\tfloat j = 2.0;\n\tfloat k = 0.5;\n\tfloat l = 2.0;\n\tfloat m = 0.5;\n\tfloat n = 2.0;\n\tfloat o = 0.5;\n\tfloat p = 2.0;\n\tfloat q = 0.5;\n\tfloat r = 2.0;\n\tfloat s = 0.5;\n\tfloat t = 2.0;\n\tfloat u = 0.5;\n\tfloat v = 2.0;\n\tfloat w = 0.5;\n\tfloat x = 2.0;\n\tfloat y = 0.5;\n\tfloat z = 2.0;\n\tfloat A = 0.5;\n\tfloat B = 2.0;\n\tfloat C = 0.5;\n\tfloat D = 2.0;\n\tfloat E = 0.5;\n\tfloat F = 2.0;\n\tfloat G = 0.5;\n\tfloat H = 2.0;\n\tfloat I = 0.5;\n\tfloat J = 2.0;\n\tfloat K = 0.5;\n\tfloat L = 2.0;\n\tfloat M = 0.5;\n\tfloat N = 2.0;\n\tfloat O = 0.5;\n\tfloat P = 2.0;\n\tfloat Q = 0.5;\n\tfloat R = 2.0;\n\tfloat S = 0.5;\n\tfloat T = 2.0;\n\tfloat U = 0.5;\n\tfloat V = 2.0;\n\tfloat W = 0.5;\n\tfloat X = 2.0;\n\t", "\n\tvec3 p = fract(p3.xyz *.1031);\n\tp += dot(p, p.yzx + 19.19);\n\treturn fract((p.x + p.y) * p.z);\n}\n\n//simplex noise\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat t = iTime;\n\tfloat a = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat b = 0.0;\n\tfloat e = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat r = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\tfloat Z", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(hue, 1.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default class HueShader extends Shader {\n    constructor() {\n        super(vertexShader, fragmentShader);\n    }\n}\n/src/shaders/hue-shader.js\nimport Shader from './shader';\n\nconst vertexShader = `\nattribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision mediump float;\n\nuniform float hue;\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec", "\n    return fract(p * size);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n\treturn (co * 127.1) - (int)(co * 127.1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat", "\n    return pow(c, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat", "\n    float r = sph.w;\n    float r2 = r*r;\n    float d = length(ro-sph.xyz);\n    float d2 = d*d;\n    float b = dot(rd,ro-sph.xyz);\n    float c = d2-r2;\n    float disc = b*b-c;\n    if (disc < 0) return dbuffer;\n    float t = -b-sqrt(disc);\n    if (t < dbuffer) return dbuffer;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n    vec4 p0 = vec4(p.x, p.y, 0.0, 0.0);\n    vec4 p1 = vec4(p.x, p.y, 1.0, 1.0);\n    vec4 p2 = vec4(p.x, p.y, 2.0, 2.0);\n    vec4 p3 = vec4(p.x, p.y, 3.0, 3.0);\n    vec4 p4 = vec4(p.x, p.y, 4.0, 4.0);\n    vec4 p5 = vec4(p.x, p.y, 5.0, 5.0);\n    vec4 p6 = vec4(p.x, p.y, 6.0, 6.0);\n    vec4 p7 = vec4(p.x, p.y, 7.0, 7.0);\n    vec4 p8 = vec4(p.x, p.y, 8.0, 8.0);\n    vec4 p9 = vec4(p.x, p.y, 9.0, 9.0);\n    vec4 p10 = vec4(p.x, p.y, 10.0, 10.0);\n    vec4 p11 = vec4(p.x, p.y, 11.0, 11.0);\n    vec4 p12 = vec4(p.x, p.y, 12.0, 12.0);\n    vec4 p13 = vec4(p.x, p.y, 13.0, 13.0);\n    vec4 p14 = vec4(p.x, p.y, 14.0, 14.0);\n    vec4 p15 = vec4(p.x, p.y, 15.0, 15.0);\n    vec4 p16 = vec4(p.x, p.y, 16.0, 16.0);\n    vec4 p17 = vec4(p.x, p.y, 17.0, 17.0);\n    vec", "\n\tvec3 q = p / r;\n\tvec3 q2 = q * q;\n\tvec3 q4 = q2 * q2;\n\tvec3 q6 = q4 * q2;\n\tvec3 q8 = q4 * q4;\n\tvec3 q10 = q6 * q4;\n\tvec3 q12 = q6 * q6;\n\tvec3 q14 = q8 * q6;\n\tvec3 q16 = q8 * q8;\n\tvec3 q18 = q10 * q8;\n\tvec3 q20 = q10 * q10;\n\tvec3 q22 = q12 * q10;\n\tvec3 q24 = q12 * q12;\n\tvec3 q26 = q14 * q12;\n\tvec3 q28 = q14 * q14;\n\tvec3 q30 = q16 * q14;\n\tvec3 q32 = q16 * q16;\n\tvec3 q34 = q18 * q16;\n\tvec3 q36 = q18 * q18;\n\tvec3 q38 = q20 * q18;\n\tvec3 q40 = q20 * q20;\n\tvec3 q42 = q22 * q20;\n\tvec3 q44 = q22 * q22;\n\tvec3 q46 = q24 * q22;\n\tvec3 q48 = q24 * q24;\n\tvec3 q50 = q26 * q24;\n\tvec3 q52 = q26 * q26;\n\tvec3 q54 = q28 * q26;\n\tvec3 q56 = q28 * q28;\n\tvec3 q58 = q30 * q28;\n\tvec3 q60 = q30 * q30;\n\tvec3 q62 = q32 * q30;\n\tvec3 q64 = q32 * q32;\n\tvec3 q66 = q34 * q", "\n    return front * front.a + back * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    return mix(back, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    p = abs(p);\n    vec2 q = vec2(p.x+p.y*0.57735026918962576450914878050196, p.y*0.57735026918962576450914878050196);\n    float d = length(q-floor(q+0.5));\n    return 1.0-smoothstep(r, r-0.5, d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(v * (a * v + b) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec", "\n    p = fract(sin(p) * 43758.5453123);\n    return fract(p * p * (34.0 + p * vec2(0.0, 103.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec3 color;\n    float x = Temp / 5000.0;\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float x4 = x3 * x;\n    float x5 = x4 * x;\n    float x6 = x5 * x;\n    float x7 = x6 * x;\n    float x8 = x7 * x;\n    float x9 = x8 * x;\n    float x10 = x9 * x;\n    float x11 = x10 * x;\n    float x12 = x11 * x;\n    float x13 = x12 * x;\n    float x14 = x13 * x;\n    float x15 = x14 * x;\n    float x16 = x15 * x;\n    float x17 = x16 * x;\n    float x18 = x17 * x;\n    float x19 = x18 * x;\n    float x20 = x19 * x;\n    float x21 = x20 * x;\n    float x22 = x21 * x;\n    float x23 = x22 * x;\n    float x24 = x23 * x;\n    float x25 = x24 * x;\n    float x26 = x25 * x;\n    float x27 = x26 * x;\n    float x28 = x27 * x;\n    float x29 = x28 * x;\n    float x30 = x29 * x;\n    float x31 = x30 * x;\n    float x32 = x31 * x;\n    float x33 = x32 * x;\n    float x34 = x33 * x;\n    float x35 = x34 * x;\n    float x36 = x35 * x;\n    float x37 = x36 * x;\n    float x38 = x37 * x;\n    float x39 = x38 * x;\n    float x40 = x39 * x;\n    float x41 = x40 * x;\n    float x42 = x41 * x;\n    float x43 = x42 * x;\n    float x44 = x", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(dot(i, i + vec2(1.0, 0.0)), dot(i + vec2(1.0, 0.0), i + vec2(1.0, 1.0)), u.x), mix(dot(i + vec2(0.0, 1.0), i + vec2(1.0, 1.0)), dot(i + vec2(0.0, 1.0), i + vec2(1.0, 0.0)), u.x), u.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec2(1.0);\n    discr = sqrt(discr);\n    float t = -b - discr;\n    if (t < 0.0) t = -b + discr;\n    return vec2(t, t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec", "\nfloat", "\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat w = 0.0;\n\tfloat v = 0.0;\n\tfloat u = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat q = 0.0;\n\tfloat p = 0.0;\n\tfloat o = 0.0;\n\tfloat n = 0.0;\n\tfloat m = 0.0;\n\tfloat l = 0.0;\n\tfloat k = 0.0;\n\tfloat j = 0.0;\n\tfloat i = 0.0;\n\tfloat h = 0.0;\n\tfloat g = 0.0;\n\tfloat f = 0.0;\n\tfloat e = 0.0;\n\tfloat d = 0.0;\n\tfloat c = 0.0;\n\tfloat b = 0.0;\n\tfloat a = 0.0;\n\tfloat _ = 0.0;\n\tfloat __ = 0.0;\n\tfloat ___ = 0.0;\n\tfloat ____ = 0.0;\n\tfloat _____ = 0.0;\n\tfloat ______ = 0.0;\n\tfloat _______ = 0.0;\n\tfloat ________ = 0.0;\n\tfloat _________ = 0.0;\n\tfloat __________ = 0.0;\n\tfloat ___________ = 0.0;\n\tfloat ____________ = 0.0;\n\tfloat _____________ = 0.0;\n\tfloat ______________ = 0.0;\n\tfloat _______________ = 0.0;\n\tfloat ________________ = 0.0;\n\tfloat __________________ = 0.0;\n\tfloat ___________________ = 0.0;\n\tfloat ____________________ = 0.0;\n\tfloat _____________________ = 0.0;\n\tfloat ______________________ = 0.0;\n\tfloat _______________________ = 0.0;\n\tfloat ________________________ = 0.0;\n\tfloat _________________________ = 0", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat", "\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat", "\n    float r;\n    float abs_y = abs(y) + 1e-10;      // kludge to prevent 0/0 condition\n    r = atan(x / abs_y);\n    if (y < 0)\n        r = PI - r;\n    else if (x < 0)\n        r = PI - r;\n    return r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec", "\n\treturn log(z + 1.0) - log(1.0 - z);\n}\n\n// Inverse hyperbolic cosine \nvec", "\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an csinh\nvec", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec", "\n\treturn vec2(exp(z.x), exp(z.y));\n}\n\nvec", "\n\treturn vec4(\n\t\tsmoothstep(0.0, 1.0, alpha.r * contrast),\n\t\tsmoothstep(0.0, 1.0, alpha.g * contrast),\n\t\tsmoothstep(0.0, 1.0, alpha.b * contrast),\n\t\talpha.a\n\t);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec", "\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat", "\n\tvec3 v = uvw;\n\tvec3 v1 = v;\n\tvec3 v2 = v;\n\tvec3 v3 = v;\n\tvec3 v4 = v;\n\tvec3 v5 = v;\n\tvec3 v6 = v;\n\tvec3 v7 = v;\n\tvec3 v8 = v;\n\tvec3 v9 = v;\n\tvec3 v10 = v;\n\tvec3 v11 = v;\n\tvec3 v12 = v;\n\tvec3 v13 = v;\n\tvec3 v14 = v;\n\tvec3 v15 = v;\n\tvec3 v16 = v;\n\tvec3 v17 = v;\n\tvec3 v18 = v;\n\tvec3 v19 = v;\n\tvec3 v20 = v;\n\tvec3 v21 = v;\n\tvec3 v22 = v;\n\tvec3 v23 = v;\n\tvec3 v24 = v;\n\tvec3 v25 = v;\n\tvec3 v26 = v;\n\tvec3 v27 = v;\n\tvec3 v28 = v;\n\tvec3 v29 = v;\n\tvec3 v30 = v;\n\tvec3 v31 = v;\n\tvec3 v32 = v;\n\tvec3 v33 = v;\n\tvec3 v34 = v;\n\tvec3 v35 = v;\n\tvec3 v36 = v;\n\tvec3 v37 = v;\n\tvec3 v38 = v;\n\tvec3 v39 = v;\n\tvec3 v40 = v;\n\tvec3 v41 = v;\n\tvec3 v42 = v;\n\tvec3 v43 = v;\n\tvec3 v44 = v;\n\tvec3 v45 = v;\n\tvec3 v46 = v;\n\tvec3 v47 = v;\n\tvec3 v48 = v;\n\tvec3 v49 = v;\n\tvec3 v50 = v;\n\tvec3 v51 = v;\n\t", "\n\tfloat u = uvw.x;\n\tfloat v = uvw.y;\n\tfloat w = uvw.z;\n\tfloat x = u + offset.x;\n\tfloat y = v + offset.y;\n\tfloat z = w + offset.z;\n\tfloat s = gridRes;\n\tfloat t = gridRes * 0.5;\n\tfloat r = gridRes * 0.5;\n\tfloat a = gridRes * 0.5;\n\tfloat b = gridRes * 0.5;\n\tfloat c = gridRes * 0.5;\n\tfloat d = gridRes * 0.5;\n\tfloat e = gridRes * 0.5;\n\tfloat f = gridRes * 0.5;\n\tfloat g = gridRes * 0.5;\n\tfloat h = gridRes * 0.5;\n\tfloat i = gridRes * 0.5;\n\tfloat j = gridRes * 0.5;\n\tfloat k = gridRes * 0.5;\n\tfloat l = gridRes * 0.5;\n\tfloat m = gridRes * 0.5;\n\tfloat n = gridRes * 0.5;\n\tfloat o = gridRes * 0.5;\n\tfloat p = gridRes * 0.5;\n\tfloat q = gridRes * 0.5;\n\tfloat r1 = gridRes * 0.5;\n\tfloat r2 = gridRes * 0.5;\n\tfloat r3 = gridRes * 0.5;\n\tfloat r4 = gridRes * 0.5;\n\tfloat r5 = gridRes * 0.5;\n\tfloat r6 = gridRes * 0.5;\n\tfloat r7 = gridRes * 0.5;\n\tfloat r8 = gridRes * 0.5;\n\tfloat r9 = gridRes * 0.5;\n\tfloat r10 = gridRes * 0.5;\n\tfloat r11 = gridRes * 0.5;\n\tfloat r12 = gridRes * 0.5;\n\tfloat r13 = gridRes * 0.5;\n\tfloat r14 = grid", "\n\tfloat gridSize = 1.0 / gridRes;\n\tfloat gridOffset = 0.5 / gridRes;\n\tfloat gridOffset2 = 0.25 / gridRes;\n\tfloat gridOffset3 = 0.75 / gridRes;\n\tfloat gridOffset4 = 0.25 / gridRes;\n\tfloat gridOffset5 = 0.75 / gridRes;\n\tfloat gridOffset6 = 0.5 / gridRes;\n\tfloat gridOffset7 = 0.25 / gridRes;\n\tfloat gridOffset8 = 0.75 / gridRes;\n\tfloat gridOffset9 = 0.5 / gridRes;\n\tfloat gridOffset10 = 0.25 / gridRes;\n\tfloat gridOffset11 = 0.75 / gridRes;\n\tfloat gridOffset12 = 0.5 / gridRes;\n\tfloat gridOffset13 = 0.25 / gridRes;\n\tfloat gridOffset14 = 0.75 / gridRes;\n\tfloat gridOffset15 = 0.5 / gridRes;\n\tfloat gridOffset16 = 0.25 / gridRes;\n\tfloat gridOffset17 = 0.75 / gridRes;\n\tfloat gridOffset18 = 0.5 / gridRes;\n\tfloat gridOffset19 = 0.25 / gridRes;\n\tfloat gridOffset20 = 0.75 / gridRes;\n\tfloat gridOffset21 = 0.5 / gridRes;\n\tfloat gridOffset22 = 0.25 / gridRes;\n\tfloat gridOffset23 = 0.75 / gridRes;\n\tfloat gridOffset24 = 0.5 / gridRes;\n\tfloat gridOffset25 = 0.25 / gridRes;\n\tfloat gridOffset26 = 0.75 / gridRes;\n\tfloat gridOffset27 = 0.5 / gridRes;\n\tfloat gridOffset28 = 0.25 / gridRes;\n\tfloat gridOffset29 = 0.75 / gridRes;\n\tfloat gridOffset30 = 0.5 / gridRes;\n\tfloat gridOffset31 =", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat", "\n\treturn vec3(\n\t\t(t < 0.16666666666666666)? 0.0 :\n\t\t(t < 0.3333333333333333)? 1.0 * (t - 0.16666666666666666) / 0.16666666666666666 :\n\t\t(t < 0.5)? 1.0 :\n\t\t(t < 0.6666666666666666)? 1.0 - (t - 0.5) / 0.16666666666666666 :\n\t\t(t < 0.8333333333333333)? 0.0 :\n\t\t(t < 1.0)? 0.0 + (t - 0.8333333333333333) / 0.16666666666666666 : 0.0\n\t);\n}\n\n// makes Hot colormap with polynimal 6\nvec", "\n\treturn v * cos(a.x) + cross(a, v) * sin(a.x) + cross(cross(a, v), a) * (1.0 - cos(a.x));\n}\n\n// returns the color of a pixel\nvec", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\treturn abs(p.x) + abs(p.y) + abs(p.x + p.y);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat", "\n\tvec2 p = uv * 2.0 - 1.0;\n\tvec2 q = vec2(p.x, -p.y);\n\tvec2 r = vec2(-p.x, -p.y);\n\tvec2 s = vec2(-p.x, p.y);\n\tvec2 t = vec2(p.x, p.y);\n\tvec2 u = vec2(0.0, 1.0);\n\tvec2 v = vec2(0.0, -1.0);\n\tvec2 w = vec2(1.0, 0.0);\n\tvec2 x = vec2(-1.0, 0.0);\n\tvec2 y = vec2(0.0, 0.0);\n\tvec2 z = vec2(0.0, 0.0);\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(0.0, 0.0);\n\tvec2 c = vec2(0.0, 0.0);\n\tvec2 d = vec2(0.0, 0.0);\n\tvec2 e = vec2(0.0, 0.0);\n\tvec2 f = vec2(0.0, 0.0);\n\tvec2 g = vec2(0.0, 0.0);\n\tvec2 h = vec2(0.0, 0.0);\n\tvec2 i = vec2(0.0, 0.0);\n\tvec2 j = vec2(0.0, 0.0);\n\tvec2 k = vec2(0.0, 0.0);\n\tvec2 l = vec2(0.0, 0.0);\n\tvec2 m = vec2(0.0, 0.0);\n\tvec2 n = vec2(0.0, 0.0);\n\tvec2 o = vec2(0.0, 0.0);\n\tvec2 p = vec2(0.0, 0.0);\n\tvec2 q = vec2(0.0, 0.0);\n\tvec2 r = vec2(0", "\n\tfloat p = pow(t, 6.0);\n\treturn vec3(p, 1.0 - p, 1.0 - p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n\treturn (x + 1) / 2;\n}\n\n//returns a random float between -1 and 1\nfloat", "\n    float res = 1.0 / gridRes;\n    float cellSize = 1.0 / gridRes;\n    float cellSize2 = cellSize * 0.5;\n    float cellSize3 = cellSize * 0.33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float t = time * 0.01;\n    float s = sin(t);\n    float c = cos(t);\n    float a = 0.0;\n    float b = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float a", "\n\tvec2 dir = normalize(point);\n\tfloat dist = length(point);\n\tfloat angle = atan(dir.y, dir.x);\n\tfloat speed = 1.0 + 0.5 * sin(time * 0.5);\n\tfloat radius2 = radius * speed;\n\tfloat radius3 = radius2 * speed;\n\tfloat radius4 = radius3 * speed;\n\tfloat radius5 = radius4 * speed;\n\tfloat radius6 = radius5 * speed;\n\tfloat radius7 = radius6 * speed;\n\tfloat radius8 = radius7 * speed;\n\tfloat radius9 = radius8 * speed;\n\tfloat radius10 = radius9 * speed;\n\tfloat radius11 = radius10 * speed;\n\tfloat radius12 = radius11 * speed;\n\tfloat radius13 = radius12 * speed;\n\tfloat radius14 = radius13 * speed;\n\tfloat radius15 = radius14 * speed;\n\tfloat radius16 = radius15 * speed;\n\tfloat radius17 = radius16 * speed;\n\tfloat radius18 = radius17 * speed;\n\tfloat radius19 = radius18 * speed;\n\tfloat radius20 = radius19 * speed;\n\tfloat radius21 = radius20 * speed;\n\tfloat radius22 = radius21 * speed;\n\tfloat radius23 = radius22 * speed;\n\tfloat radius24 = radius23 * speed;\n\tfloat radius25 = radius24 * speed;\n\tfloat radius26 = radius25 * speed;\n\tfloat radius27 = radius26 * speed;\n\tfloat radius28 = radius27 * speed;\n\tfloat radius29 = radius28 * speed;\n\tfloat radius30 = radius29 * speed;\n\tfloat radius31 = radius30 * speed;\n\tfloat radius32 = radius31 * speed;\n\tfloat radius33 = radius32 * speed;\n\tfloat radius34 = radius33 * speed;\n\tfloat radius35 = radius34 * speed;\n\tfloat radius36 = radius35 * speed;\n\tfloat radius37 = radius36 * speed;\n\tfloat radius", "\n\treturn vec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n\tvec2 d1 = p - p1;\n\tvec2 d2 = p2 - p1;\n\tfloat t = dot(d1, d2) / dot(d2, d2);\n\tt = clamp(t, 0.0, 1.0);\n\treturn length(d1 - d2 * t);\n}\n\n// Computes the signed distance from a triangle\nfloat", "\n    float d = 0.0;\n    float l = length(v);\n    if (l > 0.0) {\n        d = dot(v, p - arrowTileCenterCoord(p)) / l;\n    }\n    return d;\n}\n\n// Returns the color of the arrow at the given position\nvec", "\n\treturn (x + 1.0) / 2.0;\n}\n\n//returns a random float between 0 and 1\nfloat", "\n\tvec2 flow = vec2(0.0);\n\tfloat dist = distance(point, vec2(0.5));\n\tif (dist < 0.5)\n\t{\n\t\tfloat angle = atan(point.y, point.x);\n\t\tfloat angle2 = angle + offset;\n\t\tfloat angle3 = angle2 + spread;\n\t\tfloat angle4 = angle2 - spread;\n\t\tfloat angle5 = angle4 + spread;\n\t\tfloat angle6 = angle4 - spread;\n\t\tfloat angle7 = angle6 + spread;\n\t\tfloat angle8 = angle6 - spread;\n\t\tfloat angle9 = angle8 + spread;\n\t\tfloat angle10 = angle8 - spread;\n\t\tfloat angle11 = angle10 + spread;\n\t\tfloat angle12 = angle10 - spread;\n\t\tfloat angle13 = angle12 + spread;\n\t\tfloat angle14 = angle12 - spread;\n\t\tfloat angle15 = angle14 + spread;\n\t\tfloat angle16 = angle14 - spread;\n\t\tfloat angle17 = angle16 + spread;\n\t\tfloat angle18 = angle16 - spread;\n\t\tfloat angle19 = angle18 + spread;\n\t\tfloat angle20 = angle18 - spread;\n\t\tfloat angle21 = angle20 + spread;\n\t\tfloat angle22 = angle20 - spread;\n\t\tfloat angle23 = angle22 + spread;\n\t\tfloat angle24 = angle22 - spread;\n\t\tfloat angle25 = angle24 + spread;\n\t\tfloat angle26 = angle24 - spread;\n\t\tfloat angle27 = angle26 + spread;\n\t\tfloat angle28 = angle26 - spread;\n\t\tfloat angle29 = angle28 + spread;\n\t\tfloat angle30 = angle28 - spread;\n\t\tfloat angle31 = angle30 + spread;\n\t\tfloat angle32 = angle30 - spread;\n\t\tfloat angle33 = angle32 + spread;\n\t\tfloat angle34 = angle32 - spread;\n\t\tfloat angle35 = angle34 + spread;\n\t\tfloat angle36 = angle34 - spread;\n\t\tfloat angle37 = angle36 + spread;\n\t\tfloat angle", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat", "\n\tfloat sd = sdCircle( p, vec2( 0.0, 0.0 ), 1.0 );\n\treturn sd;\n}\n\n// the SDF we want to repeat\nfloat", "\n\tfloat d = sdCircle( p, ra );\n\tfloat r = sdCircle( p, ra + sp * time );\n\treturn min( d, r );\n}\n\n// the point of this shader\nfloat", "\n\treturn max(max(abs(uvw.x), abs(uvw.y)), abs(uvw.z));\n}\n\n//edge distance of a Sphere\nfloat", "\n\tvec3 uvw2 = uvw * 2.0;\n\tvec3 uvw3 = uvw * 3.0;\n\tvec3 uvw4 = uvw * 4.0;\n\tvec3 uvw5 = uvw * 5.0;\n\tvec3 uvw6 = uvw * 6.0;\n\tvec3 uvw7 = uvw * 7.0;\n\tvec3 uvw8 = uvw * 8.0;\n\tvec3 uvw9 = uvw * 9.0;\n\tvec3 uvw10 = uvw * 10.0;\n\tvec3 uvw11 = uvw * 11.0;\n\tvec3 uvw12 = uvw * 12.0;\n\tvec3 uvw13 = uvw * 13.0;\n\tvec3 uvw14 = uvw * 14.0;\n\tvec3 uvw15 = uvw * 15.0;\n\tvec3 uvw16 = uvw * 16.0;\n\tvec3 uvw17 = uvw * 17.0;\n\tvec3 uvw18 = uvw * 18.0;\n\tvec3 uvw19 = uvw * 19.0;\n\tvec3 uvw20 = uvw * 20.0;\n\tvec3 uvw21 = uvw * 21.0;\n\tvec3 uvw22 = uvw * 22.0;\n\tvec3 uvw23 = uvw * 23.0;\n\tvec3 uvw24 = uvw * 24.0;\n\tvec3 uvw25 = uvw * 25.0;\n\tvec3 uvw26 = uvw * 26.0;\n\tvec3 uvw27 = uvw * 27.0;\n\tvec3 uvw28 = uvw * 28.0;\n\tvec3 uvw29 = uvw * 29.0;\n\tvec3 uvw30 = uvw * 30.0;\n\tvec3 uvw", "\n    vec3 cell = floor(uvw * gridRes) + offset;\n    vec3 f = fract(uvw * gridRes);\n    vec3 c = step(f, vec3(0.5));\n    vec3 o = step(vec3(0.5) - f, vec3(0.5));\n    return vec4(mix(mix(c.x, o.x, f.x), mix(c.y, o.y, f.y), mix(c.z, o.z, f.z)), 0.0);\n}\n\n// returns the cell index of the cell containing the point\nvec", "\n\treturn mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat", "\n\treturn vec3(1.0, 1.0, 1.0) * (1.0 - t) + vec3(0.0, 0.0, 1.0) * t;\n}\n\n// makes spring colormap with polynimal 6\nvec", "\n\tvec2 st = uv * 2.0 - 1.0;\n\tvec2 p = abs(st);\n\tvec2 f = fract(st);\n\tvec2 i = step(p, vec2(0.5));\n\tvec2 r = step(vec2(0.25), p);\n\tvec2 c = step(vec2(0.75), p);\n\tvec2 o = 1.0 - i - r - c;\n\tvec2 v = i * vec2(0.0, 0.0) + r * vec2(0.5, 0.0) + c * vec2(0.0, 0.5) + o * vec2(0.5, 0.5);\n\treturn vec3(v, 0.0);\n}\n\n// simple hexagonal Tiling\nvec", "\n    vec2 p = uv * 2.0 - 1.0;\n    vec2 q = abs(p);\n    vec2 r = max(q, vec2(0.0));\n    vec2 s = min(q, vec2(0.0));\n    vec2 t = max(r, s);\n    vec2 u = min(r, s);\n    vec2 v = max(u, vec2(0.0));\n    vec2 w = min(u, vec2(0.0));\n    vec2 x = max(w, vec2(0.0));\n    vec2 y = min(w, vec2(0.0));\n    vec2 z = max(y, vec2(0.0));\n    vec2 a = min(y, vec2(0.0));\n    vec2 b = max(a, vec2(0.0));\n    vec2 c = min(a, vec2(0.0));\n    vec2 d = max(c, vec2(0.0));\n    vec2 e = min(c, vec2(0.0));\n    vec2 f = max(e, vec2(0.0));\n    vec2 g = min(e, vec2(0.0));\n    vec2 h = max(g, vec2(0.0));\n    vec2 i = min(g, vec2(0.0));\n    vec2 j = max(i, vec2(0.0));\n    vec2 k = min(i, vec2(0.0));\n    vec2 l = max(k, vec2(0.0));\n    vec2 m = min(k, vec2(0.0));\n    vec2 n = max(m, vec2(0.0));\n    vec2 o = min(m, vec2(0.0));\n    vec2 p = max(o, vec2(0.0));\n    vec2 q = min(o, vec2(0.0));\n    vec2 r = max(q, vec2(0.0));\n    vec2 s = min(q, vec2(0.0));\n    vec2 t = max(s, vec2(0.0));\n    vec2 u = min(s, vec2(0.0));\n    vec2 v = max(u, vec2(0.0));", "\n    float gridSize = 1.0 / gridRes;\n    vec2 gridPos = floor(uv * gridRes) / gridRes;\n    vec2 gridPos2 = fract(uv * gridRes) / gridRes;\n    vec2 gridPos3 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos4 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos5 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos6 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos7 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos8 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos9 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos10 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos11 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos12 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos13 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos14 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos15 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos16 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos17 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos18 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos19 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos20 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos21 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos22 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos23 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos24 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos25 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos26 = fract", "\n    float gridSize = 1.0 / gridRes;\n    float gridX = floor(uv.x / gridSize);\n    float gridY = floor(uv.y / gridSize);\n    float gridXFrac = fract(uv.x / gridSize);\n    float gridYFrac = fract(uv.y / gridSize);\n    float gridXFrac2 = fract(gridXFrac * 2.0);\n    float gridYFrac2 = fract(gridYFrac * 2.0);\n    float gridXFrac2Half = fract(gridXFrac2 * 0.5);\n    float gridYFrac2Half = fract(gridYFrac2 * 0.5);\n    float gridXFrac2Half2 = fract(gridXFrac2Half * 2.0);\n    float gridYFrac2Half2 = fract(gridYFrac2Half * 2.0);\n    float gridXFrac2Half2Half = fract(gridXFrac2Half2 * 0.5);\n    float gridYFrac2Half2Half = fract(gridYFrac2Half2 * 0.5);\n    float gridXFrac2Half2Half2 = fract(gridXFrac2Half2Half * 2.0);\n    float gridYFrac2Half2Half2 = fract(gridYFrac2Half2Half * 2.0);\n    float gridXFrac2Half2Half2Half = fract(gridXFrac2Half2Half2 * 0.5);\n    float gridYFrac2Half2Half2Half = fract(gridYFrac2Half2Half2 * 0.5);\n    float gridXFrac2Half2Half2Half2 = fract(gridXFrac2Half2Half2Half * 2.0);\n    float gridYFrac2Half2Half2Half2 = fract(gridYFrac2Half2Half2Half * 2.0);\n    float gridXFrac2Half2Half2Half2Half = fract(gridXFrac2Half2Half2Half2 * 0.5);\n    float gridYFrac2Half2Half2Half2Half = fract(gridYFrac2Half2Half2Half2 * 0.5);\n    float gridXFrac2Half2Half2Half2Half2 = fract(gridXFrac2Half", "\n    float cellSize = 1.0 / gridRes;\n    float cellSize2 = cellSize * 0.5;\n    float cellSize4 = cellSize2 * 0.5;\n    float cellSize8 = cellSize4 * 0.5;\n    float cellSize16 = cellSize8 * 0.5;\n    float cellSize32 = cellSize16 * 0.5;\n    float cellSize64 = cellSize32 * 0.5;\n    float cellSize128 = cellSize64 * 0.5;\n    float cellSize256 = cellSize128 * 0.5;\n    float cellSize512 = cellSize256 * 0.5;\n    float cellSize1024 = cellSize512 * 0.5;\n    float cellSize2048 = cellSize1024 * 0.5;\n    float cellSize4096 = cellSize2048 * 0.5;\n    float cellSize8192 = cellSize4096 * 0.5;\n    float cellSize16384 = cellSize8192 * 0.5;\n    float cellSize32768 = cellSize16384 * 0.5;\n    float cellSize65536 = cellSize32768 * 0.5;\n    float cellSize131072 = cellSize65536 * 0.5;\n    float cellSize262144 = cellSize131072 * 0.5;\n    float cellSize524288 = cellSize262144 * 0.5;\n    float cellSize1048576 = cellSize524288 * 0.5;\n    float cellSize2097152 = cellSize1048576 * 0.5;\n    float cellSize4194304 = cellSize2097152 * 0.5;\n    float cellSize8388608 = cellSize4194304 * 0.5;\n    float cellSize16777216 = cellSize83", "\n    float t = time * 0.01;\n    float r = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float a = ", "\n\tvec2 g = ddx * ddy;\n\tvec2 h = ddx * ddy;\n\tvec2 i = ddx * ddy;\n\tvec2 j = ddx * ddy;\n\tvec2 k = ddx * ddy;\n\tvec2 l = ddx * ddy;\n\tvec2 m = ddx * ddy;\n\tvec2 n = ddx * ddy;\n\tvec2 o = ddx * ddy;\n\tvec2 p = ddx * ddy;\n\tvec2 q = ddx * ddy;\n\tvec2 r = ddx * ddy;\n\tvec2 s = ddx * ddy;\n\tvec2 t = ddx * ddy;\n\tvec2 u = ddx * ddy;\n\tvec2 v = ddx * ddy;\n\tvec2 w = ddx * ddy;\n\tvec2 x = ddx * ddy;\n\tvec2 y = ddx * ddy;\n\tvec2 z = ddx * ddy;\n\tvec2 A = ddx * ddy;\n\tvec2 B = ddx * ddy;\n\tvec2 C = ddx * ddy;\n\tvec2 D = ddx * ddy;\n\tvec2 E = ddx * ddy;\n\tvec2 F = ddx * ddy;\n\tvec2 G = ddx * ddy;\n\tvec2 H = ddx * ddy;\n\tvec2 I = ddx * ddy;\n\tvec2 J = ddx * ddy;\n\tvec2 K = ddx * ddy;\n\tvec2 L = ddx * ddy;\n\tvec2 M = ddx * ddy;\n\tvec2 N = ddx * ddy;\n\tvec2 O = ddx * ddy;\n\tvec2 P = ddx * ddy;\n\tvec2 Q = ddx * ddy;\n\tvec2 R = ddx * ddy;\n\tvec2 S = ddx * ddy;\n\tvec2 T = ddx * ddy;\n\tvec2 U = ddx * ddy;\n\tvec2 V = ddx * ddy;\n\tvec2 W = ddx", "\n    p = abs(p);\n    float d = length(p - vec2(r, 0.0));\n    float a = length(p - vec2(r, r * 0.5));\n    float b = length(p - vec2(r, r * 0.5 + r * 0.8660254037844386));\n    float c = length(p - vec2(r, r * 0.5 - r * 0.8660254037844386));\n    return min(d, min(a, min(b, c)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = floor(p);\n    vec2 q = p + vec2(0.5, 0.5);\n    vec2 r = mod(p, 2.0);\n    vec2 s = step(vec2(0.5, 0.5), r);\n    vec2 t = step(vec2(1.5, 1.5), r);\n    vec2 u = step(vec2(1.5, 0.5), r);\n    vec2 v = step(vec2(0.5, 1.5), r);\n    vec2 w = step(vec2(0.5, 0.5), r);\n    vec2 x = step(vec2(1.5, 1.5), r);\n    vec2 y = step(vec2(1.5, 0.5), r);\n    vec2 z = step(vec2(0.5, 1.5), r);\n    vec2 A = step(vec2(0.5, 0.5), r);\n    vec2 B = step(vec2(1.5, 1.5), r);\n    vec2 C = step(vec2(1.5, 0.5), r);\n    vec2 D = step(vec2(0.5, 1.5), r);\n    vec2 E = step(vec2(0.5, 0.5), r);\n    vec2 F = step(vec2(1.5, 1.5), r);\n    vec2 G = step(vec2(1.5, 0.5), r);\n    vec2 H = step(vec2(0.5, 1.5), r);\n    vec2 I = step(vec2(0.5, 0.5), r);\n    vec2 J = step(vec2(1.5, 1.5), r);\n    vec2 K = step(vec2(1.5, 0.5), r);\n    vec2 L = step(vec2(0.5, 1.5), r);\n    vec2 M = step(vec2(0.5, 0.5), r);\n    vec2 N = step(vec2(1.5, 1.5), r);\n    vec2 O = step(vec2(", "\n\treturn sin( x * 10.0 ) * 0.5 + 0.5;\n}\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat", "\n    return pow(t, vec3(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat", "\n\tfloat f = 0.0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfloat a = 1.0 + 0.125 * cos(16.0 * p.x + i);\n\t\tfloat b = 1.0 + 0.125 * cos(16.0 * p.y + i);\n\t\tf += 0.25 * a * b;\n\t}\n\treturn f;\n}\n\n// Multiscale truchet\nfloat", "\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p0;\n\tvec2 s1 = p - p0;\n\tvec2 s2 = p - p1;\n\tvec2 s3 = p - p2;\n\tfloat dot00 = dot( e0, e0 );\n\tfloat dot01 = dot( e0, e1 );\n\tfloat dot02 = dot( e0, s1 );\n\tfloat dot11 = dot( e1, e1 );\n\tfloat dot12 = dot( e1, s2 );\n\tfloat dot22 = dot( s1, s1 );\n\tfloat invDenom = 1.0 / ( dot00 * dot11 - dot01 * dot01 );\n\tfloat u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\tfloat v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\tfloat w = 1.0 - u - v;\n\tfloat d = abs( u ) * dot00 + abs( v ) * dot01 + abs( w ) * dot02;\n\treturn d;\n}\n\n// signed distance to a 2D circle\nfloat", "\n    float r = sph.w;\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r8 = r4*r4;\n    float r16 = r8*r8;\n    float r32 = r16*r16;\n    float r64 = r32*r32;\n    float r128 = r64*r64;\n    float r256 = r128*r128;\n    float r512 = r256*r256;\n    float r1024 = r512*r512;\n    float r2048 = r1024*r1024;\n    float r4096 = r2048*r2048;\n    float r8192 = r4096*r4096;\n    float r16384 = r8192*r8192;\n    float r32768 = r16384*r16384;\n    float r65536 = r32768*r32768;\n    float r131072 = r65536*r65536;\n    float r262144 = r131072*r131072;\n    float r524288 = r262144*r262144;\n    float r1048576 = r524288*r524288;\n    float r2097152 = r1048576*r1048576;\n    float r4194304 = r2097152*r2097152;\n    float r8388608 = r4194304*r4194304;\n    float r16777216 = r8388608*r8388608;\n    float r33554432 = r16777", "\n    float d = length(p) - w;\n    return clamp(d, 0.0, r) - d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n\treturn abs( p.x * p.y ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat", "\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, 1.0/p.y)), sdCircle(vec2(1.0/p.x, p.y)), step(p.x, p.y) );\n}\n\n// distance to y=x\nfloat", "\n\tfloat h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n\treturn mix(b, a, h) - k * h * (1.0f - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n    return abs(a) - k * sign(a);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat", "\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n\tvec2 p = pos;\n\tvec2 f = sdBezier( p, A, B, C );\n\tvec2 df = sdBezierDerivative( p, A, B, C );\n\treturn vec3( f.x, df.x, df.y );\n}\n\n//\n// Bezier curve\n//\n\n// Bezier curve\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec", "\n\tvec2 p = pos * vec2( wi, he );\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat f = x*x + y*y;\n\tfloat df = 2.0 * x;\n\tfloat ddf = 2.0;\n\tfloat dddf = 0.0;\n\tfloat ddddf = 0.0;\n\tfloat dddddf = 0.0;\n\tfloat ddddddf = 0.0;\n\tfloat dddddddf = 0.0;\n\tfloat ddddddddf = 0.0;\n\tfloat dddddddddf = 0.0;\n\tfloat ddddddddddf = 0.0;\n\tfloat dddddddddddf = 0.0;\n\tfloat ddddddddddddf = 0.0;\n\tfloat dddddddddddddf = 0.0;\n\tfloat ddddddddddddddf = 0.0;\n\tfloat dddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddddd", "\n\tvec2 p = pos - vec2(0.5, 0.5);\n\tfloat d = dot(p, p) - k;\n\treturn vec3(d, 2.0 * p.x, 2.0 * p.y);\n}\n\n//\n// Parabola\n//\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 q = vec2(length(p)-d, atan(p.y,p.x));\n\tfloat r = length(q);\n\tfloat a = atan(q.y,q.x);\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat x = ra*r*c;\n\tfloat y = ra*r*s;\n\tfloat z = rb*r;\n\tvec3 p1 = vec3(x,y,z);\n\tvec3 p2 = vec3(x,y,z);\n\tp2.yz = normalize(p2.yz);\n\treturn p1;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg3(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg4(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg5(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v", "\n\treturn ivec3(\n\t\t(v.x * 1103515245 + 12345) & 0x7fffffff,\n\t\t(v.y * 1103515245 + 12345) & 0x7fffffff,\n\t\t(v.z * 1103515245 + 12345) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed)\n{\n\treturn ivec3(\n\t\t(v.x * 1103515245 + seed.x) & 0x7fffffff,\n\t\t(v.y * 1103515245 + seed.y) & 0x7fffffff,\n\t\t(v.z * 1103515245 + seed.z) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed, ivec3 offset)\n{\n\treturn ivec3(\n\t\t(v.x * 1103515245 + seed.x + offset.x) & 0x7fffffff,\n\t\t(v.y * 1103515245 + seed.y + offset.y) & 0x7fffffff,\n\t\t(v.z * 1103515245 + seed.z + offset.z) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed, ivec3 offset, ivec3 mul)\n{\n\treturn ivec", "\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tfloat ab2 = dot(ab, ab);\n\tfloat ac2 = dot(ac, ac);\n\tfloat bc2 = dot(bc, bc);\n\tfloat abc = dot(ab, ac);\n\tfloat bca = dot(bc, ac);\n\tfloat bac = dot(bc, ab);\n\tfloat a2 = dot(p - a, p - a);\n\tfloat b2 = dot(p - b, p - b);\n\tfloat c2 = dot(p - c, p - c);\n\tfloat a3 = a2 * a2;\n\tfloat b3 = b2 * b2;\n\tfloat c3 = c2 * c2;\n\tfloat a1 = 1.0 / a3;\n\tfloat b1 = 1.0 / b3;\n\tfloat c1 = 1.0 / c3;\n\tfloat a0 = 3.0 * a1;\n\tfloat b0 = 3.0 * b1;\n\tfloat c0 = 3.0 * c1;\n\tfloat ab0 = a0 * ab2;\n\tfloat ac0 = a0 * ac2;\n\tfloat bc0 = b0 * bc2;\n\tfloat abc0 = 6.0 * abc * a1;\n\tfloat bca0 = 6.0 * bca * b1;\n\tfloat bac0 = 6.0 * bac * c1;\n\tfloat a234 = a0 * a2 * a3;\n\tfloat b234 = b0 * b2 * b3;\n\tfloat c234 = c0 * c2 * c3;\n\tfloat a123 = a0 * a1 * a2;\n\tfloat b123 = b0 * b1 * b2;\n\tfloat c123 = c0 * c1 * c2;\n\tfloat a12 = a0 * a1;\n\tfloat b12 = b", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\nfloat", "\n    vec3 n = normalize( cross( rd, s.yzx ) );\n    vec3 p = ro + rd * ( s.x / dot( n, rd ) );\n    vec3 d = abs( p ) - s.yzx;\n    vec3 t = max( d, 0.0 );\n    return vec4( length( t ), n, t );\n}\n\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec", "\n\tfloat ret = frac_mad_i24_m12_f32(a, b, x);\n\tret_n = floor(ret);\n\treturn ret;\n}\n\n// https://www.shadertoy.com/view/4sfGzS\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n\tfloat h = clamp( dot(a,b), 0.0, 1.0 );\n\tfloat d = acos( h ) - k;\n\tvec3 m = -b + 2.0 * a * h;\n\treturn normalize( m + d * a );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n\treturn dot(p-ab,p-ab) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat", "\n\treturn a+b;\n}\n\nfloat", "\n\treturn pHyperbola( p, ab, s1, s2 );\n}\n\n//for highlighting individual solutions\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba);\n\tfloat e = length(pa - h * ba);\n\tfloat f = length(ba);\n\tfloat r = ra;\n\tif (h < 0.0) r = rb;\n\telse if (h > f) r = ra;\n\tfloat d = length(p - (a + h * ba / f));\n\treturn vec4(d - r, h, a + h * ba / f);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat", "\n\tvec3 d = p - cen;\n\treturn length(d) - rad;\n}\n\nfloat", "\n\tvec3 n = vec3( 0.0 );\n\tvec3 eps = vec3( 0.0001 );\n\tvec3 eps2 = vec3( 0.00001 );\n\tvec3 eps3 = vec3( 0.000001 );\n\tvec3 eps4 = vec3( 0.0000001 );\n\tvec3 eps5 = vec3( 0.00000001 );\n\tvec3 eps6 = vec3( 0.000000001 );\n\tvec3 eps7 = vec3( 0.0000000001 );\n\tvec3 eps8 = vec3( 0.00000000001 );\n\tvec3 eps9 = vec3( 0.000000000001 );\n\tvec3 eps10 = vec3( 0.0000000000001 );\n\tvec3 eps11 = vec3( 0.00000000000001 );\n\tvec3 eps12 = vec3( 0.000000000000001 );\n\tvec3 eps13 = vec3( 0.0000000000000001 );\n\tvec3 eps14 = vec3( 0.00000000000000001 );\n\tvec3 eps15 = vec3( 0.000000000000000001 );\n\tvec3 eps16 = vec3( 0.0000000000000000001 );\n\tvec3 eps17 = vec3( 0.00000000000000000001 );\n\tvec3 eps18 = vec3( 0.000000000000000000001 );\n\tvec3 eps19 = vec3( 0", "\n\tfloat shadow = 1.0;\n\tfloat bias = 0.0001;\n\tfloat step = 0.001;\n\tfloat maxDist = 100.0;\n\tfloat dist = 0.0;\n\tfloat t = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.", "\n\tfloat a = ra * ra;\n\tfloat b = rb * rb;\n\tfloat h = he * he;\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\tfloat x3 = x2 * x;\n\tfloat y3 = y2 * y;\n\tfloat x4 = x2 * x2;\n\tfloat y4 = y2 * y2;\n\tfloat x5 = x2 * x3;\n\tfloat y5 = y2 * y3;\n\tfloat x6 = x2 * x4;\n\tfloat y6 = y2 * y4;\n\tfloat x7 = x2 * x5;\n\tfloat y7 = y2 * y5;\n\tfloat x8 = x2 * x6;\n\tfloat y8 = y2 * y6;\n\tfloat x9 = x2 * x7;\n\tfloat y9 = y2 * y7;\n\tfloat x10 = x2 * x8;\n\tfloat y10 = y2 * y8;\n\tfloat x11 = x2 * x9;\n\tfloat y11 = y2 * y9;\n\tfloat x12 = x2 * x10;\n\tfloat y12 = y2 * y10;\n\tfloat x13 = x2 * x11;\n\tfloat y13 = y2 * y11;\n\tfloat x14 = x2 * x12;\n\tfloat y14 = y2 * y12;\n\tfloat x15 = x2 * x13;\n\tfloat y15 = y2 * y13;\n\tfloat x16 = x2 * x14;\n\tfloat y16 = y2 * y14;\n\tfloat x17 = x2 * x15;\n\tfloat y17 = y2 * y15;\n\tfloat x18 = x2 * x16;\n\tfloat y18 = y2 * y16;\n\tfloat x19 = x2 * x17;\n\tfloat y19 = y2 * y17;\n\tfloat x2", "\n    vec3 q = p - vec3( 0.0, 0.0, 0.0 );\n    float d = length( q );\n    float r = sqrt( max( 0.0, 1.0 - d * d / ( ra * ra ) ) );\n    return vec4( r, 0.0, 0.0, 1.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat", " return v.x*v.x + v.y*v.y; }\nfloat", "\n\tvec2 d = abs( p - minCorner ) - ( maxCorner - minCorner );\n\treturn max( d.x, d.y ) * max( d.x, d.y );\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = vec3(0.0);\n\tvec3 position = vec3(0.0);\n\tvec3 light = vec3(0.0);\n\tvec3 view = vec3(0.0);\n\tvec3 lightDir = vec3(0.0);\n\tvec3 lightColor = vec3(0.0);\n\tvec3 lightPos = vec3(0.0);\n\tvec3 lightAttenuation = vec3(0.0);\n\tvec3 lightDir2 = vec3(0.0);\n\tvec3 lightColor2 = vec3(0.0);\n\tvec3 lightPos2 = vec3(0.0);\n\tvec3 lightAttenuation2 = vec3(0.0);\n\tvec3 lightDir3 = vec3(0.0);\n\tvec3 lightColor3 = vec3(0.0);\n\tvec3 lightPos3 = vec3(0.0);\n\tvec3 lightAttenuation3 = vec3(0.0);\n\tvec3 lightDir4 = vec3(0.0);\n\tvec3 lightColor4 = vec3(0.0);\n\tvec3 lightPos4 = vec3(0.0);\n\tvec3 lightAttenuation4 = vec3(0.0);\n\tvec3 lightDir5 = vec3(0.0);\n\tvec3 lightColor5 = vec3(0.0);\n\tvec3 lightPos5 = vec3(0.0);\n\tvec3 lightAttenuation5 = vec3(0.0);\n\tvec3 lightDir6 = vec3(0.0);\n\tvec3 lightColor6 = vec3(0.0);\n\tvec3 lightPos6 = vec3(0.0);\n\tvec3 lightAttenuation6 = vec3(0.0);\n\tvec3 lightDir7 = vec3(0.0);\n\tvec3 lightColor7 = vec3(0.0);\n\tvec3 lightPos7 = vec3(0.0);\n\tvec3 lightAttenuation7 = vec3(0.0);\n\tvec3 lightDir8 = vec3(0.0);\n\tvec3 lightColor8 = vec", "\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\treturn normalize(vec3(xy, -1.0));\n}\n\n// Camera perspective based on [0..1] viewport\nvec", "\n\tvec3 t = cross(q.xyz, v);\n\tt += q.w * v;\n\tt += cross(q.xyz, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec", "\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat", "\n\tfloat h = 1.0 - abs( m.x );\n\tfloat k = 1.0 - abs( m.y );\n\tfloat l = max( h, k );\n\tfloat s = clamp( l, 0.0, 1.0 );\n\tfloat t = clamp( l, 0.0, 1.0 );\n\tfloat u = clamp( l, 0.0, 1.0 );\n\tfloat v = clamp( l, 0.0, 1.0 );\n\tfloat w = clamp( l, 0.0, 1.0 );\n\tfloat x = clamp( l, 0.0, 1.0 );\n\tfloat y = clamp( l, 0.0, 1.0 );\n\tfloat z = clamp( l, 0.0, 1.0 );\n\tfloat A = clamp( l, 0.0, 1.0 );\n\tfloat B = clamp( l, 0.0, 1.0 );\n\tfloat C = clamp( l, 0.0, 1.0 );\n\tfloat D = clamp( l, 0.0, 1.0 );\n\tfloat E = clamp( l, 0.0, 1.0 );\n\tfloat F = clamp( l, 0.0, 1.0 );\n\tfloat G = clamp( l, 0.0, 1.0 );\n\tfloat H = clamp( l, 0.0, 1.0 );\n\tfloat I = clamp( l, 0.0, 1.0 );\n\tfloat J = clamp( l, 0.0, 1.0 );\n\tfloat K = clamp( l, 0.0, 1.0 );\n\tfloat L = clamp( l, 0.0, 1.0 );\n\tfloat M = clamp( l, 0.0, 1.0 );\n\tfloat N = clamp( l, 0.0, 1.0 );\n\tfloat O = clamp( l, 0.0, 1.0 );\n\tfloat P = clamp( l, 0.0, 1.0 );\n\tfloat Q = clamp( l, 0.0", "\n\tfloat a = dot( rd, rd );\n\tfloat b = 2.0 * dot( rd, ro );\n\tfloat c = dot( ro, ro ) - rad * rad;\n\tfloat d = b * b - 4.0 * a * c;\n\tif( d < 0.0 ) return;\n\tfloat s = sqrt( d );\n\tfloat t = -b - s;\n\tif( t > 0.0 )\n\t{\n\t\tt = -b + s;\n\t\tif( t < 0.0 ) return;\n\t}\n\tt /= 2.0 * a;\n\tp1 = vec4( ro + rd * t, 0.0, 0.0 );\n\tp2 = vec4( ro + rd * t, 1.0, 0.0 );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectLine( in vec2 ro, in vec2 rd, in vec2 a, in vec2 b, out vec4 p1, out vec4 p2 )\n{\n\tvec2 ab = b - a;\n\tvec2 ao = ro - a;\n\tfloat h = dot( rd, ab );\n\tfloat s = -dot( rd, ao );\n\tfloat t = dot( ao, ab );\n\tif( abs( h ) < 0.0001 )\n\t{\n\t\tif( s > 0.0 ) return;\n\t\tt /= h;\n\t\tif( t < 0.0 || t > 1.0 ) return;\n\t}\n\telse\n\t{\n\t\ts /= h;\n\t\tt /= h;\n\t\tif( s < 0.0 || s > 1.0 ) return;\n\t}\n\tp1 = vec4( ro + rd * t, 0.0, 0.0 );\n\tp2 = vec4( ro + rd * t, 1.0, 0.0 );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectRay( in vec2 ro, in vec2 rd, in vec2 a, in vec2 b, out vec4 p1, out vec4 p2 )", "\n    vec2 q = p - c;\n    float d = length(q);\n    float s = clamp(1.0 - d / r, 0.0, 1.0);\n    return vec3(s, q.x / d, q.y / d);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\nvec", "\nvec", "\n  return a1 * sin(b1 * x) + a2 * sin(b2 * x);\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat", "\n  float y = pow(abs(x), n);\n  return a * pow(y + b, 1.0 / n);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                uv = uv * 2.0 - 1.0;\n                vec3 P = vec3(127.1, 311.7, 541.3);\n                vec2 Pi = floor(P.xy);\n                vec2 Pf = fract(P.xy);\n                vec2 Pii = (Pi.x+Pi.y)*P.z;\n                vec2 Pif = Pf*P.z;\n                vec2 Piii = (Pi.x+Pi.y+Pif.x)*P.z;\n                vec2 Piff = Pf*Pif;\n                vec2 Pifff = Pf*Piff;\n                vec2 Piifff = (Pi.x+Piff.x)*Pifff;\n                vec2 Piiffff = (Pi.x+Pifff.x)*Pifff;\n                vec2 Piifffff = (Pi.x+Piifff.x)*Pifff;\n                vec2 Piiffffff = (Pi.x+Piiffff.x)*Pifff;\n                vec2 Piifffffff = (Pi.x+Piifffff.x)*Pifff;\n                vec2 Piiffffffff = (Pi.x+Piiffffff.x)*Pifff;\n                vec2 Piifffffffff = (Pi.x+Piifffffff.x)*Pifff;\n                vec2 Piiffffffffff = (Pi.x+Piiffffffff.x)*Pifff;\n                vec2 Piifffffffffff = (Pi.x+Piifffffffff.x)*Pifff;\n                vec2 Piiffffffffffff = (Pi.x+Piiffffffffff.x)*Pifff;\n                vec2 Piifffffffffffff = (Pi.x+Piifffffffffff.x)*Pifff;\n                vec2 Piiffffffffffffff = (Pi.x+Piiffffffffffff.x)*Pifff;\n                vec2 Piifffffffffffffff = (Pi.x+Piifffffffffffff.x)*Pifff;\n                vec2 Piiffffffffffffffff = (Pi.x+Piiffffffffffffff.x)*Pifff;\n                vec2 Piiffffffffffffffffe = (Pi.x+Piifffffffffffffff.x)*Pifff;\n                vec2 Piiffffffffffffffffee = (Pi.x+Piiffffffffffffffffe.", "\n\tvec3 color = vec3( 0.0 );\n\tfor( int i = 0; i < 6; i++ )\n\t{\n\t\tint i1 = ( i + 1 ) % 6;\n\t\tint i2 = ( i + 2 ) % 6;\n\t\tint i3 = ( i + 3 ) % 6;\n\t\tint i4 = ( i + 4 ) % 6;\n\t\tint i5 = ( i + 5 ) % 6;\n\t\tint i6 = ( i + 6 ) % 6;\n\t\tint i7 = ( i + 7 ) % 6;\n\t\tint i8 = ( i + 8 ) % 6;\n\t\tint i9 = ( i + 9 ) % 6;\n\t\tint i10 = ( i + 10 ) % 6;\n\t\tint i11 = ( i + 11 ) % 6;\n\t\tint i12 = ( i + 12 ) % 6;\n\t\tint i13 = ( i + 13 ) % 6;\n\t\tint i14 = ( i + 14 ) % 6;\n\t\tint i15 = ( i + 15 ) % 6;\n\t\tint i16 = ( i + 16 ) % 6;\n\t\tint i17 = ( i + 17 ) % 6;\n\t\tint i18 = ( i + 18 ) % 6;\n\t\tint i19 = ( i + 19 ) % 6;\n\t\tint i20 = ( i + 20 ) % 6;\n\t\tint i21 = ( i + 21 ) % 6;\n\t\tint i22 = ( i + 22 ) % 6;\n\t\tint i23 = ( i + 23 ) % 6;\n\t\tint i24 = ( i + 24 ) % 6;\n\t\tint i25 = ( i + 25 ) % 6;\n\t\tint i26 = ( i + 26 ) % 6;\n\t\tint i27 = ( i + 27 ) % 6;\n\t\tint i28 = ( i", "\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - 0.5;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat e = dot( pa, ba );\n\tfloat f = dot( pa, pa ) - e*e;\n\tfloat k = 1.0 - h2;\n\tfloat c = k*f - d2min;\n\tfloat t = e*k - h2*sqrt( max( c, 0.0 ) );\n\tfloat s = 1.0 - abs( e );\n\treturn vec2( sqrt( max( c, 0.0 ) ) - t, s );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n\tfloat d = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\t", "\n\tvec2 q = vec2( 0.0, 0.0 );\n\tq.x = sdCircle( p, vec2( 0.0, 0.0 ), 1.0 );\n\tq.y = sdCircle( p, vec2( 0.0, 0.0 ), 1.0 );\n\treturn min( q.x, q.y );\n}\n\n// correct inside, incorrect outside\nfloat", "\n\tvec2 q = vec2( 0.0, 0.0 );\n\tq.x = sdCircle( vec2( p.x, p.y ) );\n\tq.y = sdCircle( vec2( p.x, p.y ) );\n\treturn min( q.x, q.y );\n}\n\n// correct inside, incorrect outside\nfloat", "\n\tvec3 pattern = vec3( 0.0 );\n\tuv *= 2.0;\n\tuv -= 1.0;\n\tuv.x *= 0.5;\n\tuv.y *= 0.5;\n\tuv.x += 0.5;\n\tuv.y += 0.5;\n\tuv *= 10.0;\n\tuv = mod( uv, 2.0 );\n\tuv -= 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5;\n\tuv += 0.5;\n\tuv *= 2.0;\n\tuv += 1.0;\n\tuv *= 0.5", "\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat d1 = dot(ap, ab);\n\tfloat d2 = dot(ab, ab);\n\tfloat t = clamp( d1 / d2, 0.0, 1.0 );\n\tvec2 result = a + t * ab;\n\tfloat dist = distance(p, result);\n\tif (dist < th) {\n\t\treturn result;\n\t}\n\treturn vec2(0.0);\n}\n\n// Closest point on triangle\nvec", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - th;\n}\n\n// distance to triangle\nfloat", "\n\tvec2 d = abs(p) - b;\n\tvec2 q = clamp(d, 0.0, r);\n\treturn clamp(p, b - q, b + q);\n}\n\n// closest point on rounded box\nvec", "\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y,0.0),max(q.x,q.y)) - r;\n}\n\n// distance to rounded box\nfloat", "\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to plane\nfloat", "\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat", "\n\treturn fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nfloat", "\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat res = mix(mix(snoise(vec2(n+0.0,0.0)),snoise(vec2(n+1.0,0.0)),f.x),\n\t\t\t\t\tmix(snoise(vec2(n+57.0,0.0)),snoise(vec2(n+58.0,0.0)),f.x),f.y);\n\n\treturn res;\n}\n\n// A 3D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat", "\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tsum += amp * noise(x * freq);\n\t\tamp *= 0.5;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// 2D Perlin noise\nfloat", "\n\tfloat t = 0.5 + 0.5 * sin(0.16666666666666666666666666666667 * x.x + 0.123456789 * x.y);\n\tfloat s = 0.5 + 0.5 * sin(0.123456789 * x.x + 0.16666666666666666666666666666667 * x.y);\n\treturn t * s;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat", "\n    return x * y;\n}\n\nfloat", "\n\tp3 = fract(p3 *.1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat", "\n\tvec3  F3 = fract(cos(p) * C.xyz) - 0.5;\n\tvec3  s = step(F3, vec3(0.0));\n\tfloat t = min(s.x, min(s.y, s.z));\n\tvec3  h = F3 - t;\n\tvec3  u = h.x + h.y + h.z;\n\tfloat f = max(0.0, 1.0 - u);\n\treturn t * t * t * f * f;\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4dS3zN\nfloat", "\n    return fract(sin(x)*43758.5453123);\n}\n\n// 2D simplex noise\nfloat", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa,ba);\n\tfloat l = dot(ba,ba);\n\tfloat t = clamp( h / l, 0.0, 1.0 );\n\treturn length( pa - ba * t );\n}\n\n// for visualization purposes only\nfloat", "\n\tvec2 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y;\n}\n\n// This is the final form\nfloat", "\n    // Project the center of the disk onto the plane.\n    proj_center = proj_info.xy * center;\n\n    // Project the normal of the disk onto the plane.\n    vec3 proj_normal = proj_info.xy * normal;\n\n    // Project the radius of the disk onto the plane.\n    float proj_radius = proj_info.z * radius;\n\n    // Project the major axis of the disk onto the plane.\n    major = proj_info.xy * (center + proj_normal * proj_radius);\n\n    // Project the minor axis of the disk onto the plane.\n    minor = proj_info.xy * (center - proj_normal * proj_radius);\n}\n\n// Disk projection code (project_disk()) is by me and is CC0.\n// Currently, there's some float instability near grazing angles.\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor,\n    out vec2 major_tangent,\n    out vec2 minor_tangent\n){\n    // Project the center of the disk onto the plane.\n    proj_center = proj_info.xy * center;\n\n    // Project the normal of the disk onto the plane.\n    vec3 proj_normal = proj_info.xy * normal;\n\n    // Project the radius of the disk onto the plane.\n    float proj_radius = proj_info.z * radius;\n\n    // Project the major axis of the disk onto the plane.\n    major = proj_info.xy * (center + proj_normal * proj_radius);\n\n    // Project the minor axis of the disk onto the plane.\n    minor = proj_info.xy * (center - proj_normal * proj_radius);\n\n    // Project the major axis tangent of the disk onto the plane.\n    major_tangent = proj_info.xy * (center + proj_", "\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat q = 0.0;\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31", "\n\tvec3 a = p - v[0];\n\tvec3 b = p - v[1];\n\tvec3 c = p - v[2];\n\tvec3 d = p - v[3];\n\tvec3 n = normalize( cross( a, b ) + cross( b, c ) + cross( c, d ) + cross( d, a ) );\n\treturn n;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec", "\n    float t = t0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (scene.intersect(p, t))\n        {\n            return t;\n        }\n        t += 0.001;\n    }\n    return t1;\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat", "\n\tfloat ao = 0.0;\n\tfloat dist = 0.0;\n\tfloat step = 0.01;\n\tfloat maxDist = 0.05;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tdist += step;\n\t\tvec3 dir = nor * dist;\n\t\tvec3 p = pos + dir;\n\t\tfloat d = distance( p, vec3( 0.0 ) );\n\t\tif( d > maxDist )\n\t\t\tbreak;\n\t\tao += 1.0 - d;\n\t}\n\treturn ao / 10.0;\n}\n\nvoid main()\n{\n\tvec3 pos = vec3( 0.0 );\n\tvec3 nor = vec3( 0.0 );\n\tvec3 col = vec3( 0.0 );\n\tfloat ao = 0.0;\n\tfloat dist = 0.0;\n\tfloat step = 0.01;\n\tfloat maxDist = 0.05;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tdist += step;\n\t\tvec3 dir = nor * dist;\n\t\tvec3 p = pos + dir;\n\t\tfloat d = distance( p, vec3( 0.0 ) );\n\t\tif( d > maxDist )\n\t\t\tbreak;\n\t\tao += 1.0 - d;\n\t}\n\tao /= 10.0;\n\tcol = vec3( ao );\n\tgl_FragColor = vec4( col, 1.0 );\n}\n\n`;\n\nexport default class AOShader extends Shader {\n\tconstructor() {\n\t\tsuper(\n\t\t\t'AOShader',\n\t\t\tvertexShader,\n\t\t\tfragmentShader\n\t\t);\n\t}\n}\n/src/shaders/skybox.js\nimport Shader from '../shader';\n\nconst vertexShader = `\n\nvarying vec3 v_pos;\n\nvoid main()\n{\n\tv_pos = position;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n\n`;\n\nconst fragmentShader = `\n\nuniform samplerCube u_skybox;", "\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\tfloat t = 1 - c;\n\n\tvec3 axis_normalized = normalize(axis);\n\n\treturn mat3(\n\t\tt * axis_normalized.x * axis_normalized.x + c,\n\t\tt * axis_normalized.x * axis_normalized.y + s * axis_normalized.z,\n\t\tt * axis_normalized.x * axis_normalized.z - s * axis_normalized.y,\n\t\tt * axis_normalized.x * axis_normalized.y - s * axis_normalized.z,\n\t\tt * axis_normalized.y * axis_normalized.y + c,\n\t\tt * axis_normalized.y * axis_normalized.z + s * axis_normalized.x,\n\t\tt * axis_normalized.x * axis_normalized.z + s * axis_normalized.y,\n\t\tt * axis_normalized.y * axis_normalized.z - s * axis_normalized.x,\n\t\tt * axis_normalized.z * axis_normalized.z + c\n\t);\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat", "\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0));\n\treturn ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec", "\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat", "\n\tfloat a = p.x + p.y + p.z;\n\ta = (a + (a << 8)) & 0x00ff00ff;\n\ta = (a ^ (a >> 9)) & 0x0000ffff;\n\treturn (float)a / 65536.0f;\n}\n\n// Hash for 4d vectors\nfloat", "\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(grad3(n+0.0), grad3(n+1.0), f.x), grad3(n+57.0), f.y), grad3(n+113.0), f.z);\n}\n\n// 3D value noise\nfloat", "\n\tvec3 p0 = floor(p);\n\tvec3 p1 = p0 + vec3(1,1,1);\n\tvec3 p2 = p0 + vec3(1,0,0);\n\tvec3 p3 = p0 + vec3(0,1,0);\n\tvec3 p4 = p0 + vec3(0,0,1);\n\tvec3 p5 = p0 + vec3(1,1,0);\n\tvec3 p6 = p0 + vec3(1,0,1);\n\tvec3 p7 = p0 + vec3(0,1,1);\n\tvec3 p8 = p0 + vec3(1,1,1);\n\tvec3 p9 = p0 + vec3(0,0,0);\n\tvec3 p10 = p0 + vec3(1,0,0);\n\tvec3 p11 = p0 + vec3(0,1,0);\n\tvec3 p12 = p0 + vec3(0,0,1);\n\tvec3 p13 = p0 + vec3(1,1,0);\n\tvec3 p14 = p0 + vec3(1,0,1);\n\tvec3 p15 = p0 + vec3(0,1,1);\n\tvec3 p16 = p0 + vec3(1,1,1);\n\tvec3 p17 = p0 + vec3(0,0,0);\n\tvec3 p18 = p0 + vec3(1,0,0);\n\tvec3 p19 = p0 + vec3(0,1,0);\n\tvec3 p20 = p0 + vec3(0,0,1);\n\tvec3 p21 = p0 + vec3(1,1,0);\n\tvec3 p22 = p0 + vec3(1,0,1);\n\tvec3 p23 = p0 + vec3(0,1,1);\n\tvec3 p24 = p0 + vec3(1,1,1);\n\tvec3 p25 = p0 + vec3(0,0,0);\n\tvec3 p26 = p0", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 0.5;\n\tfloat c = 0.5;\n\tfloat d = 0.5;\n\tfloat e = 0.5;\n\tfloat f = 0.5;\n\tfloat g = 0.5;\n\tfloat h = 0.5;\n\tfloat i = 0.5;\n\tfloat j = 0.5;\n\tfloat k = 0.5;\n\tfloat l = 0.5;\n\tfloat m = 0.5;\n\tfloat n = 0.5;\n\tfloat o = 0.5;\n\tfloat p = 0.5;\n\tfloat q = 0.5;\n\tfloat r = 0.5;\n\tfloat s = 0.5;\n\tfloat t = 0.5;\n\tfloat u = 0.5;\n\tfloat v = 0.5;\n\tfloat w = 0.5;\n\tfloat x = 0.5;\n\tfloat y = 0.5;\n\tfloat z = 0.5;\n\tfloat aa = 0.5;\n\tfloat bb = 0.5;\n\tfloat cc = 0.5;\n\tfloat dd = 0.5;\n\tfloat ee = 0.5;\n\tfloat ff = 0.5;\n\tfloat gg = 0.5;\n\tfloat hh = 0.5;\n\tfloat ii = 0.5;\n\tfloat jj = 0.5;\n\tfloat kk = 0.5;\n\tfloat ll = 0.5;\n\tfloat mm = 0.5;\n\tfloat nn = 0.5;\n\tfloat oo = 0.5;\n\tfloat pp = 0.5;\n\tfloat qq = 0.5;\n\tfloat rr = 0.5;\n\tfloat ss = 0.5;\n\tfloat tt = 0.5;\n\tfloat uu = 0.5;\n\tfloat vv = 0.5;\n\tfloat ww = 0.5;\n\tfloat xx = 0.5;", "\n\tvec2 result = vec2(0.0);\n\tfloat cloudDensity = 0.0;\n\tfloat cloudColor = 0.0;\n\tfloat cloudColor2 = 0.0;\n\tfloat cloudColor3 = 0.0;\n\tfloat cloudColor4 = 0.0;\n\tfloat cloudColor5 = 0.0;\n\tfloat cloudColor6 = 0.0;\n\tfloat cloudColor7 = 0.0;\n\tfloat cloudColor8 = 0.0;\n\tfloat cloudColor9 = 0.0;\n\tfloat cloudColor10 = 0.0;\n\tfloat cloudColor11 = 0.0;\n\tfloat cloudColor12 = 0.0;\n\tfloat cloudColor13 = 0.0;\n\tfloat cloudColor14 = 0.0;\n\tfloat cloudColor15 = 0.0;\n\tfloat cloudColor16 = 0.0;\n\tfloat cloudColor17 = 0.0;\n\tfloat cloudColor18 = 0.0;\n\tfloat cloudColor19 = 0.0;\n\tfloat cloudColor20 = 0.0;\n\tfloat cloudColor21 = 0.0;\n\tfloat cloudColor22 = 0.0;\n\tfloat cloudColor23 = 0.0;\n\tfloat cloudColor24 = 0.0;\n\tfloat cloudColor25 = 0.0;\n\tfloat cloudColor26 = 0.0;\n\tfloat cloudColor27 = 0.0;\n\tfloat cloudColor28 = 0.0;\n\tfloat cloudColor29 = 0.0;\n\tfloat cloudColor30 = 0.0;\n\tfloat cloudColor31 = 0.0;\n\tfloat cloudColor32 = 0.0;\n\tfloat cloudColor33 = 0.0;\n\tfloat cloudColor34 = 0.0;\n\tfloat cloudColor35 = 0.0;\n\tfloat cloudColor36 = 0.0;\n\tfloat cloudColor37 = 0.0;\n\tfloat cloudColor38 = 0.0;\n\tfloat cloud", "\n\tfloat ground = 0.0;\n\tfloat ground_dist = 0.0;\n\tfloat ground_dist_max = 0.0;\n\tfloat ground_dist_min = 0.0;\n\tfloat ground_dist_max_min = 0.0;\n\tfloat ground_dist_max_min_max = 0.0;\n\tfloat ground_dist_max_min_min = 0.0;\n\tfloat ground_dist_max_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min", "\n\tvec3 color = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat step = 0.001;\n\tfloat maxDist = 100.0;\n\tfloat fog = 0.0;\n\tfloat fogDensity = 0.0005;\n\tfloat fogColor = 0.0;\n\tfloat fogMax = 0.0;\n\tfloat fogMin = 0.0;\n\tfloat fogMaxDist = 100.0;\n\tfloat fogMinDist = 0.0;\n\tfloat fogMaxColor = 0.0;\n\tfloat fogMinColor = 0.0;\n\tfloat fogMaxDensity = 0.0005;\n\tfloat fogMinDensity = 0.00005;\n\tfloat fogMaxDist2 = 100.0;\n\tfloat fogMinDist2 = 0.0;\n\tfloat fogMaxColor2 = 0.0;\n\tfloat fogMinColor2 = 0.0;\n\tfloat fogMaxDensity2 = 0.0005;\n\tfloat fogMinDensity2 = 0.00005;\n\tfloat fogMaxDist3 = 100.0;\n\tfloat fogMinDist3 = 0.0;\n\tfloat fogMaxColor3 = 0.0;\n\tfloat fogMinColor3 = 0.0;\n\tfloat fogMaxDensity3 = 0.0005;\n\tfloat fogMinDensity3 = 0.00005;\n\tfloat fogMaxDist4 = 100.0;\n\tfloat fogMinDist4 = 0.0;\n\tfloat fogMaxColor4 = 0.0;\n\tfloat fogMinColor4 = 0.0;\n\tfloat fogMaxDensity4 = 0.0005;\n\tfloat fogMinDensity4 = 0.00005;\n\tfloat fogMaxDist5 = 100.0;\n\tfloat fogMinDist5 = 0.0;\n\tfloat fogMaxColor5 = 0.0;\n\tfloat fogMinColor5 = 0.0;\n\tfloat fogMaxDensity5 = 0.", "\n\tcolor = color * (1.0 / 1.055) - (16.0 / 116.0);\n\tcolor = max(vec3(0.0), color);\n\treturn 2.51 * pow(color, vec3(2.4)) * (1.0 / 1.0893);\n}\n\n// Gamma correction\nvec"]}