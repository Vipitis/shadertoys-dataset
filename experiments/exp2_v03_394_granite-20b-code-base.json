{"generations": [" return 0.282095; }\nfloat SH_1_0( in vec3 s ) { return -0.488603*s.y; }\nfloat SH_1_1( in vec3 s ) { return 0.488603*s.x; }\nfloat SH_2_0( in vec3 s ) { return -0.946175*s.y*s.z; }\nfloat SH_2_1( in vec3 s ) { return 1.092548*s.x*s.z; }\nfloat SH_2_2( in vec3 s ) { return -0.315392*(3.0*s.z*s.z-1.0); }\nfloat SH_3_0( in vec3 s ) { return 0.590044*(2.0*s.x*s.y*s.z); }\nfloat SH_3_1( in vec3 s ) { return -1.077847*(s.y*s.y-s.x*s.x); }\nfloat SH_3_2( in vec3 s ) { return 0.590044*(s.x*s.x-s.y*s.y); }\nfloat SH_3_3( in vec3 s ) { return -0.590044*s.x*s.y; }\n\n// evaluate the spherical harmonics basis functions\nfloat SH_0_0( in float theta, in float phi ) { return 0.282095; }\nfloat SH_1_0( in float theta, in float phi ) { return -0.488603*cos(theta); }\nfloat SH_1_1( in float theta, in float phi ) { return 0.488603*sin(theta); }\nfloat SH_2_0( in float theta, in float phi ) { return -0.946175*cos(theta)*cos(phi); }\nfloat SH_2_1( in float theta, in float phi ) { return 1.09254", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a box\nfloat box( in vec2 b, in vec2 p )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to a rounded box\nfloat roundedBox( in vec2 b, in vec2 p, float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to a circle\nfloat circle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to a rounded circle\nfloat roundedCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to an ellipse\nfloat ellipse( in vec2 p, in vec2 ab )\n{\n    vec2 l = (length(p/ab)-1.0)*ab;\n    return length(max(vec2(0.0),l));\n}\n\n// distance to a rounded ellipse\nfloat roundedEllipse( in vec2 p, in vec2 ab, in float r )\n{\n    vec2 l = (length(p/ab)-1.0)*ab;\n    return length(max(vec2(0.0),l))-r;\n}\n\n// distance to a capsule\nfloat capsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to a rounded capsule\nfloat roundedCapsule( in vec3 p, in vec3 a, in vec3 b, in float r", "\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Compute the intersection of a ray with a plane\nvec3 intersectPlane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return ro + p.xyz * ( dot( p.xyz, rd ) / dot( rd, p.xyz ) );\n}\n\n// Compute the intersection of a ray with a sphere\nvec3 intersectSphere( in vec3 ro, in vec3 rd, in vec4 s )\n{\n    vec3 oc = ro - s.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - s.w * s.w;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec3( -1.0 );\n    h = sqrt( h );\n    return ro + rd * ( -b - h );\n}\n\n// Compute the intersection of a ray with a box\nvec3 intersectBox( in vec3 ro, in vec3 rd, in vec3 boxMin, in vec3 boxMax )\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ( boxMin - ro );\n    vec3 k = m * ( boxMax - ro );\n    vec3 t1 = min( n, k );\n    vec3 t2 = max( n, k );\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec3( -1.0 );\n    return ro + rd * tN;\n}\n\n// Compute the intersection of a ray with a triangle\nvec3 intersectTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 s1 = cross( rd, e2 );\n    float divisor = dot( e1, s1 );\n    if( divisor == 0.0 ) return", "\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nivec2 reflIfNeg( in ivec2 v, in ivec2 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nivec3 reflIfNeg( in ivec3 v, in ivec3 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nivec4 reflIfNeg( in ivec4 v, in ivec4 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nuvec2 reflIfNeg( in uvec2 v, in uvec2 r )\n{\n    return mix( v, -v, step( 0.0, dot( r, v ) ) );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nuvec3 reflIfNeg( in uvec3 v, in uvec3 r )\n{\n    return mix( v, -v, step( 0.0, dot( r", "\n    return max( v, vec2(0.0) ) + min( v, vec2(0.0) ) * r;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return min( v, vec2(0.0) ) + max( v, vec2(0.0) ) * r;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    return max( v, vec3(0.0) ) + min( v, vec3(0.0) ) * r;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return min( v, vec3(0.0) ) + max( v, vec3(0.0) ) * r;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    return max( v, vec4(0.0) ) + min( v, vec4(0.0) ) * r;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return min( v, vec4(0.0) ) + max( v, vec4(0.0) ) * r;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nivec2 clipIfNeg( in ivec2 v, in ivec2 r )\n{\n    return max( v, ivec2(0) ) + min( v, ivec2(0) ) * r;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nivec2 clipIfPos( in ivec2 v,", "\n    vec2 q = p - a;\n    vec2 r = b - a;\n    float h = clamp( dot(q,r)/dot(r,r), 0.0, 1.0 );\n    float d = length( q - h*r );\n    float s = sign( p.y - a.y );\n    float w = (1.0-s)*w1 + s*w2;\n    return max(d - w,0.0);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow(p,a,b,w,w);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow(p,a,b,0.1*length(b-a));\n}\n\nfloat sdArrow( in vec2 p, vec2 a, float w )\n{\n    return sdArrow(p,a,vec2(0.0),w);\n}\n\nfloat sdArrow( in vec2 p, vec2 a )\n{\n    return sdArrow(p,a,vec2(0.0),0.1*length(a));\n}\n\nfloat sdArrow( in vec2 p, float w )\n{\n    return sdArrow(p,vec2(0.0),vec2(0.0),w);\n}\n\nfloat sdArrow( in vec2 p )\n{\n    return sdArrow(p,vec2(0.0),vec2(0.0),0.1);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float t )\n{\n    vec2 q = p - a;\n    vec2 r = b - a;\n    float h = clamp( dot(q,r)/dot(r,r), 0.0, 1.0 );\n    float d = length( q - h*r );\n    float s = sign( p.y - a.y );\n    float w = (1.0-s)*w1 + s*w2;\n    return max(d - w*t,0.0);\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b,", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot3 = sunDot2 * sunDot;\n\tfloat sunDot4 = sunDot3 * sunDot;\n\tfloat sunDot5 = sunDot4 * sunDot;\n\tfloat sunDot6 = sunDot5 * sunDot;\n\tfloat sunDot7 = sunDot6 * sunDot;\n\tfloat sunDot8 = sunDot7 * sunDot;\n\tfloat sunDot9 = sunDot8 * sunDot;\n\tfloat sunDot10 = sunDot9 * sunDot;\n\tfloat sunDot11 = sunDot10 * sunDot;\n\tfloat sunDot12 = sunDot11 * sunDot;\n\tfloat sunDot13 = sunDot12 * sunDot;\n\tfloat sunDot14 = sunDot13 * sunDot;\n\tfloat sunDot15 = sunDot14 * sunDot;\n\tfloat sunDot16 = sunDot15 * sunDot;\n\tfloat sunDot17 = sunDot16 * sunDot;\n\tfloat sunDot18 = sunDot17 * sunDot;\n\tfloat sunDot19 = sunDot18 * sunDot;\n\tfloat sunDot20 = sunDot19 * sunDot;\n\tfloat sunDot21 = sunDot20 * sunDot;\n\tfloat sunDot22 = sunDot21 * sunDot;\n\tfloat sunDot23 = sunDot22 * sunDot;\n\tfloat sunDot24 = sunDot23 * sunDot;\n\tfloat sunDot25 = sunDot24 * sunDot;\n\tfloat sunDot26 = sunDot25 * sunDot;\n\tfloat sunDot27 = sunDot26 * sunDot;\n\tfloat sunDot28 = sunDot27 * sunDot;\n\tfloat sunDot29 = sunDot28 * sunDot;\n\tfloat sunDot30 = sunDot29 * sunDot;\n\tfloat sunDot31 = sunDot30 * sunDot;\n\tfloat sunDot32 = sunDot31 * sunDot;\n\tfloat sunDot33 = sunDot32 * sunDot;\n\tfloat sun", "\n    vec4 v0 = (p2 - p0) * 0.5;\n    vec4 v1 = (p3 - p1) * 0.5;\n    float t2 = t * t;\n    float t3 = t * t2;\n    return vec4(\n        0.5 * (2.0 * p1.xyz + (-p0.xyz + p2.xyz) * t + (2.0 * v0.xyz + v1.xyz) * t2 - v0.xyz * t3),\n        1.0\n    );\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float t2, float t3)\n{\n    vec4 v0 = (p2 - p0) * 0.5;\n    vec4 v1 = (p3 - p1) * 0.5;\n    return vec4(\n        0.5 * (2.0 * p1.xyz + (-p0.xyz + p2.xyz) * t + (2.0 * v0.xyz + v1.xyz) * t2 - v0.xyz * t3),\n        1.0\n    );\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float t2, float t3, float t4)\n{\n    vec4 v0 = (p2 - p0) * 0.5;\n    vec4 v1 = (p3 - p1) * 0.5;\n    return vec4(\n        0.5 * (2.0 * p1.xyz + (-p0.xyz + p2.xyz) * t + (2.0 * v0.xyz + v1.xyz) * t2 - v0.xyz * t3),\n        1.0\n    );\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float t2, float t3, float t4, float t5)\n{\n   ", "\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tsum += amp * sin(freq * p.x + p.y + p.z);\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn sum * normalizer;\n}\n\n// This is a 3D version of the 2D \"cellular noise\" function described here:\n// http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\n// It's a type of noise that can be used to generate organic looking textures.\n// It can be a little slow, so use it sparingly.\nfloat CellularNoiseC(vec3 p)\n{\n\tvec3 pi = floor(p);\n\tvec3 pf = p - pi;\n\tvec3 w = pf * pf * (3.0 - 2.0 * pf);\n\tfloat sum = 0.0;\n\tfor (int i=0; i<8; i++)\n\t{\n\t\tvec3 offset = vec3(float(i));\n\t\tvec3 g = offset - pf + CellularNoise3D(pi + offset);\n\t\tfloat d = dot(g, g);\n\t\tsum += w.x * w.y * w.z * (d < 0.5? 0.0 : 1.0);\n\t}\n\treturn sum;\n}\n\n// This is a 3D version of the 2D \"cellular noise\" function described here:\n// http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\n// It's a type of noise that can be used to generate organic looking textures.\n// It can be a little slow, so use it sparingly.\nfloat CellularNoise3D(vec3 p)\n{\n\tvec3 pi = floor(p);\n\tvec3 pf = p - pi;\n\tvec3 w = pf * pf * (3.0 - 2.0 * pf);\n\tfloat sum = 0.0;\n", "\n\tvec4 p0 = CamPath[0];\n\tvec4 p1 = CamPath[1];\n\tvec4 p2 = CamPath[2];\n\tvec4 p3 = CamPath[3];\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\tvec4 a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;\n\tvec4 b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;\n\tvec4 c = -0.5 * p0 + 0.5 * p2;\n\tvec4 d = p1;\n\n\treturn a * t3 + b * t2 + c * t + d;\n}\n\n// This is the camera's view matrix.\n// It is a look-at matrix, with the camera position and target\n// being interpolated from the camera path.\nmat4 ViewMatrix(float t)\n{\n\tvec4 pos = CamPos(t);\n\tvec4 target = CamPos(t + 0.001);\n\tvec4 up = vec4(0, 1, 0, 0);\n\n\treturn lookAt(pos, target, up);\n}\n\n// This is the camera's projection matrix.\n// It is a perspective matrix, with the field of view\n// being interpolated from the camera path.\nmat4 ProjectionMatrix(float t)\n{\n\tfloat fov = CamPath[4].x;\n\tfloat aspect = CamPath[4].y;\n\tfloat near = CamPath[4].z;\n\tfloat far = CamPath[4].w;\n\n\treturn perspective(fov, aspect, near, far);\n}\n\n// This is the camera's view-projection matrix.\n// It is the product of the view and projection matrices.\nmat4 ViewProjectionMatrix(float t)\n{\n\treturn ProjectionMatrix(t) * ViewMatrix(t);\n}\n\n// This is the camera's inverse view-projection matrix.\n// It is the inverse of the view-projection matrix.\nmat4 InverseViewProjectionMatrix(float t)\n{\n\treturn inverse(ViewProjectionMatrix", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat Hash2d(vec2 p)\n{\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat Hash3d(vec3 p)\n{\n    return fract(sin(dot(p, vec3(127.1, 311.7, 113.9))) * 43758.5453);\n}\n\nfloat Hash4d(vec4 p)\n{\n    return fract(sin(dot(p, vec4(127.1, 311.7, 113.9, 271.9))) * 43758.5453);\n}\n\nfloat Noise1d(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(Hash1d(i), Hash1d(i + 1.0), u);\n}\n\nfloat Noise2d(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(Hash2d(i), Hash2d(i + vec2(1.0, 0.0)), u.x), mix(Hash2d(i + vec2(0.0, 1.0)), Hash2d(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat Noise3d(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(Hash3d(i), Hash3d(i + vec3(1.0, 0.0, 0.0)),", "\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfloat max = 1.0;\n\tfloat value = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tvalue += sin(p.x*freq + p.y*freq + p.z*freq) * amp;\n\t\tmax += amp;\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn value / max;\n}\n\n// This is a 3D version of the 2D fbm function I wrote.\n// It's a bit faster than the 2D version since it doesn't need to calculate the dot product.\nfloat FBM3D(vec3 p)\n{\n\tfloat value = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tvalue += RustNoise3D(p) * amp;\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn value;\n}\n\n// This is a 3D version of the 2D fbm function I wrote.\n// It's a bit faster than the 2D version since it doesn't need to calculate the dot product.\nfloat FBM3D(vec3 p, float octaves)\n{\n\tfloat value = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tvalue += RustNoise3D(p) * amp;\n\t\tp *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn value;\n}\n\n// This is a 3D version of the 2D fbm function I wrote.\n// It's a bit faster than the 2D version since it doesn't need to calculate the dot product.\nfloat FBM3D(vec3 p, float octaves, float lacunarity, float gain)\n{\n\tfloat value = 0.0;\n\tfloat amp", "\n\tfloat d = 10000.0;\n\tfloat t = 1.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td = min(d, abs(length(p) - t) - scale);\n\t\tp = abs(p) / dot(p, p) - 0.62;\n\t\tt *= 0.7;\n\t\tscale *= 0.5;\n\t}\n\treturn d;\n}\n\n// This is the function that makes the fractal shape\nfloat DistanceToFractal(vec3 p)\n{\n\tfloat d = 10000.0;\n\tfloat t = 1.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td = min(d, abs(length(p) - t) - scale);\n\t\tp = abs(p) / dot(p, p) - 0.62;\n\t\tt *= 0.7;\n\t\tscale *= 0.5;\n\t}\n\treturn d;\n}\n\n// This is the function that makes the fractal shape\nfloat DistanceToFractal(vec3 p, float t, float scale)\n{\n\tfloat d = 10000.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td = min(d, abs(length(p) - t) - scale);\n\t\tp = abs(p) / dot(p, p) - 0.62;\n\t\tt *= 0.7;\n\t\tscale *= 0.5;\n\t}\n\treturn d;\n}\n\n// This is the function that makes the fractal shape\nfloat DistanceToFractal(vec3 p, float t, float scale, float d)\n{\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td = min(d, abs(length(p) - t) - scale);\n\t\tp = abs(p) / dot(p, p) - ", "\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS = (u_envMapTransform * vec4(rayDir, 0.0)).xyz;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS = (u_envMapTransform * vec4(sunDir, 0.0)).xyz;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS2 = rayDirTS;\n    rayDirTS2.y = -rayDirTS2.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS2 = sunDirTS;\n    sunDirTS2.y = -sunDirTS2.y;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS3 = rayDirTS;\n    rayDirTS3.y = -rayDirTS3.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS3 = sunDirTS;\n    sunDirTS3.y = -sunDirTS3.y;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS4 = rayDirTS;\n    rayDirTS4.y = -rayDirTS4.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS4 = sunDirTS;\n    sunDirTS4.y = -sunDirTS4.y;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS5 = rayDirTS;\n    rayDirTS5.y = -rayDirTS5.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS5 = sunDirTS;\n    sunDirTS5.y = -sunDirTS5.y;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS6 = rayDirTS;\n    rayDirTS6.y = -rayDirTS6.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS6 = sunDirTS;\n    sunDirTS6.y = -sunDirTS6.y;\n\n    // Get the ray direction in tangent space.\n    vec3 rayDirTS7 = rayDirTS;\n    rayDirTS7.y = -rayDirTS7.y;\n\n    // Get the ray direction in tangent space.\n    vec3 sunDirTS7 = sunDir", "\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// 2D simplex noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( dot( vec2(0.0,0.0), f-vec2(0.0,0.0) ),\n                        dot( vec2(1.0,0.0), f-vec2(1.0,0.0) ), f.x),\n                   mix( dot( vec2(0.0,1.0), f-vec2(0.0,1.0) ),\n                        dot( vec2(1.0,1.0), f-vec2(1.0,1.0) ), f.x), f.y);\n    return res;\n}\n\n// 3D simplex noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( dot( vec3(0.0,0.0,0.0), f-vec3(0.0,0.0,0.0) ),\n                             dot( vec3(1.0,0.0,0.0), f-vec3(1.0,0.0,0.", "\n\tvec3 relPos = pos - spherePos;\n\tfloat b = dot(relPos, dirVecPLZNormalizeMeFirst);\n\tfloat c = dot(relPos, relPos) - rad*rad;\n\tfloat disc = b*b - c;\n\tif (disc < 0.0)\n\t\treturn -1.0;\n\telse\n\t\treturn (-b - sqrt(disc));\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 hitPos)\n{\n\tvec3 relPos = pos - spherePos;\n\tfloat b = dot(relPos, dirVecPLZNormalizeMeFirst);\n\tfloat c = dot(relPos, relPos) - rad*rad;\n\tfloat disc = b*b - c;\n\tif (disc < 0.0)\n\t\treturn -1.0;\n\telse\n\t{\n\t\tfloat t = (-b - sqrt(disc));\n\t\thitPos = pos + dirVecPLZNormalizeMeFirst*t;\n\t\treturn t;\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 hitPos, out vec3 hitNormal)\n{\n\tvec3 relPos = pos - spherePos;\n\tfloat b = dot(relPos, dirVecPLZNormalizeMeFirst);\n\tfloat c = dot(relPos, relPos) - rad*rad;\n\tfloat disc = b*b - c;\n\tif (disc < 0.0)\n\t\treturn -1.0;\n\telse\n\t{\n\t\tfloat t = (-b - sqrt(disc));\n\t\thitPos = pos + dirVecPLZNormalizeMeFirst*t;\n\t\thitNormal = normalize(hitPos - spherePos);\n\t\treturn t;\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, out vec3 hitPos, out vec3 hitNormal, out vec3 hitTangent, out vec3 hitBitang", "\n\t// Calculate the distance to the sphere.\n\tvec2 d = vec2(length(p) - 1.0, 0.0);\n\n\t// Calculate the distance to the box.\n\tvec3 q = abs(p) - vec3(1.0);\n\td = max(d, vec2(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), 1.0));\n\n\t// Calculate the distance to the torus.\n\tvec2 t = vec2(length(p.xz) - 0.2, p.y);\n\td = max(d, vec2(length(t) - 0.1, 2.0));\n\n\t// Calculate the distance to the cylinder.\n\tvec2 c = vec2(length(p.xy) - 0.2, p.z);\n\td = max(d, vec2(length(c) - 0.1, 3.0));\n\n\t// Calculate the distance to the cone.\n\tvec2 s = vec2(length(p.xy) - 0.2, -p.z - 0.1);\n\td = max(d, vec2(length(s) - 0.1, 4.0));\n\n\t// Calculate the distance to the plane.\n\td = max(d, vec2(p.y + 0.1, 5.0));\n\n\t// Calculate the distance to the capsule.\n\tvec3 a = p - vec3(0.0, 0.2, 0.0);\n\tvec3 b = p - vec3(0.0, -0.2, 0.0);\n\td = max(d, vec2(length(max(vec3(length(a.xz) - 0.2, a.y), 0.0)) + min(max(a.x, max(a.y, a.z)), 0.0), 6.0));\n\td = max(d, vec2(length(max(vec3(length(b.xz) - 0.2, b.y), 0.0)) + min(max", "\n    return vec3(0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0);\n}\n\n// surface\nvec3 mapS0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapS1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapS2(vec3 p)\n{\n    return vec3(0.0);\n}\n\n// light\nvec3 mapL0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapL1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapL2(vec3 p)\n{\n    return vec3(0.0);\n}\n\n// material\nvec3 mapM0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapM1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapM2(vec3 p)\n{\n    return vec3(0.0);\n}\n\n// camera\nvec3 mapC0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapC1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapC2(vec3 p)\n{\n    return vec3(0.0);\n}\n\n// background\nvec3 mapB0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapB1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapB2(vec3 p)\n{\n    return vec3(0.0);\n}\n\n// light\nvec3 mapL0(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapL1(vec3 p)\n{\n    return vec3(0.0);\n}\n\nvec3 mapL2(vec3", "\n\tvec3 p = map(t);\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 a = map(t - e.x) - p;\n\tvec3 b = map(t + e.x) - p;\n\tvec3 c = map(t - e.y) - p;\n\tvec3 d = map(t + e.y) - p;\n\tvec3 f = map(t - e.z) - p;\n\tvec3 g = map(t + e.z) - p;\n\treturn normalize(vec3(a.x - b.x, c.y - d.y, f.z - g.z));\n}\n\n// curve normal\nvec3 mapN(float t)\n{\n\treturn normalize(cross(mapD1(t - 0.001), mapD1(t + 0.001)));\n}\n\n// curve tangent\nvec3 mapT(float t)\n{\n\treturn normalize(mapD1(t));\n}\n\n// curve binormal\nvec3 mapB(float t)\n{\n\treturn normalize(cross(mapN(t), mapT(t)));\n}\n\n// curve surface normal\nvec3 mapS(float t)\n{\n\treturn normalize(cross(mapT(t), mapB(t)));\n}\n\n// curve surface tangent\nvec3 mapU(float t)\n{\n\treturn normalize(mapD1(t));\n}\n\n// curve surface binormal\nvec3 mapV(float t)\n{\n\treturn normalize(cross(mapN(t), mapU(t)));\n}\n\n// curve surface normal\nvec3 mapW(float t)\n{\n\treturn normalize(cross(mapU(t), mapV(t)));\n}\n\n// curve surface normal\nvec3 mapX(float t)\n{\n\treturn normalize(cross(mapV(t), mapW(t)));\n}\n\n// curve surface normal\nvec3 mapY(float t)\n{\n\treturn normalize(cross(mapW(t), mapX(t)));\n}\n\n// curve surface normal\nvec3 mapZ(float t", "\n\tvec3 p = map(t);\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 a = map(t - e.x) - 2.0 * p + map(t + e.x);\n\tvec3 b = map(t - e.y) - 2.0 * p + map(t + e.y);\n\tvec3 c = map(t - e.z) - 2.0 * p + map(t + e.z);\n\treturn normalize(a * e.x * e.x + b * e.y * e.y + c * e.z * e.z);\n}\n\n// raymarching\nfloat raymarch(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = map(p.x).x;\n\t\tt += d * 0.5;\n\t\tif (d < 0.001) break;\n\t}\n\treturn t;\n}\n\n// raymarching with normal\nvec2 raymarchNormal(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = map(p.x).x;\n\t\tt += d * 0.5;\n\t\tif (d < 0.001) break;\n\t}\n\tvec3 n = mapD(t);\n\treturn vec2(t, dot(n, rd));\n}\n\n// raymarching with normal and color\nvec3 raymarchColor(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = map(p.x).x;\n\t\tt += d * 0.5;", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( dot(pa,pa) - h*h*dot(ba,ba), h );\n}\n\n// signed squared distance between point and segment\nvec2 sqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa)*length(pa) - h*h*dot(ba,ba), h );\n}\n\n// signed squared distance between point and triangle\nvec3 sqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 cb = c - b;\n    vec3 pb = p - b;\n    vec3 ac = a - c;\n    vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return vec3(\n        dot(cross(ba,nor),pa) * dot(cross(ba,nor),pa) +\n        dot(cross(cb,nor),pb) * dot(cross(cb,nor),pb) +\n        dot(cross(ac,nor),pc) * dot(cross(ac,nor),pc),\n        dot(ba,ba)*dot(pa,pa) - dot(ba,pa)*dot(ba,pa),\n        -sign(dot(nor,pa))*sign(dot(nor,pa))*dot(nor,pa)*dot(nor,pa)\n    );\n}\n\n// signed squared distance between point and triangle\nvec3 usqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 cb = c - b;\n    vec3 pb = p - b;\n    vec3 ac = a - c;\n    vec3 pc = p - c;\n    vec3 nor =", "\n    vec3 ba = b - a;\n    vec3 ao = o - a;\n    vec3 ad = d * dot( ba, d );\n    vec3 aoad = ao + ad;\n    vec3 oa = o - a;\n    vec3 oab = oa - ba * clamp( dot( oa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec3 oabad = oab + ad;\n    vec3 oabadba = oabad - ba;\n    vec3 oabadbaad = oabadba + ad;\n    vec3 oabadbaadba = oabadbaad - ba;\n    vec3 oabadbaadbaad = oabadbaadba + ad;\n    vec3 oabadbaadbaadba = oabadbaadbaad - ba;\n    vec3 oabadbaadbaadbaad = oabadbaadbaadba + ad;\n    vec3 oabadbaadbaadbaadba = oabadbaadbaadbaad - ba;\n    vec3 oabadbaadbaadbaadbaad = oabadbaadbaadbaadba + ad;\n    vec3 oabadbaadbaadbaadbaadba = oabadbaadbaadbaadbaad - ba;\n    vec3 oabadbaadbaadbaadbaadbaad = oabadbaadbaadbaadbaadba + ad;\n    vec3 oabadbaadbaadbaadbaadbaadba = oabadbaadbaadbaadbaadbaadba - ba;\n    vec3 oabadbaadbaadbaadbaadbaadbaad = oabadbaadbaadbaadbaadbaadbaad + ad;\n    vec3 oabadbaadbaadbaadbaadbaadbaadba = oabadbaadbaadbaadbaadbaadbaadba - ba;\n    vec3 oabadbaadbaadbaadbaadbaadbaadbaad = oabadbaadbaadbaadbaadbaadbaadbaad + ad;\n    vec3 oabadbaadbaadbaadbaadbaadbaadbaadba = oabadbaadbaadba", "\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.x - r.y - r.z - r.w;\n}\n\n// p = point\n// b = box\n// r = roundness\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// p = point\n// b = box\n// r = roundness\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// p = point\n// b = box\n// r = roundness\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r ) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x - r.y - r.z;\n}\n\n// p = point\n// b = box\n// r = roundness\nfloat sdRoundBox( in vec4 p, in vec4 b, in float r ) \n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) - r;\n}\n\n// p = point\n// b = box\n// r = roundness\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r ) \n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tfloat sunDot2 = sunDot * sunDot;\n\tfloat sunDot3 = sunDot2 * sunDot;\n\tfloat sunDot4 = sunDot3 * sunDot;\n\tfloat sunDot5 = sunDot4 * sunDot;\n\tfloat sunDot6 = sunDot5 * sunDot;\n\tfloat sunDot7 = sunDot6 * sunDot;\n\tfloat sunDot8 = sunDot7 * sunDot;\n\tfloat sunDot9 = sunDot8 * sunDot;\n\tfloat sunDot10 = sunDot9 * sunDot;\n\tfloat sunDot11 = sunDot10 * sunDot;\n\tfloat sunDot12 = sunDot11 * sunDot;\n\tfloat sunDot13 = sunDot12 * sunDot;\n\tfloat sunDot14 = sunDot13 * sunDot;\n\tfloat sunDot15 = sunDot14 * sunDot;\n\tfloat sunDot16 = sunDot15 * sunDot;\n\tfloat sunDot17 = sunDot16 * sunDot;\n\tfloat sunDot18 = sunDot17 * sunDot;\n\tfloat sunDot19 = sunDot18 * sunDot;\n\tfloat sunDot20 = sunDot19 * sunDot;\n\tfloat sunDot21 = sunDot20 * sunDot;\n\tfloat sunDot22 = sunDot21 * sunDot;\n\tfloat sunDot23 = sunDot22 * sunDot;\n\tfloat sunDot24 = sunDot23 * sunDot;\n\tfloat sunDot25 = sunDot24 * sunDot;\n\tfloat sunDot26 = sunDot25 * sunDot;\n\tfloat sunDot27 = sunDot26 * sunDot;\n\tfloat sunDot28 = sunDot27 * sunDot;\n\tfloat sunDot29 = sunDot28 * sunDot;\n\tfloat sunDot30 = sunDot29 * sunDot;\n\tfloat sunDot31 = sunDot30 * sunDot;\n\tfloat sunDot32 = sunDot31 * sunDot;\n\tfloat sunDot33 = sunDot32 * sunDot;\n\tfloat sun", "\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// This is the main function that we will use to render our scene.\n// It is called every frame.\nvoid main()\n{\n    // This is the color that we will use to clear the screen.\n    // We will use a nice blue color.\n    vec3 clearColor = vec3(0.0, 0.0, 0.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor = vec3(1.0, 1.0, 0.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor2 = vec3(0.0, 1.0, 0.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor3 = vec3(0.0, 0.0, 1.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor4 = vec3(1.0, 0.0, 0.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor5 = vec3(0.0, 1.0, 1.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor6 = vec3(1.0, 1.0, 1.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will use a nice yellow color.\n    vec3 drawColor7 = vec3(0.0, 0.0, 0.0);\n\n    // This is the color that we will use to draw our scene.\n    // We will", "\n    vec2 result = vec2( 10000.0, 0.0 );\n    float d = 0.0;\n    float t = 0.0;\n    float r = 0.0;\n    float h = 0.0;\n    float s = 0.0;\n    float c = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z =", "\n    float dist1 = distance( thing1, mouse );\n    float dist2 = distance( thing2, mouse );\n    if( dist1 < dist2 ){\n        return thing1;\n    }else{\n        return thing2;\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3 ){\n    float dist1 = distance( thing1, mouse );\n    float dist2 = distance( thing2, mouse );\n    float dist3 = distance( thing3, mouse );\n    if( dist1 < dist2 && dist1 < dist3 ){\n        return thing1;\n    }else if( dist2 < dist1 && dist2 < dist3 ){\n        return thing2;\n    }else{\n        return thing3;\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3, vec2 thing4 ){\n    float dist1 = distance( thing1, mouse );\n    float dist2 = distance( thing2, mouse );\n    float dist3 = distance( thing3, mouse );\n    float dist4 = distance( thing4, mouse );\n    if( dist1 < dist2 && dist1 < dist3 && dist1 < dist4 ){\n        return thing1;\n    }else if( dist2 < dist1 && dist2 < dist3 && dist2 < dist4 ){\n        return thing2;\n    }else if( dist3 < dist1 && dist3 < dist2 && dist3 < dist4 ){\n        return thing3;\n    }else{\n        return thing4;\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing", "\n    // The distance to the closest object in the world\n    float distanceToClosestObject = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // This is the value we will return\n    vec3 normal;\n    // This is the value we will use to calculate the normal\n    float value;\n    // This is the value we will use to calculate the normal\n    float value2;\n    // This is the value we will use to calculate the normal\n    float value3;\n    // This is the value we will use to calculate the normal\n    float value4;\n    // This is the value we will use to calculate the normal\n    float value5;\n    // This is the value we will use to calculate the normal\n    float value6;\n    // This is the value we will use to calculate the normal\n    float value7;\n    // This is the value we will use to calculate the normal\n    float value8;\n    // This is the value we will use to calculate the normal\n    float value9;\n    // This is the value we will use to calculate the normal\n    float value10;\n    // This is the value we will use to calculate the normal\n    float value11;\n    // This is the value we will use to calculate the normal\n    float value12;\n    // This is the value we will use to calculate the normal\n    float value13;\n    // This is the value we will use to calculate the normal\n    float value14;\n    // This is the value we will use to calculate the normal\n    float value15;\n    // This is the value we will use to calculate the normal\n    float value16;\n    // This is the value we will use to calculate the normal\n    float value17;\n    // This is the value we will use to calculate the normal\n    float value18;\n    // This is the value we will use to calculate the normal\n    float value19;\n    // This is the value we will use to calculate the normal\n    float value20;\n    // This is the value we will use to calculate the normal\n    float value21;\n    // This is the value we will use to calculate the normal\n    float value22;\n    // This is the value we will use to calculate the normal\n    float value23;\n    // This is the value we will use to calculate the normal\n    float value24;\n    // This is the value we will use to calculate the normal\n    float value25;\n    // This is the value we will use to calculate the normal\n    float value26;\n    // This is the value we will use to calculate the normal\n   ", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// this is the main function that will be called\n// for each pixel.\nvec3 mainImage(vec2 fragCoord){\n    // first, we need to figure out where we are\n    // on the screen.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // now we can do our background color.\n    vec3 color = doBackgroundColor();\n\n    // now we can do our scene.\n    color += doScene(uv);\n\n    // and return the color.\n    return color;\n}\n\n// this is the main function that chooses our fragment\n// shader to use.\nvoid main(){\n    // first, we need to figure out where we are\n    // on the screen.\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // now we can do our background color.\n    vec3 color = doBackgroundColor();\n\n    // now we can do our scene.\n    color += doScene(uv);\n\n    // and return the color.\n    gl_FragColor = vec4(color, 1.0);\n}\n```\n\n## 3.2.2. 3D\n\n```glsl\n// this is the main function that will be called\n// for each pixel.\nvec3 mainImage(vec2 fragCoord){\n    // first, we need to figure out where we are\n    // on the screen.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // now we can do our background color.\n    vec3 color = doBackgroundColor();\n\n    // now we can do our scene.\n    color += doScene(uv);\n\n    // and return the color.\n    return color;\n}\n\n// this is the main function that chooses our fragment\n// shader to use.\nvoid main(){\n    // first, we need to figure out where we are\n    // on the screen.\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // now we can do our background color.\n    vec3 color = doBackgroundColor();\n\n    // now we can do our scene.\n    color += doScene(uv);\n\n    // and return the color.\n    gl_FragColor = vec4(color, 1.0);\n}\n```\n\n## 3.2.3. 3D", "\n\tvec3 color = vec3(0.0);\n\tvec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n\tfloat diffuse = max(0.0, dot(normalOfSurface, lightDir));\n\tcolor = diffuse * vec3(1.0, 1.0, 1.0);\n\treturn color;\n}\n\n// This is the function that will be called for every pixel\n// of the screen.\nvoid main(){\n\t// This is the color of the pixel.\n\tvec3 color = vec3(0.0);\n\t// This is the position of the pixel in the world.\n\tvec3 positionOfHit = vec3(0.0);\n\t// This is the normal of the surface at the position of the pixel.\n\tvec3 normalOfSurface = vec3(0.0);\n\t// This is the distance from the camera to the surface.\n\tfloat distanceToSurface = 0.0;\n\t// This is the position of the camera.\n\tvec3 cameraPosition = vec3(0.0, 0.0, 0.0);\n\t// This is the direction the camera is facing.\n\tvec3 cameraDirection = vec3(0.0, 0.0, 0.0);\n\t// This is the direction the camera is facing, but normalized.\n\tvec3 cameraDirectionNormalized = vec3(0.0, 0.0, 0.0);\n\t// This is the direction from the camera to the pixel.\n\tvec3 directionToPixel = vec3(0.0, 0.0, 0.0);\n\t// This is the direction from the camera to the pixel, but normalized.\n\tvec3 directionToPixelNormalized = vec3(0.0, 0.0, 0.0);\n\t// This is the direction from the camera to the surface.\n\tvec3 directionToSurface = vec3(0.0, 0.0, 0.0);\n\t// This is the direction from the camera to the surface, but normalized.\n\tvec3 directionToSurfaceNormalized = vec3(0.0, 0.0, 0.0);\n\t// This is the direction from the surface to the pixel", "\n\n  // we are going to use the rayHitInfo to determine\n  // what color to return.\n  // if rayHitInfo.x is 0.0, then we are inside the sphere\n  // if rayHitInfo.x is 1.0, then we are outside the sphere\n  // if rayHitInfo.x is between 0.0 and 1.0, then we are\n  // inside the sphere, but we are also inside the box\n  // if rayHitInfo.x is -1.0, then we are outside the sphere\n  // and outside the box.\n\n  // if rayHitInfo.y is 0.0, then we are inside the box\n  // if rayHitInfo.y is 1.0, then we are outside the box\n  // if rayHitInfo.y is between 0.0 and 1.0, then we are\n  // inside the box, but we are also inside the sphere\n  // if rayHitInfo.y is -1.0, then we are outside the box\n  // and outside the sphere.\n\n  // if rayHitInfo.x is 0.0 and rayHitInfo.y is 0.0, then\n  // we are inside the sphere and the box.\n  // if rayHitInfo.x is 0.0 and rayHitInfo.y is 1.0, then\n  // we are inside the sphere and outside the box.\n  // if rayHitInfo.x is 1.0 and rayHitInfo.y is 0.0, then\n  // we are outside the sphere and inside the box.\n  // if rayHitInfo.x is 1.0 and rayHitInfo.y is 1.0, then\n  // we are outside the sphere and outside the box.\n\n  // if rayHitInfo.x is 0.0 and rayHitInfo.y is between 0.0 and 1.0, then\n  // we are inside the sphere and inside the box.\n  // if rayHitInfo.x is 1.0 and rayHitInfo.y is between 0.0 and 1.0, then\n  // we are outside the sphere and inside the box.\n\n  // if rayHitInfo.x is between 0.0 and 1.0 and rayHitInfo.y is 0.0, then\n  // we are inside the sphere and inside the box.\n  // if", "\n    return pow(x, log(b) / log(0.5));\n}\n\n// bias x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec2 bias(vec2 x, float b) {\n    return pow(x, vec2(log(b) / log(0.5)));\n}\n\n// bias x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec3 bias(vec3 x, float b) {\n    return pow(x, vec3(log(b) / log(0.5)));\n}\n\n// bias x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nvec4 bias(vec4 x, float b) {\n    return pow(x, vec4(log(b) / log(0.5)));\n}\n\n// bias x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 123.456))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 123.456, 1234.567))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float t){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 * t);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float t){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 123.456))) * 43758.5453 * t);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p, float t){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 123.456, 1234.567))) * 43758.5453 * t);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, vec2 t){\n    return fract(", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.00001;\n}\n\n// creates white noise in the range 0..1 excluding 0 including 1\nfloat rand_exclusive_inclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.000005;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.000015;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive_2(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.00001;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive_3(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.000005;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand_exclusive_exclusive_4(vec2 p", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to radius of sphere\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r --> is torus radius\n// input R --> is torus tube radius\n// pretty simple, just compare point to radius of sphere\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to radius of sphere\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to radius of sphere\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c is the sin/cos of the angle, respectively\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.x;\n    float d2 = max(q.y, c.x);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for capsule\n// input r --> is capsule radius\n// input h --> is caps", "\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\n//  \n// think of the cylinder as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder height from that \nfloat sdCylinder(vec3 p, vec2 c)\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n// \tc.x = cone radius\n//\tc.y = cone height\n//  \n// think of the cone as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone height from that \nfloat sdCone(vec3 p, vec2 c)\n{\n\t// c.x = radius, c.y = height\n\t// c.y = sqrt(c.x^2 + c.y^2)\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat d1 = -q.y-c.y;\n\tfloat d2 = max(dot(q,q),.25)-c.x*c.x;\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// ~~~~~~~ signed distance function for capsule\n// input c -->", "\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / K, 0.0, 1.0 );\n    return mix( d2, d1, h ) - K * h * (1.0 - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothing factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothing factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float r )\n{\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h) + r * (1.0 - h) * h * (1.0 - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothing factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float r", "\n    return max(d1,d2);\n}\n\n// ~~~~~~~ distance difference, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opDifference( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ distance intersection, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// ~~~~~~~ distance union, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// ~~~~~~~ distance subtraction, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// ~~~~~~~ distance XOR, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opXor( float d1, float d2 )\n{\n    return abs(d1-d2);\n}\n\n// ~~~~~~~ distance absolute difference, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opAbsDifference( float d1, float d2 )\n{\n    return abs(d1-d2);\n}\n\n// ~~~~~~~ distance absolute subtraction, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output -->", "\n    float c = cos(yaw);\n    float s = sin(yaw);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x,q.y,q.z+t*q.x);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t )\n{\n    float c = cos(t*p.y);\n    float s = sin(t*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x,q.y,q.z+t*q.x);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n    float c = cos(yaw);\n    float s = sin(yaw);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    float c2 = cos(pitch);\n    float s2 = sin(pitch);\n    m = mat2(c2,-s2,s2,c2);\n    q.xz = m*q.xz;\n    return vec3(q.x,q.y,q.z+t*q.x);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain de", "\n    if (o1.x < o2.x) return o1;\n    if (o2.x < o1.x) return o2;\n    return o1;\n}\n\n// ~~~~~~~ do Union / combine 3 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3)\n{\n    return opU(opU(o1, o2), o3);\n}\n\n// ~~~~~~~ do Union / combine 4 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3, vec2 o4)\n{\n    return opU(opU(o1, o2), opU(o3, o4));\n}\n\n// ~~~~~~~ do Union / combine 5 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3, vec2 o4, vec2 o5)\n{\n    return opU(opU(o1, o2), opU(o3, opU(o4, o5)));\n}\n\n// ~~~~~~~ do Union / combine 6 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2, vec2 o3, vec2 o4, vec2 o5, vec2 o6)\n{\n    return opU(opU(o1, o2), opU(o3, opU(o4, opU(o5, o6))));\n}\n\n// ~~~~~~~ do Union / combine 7 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n", "\n    // sphere\n    float d = sdSphere(p, 1.0);\n    // plane\n    d = min(d, sdPlane(p, vec3(0.0, 1.0, 0.0)));\n    // box\n    d = min(d, sdBox(p, vec3(1.0, 0.2, 0.2)));\n    // cylinder\n    d = min(d, sdCylinder(p, vec2(0.0, -1.0), 0.2));\n    // torus\n    d = min(d, sdTorus(p, vec2(0.2, 0.1)));\n    // capsule\n    d = min(d, sdCapsule(p, vec3(-1.3, 0.1, 0.0), vec3(-0.8, 0.5, 0.0), 0.1));\n    // cone\n    d = min(d, sdCone(p, vec3(0.0), vec3(0.0, -0.5, 0.0), 0.15));\n    // rounded cone\n    d = min(d, sdRoundCone(p, vec3(0.0), vec3(0.0, -0.5, 0.0), 0.1, 0.05));\n    // rounded box\n    d = min(d, sdRoundBox(p, vec3(1.0), 0.1, 0.1));\n    // rounded cylinder\n    d = min(d, sdRoundCylinder(p, vec2(0.0), 0.2, 0.1));\n    // polyhedron\n    d = min(d, sdPolyhedron(p, 0.5));\n    // tetrahedron\n    d = min(d, sdTetrahedron(p, 0.5));\n    // octahedron\n    d = min(d, sdOctahedron(p, 0.5));\n    // dodecahedron\n    d = min(d, sdDodecahedron(p, 0.5));\n    // icosahedron\n    d = min(d, sdIcosahedron(p, 0.5));\n    // icosphere\n    d = min(d, sdIcosphere(p, ", "\n\tvec2 res = vec2(-1.0);\n\tfloat t = 0.0;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tvec3 p = ro + rd*t;\n\t\tfloat d = map( p );\n\t\tif( d<0.001 )\n\t\t{\n\t\t\tres = vec2(t, mapID(p) );\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t}\n\treturn res;\n}\n\n// ~~~~~~~ get the normal of a point on the surface\n// input p --> point on the surface\n// output is the normal of the surface at that point\n//\nvec3 calcNormal( vec3 p )\n{\n\tvec2 e = vec2(0.001,0.0);\n\tvec3 n = vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t);\n\treturn normalize(n);\n}\n\n// ~~~~~~~ get the color of a point on the surface\n// input p --> point on the surface\n// output is the color of the surface at that point\n//\nvec3 getColor( vec3 p )\n{\n\tvec3 c = vec3(0.0);\n\tfloat d = map(p);\n\tif( d<0.001 )\n\t{\n\t\tvec3 n = calcNormal(p);\n\t\tfloat b = max(0.0, dot(n, normalize(vec3(0.0,0.0,1.0))) );\n\t\tc = vec3(b);\n\t}\n\treturn c;\n}\n\n// ~~~~~~~ get the color of a point on the surface\n// input p --> point on the surface\n// output is the color of the surface at that point\n//\nvec3 getColor( vec3 p, vec3 rd )\n{\n\tvec3 c = vec3(0.0);\n\tfloat d = map(p);\n\tif( d<0.001 )\n\t{", "\n    // ~~~~~~~ raymarching --> find closest surface\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = sdScene(p);\n        t += d;\n        if (d < 0.001)\n        {\n            // ~~~~~~~ shading --> apply color\n            vec3 n = calcNormal(p);\n            vec3 c = vec3(0.0);\n            c += 0.2 * vec3(0.5, 0.7, 1.0);\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(1.0, 0.0, 0.0))));\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(-1.0, 0.0, 0.0))));\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(0.0, 1.0, 0.0))));\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(0.0, -1.0, 0.0))));\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(0.0, 0.0, 1.0))));\n            c += 0.8 * vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, normalize(vec3(0.0, 0.0, -1.0))));\n            return c;\n        }\n    }\n    return vec3(0.0);\n}\n\n// ~~~~~~~ main --> render image\nvoid main()\n{\n    // ~~~~~~~ camera --> set up", "\n    vec3 camDir = normalize(targetPos - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    return mat3( camRight, camUp, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos )\n{\n    return setCamera( camPos, targetPos, 0.0 );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 upDir, float roll )\n{\n    vec3 camDir = normalize(targetPos - camPos);\n    vec3 camRight = normalize(cross(upDir, camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    return mat3( camRight, camUp, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 upDir )\n{\n    return setCamera( camPos, targetPos, upDir, 0.0 );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 upDir, in vec3 camDir )\n{\n    vec3 camRight = normalize(cross(upDir, camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    return mat3( cam", "\n    if(id == 0.0) return color0;\n    if(id == 1.0) return color1;\n    if(id == 2.0) return color2;\n    if(id == 3.0) return color3;\n    if(id == 4.0) return color4;\n    if(id == 5.0) return color5;\n    if(id == 6.0) return color6;\n    if(id == 7.0) return color7;\n    if(id == 8.0) return color8;\n    if(id == 9.0) return color9;\n    if(id == 10.0) return color10;\n    if(id == 11.0) return color11;\n    if(id == 12.0) return color12;\n    if(id == 13.0) return color13;\n    if(id == 14.0) return color14;\n    if(id == 15.0) return color15;\n    if(id == 16.0) return color16;\n    if(id == 17.0) return color17;\n    if(id == 18.0) return color18;\n    if(id == 19.0) return color19;\n    if(id == 20.0) return color20;\n    if(id == 21.0) return color21;\n    if(id == 22.0) return color22;\n    if(id == 23.0) return color23;\n    if(id == 24.0) return color24;\n    if(id == 25.0) return color25;\n    if(id == 26.0) return color26;\n    if(id == 27.0) return color27;\n    if(id == 28.0) return color28;\n    if(id == 29.0) return color29;\n    if(id == 30.0) return color30;\n    if(id == 31.0) return color31;\n    if(id == 32.0) return color32;\n    if(id", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\n//  c.z = cylinder axis\n//  \n// think of the cylinder as a circle wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder height from that \nfloat sdCylinder(vec3 p, vec3 c)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - c.xy;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n//  c.x = cone radius\n//  c.y = cone height\n//  c.z = cone axis\n//  \n// think of the cone as a circle wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cone circumference/core/radius which is flat on the y axis\n// then simply subtract the cone height from that \nfloat sdCone(vec3 p, vec3 c)\n{\n    // c.z = cone axis\n    // c.x = cone radius\n    // c.y = cone height\n    // p.xz = flattened y axis\n    // p.y = y axis\n    // d.x = distance to cone circumference/core/radius\n    // d.y = distance to cone top\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max(dot(q,q),.25)-c.x*c.x;\n   ", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input bs --> specs of box\n//        bs.x --> size x\n//        bs.y --> size y\n//        bs.z --> size z\nfloat sdBox(vec3 p, vec3 bs)\n{\n    vec3 d = abs(p) - bs;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ss --> specs of sphere\n//        ss.x --> radius\nfloat sdSphere(vec3 p, vec3 ss)\n{\n    return length(p) - ss.x;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input cs --> specs of cylinder\n//        cs.x --> radius\n//        cs.y --> height\nfloat sdCylinder(vec3 p, vec3 cs)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - cs.xy;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input cs --> specs of cone\n//        cs.x --> radius\n//        cs.y --> height\nfloat sdCone(vec3 p, vec3 cs)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d1 = -q.y - cs.y;\n    float d2 = max(dot(q,q),cs.x*cs.x);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.0);\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ts --> specs of torus\n//        ts.x --> radius\n//        ts.y --> tube radius\nfloat sdTorus(vec3 p, vec3 ts)\n{\n    vec2 q = vec2(length(p.xz)-ts.x,p.y);\n    return length(q)-", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float d3, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float h2 = clamp( 0.5 + 0.5*(d3-d2)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float d3, float d4, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float h2 = clamp( 0.5 + 0.5*(d3-d2)/k, 0.0, 1.0 );\n    float h3 = clamp( 0.5 + 0.5*(d4-d3)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from i", "\n    vec4 res = vec4(0.0);\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = min(d1, d2);\n    if(d1 < d2)\n    {\n        res.x = d1;\n        res.yzw = o1.yzw;\n    }\n    else\n    {\n        res.x = d2;\n        res.yzw = o2.yzw;\n    }\n    return res;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, vec4 bf)\n{\n    vec4 res = vec4(0.0);\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = min(d1, d2);\n    if(d1 < d2)\n    {\n        res.x = d1;\n        res.yzw = o1.yzw;\n    }\n    else\n    {\n        res.x = d2;\n        res.yzw = o2.yzw;\n    }\n    return res;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, vec3 bf)\n{\n    vec4 res = vec4(0.0);\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = min(d1, d2);\n    if(d1 < d2)\n    {\n        res.x = d1;\n        res.yzw = o1.yzw;\n    }\n    else\n   ", "\n    return max(-d1,d2);\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference(float d1,float d2)\n{\n    return max(-d1,-d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference2(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference3(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing w", "\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    if(lightType == 0)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 1)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 2)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 3)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 4)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 5)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 6)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 7)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 8)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 9)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 10)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 11)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 12)\n    {\n        lightPos = vec3(0.0, 0.0, 0.0);\n    }\n    else if(lightType == 13)\n    {\n        lightPos = vec3(0.0, 0.0, 0.", "\n    // ~~~~~~~ map out the world\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    vec4 res = vec4(1.0);\n    float d = 10000.0;\n    for (int i = 0; i < 10; i++)\n    {\n        // ~~~~~~~ map out the world\n        // input p --> is ray position\n        // basically find the object/point closest to the ray by\n        // checking all the objects with respect to p\n        // move objects/shapes by messing with p\n        // outputs closest distance and blended colors for that surface as a vec4\n        vec4 obj = map_obj(p);\n        if (obj.a < d)\n        {\n            d = obj.a;\n            res = obj;\n        }\n    }\n    return res;\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 raymarch(vec3 p)\n{\n    // ~~~~~~~ raymarching\n    // input p --> is ray position\n    // basically find the object/point closest to the ray by\n    // checking all the objects with respect to p\n    // move objects/shapes by messing with p\n    // outputs closest distance and blended colors for that surface as a vec4\n    vec4 res = vec4(0.0);\n    float d = 0.0;\n    for (int i = 0; i < 64; i++)\n    {\n        // ~~~~~~~ raymarching\n        // input p --> is ray position\n        // basically find the object/point closest to the ray by\n        // checking all the objects with respect to p\n        // move objects/shapes by messing with p\n        // outputs closest distance and blended colors for that surface as a vec4\n        vec4 obj = map(p);\n        d += obj.a;\n        res = obj;\n        p += obj.rgb * 0", "\n    // ~~~~~~~ cast ray through the word and see what it hits\n    // input ro --> ray origin point/position\n    // input rd --> ray direction\n    // in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n    // output is vec3 where\n    // .x = distance travelled by ray\n    // .y = hit object's ID\n    // .z = itteration ratio\n    vec4 hit = vec4(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    float id = 0.0;\n    float itter = 0.0;\n    float itterMax = 100.0;\n    float itterMin = 0.0001;\n    float itterStep = 0.0001;\n    float itterStepMax = 0.000001;\n    float itterStepMin = 0.00000001;\n    float itterStepRatio = 0.0;\n    float itterStepRatioMax = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3  s = normalize(sp - lp);\n    vec3  e = normalize(vec3(0.0, 0.0, 1.0));\n    float k = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        t += 0.001;\n        k = max(k, dot(e, s));\n        s += 0.001 * s;\n    }\n    return k;\n}\n\n// ~~~~~~~ castRay_Shadow\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_Shadow(vec3 sp, vec3 lp)\n{\n    vec3  s = normalize(sp - lp);\n    vec3  e = normalize(vec3(0.0, 0.0, 1.0));\n    float k = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        t += 0.001;\n        k = max(k, dot(e, s));\n        s += 0.001 * s;\n    }\n    return k;\n}\n\n// ~~~~~~~ castRay_Shadow\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_Shadow(vec3 sp, vec3 lp, float bias)\n{\n    vec3  s = normalize(sp - lp);\n    vec3  e = normalize(vec3(0.0, 0.0, 1.0));\n    float k = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        t += 0.001;\n        k = max(k, dot(e, s));\n        s += 0.001 * s;\n    }\n    return k;\n}\n\n// ~~~~~~~ castRay_Shadow\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay", "\n    float t = 0.0;\n    float d = 0.0;\n    float ao = 0.0;\n    float maxd = 0.1;\n    float step = 0.01;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(sp + t * nor);\n        ao += (d * d * step);\n        t += d;\n        if (t > maxd) break;\n    }\n    return clamp(1.0 - ao, 0.0, 1.0);\n}\n\n// ~~~~~~~ lighting\n// basic phong lighting\nvec3 lighting(vec3 sp, vec3 nor, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(0.0, 0.0, 1.0));\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float amb = 0.5;\n    float bac = 0.2;\n    float spe = 0.0;\n    float shi = 10.0;\n    vec3  ambc = vec3(0.2, 0.2, 0.2);\n    vec3  difc = vec3(1.0, 0.8, 0.5);\n    vec3  bacc = vec3(0.4, 0.4, 0.4);\n    vec3  spec = vec3(1.0, 1.0, 1.0);\n    col += (amb * ambc) + (bac * bacc) + (dif * difc);\n    vec3  halfVector = normalize(lig - rd);\n    float specAngle = max(dot(halfVector, nor), 0.0);\n    float specFactor = pow(specAngle, shi);\n    col += spec * specFactor;\n    return col;\n}\n\n// ~~~~~~~ main\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 p2 = p + oN * 0.001 * float(i);\n        vec3 n2 = getNormal(p2);\n        n += n2;\n        d += 1.0;\n    }\n    return n / d;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN, float d)\n{\n    vec3 n = vec3(0.0);\n    float dd = 0.0;\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 p2 = p + oN * 0.001 * float(i);\n        vec3 n2 = getNormal(p2);\n        n += n2;\n        dd += 1.0;\n    }\n    return n / dd;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN, float d, float dd)\n{\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 p2 = p + oN * 0.001 * float(i);\n        vec3 n2 = getNormal(p2);\n        n += n2;\n    }\n    return n / dd;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN, float d, float dd, float ddd)\n{\n    vec3 n = vec3(0.0);\n    for(", "\n    return pow(c, vec3(1.0/2.2));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyToneMapping(vec3 c)\n{\n    return c / (c + vec3(1.0));\n}\n\n// ~~~~~~~ do exposure\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyExposure(vec3 c)\n{\n    return c * exposure;\n}\n\n// ~~~~~~~ do bloom\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyBloom(vec3 c)\n{\n    return c + bloom;\n}\n\n// ~~~~~~~ do vignette\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec3 applyVignette(vec3 c)\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= resolution.x / resolution.y;\n    float vig = pow( 16.0*uv.x*uv.x + uv.y*uv.y, 0.1 );\n    return mix( c, vec3( 0.0 ), vig );\n}\n\n// ~~~~~~~ do color grading\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.", "\n    float f = exp(-fs.x*d);\n    f = pow(f,fs.y);\n    vec3 fc = mix(fc1,fc2,f);\n    float l = dot(cRD,lRD);\n    l = clamp(l,0.0,1.0);\n    return mix(c,fc,l);\n}\n\n// ~~~~~~~ do lighting\n// input c --> original color\n// input l --> light color\n// input lRD --> light ray direction\n// input n --> normal\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with lighting applied\nvec3 applyLighting(vec3 c,vec3 l,vec3 lRD,vec3 n,vec3 cRD,vec3 lRD)\n{\n    float lDotN = dot(lRD,n);\n    lDotN = clamp(lDotN,0.0,1.0);\n    vec3 lC = l*lDotN;\n    float cDotN = dot(cRD,n);\n    cDotN = clamp(cDotN,0.0,1.0);\n    vec3 cC = c*cDotN;\n    return cC+lC;\n}\n\n// ~~~~~~~ do shadows\n// input c --> original color\n// input l --> light color\n// input lRD --> light ray direction\n// input n --> normal\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with shadows applied\nvec3 applyShadows(vec3 c,vec3 l,vec3 lRD,vec3 n,vec3 cRD,vec3 lRD)\n{\n    float lDotN = dot(lRD,n);\n    lDotN = clamp(lDotN,0.0,1.0);\n    vec3 lC = l*lDotN;\n    float cDotN = dot(cRD,n);\n    cDotN = clamp(cDotN,0.0,1.0);\n    vec3 cC = c*cDotN;\n    return cC+lC;\n}\n\n// ~~~~~~~ do reflections\n// input c --> original color\n// input l --> light color\n// input lRD --> light ray direction\n// input n --> normal", "\n\treturn 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates the lighting for a given point on the surface\n// input p --> point on the surface\n// input n --> normal at the point\n// input l --> light position\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nvec3 calculateLighting(vec3 p, vec3 n, vec3 l, float cF, float lF, float qF)\n{\n\tvec3 lightDir = normalize(l - p);\n\tfloat attn = calculateLightAttn(cF, lF, qF, length(l - p));\n\tfloat diffuse = max(dot(n, lightDir), 0.0);\n\tvec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n\tvec3 ambientColor = vec3(0.2, 0.2, 0.2);\n\treturn (diffuseColor * diffuse * attn) + ambientColor;\n}\n\n// ~~~~~~~ calculates the lighting for a given point on the surface\n// input p --> point on the surface\n// input n --> normal at the point\n// input l --> light position\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nvec3 calculateLighting(vec3 p, vec3 n, vec3 l, vec3 cF, vec3 lF, vec3 qF)\n{\n\tvec3 lightDir = normalize(l - p);\n\tfloat attn = calculateLightAttn(cF.x, lF.x, qF.x, length(l - p));\n\tfloat diffuse = max(dot(n, lightDir), 0.0);\n", "\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, 1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = cMatrix * vec3(fCoord, 0.0);\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix, vec3 cPos)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, 1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, vec3 cPos)\n{\n    vec3 rayOrigin = cMatrix * vec3(fCoord, 0.0);\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix, vec3 cPos, vec3 cDir)\n{\n    vec3 rayDir = normalize(cMatrix * vec3(fCoord, 1.0));\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, vec3 cPos, vec3 cDir)\n{\n    vec3 rayOrigin = cMatrix * vec3(fCoord, 0.0);\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n//", "\n    vec3 c = vec3(0.0);\n    vec3 cPos2 = cPos;\n    vec3 cPos3 = cPos;\n    vec3 cPos4 = cPos;\n    vec3 cPos5 = cPos;\n    vec3 cPos6 = cPos;\n    vec3 cPos7 = cPos;\n    vec3 cPos8 = cPos;\n    vec3 cPos9 = cPos;\n    vec3 cPos10 = cPos;\n    vec3 cPos11 = cPos;\n    vec3 cPos12 = cPos;\n    vec3 cPos13 = cPos;\n    vec3 cPos14 = cPos;\n    vec3 cPos15 = cPos;\n    vec3 cPos16 = cPos;\n    vec3 cPos17 = cPos;\n    vec3 cPos18 = cPos;\n    vec3 cPos19 = cPos;\n    vec3 cPos20 = cPos;\n    vec3 cPos21 = cPos;\n    vec3 cPos22 = cPos;\n    vec3 cPos23 = cPos;\n    vec3 cPos24 = cPos;\n    vec3 cPos25 = cPos;\n    vec3 cPos26 = cPos;\n    vec3 cPos27 = cPos;\n    vec3 cPos28 = cPos;\n    vec3 cPos29 = cPos;\n    vec3 cPos30 = cPos;\n    vec3 cPos31 = cPos;\n    vec3 cPos32 = cPos;\n    vec3 cPos33 = cPos;\n    vec3 cPos34 = cPos;\n    vec3 cPos35 = cPos;\n    vec3 cPos36 = cPos;\n    vec3 cPos37 = cPos;\n    vec3 cPos38 = cPos;\n    vec3 cPos39 = cPos;\n    vec3 cPos40 = cPos;\n    vec3 cPos41 = cPos;\n    vec3 cPos42 = cPos;\n    vec3 cPos43 = cPos;\n    vec3 cPos44 = cPos;\n    vec3 cPos45 = cPos;\n    vec3 cPos46 = cPos;\n    vec3 cPos47 = cPos;\n    vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 c = uv * 2.0 - 1.0;\n    c.x *= iResolution.x / iResolution.y;\n    vec2 z = c;\n    float i = 0.0;\n    for( i = 0.0; i < 256.0; i++ )\n    {\n        z = vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n        if( dot( z, z ) > 4.0 ) break;\n    }\n    fragColor = vec4( vec3( i / 256.0 ), 1.0 );\n}\n", "\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// infinite plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\n// infinite cone distance field\nfloat sdCone(in vec3 p, in vec3 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec3(q, p.z));\n}\n\n// infinite cylinder distance field\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// infinite cone distance field\nfloat sdCone(in vec3 p,", "\n    return length(p) - r;\n}\n\n// distance field for a rounded rectangle\nfloat roundedRect(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// distance field for a rounded rectangle with a hole\nfloat roundedRectHole(vec2 p, vec2 b, float r, float h)\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r - h;\n}\n\n// distance field for a rounded rectangle with a hole and a cutout\nfloat roundedRectHoleCutout(vec2 p, vec2 b, float r, float h, float c)\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r - h - c;\n}\n\n// distance field for a rounded rectangle with a hole and a cutout\nfloat roundedRectHoleCutout(vec2 p, vec2 b, float r, float h, float c, float w)\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r - h - c - w;\n}\n\n// distance field for a rounded rectangle with a hole and a cutout\nfloat roundedRectHoleCutout(vec2 p, vec2 b, float r, float h, float c, float w, float s)\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r - h - c - w - s;\n}\n\n// distance field for a rounded rectangle with a hole and a cutout\nfloat roundedRectHoleCutout(vec2 p, vec2 b,", "\n\t// The distance to the nearest surface and the material number\n\tvec2 result = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d2 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d3 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d4 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d5 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d6 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d7 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d8 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d9 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d10 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d11 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2 d12 = vec2(1000000.0, 0.0);\n\n\t// The distance to the nearest surface and the material number\n\tvec2", "\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    return z*z4*z4;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    vec2 z6 = z4*z2;\n    return z*z6*z6;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    vec2 z6 = z4*z2;\n    vec2 z8 = z6*z2;\n    return z*z8*z8;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    vec2 z6 = z4*z2;\n    vec2 z8 = z6*z2;\n    vec2 z10 = z8*z2;\n    return z*z10*z10;\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    vec2 z6 = z4*z2;\n    vec2 z8 = z6*z2;\n    vec2 z10 = z8*z2;\n    vec2 z12 = z10*z2;\n    return z*z12*z12;\n}\n\n//Function that returns a complex number to power of 10\nvec2 complexPower10(vec2 c)\n{\n    vec2 z = c;\n    vec2 z2 = c*c;\n    vec2 z4 = z2*z2;\n    vec2 z6 = z4*z2;\n   ", "\n\tvec2 pos = coord;\n\tvec2 pos2 = coord;\n\tvec2 pos3 = coord;\n\tvec2 pos4 = coord;\n\tvec2 pos5 = coord;\n\tvec2 pos6 = coord;\n\tvec2 pos7 = coord;\n\tvec2 pos8 = coord;\n\tvec2 pos9 = coord;\n\tvec2 pos10 = coord;\n\tvec2 pos11 = coord;\n\tvec2 pos12 = coord;\n\tvec2 pos13 = coord;\n\tvec2 pos14 = coord;\n\tvec2 pos15 = coord;\n\tvec2 pos16 = coord;\n\tvec2 pos17 = coord;\n\tvec2 pos18 = coord;\n\tvec2 pos19 = coord;\n\tvec2 pos20 = coord;\n\tvec2 pos21 = coord;\n\tvec2 pos22 = coord;\n\tvec2 pos23 = coord;\n\tvec2 pos24 = coord;\n\tvec2 pos25 = coord;\n\tvec2 pos26 = coord;\n\tvec2 pos27 = coord;\n\tvec2 pos28 = coord;\n\tvec2 pos29 = coord;\n\tvec2 pos30 = coord;\n\tvec2 pos31 = coord;\n\tvec2 pos32 = coord;\n\tvec2 pos33 = coord;\n\tvec2 pos34 = coord;\n\tvec2 pos35 = coord;\n\tvec2 pos36 = coord;\n\tvec2 pos37 = coord;\n\tvec2 pos38 = coord;\n\tvec2 pos39 = coord;\n\tvec2 pos40 = coord;\n\tvec2 pos41 = coord;\n\tvec2 pos42 = coord;\n\tvec2 pos43 = coord;\n\tvec2 pos44 = coord;\n\tvec2 pos45 = coord;\n\tvec2 pos46 = coord;\n\tvec2 pos47 = coord;\n\tvec2 pos48 = coord;\n\tvec2 pos49 = coord;\n\tvec2 pos50 = coord;\n\tvec2 pos51 = coord;\n\tvec2 pos52 = coord;\n\t", "\n\tvec4 color = vec4(0.0);\n\tfloat totalWeight = 0.0;\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 offset = vec2(i, j) * constant;\n\t\t\tvec4 sample = texture(biomorph, uv + offset);\n\t\t\tfloat weight = 1.0 - (abs(offset.x) + abs(offset.y));\n\t\t\tcolor += sample * weight;\n\t\t\ttotalWeight += weight;\n\t\t}\n\t}\n\treturn color / totalWeight;\n}\n\n//The main function\nvoid main()\n{\n\t//Get the UV coordinates\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\t//Get the color of the biomorph\n\tvec4 color = antiAliasedBiomorph(uv, 1.0 / resolution.xy);\n\n\t//Output the color\n\tfragColor = color;\n}\n", "\n\treturn fract(x);\n}\n\n// A triangle wave that repeats every 1.0\nfloat repeat1(float x) {\n\treturn fract(x) * 2.0 - 1.0;\n}\n\n// A triangle wave that repeats every 2.0\nfloat repeat2(float x) {\n\treturn fract(x * 0.5) * 4.0 - 1.0;\n}\n\n// A triangle wave that repeats every 4.0\nfloat repeat4(float x) {\n\treturn fract(x * 0.25) * 8.0 - 1.0;\n}\n\n// A triangle wave that repeats every 8.0\nfloat repeat8(float x) {\n\treturn fract(x * 0.125) * 16.0 - 1.0;\n}\n\n// A triangle wave that repeats every 16.0\nfloat repeat16(float x) {\n\treturn fract(x * 0.0625) * 32.0 - 1.0;\n}\n\n// A triangle wave that repeats every 32.0\nfloat repeat32(float x) {\n\treturn fract(x * 0.03125) * 64.0 - 1.0;\n}\n\n// A triangle wave that repeats every 64.0\nfloat repeat64(float x) {\n\treturn fract(x * 0.015625) * 128.0 - 1.0;\n}\n\n// A triangle wave that repeats every 128.0\nfloat repeat128(float x) {\n\treturn fract(x * 0.0078125) * 256.0 - 1.0;\n}\n\n// A triangle wave that repeats every 256.0\nfloat repeat256(float x) {\n\treturn fract(x * 0.00390625) * 512.0 - 1.0;\n}\n\n// A triangle wave that repeats every 512.", "\n    // This is the distance from the line to the point.\n    float dist = DistanceToLine(uv, pA, pB, thick.y);\n    // This is the distance from the line to the point, but only if it's on the line.\n    float distOnLine = DistanceToLine(uv, pA, pB, 0.0);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is not on the rounded end points.\n    float distOnLineNoRound = DistanceToLine(uv, pA, pB, thick.y - rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points.\n    float distOnLineRound = DistanceToLine(uv, pA, pB, rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points and the point is on the dash.\n    float distOnLineRoundDash = DistanceToLine(uv, pA, pB, thick.y - rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points and the point is on the dash.\n    float distOnLineRoundDash2 = DistanceToLine(uv, pA, pB, thick.y - rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points and the point is on the dash.\n    float distOnLineRoundDash3 = DistanceToLine(uv, pA, pB, thick.y - rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points and the point is on the dash.\n    float distOnLineRoundDash4 = DistanceToLine(uv, pA, pB, thick.y - rounded);\n    // This is the distance from the line to the point, but only if it's on the line and\n    // the point is on the rounded end points and the point is on the dash.\n    float distOnLineRoundDash", "\n\tvec2 dir = normalize(pB - pA);\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 pC = pA + dir * thick.x;\n\tvec2 pD = pB + dir * thick.x;\n\tvec2 pE = pA - dir * thick.y;\n\tvec2 pF = pB - dir * thick.y;\n\tfloat a = Line(uv, pC, pD, rounded);\n\tfloat b = Line(uv, pE, pF, rounded);\n\treturn max(a, b);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n\tvec2 dir = normalize(pB - pA);\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 pC = pA + dir * thick;\n\tvec2 pD = pB + dir * thick;\n\tvec2 pE = pA - dir * thick;\n\tvec2 pF = pB - dir * thick;\n\tfloat a = Line(uv, pC, pD, rounded);\n\tfloat b = Line(uv, pE, pF, rounded);\n\treturn max(a, b);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float rounded) {\n\tvec2 dir = normalize(pB - pA);\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 pC = pA + dir;\n\tvec2 pD = pB + dir;\n\tvec2 pE = pA - dir;\n\tvec2 pF = pB - dir;\n\tfloat a = Line(uv, pC, pD, rounded);\n\tfloat b = Line(uv, pE, pF, rounded);\n\treturn max(a, b", "\n\tfloat dist = DistanceToLine(uv, pA, pB, rounded);\n\tfloat dist2 = DistanceToLine(uv, pA, pB, rounded + outlineThick);\n\treturn smoothstep(dist2, dist, thick);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n\treturn DrawOutlinePix(uv, pA, pB, thick, rounded, 1.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n\treturn DrawOutlinePix(uv, pA, pB, thick, 0.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB) {\n\treturn DrawOutlinePix(uv, pA, pB, vec2(1.0));\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float rounded, float outlineThick) {\n\tfloat dist = DistanceToLine(uv, pA, pB, rounded);\n\tfloat dist2 = DistanceToLine(uv, pA, pB, rounded + outlineThick);\n\treturn smoothstep(dist2, dist, 1.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, float rounded) {\n\treturn DrawOutlinePix(uv, pA, pB, rounded, 1.0);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be ", "\n\tvec2 dir = normalize(pB - pA);\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tvec2 p = uv - pA;\n\tfloat dist = dot(p, perp);\n\tfloat dist2 = dot(p, dir);\n\tfloat dist3 = dot(p, perp) - thick.x;\n\tfloat dist4 = dot(p, dir) - thick.y;\n\tfloat dist5 = dot(p, perp) - thick.x + rounded;\n\tfloat dist6 = dot(p, dir) - thick.y + rounded;\n\tfloat dist7 = dot(p, perp) - thick.x - rounded;\n\tfloat dist8 = dot(p, dir) - thick.y - rounded;\n\tfloat dist9 = dot(p, perp) - thick.x + rounded * 2.0;\n\tfloat dist10 = dot(p, dir) - thick.y + rounded * 2.0;\n\tfloat dist11 = dot(p, perp) - thick.x - rounded * 2.0;\n\tfloat dist12 = dot(p, dir) - thick.y - rounded * 2.0;\n\tfloat dist13 = dot(p, perp) - thick.x + rounded * 3.0;\n\tfloat dist14 = dot(p, dir) - thick.y + rounded * 3.0;\n\tfloat dist15 = dot(p, perp) - thick.x - rounded * 3.0;\n\tfloat dist16 = dot(p, dir) - thick.y - rounded * 3.0;\n\tfloat dist17 = dot(p, perp) - thick.x + rounded * 4.0;\n\tfloat dist18 = dot(p, dir) - thick.y + rounded * 4.0;\n\tfloat dist19 = dot(p, perp) - thick.x - rounded * 4.0;\n\tfloat dist20 = dot(p, dir) - thick.y - rounded * 4.0;\n\tfloat dist21 = dot(", "\n\tvec2 dir = normalize(pB - pA);\n\tvec2 perp = vec2(-dir.y, dir.x);\n\tfloat len = length(pB - pA);\n\tfloat dist = distance(uv, pA);\n\tfloat dist2 = distance(uv, pB);\n\tfloat dist3 = distance(uv, pA + dir * len * 0.5);\n\tfloat dist4 = distance(uv, pB - dir * len * 0.5);\n\tfloat dist5 = distance(uv, pA + dir * len * 0.25);\n\tfloat dist6 = distance(uv, pB - dir * len * 0.25);\n\tfloat dist7 = distance(uv, pA + dir * len * 0.75);\n\tfloat dist8 = distance(uv, pB - dir * len * 0.75);\n\tfloat dist9 = distance(uv, pA + dir * len * 0.125);\n\tfloat dist10 = distance(uv, pB - dir * len * 0.125);\n\tfloat dist11 = distance(uv, pA + dir * len * 0.375);\n\tfloat dist12 = distance(uv, pB - dir * len * 0.375);\n\tfloat dist13 = distance(uv, pA + dir * len * 0.625);\n\tfloat dist14 = distance(uv, pB - dir * len * 0.625);\n\tfloat dist15 = distance(uv, pA + dir * len * 0.875);\n\tfloat dist16 = distance(uv, pB - dir * len * 0.875);\n\tfloat dist17 = distance(uv, pA + dir * len * 0.0625);\n\tfloat dist18 = distance(uv, pB - dir * len * 0.0625);\n\tfloat dist19 = distance(uv, pA + dir * len * 0.2125);\n\tfloat dist20 = distance(uv, pB - dir * len * 0.2125);\n\tfloat", "\n\tfloat dist = DistanceToLine(uv, pA, pB, rounded);\n\tfloat distThick = DistanceToLine(uv, pA, pB, rounded + outlineThick);\n\tfloat distThick2 = DistanceToLine(uv, pA, pB, rounded - outlineThick);\n\tfloat distThick3 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 2);\n\tfloat distThick4 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 2);\n\tfloat distThick5 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 3);\n\tfloat distThick6 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 3);\n\tfloat distThick7 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 4);\n\tfloat distThick8 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 4);\n\tfloat distThick9 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 5);\n\tfloat distThick10 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 5);\n\tfloat distThick11 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 6);\n\tfloat distThick12 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 6);\n\tfloat distThick13 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 7);\n\tfloat distThick14 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 7);\n\tfloat distThick15 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 8);\n\tfloat distThick16 = DistanceToLine(uv, pA, pB, rounded - outlineThick * 8);\n\tfloat distThick17 = DistanceToLine(uv, pA, pB, rounded + outlineThick * 9", "\n\tfloat d = length(uv - p);\n\tfloat a = smoothstep(0.0, 0.002, d);\n\tcol = mix(col, vec3(1.0), a);\n}\n\n// This is the main function that does all the work.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\n\t// Draw a grid\n\tfloat grid = 0.0;\n\tfor (float i = 0.0; i < 1.0; i += 0.01) {\n\t\tgrid += smoothstep(0.0, 0.002, abs(uv.x - i));\n\t}\n\tcol = mix(col, vec3(1.0), grid);\n\n\t// Draw a point\n\tDrawPoint(uv, vec2(0.5, 0.5), col);\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n", "\n    vec3  d = ro - cen;\n    float b = dot(nor,d);\n    float c = dot(d,d) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 cen, float rad )\n{\n    vec3  d = ro - cen;\n    float b = dot(d,rd);\n    float c = dot(d,d) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 boxMin, in vec3 boxMax )\n{\n    vec3  m = 1.0/rd;\n    vec3  n = m*ro;\n    vec3  k = abs(m)*(boxMax-boxMin);\n    vec3  t1 = -n - k;\n    vec3  t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return -1.0;\n    return tN;\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 nor, float off )\n{\n    float den = dot(nor,rd);\n    if( den==0.0 ) return -1.0;\n    return -(dot(nor,ro)+off)/den;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3  ba = b - a;\n    vec3  pa = ro - a;\n    vec3  cb = c - b;\n    vec3  pb = ro -", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(n) - rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float n = dot( pla.xyz, rd );\n    if( n==0.0 ) return vec2(-1.0);\n    return vec2( -dot( pla.xyz, ro )/n );\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 s1 = cross( rd, e2 );\n    float div = dot( s1, e1 );\n    if( div>0.0001 )\n    {\n        vec3 s = ro - v0;\n        float u = dot( s, s1 ) / div;\n        vec3 s2 = cross( s, e1 );\n        float v = dot( rd, s2 ) / div;\n        float t = dot( e2, s2 ) / div;\n        if( (u>=0.0)&&(v>=0", "\n    vec3  ba  = pb - pa;\n    float h   = length(ba);\n    float r   = ra;\n    float rr  = r*r;\n    float hh  = h*h;\n\n    float a = 0.5/hh;\n    float b = 0.5*rr/hh;\n    float c = -a;\n    float d = -b;\n\n    float e = -pa.x*ba.x - pa.y*ba.y - pa.z*ba.z;\n    float f = e + a*pa.x*pa.x + b*pa.y*pa.y + c*pa.z*pa.z + d*h;\n\n    float k = 0.5*sqrt( max( f*f - 4.0*e, 0.0 ) );\n    float t1 = f - k;\n    float t2 = f + k;\n\n    vec3  pt1 = pa + ba*clamp( t1, 0.0, h );\n    vec3  pt2 = pa + ba*clamp( t2, 0.0, h );\n\n    vec3  pt3 = vec3( -r, pt1.yz );\n    vec3  pt4 = vec3(  r, pt1.yz );\n    vec3  pt5 = vec3( -r, pt2.yz );\n    vec3  pt6 = vec3(  r, pt2.yz );\n\n    vec3  pt7 = vec3( pt1.x, -r, pt1.z );\n    vec3  pt8 = vec3( pt1.x,  r, pt1.z );\n    vec3  pt9 = vec3( pt2.x, -r, pt2.z );\n    vec3  pt10 = vec3( pt2.x,  r, pt2.z );\n\n    vec3  pt11 = vec3( pt1.xy, -r );\n    vec3  pt12 = vec3( pt1.xy,  r );\n    vec3  pt13 = vec3( pt2.xy, -r );\n    vec3  pt14 = vec3( pt2.xy,  r );\n\n    return bound3( min( min( min( min( min( min( min( min( min( min(", "\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float ocda = dot(oc,rd);\n    float ocdb = dot(oc,ba);\n    float ocoa = dot(oc,oc);\n    float h = ocoa*baba-ocdb*ocdb;\n    float k = baba*ocda-ocdb*ocda;\n    float q = k*k-h*(baba*ra*ra-ocdb*ocdb);\n    if( q<0.0 ) return vec4(-1.0);\n    float t = (-k-sqrt(q))/h;\n    vec3 pt = ro+rd*t;\n    vec3 pc = pt-pa;\n    float m = dot(ba,pc)/baba;\n    vec3 n = normalize( pc - ba*m );\n    return vec4(t, m, n);\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec4 pl ) // plane: normal.xyz, distance\n{\n    float t = (pl.w - dot(pl.xyz,ro))/dot(pl.xyz,rd);\n    return vec4(t, pl.xyz);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec4 sp ) // sphere: position.xyz, radius\n{\n    vec3 oc = ro - sp.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sp.w*sp.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0);\n    float t = -b - sqrt(h);\n    vec3 pt = ro + t*rd;\n    vec3 pc = pt - sp.xyz;\n    float m = length(pc)/sp.w;\n    vec3 n = pc/sp.w;\n    return vec4(t, m, n);\n}\n\n// ray-box intersection (returns t and normal)\nvec4 iBox( in vec3 ro, in vec3 rd, in vec3 box", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(n) - rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float n = dot( pla.xyz, rd );\n    if( n==0.0 ) return vec2(-1.0);\n    return vec2( -dot( pla.xyz, ro )/n );\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 s1 = cross( rd, e1 );\n    float div = dot( s1, e0 );\n    if( div>0.0001 )\n    {\n        vec3 s = ro - v0;\n        float u = dot( s, s1 ) / div;\n        vec3 s2 = cross( s, e0 );\n        float v = dot( rd, s2 ) / div;\n        float t = dot( e1, s2 ) / div;\n        if( (u>=0.0)&&(v>=0", "\n    vec3 ba = pb - pa;\n    vec3 oc = ro - pa;\n    float baba = dot( ba, ba );\n    float bard = dot( ba, rd );\n    float ocda = dot( oc, rd );\n    float ocbp = dot( oc, ba );\n    float s = ocbp / bard;\n    float t = clamp( ocda + bard * s, 0.0, baba );\n    float d2 = dot( oc, oc ) - t * ( t + 2.0 * ocbp );\n    float h = clamp( r * r - d2, 0.0, r * r );\n    float m = sqrt( h * ( h + 2.0 * d2 ) );\n    float t2 = clamp( baba * s - ocbp - m, 0.0, baba );\n    if( t2 < 0.0 ) return -1.0;\n    float t1 = clamp( ocbp - m, 0.0, baba );\n    return t1 + t2;\n}\n\n// intersect cylinder : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3 ba = pb - pa;\n    vec3 oc = ro - pa;\n    float baba = dot( ba, ba );\n    float bard = dot( ba, rd );\n    float ocda = dot( oc, rd );\n    float ocbp = dot( oc, ba );\n    float s = ocbp / bard;\n    float t = clamp( ocda + bard * s, 0.0, baba );\n    float d2 = dot( oc, oc ) - t * ( t + 2.0 * ocbp );\n    float h = clamp( r * r - d2, 0.0, r * r );\n    float m = sqrt( h * ( h + 2.0 * d2 ) );\n    float t2 = clamp( baba * s - ocbp - m, 0.0, baba );\n    if( t2 < 0.0 ) return -1.0;\n    float t1 =", "\n    vec3 ba = b - a;\n    vec3 pa = pos - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return normalize( pa - ba*h - a*r );\n}\n\n// compute lighting\nvec3 lighting( in vec3 pos, in vec3 nor )\n{\n    vec3 lig = normalize(vec3(0.5,0.2,1.0));\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float bac = clamp( dot(nor,vec3(-lig.x,lig.y,0.0)), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep(-0.1,0.1,nor.y);\n    float fre = pow( clamp(1.0+dot(nor,vec3(0.0,0.0,1.0)),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( reflect(vec3(0.0,0.0,1.0), nor), lig ), 0.0, 1.0 ),16.0);\n    return vec3(0.35,0.35,0.35)*dif + vec3(0.35,0.35,0.35)*bac + vec3(0.25,0.27,0.25)*dom + vec3(0.10,0.09,0.08)*fre + vec3(0.25,0.25,0.25)*spe;\n}\n\n// compute shadow\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.3 );\n        if( res<", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection in box space\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 oc = ro - vec3(0.5);\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-plane intersection in box space\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float h ) \n{\n    float d = dot( n, ro ) + h;\n    float v = dot( n, rd );\n    if( abs(v)<0.001 ) return vec2(-1.0);\n    return vec2( -d/v );\n}\n\n// ray-cylinder intersection in box space\nvec2 iCylinder( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 oc = ro - vec3(0.5);\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-cone intersection in box space\nvec2 iCone( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 oc = ro - vec3(0.5);\n    float b =", "\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float d = map( p );\n        if( d<0.001 || t>20.0 ) break;\n        t += d;\n    }\n\n    if( t>20.0 ) t = -1.0;\n    return vec4( ro+t*rd, t );\n}\n\n// raymarch\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// raymarch\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec4 res = interesect( ro, rd );\n    if( res.w>0.0 )\n    {\n        vec3 pos = res.xyz;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\n        // material\n        col = vec3(0.45,0.45,0.45);\n        if( pos.y<0.0 ) col = vec3(0.0,0.1,0.2);\n        if( pos.y>0.0 ) col = vec3(0.2,0.1,0.0);\n\n        // lighting\n        float occ = clamp( 1.0 - 5.0*pos.y, 0.0, 1.0 );\n        float amb = 0.5 + 0.5*nor.y;\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float bac = clamp( dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0", "\n    float phi = 2.0 * PI * i / n;\n    float theta = acos(1.0 - 2.0 * i / n);\n    float x = sin(theta) * cos(phi);\n    float y = sin(theta) * sin(phi);\n    float z = cos(theta);\n    return vec3(x, y, z);\n}\n\n// inverse spheric fibonacci mapping\nvec3 inverseSF(vec3 v)\n{\n    float phi = atan(v.y, v.x);\n    float theta = acos(v.z);\n    float i = theta / PI;\n    float n = 2.0 * i;\n    return vec3(phi, n, i);\n}\n\n// spherical fibonacci mapping\nvec3 sfMapping(vec3 v)\n{\n    vec3 sf = inverseSF(v);\n    float phi = sf.x;\n    float n = sf.y;\n    float i = sf.z;\n    float theta = acos(1.0 - 2.0 * i / n);\n    float x = sin(theta) * cos(phi);\n    float y = sin(theta) * sin(phi);\n    float z = cos(theta);\n    return vec3(x, y, z);\n}\n\n// inverse spherical fibonacci mapping\nvec3 sfMappingInverse(vec3 v)\n{\n    float phi = atan(v.y, v.x);\n    float theta = acos(v.z);\n    float i = theta / PI;\n    float n = 2.0 * i;\n    return vec3(phi, n, i);\n}\n\n// spherical fibonacci mapping\nvec3 sfMapping(vec3 v, float n)\n{\n    vec3 sf = inverseSF(v);\n    float phi = sf.x;\n    float i = sf.z;\n    float theta = acos(1.0 - 2.0 * i / n);\n    float x = sin(theta) * cos(phi);\n    float y = sin(theta) * sin(phi);\n    float z = cos(theta);\n    return vec3(x, y, z);\n}\n\n// inverse spherical fibonacci mapping\nvec3 sfMappingInverse(vec3 v, float n)\n{\n    float phi = atan(v.y,", "\n    // raymarching\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float d = map( p );\n        if( d<0.001 )\n        {\n            resS = mat3( 1.0 );\n            return vec4( p, d );\n        }\n        t += d;\n    }\n    return vec4( 0.0 );\n}\n\n// normal\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// lighting\nvec3 calcLighting( in vec3 pos, in vec3 nor )\n{\n    vec3 lig = normalize(vec3(0.0,0.0,1.0));\n    vec3 col = vec3(0.0);\n    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n    float bac = clamp( dot(nor,normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0 );\n    float dom = smoothstep( -0.1, 0.1, ref.x-pos.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref.z*nor, lig ), 0.0, 1.0 ),16.0);\n    col = vec3(0.0);\n    col += 0.30*dif;\n    col += 0.50*spe;\n    col += 0.25*bac;\n    col += 0.25*dom;\n    col += ", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = random( i );\n    float b = random( i + vec2( 1.0, 0.0 ) );\n    float c = random( i + vec2( 0.0, 1.0 ) );\n    float d = random( i + vec2( 1.0, 1.0 ) );\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return vec3( a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n// Classic Perlin noise\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor( p + (p.x+p.y)*K1 );\n\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y)? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n    vec3", "\n\tvec2 d = abs(p) - size + radius;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size)\n{\n\tvec2 d = abs(p) - size;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat boxDist(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(max(d.x, d.y), d.z), 0.0) + length(max(d, 0.0));\n}\n\nfloat boxDist(vec3 p, vec3 size, float radius)\n{\n\tvec3 d = abs(p) - size + radius;\n\treturn min(max(max(d.x, d.y), d.z), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n\treturn mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge(float d1, float d2, float d3, float k)\n{\n\tfloat d12 = smoothMerge(d1, d2, k);\n\tfloat d23 = smoothMerge(d2, d3, k);\n\treturn smoothMerge(d12, d23, k);\n}\n\nfloat smoothMerge(float d1, float d2, float d3, float d4, float k)\n{\n\tfloat d12 = smoothMerge(d1, d2, k);\n\tfloat d23 = smoothMerge(d2, d3, k);\n\tfloat d34 = smoothMerge(d3, d4, k);\n\treturn smoothMerge(d12, d", "\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 7\nvec3 pat7(", "\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    float s = sin(orient.x);\n    float c = cos(orient.x);\n    uv *= mat2(c, -s, s, c);\n    uv += orient.y;\n    return vec3(uv, 0.5 + 0.5 * sin(time));\n}\n\n// Pattern 8\nvec3 pat8(", "\n    vec2 d = vec2( 0.0 );\n    vec2 a = vec2( 0.0 );\n    vec2 b = vec2( 0.0 );\n    vec2 c = vec2( 0.0 );\n    vec2 e = vec2( 0.0 );\n    vec2 f = vec2( 0.0 );\n    vec2 g = vec2( 0.0 );\n    vec2 h = vec2( 0.0 );\n    vec2 i = vec2( 0.0 );\n    vec2 j = vec2( 0.0 );\n    vec2 k = vec2( 0.0 );\n    vec2 l = vec2( 0.0 );\n    vec2 m = vec2( 0.0 );\n    vec2 n = vec2( 0.0 );\n    vec2 o = vec2( 0.0 );\n    vec2 p = vec2( 0.0 );\n    vec2 q = vec2( 0.0 );\n    vec2 r = vec2( 0.0 );\n    vec2 s = vec2( 0.0 );\n    vec2 t = vec2( 0.0 );\n    vec2 u = vec2( 0.0 );\n    vec2 v = vec2( 0.0 );\n    vec2 w = vec2( 0.0 );\n    vec2 x = vec2( 0.0 );\n    vec2 y = vec2( 0.0 );\n    vec2 z = vec2( 0.0 );\n    vec2 A = vec2( 0.0 );\n    vec2 B = vec2( 0.0 );\n    vec2 C = vec2( 0.0 );\n    vec2 D = vec2( 0.0 );\n    vec2 E = vec2( 0.0 );\n    vec2 F = vec2( 0.0 );\n    vec2 G = vec2( 0.0 );\n    vec2 H = vec2( 0.0 );\n    vec2 I = vec2( 0.0 );\n    vec2 J = vec2( 0.0 );\n    vec2 K = vec2( 0.0 );\n    vec2 L = vec2( 0.0 );\n    vec2 M = vec2( 0.0 );\n    vec2 N =", "\n    vec3 e = vec3(0.001,0.0,0,0);\n    vec3 n = vec3(\n        map(p+e.xyy).x - map(p-e.xyy).x,\n        map(p+e.yxy).x - map(p-e.yxy).x,\n        map(p+e.yyx).x - map(p-e.yyx).x );\n    return normalize(n);\n}\n\n// raymarching\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        float d = map(p);\n        p += d*rd;\n        t += d;\n        if( abs(d)<0.001 || t>10.0 ) break;\n    }\n    if( t<10.0 )\n    {\n        vec3 n = dmap(p);\n        vec3 l = normalize(vec3(1.0,0.5,0.2));\n        float dif = clamp( dot(n,l), 0.0, 1.0 );\n        col = vec3(0.4,0.6,0.8) * dif;\n    }\n    return col;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 z  = normalize( ta - ro );\n    vec3 up  = vec3( 0.0, 1.0, 0.0 );\n    vec3 x = normalize( cross( z,", "\n\tv33 c=a;\n\ta=b;\n\tb=c;\n}\n\n//this is the main function, it's called once per pixel\nvoid main(){\n\t//get the ray from the camera to the pixel\n\tv33 ray=normalize(v33(\n\t\t(2.0*gl_FragCoord.x-resolution.x)/resolution.x,\n\t\t(resolution.y-2.0*gl_FragCoord.y)/resolution.y,\n\t\t1.0\n\t));\n\t//get the ray from the camera to the pixel, but transposed\n\tv33 rayT=normalize(v33(\n\t\t(2.0*gl_FragCoord.x-resolution.x)/resolution.x,\n\t\t(2.0*gl_FragCoord.y-resolution.y)/resolution.y,\n\t\t1.0\n\t));\n\t//get the ray from the camera to the pixel, but transposed and inverted\n\tv33 rayTI=normalize(v33(\n\t\t(2.0*gl_FragCoord.x-resolution.x)/resolution.x,\n\t\t(resolution.y-2.0*gl_FragCoord.y)/resolution.y,\n\t\t-1.0\n\t));\n\t//get the ray from the camera to the pixel, but transposed and inverted and transposed\n\tv33 rayTIT=normalize(v33(\n\t\t(2.0*gl_FragCoord.x-resolution.x)/resolution.x,\n\t\t(2.0*gl_FragCoord.y-resolution.y)/resolution.y,\n\t\t-1.0\n\t));\n\t//get the ray from the camera to the pixel, but transposed and inverted and transposed and inverted\n\tv33 rayTITI=normalize(v33(\n\t\t(2.0*gl_FragCoord.x-resolution.x)/resolution.x,\n\t\t(resolution.y-2.0*gl_FragCoord.y)/resolution.y,\n\t\t1.0\n\t));\n\t//get the ray from the camera to the pixel, but transposed and inverted and transposed and inverted and transposed\n\tv33 rayTITIT=normalize(v33(\n\t\t(2.0*gl_Frag", "return a-b;}\nv33 mul(v33 a,vec3 b){return a*b;}\nv33 div(v33 a,vec3 b){return a/b;}\nv33 add(v33 a,vec3 b){return a+b;}\nv33 mul(v33 a,float b){return a*b;}\nv33 div(v33 a,float b){return a/b;}\nv33 add(v33 a,float b){return a+b;}\nv33 mul(float a,v33 b){return a*b;}\nv33 div(float a,v33 b){return a/b;}\nv33 add(float a,v33 b){return a+b;}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv44 sub(v44 a,vec4 b){return a-b;}\nv44 mul(v44 a,vec4 b){return a*b;}\nv44 div(v44 a,vec4 b){return a/b;}\nv44 add(v44 a,vec4 b){return a+b;}\nv44 mul(v44 a,float b){return a*b;}\nv44 div(v44 a,float b){return a/b;}\nv44 add(v44 a,float b){return a+b;}\nv44 mul(float a,v44 b){return a*b;}\nv44 div(float a,v44 b){return a/b;}\nv44 add(float a,v44 b){return a+b;}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv22 sub(v22 a,mat2 b){return a-b;}\nv22 mul(v22 a,mat2 b){return a*b;}\nv22 div(v22 a,mat2 b){return a/b;}\nv22 add(v22 a,mat2 b){return a+b;}\nv22 mul(v22 a,float b){return a*", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//multiply ray components by a scalar\nv33 mulc(v33 a,float b){\n\treturn v33(a.x*b,a.y*b,a.z*b);\n}\n//divide ray components by a scalar\nv33 divc(v33 a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\n//dot product of two vectors\nfloat dot(v33 a,v33 b){\n\treturn a.x*b.x+a.y*b.y+a.z*b.z;\n}\n//cross product of two vectors\nv33 cross(v33 a,v33 b){\n\treturn v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//length of a vector\nfloat len(v33 a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\n//normalize a vector\nv33 norm(v33 a){\n\treturn divc(a,len(a));\n}\n//reflect a vector\nv33 reflect(v33 a,v33 n){\n\treturn subc(a,mulc(n,2*dot(a,n)));\n}\n//refract a vector\nv33 refract(v33 a,v33 n,float ior){\n\tfloat cosi=dot(a,n);\n\tfloat k=1-ior*ior*(1-cosi*cosi);\n\tif(k<0)return v33(0,0,0);\n\telse return subc(mulc(a,ior),mulc(n,ior*cosi-sqrt(k)));\n}\n//return the angle between two vectors\nfloat angle(v33 a,v33 b){", "\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h,v33 i){\n\treturn vec2(a.x-b.x,a.y-b.y);", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(vec3 a,v33 b){\n\treturn vec2(dot(a,b.x),dot(a,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n\treturn vec2(dot(a.x,b.x,c.x),dot(a.y,b.y,c.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n\treturn vec2(dot(a.x,b.x,c.x,d.x),dot(a.y,b.y,c.y,d.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn vec2(dot(a.x,b.x,c.x,d.x,e.x),dot(a.y,b.y,c.y,d.y,e.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn vec2(dot(a.x,b.x,c.x,d.x,e.x,f.x),dot(a.y,b.y,c.y,d.y,e.y,f.y));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.y);\n}\nv33 mul(v33 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,vec4 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,mat2 b){\n\treturn v33(a.x*b.x.x+a.y*b.y.x,a.x*b.x.y+a.y*b.y.y,a.z*b.x.y+a.z*b.y.y);\n}\nv33 mul(v33 a,mat3 b){\n\treturn v33(a.x*b.x.x+a.y*b.y.x+a.z*b.z.x,a.x*b.x.y+a.y*b.y.y+a.z*b.z.y,a.x*b.x.z+a.y*b.y.z+a.z*b.z.z);\n}\nv33 mul(v33 a,mat4 b){\n\treturn v33(a.x*b.x.x+a.y*b.y.x+a.z*b.z.x,a.x*b.x.y+a.y*b.y.y+a.z*b.z.y,a.x*b.x.z+a.y*b.y.z+a.z*b.z.z);\n}\nv33 mul(v33 a,quat b){\n\treturn v33(a.x*b.x+a.y*b.y+a.z*b.z,a.y*b.z-a.z*b.y,a.z*b.x-a.", "\n\tfloat a=tri(p,w);\n\tfloat b=tri(p+vec3(0.0,w.y,w.z),w);\n\tfloat c=tri(p+vec3(w.x,0.0,w.z),w);\n\tfloat d=tri(p+vec3(w.x,w.y,0.0),w);\n\tfloat e=tri(p+vec3(0.0,w.y,0.0),w);\n\tfloat f=tri(p+vec3(w.x,0.0,0.0),w);\n\tfloat g=tri(p+vec3(0.0,0.0,w.z),w);\n\tfloat h=tri(p+vec3(0.0,w.y,w.z)+vec3(w.x,0.0,0.0),w);\n\treturn a+b+c+d+e+f+g+h;\n}\n\nfloat checkerF(vec3 p,vec3 w){\n\tfloat a=tri(p,w);\n\tfloat b=tri(p+vec3(0.0,w.y,w.z),w);\n\tfloat c=tri(p+vec3(w.x,0.0,w.z),w);\n\tfloat d=tri(p+vec3(w.x,w.y,0.0),w);\n\treturn a+b+c+d;\n}\n\nfloat checkerF3(vec3 p,vec3 w){\n\tfloat a=tri(p,w);\n\tfloat b=tri(p+vec3(0.0,w.y,w.z),w);\n\tfloat c=tri(p+vec3(w.x,0.0,w.z),w);\n\tfloat d=tri(p+vec3(w.x,w.y,0.0),w);\n\tfloat e=tri(p+vec3(0.0,w.y,0.0),w);\n\tfloat f=tri(p+vec3(w.x,0.0,0.0),w);\n\tfloat g=tri(p+vec3", "\n\tvec3 q=abs(p);\n\tfloat d=max(q.x,max(q.y,q.z));\n\tfloat e=min(q.x,min(q.y,q.z));\n\tfloat f=max(e,d-w.x);\n\tfloat g=max(e,d-w.y);\n\tfloat h=max(e,d-w.z);\n\treturn(f*g*h);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,float w){\n\tvec3 q=abs(p);\n\tfloat d=max(q.x,max(q.y,q.z));\n\tfloat e=min(q.x,min(q.y,q.z));\n\tfloat f=max(e,d-w);\n\treturn(f*f*f);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,float w,float w2){\n\tvec3 q=abs(p);\n\tfloat d=max(q.x,max(q.y,q.z));\n\tfloat e=min(q.x,min(q.y,q.z));\n\tfloat f=max(e,d-w);\n\tfloat g=max(e,d-w2);\n\treturn(f*f*f*g*g*g);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,float w,float w2,float w3){\n\tvec3 q=abs(p);\n\tfloat d=max(q.x,max(q.y,q.z));\n\tfloat e=min(q.x,min(q.y,q.z));\n\tfloat f=max(e,d-w);\n\t", "\n\tfloat d=sdSphere(r,s);\n\tif(d<0.0){\n\t\tv33 p=r.xyz+d*r.xyz;\n\t\tv33 n=normalize(p-s.xyz);\n\t\tv33 l=normalize(light-p);\n\t\tfloat dif=max(0.0,dot(n,l));\n\t\tfloat dif2=max(0.0,dot(n,normalize(light2-p)));\n\t\tfloat dif3=max(0.0,dot(n,normalize(light3-p)));\n\t\tfloat dif4=max(0.0,dot(n,normalize(light4-p)));\n\t\tfloat dif5=max(0.0,dot(n,normalize(light5-p)));\n\t\tfloat dif6=max(0.0,dot(n,normalize(light6-p)));\n\t\tfloat dif7=max(0.0,dot(n,normalize(light7-p)));\n\t\tfloat dif8=max(0.0,dot(n,normalize(light8-p)));\n\t\tfloat dif9=max(0.0,dot(n,normalize(light9-p)));\n\t\tfloat dif10=max(0.0,dot(n,normalize(light10-p)));\n\t\tfloat dif11=max(0.0,dot(n,normalize(light11-p)));\n\t\tfloat dif12=max(0.0,dot(n,normalize(light12-p)));\n\t\tfloat dif13=max(0.0,dot(n,normalize(light13-p)));\n\t\tfloat dif14=max(0.0,dot(n,normalize(light14-p)));\n\t\tfloat dif15=max(0.0,dot(n,normalize(light15-p)));\n\t\tfloat dif16=max(0.0,dot(n,normalize(light16-p)));\n\t\tfloat dif17=max(0.0,dot(n,normalize(light17-p)));\n\t\tfloat dif18=max(0.0,dot(n,normalize(light18-p)));\n\t\tfloat dif19=max(0.0,dot(n,normalize(", "\n\tfloat d=length(u-s.xyz)-s.w;\n\treturn smoothstep(0.0,1.0,d*d/(s.w*s.w));\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 b){\n\tvec3 d=abs(u-b.xyz)-b.w;\n\treturn smoothstep(0.0,1.0,min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)));\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 c){\n\tvec3 d=abs(u-c.xyz)-c.w;\n\treturn smoothstep(0.0,1.0,min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)));\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 c){\n\tvec3 d=abs(u-c.xyz)-c.w;\n\treturn smoothstep(0.0,1.0,min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)));\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 t){\n\tvec3 q=vec3(length(u.xz)-t.x,u.y,0.0);\n\treturn smoothstep(0.0,1.0,length(q)-t.y);\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 p){\n\treturn smoothstep(0.0,1.0,dot(u-p.xyz,n)-p.w);\n}\n\n//capsule occlusion\nfloat occCapsule(vec3 u,vec3 n,vec4 c){\n\tvec3 q=abs(u-c.xyz)-c.w;\n\treturn smoothstep(0.0,1.0,min(max(q.x,max(q", "\n    vec2 v0 = p2 - p0;\n    vec2 v1 = p1 - p0;\n    vec2 v2 = p0;\n    float tvalues[2], roots[2];\n    int solutions = solveQuadratic(v0.x, v1.x, v2.x, tvalues);\n    vec4 bbox = vec4( p0, p0 );\n    for ( int j = 0; j < solutions; ++j )\n    {\n        float t = tvalues[j];\n        vec2 p = getBezier( t, p0, p1, p2 );\n        bbox.xy = min( bbox.xy, p );\n        bbox.zw = max( bbox.zw, p );\n    }\n    return bbox;\n}\n\n// Exact BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 v0 = p3 - p0;\n    vec2 v1 = p2 - p1 - v0;\n    vec2 v2 = p1 - p0;\n    vec2 v3 = p0;\n    float tvalues[3], roots[3];\n    int solutions = solveCubic(v0.x, v1.x, v2.x, v3.x, tvalues);\n    vec4 bbox = vec4( p0, p0 );\n    for ( int j = 0; j < solutions; ++j )\n    {\n        float t = tvalues[j];\n        vec2 p = getBezier( t, p0, p1, p2, p3 );\n        bbox.xy = min( bbox.xy, p );\n        bbox.zw = max( bbox.zw, p );\n    }\n    return bbox;\n}\n\n// Exact BBox to a quadratic bezier, split into two curves\nvec4 bboxBezier2(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 v0 = p2 - p0;\n    vec2 v1 = p1 - p0;\n    vec2 v2 = p0;\n    float tvalues[2], roots[2];\n    int solutions = solveQuadratic(v0.x, v1.x, v2.x, tvalues);\n    vec4 bbox =", "\n    vec2 p0p1 = p1 - p0;\n    vec2 p1p2 = p2 - p1;\n    vec2 p0p2 = p2 - p0;\n    vec2 p0p1p2 = p1p2 - p0p1;\n    vec2 p0p1p2_2 = p0p1p2 * 2.0;\n    vec2 p0p1p2_3 = p0p1p2 * 3.0;\n    vec2 p0p1p2_4 = p0p1p2 * 4.0;\n    vec2 p0p1p2_6 = p0p1p2 * 6.0;\n    vec2 p0p1p2_12 = p0p1p2 * 12.0;\n    vec2 p0p1p2_24 = p0p1p2 * 24.0;\n    vec2 p0p1p2_36 = p0p1p2 * 36.0;\n    vec2 p0p1p2_48 = p0p1p2 * 48.0;\n    vec2 p0p1p2_60 = p0p1p2 * 60.0;\n    vec2 p0p1p2_72 = p0p1p2 * 72.0;\n    vec2 p0p1p2_84 = p0p1p2 * 84.0;\n    vec2 p0p1p2_96 = p0p1p2 * 96.0;\n    vec2 p0p1p2_108 = p0p1p2 * 108.0;\n    vec2 p0p1p2_120 = p0p1p2 * 120.0;\n    vec2 p0p1p2_132 = p0p1p2 * 132.0;\n    vec2 p0p1p2_144 = p0p1p2 * 144.0;\n    vec2 p0p1p2_156 = p0p1p2 * 156.0;\n    vec2 p0p", "\n    vec3 u = p0 - p1;\n    vec3 v = p3 - p2;\n    vec3 w = p0 - 2.0*p1 + p2;\n    vec3 x = p3 - 2.0*p2 + p1;\n    vec3 a = 3.0*u;\n    vec3 b = 3.0*(v - u - w);\n    vec3 c = 3.0*(w - v);\n    vec3 d = v;\n    vec3 m = max( max( vec3( dot(a,a), dot(a,b), dot(a,c) ), vec3( dot(b,b), dot(b,c), dot(b,d) ) ), vec3( dot(c,c), dot(c,d), dot(d,d) ) );\n    vec3 n = min( min( vec3( dot(a,a), dot(a,b), dot(a,c) ), vec3( dot(b,b), dot(b,c), dot(b,d) ) ), vec3( dot(c,c), dot(c,d), dot(d,d) ) );\n    return bound3( p0 + 0.5*(n.x*a + n.y*b + n.z*c), p0 + 0.5*(m.x*a + m.y*b + m.z*c) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 u = p0 - p1;\n    vec3 v = p3 - p2;\n    vec3 w = p0 - 2.0*p1 + p2;\n    vec3 x = p3 - 2.0*p2 + p1;\n    vec3 a = 3.0*u;\n    vec3 b = 3.0*(v - u - w);\n    vec3 c = 3.0*(w - v);\n    vec3 d = v;\n    vec3 m =", "\n    vec2 p03 = mix(p0, p3, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return vec4(p0, p0123);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 p03 = mix(p0, p3, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    vec2 p01234 = mix(p0123, p123, 0.5);\n    return vec4(p0, p01234);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n    vec2 p03 = mix(p0, p3, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p0", "\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.x);\n    vec2 p123 = mix(p12, p23, pos.x);\n    return mix(p012, p123, pos.x);\n}\n\n// 2D cubic bezier curve.\n// p0, p1, p2, p3 are the control points.\n// pos is the position on the curve, in [0, 1].\n//\n// This is a very slow function, do not use in production.\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{\n    vec2 p01 = mix(p0, p1, pos.x);\n    vec2 p12 = mix(p1, p2, pos.x);\n    vec2 p23 = mix(p2, p3, pos.x);\n    vec2 p012 = mix(p01, p12, pos.x);\n    vec2 p123 = mix(p12, p23, pos.x);\n    return mix(p012, p123, pos.x);\n}\n\n// 2D cubic bezier curve.\n// p0, p1, p2, p3 are the control points.\n// pos is the position on the curve, in [0, 1].\n//\n// This is a very slow function, do not use in production.\nvec2 bezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, float pos)\n{\n    vec2 p01 = mix(p0, p1, pos);\n    vec2 p12 = mix(p1, p2, pos);\n    vec2 p23 = mix(p2, p3, pos);\n    vec2 p012 = mix(p01, p12, pos);\n    vec2 p123 =", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p  = cross( rd, e2 );\n    vec3 q  = cross( e1, rd );\n    vec3 t  = cross( e1, e2 );\n    float det = dot( t, vec3( 1.0 ) );\n    vec3 s = ro - v0;\n    float u = dot( s, p ) / det;\n    float v = dot( s, q ) / det;\n    float t_ = dot( t, s ) / det;\n    return vec3( t_, u, v );\n}\n\n// Sphere intersection. Returns { t, u, v }\nvec3 sphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w * sph.w;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec3( -1.0 );\n    h = sqrt( h );\n    return vec3( -b - h, -b + h );\n}\n\n// Box intersection. Returns { t, u, v }\nvec3 boxIntersect( in vec3 ro, in vec3 rd, in vec3 boxMin, in vec3 boxMax )\n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ( boxMin - ro );\n    vec3 k = m * ( boxMax - ro );\n    vec3 t1 = min( n, k );\n    vec3 t2 = max( n, k );\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec3( -1.0 );\n    return vec3( tN );\n}\n\n// Plane intersection. Returns { t }\nvec3 planeIntersect( in vec3 ro, in vec3 rd, in vec4 pln )\n{\n    float d = dot( pln.xyz", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 v0pos = pos - v0;\n    vec3 v0nor = nor;\n    vec3 v1v2 = v2 - v1;\n    vec3 v1pos = pos - v1;\n    vec3 v1nor = nor;\n    vec3 v2pos = pos - v2;\n    vec3 v2nor = nor;\n    vec3 c1 = cross( v0v1, v0pos );\n    vec3 c2 = cross( v1v2, v1pos );\n    vec3 c3 = cross( v2pos, v0v2 );\n    float d1 = dot( c1, v0nor );\n    float d2 = dot( c2, v1nor );\n    float d3 = dot( c3, v2nor );\n    float sum = d1 + d2 + d3;\n    if( sum < 0.0 ) return 1.0;\n    return 0.0;\n}\n\n// Sphere occlusion (if fully visible)\nfloat sphereOcclusion( in vec3 pos, in vec3 nor, in vec3 spos, in float srad )\n{\n    vec3 v = pos - spos;\n    float d2 = dot( v, v );\n    if( d2 < srad*srad ) return 1.0;\n    return 0.0;\n}\n\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in vec3 bmin, in vec3 bmax )\n{\n    vec3 v = pos - bmin;\n    vec3 w = bmax - pos;\n    if( any( lessThan( v, vec3(0.0) ) ) ) return 1.0;\n    if( any( lessThan( w, vec3(0.0) ) ) ) return 1.0;\n    return 0.0;\n}\n\n// Cylinder occlusion (if fully visible)\nfloat cylinderOcclusion( in vec3 pos, in vec3 nor, in vec3 cpos, in vec3 cdir, in float crad )\n{\n    vec3 v = pos - cpos;\n    float d = dot( v,", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x),vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        res = dot(d+c*t,d+c*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        res = dot(d+(c+b*t.x)*t.x+(c+b*t.y)*t.y+(c+b*t.z)*t.z, d+(c+b*t.x)*t.x+(c+b*t.y)*t.y+(c+b*t.z)*t.z);\n    }\n    return sign(res)*sqrt(abs(res));\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(", "\n    float r = clamp( (p.y-he)*0.5/r1, 0.0, 1.0 );\n    return length(p) - r*(r1+r2-r1*r2);\n}\n\n// hexagon\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254,0.5773503,0.5773503);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// octogon\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254,0.5773503,0.5773503);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// rounded hexagon\nfloat sdRoundedHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254,0.5773503,0.5773503);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y) - r;\n}\n\n// rounded octogon\nfloat sdRoundedOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.8660254,0.", "\n    vec2 q = abs(p);\n    float h = clamp( (q.y-0.5*b.x)/b.y, 0.0, 1.0 );\n    float w = q.x;\n    return mix( mix( rb*w, ra*w, h ), q.y-0.5*b.x, step(0.0,p.y-0.5*b.x) );\n}\n\n// hexagon\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p = abs(p);\n    return max(abs(p.y/r),p.x/r*(1.0+k/2.0));\n}\n\n// octagon\nfloat sdOctagon( in vec2 p, in float r )\n{\n    p = abs(p);\n    float m = max(p.x,p.y);\n    float q = min(p.x,p.y);\n    return m-q-(r-1.0/sqrt(2.0))*sqrt(2.0*(m-q));\n}\n\n// rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b+r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float m )\n{\n    vec2 d = abs(p)-b+r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - m;\n}\n\n// rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float m, in float n )\n{\n    vec2 d = abs(p)-b+r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - m - n;\n}\n\n// rounded rectangle\nfloat sdRoundRect( in vec2 p,", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        float s = clamp( 8.0*h/t, 0.0, 1.0 );\n        res = min( res, k*s*s*(1.0-k)+s );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    return calcSoftshadow( ro, rd, tmin, tmax, 16.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmax )\n{\n    return calcSoftshadow( ro, rd, 0.02, tmax, 16.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    return calcSoftshadow( ro, rd, 0.02, 2.5, 16.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k, float t )\n{\n    return calcSoftshadow( ro, rd, tmin, tmax, k ) * (1.0 - smoothstep( 0.0, 1.0, t ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmax, float k, float t )\n{\n    return calcSoftshadow( ro, rd, 0.02,", "\n    return fract(sin(dot(q.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in vec2 q )\n{\n    return fract(sin(dot(q.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in vec3 q )\n{\n    return fract(sin(dot(q.xyz,vec3(12.9898,78.233,123.456))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in vec4 q )\n{\n    return fract(sin(dot(q.xyzw,vec4(12.9898,78.233,123.456,1234.567))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in float q )\n{\n    return fract(sin(dot(vec2(q,q),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in int q )\n{\n    return fract(sin(dot(vec2(q,q),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in uint q )\n{\n    return fract(sin(dot(vec2(q,q),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// random hash\nfloat hash( in bool q )\n{\n    return fract(sin(dot(vec2(q,q),vec2(12.9898,78.233))) * 43758.5453);", "\n    vec2 u = x * p;\n    return fract(sin(dot(u, vec2(12.9898,78.233)))* 43758.5453);\n}\n\n// fbm\nfloat fbm( in vec2 p, in int octaves, in float lacunarity, in float gain )\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for( int i = 0; i < octaves; i++ )\n    {\n        sum += amp * noise( p, int(freq) );\n        amp *= gain;\n        freq *= lacunarity;\n    }\n    return sum;\n}\n\n// fbm\nfloat fbm( in vec2 p, in int octaves, in float lacunarity, in float gain, in float offset )\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for( int i = 0; i < octaves; i++ )\n    {\n        sum += amp * noise( p + offset, int(freq) );\n        amp *= gain;\n        freq *= lacunarity;\n    }\n    return sum;\n}\n\n// fbm\nfloat fbm( in vec2 p, in int octaves, in float lacunarity, in float gain, in float offset, in float time )\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for( int i = 0; i < octaves; i++ )\n    {\n        sum += amp * noise( p + offset + time, int(freq) );\n        amp *= gain;\n        freq *= lacunarity;\n    }\n    return sum;\n}\n\n// fbm\nfloat fbm( in vec2 p, in int octaves, in float lacunarity, in float gain, in float offset, in float time, in float time2 )\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for( int i = 0; i < octaves; i++ )\n    {\n        sum += amp * noise( p + offset + time + time", "\n    float f = 0.0;\n    f += 0.5000 * noise( x ); p -= 1;\n    f += 0.2500 * noise( 2.0*x ); p -= 1;\n    f += 0.1250 * noise( 4.0*x ); p -= 1;\n    f += 0.0625 * noise( 8.0*x ); p -= 1;\n    f += 0.0312 * noise( 16.0*x ); p -= 1;\n    return f / 0.984375;\n}\n\n// fractal noise\nfloat fbm( in vec2 x )\n{\n    return fbm( x, 5 );\n}\n\n// fractal noise\nfloat fbm( in vec3 x, in int p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( x ); p -= 1;\n    f += 0.2500 * noise( 2.0*x ); p -= 1;\n    f += 0.1250 * noise( 4.0*x ); p -= 1;\n    f += 0.0625 * noise( 8.0*x ); p -= 1;\n    f += 0.0312 * noise( 16.0*x ); p -= 1;\n    return f / 0.984375;\n}\n\n// fractal noise\nfloat fbm( in vec3 x )\n{\n    return fbm( x, 5 );\n}\n\n// fractal noise\nfloat fbm( in vec4 x, in int p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( x ); p -= 1;\n    f += 0.2500 * noise( 2.0*x ); p -= 1;\n    f += 0.1250 * noise( 4.0*x ); p -= 1;\n    f += 0.0625 * noise( 8.0*x ); p -= 1;\n    f += 0.03", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCylinder( in vec3 p, in vec2 h ) \n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCone( in vec3 p, in vec3 c ) \n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c.xy,vec2(q,p.z));\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdTorus( in vec3 p, in vec2 t ) \n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// generic capsule - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r ) \n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// generic box - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// generic rounded box - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat udRoundBox( vec3 p, vec3 b, float r )", "\n    p = abs(p);\n    float b = (p.x + p.z) - r.x;\n    float c = (p.y*p.y) - r.y*r.y;\n    float h = max(b,c);\n    float d = min(max(b,c), 0.0);\n    return sqrt(d*d + h*h);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXY( in vec3 p, in vec2 r ) \n{\n    p = abs(p);\n    float b = (p.x + p.y) - r.x;\n    float c = (p.z*p.z) - r.y*r.y;\n    float h = max(b,c);\n    float d = min(max(b,c), 0.0);\n    return sqrt(d*d + h*h);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec2 r ) \n{\n    p = abs(p);\n    float b = (p.x + p.y + p.z) - r.x;\n    float c = (p.x*p.x + p.y*p.y) - r.y*r.y;\n    float h = max(b,c);\n    float d = min(max(b,c), 0.0);\n    return sqrt(d*d + h*h);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYY( in vec3 p, in vec2 r ) \n{\n    p = abs(p);\n    float b = (p.x + p.y) - r.x;\n    float c = (p.x*p.x + p.z*p.z) - r.y*r.y;\n    float h = max(b,c);\n    float d = min(max(b,c), 0.0);\n    return sqrt(d*d + h*h);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZZ( in vec3 p, in vec2 r ) \n{\n    p = abs(p);\n    float", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_Better( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0+1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_Better2( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_Better3( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0+1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_Better4( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_Better5( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0+1.0)/k1;\n}\n\n// generic ellipsoid - better approximated distance\nfloat sdEllipsoid_", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - exact distance\nfloat sdEllipsoid2( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0+1.0)/k1;\n}\n\n// ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float smoothness ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    float k2 = length(p/(r*r*r));\n    return k0*(k0-1.0)/k1 + smoothness*smoothness*k2;\n}\n\n// ellipsoid\nfloat sdEllipsoid2( in vec3 p, in vec3 r, in float smoothness ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    float k2 = length(p/(r*r*r));\n    return k0*(k0+1.0)/k1 + smoothness*smoothness*k2;\n}\n\n// torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// infinite cylinder\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length", "\n    // filter kernel\n    vec2 w = fwidth(p) * 0.5;\n    vec2 i = 2.0 * (abs(fract((p-0.5*w)/w))-0.5);\n    // analytical integral (box filter)\n    return 0.25 - (i.x*i.y);\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w )\n{\n    // filter kernel\n    vec2 i = 2.0 * (abs(fract((p-0.5*w)/w))-0.5);\n    // analytical integral (box filter)\n    return 0.25 - (i.x*i.y);\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float scale )\n{\n    // filter kernel\n    vec2 i = 2.0 * (abs(fract((p-0.5*w)/w))-0.5);\n    // analytical integral (box filter)\n    return 0.25 - (i.x*i.y) * scale;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float scale, in float offset )\n{\n    // filter kernel\n    vec2 i = 2.0 * (abs(fract((p-0.5*w)/w))-0.5);\n    // analytical integral (box filter)\n    return 0.25 - (i.x*i.y) * scale + offset;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float scale, in float offset, in float offset2 )\n{\n    // filter kernel\n    vec2 i = 2.0 * (abs(fract((p-0.5*w)/w))-0.5);\n    // analytical integral (box filter)\n    return 0.25 - (i.x*i.y) * scale + offset + offset2;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 w, in float scale, in float offset, in float offset2, in float offset3 )\n{\n    // filter kernel\n    vec2 i = 2.0 * (abs(fract((p-0", "\n\treturn a / ( 1.0 + ( 1.0 - a ) * x );\n}\n\n// Schlick Fresnel approximation, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat fresnel( float f0, float f90, float dotVH )\n{\n\treturn f0 + ( f90 - f0 ) * pow( clamp( 1.0 - dotVH, 0.0, 1.0 ), 5.0 );\n}\n\n// Shlick approximation of the Fresnel term, from https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nfloat fresnelSchlick( float f0, float f90, float dotVH )\n{\n\treturn f0 + ( f90 - f0 ) * pow( clamp( 1.0 - dotVH, 0.0, 1.0 ), 5.0 );\n}\n\n// Shlick approximation of the Fresnel term, from https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 fresnelSchlick( vec3 f0, vec3 f90, float dotVH )\n{\n\treturn f0 + ( f90 - f0 ) * pow( clamp( 1.0 - dotVH, 0.0, 1.0 ), 5.0 );\n}\n\n// Shlick approximation of the Fresnel term, from https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 fresnelSchlick( vec3 f0, vec3 f90, vec3 dotVH )\n{\n\treturn f0 + ( f90 - f0 ) * pow( clamp( 1.0 - dotVH, 0.0, 1.0 ), 5.0 );\n}\n\n// Shlick approximation of the Fresnel term, from https://seblagarde.wordpress.com/2013/0", "\n\tfloat y = x / p;\n\treturn 2.0 * ( y - floor( y + 0.5 ) );\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n\tfloat y = x / p;\n\treturn 2.0 * fabs( fmod( y, 1.0 ) - 0.5 );\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - 0.5 ) );\n}\n\n// biased pulse\nfloat my_pul( float x, float p )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - 0.5 ) ) - 1.0;\n}\n\n// biased noise\nfloat my_noi( float x, float p )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - 0.5 ) ) - 1.0;\n}\n\n// biased noise\nfloat my_noi( float x, float p, float q )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - 0.5 ) ) - 1.0;\n}\n\n// biased noise\nfloat my_noi( float x, float p, float q, float r )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - 0.5 ) ) - 1.0;\n}\n\n// biased noise\nfloat my_noi( float x, float p, float q, float r, float s )\n{\n\tfloat y = x / p;\n\treturn 2.0 * ( 1.0 - fabs( fmod( y, 1.0 ) - ", "\n    vec3 c = vec3( 0.0 );\n    if( h < 0.0 )\n    {\n        c = vec3( 0.0, 0.0, 0.0 );\n    }\n    else if( h < 0.25 )\n    {\n        c = vec3( 0.0, 4.0 * h, 1.0 );\n    }\n    else if( h < 0.5 )\n    {\n        c = vec3( 0.0, 1.0, 1.0 - 4.0 * ( h - 0.25 ) );\n    }\n    else if( h < 0.75 )\n    {\n        c = vec3( 4.0 * ( h - 0.5 ), 1.0, 0.0 );\n    }\n    else\n    {\n        c = vec3( 1.0, 1.0 - 4.0 * ( h - 0.75 ), 0.0 );\n    }\n    return c;\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf_2( float h )\n{\n    vec3 c = vec3( 0.0 );\n    if( h < 0.0 )\n    {\n        c = vec3( 0.0, 0.0, 0.0 );\n    }\n    else if( h < 0.25 )\n    {\n        c = vec3( 0.0, 4.0 * h, 1.0 );\n    }\n    else if( h < 0.5 )\n    {\n        c = vec3( 0.0, 1.0, 1.0 - 4.0 * ( h - 0.25 ) );\n    }\n    else if( h < 0.75 )\n    {\n        c = vec3( 4.0 * ( h - 0.5 ), 1.0, 0.0 );\n    }\n    else\n    {\n        c = vec3( 1.0, 1.0 - 4.0 * ( h - 0.75 ), 0.0 );\n    }\n    return c;\n}\n\n// modified DLMF coloring, adapted from https", "\n    vec3 ba = pb - pa;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float bao = dot(ba,oc);\n    float k2 = baba - bard*bard;\n    float k1 = bao - bard*ro.z;\n    float k0 = dot(oc,oc) - ro.z*ro.z - r*r;\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = ( -k1 - h ) / k2;\n    if( t>0.0 ) return t;\n    t = ( -k1 + h ) / k2;\n    if( t>0.0 ) return t;\n    return -1.0;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3 ba = pb - pa;\n    vec3 oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float bao = dot(ba,oc);\n    float k2 = baba - bard*bard;\n    float k1 = bao - bard*ro.z;\n    float k0 = dot(oc,oc) - ro.z*ro.z - r*r;\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = ( -k1 - h ) / k2;\n    if( t>0.0 ) return t;\n    t = ( -k1 + h ) / k2;\n    if( t>0.0 ) return t;\n    return -1.0;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pl )", "\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ra*h;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-", "\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro+rd*t ).x;\n        float s = smoothstep( 0.0, r, h );\n        res = min( res, k*s*(1.0-res) );\n        t += h;\n        if( res<0.001 || t>20.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// soft shadow occlusion\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        float s = smoothstep( 0.0, 0.001, h );\n        res = min( res, s*(1.0-res) );\n        t += h;\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// sky\nvec3 getSkyColor( in vec3 rd )\n{\n    float sunAmount = clamp( dot(rd,sunDir), 0.0, 1.0 );\n    vec3 sky = mix( vec3(0.1,0.2,0.4), vec3(0.3,0.5,0.8), rd.y*0.5+0.5 );\n    sky += pow( sunAmount, 8.0 ) * vec3(1.0,0.8,0.5) * 2.0;\n    sky += pow( sunAmount, 16.0 ) * vec3(1.0,0.7,0.4) * 0.5;\n    return clamp( sky, 0.0, 1.0 );\n}\n\n// sun\nvec3 getSunColor( in vec3 ro, in vec3 rd )\n{\n    float sunAmount = clamp( dot(rd,sunDir), 0.0, ", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float d = 0.0;\n    if (r < rad1)\n    {\n        d = th * (1.0 - r / rad1);\n    }\n    else if (r > rad2)\n    {\n        d = th * (r - rad2) / (1.0 - rad2);\n    }\n    return vec2(cos(a + d), sin(a + d)) * r;\n}\n\nvoid main()\n{\n    vec2 uv = v_texcoord0;\n    vec2 uv2 = uv;\n    uv2.x = 1.0 - uv2.x;\n    uv2.y = 1.0 - uv2.y;\n    vec2 uv3 = uv;\n    uv3.x = 1.0 - uv3.x;\n    uv3.y = 1.0 - uv3.y;\n    uv = snake(uv, 0.2, 0.8, 0.05);\n    uv2 = snake(uv2, 0.2, 0.8, 0.05);\n    uv3 = snake(uv3, 0.2, 0.8, 0.05);\n    vec4 color = texture2D(u_texture, uv);\n    vec4 color2 = texture2D(u_texture, uv2);\n    vec4 color3 = texture2D(u_texture, uv3);\n    gl_FragColor = color + color2 + color3;\n}\n", "\n    p = abs(p);\n    float l = length(p-c*r);\n    float a = atan(p.y-c.y,p.x-c.x);\n    float d = ((a+3.14159/2.0)/3.14159);\n    return max(l-r,r*r*(1.0-d*d));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie2( in vec2 p, in vec2 c, in float r )\n{\n    p = abs(p);\n    float l = length(p-c*r);\n    float a = atan(p.y-c.y,p.x-c.x);\n    float d = ((a+3.14159/2.0)/3.14159);\n    return max(l-r,r*r*(1.0-d*d));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie3( in vec2 p, in vec2 c, in float r )\n{\n    p = abs(p);\n    float l = length(p-c*r);\n    float a = atan(p.y-c.y,p.x-c.x);\n    float d = ((a+3.14159/2.0)/3.14159);\n    return max(l-r,r*r*(1.0-d*d));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie4( in vec2 p, in vec2 c, in float r )\n{\n    p = abs(p);\n    float l = length(p-c*r);\n    float a = atan(p.y-c.y,p.x-c.x);\n    float d = ((a+3.14159/2.0)/3.14159);\n    return max(l-r,r*r*(1.0-d*d));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie5( in vec2 p, in vec2 c, in float", "\n    vec3 e = vec3(0.001,0.0,0,0);\n    vec3 n = vec3(\n        map(pos+e.xyy).x - map(pos-e.xyy).x,\n        map(pos+e.yxy).x - map(pos-e.yxy).x,\n        map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in vec3 nor )\n{\n    vec3 e = vec3(0.001,0.0,0,0);\n    vec3 n = vec3(\n        map(pos+e.xyy).x - map(pos-e.xyy).x,\n        map(pos+e.yxy).x - map(pos-e.yxy).x,\n        map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in vec3 nor, in float r )\n{\n    vec3 e = vec3(0.001,0.0,0,0);\n    vec3 n = vec3(\n        map(pos+e.xyy,r).x - map(pos-e.xyy,r).x,\n        map(pos+e.yxy,r).x - map(pos-e.yxy,r).x,\n        map(pos+e.yyx,r).x - map(pos-e.yyx,r).x );\n    return normalize(n);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in vec3 nor, in float r", "\n    p.x = abs(p.x);\n    p -= sca*dot(p,sca);\n    float h = clamp( dot(p,scb), -1.0, 1.0 );\n    return length(p) - ra*acos(h) - rb*sqrt( max(0.0,1.0-h*h) );\n}\n\nfloat sdArc( in vec2 p, in float ra, in float rb )\n{\n    return sdArc(p,vec2(1.0),vec2(1.0),ra,rb);\n}\n\nfloat sdArc( in vec2 p, in float ra )\n{\n    return sdArc(p,vec2(1.0),vec2(1.0),ra,ra);\n}\n\nfloat sdArc( in vec2 p, in float ra, in float rb, in float a )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return sdArc(p,vec2(ca,sa),vec2(ca,sa),ra,rb);\n}\n\nfloat sdArc( in vec2 p, in float ra, in float a )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return sdArc(p,vec2(ca,sa),vec2(ca,sa),ra,ra);\n}\n\nfloat sdArc( in vec2 p, in float ra, in float rb, in float a, in float b )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    float sb = sin(b);\n    float cb = cos(b);\n    return sdArc(p,vec2(ca,sa),vec2(cb,sb),ra,rb);\n}\n\nfloat sdArc( in vec2 p, in float ra, in float a, in float b )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    float sb = sin(b);\n    float cb = cos(b);\n    return sdArc(p,vec2(ca,sa),vec2(cb,sb),ra,ra);\n}\n\nfloat sdArc( in vec2 p, in float ra, in float rb, in float a, in float b, in float c )\n{\n    float sa", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        float s = clamp( 8.0*h/t, 0.0, 1.0 );\n        res = min( res, k*s*s*(1.0-k)+s );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k, in float t )\n{\n    float res = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        float s = clamp( 8.0*h/t, 0.0, 1.0 );\n        res = min( res, k*s*s*(1.0-k)+s );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;", "\n\tvec3 normal = vec3(0.0);\n\n\tfloat d = 0.0;\n\tfor( int i=0; i<4; i++ )\n\t{\n\t\tfloat scale = 0.5*(3.0-float(i));\n\t\td = sdSphere( pos*scale, 1.0 );\n\t\tnormal += normalize(pos-pos*scale)*d;\n\t}\n\n\treturn normalize(normal);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = sdSphere(ro + rd*t, 1.0);\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = sdSphere(ro + rd*t, 1.0);\n\t\tfloat s = clamp(8.0*h/t, 0.0, 1.0);\n\t\tres = min( res, k*s*s*(1.0-k)+s );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    return calcSoftshadow( ro, rd, 0.02, 2.5, time );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    return calcSoftshadow( ro, rd, 0.02, 2.5, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    return calcSoftshadow( ro, rd, mint, tmax, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmax )\n{\n    return calcSoftshadow( ro, rd, 0.02, tmax, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    return calcSoftshadow( ro, rd, mint, 2.5, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows", "\n    // filter kernel\n    vec2 w = max(abs(dpdx), abs(dpdy)) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5)) / w;\n    // analytical integral (box filter)\n    return 0.25 - 0.5*i.x*i.y;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    return checkersGradBox( p, dFdx(p), dFdy(p) );\n}\n\nfloat checkersGradBox( in vec2 p, in float scale )\n{\n    return checkersGradBox( p*scale, dFdx(p*scale), dFdy(p*scale) );\n}\n\nfloat checkersGradBox( in vec2 p, in float scale, in vec2 dpdx, in vec2 dpdy )\n{\n    return checkersGradBox( p*scale, dpdx*scale, dpdy*scale );\n}\n\nfloat checkersGradBox( in vec2 p, in float scale, in float rot )\n{\n    float s = sin(rot);\n    float c = cos(rot);\n    mat2  m = mat2(c,-s,s,c);\n    return checkersGradBox( (m*p)*scale, m*dFdx(p)*scale, m*dFdy(p)*scale );\n}\n\nfloat checkersGradBox( in vec2 p, in float scale, in float rot, in vec2 dpdx, in vec2 dpdy )\n{\n    float s = sin(rot);\n    float c = cos(rot);\n    mat2  m = mat2(c,-s,s,c);\n    return checkersGradBox( (m*p)*scale, m*dpdx*scale, m*dpdy*scale );\n}\n\nfloat checkersGradBox( in vec2 p, in float scale, in float rot, in float rot2 )\n{\n    float s = sin(rot);\n    float c = cos(rot);\n    mat2  m = mat2(c,-s,s,c);\n    return checkers", "\n    return k*floor(x/k);\n}\n\n//\n// 2D staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2 x, in float k )\n{\n    return k*floor(x/k);\n}\n\n//\n// 3D staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec3 staircase( in vec3 x, in float k )\n{\n    return k*floor(x/k);\n}\n\n//\n// 4D staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec4 staircase( in vec4 x, in float k )\n{\n    return k*floor(x/k);\n}\n\n//\n// 1D staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float a )\n{\n    return k*floor(x/k) + a;\n}\n\n//\n// 2D staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nvec2 staircase( in vec2", "\n\tvec3 sample_dir = normalize(sample_pos - surface_normal);\n\tfloat sample_dist = length(sample_pos - surface_normal);\n\tfloat sample_dist_scaled = sample_dist * 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 normal = normalize(pos);\n    vec3 light_color = vec3(1.0, 1.0, 0.0);\n    float light_intensity = 1.0;\n    float light_distance = length(pos);\n    float light_attenuation = 1.0 / (1.0 + 0.09 * light_distance + 0.032 * (light_distance * light_distance));\n    float diffuse = max(0.0, dot(normal, light_dir));\n    float specular = 0.0;\n    if (diffuse > 0.0) {\n        vec3 view_dir = normalize(-pos);\n        vec3 reflect_dir = reflect(-light_dir, normal);\n        specular = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);\n    }\n    vec3 color = light_color * light_intensity * light_attenuation * (diffuse + specular);\n    return vec4(color, light_distance);\n}\n\n/*\nThe following function returns the color of the sky\n\nin this case, the function returns a gradient from blue to white\n*/\nvec3 render_sky(vec3 dir) {\n    float t = 0.5 * (dir.y + 1.0);\n    return (1.0 - t) * vec3(0.5, 0.7, 1.0) + t * vec3(1.0);\n}\n\n/*\nThe following function returns the color of the atmosphere\n\nin this case, the function returns a gradient from blue to white\n*/\nvec3 render_atmosphere(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec3 normal = normalize(pos);\n    vec3 light_color = vec3(1.0, 1.0, 0.0);\n    float light_intensity = 1.0;\n    float light_distance = length(pos);\n    float light_attenuation = 1.0 / (1.0 + 0.09 * light_distance + 0.032 * (light_distance * light_distance));\n    float diffuse = max(0.0, dot(normal, light_dir));\n    float specular = 0.0;\n    if (diffuse > 0", "\n\tvec2 uv = coord / resolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= resolution.x / resolution.y;\n\treturn normalize(vec3(uv, -1.0));\n}\n\n/*\nthis function calculates the scattering function for a given ray direction\n*/\nvec3 get_scattering(vec3 ray_direction) {\n\t//we need to calculate the scattering function for the given ray direction\n\t//we do this by calculating the distance to the surface of the sphere\n\t//and then using that distance to calculate the scattering function\n\t//the scattering function is a function of the distance to the surface of the sphere\n\t//and the angle of incidence of the ray\n\t//the angle of incidence is the angle between the ray direction and the normal of the surface\n\t//the normal of the surface is the vector from the center of the sphere to the point on the surface\n\t//the distance to the surface is the length of the normal vector\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of incidence\n\t//the scattering function is a function of the distance to the surface and the angle of", "\n    // project p onto the unit sphere\n    p = normalize(p);\n\n    // calculate the solid angle of the cone\n    float sa = 2.0 * atan(c.y / (c.x * p.x + c.y * p.y + c.z * p.z));\n\n    // return the signed distance to the cone\n    return length(p) - ra * (sa - 1.0);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p, vec2 c, float ra)\n{\n    // project p onto the unit sphere\n    p = normalize(p);\n\n    // calculate the solid angle of the cone\n    float sa = 2.0 * atan(c.y / (c.x * p.x + c.y * p.y + c.z * p.z));\n\n    // return the signed distance to the cone\n    return length(p) - ra * (sa - 1.0);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p, vec2 c)\n{\n    // project p onto the unit sphere\n    p = normalize(p);\n\n    // calculate the solid angle of the cone\n    float sa = 2.0 * atan(c.y / (c.x * p.x + c.y * p.y + c.z * p.z));\n\n    // return the signed distance to the cone\n    return length(p) - (sa - 1.0);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p, float ra)\n{\n    // project p onto the unit sphere\n    p = normalize(p);\n\n    // calculate the solid angle of the cone\n    float sa = 2.0 * atan(p.y / (p.x * p.x + p.y * p.y + p.z * p.z));\n\n    // return the signed distance to the cone\n    return length(p) - ra * (sa - 1.0);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdCone(vec3 p)\n{\n    // project p onto the unit sphere\n    p = normalize(p);\n\n   ", "\n\tvec3 color = vec3(0.0);\n\tswitch (material) {\n\t\tcase 0:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tcolor = vec3(0.0, 0.0", "\n\tswitch (material) {\n\t\tcase MATERIAL_GLASS:\n\t\t\treturn 0.5;\n\t\tcase MATERIAL_METAL:\n\t\t\treturn 0.8;\n\t\tcase MATERIAL_PLASTIC:\n\t\t\treturn 0.1;\n\t\tcase MATERIAL_WOOD:\n\t\t\treturn 0.2;\n\t\tdefault:\n\t\t\treturn 0.0;\n\t}\n}\n\n// Get refractive index of a material.\n// 1.0 is a vacuum.\n// 1.33 is the refractive index of water.\nfloat get_material_refractive_index(int material) {\n\tswitch (material) {\n\t\tcase MATERIAL_GLASS:\n\t\t\treturn 1.5;\n\t\tcase MATERIAL_METAL:\n\t\t\treturn 1.0;\n\t\tcase MATERIAL_PLASTIC:\n\t\t\treturn 1.33;\n\t\tcase MATERIAL_WOOD:\n\t\t\treturn 1.33;\n\t\tdefault:\n\t\t\treturn 1.0;\n\t}\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n\tswitch (material) {\n\t\tcase MATERIAL_GLASS:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t\tcase MATERIAL_METAL:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t\tcase MATERIAL_PLASTIC:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t\tcase MATERIAL_WOOD:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t\tdefault:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t}\n}\n\n// Get the emission of a material.\nvec3 get_material_emission(int material) {\n\tswitch (material) {\n\t\tcase MATERIAL_GLASS:\n\t\t\treturn vec3(0.0, 0.0, 0.0);\n\t\tcase MATERIAL_METAL:\n\t\t\treturn vec3(0.0, ", "\n\tswitch (material) {\n\t\tcase MATERIAL_GLASS:\n\t\t\treturn 1.5;\n\t\tcase MATERIAL_PLASTIC:\n\t\t\treturn 1.25;\n\t\tcase MATERIAL_WATER:\n\t\t\treturn 1.33;\n\t\tcase MATERIAL_ICE:\n\t\t\treturn 1.31;\n\t\tcase MATERIAL_DIAMOND:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_GOLD:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_SILVER:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_PLATINUM:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_EMERALD:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_RUBY:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_SAPPHIRE:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_AMETHYST:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_OPAL:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_TOPAZ:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_DIAMOND_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_GOLD_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_SILVER_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_PLATINUM_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_EMERALD_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_RUBY_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_SAPPHIRE_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_AMETHYST_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_OPAL_RAINBOW:\n\t\t\treturn 2.42;\n\t\tcase MATERIAL_", "\n    return materials[material].opacity;\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return materials[material].color;\n}\n\n// Get the ambient color of a material.\nvec3 get_material_ambient(int material) {\n    return materials[material].ambient;\n}\n\n// Get the diffuse color of a material.\nvec3 get_material_diffuse(int material) {\n    return materials[material].diffuse;\n}\n\n// Get the specular color of a material.\nvec3 get_material_specular(int material) {\n    return materials[material].specular;\n}\n\n// Get the shininess of a material.\nfloat get_material_shininess(int material) {\n    return materials[material].shininess;\n}\n\n// Get the emission color of a material.\nvec3 get_material_emission(int material) {\n    return materials[material].emission;\n}\n\n// Get the texture of a material.\nint get_material_texture(int material) {\n    return materials[material].texture;\n}\n\n// Get the bump map of a material.\nint get_material_bump_map(int material) {\n    return materials[material].bump_map;\n}\n\n// Get the bump map scale of a material.\nfloat get_material_bump_map_scale(int material) {\n    return materials[material].bump_map_scale;\n}\n\n// Get the normal map of a material.\nint get_material_normal_map(int material) {\n    return materials[material].normal_map;\n}\n\n// Get the normal map scale of a material.\nfloat get_material_normal_map_scale(int material) {\n    return materials[material].normal_map_scale;\n}\n\n// Get the reflection map of a material.\nint get_material_reflection_map(int material) {\n    return materials[material].reflection_map;\n}\n\n// Get the reflection map scale of a material.\nfloat get_material_reflection_map_scale(int material) {\n    return materials[material].reflection_map_scale;\n}\n\n// Get the transparency map of a material.\nint get_material_transparency_map(int material", "\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    vec3 n = cross(u, v);\n    vec3 w0 = tri_a - line_a;\n    vec3 w = line_b - line_a;\n    float d = dot(cross(w, u), n);\n    float s = dot(cross(w0, u), n);\n    float t = dot(cross(w, v), n);\n    float r = dot(cross(w0, v), n);\n    vec3 result = vec3(false, 0.0, 0.0);\n    if (abs(d) < 0.000001) {\n        return result;\n    }\n    float inv_d = 1.0 / d;\n    s *= inv_d;\n    t *= inv_d;\n    r *= inv_d;\n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0 && r >= 0.0) {\n        result.x = true;\n        result.y = s;\n        result.z = t;\n    }\n    return result;\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    vec3 n = cross(u, v);\n    vec3 w0 = tri_a - line_a;\n    vec3 w = line_b - line_a;\n    float d = dot(cross(w, u), n);\n    float s = dot(cross(w0, u), n);\n    float t = dot(cross(w, v), n);\n    float r = dot(cross(w0, v), n);\n    vec3 result = vec3(false, 0.0, 0.0);\n    if (abs(d) < 0.0000", "\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec2 tri_a, vec2 tri_b, vec2 tri_c) {\n    vec2 u = tri_b - tri_a;\n    vec2 v = tri_c - tri_a;\n    return normalize(vec3(cross(u, v), 0.0));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec2 tri_a, vec2 tri_b, vec2 tri_c, vec3 tri_a_normal, vec3 tri_b_normal, vec3 tri_c_normal) {\n    vec2 u = tri_b - tri_a;\n    vec2 v = tri_c - tri_a;\n    return normalize(vec3(cross(u, v), 0.0));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_a_normal, vec3 tri_b_normal, vec3 tri_c_normal) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat3(x_axis, y_axis, z_axis);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(fov / 2.0);\n    float nf = 1.0 / (near - far);\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) * nf, -1.0,\n        0.0, 0.0, (2.0 * far * near) * nf, 0.0\n    );\n}\n\n// Generate an orthographic projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-orthographic-projection-matrix\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    float lr = 1.0 / (left - right);\n    float bt = 1.0 / (bottom - top);\n    float nf = 1.0 / (near - far);\n    return mat4(\n        -2.0 * lr, 0.0, 0.0, 0.0,\n        0.0, -2.0 * bt, 0.0, 0.0,\n        0.0, 0.0, 2.0 * nf, 0.0,\n        (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1.0\n   ", "\n\tcast_ray_result result;\n\tresult.hit = false;\n\tresult.distance = 1000000.0;\n\tresult.normal = vec3(0.0, 0.0, 0.0);\n\tresult.color = vec3(0.0, 0.0, 0.0);\n\tresult.material = 0;\n\tresult.object_id = 0;\n\n\tfor (int i = 0; i < num_triangles; i++) {\n\t\tvec3 p0 = triangles[i].p0;\n\t\tvec3 p1 = triangles[i].p1;\n\t\tvec3 p2 = triangles[i].p2;\n\t\tvec3 normal = triangles[i].normal;\n\t\tvec3 color = triangles[i].color;\n\t\tint material = triangles[i].material;\n\t\tint object_id = triangles[i].object_id;\n\n\t\tfloat t = intersect_triangle(ray_origin, ray_target, p0, p1, p2);\n\t\tif (t > 0.0 && t < result.distance) {\n\t\t\tresult.hit = true;\n\t\t\tresult.distance = t;\n\t\t\tresult.normal = normal;\n\t\t\tresult.color = color;\n\t\t\tresult.material = material;\n\t\t\tresult.object_id = object_id;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Trace a ray through the scene, returning the color of the pixel\n// that the ray hits.\nvec3 trace_ray(vec3 ray_origin, vec3 ray_target) {\n\tcast_ray_result result = cast_ray(ray_origin, ray_target);\n\tif (result.hit) {\n\t\treturn result.color;\n\t} else {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t}\n}\n\n// Trace a ray through the scene, returning the color of the pixel\n// that the ray hits.\nvec3 trace_ray_with_depth(vec3 ray_origin, vec3 ray_target, float depth) {\n\tcast_ray_result result = cast_ray(ray_origin, ray_target);\n\tif (result.hit) {\n\t\t", "\n\t// Calculate the ray's direction and length.\n\tvec3 ray_direction = normalize(ray_target - ray_origin);\n\tfloat ray_length = length(ray_target - ray_origin);\n\n\t// Initialize the ray's position.\n\tvec3 ray_position = ray_origin;\n\n\t// Initialize the ray's opacity.\n\tfloat ray_opacity = 1.0;\n\n\t// Initialize the ray's distance from the surface.\n\tfloat ray_distance = 0.0;\n\n\t// Initialize the ray's color.\n\tvec3 ray_color = vec3(0.0);\n\n\t// Initialize the ray's normal.\n\tvec3 ray_normal = vec3(0.0);\n\n\t// Initialize the ray's material.\n\tMaterial ray_material;\n\n\t// Initialize the ray's refractive index.\n\tfloat ray_refractive_index = 1.0;\n\n\t// Initialize the ray's reflection coefficient.\n\tfloat ray_reflection_coefficient = 0.0;\n\n\t// Initialize the ray's refraction coefficient.\n\tfloat ray_refraction_coefficient = 0.0;\n\n\t// Initialize the ray's refraction index.\n\tfloat ray_refraction_index = 0.0;\n\n\t// Initialize the ray's refraction ray origin.\n\tvec3 ray_refraction_ray_origin = vec3(0.0);\n\n\t// Initialize the ray's refraction ray direction.\n\tvec3 ray_refraction_ray_direction = vec3(0.0);\n\n\t// Initialize the ray's refraction ray length.\n\tfloat ray_refraction_ray_length = 0.0;\n\n\t// Initialize the ray's refraction ray position.\n\tvec3 ray_refraction_ray_position = vec3(0.0);\n\n\t// Initialize the ray's refraction ray opacity.\n\tfloat ray_refraction_ray_opacity = 0.0;\n\n\t// Initialize the ray's refraction ray distance.\n\tfloat ray_refraction_ray_distance = 0.0;\n\n\t// Initialize the ray's refraction ray color.\n\tvec3 ray_refraction_ray_color = vec3(0.0);\n\n\t// Initialize the ray's refraction ray normal.\n\tvec3 ray_", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f*f*(3.0-2.0*f);\n    return mix( nrand(i), nrand(i+1.0), u );\n}\n\n// Fractional Brownian motion, fBm\nfloat fbm( in float x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i=0; i<4; ++i) {\n        v += a*bnoise(x);\n        x = x*2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D fBm\nfloat fbm( in vec2 p )\n{\n    float freq = 0.5;\n    float amp = 0.5;\n    float v = 0.0;\n    v += amp*fbm( p.x*freq + 0.0*time );\n    v += amp*fbm( p.x*freq + 1.0*time );\n    v += amp*fbm( p.x*freq + 2.0*time );\n    v += amp*fbm( p.x*freq + 3.0*time );\n    return v;\n}\n\n// 3D fBm\nfloat fbm( in vec3 p )\n{\n    float freq = 0.5;\n    float amp = 0.5;\n    float v = 0.0;\n    v += amp*fbm( p.x*freq + 0.0*time );\n    v += amp*fbm( p.x*freq + 1.0*time );\n    v += amp*fbm( p.x*freq + 2.0*time );\n    v += amp*fbm( p.x*freq + 3.0*time );\n    return v;\n}\n\n// 4D fBm\nfloat fbm( in vec4 p )\n{\n    float freq = 0.5;\n    float amp = 0.5;\n    float v = 0.0;\n    v += amp*fbm( p.x*freq + 0.0*time );\n    v += amp*fbm( p.", "\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(noise(fl), noise(fl + 1.0), fc);\n}\n\n// Fractional Brownian motion, also called turbulence\nfloat fbm( in float p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p *= 2.02;\n    f += 0.2500*noise( p ); p *= 2.03;\n    f += 0.1250*noise( p ); p *= 2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n// 2D Fractional Brownian motion\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n// 3D Fractional Brownian motion\nfloat fbm( in vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n// 4D Fractional Brownian motion\nfloat fbm( in vec4 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += ", "\n    return fract(sin(float(n))*43758.5453);\n}\n\n// 2D value noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n// 3D value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// 4D value noise\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z + 17.0*p.w;\n\n    return mix(mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                       mix( hash(n+ 57.0), hash(n+ 58", "\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(noise(fl), noise(fl + 1.0), fc);\n}\n\n// fbm\nfloat fbm( in float p )\n{\n    float f = 0.0;\n    f += 0.5000*gnoise( p ); p *= 2.02;\n    f += 0.2500*gnoise( p ); p *= 2.03;\n    f += 0.1250*gnoise( p ); p *= 2.01;\n    f += 0.0625*gnoise( p );\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*gnoise( p ); p = m*p*2.02;\n    f += 0.2500*gnoise( p ); p = m*p*2.03;\n    f += 0.1250*gnoise( p ); p = m*p*2.01;\n    f += 0.0625*gnoise( p );\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*gnoise( p ); p = m*p*2.02;\n    f += 0.2500*gnoise( p ); p = m*p*2.03;\n    f += 0.1250*gnoise( p ); p = m*p*2.01;\n    f += 0.0625*gnoise( p );\n    return f;\n}\n\n// fbm\nfloat fbm( in vec4 p )\n{\n    float f = 0.0;\n    f += 0.5000*gnoise( p ); p = m*p*2.02;\n    f += 0.2500*gnoise( p ); p = m*p*2.03;\n    f += 0.1250*gnoise( p ); p", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= G;\n    }\n    return v;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= G;\n    }\n    return v;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= G;\n    }\n    return v;\n}\n\n// fbm\nfloat fbm( in vec4 x, in float G )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec4 shift = vec4(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -", "\n    // Compute the quadratic polynomial coefficients\n    vec3 a = p*p;\n    vec3 b = 3.0*p;\n    vec3 c = 1.0;\n\n    // Compute the solutions of the polynomial\n    vec3 s = solveCubic( a, b, c );\n\n    // Return the color based on the solutions\n    return vec3( 1.0, 0.0, 0.0 ) * ( 1.0 - s.x ) +\n           vec3( 0.0, 1.0, 0.0 ) * ( 1.0 - s.y ) +\n           vec3( 0.0, 0.0, 1.0 ) * ( 1.0 - s.z );\n}\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec3 getColor( in vec3 p, in vec3 n )\n{\n    // Compute the quadratic polynomial coefficients\n    vec3 a = p*p;\n    vec3 b = 3.0*p;\n    vec3 c = 1.0;\n\n    // Compute the solutions of the polynomial\n    vec3 s = solveCubic( a, b, c );\n\n    // Return the color based on the solutions\n    return vec3( 1.0, 0.0, 0.0 ) * ( 1.0 - s.x ) +\n           vec3( 0.0, 1.0, 0.0 ) * ( 1.0 - s.y ) +\n           vec3( 0.0, 0.0, 1.0 ) * ( 1.0 - s.z );\n}\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec3 getColor( in vec3 p, in vec3 n, in vec3 v )\n{\n    // Compute the quadratic polynomial coefficients\n    vec3 a = p*p;\n    vec3 b = 3.0*p;\n    vec3 c = 1.0;\n\n    // Compute the solutions of the polynomial\n    vec3 s = solveCubic( a, b, c );\n\n    // Return the color based on the solutions\n    return vec3( 1.0, 0.0,", "\n    // 4D point in a unit sphere\n    vec4 p = vec4(pb,1.0);\n    // 4D point in a unit box\n    p = p*p;\n    // 3D point in a unit box\n    vec3 p3 = p.xyz;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in a unit sphere\n    p = p*p;\n    // 3D point in a unit box\n    p3 = p3*p3;\n    // 3D point in", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0 ) return vec4(-1.0);\n    return vec4(tN,tF,tN,1.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float", "\n    vec3 m = 1.0/rad;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rd;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return clamp( (tN > 0.0)? tN : tF, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat rmShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float k ) \n{\n    vec3 m = 1.0/rad;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rd;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return clamp( (tN > 0.0)? tN : tF, 0.0, 1.0 ) * k.x * k.y * k.z;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat rmShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float k, inout float resDist ) \n{\n    vec3 m = 1.0/rad;\n    vec3 n = m*ro-m*cen;\n    vec3 k = abs(m)*rd;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x,", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t).x;\n        res = min(res, w * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Main\n//\n//------------------------------------------------------------------\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < 64; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 h = map(p);\n        float d = h.x;\n        col = mix(col, h.y, smoothstep(0.0, 0.01, d));\n        t += d;\n        if (d < 0.001 || t > 10.0)\n            break;\n    }\n\n    // lighting\n    vec3 lpos = vec3(0.0, 0.0, 1.0);\n    vec3 ldir = normalize(lpos - ro);\n    float ldist = length(lpos - ro);\n    float lsoft = apprSoftShadow(ro, ldir, 0.02, ldist, 16.0);\n    float ldiff = max(0.0, dot(ldir, normal));\n    float lspec = pow(max(0.0, dot(reflect(-ldir, normal), -rd)), 32.0);\n    vec3 lcol = vec3(1.0) * 0.25 + vec3(0.5, 0.7, 1.0) * 0", " seed = fract(sin(seed) * 10000.0); return seed; }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co) { return fract(sin(dot(co.xyz,vec3(12.9898,78.233,123.456))) * 43758.5453); }\nfloat rand(vec4 co) { return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,123.456,1234.567))) * 43758.5453); }\n\nfloat rand_range(float min, float max) { return rand() * (max - min) + min; }\nvec3 rand_range(vec3 min, vec3 max) { return rand_range(min.x, max.x), rand_range(min.y, max.y), rand_range(min.z, max.z); }\nvec4 rand_range(vec4 min, vec4 max) { return rand_range(min.x, max.x), rand_range(min.y, max.y), rand_range(min.z, max.z), rand_range(min.w, max.w); }\n\nfloat rand_range(float min, float max, float seed) { return rand(seed) * (max - min) + min; }\nvec3 rand_range(vec3 min, vec3 max, float seed) { return rand_range(min.x, max.x, seed), rand_range(min.y, max.y, seed), rand_range(min.z, max.z, seed); }\nvec4 rand_range(vec4 min, vec4 max, float seed) { return rand_range(min.x, max.x, seed), rand_range(min.y, max.y, seed), rand_range(min.z, max.z, seed),", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float f = 0.0;\n    float t = 0.0;\n    float s = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float l = 0.0;\n    float k = 0.0;\n    float j = 0.0;\n    float i = 0.0;\n    float h = 0.0;\n    float g = 0.0;\n    float e = 0.0;\n    float d = 0.0;\n    float c = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float z = 0.0;\n    float y = 0.0;\n    float x = 0.0;\n    float w = 0.0;\n    float v = 0.0;\n    float u = 0.0;\n    float t = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float q = 0.0;\n    float p = 0.0;\n    float o = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float l = 0.0;\n    float k = 0.0;\n    float j = 0.0;\n    float i = 0.0;\n    float h = 0.0;\n    float g = 0.0;\n    float f = 0.0;\n    float e = 0.0;\n    float d = 0.0;\n    float c = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float z = 0.0;\n    float y = 0.0;\n    float x", "\n    p.z -= h;\n    float b = abs(p.x);\n    float a = abs(p.y);\n    float q = max(a,b);\n    float d = q - ra;\n    if(d < 0.0) return length(max(vec2(b,a),0.0)) - ra;\n    if(q > la) return d;\n    float s = ra*ra - (d*d);\n    if(s < 0.0) return d;\n    s = sqrt(s);\n    float r = ra - s;\n    if(q < lb) return r;\n    return length(max(vec2(b,a),0.0)) - r;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h)\n{\n    return sdRhombus(p, la, lb, h, 0.0);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb)\n{\n    return sdRhombus(p, la, lb, 0.0);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p)\n{\n    return sdRhombus(p, 1.0, 1.0, 0.0);\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec2 p, float la, float lb, float h, float ra)\n{\n    p.y -= h;\n    float b = abs(p.x);\n    float a = abs(p.y);\n    float q = max(a,b);\n    float d = q - ra;\n    if(d < 0.0) return length(max(vec2(b,a),0.0)) - ra;\n    if(q > la) return d;\n    float s = ra*ra - (d*d);\n    if(s < 0.0) return d;\n    s = sqrt(s);\n    float r = ra - s;\n    if(q < lb) return r;\n    return length(max", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + ba*h;\n    vec2 ab = q - p;\n    float d = length(ab);\n    float w = d - r;\n    float w2 = w * w;\n    float w4 = w2 * w2;\n    float w6 = w4 * w2;\n    float w8 = w6 * w2;\n    float w10 = w8 * w2;\n    float w12 = w10 * w2;\n    float w14 = w12 * w2;\n    float w16 = w14 * w2;\n    float w18 = w16 * w2;\n    float w20 = w18 * w2;\n    float w22 = w20 * w2;\n    float w24 = w22 * w2;\n    float w26 = w24 * w2;\n    float w28 = w26 * w2;\n    float w30 = w28 * w2;\n    float w32 = w30 * w2;\n    float w34 = w32 * w2;\n    float w36 = w34 * w2;\n    float w38 = w36 * w2;\n    float w40 = w38 * w2;\n    float w42 = w40 * w2;\n    float w44 = w42 * w2;\n    float w46 = w44 * w2;\n    float w48 = w46 * w2;\n    float w50 = w48 * w2;\n    float w52 = w50 * w2;\n    float w54 = w52 * w2;\n    float w56 = w54 * w2;\n    float w58 = w56 * w2;\n    float w60 = w58 * w2;\n    float w62 = w60 * w2;\n    float w64 = w62 * w2;\n    float w66 = w64 * w2;\n    float w68 = w66 * w2", "\n    vec2 d = abs(p)-b;\n    float e = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    float f = r-e;\n    float g = s-f;\n    return vec4( e, f, g, f );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, \n               in float r, \n               in float s )\n{\n    float d = length(p)-r;\n    float f = s-d;\n    return vec4( d, d, f, f );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paEllipse( in vec2 p, \n                in vec2 b, in float r, \n                in float s )\n{\n    vec2 d = abs(p/b)-vec2(1.0);\n    float e = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    float f = r-e;\n    float g = s-f;\n    return vec4( e, f, g, f );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paLine( in vec2 p, \n            in vec2 a, in vec2 b, \n            in float r, \n            in float s )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + ba*h;\n    float d = length(p-q);\n    float f = s-d;\n    return vec4( d, d, f, f );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, \n            in vec2 a, in vec2 b, in vec2 c", "\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs(vec2(length(p.x),p.y)) - c;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCone( in vec2 p, in vec3 c )\n{\n    // c.xy = cone axis direction, c.z = cone angle\n    vec2 q = vec2(length(p.xy),p.", "\n    vec2  c = vec2(0.0);\n    float d = length(p-c) - r;\n    float w = d;\n    float z = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    if( d < 0.0 )\n    {\n        d = 0.0;\n    }\n    else\n    {\n        float a = atan(p.y,p.x);\n        float b = mod(a,band);\n        if( b < band/2.0 )\n        {\n            x = d;\n            y = band/2.0 - b;\n            z = band/2.0;\n        }\n        else\n        {\n            x = d;\n            y = b - band/2.0;\n            z = band/2.0;\n        }\n    }\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paEllipse( in vec2 p, vec2 r, float band ) \n{\n    vec2  c = vec2(0.0);\n    float d = length(p-c) - length(p-c)/r;\n    float w = d;\n    float z = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    if( d < 0.0 )\n    {\n        d = 0.0;\n    }\n    else\n    {\n        float a = atan(p.y,p.x);\n        float b = mod(a,band);\n        if( b < band/2.0 )\n        {\n            x = d;\n            y = band/2.0 - b;\n            z = band/2.0;\n        }\n        else\n        {\n            x = d;\n            y = b - band/2.0;\n            z = band/2.0;\n        }\n    }\n    return vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRectangle( in vec2 p, vec2 r, float band ) \n{\n    vec2  c =", "\n    float d = 1e9;\n    for( int i=0; i<5; i++ )\n    {\n        d = min( d, sdPoly(p, verts[i], verts[(i+1)%5], r) );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    float d = 1e9;\n    for( int i=0; i<5; i++ )\n    {\n        d = min( d, sdPoly(p, verts[i], verts[(i+1)%5], r) );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    float d = 1e9;\n    for( int i=0; i<5; i++ )\n    {\n        d = min( d, sdPoly(p, verts[i], verts[(i+1)%5], r) );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    float d = 1e9;\n    for( int i=0; i<5; i++ )\n    {\n        d = min( d, sdPoly(p, verts[i], verts[(i+1)%5], r) );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    float d = 1e9;\n    for( int i=0; i<5; i++ )\n    {\n        d = min( d, sdPoly(p, verts[i], verts[(i+1)%5], r) );\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec", "\n    vec2 v0 = verts[0];\n    vec2 v1 = verts[1];\n    vec2 v2 = verts[2];\n    vec2 v3 = verts[3];\n    vec2 v4 = verts[4];\n\n    vec2 v01 = v1 - v0;\n    vec2 v02 = v2 - v0;\n    vec2 v03 = v3 - v0;\n    vec2 v04 = v4 - v0;\n\n    vec2 v12 = v2 - v1;\n    vec2 v13 = v3 - v1;\n    vec2 v14 = v4 - v1;\n\n    vec2 v23 = v3 - v2;\n    vec2 v24 = v4 - v2;\n\n    vec2 v34 = v4 - v3;\n\n    vec2 v0p = p - v0;\n    vec2 v1p = p - v1;\n    vec2 v2p = p - v2;\n    vec2 v3p = p - v3;\n    vec2 v4p = p - v4;\n\n    float d01 = dot( v01, v01 );\n    float d02 = dot( v02, v02 );\n    float d03 = dot( v03, v03 );\n    float d04 = dot( v04, v04 );\n\n    float d12 = dot( v12, v12 );\n    float d13 = dot( v13, v13 );\n    float d14 = dot( v14, v14 );\n\n    float d23 = dot( v23, v23 );\n    float d24 = dot( v24, v24 );\n\n    float d34 = dot( v34, v34 );\n\n    float d0p = dot( v0p, v0p );\n    float d1p = dot( v1p, v1p );\n    float d2p = dot( v2p, v2p );\n    float d3p = dot( v3p, v3p );\n    float d4p = dot( v4p, v4p );\n\n    float a01 = acos( dot( v01, v0p ) / sqrt( d01 * d", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( a + ba*h, normalize( vec3( ba.y, -ba.x, 0.0 ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    vec2 pc = p - c;\n    float d = length( pc );\n    return vec3( c + pc*r/d, normalize( pc ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 pc = p - c;\n    float d = length( pc/r );\n    return vec3( c + pc*r/d, normalize( pc ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs( p ) - b;\n    vec2 q = vec2( max( d.x, d.y ), min( d.x, d.y ) );\n    float d1 = length( q - r );\n    float d2 = length( q + r ) - r.x*2.0;\n    float d = min( d1, d2 );\n    vec2 n = vec2( sign( p.x ), sign", "\n    vec3 q = vec3(p.xy,r);\n    vec3 h = vec3(0.0);\n    float s = 0.0;\n    float t = 0.0;\n    for( int i=0; i<6; i++ )\n    {\n        h += snoise( q + float(i)*0.5 ) * float(i%2==0?1:-1);\n        s += snoise( q + float(i)*0.5 + 100.0 ) * float(i%2==0?1:-1);\n        t += snoise( q + float(i)*0.5 + 200.0 ) * float(i%2==0?1:-1);\n    }\n    vec3 n = vec3(h.xy,-h.z);\n    float l = length(n);\n    if( l>0.0 ) n /= l;\n    return vec3( s, n.x, n.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec2 p ) \n{\n    return sdgHexagon( p, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec3 p, in float r ) \n{\n    vec3 q = vec3(p.xy,r);\n    vec3 h = vec3(0.0);\n    float s = 0.0;\n    float t = 0.0;\n    for( int i=0; i<6; i++ )\n    {\n        h += snoise( q + float(i)*0.5 ) * float(i%2==0?1:-1);\n        s += snoise( q + float(i)*0.5 + 100.0 ) * float(", "\n    float A = dot(X[0], p);\n    float B = dot(X[1], p);\n    float C = dot(X[2], p);\n    float D = A*A + B*B - C*C;\n    if (D < 0.0) {\n        return false;\n    }\n    float sqrtD = sqrt(D);\n    tan1 = vec3(A + sqrtD, B, -C);\n    tan2 = vec3(A - sqrtD, B, -C);\n    return true;\n}\n\n// Find the point on conic X closest to p.\nvec3 closest(vec3 p, mat3 X) {\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2)) {\n        return p - X * tan1;\n    }\n    return p - X * p;\n}\n\n// Find the point on conic X closest to p, and the tangent at that point.\nvec3 closest(vec3 p, mat3 X, out vec3 tan) {\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2)) {\n        tan = X * tan1;\n        return p - tan;\n    }\n    tan = X * p;\n    return p - tan;\n}\n\n// Find the point on conic X closest to p, and the tangent at that point.\nvec3 closest(vec3 p, mat3 X, out vec3 tan, out float t) {\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2)) {\n        tan = X * tan1;\n        t = dot(tan, tan);\n        return p - tan;\n    }\n    tan = X * p;\n    t = dot(tan, tan);\n    return p - tan;\n}\n\n// Find the point on conic X closest to p, and the tangent at that point.\nvec3 closest(vec3 p, mat3 X, out vec3 tan, out float t, out vec3 n) {\n    vec3 tan1, tan2;\n    if (tangents(p, X, tan1, tan2)) {\n        tan = X * tan1;\n        t = dot(tan, tan);\n        n = normalize(cross(tan, X[", "\n\treturn a / (b + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 a)\n{\n    return RotateX(RotateY(RotateZ(p, a.z), a.y), a.x);\n}\n\nvec3 Rotate(vec3 p, float a)\n{\n    return Rotate(p, vec3(0.0, 0.0, a));\n}\n\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p + t;\n}\n\nvec3 Scale(vec3 p, vec3 s)\n{\n    return p * s;\n}\n\nvec3 Scale(vec3 p, float s)\n{\n    return p * s;\n}\n\nvec3 Reflect(vec3 p, vec3 n)\n{\n    return p - 2.0 * dot(p, n) * n;\n}\n\nvec3 Reflect(vec3 p, float n)\n{\n    return p - 2.0 * dot(p, n) * n;\n}\n\nvec3 Refract(vec3 p, vec3 n, float ior)\n{\n    float d = dot(p, n);\n    float k = 1.0 - ior * ior * (1.0 - d * d);\n    return ior * p - (ior * d + sqrt(k)) * n;\n}\n\nvec3 Refract(vec3 p, float n, float ior)\n{\n    float d = dot(p,", "\n\tfloat f = (x / R);\n\treturn f * f * (3.0 - 2.0 * f);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat FalloffLinear(float x, float R)\n{\n\treturn 1.0 - clamp(x / R, 0.0, 1.0);\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat FalloffExp(float x, float R)\n{\n\treturn 1.0 - exp(-x / R);\n}\n\n// Inverse square falloff\n// x: distance\n// R: radius\nfloat FalloffInvSq(float x, float R)\n{\n\treturn 1.0 / (1.0 + x * x / (R * R));\n}\n\n// Inverse cubic falloff\n// x: distance\n// R: radius\nfloat FalloffInvCubic(float x, float R)\n{\n\treturn 1.0 / (1.0 + x * x * x / (R * R * R));\n}\n\n// Inverse quartic falloff\n// x: distance\n// R: radius\nfloat FalloffInvQuart(float x, float R)\n{\n\treturn 1.0 / (1.0 + x * x * x * x / (R * R * R * R));\n}\n\n// Inverse quintic falloff\n// x: distance\n// R: radius\nfloat FalloffInvQuint(float x, float R)\n{\n\treturn 1.0 / (1.0 + x * x * x * x * x / (R * R * R * R * R));\n}\n\n// Inverse sextic falloff\n// x: distance\n// R: radius\nfloat FalloffInvSext(float x, float R)\n{\n\treturn 1.0 / (1.0 + x * x * x * x * x * x / (R * R * R * R * R * R));\n}\n\n// Inverse septic falloff\n// x: distance\n// R: radius\nfloat FalloffInvSept(float x, float R)\n{", "\n\treturn 1.0f / (1.0f - e * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float& dKde)\n{\n\tfloat K = 1.0f / (1.0f - e * R);\n\tdKde = -K / (1.0f - e * R);\n\treturn K;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float& dKde, float& dKde2)\n{\n\tfloat K = 1.0f / (1.0f - e * R);\n\tdKde = -K / (1.0f - e * R);\n\tdKde2 = K / (1.0f - e * R) / (1.0f - e * R);\n\treturn K;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float& dKde, float& dKde2, float& dKde3)\n{\n\tfloat K = 1.0f / (1.0f - e * R);\n\tdKde = -K / (1.0f - e * R);\n\tdKde2 = K / (1.0f - e * R) / (1.0f - e * R);\n\tdKde3 = -K / (1.0f - e * R) / (1.0f - e * R) / (1.0f - e * R);\n\treturn K;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float& dKde, float& dKde2, float& dKde3, float& dKde4)\n{\n\tfloat K = 1.0f / (1.0f - e", "\n\tfloat k = 0.0f;\n\tif (e < 0.0f)\n\t{\n\t\tk = 0.0f;\n\t}\n\telse if (e < 1.0f)\n\t{\n\t\tk = (a - b) / (1.0f - e);\n\t}\n\telse\n\t{\n\t\tk = (a - b) / (1.0f - e) + (a - b) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) * (1.0f - e) / (1.0f - e) *", "\n    return length(p - c) - R;\n}\n\n// Line primitive field function\n// p: world point\n// a: start point\n// b: end point\n// e: energy\nfloat Vertex(vec3 p, vec3 a, vec3 b, float e)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    return length(ap - ab * t) - e;\n}\n\n// Plane primitive field function\n// p: world point\n// n: normal\n// d: distance\n// e: energy\nfloat Vertex(vec3 p, vec3 n, float d, float e)\n{\n    return dot(p, n) - d - e;\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Vertex(vec3 p, vec3 c, vec3 s, float e)\n{\n    vec3 q = abs(p - c) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - e;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// r: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float r, float e)\n{\n    return length(p - c) - r - e;\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// r: radius\n// R: tube radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float r, float R, float e)\n{\n    vec2 q = vec2(length(p.xz - c.xz) - r, p.y - c.y);\n    return length(q) - R - e;\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// r: radius\n// h: height\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float r, float h, float e)\n{\n    vec2 q = vec2(length", "\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 bc = c - b;\n    float ab2 = dot(ab, ab);\n    float ac2 = dot(ac, ac);\n    float bc2 = dot(bc, bc);\n    float abac = dot(ab, ac);\n    float abbc = dot(ab, bc);\n    float acbc = dot(ac, bc);\n    float t = clamp(abac / ab2, 0.0, 1.0);\n    float s = clamp(acbc / ab2, 0.0, 1.0);\n    float t2 = t * t;\n    float s2 = s * s;\n    float t3 = t2 * t;\n    float s3 = s2 * s;\n    float t4 = t3 * t;\n    float s4 = s3 * s;\n    float t5 = t4 * t;\n    float s5 = s4 * s;\n    float t6 = t5 * t;\n    float s6 = s5 * s;\n    float t7 = t6 * t;\n    float s7 = s6 * s;\n    float t8 = t7 * t;\n    float s8 = s7 * s;\n    float t9 = t8 * t;\n    float s9 = s8 * s;\n    float t10 = t9 * t;\n    float s10 = s9 * s;\n    float t11 = t10 * t;\n    float s11 = s10 * s;\n    float t12 = t11 * t;\n    float s12 = s11 * s;\n    float t13 = t12 * t;\n    float s13 = s12 * s;\n    float t14 = t13 * t;\n    float s14 = s13 * s;\n    float t15 = t14 * t;\n    float s15 = s14 * s;\n    float t16 = t15 * t;\n    float s16 = s15 * s;\n    float t17 = t16 * t;\n    float s17 = s16 * s;\n    float t18 = t17 * t;\n    float s18 = s17 * s;\n    float t", "\n\tfloat d = 1e10;\n\td = min(d, Sphere(p, 1.0));\n\td = min(d, Box(p, vec3(1.0, 0.2, 0.5)));\n\td = min(d, Box(p, vec3(0.2, 1.0, 0.5)));\n\td = min(d, Box(p, vec3(0.5, 0.2, 1.0)));\n\td = min(d, Box(p, vec3(0.2, 0.5, 1.0)));\n\td = min(d, Box(p, vec3(0.5, 1.0, 0.2)));\n\td = min(d, Box(p, vec3(1.0, 0.5, 0.2)));\n\td = min(d, Box(p, vec3(0.5, 0.2, 0.2)));\n\td = min(d, Box(p, vec3(0.2, 0.5, 0.2)));\n\td = min(d, Box(p, vec3(0.2, 0.2, 0.5)));\n\td = min(d, Box(p, vec3(0.2, 0.2, 0.2)));\n\treturn d;\n}\n\n// Ray marching\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO = 0.0;\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tvec3 p = ro + rd * dO;\n\t\tfloat dS = Object(p);\n\t\tdO += dS;\n\t\tif (dS < 0.001)\n\t\t{\n\t\t\tvec3 n = Normal(p);\n\t\t\tvec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\t\t\tfloat diff = max(0.0, dot(n, l));\n\t\t\tvec3 col = vec3(0.5) + diff * vec3(1.0);\n\t\t\treturn col;\n\t\t}", "\n\treturn length(a - b);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b)\n{\n\treturn length(a - b);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b)\n{\n\treturn length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n\treturn length(cross(b - a, c - a)) / length(b - a);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c)\n{\n\treturn length(cross(b - a, c - a)) / length(b - a);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b, vec4 c)\n{\n\treturn length(cross(b - a, c - a)) / length(b - a);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\treturn length(cross(c - b, d - b)) / length(c - b);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn length(cross(c - b, d - b)) / length(c - b);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b, vec4 c, vec4 d)\n{\n\treturn length(cross(c - b, d - b)) / length(c - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n\treturn length(cross(d - c, e - c)) / length(d - c);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d, vec2 e)\n{\n\treturn length(cross(d - c, e - c)) / length(d - c);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b, vec4 c, vec4 d, vec", "\n    vec3 n;\n    n.x = dFdx( p.x );\n    n.y = dFdy( p.y );\n    n.z = dFdx( p.z );\n    return normalize( n );\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n )\n{\n    vec3 nn;\n    nn.x = dFdx( p.x ) * n.x + dFdy( p.y ) * n.y + dFdx( p.z ) * n.z;\n    nn.y = dFdx( p.x ) * n.y + dFdy( p.y ) * n.z + dFdx( p.z ) * n.x;\n    nn.z = dFdx( p.x ) * n.z + dFdy( p.y ) * n.x + dFdx( p.z ) * n.y;\n    return normalize( nn );\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in float k )\n{\n    vec3 nn;\n    nn.x = dFdx( p.x ) * n.x + dFdy( p.y ) * n.y + dFdx( p.z ) * n.z;\n    nn.y = dFdx( p.x ) * n.y + dFdy( p.y ) * n.z + dFdx( p.z ) * n.x;\n    nn.z = dFdx( p.x ) * n.z + dFdy( p.y ) * n.x + dFdx( p.z ) * n.y;\n    return normalize( nn ) * k;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in float k, in float k2 )\n{\n    vec3 nn;\n    nn.x = dFdx( p.x ) * n.x + dFdy( p.y ) * n.y + dFdx( p.z ) * n.z;\n    nn.y = dFdx( p.x ) * n.y + dFdy( p.y ) * n.z + dFdx( p", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + t * u;\n\t\tfloat d = Sphere(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 n)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tvec3 p = o + t * u;\n\t\tfloat d = Sphere(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tn = normalize(p);\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 n, out vec3 p)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tp = o + t * u;\n\t\tfloat d = Sphere(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tn = normalize(p);\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s", "\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + t * u;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        p = o + t * u;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n)\n{\n    float t = 0.0;\n    h = false;\n    s = 0;\n    for (int i = 0; i < 100; i++)\n    {\n        p = o + t * u;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            n = Normal(p);\n            break;\n        }\n        t += d;\n        s++;\n    }\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n, out vec3 c)\n{\n    float t = 0.0;\n    h", "\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.5 + 0.5 * rd.y;\n\tcol = mix(vec3(0.1, 0.2, 0.3), vec3(0.7, 0.8, 1.0), t);\n\treturn col;\n}\n\nvec3 Shade(vec3 rd, vec3 pos, vec3 nor, vec3 col)\n{\n\tvec3 col2 = vec3(0.0);\n\tfloat t = 0.5 + 0.5 * nor.y;\n\tcol2 = mix(vec3(0.1, 0.2, 0.3), vec3(0.7, 0.8, 1.0), t);\n\tcol = mix(col, col2, 0.5);\n\treturn col;\n}\n\n// Raymarching\nvec3 Raymarch(vec3 ro, vec3 rd)\n{\n\tvec3 col = vec3(0.0);\n\tvec3 pos = ro;\n\tvec3 nor = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat eps = 0.001;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\td = sdSphere(pos, 1.0);\n\t\tif (d < eps)\n\t\t{\n\t\t\tnor = normalize(pos - ro);\n\t\t\tcol = Shade(rd, pos, nor, col);\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n\t\tpos = ro + t * rd;\n\t}\n\tif (t > 100.0)\n\t{\n\t\tcol = Background(rd);\n\t}\n\treturn col;\n}\n\n// Main\nvoid main()\n{\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 3.0);\n\tvec3 rd =", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// arbitrary orientation\nfloat sdCone( in vec3 p, in vec3 c, in float r1, in float r2 )\n{\n    // c is the apex, p is the point\n    // a is a point on the cone\n    vec3  ba = p - c;\n    float h = clamp( dot(ba, ba)/dot(ba, ba), 0.0, 1.0 );\n    return length(p - c - ba*h) - r1*h - r2*(1.0-h);\n}\n\n// arbitrary orientation\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float s = max(sqrt(dot(p.xz,p.xz)) - r2,q);\n    float d2 = max(s,d1);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// arbitrary orientation\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// arbitrary orientation\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// arbitrary orientation\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// arbitrary orientation\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iCylinder( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/dist", "\n    return coord / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(ivec2 coord) {\n    return vec2(coord) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(uvec2 coord) {\n    return vec2(coord) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord) {\n    return coord.xy / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(ivec3 coord) {\n    return vec2(coord.xy) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(uvec3 coord) {\n    return vec2(coord.xy) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord) {\n    return coord.xy / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(ivec4 coord) {\n    return vec2(coord.xy) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(uvec4 coord) {\n    return vec2(coord.xy) / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, int layer) {\n    return coord / vec2(textureSize(tex, layer));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(ivec2 coord, int layer) {\n    return vec2(coord) / vec2(textureSize(tex, layer));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(uvec2 coord, int layer) {\n    return vec2(coord) / vec2(textureSize(tex, layer));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord, int layer) {\n    return coord.xy / vec2(textureSize(tex, layer));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(ivec3 coord, int layer) {", "\n    vec2 w = p - 2.0*q;\n    vec2 a = w - dot(q,w)/dot(q,q)*q;\n    vec2 b = w - 2.0*a;\n    float d = dot(a,a);\n    float e = dot(b,b);\n    float s = sign( p.x*q.y - p.y*q.x );\n    float t = clamp( e/(d+e), 0.0, 1.0 );\n    float u = clamp( (d+e-t*t*d)/(2.0*e), 0.0, 1.0 );\n    vec3 res = vec3( 0.0 );\n    res.x = s*(1.0-u)*d + s*t*e;\n    res.y = s*(1.0-u)*2.0*dot(q,a) + s*t*2.0*dot(q,b);\n    res.z = s*(1.0-u)*2.0*q.x + s*t*2.0*q.y;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleEquilateral( in vec2 p, in vec2 q )\n{\n    vec2 w = p - 2.0*q;\n    vec2 a = w - dot(q,w)/dot(q,q)*q;\n    vec2 b = w - 2.0*a;\n    float d = dot(a,a);\n    float e = dot(b,b);\n    float s = sign( p.x*q.y - p.y*q.x );\n    float t = clamp( e/(d+e), 0.0, 1.0 );\n    float u = clamp( (d+e-t*t*d)/(2.0*e), 0.0, 1.0 );\n    vec3 res = vec3( 0.0 );\n    res.x = s*(1.0-", "\n    vec2 q = p - vec2(r, 0);\n    float l = length(q);\n    float a = atan(q.y, q.x);\n    float b = acos(l / r);\n    float c = a + b;\n    float s = sin(c);\n    float t = tan(c);\n    float x = r * (s - t * d);\n    float y = r * (s + t * d);\n    float z = r * (1.0 - d * d);\n    return vec3(x, y, z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p, float r)\n{\n    return sdgVesica(p, r, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec2 p)\n{\n    return sdgVesica(p, 1.0, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgVesica(vec3 p, float r, float d)\n{\n    vec2 q = p.xy - vec2(r, 0);\n    float l = length(q);\n    float a = atan(q.y, q.x);\n    float b = acos(l / r);\n    float c = a + b;\n    float s = sin(c);\n    float t = tan(c);\n    float x = r * (s - t * d);\n    float y = r * (s + t * d);\n    float", "\n    vec2 q = vec2( dot(p,c), length(p) - r );\n    float d = length(q);\n    float f = 1.0 - smoothstep( 0.0, r, d );\n    return vec3( f, q.x/d, q.y/d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in float c, in float r )\n{\n    return sdgPie( p, vec2(sin(c),cos(c)), r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in float r )\n{\n    return sdgPie( p, vec2(sin(PI/4.0),cos(PI/4.0)), r );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float w )\n{\n    vec2 q = vec2( dot(p,c), length(p) - r );\n    float d = length(q);\n    float f = 1.0 - smoothstep( 0.0, r, d );\n    return vec3( f, q.x/d, q.y/d );\n}\n\n//.x = f(p)\n//", "\n    vec3 e0 = vec3( v[2] - v[0], 0.0 );\n    vec3 e1 = vec3( v[1] - v[0], 0.0 );\n    vec3 s0 = vec3( v[0], 1.0 );\n    vec3 s1 = cross( e1, s0 );\n    vec3 s2 = cross( e0, s0 );\n    vec3 pvec = cross( s1, e0 );\n    float det = dot( s2, pvec );\n    vec3 tvec = vec3( p - v[0], 0.0 );\n    vec3 qvec = cross( tvec, s1 );\n    float invDet = 1.0 / det;\n    float u = dot( tvec, pvec ) * invDet;\n    float v = dot( qvec, s2 ) * invDet;\n    float t = dot( qvec, e1 ) * invDet;\n    vec3 pos = v[0] + u * e0 + v * e1;\n    vec3 normal = normalize( cross( e0, e1 ) );\n    vec3 grad = normalize( cross( s1, tvec ) );\n    return vec3( t, u, v );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec3 p, in float r )\n{\n    float d = length( p ) - r;\n    vec3 normal = normalize( p );\n    return vec3( d, normal );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    float m = max( d.x, max( d.y, d.z ) );\n    vec3 normal = normalize( sign", "\n    vec2 q = p;\n    float a = sca.x;\n    float b = sca.y;\n    float c = scb.x;\n    float d = scb.y;\n    float r = ra;\n    float s = rb;\n    float x = q.x;\n    float y = q.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float x2y2 = x2 + y2;\n    float x2y2r2 = x2y2*r*r;\n    float x2y2s2 = x2y2*s*s;\n    float x2y2rs = x2y2*r*s;\n    float x2y2rs2 = x2y2rs*s;\n    float x2y2rs4 = x2y2rs2*s;\n    float x2y2rs6 = x2y2rs4*s;\n    float x2y2rs8 = x2y2rs6*s;\n    float x2y2rs10 = x2y2rs8*s;\n    float x2y2rs12 = x2y2rs10*s;\n    float x2y2rs14 = x2y2rs12*s;\n    float x2y2rs16 = x2y2rs14*s;\n    float x2y2rs18 = x2y2rs16*s;\n    float x2y2rs20 = x2y2rs18*s;\n    float x2y2rs22 = x2y2rs20*s;\n    float x2y2rs24 = x2y2rs22*s;\n    float x2y2rs26 = x2y2rs24*s;\n    float x2y2rs28 = x2y2rs26*s;\n    float x2y2rs30 = x2y2rs28*s;\n    float x2y2rs32 = x2y2rs30*s;\n    float x2y2rs34 = x2y2rs32*s;\n    float x2y2rs36 = x2y2rs34*s;\n    float x2y2rs38", "\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) {\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec4 a, in vec4 b ) {\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec3 b ) {\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec2 b ) {\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec4 b ) {\n    return dot( a, b ) / length( b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec2 q = p / ab;\n    float r = dot( q, q );\n    float k = 1.0 - r;\n    float d = k * k;\n    float s = sqrt( d );\n    float n = ab.x * ab.y / sqrt( d );\n    vec3 res;\n    res.x = s;\n    res.y = n * q.x;\n    res.z = n * q.y;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( vec2 p, float r )\n{\n    float d = length( p );\n    float s = sqrt( r * r - d * d );\n    float n = r * r / d;\n    vec3 res;\n    res.x = s;\n    res.y = n * p.x;\n    res.z = n * p.y;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLine( vec2 p, vec2 a, vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    vec2 q = a + t * ab;\n    vec2 pq = q - p;\n    float d = length( pq );\n    float s = sqrt( d );\n    float n = 1.0 / d;\n    vec3 res;\n    res.x = s;\n    res.y = n * pq.x;\n    res.z = n * pq.y;\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\ufffd", "\n    vec3 q = vec3( length(p.xz) - ra, p.y, 0.0 );\n    float d = length(q) - rb;\n    return vec4( d, d - dot(q, q) / dot(q, q), 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float ra )\n{\n    float d = length(p) - ra;\n    return vec4( d, d - dot(p, p) / dot(p, p), 0.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec4( min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)), d, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgPlane( vec3 p, vec4 n )\n{\n    return vec4( dot(p, n.xyz) + n.w, n.xyz, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\ufffd", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec3 q = a + ba * h;\n    vec3 pq = q - p;\n    float d = length( pq );\n    float e = fwidth( d );\n    float s = smoothstep( r - e, r + e, d );\n    vec3 n = normalize( pq );\n    return vec4( s, n.x, n.y, n.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    float d = length( p ) - r;\n    float e = fwidth( d );\n    float s = smoothstep( -e, e, d );\n    vec3 n = normalize( p );\n    return vec4( s, n.x, n.y, n.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    float e = fwidth( d.x );\n    float s = smoothstep( -e, e, d.x );\n    e = fwidth( d.y );\n    s *= smoothstep( -e, e, d.y );\n    e = fwidth( d.z );\n    s *= smoothstep( -e, e, d.z );\n    vec3 n = sign( p );\n    return vec4( s, n.x, n.y, n.z );\n}\n\n//.x = f(p", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 w = vec2(wi,he);\n    vec2 a = w*0.5;\n    vec2 b = vec2(w.x + sk*w.y, w.y);\n    vec2 q = vec2( dot(a,p), dot(b,p) );\n    vec2 r = vec2( q.x, q.y - 0.5*w.x );\n    float c = clamp( dot(r,r), 0.0, 4.0 );\n    c = sqrt( c );\n    c = dot( r, vec2(w.x,w.y) - c*vec2(sk,1.0) ) - 0.5*wi*he;\n    return c;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 w = vec2(wi,he);\n    vec2 a = w*0.5;\n    vec2 b = vec2(w.x + sk*w.y, w.y);\n    vec2 q = vec2( dot(a,p), dot(b,p) );\n    vec2 r = vec2( q.x, q.y - 0.5*w.x );\n    float c = clamp( dot(r,r), 0.0, 4.0 );\n    c = sqrt( c );\n    c = dot( r, vec2(w.x,w.y) - c*vec2(sk,1.0) ) - 0.5*wi*he;\n    return c;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    vec2 w = vec2(wi,he);\n    vec2 a = w*0", "\n    vec2 q = p - vec2(wi,he);\n    vec2 r = vec2(wi,he) - p;\n    float a = dot(q,q);\n    float b = dot(r,r);\n    float c = dot(q,r);\n    float s = sign(c);\n    float d = s*sqrt(a*b - c*c);\n    float e = wi*wi + he*he;\n    float f = (a + b - e) / (2.0*d);\n    float g = sqrt(e - f*f);\n    float h = s*(c - f*g) / g;\n    float i = s*(c + f*g) / g;\n    float j = -s*wi*he*sk;\n    float k = s*wi*he*sk;\n    vec3 o = vec3(0.0);\n    if( h < 0.0 )\n    {\n        o.x = 0.0;\n        o.y = 0.0;\n        o.z = 0.0;\n    }\n    else if( i < 0.0 )\n    {\n        o.x = 0.0;\n        o.y = 0.0;\n        o.z = 0.0;\n    }\n    else\n    {\n        o.x = 1.0;\n        o.y = h;\n        o.z = i;\n    }\n    return o;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, float wi, float he, float sk )\n{\n    vec2 q = p - vec2(wi,he);\n    vec2 r = vec2(wi,he) - p;\n    float a = dot(q,q);\n    float b = dot(r,r);\n    float c = dot(q,r);\n    float s = sign(c);\n    float d = s*sqrt(a*b - c*c);\n    float e = wi*wi + he*he;\n    float f = (a + b - e) / (", "\n\tfloat q = mod( p, c );\n\treturn q;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\tvec2 q = mod( p, c );\n\treturn q.x + q.y;\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\tvec3 q = mod( p, c );\n\treturn q.x + q.y + q.z;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{\n\tfloat q = mod( p, c );\n\treturn q;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\tvec2 q = mod( p, c );\n\treturn q.x + q.y;\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\tvec3 q = mod( p, c );\n\treturn q.x + q.y + q.z;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{\n\tfloat q = mod( p, c );\n\treturn q;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\tvec2 q = mod( p, c );\n\treturn q.x + q.y;\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\tvec3 q = mod( p, c );\n\treturn q.x + q.y + q.z;\n\t}\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{\n\tfloat q = mod( p, c );\n\treturn q;\n\t}\n\nfloat opRep2D( vec2 p, vec2 c )\n\t{\n\tvec2 q = mod( p, c );\n\treturn q.x + q.y;\n\t}\n\nfloat opRep3D( vec3 p, vec3 c )\n\t{\n\tvec3 q = mod( p", "\n    return -k * a + k * b + min(a, b);\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return k * a - k * b + max(a, b);\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float x, float a, float b) {\n    return pmin(pmax(x, a, 1.0), b, 1.0);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float edge0, float edge1, float x) {\n    x = pclamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float edge0, float edge1, float x) {\n    x = pclamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// IQ's polynominal fade\nfloat pfade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// IQ's polynominal fade\nfloat pfade(float t, float k) {\n    return t * t * t * (t * (t * k - 15.0) + 10.0);\n}\n\n// IQ's polynominal fade\nfloat pfade(float t, float k, float n) {\n    return t * t * t * (t * (t * k - n) + n);\n}\n\n// IQ's polynominal fade\nfloat pfade(float t, float k, float n, float m) {\n    return t * t * t * (t * (t * k - n) + m);\n}\n\n// IQ's polynominal fade\nfloat pfade(float t, float k", "\n    vec2 halfSize = size * 0.5;\n    vec2 c = floor((p + halfSize) / size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nvec3 mod2(inout vec3 p, vec3 size) {\n    vec3 halfSize = size * 0.5;\n    vec3 c = floor((p + halfSize) / size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nvec4 mod2(inout vec4 p, vec4 size) {\n    vec4 halfSize = size * 0.5;\n    vec4 c = floor((p + halfSize) / size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdCone(vec3 p, vec3 c)", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec3 color = vec3(0.0);\n\n    // 1. Create a grid\n    float grid = 0.0;\n    grid = step(0.1, fract(uv.x * 10.0));\n    grid += step(0.1, fract(uv.y * 10.0));\n    grid = 1.0 - grid;\n\n    // 2. Create a circle\n    float circle = 0.0;\n    circle = 1.0 - smoothstep(0.5, 0.5 + 0.05, length(uv - vec2(0.5)));\n\n    // 3. Combine the two\n    float shape = grid * circle;\n\n    // 4. Create a color gradient\n    vec3 hsv = vec3(0.0, 0.0, shape);\n    color = hsv2rgb(hsv);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n```", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    float n = dot(rd, p.xyz);\n    if (n == 0.0) return vec2(-1.0);\n    return vec2(-dot(ro, p.xyz) - p.w) / n;\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = m * (boxMin - ro);\n    vec3 t1 = mix(k, n, greaterThan(k, n));\n    vec3 k = m * (boxMax - ro);\n    vec3 t2 = mix(k, n, greaterThan(k, n));\n    vec3 tN = max(t1, t2);\n    float t0 = max(tN.x, max(tN.y, tN.z));\n    vec3 tF = min(t1, t2);\n    float t1 = min(tF.x, min(tF.y, tF.z));\n    if (t0 > t1) return vec2(-1.0);\n    return vec2(t0, t1);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 nor = cross(ba, ca);\n    float n = dot(nor, rd);\n    if (n == 0.0) return vec2(-1.0);\n    vec3 va = ro - a;\n    float u = dot(cross(va, ca), rd) / n", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2( -1.0 );\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2( tN, tF );\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, float radius, out vec3 outNormal )  {\n    vec3 oc = ro - vec3(0.0, 0.0, 0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec2( -1.0 );\n    h = sqrt( h );\n    return vec2( -b - h, -b + h );\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 plane )  {\n    float denom = dot(rd, plane.xyz);\n    if( abs(denom) < 0.001 ) return vec2( -1.0 );\n    float t = - (dot(ro, plane.xyz) + plane.w) / denom;\n    return vec2( t );\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 outNormal )  {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if( abs(det) < 0", "\n    e1 = p - vec2(d.x, 0.0);\n    e2 = p + vec2(d.x, 0.0);\n    e3 = p - vec2(0.0, d.y);\n    e4 = p + vec2(0.0, d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n    e1 = p - vec2(d.x, 0.0);\n    e2 = p + vec2(d.x, 0.0);\n    e3 = p - vec2(0.0, d.y);\n    e4 = p + vec2(0.0, d.y);\n    e5 = p - vec2(d.x, d.y);\n    e6 = p + vec2(d.x, d.y);\n    e7 = p - vec2(d.x, -d.y);\n    e8 = p + vec2(d.x, -d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge16(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8, inout vec2 e9, inout vec2 e10, inout vec2 e11, inout vec2 e12, inout vec2 e13, inout vec2 e14, inout vec2 e15, inout vec2 e16) {\n    e1 = p - vec2(d.x, 0.0);\n    e2 = p + vec2", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat edgedist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat edgedist(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 ba = b - a, ca = c - a;\n    float baba = dot(ba,ba);\n    float caab = dot(ca,ba);\n    float h = clamp(caab/baba, 0.0, 1.0);\n    float pa = dot(ba, pa);\n    float pb = dot(ba, p - b);\n    float pc = dot(ca, p - c);\n    float pd = dot(ba, p - a);\n    float cacb = dot(ca,ba);\n    float cabc = dot(ca,ba);\n    float x = length(pa*cabc - pb*cacb + pc*baba - pd*caab);\n    float y = abs(pa*caba - pb*cabc + pc*baba - pd*caab);\n    float z = length(pa*caba - pb*cabc + pc*baba - pd*caab);\n    return min(x,min(y,z));\n}\n\nfloat edgedist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 ba = b - a, ca = c - a, da = d - a;\n    float baba = dot(ba,ba);\n    float caab = dot(ca,ba);\n    float dada = dot(da,da);\n    float dadb = dot(da,db);\n    float h = clamp((dadb*caab - dada*cadb)/(baba*dada - caab*dadb), 0.0, 1.0);\n    float pa = dot(ba, pa", "\n    vec2  u = normalize(b-a);\n    vec2  v = vec2( -u.y, u.x );\n    float l = length(p-a);\n    float r = length(p-b);\n    float h = clamp( dot( p-a, u ), 0.0, l );\n    float d = length( vec2( h, length(p-(a+u*h)) ) );\n    float e = length( vec2( l-h, length(p-(b+u*(l-h))) ) );\n    float f = max(d,e);\n    float g = min(d,e);\n    float m = clamp( (w1/w2)*r/(r-g), 0.0, 1.0 );\n    float n = clamp( g/r, 0.0, 1.0 );\n    float s = (1.0-step(0.0,r-w1))*(1.0-m);\n    return f*s + (w1/w2)*r*n*(1.0-s);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float w3 )\n{\n    vec2  u = normalize(b-a);\n    vec2  v = vec2( -u.y, u.x );\n    float l = length(p-a);\n    float r = length(p-b);\n    float h = clamp( dot( p-a, u ), 0.0, l );\n    float d = length( vec2( h, length(p-(a+u*h)) ) );\n    float e = length( vec2( l-h, length(p-(b+u*(l-h))) ) );\n    float f = max(d,e);\n    float g = min(d,e);\n    float m = clamp( (w1/w2)*r/(r-g), 0.0, 1.0 );\n    float n = clamp( g/r, 0.0, 1.0 );\n    float s = (1.0-step(0.0,r-w1", "\n    vec3 p = ro - vec3(0.0, 0.0, tor.y);\n    float r2 = dot(p, p);\n    float q2 = dot(rd, rd);\n    float q = sqrt(q2);\n    float r = sqrt(r2);\n    float a = tor.x;\n    float b = r - a;\n    float c = q * a - b * b;\n    float h = c * c - q2 * r2;\n    float t = -c - sqrt(h);\n    if (t < 0.0) return -1.0;\n    return t - b;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCapsule(vec3 ro, vec3 rd, vec3 p1, vec3 p2, float r) {\n    vec3 ab = p2 - p1;\n    vec3 ac = ro - p1;\n    float t = dot(ac, ab) / dot(ab, ab);\n    if (t < 0.0) t = 0.0;\n    if (t > 1.0) t = 1.0;\n    vec3 pt = p1 + t * ab;\n    vec3 oc = ro - pt;\n    return raySphere(ro, rd, vec4(oc, r));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCylinder(vec3 ro", "\n    vec3 q = pos.xyz - vec3(tor.x, 0.0, 0.0);\n    vec2 p = vec2(length(q.xz) - tor.y, q.y);\n    vec3 n = vec3(p.x, q.y, p.y);\n    return normalize(n);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torus(vec3 pos, vec2 tor) {\n    vec3 q = pos.xyz - vec3(tor.x, 0.0, 0.0);\n    return length(q.xz) - tor.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torus(vec3 pos, vec2 tor, out vec3 normal) {\n    vec3 q = pos.xyz - vec3(tor.x, 0.0, 0.0);\n    vec2 p = vec2(length(q.xz) - tor.y, q.y);\n    normal = vec3(p.x, q.y, p.y);\n    return length(p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torus(vec3 pos, vec2 tor, out vec3 normal, out vec3 barycentric) {\n    vec3 q = pos.xyz - vec3(tor.x, 0.0, 0.0);\n    vec2 p = vec2(length(q.xz) - tor.y, q.y);\n    normal = vec3(p.x, q.y, p.y);\n    barycentric = vec3(length(p), 0.0, 0.0);\n    return length(p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat tor", "\n    float a = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 uv;\n    uv.x = p.x;\n    uv.y = p.y * 0.5 + 0.5;\n    vec3 col2 = texture(iChannel0, uv).xyz;\n    col = mix(col, col2, 0.5);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 uv;\n    uv.x = p.x;\n    uv.y = p.y * 0.5 + 0.5;\n    vec3 col = texture(iChannel0, uv).xyz;\n    col = postProcess(col, q);\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec2 halfSize = size * 0.5;\n    vec2 c = floor((p + halfSize) / size);\n    p = mod(p + halfSize, size) - halfSize;\n    return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.x;\n    float d2 = max(dot(q, c.yxx), q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    v += noise(uv) * 0.5;\n    v += noise(uv * 2.0) * 0.25;\n    v += noise(uv * 4.0) * 0.125;\n    v += noise(uv * 8.0) * 0.0625;\n    return v;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    uv.x *= resolution.x / resolution.y;\n    float v = fbm(uv * 8.0);\n    gl_FragColor = vec4(vec3(v), 1.0);\n}\n", "\n    vec2 q = p - c;\n    return length(q) - r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w )\n{\n    vec2 q = abs(p-b);\n    return length(max(q-vec2(b.x+r,b.y+w),0.0)) + min(max(q.x-b.x+r,q.y-b.y+w),0.0) - r;\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w, in float m )\n{\n    vec2 q = abs(p-b);\n    return length(max(q-vec2(b.x+r,b.y+w),0.0)) + min(max(q.x-b.x+r,q.y-b.y+w),0.0) - r - m*min(q.x-b.x+r,max(q.y-b.y+w,0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w, in float m, in float n )\n{\n    vec2 q = abs(p-b);\n    return length(max(q-vec2(b.x+r,b.y+w),0.0)) + min(max(q.x-b.x+r,q", "\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - w;\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w, in float m )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - w - m;\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w, in float m, in float n )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r - w - m - n;\n}\n\n// distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float w, in float m, in float n, in float o )\n{\n  vec2 d", " return a.x*b.y - a.y*b.x; }\nfloat dist2tri( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 cb = c-b;\n    vec2 pb = p-b;\n    vec2 ac = a-c;\n    vec2 pc = p-c;\n    float ha = cro(ba,pa);\n    float hb = cro(cb,pb);\n    float hc = cro(ac,pc);\n    float h = max( ha, max(hb,hc) );\n    if( h<0.0 ) return min( cro(ba,pa), min( cro(cb,pb), cro(ac,pc) ) );\n    return h*h / cro(ba,ba);\n}\n\n// signed distance to a 2D triangle\nfloat dist2tri( in vec2 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec2 ba = b.xy-a.xy;\n    vec2 pa = p-a.xy;\n    vec2 cb = c.xy-b.xy;\n    vec2 pb = p-b.xy;\n    vec2 ac = a.xy-c.xy;\n    vec2 pc = p-c.xy;\n    float ha = cro(ba,pa);\n    float hb = cro(cb,pb);\n    float hc = cro(ac,pc);\n    float h = max( ha, max(hb,hc) );\n    if( h<0.0 ) return min( cro(ba,pa), min( cro(cb,pb), cro(ac,pc) ) );\n    return h*h / cro(ba,ba);\n}\n\n// signed distance to a 2D triangle\nfloat dist2tri( in vec2 p, in vec4 a, in vec4 b, in vec4 c )\n{\n    vec2 ba = b.xy-a.xy;\n    vec2 pa = p-a.xy;\n    vec2 cb = c.xy-b.xy;\n    vec2 pb = p-b.xy;\n    vec2 ac = a.xy-c.xy;\n    vec2 pc = p-c.xy;\n    float ha =", "\n    vec2 q = abs(p);\n    return max(q.x,q.y)-s+r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in float r ) \n{\n    vec2 q = abs(p)-s;\n    return max(q.x,q.y)-s.x+r;\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r ) \n{\n    vec2 q = abs(p)-s;\n    return max(q.x,q.y)-s.x+max(r.x,r.y);\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in float r, in float m ) \n{\n    vec2 q = abs(p)-s;\n    return max(q.x,q.y)-s.x+r-m*min(q.x,q.y);\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in float m ) \n{\n    vec2 q = abs(p)-s;\n    return max(q.x,q.y)-s.x+max(r.x,r.y)-m*min(q.x,q.y);\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in float r, in float m, in float n ) \n{\n    vec2 q = abs(p)-s;\n    return max(q.x,q.y)-s.x+r-m*min(q.x,q.y)-n*max(q.x,q.y);\n}\n\n// p = point\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in float m,", "\n    return x / (x + 0.155) - 0.055;\n}\n\nvec3 linear_to_srgb(vec3 color)\n{\n    return s_curve(color * 12.92);\n}\n\nvec3 srgb_to_linear(vec3 color)\n{\n    return s_curve(color * 0.41666) / 12.92;\n}\n\nvec3 tonemap_aces(vec3 color)\n{\n    color = srgb_to_linear(color);\n    color = (color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14);\n    color = linear_to_srgb(color);\n    return color;\n}\n\nvec3 tonemap_reinhard(vec3 color)\n{\n    color = color / (color + vec3(1.0));\n    return color;\n}\n\nvec3 tonemap_uncharted2(vec3 color)\n{\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    const float W = 11.2;\n    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n    float white_scale = 1.0 / mix(vec3(W), vec3(W) * (1.0 / tonemap_reinhard(vec3(W))), vec3(dot(color, vec3(1.0))));\n    color = color * white_scale;\n    return color;\n}\n\nvec3 tonemap_filmic(vec3 color)\n{\n    color = max(vec3(0.0), color - vec3(0.004));\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0", "\n    return 6.0 * x * (1.0 - x);\n}\n\n// 1D cubic Hermite spline\nfloat hermite(float x, float p0, float m0, float p1, float m1)\n{\n    float t = x;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float h00 = 2.0 * t3 - 3.0 * t2 + 1.0;\n    float h10 = t3 - 2.0 * t2 + t;\n    float h01 = -2.0 * t3 + 3.0 * t2;\n    float h11 = t3 - t2;\n    return h00 * p0 + h10 * m0 + h01 * p1 + h11 * m1;\n}\n\n// 2D cubic Hermite spline\nvec2 hermite(vec2 x, vec2 p0, vec2 m0, vec2 p1, vec2 m1)\n{\n    vec2 t = x;\n    vec2 t2 = t * t;\n    vec2 t3 = t2 * t;\n    vec2 h00 = 2.0 * t3 - 3.0 * t2 + 1.0;\n    vec2 h10 = t3 - 2.0 * t2 + t;\n    vec2 h01 = -2.0 * t3 + 3.0 * t2;\n    vec2 h11 = t3 - t2;\n    return h00 * p0 + h10 * m0 + h01 * p1 + h11 * m1;\n}\n\n// 3D cubic Hermite spline\nvec3 hermite(vec3 x, vec3 p0, vec3 m0, vec3 p1, vec3 m1)\n{\n    vec3 t = x;\n    vec3 t2 = t * t;\n    vec3 t3 = t2 * t;\n    vec3 h00 = 2.0 * t3 - 3.0 * t2 + 1.0;\n    vec3 h10 = t3 - 2.0 * t2 + t;\n    vec3 h01 = -2.0", "\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(w,w),p),0.0)*vec2(w,w);\n    float d = length(p);\n    return d - w*k;\n}\n\n// 2D box\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r, float w )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - w;\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r, float w, float m )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - w - m;\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r, float w, float m, float n )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - w - m - n;\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r, float w, float m, float n, float o )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.", "\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n\treturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float opticalDepth2)\n{\n\treturn exp(-opticalDepth - opticalDepth2);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2)\n{\n\treturn exp(-opticalDepth - opticalDepth2);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3)\n{\n\treturn exp(-opticalDepth - opticalDepth2 - opticalDepth3);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float opticalDepth2, float opticalDepth3)\n{\n\treturn exp(-opticalDepth - opticalDepth2 - opticalDepth3);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4)\n{\n\treturn exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float opticalDepth2, float opticalDepth3, float opticalDepth4)\n{\n\treturn exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 opticalDepth2, vec3 opticalDepth3, vec3 opticalDepth4, vec3 opticalDepth5)\n{\n\treturn exp(-opticalDepth - opticalDepth2 - opticalDepth3 - opticalDepth4 - opticalDepth5);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, float opticalDepth2,", "\n\t// Calculate the optical depth along the ray.\n\tfloat opticalDepth = 0.0;\n\ttransmittance = vec3(1.0);\n\tfor (int i = 0; i < g_numSamples; ++i)\n\t{\n\t\tvec3 samplePos = rayStart + rayDir * (i / float(g_numSamples) * rayLength);\n\t\tfloat sampleDepth = texture(g_depthTexture, samplePos.xy).r;\n\t\tif (sampleDepth > 0.0)\n\t\t{\n\t\t\tfloat sampleDistance = length(samplePos - rayStart);\n\t\t\tfloat sampleOpticalDepth = exp(-sampleDistance * g_extinction);\n\t\t\topticalDepth += sampleOpticalDepth;\n\t\t\ttransmittance *= exp(-sampleOpticalDepth);\n\t\t}\n\t}\n\n\t// Calculate the inscattering.\n\tvec3 inscattering = vec3(0.0);\n\tfor (int i = 0; i < g_numSamples; ++i)\n\t{\n\t\tvec3 samplePos = rayStart + rayDir * (i / float(g_numSamples) * rayLength);\n\t\tfloat sampleDepth = texture(g_depthTexture, samplePos.xy).r;\n\t\tif (sampleDepth > 0.0)\n\t\t{\n\t\t\tfloat sampleDistance = length(samplePos - rayStart);\n\t\t\tfloat sampleOpticalDepth = exp(-sampleDistance * g_extinction);\n\t\t\tfloat sampleTransmittance = exp(-(opticalDepth - sampleOpticalDepth) * g_extinction);\n\t\t\tvec3 sampleInscattering = sampleTransmittance * g_inscattering * g_extinction * g_numSamples / rayLength;\n\t\t\tinscattering += sampleInscattering;\n\t\t}\n\t}\n\n\t// Calculate the scattering.\n\tvec3 scattering = inscattering * lightColor * max(0.0, dot(lightDir, rayDir)) / opticalDepth;\n\n\treturn scattering;\n}\n\n// Integrate scattering over a ray for all directional light sources.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength)\n{\n\t// Calculate the optical depth along the ray.\n\tfloat opticalDepth = 0.0;\n\t", "\n    float h = clamp( 1.0 - (length(p2) - ra) / d, 0.0, 1.0 );\n    float h2 = clamp( 1.0 - (length(p2) - ra - rb) / d, 0.0, 1.0 );\n    return length(p2) - ra - rb * h2 * h;\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdSphere( in vec3 p, in float ra )\n{\n    return length(p) - ra;\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdCylinder( in vec3 p, in float ra, in float rb )\n{\n    return length(p.xz)-ra+abs(p.y)-rb;\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle/2\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.x;\n    float d2 = max(q.x,q.y)-c.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// p = position\n// ra = sphere's radius\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n   ", "\n    float d = sdSphere( p, r );\n    d = max( d, sdBox( p.yzx, vec3( t, r, r ) ) );\n    d = max( d, sdBox( p.zxy, vec3( r, t, r ) ) );\n    d = max( d, sdBox( p.xzy, vec3( r, r, t ) ) );\n    d = max( d, sdBox( p.xyz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.yxz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.zxy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xzy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xyz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.yxz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.zxy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xzy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xyz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.yxz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.zxy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xzy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xyz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.yxz, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.zxy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p.xzy, vec3( t, t, t ) ) );\n    d = max( d, sdBox( p", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,", "\n    return length(p)-max(r,abs(p.y-h));\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k )\n{\n    return length(p)-max(r,abs(p.y-h)-k);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k, in float m )\n{\n    return length(p)-max(r,abs(p.y-h)-k-m);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k, in float m, in float n )\n{\n    return length(p)-max(r,abs(p.y-h)-k-m-n);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k, in float m, in float n, in float o )\n{\n    return length(p)-max(r,abs(p.y-h)-k-m-n-o);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k, in float m, in float n, in float o, in float p )\n{\n    return length(p)-max(r,abs(p.y-h)-k-m-n-o-p);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float k, in float m, in float n, in float o, in float p, in float q )\n{\n    return length(p)-max(r,abs(p.y-h)-k-m-n-o-p-q);\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c.xy,vec2(q,p.z));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1", "\n    vec2 q = vec2(length(p.xy),p.z);\n    return max(r-q.x,q.y-h);\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p, in vec3 b, in float r, in float h )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r + h;\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p, in vec3 b, in float r )\n{\n    return sdCutBox( p, b, r, 0.0 );\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p, in vec3 b )\n{\n    return sdCutBox( p, b, 0.0, 0.0 );\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p, in float r, in float h )\n{\n    return sdCutBox( p, vec3(1.0), r, h );\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p, in float r )\n{\n    return sdCutBox( p, vec3(1.0), r, 0.0 );\n}\n\n// r=radius, h=height\nfloat sdCutBox( in vec3 p )\n{\n    return sdCutBox( p, vec3(1.0), 0.0, 0.0 );\n}\n\n// r=radius, h=height\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p)-r+h;\n}\n\n// r=radius, h=height\nfloat sdCutSphere( in vec3 p, in float r )\n{\n    return sdCutSphere( p, r, 0.0 );\n}\n\n// r=radius, h=height\nfloat sdCutSphere( in vec3 p )\n{\n    return sdCutSphere( p, 1.0, 0.0 );\n}\n\n", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// 2d fbm\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3d fbm\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 2d fbm with octaves\nfloat fbm( vec2 p, float octaves )\n{\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    mat2", "\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = rot( p, 0.5 );\n    f += 0.2500 * noise( p ); p = rot( p, 0.5 );\n    f += 0.1250 * noise( p ); p = rot( p, 0.5 );\n    f += 0.0625 * noise( p );\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = rot( p, 0.5 );\n    f += 0.2500 * noise( p ); p = rot( p, 0.5 );\n    f += 0.1250 * noise( p ); p = rot( p, 0.5 );\n    f += 0.0625 * noise( p );\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( float p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = rot( p, 0.5 );\n    f += 0.2500 * noise( p ); p = rot( p, 0.5 );\n    f += 0.1250 * noise( p ); p = rot( p, 0.5 );\n    f += 0.0625 * noise( p );\n    return f;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, float rot )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = rot( p, rot );\n    f += 0.2500 * noise( p ); p = rot( p, rot );\n    f += 0.1250 * noise( p ); p = rot( p, rot );\n    f += 0.0625 * noise( p );\n    return f;\n}", "\n\tvec3 p = fract(p3 * vec3(123.34, 456.21, 789.23));\n\tp += dot(p, p.yzx + 19.19);\n\treturn fract((p.x + p.y) * p.z);\n}\n\n//value noise\nfloat noise31(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(hash31(i + vec3(0, 0, 0)), hash31(i + vec3(1, 0, 0)), u.x),\n\t\tmix(hash31(i + vec3(0, 1, 0)), hash31(i + vec3(1, 1, 0)), u.x), u.y),\n\t\tmix(mix(hash31(i + vec3(0, 0, 1)), hash31(i + vec3(1, 0, 1)), u.x),\n\t\tmix(hash31(i + vec3(0, 1, 1)), hash31(i + vec3(1, 1, 1)), u.x), u.y), u.z);\n}\n\n//fractal noise\nfloat fbm31(vec3 p)\n{\n\tfloat f = 0.0;\n\tf += 0.5000 * noise31(p); p *= 2.02;\n\tf += 0.2500 * noise31(p); p *= 2.03;\n\tf += 0.1250 * noise31(p); p *= 2.01;\n\tf += 0.0625 * noise31(p);\n\treturn f;\n}\n\n//fractal noise\nfloat fbm31(vec3 p, float octaves)\n{\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat max = 1.0", "\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv_ = uv * 2.0 - 1.0;\n    uv_.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 p = uv_ + vec2(cos(float(i) * 0.1), sin(float(i) * 0.1)) * 0.01;\n        d += length(p) * 0.5;\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec2 uv_center = uv - 0.5;\n    float dist = length(uv_center);\n    float angle = atan(uv_center.y, uv_center.x);\n    float angle_norm = (angle + PI) / (2.0 * PI);\n    float dist_norm = dist / u_resolution.x;\n    vec3 color = hsv2rgb(vec3(angle_norm, 1.0, dist_norm));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat mod2(inout vec2 p, vec2 size) {\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c.x + c.y * size.x;\n}\n\nfloat mod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c.x + c.y * size.x + c.z * size.x * size.y;\n}\n\nfloat mod4(inout vec4 p, vec4 size) {\n    vec4 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c.x + c.y * size.x + c.z * size.x * size.y + c.w * size.x * size.y * size.z;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.", "\n    return fract(sin(co) * 43758.5453);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + 57.0 + i.y * 57.0);\n    float d = hash(i.x + 1.0 + i.y * 57.0 + 1.0);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0", "\n    return t < 0.04045? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nvec3 sRGB(vec3 c) {\n    return vec3(sRGB(c.r), sRGB(c.g), sRGB(c.b));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb - 0.5) * (1.0 - abs", "\n    bvec3 leq = lessThanEqual(c, vec3(0.04045));\n    vec3  tmp = c / 12.92;\n    vec3  res = mix(tmp, pow((c + 0.055) / 1.055, vec3(2.4)), leq);\n    return res;\n}\n\n// License: MIT, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 linearRGB(in vec3 c) {\n    bvec3 gte = greaterThanEqual(c, vec3(0.04045));\n    vec3  tmp = c / 12.92;\n    vec3  res = mix(tmp, pow((c + 0.055) / 1.055, vec3(2.4)), gte);\n    return res;\n}\n\n// License: MIT, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 rgb2hsv(in vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// License: MIT, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float c, float k) {\n    float h = clamp(0.5 + 0.5 * (c - b) / k, 0.0, 1.0);\n    b = mix(b, c, h) - k * h * (1.0 - h);\n    h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h > dbuffer? -b + h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph) {\n    return sphered(ro, rd, sph, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph, float dbuffer) {\n    return sphered(ro, rd, vec4(sph, 1.0), dbuffer);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec3 sph) {\n    return sphered(ro, rd, vec4(sph, 1.0), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, float sph, float dbuffer) {\n    return sphered(ro, rd, vec4(0.0, 0.0, 0.0, sph), dbuffer);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, float sph) {\n    return sphered(ro, rd, vec4(0.0, 0.0, 0.0, sph), 0.0);\n}\n\n// License: MIT, author:", "\n\tvec4 z = p;\n\tvec4 c = vec4(0.0);\n\tfloat m2 = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tif (dot(z, z) > 4.0) break;\n\t\tz = vec4(z.x*z.x - z.y*z.y, 2.0*z.x*z.y, z.z*z.z - z.w*z.w, 2.0*z.z*z.w) + p;\n\t\tc += vec4(1.0, 1.0, 1.0, 1.0) / (z*z + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 q = abs(p) - r;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return vec4( d, q/d );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, vec2 r )\n{\n    vec2 q = vec2(length(p.xz)-r.x,p.y);\n    return vec4( length(q)-r.y, q/length(q) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgPlane( vec3 p, vec3 n )\n{\n    return vec4( dot(p,n), n );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec4( min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), d/length(d) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f", "\n    return vec4(back.rgb * (1.0 - front.a) + front.rgb * front.a, back.a + front.a * (1.0 - back.a));\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec4 blendSoftLight(vec4 back, vec4 front) {\n    vec4 result = back;\n    result.rgb = (back.rgb * (1.0 - front.a) + front.rgb * front.a) - (back.rgb - back.rgb * back.rgb) * (1.0 - front.a) * (1.0 - front.a);\n    return result;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec4 blendOverlay(vec4 back, vec4 front) {\n    vec4 result = back;\n    result.rgb = (back.rgb * (1.0 - front.a) + front.rgb * front.a) - (back.rgb * (1.0 - front.rgb) * (1.0 - front.a) * (1.0 - front.a));\n    return result;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec4 blendHardLight(vec4 back, vec4 front) {\n    vec4 result = back;\n    result.rgb = (back.rgb * (1.0 - front.a) + front.rgb * front.a) - (back.rgb * (1.0 - front.rgb) * (1.0 - front.a) * (1.0 - front.a));\n    return result;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec4 blendLighten(vec4 back, vec4 front) {\n    vec4 result = back;\n    result.rgb = max(back.rgb, front.rgb);\n    return result;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec4", "\n    return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nvec3 hsl2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z", "\n    p = abs(p);\n    return max(r-p.y,max(p.x*0.866025+p.y*0.5,-p.x*0.866025+p.y*0.5));\n}\n\nfloat hex(vec2 p) {\n    return hex(p, 1.0);\n}\n\nfloat hex(vec2 p, float r, float m) {\n    p = abs(p);\n    return max(r-p.y,max(p.x*0.866025+p.y*0.5,-p.x*0.866025+p.y*0.5)) - m;\n}\n\nfloat hex(vec2 p, float m) {\n    return hex(p, 1.0, m);\n}\n\nfloat hex(vec2 p, float r, float m, float t) {\n    p = abs(p);\n    return max(r-p.y,max(p.x*0.866025+p.y*0.5,-p.x*0.866025+p.y*0.5)) - m - t;\n}\n\nfloat hex(vec2 p, float m, float t) {\n    return hex(p, 1.0, m, t);\n}\n\nfloat hex(vec2 p, float r, float m, float t, float s) {\n    p = abs(p);\n    return max(r-p.y,max(p.x*0.866025+p.y*0.5,-p.x*0.866025+p.y*0.5)) - m - t - s;\n}\n\nfloat hex(vec2 p, float m, float t, float s) {\n    return hex(p, 1.0, m, t, s);\n}\n\nfloat hex(vec2 p, float r, float m, float t, float s, float u) {\n    p = abs(p);\n    return max(r-p.y,max(p.x*0.866025+p.y*0.5,-p", "\n    v *= 0.6;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// License: MIT, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_approx(vec3 v) {\n    return v / (v + 1.0);\n}\n\n// License: MIT, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_extended_approx(vec3 v) {\n    vec3 v_max = max(vec3(0.0), v - 0.004);\n    return v_max / (v_max + 1.0);\n}\n\n// License: MIT, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 filmic_approx(vec3 v) {\n    vec3 x = max(vec3(0.0), v - 0.004);\n    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\n}\n\n// License: MIT, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 uncharted2_approx(vec3 v) {\n    float a = 0.15f;\n    float b = 0.50f;\n    float c = 0.10f;\n    float d = 0.20f;\n    float e = 0.02f;\n    float f = 0.30f;\n    return ((v*(a*v+c*b)+d*e)/(v*(a*v+b)+", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p*2.02;\n    f += 0.2500 * noise(p); p = p*2.03;\n    f += 0.1250 * noise(p); p = p*2.01;\n    f += 0.0625 * noise(p);\n    return f/0.9375;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 p, float octaves) {\n    float f = 0.", "\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\tfloat t = Temp / 100.0;\n\tif (t < 4000.0) {\n\t\tr = 1.0;\n\t}\n\telse if (t < 7000.0) {\n\t\tr = 1.0 - (t - 4000.0) / 3000.0;\n\t\tg = 1.0;\n\t}\n\telse if (t < 25000.0) {\n\t\tg = 1.0 - (t - 7000.0) / 18000.0;\n\t}\n\telse if (t < 40000.0) {\n\t\tg = 0.0;\n\t\tb = (t - 25000.0) / 15000.0;\n\t}\n\treturn vec3(r, g, b);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody_approx(float Temp) {\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\tfloat t = Temp / 100.0;\n\tif (t < 4000.0) {\n\t\tr = 1.0;\n\t}\n\telse if (t < 7000.0) {\n\t\tr = 1.0 - (t - 4000.0) / 3000.0;\n\t\tg = 1.0;\n\t}\n\telse if (t < 25000.0) {\n\t\tg = 1.0 - (t - 7000.0) / 18000.0;\n\t}\n\telse if (t < 40000.0) {\n\t", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0 - 2.0 * f);\n    return mix(mix(dot(hash21(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash21(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), f.x),\n               mix(dot(hash21(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash21(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat fbm(vec2 p, float freq) {\n    float f = 0.0;\n    f += 0.5000 * noise(p * freq); p *= 2.02;\n    f += 0.2500 * noise(p * freq); p *= 2.03;\n    f += 0.1250 * noise(p * freq); p *= 2.01;\n    f += 0.0625 * noise(p * freq);\n    return f;\n}\n\nfloat fbm(vec2 p, float freq, float amp) {\n    float f = 0.0;\n    f += 0.5000 * noise(p * freq) * amp; p *= 2.02;\n    f += 0.2500 * noise(p * freq) * amp; p *= 2.03;\n    f", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 p, vec2 b, float r) {\n    return sdBox(p, b) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 p, vec2 b, vec4 r) {\n    return sdBox(p, b, r.x) - r.y;\n}\n\n// License: MIT, author: In", "\n    vec2 q = abs(p);\n    return vec3(length(max(q, 0.0)) - n, q.x - q.y, q.x + q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdStar(vec2 p, float n)\n{\n    float r = length(p) * 2.0;\n    float a = atan(p.y, p.x) + PI;\n    float s = sin(a * n);\n    float c = cos(a * n);\n    vec2 q = vec2(abs(p.x) - abs(p.y) * c, abs(p.y) - abs(p.x) * s);\n    return vec3(length(q) * sign(p.y * s - p.x * c), q.x, q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTriangle(vec2 p, float n)\n{\n    vec2 q = abs(p);\n    return vec3(length(max(q, 0.0)) - n, q.x - q.y, q.x + q.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTriangle2(vec2 p, float n)\n{\n    vec2 q = abs(p);\n    return vec3(length(max(q, 0.0)) - n, q.x - q.y, q.x + q.y);\n}\n\n//.x = f(p)\n//.y", "\nfloat x0 = floor( x );\nfloat x1 = x0 + 1.0;\nfloat y0 = 0.0;\nfloat y1 = 0.0;\n\nfor( int i = 0; i < 100; i++ )\n{\nfloat t0 = pow( t, i );\nfloat t1 = pow( t, i + 1.0 );\n\ny0 += t0 * floor( mod( x0, t1 ) / t0 );\ny1 += t0 * floor( mod( x1, t1 ) / t0 );\n}\n\nreturn y0 + ( x1 - x0 ) * ( y1 - y0 );\n}\n\n// 2D Cantor function\nfloat cantor2D( vec2 p, float t )\n{\nreturn cantor( cantor( p.x, t ), t );\n}\n\n// 3D Cantor function\nfloat cantor3D( vec3 p, float t )\n{\nreturn cantor( cantor( cantor( p.x, t ), t ), t );\n}\n\n// 4D Cantor function\nfloat cantor4D( vec4 p, float t )\n{\nreturn cantor( cantor( cantor( cantor( p.x, t ), t ), t ), t );\n}\n\n// 5D Cantor function\nfloat cantor5D( vec5 p, float t )\n{\nreturn cantor( cantor( cantor( cantor( cantor( p.x, t ), t ), t ), t ), t );\n}\n\n// 6D Cantor function\nfloat cantor6D( vec6 p, float t )\n{\nreturn cantor( cantor( cantor( cantor( cantor( cantor( p.x, t ), t ), t ), t ), t ), t );\n}\n\n// 7D Cantor function\nfloat cantor7D( vec7 p, float t )\n{\nreturn cantor( cantor( cantor( cantor( cantor( cantor( cantor( p.x, t ), t ), t ), t ), t ), t ), t );\n}\n\n// 8D Cantor function\nfloat cantor8D( vec8 p,", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.001;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox2( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox3( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox4( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox5( in vec2", "\n    float d = 1e10;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = p;\n        float r = 1.0;\n        for (int j = 0; j < 6; j++) {\n            p = abs(p) / dot(p, p) - vec3(1.0, 1.0, 1.0) * 2.0;\n            p = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * p;\n            p = p * r + vec3(0.0, 0.0, 0.0);\n            r *= 1.0;\n            d = min(d, length(p) - 0.01);\n        }\n    }\n    return d;\n}\n\n// raymarching\nfloat raymarch(in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * d;\n        d += map(p, 0);\n        if (d > 100.0) break;\n    }\n    return d;\n}\n\n// normal\nvec3 normal(in vec3 p) {\n    const float eps = 0.001;\n    vec3 n;\n    n.x = map(p + vec3(eps, 0.0, 0.0), 0) - map(p + vec3(-eps, 0.0, 0.0), 0);\n    n.y = map(p + vec3(0.0, eps, 0.0), 0) - map(p + vec3(0.0, -eps, 0.0), 0);\n    n.z = map(p + vec3(0.0, 0.0, eps), 0) - map(p + vec3(0.0, 0.0, -eps), 0);\n    return normalize(n);\n}\n\n// lighting\nvec3 lighting(in vec3 p, in", "\n    float r = atan(y, x);\n    float a = abs(x);\n    float b = abs(y);\n    float c = max(a, b);\n    float d = min(a, b);\n    if (c > 1.0) {\n        r += 0.25 * PI * sign(x);\n    }\n    if (d > 0.25) {\n        r += 0.25 * PI * sign(y);\n    }\n    return r;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec2 v) {\n    return atan_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec3 v) {\n    return atan_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec4 v) {\n    return atan_approx(v.y, v.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x, float z) {\n    float r = atan(y, x);\n    float a = abs(x);\n    float b = abs(y);\n    float c = max(a, b);\n    float d = min(a, b);\n    if (c > 1.0) {\n        r += 0.25 * PI * sign(x);\n    }\n    if (d > 0.25) {\n        r += 0.25 * PI * sign(y);\n    }\n    if (z > 0.25) {\n        r += 0.25 * PI * sign(z);\n    }\n    return r;\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec3", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d = dot(w, w);\n    return vec2((z.x*w.x + z.y*w.y)/d, (z.y*w.x - z.x*w.y)/d);\n}\n\nvec2 csqrt(vec2 z) {\n    if (z.x == 0.0 && z.y == 0.0) return vec2(0.0, 0.0);\n    float a = abs(z.x);\n    float b = abs(z.y);\n    float w = sqrt((a + b) * 0.5);\n    float t = 1.0 / (w + (z.y > 0.0? a : -a));\n    return vec2(w, z.x > 0.0? w : -w) * t;\n}\n\nvec2 catanh(vec2 z) {\n    vec2 w = csqrt(vec2(1.0) - z*z);\n    return vec2(0.5) * log((1.0 + z) / (1.0 - z)) + 0.5 * w;\n}\n\nvec2 catan(vec2 z) {\n    vec2 w = csqrt(vec2(1.0) + z*z);\n    return vec2(0.5) * log((1.0 - z) / (1.0 + z)) + 0.5 * w;\n}\n\nvec2 clog(vec2 z) {\n    return 0.5 * log(z.x*z.x + z.y*z.y) + vec2(atan(z.y, z.x), 0.0);\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return exp(w * clog(z));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y", "\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(w * s) - 0.5 * log(u * s);\n}\n\n// Inverse hyperbolic cotangent \nvec2 cacoth(vec2 z) {\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(w * s) + 0.5 * log(u * s);\n}\n\n// Inverse hyperbolic secant \nvec2 casech(vec2 z) {\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(w * s) + 0.5 * log(u * s);\n}\n\n// Inverse hyperbolic cosecant \nvec2 cacsch(vec2 z) {\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(w * s) - 0.5 * log(u * s);\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(w * s);\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n    vec2 w = 1.0 + z;\n    vec2 u = 1.0 - z;\n    vec2 s = 2.0 / (w + u);\n    return 0.5 * log(u * s);\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n   ", "\n    float a = exp(z.x);\n    float b = z.y;\n    return vec2(a * cos(b), a * sin(b));\n}\n\nvec2 ctanh(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return (e - 1.0) / (e + 1.0);\n}\n\n// My own attempt at an catan\nvec2 catan(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return 0.5 * log((e + 1.0) / (e - 1.0));\n}\n\n// My own attempt at an catanh\nvec2 catanh(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return 0.5 * log((e + 1.0) / (e - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at an", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d = dot(w, w);\n    return vec2((z.x*w.x + z.y*w.y)/d, (z.y*w.x - z.x*w.y)/d);\n}\n\nvec2 csqrt(vec2 z) {\n    if (z.x == 0.0 && z.y == 0.0) return vec2(0.0, 0.0);\n    float a = abs(z.x);\n    float b = abs(z.y);\n    float w = sqrt((a + b) * 0.5);\n    float t = 1.0 / (w + (z.y > 0.0? a : -a));\n    return vec2(w, z.x > 0.0? w : -w) * t;\n}\n\nvec2 catanh(vec2 z) {\n    vec2 w = csqrt(vec2(1.0) - z*z);\n    return vec2(0.5) * log((1.0 + z) / (1.0 - z)) + 0.5 * w;\n}\n\nvec2 catan(vec2 z) {\n    vec2 w = csqrt(vec2(1.0) + z*z);\n    return vec2(0.5) * log((1.0 - z) / (1.0 + z)) - 0.5 * w;\n}\n\nvec2 clog(vec2 z) {\n    return 0.5 * log(z.x*z.x + z.y*z.y) + vec2(atan(z.y, z.x), 0.0);\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return exp(w * clog(z));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return (e - 1.0) / (e + 1.0);\n}\n\n// My own attempt at a catan\nvec2 catan(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return 0.5 * log((e + 1.0) / (e - 1.0));\n}\n\n// My own attempt at a catanh\nvec2 catanh(vec2 z) {\n    vec2 e = cexp(2.0 * z);\n    return 0.5 * log((e + 1.0) / (e - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a casinh\nvec2 casinh(vec2 z) {\n    return log(z + sqrt(z * z + 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2 cacosh(vec2 z) {\n    return log(z + sqrt(z * z - 1.0));\n}\n\n// My own attempt at a cacosh\nvec2", "\n  float a = alpha.a;\n  float b = alpha.r + alpha.g + alpha.b;\n  float c = a + b;\n  float d = a * b;\n  float e = c * d;\n  float f = e * contrast;\n  float g = f + 1.0;\n  float h = g * 0.5;\n  float i = h * 2.0;\n  float j = i - 1.0;\n  float k = j * a;\n  float l = k + b;\n  float m = l + c;\n  float n = m + d;\n  float o = n + e;\n  float p = o + f;\n  float q = p + g;\n  float r = q + h;\n  float s = r + i;\n  float t = s + j;\n  float u = t + k;\n  float v = u + l;\n  float w = v + m;\n  float x = w + n;\n  float y = x + o;\n  float z = y + p;\n  float A = z + q;\n  float B = A + r;\n  float C = B + s;\n  float D = C + t;\n  float E = D + u;\n  float F = E + v;\n  float G = F + w;\n  float H = G + x;\n  float I = H + y;\n  float J = I + z;\n  float K = J + A;\n  float L = K + B;\n  float M = L + C;\n  float N = M + D;\n  float O = N + E;\n  float P = O + F;\n  float Q = P + G;\n  float R = Q + H;\n  float S = R + I;\n  float T = S + J;\n  float U = T + K;\n  float V = U + L;\n  float W = V + M;\n  float X = W + N;\n  float Y = X + O;\n  float Z = Y + P;\n  float _0 = Z + Q;\n  float _1 = _0 + R;\n  float _2 = _1 + S;\n  float _3 = _2 + T;\n  float _4 = _3 + U;\n  float _5 = _4 + V;\n  float _6 = _5 + W;\n  float _7 = _6", "\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z));\n}\n\n//Distance from the Edge of Truncated Octahedron\nfloat toOctDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.5;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.25;\n}\n\n//Distance from the Edge of Truncated Icosahedron\nfloat toIcoDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.5;\n}\n\n//Distance from the Edge of Cuboctahedron\nfloat cubDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.25;\n}\n\n//Distance from the Edge of Truncated Cuboctahedron\nfloat toCubDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.5;\n}\n\n//Distance from the Edge of Truncated Tetrahedron\nfloat toTetDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z - q.x, max(q.y - q.x, q.y - q.z)) - 0.5;\n}\n\n//Distance from the Edge of Truncated Cube\nfloat toCubDist2(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.z -", "\n    vec3 uvw2 = uvw;\n    vec3 uvw3 = uvw;\n    vec3 uvw4 = uvw;\n    vec3 uvw5 = uvw;\n    vec3 uvw6 = uvw;\n    vec3 uvw7 = uvw;\n    vec3 uvw8 = uvw;\n    vec3 uvw9 = uvw;\n    vec3 uvw10 = uvw;\n    vec3 uvw11 = uvw;\n    vec3 uvw12 = uvw;\n    vec3 uvw13 = uvw;\n    vec3 uvw14 = uvw;\n    vec3 uvw15 = uvw;\n    vec3 uvw16 = uvw;\n    vec3 uvw17 = uvw;\n    vec3 uvw18 = uvw;\n    vec3 uvw19 = uvw;\n    vec3 uvw20 = uvw;\n    vec3 uvw21 = uvw;\n    vec3 uvw22 = uvw;\n    vec3 uvw23 = uvw;\n    vec3 uvw24 = uvw;\n    vec3 uvw25 = uvw;\n    vec3 uvw26 = uvw;\n    vec3 uvw27 = uvw;\n    vec3 uvw28 = uvw;\n    vec3 uvw29 = uvw;\n    vec3 uvw30 = uvw;\n    vec3 uvw31 = uvw;\n    vec3 uvw32 = uvw;\n    vec3 uvw33 = uvw;\n    vec3 uvw34 = uvw;\n    vec3 uvw35 = uvw;\n    vec3 uvw36 = uvw;\n    vec3 uvw37 = uvw;\n    vec3 uvw38 = uvw;\n    vec3 uvw39 = uvw;\n    vec3 uvw40 = uvw;\n    vec3 uvw41 = uvw;\n    vec3 uvw42 = uvw;\n    vec3 uvw43 = uvw;\n    vec3 uvw44 = uvw;\n    vec3 uvw45 = uvw;\n    vec3 uvw46 = uvw;\n    vec3 uvw47 = uvw;\n    vec3 uvw48 = uvw;\n    vec3", "\n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw * 3.0;\n    vec3 uvw4 = uvw * 4.0;\n    vec3 uvw5 = uvw * 5.0;\n    vec3 uvw6 = uvw * 6.0;\n    vec3 uvw7 = uvw * 7.0;\n    vec3 uvw8 = uvw * 8.0;\n    vec3 uvw9 = uvw * 9.0;\n    vec3 uvw10 = uvw * 10.0;\n    vec3 uvw11 = uvw * 11.0;\n    vec3 uvw12 = uvw * 12.0;\n    vec3 uvw13 = uvw * 13.0;\n    vec3 uvw14 = uvw * 14.0;\n    vec3 uvw15 = uvw * 15.0;\n    vec3 uvw16 = uvw * 16.0;\n    vec3 uvw17 = uvw * 17.0;\n    vec3 uvw18 = uvw * 18.0;\n    vec3 uvw19 = uvw * 19.0;\n    vec3 uvw20 = uvw * 20.0;\n    vec3 uvw21 = uvw * 21.0;\n    vec3 uvw22 = uvw * 22.0;\n    vec3 uvw23 = uvw * 23.0;\n    vec3 uvw24 = uvw * 24.0;\n    vec3 uvw25 = uvw * 25.0;\n    vec3 uvw26 = uvw * 26.0;\n    vec3 uvw27 = uvw * 27.0;\n    vec3 uvw28 = uvw * 28.0;\n    vec3 uvw29 = uvw * 29.0;\n    vec3 uvw30 = uvw * 30.0;\n    vec3 uvw31 = uvw * 31.0;\n    vec3 uvw32 = uvw * 32.0;\n   ", "\n    vec3 uvw2 = uvw;\n    uvw2.x += 0.5;\n    uvw2.y += 0.5;\n    uvw2.z += 0.5;\n    vec3 uvw3 = uvw;\n    uvw3.x += 0.5;\n    uvw3.y += 0.5;\n    uvw3.z += 0.5;\n    vec3 uvw4 = uvw;\n    uvw4.x += 0.5;\n    uvw4.y += 0.5;\n    uvw4.z += 0.5;\n    vec3 uvw5 = uvw;\n    uvw5.x += 0.5;\n    uvw5.y += 0.5;\n    uvw5.z += 0.5;\n    vec3 uvw6 = uvw;\n    uvw6.x += 0.5;\n    uvw6.y += 0.5;\n    uvw6.z += 0.5;\n    vec3 uvw7 = uvw;\n    uvw7.x += 0.5;\n    uvw7.y += 0.5;\n    uvw7.z += 0.5;\n    vec3 uvw8 = uvw;\n    uvw8.x += 0.5;\n    uvw8.y += 0.5;\n    uvw8.z += 0.5;\n    vec3 uvw9 = uvw;\n    uvw9.x += 0.5;\n    uvw9.y += 0.5;\n    uvw9.z += 0.5;\n    vec3 uvw10 = uvw;\n    uvw10.x += 0.5;\n    uvw10.y += 0.5;\n    uvw10.z += 0.5;\n    vec3 uvw11 = uvw;\n    uvw11.x += 0.5;\n    uvw11.y += 0.5;\n    uvw11.z += 0.5;\n    vec3 uvw12 = uvw;\n    uvw12.x += 0.5;\n    uvw12.y += 0.5;\n    uvw12.z", "\n\tp = abs(p);\n\tfloat m = max(max(p.x, p.y), p.z);\n\tfloat d = 0.0;\n\tif (m == p.x) {\n\t\td = dot(p, vec3(1.0, 0.0, 0.0));\n\t} else if (m == p.y) {\n\t\td = dot(p, vec3(0.0, 1.0, 0.0));\n\t} else {\n\t\td = dot(p, vec3(0.0, 0.0, 1.0));\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float s) {\n\tp = abs(p);\n\tfloat m = max(max(p.x, p.y), p.z);\n\tfloat d = 0.0;\n\tif (m == p.x) {\n\t\td = dot(p, vec3(1.0, 0.0, 0.0));\n\t} else if (m == p.y) {\n\t\td = dot(p, vec3(0.0, 1.0, 0.0));\n\t} else {\n\t\td = dot(p, vec3(0.0, 0.0, 1.0));\n\t}\n\treturn d - s;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float s, float t) {\n\tp = abs(p);\n\tfloat m = max(max(p.x, p.y), p.z);\n\tfloat d = 0.0;\n\tif (m == p.x) {\n\t\td = dot(p, vec3(1.0, 0.0, 0.0));\n\t} else if (m == p.y) {\n\t\td = dot(p, vec3(0.0, 1.0, 0.0));\n\t} else {\n\t\td = dot(p, vec3(0.0, 0.0, 1.0));\n\t}\n\treturn d - s -", "\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes Warm colormap with polynimal 6\nvec3 Warm(float t) {\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes Cold colormap with polynimal 6\nvec3 Cold(float t) {\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes Jet colormap with polynimal 4\nvec3 Jet(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes HSV colormap with polynimal 4\nvec3 HSV(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes Hot colormap with polynimal 4\nvec3 Hot(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes Spring colormap with polynimal 4\nvec3 Spring(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes Summer colormap with polynimal 4\nvec3 Summer(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes Autumn colormap with polynimal 4\nvec3 Autumn(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes Winter colormap with polynimal 4\nvec3 Winter(", "\n    vec3 v1 = cross(a, v);\n    vec3 v2 = cross(a, v1);\n    return v + 2.0 * v1 * cos(a.x) + 2.0 * v2 * cos(a.y);\n}\n\n// returns the color of the sky\nvec3 sky(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float sun = clamp(dot(rd, sunDir), 0.0, 1.0);\n    col += 0.25 * pow(sun, 8.0) * vec3(1.0, 0.9, 0.8);\n    col += 0.25 * pow(sun, 4.0) * vec3(1.0, 0.8, 0.6);\n    col += 0.25 * pow(sun, 2.0) * vec3(1.0, 0.7, 0.4);\n    col += 0.25 * sun * vec3(1.0, 0.6, 0.2);\n    col += 0.25 * vec3(1.0, 0.5, 0.0);\n    col += 0.25 * vec3(1.0, 0.4, 0.0);\n    col += 0.25 * vec3(1.0, 0.3, 0.0);\n    col += 0.25 * vec3(1.0, 0.2, 0.0);\n    col += 0.25 * vec3(1.0, 0.1, 0.0);\n    col += 0.25 * vec3(1.0, 0.0, 0.0);\n    return col;\n}\n\n// returns the color of the ground\nvec3 ground(vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float sun = clamp(dot(rd, sunDir), 0.0, 1.0);\n    col += 0.25 * pow(sun, 8.0) * vec3(0.0, 0.0, 0.0);\n    col += 0.25", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return mix(mix(a, b, smoothstep(0., 1., f.x)),\n    //            mix(c, d, smoothstep(0., 1., f.x)),\n    //            smoothstep(0., 1., f.y));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// License: MIT, author: <NAME>, found: https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec", "\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y);\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y) * size;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size, float scale) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y) * size * scale;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size, float scale, float offset) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y) * size * scale + offset;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size, float scale, float offset, float offset2) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y) * size * scale + offset + offset2;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size, float scale, float offset, float offset2, float offset3) {\n    vec2 q = abs(p);\n    return max(q.x * 0.866025 + q.y * 0.5, q.y) * size * scale + offset + offset2 + offset3;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size, float scale, float offset, float offset2, float offset3, float offset", "\n    vec2 p = fract(uv);\n    vec2 o = vec2(0.5);\n    vec2 h = vec2(0.5);\n    vec2 s = vec2(0.5);\n    vec2 e = vec2(0.5);\n    vec2 n = vec2(0.5);\n    vec2 w = vec2(0.5);\n    vec2 c = vec2(0.5);\n    vec2 a = vec2(0.5);\n    vec2 b = vec2(0.5);\n    vec2 d = vec2(0.5);\n    vec2 f = vec2(0.5);\n    vec2 g = vec2(0.5);\n    vec2 i = vec2(0.5);\n    vec2 j = vec2(0.5);\n    vec2 k = vec2(0.5);\n    vec2 l = vec2(0.5);\n    vec2 m = vec2(0.5);\n    vec2 o = vec2(0.5);\n    vec2 p = vec2(0.5);\n    vec2 q = vec2(0.5);\n    vec2 r = vec2(0.5);\n    vec2 s = vec2(0.5);\n    vec2 t = vec2(0.5);\n    vec2 u = vec2(0.5);\n    vec2 v = vec2(0.5);\n    vec2 w = vec2(0.5);\n    vec2 x = vec2(0.5);\n    vec2 y = vec2(0.5);\n    vec2 z = vec2(0.5);\n    vec2 aa = vec2(0.5);\n    vec2 ab = vec2(0.5);\n    vec2 ac = vec2(0.5);\n    vec2 ad = vec2(0.5);\n    vec2 ae = vec2(0.5);\n    vec2 af = vec2(0.5);\n    vec2 ag = vec2(0.5);\n    vec2 ah = vec2(0.5);\n    vec2 ai = vec2(0.5);\n    vec2 aj = vec2(0.5);\n    vec2 ak = vec2(0.5);\n    vec2 al = vec2(0.5);\n    vec2 am = vec2(0.", "\n    vec3 c0 = vec3(0.2824, 0.17886, 0.54512);\n    vec3 c1 = vec3(0.23294, 0.29243, 0.75168);\n    vec3 c2 = vec3(0.15873, 0.49001, 0.83557);\n    vec3 c3 = vec3(0.10608, 0.70103, 0.79787);\n    vec3 c4 = vec3(0.14915, 0.8764, 0.71435);\n    vec3 c5 = vec3(0.31569, 0.96956, 0.53941);\n    vec3 c6 = vec3(0.64151, 0.97648, 0.32238);\n    vec3 c7 = vec3(0.96822, 0.90615, 0.16874);\n    vec3 c8 = vec3(0.99408, 0.74141, 0.16831);\n    vec3 c9 = vec3(0.9986, 0.5519, 0.23113);\n    vec3 c10 = vec3(1, 0.40346, 0.38818);\n    vec3 c11 = vec3(1, 0.25663, 0.48307);\n    vec3 c12 = vec3(0.96855, 0.14094, 0.63373);\n    vec3 c13 = vec3(0.80841, 0.07176, 0.79718);\n    vec3 c14 = vec3(0.569, 0.06518, 0.88965);", "\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat make1to1(float x) {\n\treturn x * 2 - 1;\n}\n\n//converts a float to a byte\nbyte floatToByte(float x) {\n\treturn (byte)(x * 127.5 + 127.5);\n}\n\n//converts a byte to a float\nfloat byteToFloat(byte x) {\n\treturn (float)(x - 127.5) / 127.5;\n}\n\n//converts a float to a short\nshort floatToShort(float x) {\n\treturn (short)(x * 32767.5 + 32767.5);\n}\n\n//converts a short to a float\nfloat shortToFloat(short x) {\n\treturn (float)(x - 32767.5) / 32767.5;\n}\n\n//converts a float to a int\nint floatToInt(float x) {\n\treturn (int)(x * 2147483647.5 + 2147483647.5);\n}\n\n//converts a int to a float\nfloat intToFloat(int x) {\n\treturn (float)(x - 2147483647.5) / 2147483647.5;\n}\n\n//converts a float to a long\nlong floatToLong(float x) {\n\treturn (long)(x * 9223372036854775807.5 + 9223372036854775807.5);\n}\n\n//converts a long to a float\nfloat longToFloat(long x) {\n\treturn (float)(x - 9223372036854775807.5) / 9223372036854775807.5;\n}\n\n", "\n    vec2 p = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 i = floor(f * 6.0);\n    vec2 d = f * 6.0 - i;\n    vec2 uv0, uv1;\n    if (i.x + i.y < 1.0) {\n        uv0 = p;\n        uv1 = p + vec2(1.0, 0.0);\n    } else if (i.x + i.y < 2.0) {\n        uv0 = p + vec2(0.0, 1.0);\n        uv1 = p + vec2(1.0, 1.0);\n    } else if (i.x + i.y < 3.0) {\n        uv0 = p + vec2(1.0, 0.0);\n        uv1 = p + vec2(1.0, 1.0);\n    } else if (i.x + i.y < 4.0) {\n        uv0 = p + vec2(0.0, 1.0);\n        uv1 = p + vec2(1.0, 1.0);\n    } else if (i.x + i.y < 5.0) {\n        uv0 = p;\n        uv1 = p + vec2(1.0, 0.0);\n    } else {\n        uv0 = p + vec2(0.0, 1.0);\n        uv1 = p + vec2(1.0, 1.0);\n    }\n    vec2 uv2 = uv0 + vec2(-offset.x, offset.y);\n    vec2 uv3 = uv0 + vec2(offset.x, -offset.y);\n    vec2 uv4 = uv1 + vec2(-offset.x, offset.y);\n    vec2 uv5 = uv1 + vec2(offset.x, -offset.y);\n    vec2 uv6 = uv2 + vec2(-offset.x, offset.y);\n    vec2 uv7 = uv2 + vec2(offset.x, -offset.y);\n    vec2 uv8 = uv3 + vec2(-offset.x, offset.y);\n    vec2 uv9 = uv3 + vec2(offset.x,", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 uv2 = uv * gridRes - grid;\n    vec2 uv3 = uv2 - vec2(0.5, 0.5);\n    float d = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d", "\n    vec2 flow = vec2(0.0);\n    float t = time * 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 tileCoord = floor(pos / arrowTileSize);\n    return tileCoord * arrowTileSize + arrowTileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    vec2 tileCoord = floor(pos / tileSize);\n    return tileCoord * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize) {\n    vec2 tileCoord = floor(pos / tileSize);\n    return tileCoord * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, int tileSize) {\n    vec2 tileCoord = floor(pos / float(tileSize));\n    return tileCoord * float(tileSize) + float(tileSize) / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, ivec2 tileSize) {\n    vec2 tileCoord = floor(pos / vec2(tileSize));\n    return tileCoord * vec2(tileSize) + vec2(tileSize) / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, uvec2 tileSize) {\n    vec2 tileCoord = floor(pos / vec2(tileSize));\n    return tileCoord * vec2(tileSize) + vec2(tileSize) / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n    vec2 tileCoord = floor((pos - tileOffset) / tileSize);\n    return tileCoord * tileSize + tileSize / 2.0 + tileOffset;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float tileSize, float tileOffset) {\n    vec2 tileCoord = floor((pos - tileOffset) / tileSize);\n    return tileCoord * tileSize + tileSize / 2", "\n    vec2 a = p2 - p1;\n    vec2 b = p - p1;\n    float t = clamp(dot(b, a) / dot(a, a), 0.0, 1.0);\n    vec2 proj = p1 + t * a;\n    return length(p - proj);\n}\n\n// Computes the signed distance from a circle\nfloat circle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\n// Computes the signed distance from a rectangle\nfloat rect(vec2 p, vec2 c, vec2 s) {\n    vec2 d = abs(p - c) - s;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Computes the signed distance from a rounded rectangle\nfloat roundedRect(vec2 p, vec2 c, vec2 s, float r) {\n    vec2 d = abs(p - c) - s;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// Computes the signed distance from a polygon\nfloat poly(vec2 p, vec2 c, vec2 r, int n) {\n    vec2 a = p - c;\n    float da = dot(a, r);\n    float f = clamp(da / dot(r, r), 0.0, 1.0);\n    return length(a - f * r) * sign(da);\n}\n\n// Computes the signed distance from a star\nfloat star(vec2 p, vec2 c, vec2 r, int n) {\n    vec2 a = p - c;\n    float da = dot(a, r);\n    float f = clamp(da / dot(r, r), 0.0, 1.0);\n    float angle = atan(a.y, a.x) + 3.1415926535897932384626433832795 / n;\n    float d = length(a - f * r) * sign(da);\n    if (abs(angle / 3.141", "\n    float d = length(p) - 0.5;\n    float a = atan(p.y, p.x);\n    float da = abs(a - atan(v.y, v.x));\n    float s = sign(da - 0.5 * PI);\n    return s * max(d, da - 0.5 * PI);\n}\n\n// Returns a signed distance from the arrowhead\nfloat arrowhead(vec2 p, vec2 v) {\n    float d = length(p) - 0.5;\n    float a = atan(p.y, p.x);\n    float da = abs(a - atan(v.y, v.x));\n    float s = sign(da - 0.5 * PI);\n    return s * max(d, da - 0.5 * PI) - 0.1;\n}\n\n// Returns a signed distance from the arrowhead\nfloat arrowhead2(vec2 p, vec2 v) {\n    float d = length(p) - 0.5;\n    float a = atan(p.y, p.x);\n    float da = abs(a - atan(v.y, v.x));\n    float s = sign(da - 0.5 * PI);\n    return s * max(d, da - 0.5 * PI) - 0.1;\n}\n\n// Returns a signed distance from the arrowhead\nfloat arrowhead3(vec2 p, vec2 v) {\n    float d = length(p) - 0.5;\n    float a = atan(p.y, p.x);\n    float da = abs(a - atan(v.y, v.x));\n    float s = sign(da - 0.5 * PI);\n    return s * max(d, da - 0.5 * PI) - 0.1;\n}\n\n// Returns a signed distance from the arrowhead\nfloat arrowhead4(vec2 p, vec2 v) {\n    float d = length(p) - 0.5;\n    float a = atan(p.y, p.x);\n    float da = abs(a - atan(v.y, v.x));\n    float s = sign(da - 0.5 * PI);\n    return s * max(d, da -", "\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make1to0(vec2 x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec3 make0to1(vec3 x) {\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make1to0(vec3 x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec4 make0to1(vec4 x) {\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 make1to0(vec4 x) {\n\treturn x * 2.0 - 1.0;\n}\n\n//converts a 0-1 value to a 0-255 value\nvec4 make0to255(vec4 x) {\n\treturn x * 255.0;\n}\n\n//converts a 0-255 value to a 0-1 value\nvec4 make255to0(vec4 x) {\n\treturn x / 255.0;\n}\n\n//converts a 0-1 value to a 0-255 value\nvec3 make0to255(vec3 x) {\n\treturn x * 255.0;\n}\n\n//converts a 0-255 value to a 0-1 value\nvec3 make255to0(vec3 x) {\n\treturn x / 255.0;\n}\n\n//converts a 0-1 value to a 0-255 value\nvec2 make0to255(vec2 x) {\n\treturn x * 255.0;\n}\n\n//converts a 0-255 value to a 0-1 value", "\n    float r = length(point);\n    float a = atan(point.y, point.x);\n    float da = spread * (1.0 - smoothstep(0.0, 1.0, r));\n    float a2 = mod(a + da + offset, 6.28318530718);\n    float r2 = sqrt(r);\n    return vec2(cos(a2) * r2, sin(a2) * r2);\n}\n\n// makes a simple flowmap in the shape of a spiral centered on point\nvec2 spiralFlow(vec2 point, float offset)\n{\n    float r = length(point);\n    float a = atan(point.y, point.x);\n    float a2 = mod(a + offset, 6.28318530718);\n    float r2 = sqrt(r);\n    return vec2(cos(a2) * r2, sin(a2) * r2);\n}\n\n// makes a simple flowmap in the shape of a spiral centered on point\nvec2 spiralFlow(vec2 point, float offset, float scale)\n{\n    float r = length(point);\n    float a = atan(point.y, point.x);\n    float a2 = mod(a + offset, 6.28318530718);\n    float r2 = sqrt(r) * scale;\n    return vec2(cos(a2) * r2, sin(a2) * r2);\n}\n\n// makes a simple flowmap in the shape of a spiral centered on point\nvec2 spiralFlow(vec2 point, float offset, float scale, float rotation)\n{\n    float r = length(point);\n    float a = atan(point.y, point.x);\n    float a2 = mod(a + offset, 6.28318530718);\n    float r2 = sqrt(r) * scale;\n    float a3 = a2 + rotation;\n    return vec2(cos(a3) * r2, sin(a3) * r2);\n}\n\n// makes a simple flowmap in the shape of a spiral centered on point\nvec2 spiralFlow(vec2 point, float", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  float d1 = -q.y-c.z;\n  float d2 = max( dot(q,c.xy), q.y);\n  return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba", "\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, id, sp );\n\n    // add some noise\n    d += 0.1 * sin( 10.0 * p.x + 10.0 * p.y + time );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, id, sp );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, id );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, float time )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, time );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, in float time )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, time );\n\n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, float time, in float time2 )\n{\n    // the SDF we want to repeat\n    float d = sdSphere( p, 1.0 );\n\n    // repeat the SDF\n    d = opRepeat( d, time, time2 );\n\n    return d", "\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float d = abs(mod(r,ra)-ra/2.)-ra/2.;\n    float m = mod(a,sp);\n    float d2 = abs(m-sp/2.)-sp/2.;\n    float d3 = abs(m-sp/4.)-sp/4.;\n    float d4 = abs(m-sp/8.)-sp/8.;\n    float d5 = abs(m-sp/16.)-sp/16.;\n    float d6 = abs(m-sp/32.)-sp/32.;\n    float d7 = abs(m-sp/64.)-sp/64.;\n    float d8 = abs(m-sp/128.)-sp/128.;\n    float d9 = abs(m-sp/256.)-sp/256.;\n    float d10 = abs(m-sp/512.)-sp/512.;\n    float d11 = abs(m-sp/1024.)-sp/1024.;\n    float d12 = abs(m-sp/2048.)-sp/2048.;\n    float d13 = abs(m-sp/4096.)-sp/4096.;\n    float d14 = abs(m-sp/8192.)-sp/8192.;\n    float d15 = abs(m-sp/16384.)-sp/16384.;\n    float d16 = abs(m-sp/32768.)-sp/32768.;\n    float d17 = abs(m-sp/65536.)-sp/65536.;\n    float d18 = abs(m-sp/131072.)-sp/131072.;\n    float d19 = abs(m-sp/262144.)-sp/262144.;\n    float d20 = abs(m-sp/524288.)-sp/524288.;\n    float d21 = abs(m-", "\n    vec3 d = abs(uvw) - 0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 0.5;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    vec2 q = vec2(length(uvw.xz) - 0.25, uvw.y);\n    return length(q) - 0.05;\n}\n\n//edge distance of a Klein Bottle\nfloat kleinDist(vec3 uvw) {\n    float p2 = uvw.x*uvw.x + uvw.z*uvw.z;\n    float q2 = uvw.y*uvw.y + uvw.z*uvw.z;\n    float b = p2*q2;\n    float c = uvw.y*p2*uvw.y + uvw.x*q2*uvw.x;\n    float h = b + c - 0.125;\n    float d = sqrt(h*h + 0.25*c*c) - h*0.5;\n    return sqrt(d*d + b);\n}\n\n//edge distance of a M\u00f6bius Strip\nfloat mobiusDist(vec3 uvw) {\n    float p2 = uvw.x*uvw.x + uvw.z*uvw.z;\n    float q2 = uvw.y*uvw.y + uvw.z*uvw.z;\n    float b = p2*q2;\n    float c = uvw.y*p2*uvw.y + uvw.x*q2*uvw.x;\n    float h = b + c - 0.125;\n    float d = sqrt(h*h + 0.25*c*c) - h*0.5;\n    return sqrt(d*d + b);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float q = length(uvw.xz);\n    return max(q - u", "\n    vec3 uvwAbs = abs(uvw);\n    float maxAbs = max(uvwAbs.x, max(uvwAbs.y, uvwAbs.z));\n    float minAbs = min(uvwAbs.x, min(uvwAbs.y, uvwAbs.z));\n    float maxAbs2 = maxAbs * maxAbs;\n    float minAbs2 = minAbs * minAbs;\n    float maxAbs3 = maxAbs2 * maxAbs;\n    float minAbs3 = minAbs2 * minAbs;\n    float maxAbs4 = maxAbs3 * maxAbs;\n    float minAbs4 = minAbs3 * minAbs;\n    float maxAbs5 = maxAbs4 * maxAbs;\n    float minAbs5 = minAbs4 * minAbs;\n    float maxAbs6 = maxAbs5 * maxAbs;\n    float minAbs6 = minAbs5 * minAbs;\n    float maxAbs7 = maxAbs6 * maxAbs;\n    float minAbs7 = minAbs6 * minAbs;\n    float maxAbs8 = maxAbs7 * maxAbs;\n    float minAbs8 = minAbs7 * minAbs;\n    float maxAbs9 = maxAbs8 * maxAbs;\n    float minAbs9 = minAbs8 * minAbs;\n    float maxAbs10 = maxAbs9 * maxAbs;\n    float minAbs10 = minAbs9 * minAbs;\n    float maxAbs11 = maxAbs10 * maxAbs;\n    float minAbs11 = minAbs10 * minAbs;\n    float maxAbs12 = maxAbs11 * maxAbs;\n    float minAbs12 = minAbs11 * minAbs;\n    float maxAbs13 = maxAbs12 * maxAbs;\n    float minAbs13 = minAbs12 * minAbs;\n    float maxAbs14 = maxAbs13 * maxAbs;\n    float minAbs14 = minAbs13 * minAbs;\n    float maxAbs15 = maxAbs14 * maxAbs;\n    float minAbs15 = minAbs14 * minAbs;\n    float maxAbs16 = maxAbs15 * maxAbs;\n    float minAbs16 = minAbs15 * minAbs;\n    float maxAbs17 = maxAbs16 * maxAbs;\n    float minAbs17 = minAbs16 * minAbs;\n    float maxAbs18 =", "\n  vec3 uvw0 = uvw - offset;\n  vec3 uvw1 = uvw + offset;\n  vec3 uvw2 = uvw - offset * 2.0;\n  vec3 uvw3 = uvw + offset * 2.0;\n\n  vec4 cell0 = texture(cubeTexture, uvw0);\n  vec4 cell1 = texture(cubeTexture, uvw1);\n  vec4 cell2 = texture(cubeTexture, uvw2);\n  vec4 cell3 = texture(cubeTexture, uvw3);\n\n  vec4 cell = mix(cell0, cell1, step(0.5, fract(uvw0.x * gridRes)));\n  cell = mix(cell, cell2, step(0.5, fract(uvw2.x * gridRes)));\n  cell = mix(cell, cell3, step(0.5, fract(uvw3.x * gridRes)));\n\n  return cell;\n}\n\n// get the cell value at the given position\nvec4 getCell(vec3 uvw) {\n  vec3 offset = vec3(0.0);\n  float gridRes = 1.0;\n\n  vec4 cell = cubeCell(uvw, offset, gridRes);\n\n  return cell;\n}\n\n// get the cell value at the given position\nvec4 getCell(vec3 uvw, vec3 offset, float gridRes) {\n  vec4 cell = cubeCell(uvw, offset, gridRes);\n\n  return cell;\n}\n\n// get the cell value at the given position\nvec4 getCell(vec3 uvw, vec3 offset, float gridRes, float gridSize) {\n  vec4 cell = cubeCell(uvw, offset, gridRes);\n\n  return cell;\n}\n\n// get the cell value at the given position\nvec4 getCell(vec3 uvw, vec3 offset, float gridRes, float gridSize, float gridScale) {\n  vec4 cell = cubeCell(uvw, offset, gridRes);\n\n  return cell;\n}\n\n// get the cell value at the given position\nvec4 getCell(vec3 uvw, vec3 offset, float gridRes, float gridSize, float gridScale, float gridBias) {\n  vec4 cell = cubeCell(uvw, offset, gridRes);\n\n  return cell;\n}\n\n// get the cell", "\n    vec3 c = vec3(0.0);\n    if (t < 0.5) {\n        c.r = 4.0 * t;\n        c.g = 1.0;\n    } else {\n        c.b = 2.0 * (t - 0.5);\n        c.r = 1.0;\n    }\n    return c;\n}\n\n// makes RdYlBu_r colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float s) {\n    vec3 c = vec3(0.0);\n    if (t < 0.5) {\n        c.r = 4.0 * t;\n        c.g = 1.0;\n    } else {\n        c.b = 2.0 * (t - 0.5);\n        c.r = 1.0;\n    }\n    return c * s;\n}\n\n// makes RdYlBu_r colormap with polynimal 8 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float s, float v) {\n    vec3 c = vec3(0.0);\n    if (t < 0.5) {\n        c.r = 4.0 * t;\n        c.g = 1.0;\n    } else {\n        c.b = 2.0 * (t - 0.5);\n        c.r = 1.0;\n    }\n    return c * s * v;\n}\n\n// makes RdYlBu_r colormap with polynimal 9 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float s, float v, float a) {\n    vec3 c = vec3(0.0);\n    if (t < 0.5) {\n        c.r = 4.0 * t;\n        c.g = 1.0;\n    } else {\n        c.b = 2.0 * (t - 0.5);\n        c.r = 1.0;\n    }\n    return c * s * v * a;", "\n    p = abs(p);\n    float d = max(p.x + p.y + p.z - 1.0, 0.0);\n    d = min(d, p.x + p.y - p.z);\n    d = min(d, p.x + p.z - p.y);\n    d = min(d, p.y + p.z - p.x);\n    return d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x + p.y + p.z - 1.0, 0.0);\n    d = min(d, p.x + p.y - p.z);\n    d = min(d, p.x + p.z - p.y);\n    d = min(d, p.y + p.z - p.x);\n    d = min(d, p.x - p.y);\n    d = min(d, p.x - p.z);\n    d = min(d, p.y - p.z);\n    return d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x + p.y + p.z - 1.0, 0.0);\n    d = min(d, p.x + p.y - p.z);\n    d = min(d, p.x + p.z - p.y);\n    d = min(d, p.y + p.z - p.x);\n    d = min(d, p.x - p.y);\n    d = min(d, p.x - p.z);\n    d = min(d, p.y - p.z);\n    d = min(d, p.x + p.y + p.z);\n    return d;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecaDist(vec3 p) {\n    p = abs(p);\n    float d = max(p.x + p.y + p.z - 1.0, 0.0);\n    d = min(", "\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(pow(t, 6.0), pow(t, 5.0), pow(t, 4.0));\n}\n\n// makes winter colormap with polynimal 5\nvec3 winter5(float t) {\n    return vec3(pow(t, 5.0), pow(t, 4.0), pow(t, 3.0));\n}\n\n// makes summer colormap with polynimal 5\nvec3 summer5(float t) {\n    return vec3(pow(t, 5.0), pow(t, 4.0), pow(t, 3.0));\n}\n\n// makes autumn colormap with polynimal 5\nvec3 autumn5(float t) {\n    return vec3(pow(t, 5.0), pow(t, 4.0), pow(t, 3.0));\n}\n\n// makes spring colormap with polynimal 5\nvec3 spring5(float t) {\n    return vec3(pow(t, 5.0), pow(t, 4.0), pow(t, 3.0));\n}\n\n// makes winter colormap with polynimal 4\nvec3 winter4(float t) {\n    return vec3(pow(t, 4.0), pow(t, 3.0), pow(t, 2.0));\n}\n\n// makes summer colormap with polynimal 4\nvec3 summer", "\n    vec2 size = vec2(1.0 / 3.0, 1.0 / 3.0);\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple hexagonal Tiling\nvec3 hexTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple triangular Tiling\nvec3 triTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple diamond Tiling\nvec3 diamondTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple octagonal Tiling\nvec3 octTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple pentagonal Tiling\nvec3 pentTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n// simple hexagonal Tiling\nvec3 hexTile(vec2 uv) {\n    vec2 size = vec2(1.0 / 3.0, 1.0 / sqrt(3.0));\n    vec2 pos = floor(uv * size) / size;\n    return vec3(pos, 0.0);\n}\n\n", "\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(min(q.x, q.y), max(q.x, q.y), 0.0);\n}\n\n//triangular shape form Manhattan distance\nvec3 triTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(min(q.x, q.y), max(q.x, q.y), 0.0);\n}\n\n//square shape form Manhattan distance\nvec3 sqrTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(min(q.x, q.y), max(q.x, q.y), 0.0);\n}\n\n//hexagonal shape form Manhattan distance\nvec3 hexTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(min(q.x, q.y), max(q.x, q.y), 0.0);\n}\n\n//octagonal shape form Manhattan distance\nvec3 octTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(min(q.x, q.y), max(q.x, q.y), 0.0);\n}\n\n//triangular shape form Chebyshev distance\nvec3 triTileChebyshev(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(max(q.x, q.y), 0.0, 0.0);\n}\n\n//square shape form Chebyshev distance\nvec3 sqrTileChebyshev(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 q = abs(p - 0.5);\n    return vec3(max(q.", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d.x * d.y);\n}\n\n// nakes a hexagonal pixelized pattern\nvec3 hexPixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d.x * d.y);\n}\n\n// nakes a triangular pixelized pattern\nvec3 triPixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d.x * d.y);\n}\n\n// nakes a circular pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d.x * d.y);\n}\n\n// nakes a circular pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d.x * d.y);\n}\n\n// nakes a circular pixelized pattern\nvec3 circlePixelizor(vec2 uv, float gridRes, vec2 offset, float radius, float thickness) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 f = fract(uv * gridRes);\n    vec2 d = step(f, vec2(0.5));\n    return vec3(d", "\n    vec2 grid = floor(uv * gridRes) / gridRes;\n    vec2 d = fract(uv * gridRes);\n    vec2 d2 = 1.0 - d;\n    vec3 col = vec3(0.0);\n    col += d.x * d.y * vec3(1.0, 0.0, 0.0);\n    col += d.x * d2.y * vec3(0.0, 1.0, 0.0);\n    col += d2.x * d.y * vec3(0.0, 0.0, 1.0);\n    col += d2.x * d2.y * vec3(1.0, 1.0, 1.0);\n    return col;\n}\n\n// nakes a triangular pixelized pattern\nvec3 triPixelizor(vec2 uv, float gridRes) {\n    vec2 grid = floor(uv * gridRes) / gridRes;\n    vec2 d = fract(uv * gridRes);\n    vec2 d2 = 1.0 - d;\n    vec3 col = vec3(0.0);\n    col += d.x * d.y * vec3(1.0, 0.0, 0.0);\n    col += d.x * d2.y * vec3(0.0, 1.0, 0.0);\n    col += d2.x * d.y * vec3(0.0, 0.0, 1.0);\n    col += d2.x * d2.y * vec3(1.0, 1.0, 1.0);\n    return col;\n}\n\n// nakes a hexagonal pixelized pattern\nvec3 hexPixelizor(vec2 uv, float gridRes) {\n    vec2 grid = floor(uv * gridRes) / gridRes;\n    vec2 d = fract(uv * gridRes);\n    vec2 d2 = 1.0 - d;\n    vec3 col = vec3(0.0);\n    col += d.x * d.y * vec3(1.0, 0.0, 0.0);\n    col += d.x * d2.y * vec3(0.0, 1", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    vec2 uv2 = fract(uv * gridRes) + offset;\n    vec2 grid2 = floor(uv2 * gridRes) + offset;\n    vec2 uv3 = fract(uv2 * gridRes) + offset;\n    vec2 grid3 = floor(uv3 * gridRes) + offset;\n    vec2 uv4 = fract(uv3 * gridRes) + offset;\n    vec2 grid4 = floor(uv4 * gridRes) + offset;\n    vec2 uv5 = fract(uv4 * gridRes) + offset;\n    vec2 grid5 = floor(uv5 * gridRes) + offset;\n    vec2 uv6 = fract(uv5 * gridRes) + offset;\n    vec2 grid6 = floor(uv6 * gridRes) + offset;\n    vec2 uv7 = fract(uv6 * gridRes) + offset;\n    vec2 grid7 = floor(uv7 * gridRes) + offset;\n    vec2 uv8 = fract(uv7 * gridRes) + offset;\n    vec2 grid8 = floor(uv8 * gridRes) + offset;\n    vec2 uv9 = fract(uv8 * gridRes) + offset;\n    vec2 grid9 = floor(uv9 * gridRes) + offset;\n    vec2 uv10 = fract(uv9 * gridRes) + offset;\n    vec2 grid10 = floor(uv10 * gridRes) + offset;\n    vec2 uv11 = fract(uv10 * gridRes) + offset;\n    vec2 grid11 = floor(uv11 * gridRes) + offset;\n    vec2 uv12 = fract(uv11 * gridRes) + offset;\n    vec2 grid12 = floor(uv12 * gridRes) + offset;\n    vec2 uv13 = fract(uv12 * gridRes) + offset;\n    vec2 grid13 = floor(uv13 * gridRes) + offset;\n    vec2 uv14 = fract(uv13 * gridRes) + offset;\n    vec2 grid14 = floor(uv14 * gridRes) + offset;\n    vec2 uv15 = fract(uv14 * gridRes) + offset;\n    vec2 grid", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 uv2 = uv * gridRes - grid;\n    vec2 uv3 = uv2 - 0.5;\n    float d = length(uv3);\n    float a = atan(uv3.y, uv3.x);\n    float t = time * 0.1;\n    float v = sin(a * 2.0 + t) * sin(a * 4.0 + t * 2.0) * sin(a * 8.0 + t * 4.0);\n    float f = smoothstep(0.0, 1.0, v);\n    float g = smoothstep(0.0, 1.0, 1.0 - d);\n    float h = smoothstep(0.0, 1.0, 1.0 - f * g);\n    return h;\n}\n\n// generates a cellular noise pattern\nfloat flowRhomNoise(vec2 uv, float gridRes, float time) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 uv2 = uv * gridRes - grid;\n    vec2 uv3 = uv2 - 0.5;\n    float d = length(uv3);\n    float a = atan(uv3.y, uv3.x);\n    float t = time * 0.1;\n    float v = sin(a * 2.0 + t) * sin(a * 4.0 + t * 2.0) * sin(a * 8.0 + t * 4.0);\n    float f = smoothstep(0.0, 1.0, v);\n    float g = smoothstep(0.0, 1.0, 1.0 - d);\n    float h = smoothstep(0.0, 1.0, 1.0 - f * g);\n    return h;\n}\n\n// generates a cellular noise pattern with a random offset\nfloat flowRhomNoiseOffset(vec2 uv, float gridRes, float time) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 uv2 = uv * gridRes - grid;\n    vec2 uv3 = uv2 - 0.5;\n    float d = length(uv3);\n    float a = atan(uv3.y,", "\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.001;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = 2.0*floor(a);\n    vec2 f = fract(a);\n    vec2 c = vec2(a.x-i.x, b.x-i.x);\n    vec2 g = vec2(a.y-i.y, b.y-i.y);\n    vec2 l = step(c,f);\n    vec2 h = 1.0-step(g,vec2(f.y,c.y));\n    vec2 m = l*h;\n    return mix( mix( m.x*m.y, m.y*(1.0-m.x), l.x ),\n                mix( m.x*(1.0-m.y), (1.0-m.x)*(1.0-m.y), l.x ),\n                l.y );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGradBox( p*scale, ddx*scale, ddy*scale );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset )\n{\n    return gridTextureGradBox( p*scale+offset, ddx*scale, ddy*scale );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset, in float threshold )\n{\n    return gridTextureGradBox( p*scale+offset, ddx*scale, ddy*scale ) > threshold? 1.0 : 0.0;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale, in float offset, in float threshold, in float falloff )\n{\n    return gridTextureGradBox( p*scale+offset, ddx*scale, ddy*scale ) > threshold? 1.0-pow(1.", "\n    p = abs(p);\n    return max(abs(p.y) - r, p.x * 0.866025 + p.y * 0.5);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p) {\n    p = abs(p);\n    return max(abs(p.y) - 1.0, p.x * 0.866025 + p.y * 0.5);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float m) {\n    p = abs(p);\n    return max(abs(p.y) - r, p.x * 0.866025 + p.y * 0.5) - m;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float m) {\n    p = abs(p);\n    return max(abs(p.y) - 1.0, p.x * 0.866025 + p.y * 0.5) - m;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float m, float n) {\n    p = abs(p);\n    return max(abs(p.y) - r, p.x * 0.866025 + p.y * 0.5) - m - n * length(p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d", "\n    vec2 s = floor(p);\n    p = fract(p);\n    p = abs(p - 0.5);\n    return s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdBox(vec3 p, vec3 b, float r) {\n    return sdSphere(p, r) - sdBox(p, b);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdBox(vec3 p, vec3 b, float r, float h) {\n    return max(sdBox(p, b, r), -p.y - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdBox(vec3 p, vec3 b, float r, float h, float d) {\n    return max(sdBox(p, b, r, h), -p.y - d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/4djSRW\nfloat sdBox(vec3 p, vec3 b, float r, float h, float d, float e) {\n    return max(sdBox(p, b, r, h, d), -p.y - e);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://", "\n    return 0.5 + 0.5*sin(x);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat fbm( vec3 p, float f )\n{\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float t = 0.5*(a+b);\n        float w = smoothstep( a, b, f );\n        a = t;\n        b = t+w*(1.0-t);\n        f = f*w;\n        p = m*p*2.02;\n    }\n    return mix( a, b, f );\n}\n\nfloat fbm( vec3 p, float f, float w )\n{\n    float a = 0.0;\n    float b = 1.0;\n    for( int i=0; i<5;", "\n    return mix(1.055*pow(t,vec3(0.4166666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666", "\n    vec2 q = fract(p);\n    float d = 1.0;\n    if (q.x < 0.5) {\n        if (q.y < 0.5) {\n            d = 0.0;\n        } else {\n            d = 0.5;\n        }\n    } else {\n        if (q.y < 0.5) {\n            d = 0.5;\n        } else {\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// Truchet pattern with 45 degree rotations\nfloat df1(vec2 p) {\n    vec2 q = fract(p);\n    float d = 1.0;\n    if (q.x < 0.5) {\n        if (q.y < 0.5) {\n            d = 0.0;\n        } else {\n            d = 0.5;\n        }\n    } else {\n        if (q.y < 0.5) {\n            d = 0.5;\n        } else {\n            d = 1.0;\n        }\n    }\n    if (q.x < 0.25) {\n        d = 0.5 - d;\n    } else if (q.x < 0.75) {\n        d = 0.5 + d;\n    }\n    if (q.y < 0.25) {\n        d = 0.5 - d;\n    } else if (q.y < 0.75) {\n        d = 0.5 + d;\n    }\n    return d;\n}\n\n// Truchet pattern with 90 degree rotations\nfloat df2(vec2 p) {\n    vec2 q = fract(p);\n    float d = 1.0;\n    if (q.x < 0.5) {\n        if (q.y < 0.5) {\n            d = 0.0;\n        } else {\n            d = 0.5;\n        }\n    } else {\n        if (q.y < 0.5) {\n            d = 0.5;\n        } else {\n            d = 1.0;\n        }\n    }\n    if (q.x < 0.25) {\n        d = 0.5 - d;", "\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i));\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.5);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.25);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.125);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.0625);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df6(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.03125);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df7(vec2 p) {\n    float d = 0.0;\n    for (int i = 0; i < 10; i++) {\n        d += truchet(p, float(i) * 0.015625);\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    float a = dot( e0, e0 );\n    float b = dot( e0, e1 );\n    float c = dot( e1, e1 );\n    float d = dot( e0, v0 );\n    float e = dot( e1, v1 );\n    float f = dot( v0, v0 );\n    float g = dot( v1, v1 );\n    float h = dot( v2, v2 );\n\n    float i = sqrt( abs( a*h - b*g + c*f + d*e - 2.0*b*d + a*g - c*e - b*f + 2.0*c*d ) );\n    float j = sign( a*h - b*g + c*f + d*e - 2.0*b*d + a*g - c*e - b*f + 2.0*c*d ) * ( a*f - b*d + c*d + g*b - h*a + c*e );\n\n    return i/j;\n}\n\n// signed distance to a 2D rectangle\nfloat sdRectangle( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// signed distance to a 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    return length(p/r) - 1.0;\n}\n\n// signed distance to a 2D capsule\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p - a, ba = b -", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h > dbuffer? -b + h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph) {\n    return sphered(ro, rd, sph, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec3 sph, float dbuffer) {\n    return sphered(ro, rd, vec4(sph, 1.0), dbuffer);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec3 sph) {\n    return sphered(ro, rd, vec4(sph, 1.0), 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, float sph, float dbuffer) {\n    return sphered(ro, rd, vec4(0.0, 0.0, 0.0, sph), dbuffer);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, float sph) {\n   ", "\n    vec2 d = abs(p) - vec2(w, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float w, float r) {\n    vec2 d = abs(p) - vec2(r, w);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float r) {\n    vec2 d = abs(p) - vec2(w, w);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, float r, float m) {\n    vec2 d = abs(p) - b;\n    return length(max(vec2(d.x, d.y * m), 0.0)) + min(max(d.x, d.y * m), 0.0) - r;\n}\n\n// License: MIT, author: Inigo Quilez", "\n    vec2 d = abs(vec2(length(p.xy),p.y)) - vec2(k,1.0);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n    vec3 d = abs(vec3(length(p.xy),p.z)) - vec3(k,1.0);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\n    vec4 d = abs(vec4(length(p.xy),p.z,p.w)) - vec4(k,1.0,1.0,1.0);\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, vec2 k )\n{\n    vec2 d = abs(vec2(length(p.xy),p.y)) - k;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, vec3 k )\n{\n    vec3 d = abs(vec3(length(p.xy),p.z)) - k;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, vec4 k )\n{\n    vec4 d = abs(vec4(length(p.xy),p.z,p.w)) - k;\n    return min(max(d.x,", "\n    p.x = abs(p.x);\n    return -length(p)+.5;\n}\n\n// distance to y=1/x^2\nfloat sdOOX2( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.25;\n}\n\n// distance to y=1/x^3\nfloat sdOOX3( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.125;\n}\n\n// distance to y=1/x^4\nfloat sdOOX4( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.0625;\n}\n\n// distance to y=1/x^5\nfloat sdOOX5( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.03125;\n}\n\n// distance to y=1/x^6\nfloat sdOOX6( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.015625;\n}\n\n// distance to y=1/x^7\nfloat sdOOX7( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.0078125;\n}\n\n// distance to y=1/x^8\nfloat sdOOX8( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.00390625;\n}\n\n// distance to y=1/x^9\nfloat sdOOX9( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.001953125;\n}\n\n// distance to y=1/x^10\nfloat sdOOX10( in vec2 p )\n{\n    p.x = abs(p.x);\n    return -length(p)+.0009765625;\n}\n", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) + k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float c, float k) {\n    float a1 = pmin(a, b, k);\n    float a2 = pmin(c, b, k);\n    float a3 = pmin(a, c, k);\n    float a4 = pmin(a, b, c, k);\n    return pmax(pmax(a1, a2, k), pmax(a3, a4, k), k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float c, float k) {\n    float a1 = pmax(a, b, k);\n    float a2 = pmax(c, b, k);\n    float a3 = pmax(a, c, k);\n    float a4 = pmax(a, b, c, k);\n    return pmin(pmin(a1, a2, k), pmin(a3, a4, k), k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float", "\n    return k * (a < 0.0? -a : a);\n}\n\nfloat psign(float a, float k) {\n    return k * (a < 0.0? -1.0 : 1.0);\n}\n\nfloat psign(float a) {\n    return psign(a, 1.0);\n}\n\nfloat psign(float a, float k, float n) {\n    return psign(a, k) * pow(abs(a), n - 1.0);\n}\n\nfloat psign(float a, float n) {\n    return psign(a, 1.0, n);\n}\n\nfloat psign(float a, float k, float n, float m) {\n    return psign(a, k, n) * pow(abs(a), m - n);\n}\n\nfloat psign(float a, float n, float m) {\n    return psign(a, 1.0, n, m);\n}\n\nfloat psign(float a, float k, float n, float m, float o) {\n    return psign(a, k, n, m) * pow(abs(a), o - m);\n}\n\nfloat psign(float a, float n, float m, float o) {\n    return psign(a, 1.0, n, m, o);\n}\n\nfloat psign(float a, float k, float n, float m, float o, float p) {\n    return psign(a, k, n, m, o) * pow(abs(a), p - o);\n}\n\nfloat psign(float a, float n, float m, float o, float p) {\n    return psign(a, 1.0, n, m, o, p);\n}\n\nfloat psign(float a, float k, float n, float m, float o, float p, float q) {\n    return psign(a, k, n, m, o, p) * pow(abs(a), q - p);\n}\n\nfloat psign(float a, float n, float m, float o, float p, float q) {\n    return psign(a, 1.0, n, m, o,", "\n    p.x *= 1.6;\n    p.y *= 1.1;\n    p -= vec2(0.5, 0.8);\n    p.x *= 1.6;\n    p.y *= 2.2;\n    p.x += 0.25 * p.y;\n    p *= 1.1;\n    p.y -= 0.25;\n    p.x *= 0.8;\n    p.y *= 1.2;\n    p.x -= 0.05;\n    p.y -= 0.25;\n    p.x *= 1.3;\n    p.y *= 1.2;\n    p.x -= 0.1;\n    p.y -= 0.2;\n    p.x *= 1.2;\n    p.y *= 1.1;\n    p.x -= 0.15;\n    p.y -= 0.15;\n    p.x *= 1.1;\n    p.y *= 1.05;\n    p.x -= 0.1;\n    p.y -= 0.1;\n    p.x *= 1.05;\n    p.y *= 1.0;\n    p.x -= 0.05;\n    p.y -= 0.05;\n    p.x *= 1.0;\n    p.y *= 1.0;\n    p.x -= 0.05;\n    p.y -= 0.05;\n    p.x *= 1.0;\n    p.y *= 0.95;\n    p.x -= 0.05;\n    p.y -= 0.05;\n    p.x *= 0.95;\n    p.y *= 0.95;\n    p.x -= 0.05;\n    p.y -= 0.05;\n    p.x *= 0.95;\n    p.y *= 0.9;\n    p.x -= 0.05;\n    p.y -= 0.05;\n    p.x *= 0.9;\n    p.y *= 0.9;\n    p.x -= 0.05;\n    p.y -= 0.05;\n   ", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12_sine(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z) * 2. - 1.;\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13_sine(vec3 p3) {\n\tp3 = fract(p3 *.1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z) * 2. - 1.;\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p) {\n\tvec2 p2 = fract(p * vec2(.1031,.1030));\n\tp2 += dot(p2, p2.yx + 33.33);\n\treturn fract((p2.x + p2.y) * p2.x);\n}\n\n// Hash with Sine https://www.shader", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n\n    vec2 d = pos - A;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv;\n        if( x.x > x.y ) uv = vec2(p,x.x);\n        else uv = vec2(x.y,p);\n        uv *= 1.0/3.0;\n        res = dot(uv,uv*uv);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        res = z*m*m;\n    }\n\n    return vec3( res, -kx - kx*res, ky - kx*res );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B +", "\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float z = x*x + y*y;\n    float dzdx = 2.0*x;\n    float dzdy = 2.0*y;\n    float d = sqrt(dzdx*dzdx + dzdy*dzdy);\n    dzdx /= d;\n    dzdy /= d;\n    return vec3(z, dzdx, dzdy);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float w, in float h )\n{\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float z = x*x + y*y;\n    float dzdx = 2.0*x;\n    float dzdy = 2.0*y;\n    float d = sqrt(dzdx*dzdx + dzdy*dzdy);\n    dzdx /= d;\n    dzdy /= d;\n    return vec3(z, dzdx, dzdy);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float w, in float h, in float t )\n{\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float z = x*x + y*y;\n    float dzdx = 2.0*x;\n    float dzdy = 2.0*y;\n    float d = sqrt(dzdx*dzdx + dzdy*dzdy);\n    dzdx /= d;\n    dzdy /= d;\n    return", "\n    vec2 p = pos.xy - vec2(0.0, 0.5);\n    float x = length(p);\n    float y = p.y;\n    float z = p.x;\n    float yz = sqrt(y*y + z*z);\n    float d = (x - yz) * (x - yz) + k * y * y;\n    return vec3(d, x, yz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec3 pos, in float k )\n{\n    vec3 p = pos.xyz - vec3(0.0, 0.5, 0.0);\n    float x = length(p.xy);\n    float y = p.y;\n    float z = p.z;\n    float yz = sqrt(y*y + z*z);\n    float d = (x - yz) * (x - yz) + k * y * y;\n    return vec3(d, x, yz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec4 pos, in float k )\n{\n    vec4 p = pos.xyzw - vec4(0.0, 0.5, 0.0, 0.0);\n    float x = length(p.xy);\n    float y = p.y;\n    float z = p.z;\n    float yz = sqrt(y*y + z*z);\n    float d = (x - yz) * (x - yz) + k * y * y;\n    return vec3(d, x, yz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p", "\n    vec2 q = p;\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float b = a + 0.5;\n    float c = a - 0.5;\n    float d1 = abs(r - ra) - rb;\n    float d2 = abs(r - ra) + rb;\n    float d3 = abs(r - ra) - 0.5;\n    float d4 = abs(r - ra) + 0.5;\n    float d5 = abs(r - ra) - 0.25;\n    float d6 = abs(r - ra) + 0.25;\n    float d7 = abs(r - ra) - 0.125;\n    float d8 = abs(r - ra) + 0.125;\n    float d9 = abs(r - ra) - 0.0625;\n    float d10 = abs(r - ra) + 0.0625;\n    float d11 = abs(r - ra) - 0.03125;\n    float d12 = abs(r - ra) + 0.03125;\n    float d13 = abs(r - ra) - 0.015625;\n    float d14 = abs(r - ra) + 0.015625;\n    float d15 = abs(r - ra) - 0.0078125;\n    float d16 = abs(r - ra) + 0.0078125;\n    float d17 = abs(r - ra) - 0.00390625;\n    float d18 = abs(r - ra) + 0.00390625;\n    float d19 = abs(r - ra) - 0.001953125;\n    float d20 = abs(r - ra) + 0.001953125;\n    float d21 = abs(r - ra) - 0.0009765625;\n    float d22 = abs(r - ra) + 0.0", "\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.y;\n    v.y += v.x * v.x;\n    return v;\n}\n\n// 2D Perlin Noise\nfloat Perlin2D(vec2 p)\n{\n    ivec2 pi = ivec2(floor(p));\n    vec2 pf = fract(p);\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    vec2 u = vec2(pi.x + 0.0, pi.y + 0.0);\n    vec2 v = vec2(pi.x + 1.0, pi.y + 0.0);\n    vec2 s = vec2(pi.x + 0.0, pi.y + 1.0);\n    vec2 t = vec2(pi.x + 1.0, pi.y + 1.0);\n    float a = mix(mix(hash21(u), hash21(v), w.x), mix(hash21(s), hash21(t), w.x), w.y);\n    return a;\n}\n\n// 3D Perlin Noise\nfloat Perlin3D(vec3 p)\n{\n    ivec3 pi = ivec3(floor(p));\n    vec3 pf = fract(p);\n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    vec3 u = vec3(pi.x + 0.0, pi.y + 0.0, pi.z + 0.0);\n    vec3 v = vec3(pi.x + 1.0, pi.y + 0.0, pi.z + 0.0);\n    vec3 s = vec3(pi.x + 0.0, pi.y + 1.0, pi.z + 0.0);\n    vec3 t = vec3(pi.x + 1.0, pi.y + 1.0, pi.z + 0.0);\n    vec3 a = mix(mix(mix(hash31(u), hash31(v", "\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 increment)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v += increment;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nvec3 Pcg3(vec3 v)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v ^= v >> 16;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if(h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x),vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        res = dot(d + (c + b*t)*t, d + (c + b*t)*t);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q/p/z)/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        res = dot(d + (c + b*t.x)*t.x, d + (c + b*t.x)*t.x);\n        res = min(res, dot(d + (c + b*t.y)*t.y, d + (c + b*t.y)*t.y));\n        res = min(res, dot(d + (c + b*t.z)*t.z, d + (c + b*t.z)*t.z", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) + winding_sign(p, b, c, d) + winding_sign(p, c, d, a) + winding_sign(p, d, a, b);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) + winding_sign(p, b, c, d, e) + winding_sign(p, c, d, e, a) + winding_sign(p, d, e, a, b) + winding_sign(p, e, a, b, c);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) + winding_sign(p, b, c, d, e, f) + winding_sign(p, c, d, e, f, a) + winding_sign(p, d, e, f, a, b) + winding_sign(p, e, f, a, b, c) + winding_sign(p, f, a, b, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2", "\n    vec3 m = -1.0;\n    vec3 n = -1.0;\n    vec3 p = -1.0;\n    vec3 q = -1.0;\n    vec3 r = -1.0;\n    vec3 t = -1.0;\n    vec3 u = -1.0;\n    vec3 v = -1.0;\n    vec3 w = -1.0;\n    vec3 x = -1.0;\n    vec3 y = -1.0;\n    vec3 z = -1.0;\n    vec3 a = -1.0;\n    vec3 b = -1.0;\n    vec3 c = -1.0;\n    vec3 d = -1.0;\n    vec3 e = -1.0;\n    vec3 f = -1.0;\n    vec3 g = -1.0;\n    vec3 h = -1.0;\n    vec3 i = -1.0;\n    vec3 j = -1.0;\n    vec3 k = -1.0;\n    vec3 l = -1.0;\n    vec3 m = -1.0;\n    vec3 n = -1.0;\n    vec3 o = -1.0;\n    vec3 p = -1.0;\n    vec3 q = -1.0;\n    vec3 r = -1.0;\n    vec3 s = -1.0;\n    vec3 t = -1.0;\n    vec3 u = -1.0;\n    vec3 v = -1.0;\n    vec3 w = -1.0;\n    vec3 x = -1.0;\n    vec3 y = -1.0;\n    vec3 z = -1.0;\n    vec3 a = -1.0;\n    vec3 b = -1.0;\n    vec3 c = -1.0;\n    vec3 d = -1.0;\n    vec3 e = -1.0;\n    vec3 f = -1.0;\n    vec3 g = -1.0;\n    vec3 h = -1.0;\n    vec3 i = -1.0;\n    vec3 j = -1.0;\n    vec3 k = -1.0;\n    vec3 l = -1.0;\n    vec3 m = -1.0;\n    vec", "\n\tint n = a * int(b);\n\tret_n = n;\n\treturn frac(float(n) + x);\n}\n\n// https://www.shadertoy.com/view/4d23zn\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f64 (out int ret_n, int a, double b, double x) {\n\tint n = a * int(b);\n\tret_n = n;\n\treturn frac(double(n) + x);\n}\n\n// https://www.shadertoy.com/view/4d23zn\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f128 (out int ret_n, int a, float128 b, float128 x) {\n\tint n = a * int(b);\n\tret_n = n;\n\treturn frac(float128(n) + x);\n}\n\n// https://www.shadertoy.com/view/4d23zn\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f256 (out int ret_n, int a, float256 b, float256 x) {\n\tint n = a * int(b);\n\tret_n = n;\n\treturn frac(float256(n) + x);\n}\n\n// https://www.shadertoy.com/view/4d23zn\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n", "\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec3( mix( b.xy, a.xy, h )-a.xy, mix( b.z, a.z, pow(h,k) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    float h = clamp( 0.5-0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec3( mix( b.xy, a.xy, h )-a.xy, mix( b.z, a.z, pow(h,k) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSAbs( in vec3 a )\n{\n    return vec3( abs(a.xy)-a.xy, a.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMod( in vec3 a, in vec3 b )\n{\n    vec3 q = floor( a.xy/b.xy );\n    vec3 r = a.xy-q*b.xy;\n    return vec3( r-a.xy, a.z+q*b.z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x", "\n    vec2 f = p - ab;\n    return dot(f,f) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat inside_Ellipse( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f) / dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in float r){\n    return dot(p,p) - r*r;\n}\n\n//using the \"locus of points\" geometric defn of line\nfloat inside_Line( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of ray\nfloat inside_Ray( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of segment\nfloat inside_Segment( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of rectangle\nfloat inside_Rectangle( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of triangle\nfloat inside_Triangle( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of polygon\nfloat inside_Polygon( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of polyhedron\nfloat inside_Polyhedron( vec2 p, in vec2 ab){\n    vec2 f = p - ab;\n    return dot(f,f);\n}\n\n//using the \"locus of points\" geometric defn of sphere\nfloat inside_Sphere", "\n    return a+b;\n}\n\nfloat sub_ploss(in float a, in float b){\n    return a-b;\n}\n\nfloat mul_ploss(in float a, in float b){\n    return a*b;\n}\n\nfloat div_ploss(in float a, in float b){\n    return a/b;\n}\n\nfloat mod_ploss(in float a, in float b){\n    return mod(a,b);\n}\n\nfloat pow_ploss(in float a, in float b){\n    return pow(a,b);\n}\n\nfloat exp_ploss(in float a){\n    return exp(a);\n}\n\nfloat log_ploss(in float a){\n    return log(a);\n}\n\nfloat sqrt_ploss(in float a){\n    return sqrt(a);\n}\n\nfloat sin_ploss(in float a){\n    return sin(a);\n}\n\nfloat cos_ploss(in float a){\n    return cos(a);\n}\n\nfloat tan_ploss(in float a){\n    return tan(a);\n}\n\nfloat asin_ploss(in float a){\n    return asin(a);\n}\n\nfloat acos_ploss(in float a){\n    return acos(a);\n}\n\nfloat atan_ploss(in float a){\n    return atan(a);\n}\n\nfloat atan2_ploss(in float a, in float b){\n    return atan(a,b);\n}\n\nfloat sinh_ploss(in float a){\n    return sinh(a);\n}\n\nfloat cosh_ploss(in float a){\n    return cosh(a);\n}\n\nfloat tanh_ploss(in float a){\n    return tanh(a);\n}\n\nfloat asinh_ploss(in float a){\n    return asinh(a);\n}\n\nfloat acosh_ploss(in float a){\n    return acosh(a);\n}\n\nfloat atanh_ploss(in float a){\n    return atanh(a);\n}\n\nfloat abs_ploss(in float a){\n    return abs(a);\n}\n\nfloat sign_ploss(in float a){\n    return sign", "\n\tvec2 p1 = pHyperbola( p, ab, s1 );\n\tvec2 p2 = pHyperbola( p, ab, s2 );\n\tvec2 p3 = pHyperbola( p, ab, s1 + s2 );\n\tvec2 p4 = pHyperbola( p, ab, s1 - s2 );\n\tvec2 p5 = pHyperbola( p, ab, -s1 + s2 );\n\tvec2 p6 = pHyperbola( p, ab, -s1 - s2 );\n\tvec2 p7 = pHyperbola( p, ab, -s1 );\n\tvec2 p8 = pHyperbola( p, ab, -s2 );\n\tvec2 p9 = pHyperbola( p, ab, 0.0 );\n\tvec2 p10 = pHyperbola( p, ab, 1.0 );\n\tvec2 p11 = pHyperbola( p, ab, 2.0 );\n\tvec2 p12 = pHyperbola( p, ab, 3.0 );\n\tvec2 p13 = pHyperbola( p, ab, 4.0 );\n\tvec2 p14 = pHyperbola( p, ab, 5.0 );\n\tvec2 p15 = pHyperbola( p, ab, 6.0 );\n\tvec2 p16 = pHyperbola( p, ab, 7.0 );\n\tvec2 p17 = pHyperbola( p, ab, 8.0 );\n\tvec2 p18 = pHyperbola( p, ab, 9.0 );\n\tvec2 p19 = pHyperbola( p, ab, 10.0 );\n\tvec2 p20 = pHyperbola( p, ab, 11.0 );\n\tvec2 p21 = pHyperbola( p, ab, 12.0 );\n\tvec2 p22 = pHyperbola( p, ab, 13.0 );\n\tvec2 p23 = pHyperbola( p, ab, 14.0 );\n\tvec2 p24 = pHyper", "\n    vec3  ba = b - a;\n    float h  = length(ba);\n    float r  = (ra * h + rb * length(p - a)) / h;\n    float m  = clamp(dot(p - a, ba) / (h * h), 0.0, 1.0);\n    vec3  cp = a + ba * m;\n    return vec4(length(p - cp) - r, cp);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec4 sdcCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    float h  = length(ba);\n    float m  = clamp(dot(p - a, ba) / (h * h), 0.0, 1.0);\n    vec3  cp = a + ba * m;\n    return vec4(length(p - cp) - r, cp);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec4 sdcCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    float h  = length(ba);\n    float m  = clamp(dot(p - a, ba) / (h * h), 0.0, 1.0);\n    vec3  cp = a + ba * m;\n    return vec4(length(p - cp) - r, cp);\n}\n\n//.x   distance to the plane\n//.yzw closest point\nvec4 sdcPlane(vec3 p, vec3 n, float d)\n{\n    return vec4(dot(p, n) + d, p - n * dot(p, n));\n}\n\n//.x   distance to the sphere\n//.yzw closest point\nvec4 sdcSphere(vec3 p, vec3 c, float r)\n{\n    return vec4(length(p - c) - r, p - c);\n}\n\n//.x   distance to the torus\n//.yzw closest point\nvec4 sdcTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2", "\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  // c must be normalized\n  float q = length(p.xy);\n  return dot(c,vec3(q,p.z));\n}\n\nfloat opU( float d1, float d2 )\n{\n  return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n  return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n  return max(d1,d2);\n}\n\nfloat opRep( float p, float sz )\n{\n  return mod(p,sz)-sz/2.0;\n}\n\nfloat opTwist( float p )\n{\n  float c = cos(10.0*p);\n  float s = sin(10.0*p", "\n    return length(p-cen) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - max(r.x,max(r.y,r.z));\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 r, float e )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - max(r.x,max(r.y,r.z)) - e;\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 r, vec3 e )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - max(r.x,max(r.y,r.z)) - max(e.x,max(e.y,e.z));\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 r, vec3 e, float s )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - max(", "\n    vec3 e = vec3(0.001,0.0,0.0);\n    vec3 n = vec3(\n        showSurface? map(pos+e.xyy).x - map(pos-e.xyy).x : samplePoint.x - map(pos-e.xyy).x,\n        showSurface? map(pos+e.yxy).x - map(pos-e.yxy).x : samplePoint.y - map(pos-e.yxy).x,\n        showSurface? map(pos+e.yyx).x - map(pos-e.yyx).x : samplePoint.z - map(pos-e.yyx).x\n    );\n    return normalize(n);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z", "\n    float res = 1.0;\n    float t = 0.001;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( samplePoint + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>2.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c.xy,vec2(q,p.z));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdConeSection( in vec3 p, in float h,", "\n    vec2 q = abs(p);\n    float d = max(q.x, q.y);\n    float h = clamp(d - ra, 0.0, he);\n    float a = clamp(d - rb, 0.0, he);\n    float b = clamp(d - ra - he, 0.0, he);\n    float c = clamp(d - rb - he, 0.0, he);\n    float e = max(a, b);\n    float f = max(c, h);\n    float g = max(e, f);\n    ocl = vec2(e, f);\n    return vec3(g, e - g, f - g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2 ocl, out vec2 ocl2 )\n{\n    vec2 q = abs(p);\n    float d = max(q.x, q.y);\n    float h = clamp(d - ra, 0.0, he);\n    float a = clamp(d - rb, 0.0, he);\n    float b = clamp(d - ra - he, 0.0, he);\n    float c = clamp(d - rb - he, 0.0, he);\n    float e = max(a, b);\n    float f = max(c, h);\n    float g = max(e, f);\n    ocl = vec2(e, f);\n    ocl2 = vec2(a, c);\n    return vec3(g, e - g, f - g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he, out vec2", "\n\tvec2 q = vec2( length(p.xz)-ra, p.y );\n\tvec2 w = vec2( q.x, abs(q.y)-rb );\n\tfloat d = length(w) - rb;\n\treturn vec4( vec3(d,w.y,q.x), d );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float t )\n{\n\tvec2 q = vec2( length(p.xz)-ra, p.y );\n\tvec2 w = vec2( q.x, abs(q.y)-rb );\n\tfloat d = length(w) - rb;\n\treturn vec4( vec3(d,w.y,q.x), d );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float t, float s )\n{\n\tvec2 q = vec2( length(p.xz)-ra, p.y );\n\tvec2 w = vec2( q.x, abs(q.y)-rb );\n\tfloat d = length(w) - rb;\n\treturn vec4( vec3(d,w.y,q.x), d );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float t, float s, float r )\n{\n\tvec2 q = vec2( length(p.xz)-ra, p.y );\n\tvec2 w = vec2( q.x, abs(q.y)-rb );\n\tfloat d = length(w) - rb;\n\treturn vec4( vec3(d,w.y,q.x), d );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float t, float s, float r, float g )\n{\n\tvec2 q = vec2( length", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n  vec2 ba = b-a; vec2 pa = p-a;\n  vec2 cb = c-b; vec2 pb = p-b;\n  vec2 ac = a-c; vec2 pc = p-c;\n  vec2 nor = vec2(ba.y,-ba.x);\n\n  return min(\n     min(\n       dot(ba,pa),\n       -dot(ba,nor)*udSegment(p,b,c)\n     ),\n     -dot(ba,nor)*udSegment(p,a,c)\n  );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n  vec2 ba = b-a; vec2 pa = p-a;\n  vec2 cb = c-b; vec2 pb = p-b;\n  vec2 ac = a-c; vec2 pc = p-c;\n  vec2 nor = vec2(ba.y,-ba.x);\n\n  return min(\n     min(\n       dot(ba,pa),\n       -dot", " return dot(v, v); }\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot2(ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.x;\n    float d2 = max(dot(q, q), c.y * c.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions", "\n    vec2 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size ) \n{\n    vec2 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d) / dot(size, size);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in vec3 size ) \n{\n    vec3 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d) / dot(size, size);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner, in vec4 size ) \n{\n    vec4 d = max(minCorner - p, p - maxCorner);\n    return dot(d, d) / dot(size, size);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner", "\n\t// Water color\n\tvec3 waterColor = vec3(0.0, 0.3, 0.5);\n\n\t// Water normal\n\tvec3 waterNormal = vec3(0.0, 1.0, 0.0);\n\n\t// Water depth\n\tfloat waterDepth = 0.0;\n\n\t// Water reflection\n\tvec3 waterReflection = vec3(0.0);\n\n\t// Water refraction\n\tvec3 waterRefraction = vec3(0.0);\n\n\t// Water fresnel\n\tfloat waterFresnel = 0.0;\n\n\t// Water specular\n\tfloat waterSpecular = 0.0;\n\n\t// Water specular color\n\tvec3 waterSpecularColor = vec3(0.0);\n\n\t// Water specular power\n\tfloat waterSpecularPower = 0.0;\n\n\t// Water specular intensity\n\tfloat waterSpecularIntensity = 0.0;\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection2 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection3 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection4 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection5 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection6 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection7 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection8 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection9 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection10 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection11 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection12 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection13 = vec3(0.0);\n\n\t// Water specular direction\n\tvec3 waterSpecularDirection14", "\n    vec3 ray = vec3(uv, 1.0);\n    ray.x *= 2.0 * tan(fov * 0.5);\n    ray.y *= 2.0 * tan(fov * 0.5);\n    ray.x += eye.x;\n    ray.y += eye.y;\n    ray.z += eye.z;\n    ray = normalize(ray);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 eye)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.x *= 2.0 * tan(fov * 0.5);\n    ray.y *= 2.0 * tan(fov * 0.5);\n    ray.x += eye.x;\n    ray.y += eye.y;\n    ray.z += eye.z;\n    ray = normalize(ray);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 eye, float fov)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.x *= 2.0 * tan(fov * 0.5);\n    ray.y *= 2.0 * tan(fov * 0.5);\n    ray.x += eye.x;\n    ray.y += eye.y;\n    ray.z += eye.z;\n    ray = normalize(ray);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 eye, float fov, vec3 up)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.x *= 2.0 * tan(fov * 0.5);\n    ray.y *= 2.0 * tan(fov * 0.5);\n    ray.x += eye.x;\n    ray.y += eye.y;\n    ray.z += eye.z;\n    ray = normalize(ray);\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec3 eye, float f", "\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(vec4 q, vec4 v)\n{\n    return vec4(quatmul(q, v.xyz), v.w);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Quaternion conjugate\nvec4 quatconj(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// Quaternion inverse\nvec4 quatinv(vec4 q)\n{\n    return quatconj(q) / dot(q, q);\n}\n\n// Quaternion exponential\nvec4 quatexp(vec4 q)\n{\n    float theta = length(q.xyz);\n    float s = sin(theta);\n    return vec4(\n        q.xyz * s / theta,\n        cos(theta)\n    );\n}\n\n// Quaternion logarithm\nvec4 quatlog(vec4 q)\n{\n    float theta = acos(q.w);\n    float s = sin(theta);\n    return vec4(\n        q.xyz * theta / s,\n        log(s)\n    );\n}\n\n// Quaternion power\nvec4 quatpow(vec4 q, float t)\n{\n    return quatexp(quatlog(q) * t);\n}\n\n// Quaternion slerp\nvec4 quatslerp(vec4 q1, vec4 q2, float t)\n{\n    float cosTheta = dot(q1, q2);\n    vec4 q3;\n    if (cosTheta < 0.0)\n    {\n        q3 = -q2;\n        cosTheta = -cosTheta;\n    }\n    else\n    {\n        q3 = q2;\n    }\n    if (cosTheta > 0.9995)\n    {\n        return (1.0 - t) * q1 + t * q3;", "\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdSphere( in vec3 p, in float s, in float r )\n{\n    return length(p)-s-r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c, in float r )\n{\n    return length(p.xz-c.xy)-c.z-r;\n}\n\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return sdLine( p, a, b ) - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float h )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float y = length( pa - ba*h );\n    float x = abs( pa.x - ba.x*h );\n    float d = max( abs(y-h*w), x );\n    return d;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float h, in float r )\n{\n    return sdLine( p, a, b, w, h ) - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float h, in float r, in float m )\n{\n    float d = sdLine( p, a, b, w, h, r );\n    return max( d, -sdLine( p, a, b, w, h, r+m ) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float h, in float r, in float m, in float n )\n{\n    float d = sdLine( p, a, b, w, h, r, m );\n    return max( d, -sdLine( p, a, b, w, h, r+m, m, n ) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float w, in float h, in float r, in float m, in float n, in float o )\n{\n    float d = sdLine( p", "\n    return m.x < d? m : vec2( d, a );\n}\n\nvec2 opUnion( vec2 m1, vec2 m2 )\n{\n    return m1.x < m2.x? m1 : m2;\n}\n\nvec2 opSubtraction( vec2 m1, vec2 m2 )\n{\n    return m1.x < m2.x? m1 : m2;\n}\n\nvec2 opIntersection( vec2 m1, vec2 m2 )\n{\n    return m1.x < m2.x? m2 : m1;\n}\n\nvec2 opSmoothUnion( vec2 m1, vec2 m2, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( m2.x - m1.x ) / k, 0.0, 1.0 );\n    return vec2( mix( m1.x, m2.x, h ) - k * h * ( 1.0 - h ), mix( m1.y, m2.y, h ) );\n}\n\nvec2 opSmoothSubtraction( vec2 m1, vec2 m2, float k )\n{\n    float h = clamp( 0.5 - 0.5 * ( m2.x - m1.x ) / k, 0.0, 1.0 );\n    return vec2( mix( m1.x, m2.x, h ) + k * h * ( 1.0 - h ), mix( m1.y, m2.y, h ) );\n}\n\nvec2 opSmoothIntersection( vec2 m1, vec2 m2, float k )\n{\n    float h = clamp( 0.5 - 0.5 * ( m2.x - m1.x ) / k, 0.0, 1.0 );\n    return vec2( mix( m1.x, m2.x, h ) + k * h * ( 1.0 - h ), mix( m1.y, m2.y, h ) );\n}\n\nvec2 opDisplace( vec2 m, float d, float a )\n{\n    return m.x < d? vec2( d, a ) : m;", "\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ro );\n    float c = dot( ro, ro ) - rad * rad;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 ) return;\n    h = sqrt( h );\n    float t1 = ( -b - h ) / ( 2.0 * a );\n    float t2 = ( -b + h ) / ( 2.0 * a );\n    p1 = vec4( ro + rd * t1, t1 );\n    p2 = vec4( ro + rd * t2, t2 );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCapsule( in vec2 ro, in vec2 rd, float rad, float len, out vec4 p1, out vec4 p2 )\n{\n    vec2 pa = ro - vec2( 0.0, len * 0.5 );\n    vec2 pb = ro + vec2( 0.0, len * 0.5 );\n    vec2 ba = pb - pa;\n    vec2 oc = ro - pa;\n    float baba = dot( ba, ba );\n    float papa = dot( pa, pa );\n    float poca = dot( oc, ba );\n    float h = clamp( poca * poca / baba - papa, 0.0, len );\n    float t = clamp( - poca - h, 0.0, len );\n    vec2 pt = pa + ba * t;\n    vec2 qa = pt - pa;\n    vec2 qb = pt - pb;\n    float qqa = dot( qa, qa );\n    float qqb = dot( qb, qb );\n    float qab = dot( qa, qb );\n    float t1 = clamp( ( - qab + sqrt( qqa * qqb - qab * qab ) ) / ( qqa - qqb ), 0.0, len );\n    float t2 = clamp( ( - qab - sqrt( qqa * qqb - qab * qab ) ) / ( qqa - qqb ), 0.0, len );\n    p1 = vec4( pa + ba * t1", "\n    vec2 q = p - c;\n    float d = length(q);\n    return vec3( d - r, q / d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,d.y),0.0), d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r )\n{\n    vec3 h = sdgBox( p, b );\n    return vec3( h.x - r, h.yz );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float e )\n{\n    vec3 h = sdgBox( p, b, r );\n    vec3 q = vec3( smoothstep( -e, e, h.x ) );\n    return vec3( mix( h.x, q.x, q.y*q.z*(3.0-2.0*q.y) ), h.yz );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float e, in float i )\n{\n    vec3 h = sdgBox( p, b, r, e );\n    vec3 q = vec3( smoothstep( -i, i, h.x ) );\n    return vec3( mix( h.x, q.x, q.y*q.z*(3.0-2.0*q.y) ), h.yz );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r, in float e, in float i, in float o )\n{\n    vec3 h = sdgBox( p, b, r, e, i );\n    vec3 q = vec3( smoothstep( -o, o, h.x ) );\n    return vec3( mix( h.x, q.x, q.y*q.z*(3.0-2.0*q.y) ), h.yz );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b, in float r,", "\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)), d.x, d.y);\n}\n\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    return vec3(length(p)-r, p.x, p.y);\n}\n\nvec3 sdgTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p)-t.x,p.y);\n    return vec3(length(q)-t.y, q.x, p.y);\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 c )\n{\n    vec2 d = abs(vec2(length(p.x),p.y)) - c;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)), d.x, d.y);\n}\n\nvec3 sdgCone( in vec2 p, in vec3 c )\n{\n    // c must be normalized\n    vec2 q = vec2(length(p.x),p.y);\n    float d1 = -q.y-c.z;\n    float d2 = max(dot(q,c.xy),q.y);\n    return vec3(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0), d1, d2);\n}\n\nvec3 sdgPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return vec3(dot(p,n.xyz)-n.w, p.x, p.y);\n}\n\nvec3 sdgUnion( in vec3 d1, in vec3 d2 )\n{\n    return (d1.x<d2.x)? d1 : d2;\n}\n\nvec3 sdgSub( in vec3 d1, in vec3 d2 )\n{\n    return (d1.x>d2.x)? d1 : d2;\n}\n\nvec", "\n    p.x *= 1.5;\n    p.y *= 1.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p.y += 0.5;\n    p.x *= 2.0;\n    p.y *= 2.0;\n    p.x -= 1.0;\n    p.y -= 1.0;\n    p.x *= 0.5;\n    p.y *= 0.5;\n    p.x += 0.5;\n    p", "\n    float y = 0;\n    if (x < a1) {\n        y = 0;\n    } else if (x < a2) {\n        y = (x - a1) / (a2 - a1) * (b2 - b1) + b1;\n    } else {\n        y = 1;\n    }\n    return y;\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat h(float a1, float b1, float a2, float b2, float x) {\n    float y = 0;\n    if (x < a1) {\n        y = 0;\n    } else if (x < a2) {\n        y = (x - a1) / (a2 - a1) * (b2 - b1) + b1;\n    } else {\n        y = 1;\n    }\n    return y;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat i(float a1, float b1, float a2, float b2, float x) {\n    float y = 0;\n    if (x < a1) {\n        y = 0;\n    } else if (x < a2) {\n        y = (x - a1) / (a2 - a1) * (b2 - b1) + b1;\n    } else {\n        y = 1;\n    }\n    return y;\n}\n\n// Instant push -> wobble (alpha)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat j(float a1, float b1, float a2, float b2, float x) {\n    float y = 0;\n    if (x < a1) {\n        y = 0;\n    } else if (x < a2) {\n        y = (x - a1) / (a2 - a1) * (b2 - b1) + b1;\n    } else {\n        y = 1;\n    }\n    return y;\n}\n\n// Instant push -> wobble (red)\n// https://www.desmos", "\n    return pow(abs(pow(abs(x), n) + a), 1.0 / n) - b;\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(abs(pow(abs(x), n) + a), 1.0 / n) - b;\n}\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(abs(pow(abs(x), n) + a), 1.0 / n) - b;\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(abs(pow(abs(x), n) + a), 1.0 / n) - b;\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(", "\n                vec2 p = floor(uv);\n                vec2 f = fract(uv);\n                f = f*f*(3.0-2.0*f);\n                float res = mix(mix(dot(hash22(p+vec2(0.0,0.0)),f-vec2(0.0,0.0)),\n                                    dot(hash22(p+vec2(1.0,0.0)),f-vec2(1.0,0.0)),f.x),\n                                mix(dot(hash22(p+vec2(0.0,1.0)),f-vec2(0.0,1.0)),\n                                    dot(hash22(p+vec2(1.0,1.0)),f-vec2(1.0,1.0)),f.x),f.y);\n                return res;\n            }\n\n            void main(){\n                vec2 uv = gl_FragCoord.xy / resolution.xy;\n                vec2 uv2 = uv * 2.0;\n                vec2 uv3 = uv * 3.0;\n                vec2 uv4 = uv * 4.0;\n                vec2 uv5 = uv * 5.0;\n                vec2 uv6 = uv * 6.0;\n                vec2 uv7 = uv * 7.0;\n                vec2 uv8 = uv * 8.0;\n                vec2 uv9 = uv * 9.0;\n                vec2 uv10 = uv * 10.0;\n                vec2 uv11 = uv * 11.0;\n                vec2 uv12 = uv * 12.0;\n                vec2 uv13 = uv * 13.0;\n                vec2 uv14 = uv * 14.0;\n                vec2 uv15 = uv * 15.0;\n                vec2 uv16 = uv * 16.0;\n                vec2 uv17 = uv * 17.0;\n                vec2 uv18 = uv * 18.0;\n                vec2 uv19 = uv * 19.0;\n                vec2 uv20 = uv * 20.0;\n                vec2 uv21 = uv * 21.0;\n                vec2 uv22 = uv * 22.", "\n    vec3 sum = vec3( 0.0 );\n    for( int i = 0; i < 14; i++ )\n    {\n        sum += texture2D( u_texture, vec2( x + i, y ) ).rgb;\n    }\n    return sum;\n}\n\nvoid main()\n{\n    vec3 sum = compute( int( v_texcoord.x ), int( v_texcoord.y ) );\n    gl_FragColor = vec4( sum, 1.0 );\n}\n", "\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x*r.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in float b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in float b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdBox( in vec2 p, in float b, in float r, in float r2 )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2;\n}\n\nfloat sdBox( in vec2 p, in float b, in float r, in float r2, in float r3 )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2 - r3;\n}\n\nfloat sdBox( in vec2 p, in float b, in float r, in float r2, in float r3, in float r4 )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - r2 - r3", "\n  vec2 q = abs(p) - c;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - b.x*b.y;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in float b ) \n{\n  vec2 d = abs(p) - vec2(b);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in float b ) \n{\n  vec2 d = abs(p) - vec2(b);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in float b ) \n{\n  vec2 d = abs(p) - vec2(b);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in float b ) \n{\n  vec2 d = abs(p) - vec2(b);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in float b ) \n{\n  vec2 d = abs(p) - vec2(b);\n ", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return pa - ba*h;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out float t )\n{\n    vec2 pa = p - a, ba = b - a;\n    t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*t );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 q )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    q = a + ba*h;\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 q, out float t )\n{\n    vec2 pa = p - a, ba = b - a;\n    t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    q = a + ba*t;\n    return length( pa - ba*t );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, out vec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h*h;\n    float h2pa = dot(pa,pa) - h2;\n    float h2ba = dot(ba,ba) - h2;\n    float h2ba_pa = dot(ba,pa) - h2;\n    float h2ba_pa2 = h2ba_pa*h2ba_pa;\n    float h2ba_pa2_h2ba = h2ba_pa2 - h2ba;\n    float h2ba_pa2_h2ba_h2pa = h2ba_pa2_h2ba + h2pa;\n    float h2ba_pa2_h2ba_h2pa_h2ba = h2ba_pa2_h2ba_h2pa + h2ba;\n    float h2ba_pa2_h2ba_h2pa_h2ba_h2ba = h2ba_pa2_h2ba_h2pa_h2ba + h2ba;\n    float h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba = h2ba_pa2_h2ba_h2pa_h2ba_h2ba + h2ba;\n    float h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba_h2ba = h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba + h2ba;\n    float h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba_h2ba_h2ba = h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba_h2ba + h2ba;\n    float h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba_h2ba_h2ba_h2ba = h2ba_pa2_h2ba_h2pa_h2ba_h2ba_h2ba_h2ba_h2ba + h2", "\n    float d = 0.0;\n    float s = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float t = 0.0;\n    float r = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0", "\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdG( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdH( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdI( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdJ( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdK( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdL( in vec2 p )\n{\n    return sdBox( p, vec2(0.25,0.25) );\n}\n\n// correct inside, incorrect outside\nfloat sdM( in vec2", "\n    float d = sdA(p);\n    d = abs(d) - 0.2;\n    d = max(d, -sdA(p+vec2(0.2,0.0)));\n    d = max(d, -sdA(p+vec2(-0.2,0.0)));\n    d = max(d, -sdA(p+vec2(0.0,0.2)));\n    d = max(d, -sdA(p+vec2(0.0,-0.2)));\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\n    float d = sdA(p);\n    d = abs(d) - 0.2;\n    d = max(d, -sdA(p+vec2(0.2,0.0)));\n    d = max(d, -sdA(p+vec2(-0.2,0.0)));\n    d = max(d, -sdA(p+vec2(0.0,0.2)));\n    d = max(d, -sdA(p+vec2(0.0,-0.2)));\n    d = max(d, -sdA(p+vec2(0.2,0.2)));\n    d = max(d, -sdA(p+vec2(-0.2,0.2)));\n    d = max(d, -sdA(p+vec2(0.2,-0.2)));\n    d = max(d, -sdA(p+vec2(-0.2,-0.2)));\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\n    float d = sdA(p);\n    d = abs(d) - 0.2;\n    d = max(d, -sdA(p+vec2(0.2,0.0)));\n    d = max(d, -sdA(p+vec2(-0.2,0.0)));\n    d = max(d, -sdA(p+vec2(0.0,0.2)));\n    d = max(d, -sdA(p+vec2(0.0,-0.2)));\n    d = max(d, -sdA", "\n    vec3 c = vec3( 0.0 );\n    float s = sin( 2.0*PI*uv.x );\n    float c = cos( 2.0*PI*uv.y );\n    vec2 q = vec2( fbm4( uv + 0.00*s + 0.00*c ), fbm4( uv + 4.00*s + 2.00*c ) );\n    c.x = fbm4( uv + 4.00*q + 4.00*s + 1.00*c );\n    c.y = fbm4( uv + 2.00*q + 1.00*s + 2.00*c );\n    c.z = fbm4( uv + 4.00*q + 8.00*s + 4.00*c );\n    c = mix( c, vec3( 0.507, 0.507, 0.507 ), 0.5 );\n    return c;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern2( in vec2 uv )\n{\n    vec3 c = vec3( 0.0 );\n    float s = sin( 2.0*PI*uv.x );\n    float c = cos( 2.0*PI*uv.y );\n    vec2 q = vec2( fbm4( uv + 0.00*s + 0.00*c ), fbm4( uv + 4.00*s + 2.00*c ) );\n    c.x = fbm4( uv + 4.00*q + 4.00*s + 1.00*c );\n    c.y = fbm4( uv + 2.00*q + 1.00*s + 2.00*c );\n    c.z = fbm4( uv + 4.00*q + 8.00*s + 4.00*c );\n    c = mix( c, vec3( 0.507, 0.507, 0.50", "\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on ray\nvec2 cloRay( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r, in float th )\n{\n    vec2 pc = p-c;\n    float d = length(pc);\n    float h = clamp( d/r, 0.0, 1.0 );\n    return c + pc*h;\n}\n\n// Closest point on ellipse\nvec2 cloEllipse( in vec2 p, in vec2 c, in vec2 r, in float th )\n{\n    vec2 pc = p-c;\n    float d = length(pc);\n    float h = clamp( d/r, 0.0, 1.0 );\n    return c + pc*h;\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 c, in vec2 r, in float th )\n{\n    vec2 pc = p-c;\n    vec2 h = clamp( abs(pc)/r, 0.0, 1.0 );\n    return c + pc*h;\n}\n\n// Closest point on rounded rectangle\nvec2 cloRoundRect( in vec2 p, in vec2 c, in vec2 r, in float", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float w )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r - w;\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float w, in float m )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r - w - m;\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float w, in float m, in float n )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r - w - m - n;\n}\n\n// distance to rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float w, in float m, in float n, in float o )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r - w -", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// closest point on rounded box\nfloat cloRoundBox( in vec3 p, in vec3 b, float r )\n{\n    return cloRoundBox(p.xy, b.xy, r) + abs(p.z) - b.z;\n}\n\n// closest point on rounded box\nfloat cloRoundBox( in vec4 p, in vec4 b, float r )\n{\n    return cloRoundBox(p.xyz, b.xyz, r) + p.w - b.w;\n}\n\n// closest point on rounded box\nfloat cloRoundBox( in vec3 p, in vec3 b, float r, out vec3 q )\n{\n    q = p;\n    float d = cloRoundBox(p, b, r);\n    if( d < 0.0 ) return d;\n    q.xy = p.xy - b.xy;\n    q.xy = q.xy * sign(p.xy);\n    q.xy = q.xy + b.xy;\n    q.z = p.z - b.z;\n    return d;\n}\n\n// closest point on rounded box\nfloat cloRoundBox( in vec4 p, in vec4 b, float r, out vec4 q )\n{\n    q = p;\n    float d = cloRoundBox(p, b, r);\n    if( d < 0.0 ) return d;\n    q.xyz = p.xyz - b.xyz;\n    q.xyz = q.xyz * sign(p.xyz);\n    q.xyz = q.xyz + b.xyz;\n    q.w = p.w - b.w;\n    return d;\n}\n\n// closest point on rounded box\nfloat cloRoundBox( in vec3 p, in vec3 b, float r, out vec3 q, out vec3 n )\n{\n    q = p;\n    float d = cloRoundBox(p, b, r);\n    if( d < 0.0 ) return d;\n    q.xy = p.xy - b.xy;\n    q.xy = q.xy * sign(p.xy);\n   ", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\n  vec4 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(r.x,r.y);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - max(r.x,max(r.y,r.z));\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n  vec4 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0) - max(r.x,max(r.y,max(r.z,r.w)));\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p,", "\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n  vec3 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r;\n}\n\n// distance to capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n  return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to cone\nfloat sdCone( in vec3 p, in vec3 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  float d1 = -q.y-c.z;\n  float d2 = max( dot(q,c.xy), q.y);\n  return length(max(vec2", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12s(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z) * 2. - 1.;\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13s(vec3 p3){\n\tp3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z) * 2. - 1.;\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){\n\tvec3 p3 = fr", "\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x.xyz, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x.xyzw, vec4(12.9898, 78.233, 45.5432, 98.7234))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(uint x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(bool x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(bvec2 x)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(bvec3 x)\n{\n    return fract(sin(dot(x.xyz, vec3(12.9", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random2(i);\n    float b = random2(i + vec2(1.0, 0.0));\n    float c = random2(i + vec2(0.0, 1.0));\n    float d = random2(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// From iq\nfloat fbm(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float frequency = 0.;\n\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *=.5;\n    }\n    return value;\n}\n\n// From iq\nfloat fbm(vec2 st, float scale) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float frequency = 0.;\n\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= scale;\n        amplitude *=.5;\n    }\n    return value;\n}\n\n// From iq\n", "\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(rand(i + vec2(0.0, 0.0)), rand(i + vec2(1.0, 0.0)), u.x), mix(rand(i + vec2(0.0, 1.0)), rand(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// 3D value noise\nfloat valueNoise(vec3 x)\n{\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(rand(i + vec3(0.0, 0.0, 0.0)), rand(i + vec3(1.0, 0.0, 0.0)), u.x), mix(rand(i + vec3(0.0, 1.0, 0.0)), rand(i + vec3(1.0, 1.0, 0.0)), u.x), u.y), mix(mix(rand(i + vec3(0.0, 0.0, 1.0)), rand(i + vec3(1.0, 0.0, 1.0)), u.x), mix(rand(i + vec3(0.0, 1.0, 1.0)), rand(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\n// 3D value noise\nfloat valueNoise(vec3 x, float scale)\n{\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(rand(i + vec3(0.0, 0.0, 0.0), scale), rand(i + vec3(1", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < OCTAVES; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 2D Fractional Brownian Motion, used for turbulence\nfloat fbm(vec2 p)\n{\n    float freq = 1.0;\n    float amp = 0.5;\n    float noiseVal = 0.0;\n    for (int i = 0; i < OCTAVES; ++i)\n    {\n        noiseVal += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return noiseVal;\n}\n\n// 3D Fractional Brownian Motion, used for turbulence\nfloat fbm(vec3 p)\n{\n    float freq = 1.0;\n    float amp = 0.5;\n    float noiseVal = 0.0;\n    for (int i = 0; i < OCTAVES; ++i)\n    {\n        noiseVal += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return noiseVal;\n}\n\n// 4D Fractional Brownian Motion, used for turbulence\nfloat fbm(vec4 p)\n{\n    float freq = 1.0;\n    float amp = 0.5;\n    float noiseVal = 0.0;\n    for (int i = 0; i < OCTAVES; ++i)\n    {\n        noiseVal += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return noiseVal;\n}\n\n// 2D turbulence function\nfloat turbulence(vec2 p)\n{\n    float w = 100.0;\n    float t = -.5;\n    for (float", "\n    float s = sin(12.9898 * x.x + 78.233 * x.y);\n    float c = cos(12.9898 * x.x + 78.233 * x.y);\n\n    vec2 uv = vec2(s, c) * 0.5 + 0.5;\n    uv = fract(uv);\n    uv *= 10.0;\n\n    float v = 0.0;\n\n    for (int i = 0; i < 3; ++i)\n    {\n        vec2 gv = fract(uv);\n        v += gv.x * gv.y * (3.0 - 2.0 * gv.x - 2.0 * gv.y);\n        uv = floor(uv) * 0.125 + 0.625;\n    }\n\n    return v;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = iTime * 0.5;\n\n    float v = pattern(uv * 4.0 + time);\n    v = pow(v, 1.0 / 3.0);\n\n    vec3 color = vec3(v);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return 4.0 * atan(x * y / (sqrt(x * x + y * y + 1.0) + sqrt(x * x + y * y - 1.0)));\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    return areaElement(x, y) / (4.0 * M_PI);\n}\n\nvec3 texelDirection(float x, float y)\n{\n    float phi = 2.0 * M_PI * x;\n    float theta = M_PI * y;\n    float sinTheta = sin(theta);\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nvec3 texelDirection(vec2 uv)\n{\n    return texelDirection(uv.x, uv.y);\n}\n\nvec3 texelDirection(vec3 uv)\n{\n    return texelDirection(uv.x, uv.y);\n}\n\nvec3 texelDirection(vec4 uv)\n{\n    return texelDirection(uv.x, uv.y);\n}\n\nvec3 texelDirection(ivec2 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(ivec3 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(ivec4 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(uvec2 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(uvec3 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(uvec4 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(bvec2 uv)\n{\n    return texelDirection(float(uv.x), float(uv.y));\n}\n\nvec3 texelDirection(bvec3 uv)\n{\n    return texelDirection(float", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p, float lacunarity, float gain) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= lacunarity;\n    f += 0.2500 * noise(p); p *= lacunarity;\n    f += 0.1250 * noise(p); p *= lacunarity;\n    f += 0.0625 * noise(p);\n    return", "\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, vec3(1.0, 1.0, 1.0)), dot(d1, vec3(1.0, 1.0, 1.0)), dot(d2, vec3(1.0, 1.0, 1.0)), dot(d3, vec3(1.0, 1.0, 1.0)));\n\n    return dot(vec4(31.316, 31.316, 31.316, 31.316), n);\n}\n\nfloat simplex3d(vec3 p, float scale) {\n    return simplex3d(p * scale) / scale;\n}\n\nfloat simplex3d(vec3 p, float scale, float offset) {\n    return simplex3d(p * scale + offset) / scale;\n}\n\nfloat simplex3d(vec3 p, float scale, float offset, float frequency) {\n    return simplex", "\n    vec3 p = vec3(x.xy,1.0);\n    p = fract(sin(p*133.3333)*13.1313);\n    return fract(p.xy);\n}\n\n// 2D Noise based on <NAME> @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y)? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\n// 2D Fractal Brownian Motion\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p =", "\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// 2D box\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// 2D triangle\nfloat sdTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ba = b - a;\n  vec2 pa = p - a;\n  vec2 cb = c - b;\n  vec2 pb = p - b;\n  vec2 ac = a - c;\n  vec2 pc = p - c;\n  vec2 nor = vec2(\n    -ba.y * cb.x + ba.x * cb.y,\n    ba.y * ac.x - ba.x * ac.y );\n\n  return length(cross(ba,nor)) * sign(\n    pa.x*cb.y - pa.y*cb.x +\n    pb.x*ac.y - pb.y*ac.x +\n    pc.x*ba.y - pc.y*ba.x );\n}\n\n// 2D circle\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n// 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n  return length(p/ab) - 1.0;\n}\n\n// 2D rounded box\nfloat sdRoundBox( vec2 p, vec2 b, float r )\n{\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// 2D rounded triangle\nfloat sdRoundTriangle( vec2 p, vec2 a, vec2 b, vec2 c, float r )\n{\n  vec2 ba = b - a;\n  vec2 pa = p - a;", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x*r.y;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r.x*r.y*r.z;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    vec4 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0) - r.x*r.y*r.z*r.w;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0);\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.", "\n    // Project the disk onto the plane perpendicular to the normal.\n    // This is a circle.\n    vec2 proj_center_2d = center.xy - proj_info.xy * normal.xy;\n    float proj_radius = radius * proj_info.z;\n    float proj_radius_sq = proj_radius * proj_radius;\n\n    // Project the disk onto the plane parallel to the normal.\n    // This is an ellipse.\n    vec2 proj_center_2d_sq = proj_center_2d * proj_center_2d;\n    float proj_center_2d_sq_sum = proj_center_2d_sq.x + proj_center_2d_sq.y;\n    float proj_center_2d_sq_diff = proj_center_2d_sq.x - proj_center_2d_sq.y;\n    float proj_center_2d_sq_sum_sq = proj_center_2d_sq_sum * proj_center_2d_sq_sum;\n    float proj_center_2d_sq_diff_sq = proj_center_2d_sq_diff * proj_center_2d_sq_diff;\n    float proj_center_2d_sq_sum_diff = proj_center_2d_sq_sum - proj_center_2d_sq_diff;\n    float proj_center_2d_sq_sum_diff_sq = proj_center_2d_sq_sum_diff * proj_center_2d_sq_sum_diff;\n    float proj_center_2d_sq_sum_diff_sq_sq = proj_center_2d_sq_sum_diff_sq * proj_center_2d_sq_sum_diff_sq;\n    float proj_center_2d_sq_sum_diff_sq_sq_sq = proj_center_2d_sq_sum_diff_sq_sq * proj_center_2d_sq_sum_diff_sq_sq;\n    float proj_center_2d_sq_sum_diff_sq_sq_sq_sq = proj_center_2d_sq_sum_diff_sq_sq_sq * proj_center_2d_sq_sum_diff_sq_sq_sq;", "\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash13(vec3 p3)\n{\n\tp3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash21(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash23(vec3 p3)\n{\n\tp3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash31(vec3 p)\n{\n\tvec3 p3 = fract(vec3(p.xyz) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash33(vec3 p3)\n{\n\tp3 = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash41(vec4 p)\n{\n\tvec3 p3 = fract(vec3(p.xyz) *.1031);\n    p3 += dot(p3, p3.", "\n    float a = an * 0.5;\n    float b = bn * 0.5;\n    float c = 1.0 - a - b;\n    float s = sin(a);\n    float csc = 1.0 / sin(c);\n    float cotb = cos(b) / sin(b);\n    float cota = cos(a) / sin(a);\n    float cotc = cos(c) / sin(c);\n    float cotm = cos(m * 0.5) / sin(m * 0.5);\n    float cot = cota * cotb * cotc * cotm;\n    float cs = csc * cot;\n    float sn = s * cot;\n    float ca = cota * cotb * cotc;\n    float cb = csc * cotb * cotc;\n    float cc = csc * cota * cotc;\n    float cd = csc * cota * cotb;\n    float ce = csc * cota;\n    float cf = csc * cotb;\n    float cg = csc * cotc;\n    float ch = csc;\n    float ci = s;\n    float cj = cota;\n    float ck = cotb;\n    float cl = cotc;\n    float cm = cotm;\n    float cn = cot;\n    float x = p.x - acs.x;\n    float y = p.y - acs.y;\n    float d = 0.0;\n    d = max(d, abs(x * cn + y * sn) - r);\n    d = max(d, abs(x * cs - y * sn) - r);\n    d = max(d, abs(x * ca + y * cb) - r);\n    d = max(d, abs(x * cc - y * cb) - r);\n    d = max(d, abs(x * cd + y * cc) - r);\n    d = max(d, abs(x * ce - y * cc) - r);\n    d = max(d, abs(x * cf + y * cd) - r);\n    d = max(d, abs(x * cg - y * cd) - r);\n    d = max(d, abs(x", "\n    vec3 e = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        dist( p + e.xyy ) - dist( p - e.xyy ),\n        dist( p + e.yxy ) - dist( p - e.yxy ),\n        dist( p + e.yyx ) - dist( p - e.yyx )\n    );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal( vec3 p, float d )\n{\n    vec3 e = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        dist( p + e.xyy ) - d,\n        dist( p + e.yxy ) - d,\n        dist( p + e.yyx ) - d\n    );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal( vec3 p, float d, float e )\n{\n    vec3 n = vec3(\n        dist( p + vec3( e, 0.0, 0.0 ) ) - d,\n        dist( p + vec3( 0.0, e, 0.0 ) ) - d,\n        dist( p + vec3( 0.0, 0.0, e ) ) - d\n    );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal( vec3 p, float d, float e, float f )\n{\n    vec3 n = vec3(\n        dist( p + vec3( e, 0.0, 0.0 ) ) - d,\n        dist( p + vec3( 0.0, e, 0.0 ) ) - d,\n        dist( p + vec3( 0.0, 0.0, e ) ) - d\n    );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal( vec3 p, float d, float e, float f, float g )\n{\n    vec", "\n    float res = 1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        float t = (t0 + t1) * 0.5;\n        vec3 p = ro + rd * t;\n        float h = map(p);\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, 10.0 * h / t);\n        t0 = t;\n    }\n    return res;\n}\n\n// Calculates the color of the scene\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0);\n\n    // Calculate the distance to the surface\n    float t = raymarch(ro, rd);\n\n    // If the ray didn't hit anything, return the background color\n    if (t == INFINITY)\n        return vec3(0.0);\n\n    // Calculate the normal at the hit point\n    vec3 p = ro + rd * t;\n    vec3 n = calcNormal(p);\n\n    // Calculate the color of the surface\n    col = vec3(0.5 + 0.5 * sin(p.xzy * 0.1 + iTime));\n\n    // Calculate the color of the light\n    vec3 ld = normalize(vec3(-1.0, 0.5, 1.0));\n    float diff = max(0.0, dot(n, ld));\n    float spec = 0.0;\n    if (diff > 0.0)\n    {\n        vec3 h = normalize(ld + rd);\n        spec = pow(max(0.0, dot(n, h)), 32.0);\n    }\n    col *= 0.2 + 0.8 * diff + 0.2 * spec;\n\n    // Calculate the shadow\n    float s = shadow(ro, ld, 0.02, t);\n    col *= 1.0 - 0.5 * s;\n\n    return col;\n}\n\n// Calculates the color of the scene\nvec3 render(vec2 uv)\n{\n    // Calculate the ray direction\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Render the scene", "\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nvec3 render( in vec3", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    float tx = t * x;\n    float ty = t * y;\n    float tz = t * z;\n    float sx = s * x;\n    float sy = s * y;\n    float sz = s * z;\n    return mat3(\n        tx * x + c, tx * y - sz, tx * z + sy,\n        tx * y + sz, ty * y + c, ty * z - sx,\n        tx * z - sy, ty * z + sx, tz * z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat4 createRotationMatrixX4(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    return ray;\n}\n\n// Helper function that returns the color of a ray\nvec3 rayColor(vec3 ray) {\n    // Implementation of rayColor function\n    //...\n}\n\n// Main function that renders the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ray = getRay(fragCoord);\n    vec3 color = rayColor(ray);\n    fragColor = vec4(color, 1.0);\n}\n```\nThis solution provides the implementation of the ray tracing algorithm using GLSL. It includes the necessary functions for generating camera rays, calculating ray color, and rendering the scene. The main function `mainImage` takes the fragment coordinates and outputs the final color of the ray.", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 123.456))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4dTime(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233, 123.456, 1234.567))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 123.456))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233, 123.456, 1234.567))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co, float seed){\n    return fract(sin(dot(co.xy,vec2(seed, seed))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co, float seed){\n    return fract(sin(dot(co.xyz,vec3(", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 45.5432, 12.345))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p){\n    return fract(sin(p.x * 12.9898) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p){\n    return fract(sin(p.x * 12.9898) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec4 p){\n    return fract(sin(p.x * 12.9898) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec2 p, float t){\n    return fract(sin(p.x * 12.9898 + t) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec3 p, float t){\n    return fract(sin(p.x * 12.9898", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 4D value noise\nfloat noise4d(vec4 x){\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D value noise\nfloat noise2d(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 1D value noise\nfloat noise1d(float x){\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float uv = (p+ 17.0*p.z) + f;\n    float rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).x;\n    return mix(rg.x, rg.y, f.z);", "\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n    float n_ = 0.5 - dot(x, x);\n    vec3 ns = n_ * n_ * n_ * n_ * n_;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tvec3 s = vec3(1.0);\n\tfor(int i = 0; i < 8; i++){\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float scale){\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tvec3 s = vec3(1.0);\n\tfor(int i = 0; i < 8; i++){\n\t\tf += a * noise(p * scale);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float scale, float a){\n\tfloat f = 0.0;\n\tfloat a2 = a;\n\tvec3 s = vec3(1.0);\n\tfor(int i = 0; i < 8; i++){\n\t\tf += a2 * noise(p * scale);\n\t\tp *= 2.0;\n\t\ta2 *= 0.5;\n\t}\n\treturn f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float scale, float a, float b){\n\tfloat f = 0.0;\n\tfloat a2 = a;\n\tvec3 s = vec3(1.0);\n\tfor(int i = 0; i < 8; i++){\n\t\tf += a2 * noise(p * scale);\n\t\tp *= 2.0;\n\t\ta2 *= b;\n\t}\n\treturn f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float scale, float a, float b, float c){\n\tfloat f = 0.0;\n\tfloat a2 = a;\n\tvec3 s", "\n\tvec2 ret = vec2(0.0);\n\tfloat cloudDensity = 0.0;\n\tfloat cloudColor = 0.0;\n\tfloat cloudCoverage = 0.0;\n\tfloat cloudCoverage2 = 0.0;\n\tfloat cloudCoverage3 = 0.0;\n\tfloat cloudCoverage4 = 0.0;\n\tfloat cloudCoverage5 = 0.0;\n\tfloat cloudCoverage6 = 0.0;\n\tfloat cloudCoverage7 = 0.0;\n\tfloat cloudCoverage8 = 0.0;\n\tfloat cloudCoverage9 = 0.0;\n\tfloat cloudCoverage10 = 0.0;\n\tfloat cloudCoverage11 = 0.0;\n\tfloat cloudCoverage12 = 0.0;\n\tfloat cloudCoverage13 = 0.0;\n\tfloat cloudCoverage14 = 0.0;\n\tfloat cloudCoverage15 = 0.0;\n\tfloat cloudCoverage16 = 0.0;\n\tfloat cloudCoverage17 = 0.0;\n\tfloat cloudCoverage18 = 0.0;\n\tfloat cloudCoverage19 = 0.0;\n\tfloat cloudCoverage20 = 0.0;\n\tfloat cloudCoverage21 = 0.0;\n\tfloat cloudCoverage22 = 0.0;\n\tfloat cloudCoverage23 = 0.0;\n\tfloat cloudCoverage24 = 0.0;\n\tfloat cloudCoverage25 = 0.0;\n\tfloat cloudCoverage26 = 0.0;\n\tfloat cloudCoverage27 = 0.0;\n\tfloat cloudCoverage28 = 0.0;\n\tfloat cloudCoverage29 = 0.0;\n\tfloat cloudCoverage30 = 0.0;\n\tfloat cloudCoverage31 = 0.0;\n\tfloat cloudCoverage32 = 0.0;\n\tfloat cloudCoverage33 = 0.0;\n\tfloat cloudCoverage34 = 0.0;\n\tfloat cloudCoverage35 = 0.0;\n\tfloat cloudCoverage36 = 0.0;\n\tfloat cloudCoverage37 = 0.0;\n\tfloat cloudCoverage3", "\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float light = max(0.0, dot(normal, lightDir));\n    float coverage = 1.0 - smoothstep(0.0, 0.005, dist);\n    float shadow = 1.0 - smoothstep(0.0, 0.005, dist);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0) * coverage;\n    color += vec3(0.0, 0.0, 0.0) * shadow;\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - coverage) * (1.0 - shadow);\n    return color;\n}\n\n// render the clouds\n// this is done by sampling the clouds texture and applying a noise function to it\n// the noise function is a 3d simplex noise function, which is a bit expensive to compute\n// but it looks really good\n// the clouds are rendered as a 3d plane, which is then projected to the screen\n// the plane is rotated around the y axis to simulate the clouds moving\n// the plane is also scaled to simulate the clouds moving\n// the clouds are also colored by the height of the plane, so that the clouds are darker at the top\n// and lighter at the bottom\n// the clouds are also colored by the distance to the camera, so that the clouds are darker at the horizon\n// and lighter at the top\n// the clouds are also colored by the direction of the sun, so that the clouds are darker when the sun is behind the clouds\n// and lighter when the sun is in front of the clouds\n// the clouds are also colored by the direction of the sun, so that the clouds are darker when the sun is to the left of the clouds\n// and lighter when the sun is to the right of the clouds\n// the clouds are also colored by the direction of the sun, so that the clouds are darker when the sun is above the clouds\n// and lighter when the sun", "\n\tvec3 ray = pointEnd - pointStart;\n\tfloat rayLength = length(ray);\n\tfloat rayStep = rayLength / 100.0;\n\tfloat rayCurrent = 0.0;\n\tfloat rayStepSize = 0.0;\n\tfloat rayStepSize2 = 0.0;\n\tfloat rayStepSize3 = 0.0;\n\tfloat rayStepSize4 = 0.0;\n\tfloat rayStepSize5 = 0.0;\n\tfloat rayStepSize6 = 0.0;\n\tfloat rayStepSize7 = 0.0;\n\tfloat rayStepSize8 = 0.0;\n\tfloat rayStepSize9 = 0.0;\n\tfloat rayStepSize10 = 0.0;\n\tfloat rayStepSize11 = 0.0;\n\tfloat rayStepSize12 = 0.0;\n\tfloat rayStepSize13 = 0.0;\n\tfloat rayStepSize14 = 0.0;\n\tfloat rayStepSize15 = 0.0;\n\tfloat rayStepSize16 = 0.0;\n\tfloat rayStepSize17 = 0.0;\n\tfloat rayStepSize18 = 0.0;\n\tfloat rayStepSize19 = 0.0;\n\tfloat rayStepSize20 = 0.0;\n\tfloat rayStepSize21 = 0.0;\n\tfloat rayStepSize22 = 0.0;\n\tfloat rayStepSize23 = 0.0;\n\tfloat rayStepSize24 = 0.0;\n\tfloat rayStepSize25 = 0.0;\n\tfloat rayStepSize26 = 0.0;\n\tfloat rayStepSize27 = 0.0;\n\tfloat rayStepSize28 = 0.0;\n\tfloat rayStepSize29 = 0.0;\n\tfloat rayStepSize30 = 0.0;\n\tfloat rayStepSize31 = 0.0;\n\tfloat rayStepSize32 = 0.0;\n\tfloat rayStepSize33 = 0.0;\n\tfloat rayStepSize34 = 0", "\n    color *= 0.6;\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texcoord).rgb;\n    color = aces_tonemap(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    out_color = vec4(color, 1.0);\n}\n"]}