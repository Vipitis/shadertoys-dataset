{"input_both": ["\n\treturn max(0.0,cos(a)*2-1);\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    vec3 q = p;\n    q.xz = Rotate(q.xz, rotDir, rotSpeed);\n    q.y = Rotate(q.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 r = p;\n    r.xz = Rotate(r.xz, scaleDir, scaleSpeed);\n    r.y = Rotate(r.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 s = p;\n    s.xz = Rotate(s.xz, transDir, transSpeed);\n    s.y = Rotate(s.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 t = p;\n    t.xz = Rotate(t.xz, scaleDir, scaleSpeed);\n    t.y = Rotate(t.y, scaleDir, scaleSpeed);\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 u = p;\n    u.xz = Rotate(u.xz, rotDir, rotSpeed);\n    u.y = Rotate(u.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 v = p;\n    v.xz = Rotate(v.xz, scaleDir, scaleSpeed);\n    v.y = Rotate(v.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 w = p;\n    w.xz = Rotate(w.xz, transDir, transSpeed);\n    w.y = Rotate(w.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 x = p;\n    x.xz = Rotate(x.xz, scaleDir, scaleSpeed);\n    x.y =", "\n\tglowCounter += (1.0 - glowCounter) * (1.0 - glowCounter);\n\n\t// Get the voxel position\n\tvec3 voxelPos = floor(p);\n\n\t// Get the voxel size\n\tfloat voxelSize = voxelSizeF;\n\n\t// Get the voxel color\n\tvec4 voxelColor = texture(voxelTexture, voxelPos.xy / voxelSize);\n\n\t// Get the voxel distance\n\tfloat voxelDist = length(p - voxelPos);\n\n\t// Get the voxel glow\n\tfloat voxelGlow = glowCounter;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity = voxelColor.a;\n\n\t// Get the voxel distance\n\tfloat voxelDist2 = voxelDist * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow2 = voxelGlow * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity2 = voxelOpacity * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist3 = voxelDist2 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow3 = voxelGlow2 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity3 = voxelOpacity2 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist4 = voxelDist3 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow4 = voxelGlow3 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity4 = voxelOpacity3 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist5 = voxelDist4 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow5 = voxelGlow4 * voxelG", "\n\tglowCounter += 1.0;\n\n\t// Get the distance to the scene\n\tfloat d = scene(p);\n\n\t// Get the closest point on the scene\n\tP = vec3(p.x, p.y, d);\n\n\t// Return the distance to the scene\n\treturn vec2(d, glowCounter);\n}\n\n// Distance to the scene and color of the closest point\nvec", " position in the pixel\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the screen\n\tvec2 p_screen = (p * 2.0) - 1.0;\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n", "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\n\t// this is a bit of a hack to get the color gradient to work\n\t// the color values are in the range 0.0 to 1.0\n\t// the x value is in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to ", "\n\tvec4 c = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tc.rgb = pow(c.rgb, vec3(1.0/2.2));\n\t\n\t// apply brightness\n\tc.rgb *= vec3(0.5);\n\t\n\t// apply contrast\n\tc.rgb = (c.rgb - 0.5) * 2.0 + 0.5;\n\t\n\t// apply saturation\n\tc.rgb = mix(c.rgb, vec3(0.0), 0.5);\n\t\n\treturn c;\n}\n\n// main\nvoid main()\n{\n\t// get distance to surface\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\t// shade point\n\tvec4 c = shade(d);\n\t\n\t// write to framebuffer\n\tgl_FragColor = c;\n}\n", " and forth\n    float fade = clamp(0.5 + 0.5 * (1.0 + dot(rayDir, sunDir)), 0.0, 1.0);\n\n    // softbox\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        pos = vec3(0.0);\n        dist = 0.0;\n        for (int j = 0; j < 10; j++)\n        {\n            pos += vec3(0.0, 0.0, 0.0);\n            pos.x += scale;\n            pos.y += scale;\n            pos.z += scale;\n            dist += scale;\n            scale *= 0.5;\n        }\n        pos.x -= dist;\n        pos.y -= dist;\n        pos.z -= dist;\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n       ", "\n    float time = (coords.x - 2.0) / 2.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float time = (coords.x - 2.0) / 4.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float time = (coords.x - 1.0) / 3.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float t = p.z * 0.001;\n\n    // The first layer is just a simple noise function.\n    float n = noise(p);\n\n    // The second layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t)) * 0.5;\n\n    // The third layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 2.0)) * 0.25;\n\n    // The fourth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 4.0)) * 0.125;\n\n    // The fifth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 8.0)) * 0.0625;\n\n    // The sixth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 16.0)) * 0.03125;\n\n    // The seventh layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 32.0)) * 0.015625;\n\n    // The eighth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 64.0)) * 0.0078125;\n\n    // The ninth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 128.0)) * 0.00390625;\n\n    // The tenth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 256.0)) * 0.001953125;", "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things as nicely as the first way.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    // This is a simplex grid, with a 3x3x3 grid.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid", "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n    vec2 cell_center = (cell + cell_offset) * cell_size;\n\n    // The distance from the cell center to the point.\n    vec2 dist = abs(p - cell_center);\n\n    // The distance from the cell center to the point.\n    float dist_min = min(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_max = max(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_avg = (dist_min + dist_max) / 2.0;\n\n    // The distance from the cell center to the point.\n    float dist_max_avg = max(dist_max, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_avg = min(dist_min, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min = max(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_max = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_max = max(dist_max_avg, dist_max_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_min = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min_max = max(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point.\n    float dist_min_min_max = min(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point.", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "\n    vec2 res = vec2(0.0);\n\n    // find the closest object\n    float t = INF;\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < t)\n        {\n            t = d;\n            res = objects[i].position;\n        }\n    }\n\n    // move the object\n    if (t < INF)\n    {\n        p = res;\n    }\n\n    // find the closest point on the sphere\n    float d = distance(p, vec3(0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cylinder\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cone\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the torus\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere", "\n\tfloat t = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tmin = 0.001;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;\n\tfloat t43 = 0.0;\n\tfloat t", "\n    vec4 result = vec4(0.0);\n\n    // find the closest object\n    float t = findClosest(p);\n\n    // if there is an object, then we have a hit\n    if (t > 0.0)\n    {\n        // get the position of the object\n        vec3 q = p + t * rayDir;\n\n        // get the color of the object\n        vec3 color = getColor(q);\n\n        // get the normal of the object\n        vec3 normal = getNormal(q);\n\n        // get the specular color of the object\n        vec3 specular = getSpecular(q);\n\n        // get the ambient color of the object\n        vec3 ambient = getAmbient(q);\n\n        // get the diffuse color of the object\n        vec3 diffuse = getDiffuse(q);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n\n        // get the diffuse color of the light\n        vec3 diffuseLight = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight2 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight2 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight2 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight3 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight3 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight3 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diff", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_tmax = 0.0;\n    float tmax_tmin = 10000.0;\n    float tmin_tmax_t = 0.0;\n    float tmax_tmin_t = 10000.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmax_tmin_t_t = 10000.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmax_tmin_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t_t = 10000.0", "s\n    vec3 wp1 = vec3(0.0);\n    vec3 wp2 = vec3(0.0);\n    vec3 wp3 = vec3(0.0);\n    vec3 wp4 = vec3(0.0);\n    vec3 wp5 = vec3(0.0);\n    vec3 wp6 = vec3(0.0);\n    vec3 wp7 = vec3(0.0);\n    vec3 wp8 = vec3(0.0);\n    vec3 wp9 = vec3(0.0);\n    vec3 wp10 = vec3(0.0);\n    vec3 wp11 = vec3(0.0);\n    vec3 wp12 = vec3(0.0);\n    vec3 wp13 = vec3(0.0);\n    vec3 wp14 = vec3(0.0);\n    vec3 wp15 = vec3(0.0);\n    vec3 wp16 = vec3(0.0);\n    vec3 wp17 = vec3(0.0);\n    vec3 wp18 = vec3(0.0);\n    vec3 wp19 = vec3(0.0);\n    vec3 wp20 = vec3(0.0);\n    vec3 wp21 = vec3(0.0);\n    vec3 wp22 = vec3(0.0);\n    vec3 wp23 = vec3(0.0);\n    vec3 wp24 = vec3(0.0);\n    vec3 wp25 = vec3(0.0);\n    vec3 wp26 = vec3(0.0);\n    vec3 wp27 = vec3(0.0);\n    vec3 wp28 = vec3(0.0);\n    vec3 wp29 = vec3(0.", "\n    float n = 123456789.0;\n    float b = 0.0;\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float h = fract(sin(dot(p, vec3(n, n+1.0, n+2.0))) * 43758.5453);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float f = fract(sin(dot(p, vec3(n+3.0, n+5.0, n+7.0))) * 98765.4321);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float g = fract(sin(dot(p, vec3(n+9.0, n+13.0, n+17.0))) * 15973.3645);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float r = fract(sin(dot(p, vec3(n+19.0, n+23.0, n+27.0))) * 31415.9265);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to", "\n\tvec3 color = vec3(0.0);\n\tvec2 uv = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.0000000000000", "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float lineDist = distance(coords, mix(A, B, 0.5));\n    // calculate the distance from the box center to the line\n    float boxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxBoxDist = distance(coords, mix(A + box * 0.5, B -", "\n     float dot = dot(start, end);\n\n     // If the dot product is negative, the angle between the vectors is greater than 180 degrees.\n     // In this case, we need to take the shortest path.\n     if (dot < 0.0f)\n     {\n          dot = -dot;\n     }\n\n     // If the dot product is 1, the angle between the vectors is 0 degrees.\n     // In this case, we need to take the longer path.\n     if (dot > 0.9999f)\n     {\n          return normalize(start + (end - start) * percent);\n     }\n\n     // The angle between the vectors is less than 180 degrees.\n     // Perform a linear interpolation.\n     float theta = acos(dot);\n     float sinTheta = sin(theta);\n\n     // If the angle is 0, return the first vector.\n     if (sinTheta < 0.0001f)\n     {\n          return start;\n     }\n\n     // Compute the sin of the angle.\n     float sinPerTheta = sin(theta * percent);\n\n     // Compute the cos of the angle.\n     float cosPerTheta = sqrt(1.0f - sinPerTheta * sinPerTheta);\n\n     // Compute the cross product.\n     vec2 perp;\n     perp.x = perp.y = 0.0f;\n     perp.x = perp.y = (end.y * sinPerTheta - start.y * cosPerTheta) / sinTheta;\n\n     // Compute the final vector.\n     return normalize(start + perp * cosPerTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    float dist = length( ta - ro );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    // raymarch\n    vec3 col = vec3( 0.0 );\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + t * rd;\n        float d = map( pos );\n        col += d * vec3( 0.5, 0.5, 0.5 );\n        t += d;\n        if( t > 100.0 || d < 0.001 ) break;\n    }\n\n    // tone mapping\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // output to screen\n    fragColor = vec4( col, 1.0 );\n}\n", "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b", " and forth\n    float fade = clamp(0.5 + 0.5 * rayDir.y, 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0) * fade;\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - fade);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    vec2 d = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d1 = vec2(0.0);\n    vec2 d2 = vec2(0.0);\n    vec2 d3 = vec2(0.0);\n    vec2 d4 = vec2(0.0);\n    vec2 d5 = vec2(0.0);\n    vec2 d6 = vec2(0.0);\n    vec2 d7 = vec2(0.0);\n    vec2 d8 = vec2(0.0);\n    vec2 d9 = vec2(0.0);\n    vec2 d10 = vec2(0.0);\n    vec2 d11 = vec2(0.0);\n    vec2 d12 = vec2(0.0);\n    vec2 d13 = vec2(0.0);\n    vec2 d14 = vec2(0.0);\n    vec2 d15 = vec2(0.0);\n    vec2 d16 = vec2(0.0);\n    vec2 d17 = vec2(0.0);\n    vec2 d18 = vec2(0.0);\n    vec2 d19 = vec2(0.0);\n    vec2 d20 = vec2(0.0);\n    vec2 d21 = vec2(0.0);\n    vec2 d22 = vec2(0.0);\n    vec2 d23 = vec2(0.0);\n    vec2 d24 = vec2(0.0);\n    vec2 d25 = vec2(0.0);\n    vec2 d26 = vec2(0.0);\n    vec2 d27 = vec2(0.0);\n   ", "^2\n\t// t = -0.5*org.x/dir.x\n\tfloat t = -0.5*dot(org, dir)/dot(dir, dir);\n\tnear = t;\n\tfar = t + 0.5;\n\treturn near >= 0 && far <= 1;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat", "\n    vec3 q = p - vec3(s.xy, s.z);\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q35 = q34 * q", "\n    float n = noise(p);\n    float n2 = noise(p + vec3(1.0, 0.0, 0.0));\n    float n3 = noise(p + vec3(0.0, 1.0, 0.0));\n    float n4 = noise(p + vec3(0.0, 0.0, 1.0));\n    \n    // This is the actual formula.\n    return mix(n, n2, step(0.5, fract(p.x)));\n    return mix(n3, n4, step(0.5, fract(p.y)));\n    return mix(n, n3, step(0.5, fract(p.z)));\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat", "\n    float d = length(p) - 1.0;\n    \n    // The distance to the nearest wrappable circle.\n    float d2 = min(d, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d3 = min(d2, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d4 = min(d3, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d5 = min(d4, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d6 = min(d5, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d7 = min(d6, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d8 = min(d7, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d9 = min(d8, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d10 = min(d9, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d11 = min(d10, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d12 = min(d11, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d13 = min(d12, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d14 = min(d13, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d15 = min(d14, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d16 = min(d15, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d1", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // The following is the bump mapping function.\n    //\n    // The bump mapping function is a simple bump mapping function.\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor", "\n    //return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  float light_intensity = 1.0;\n\n  // ambient\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * light_color * light_intensity;\n\n  // diffuse\n  float diffuse = max(dot(light_dir, n), 0.0);\n  vec3 diffuse_color = vec3(0.5, 0.5, 0.5) * light_color * diffuse * light_intensity;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float specular = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);\n  vec3 specular_color = vec3(1.0, 1.0, 1.0) * light_color * specular * light_intensity;\n\n  return ambient + diffuse_color + specular_color;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat", "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    //creates a camera object\n    Camera cam = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 1.0, 1.0, 1.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //creates a plane object\n    Plane plane = Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\n// skybox\nvec", "i\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n", "\n    return length(p) - rad;\n}\n\n//cube\nfloat", "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // distance to the floor\n    float d1 = abs(floor) - param.z;\n\n    // distance to the ceiling\n    float d2 = abs(ceiling) - param.z;\n\n    // return the smaller distance\n    return min(d1, d2);\n}\n\n// scene distance\nfloat", "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // light gathering\n    float light = max(floor, ceiling);\n\n    // distance to light\n    float dist = length(p - param);\n\n    // return the distance to light\n    return dist - light;\n}\n\n// scene distant with light gathering\nfloat", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(ro, par);\n    if (t < 0.0)\n        return sky;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t3", "i\n    const float k = 1.0;\n    const float k2 = 1.0;\n    const float k3 = 1.0;\n    const float k4 = 1.0;\n    const float k5 = 1.0;\n    const float k6 = 1.0;\n    const float k7 = 1.0;\n    const float k8 = 1.0;\n    const float k9 = 1.0;\n    const float k10 = 1.0;\n    const float k11 = 1.0;\n    const float k12 = 1.0;\n    const float k13 = 1.0;\n    const float k14 = 1.0;\n    const float k15 = 1.0;\n    const float k16 = 1.0;\n    const float k17 = 1.0;\n    const float k18 = 1.0;\n    const float k19 = 1.0;\n    const float k20 = 1.0;\n    const float k21 = 1.0;\n    const float k22 = 1.0;\n    const float k23 = 1.0;\n    const float k24 = 1.0;\n    const float k25 = 1.0;\n    const float k26 = 1.0;\n    const float k27 = 1.0;\n    const float k28 = 1.0;\n    const float k29 = 1.0;\n    const float k30 = 1.0;\n    const float k31 = 1.0;\n    const float k32 = 1.0;\n    const float k33 = 1.0;\n    const float k34 = 1.0;\n    const float k35 = 1.0;\n    const float k36 = 1.0;\n    const float k37 = 1.0;\n    const float k38 = 1.0;\n    const float k39 = 1.0;\n    const float k40 = 1.0;\n    const float k41 = 1.0;\n    const float k42 = 1.0;\n    const float k43 = 1.0;\n    const float k", "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(clamp(q.x, -diamond.z, diamond.z), clamp(q.y, -diamond.w, diamond.w))) - diamond.z;\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat", "\n    // to avoid the need for a separate background texture.\n    vec3 background = vec3(0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);", "\n\tfloat d = length( pos - vec3( 0.0, 0.0, 0.0 ) );\n\treturn d;\n}\n\n// get distance in the world\nfloat", "\n\tvec3 light = vec3(0.0, 0.0, 0.0);\n\tvec3 diffuse = vec3(0.0, 0.0, 0.0);\n\tvec3 specular = vec3(0.0, 0.0, 0.0);\n\tvec3 ambient = vec3(0.0, 0.0, 0.0);\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tvec3 lightDir = normalize(light - v);\n\tvec3 viewDir = normalize(eye - v);\n\tvec3 halfDir = normalize(lightDir + viewDir);\n\tfloat diff = max(dot(n, lightDir), 0.0);\n\tdiffuse = diff * vec3(1.0, 1.0, 1.0);\n\tfloat spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n\tspecular = spec * vec3(1.0, 1.0, 1.0);\n\tambient = vec3(0.1, 0.1, 0.1) * diffuse;\n\tcolor = (ambient + diffuse + specular) * vec3(1.0, 1.0, 1.0);\n\treturn color;\n}\n\n// raymarching\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely as the first. :)\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n   ", ".\n    float d = length(p.xy) - r;\n    // How far along the cylinder the point is, vertically.\n    float dz = p.z;\n    // If the point is inside the cylinder, return the distance.\n    if (dz < -h / 2.0) {\n        return d;\n    }\n    // If the point is outside the cylinder, return the distance.\n    if (dz > h / 2.0) {\n        return d;\n    }\n    // If the point is on the cylinder, return the distance.\n    return dz;\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat", "\n    float t = TIME * 0.01;\n    float s = sin(t);\n    float c = cos(t);\n    p.xz *= mat2(c, s, -s, c);\n    \n    // Scale the scene\n    p *= 1.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float f = fbm(p);\n    f = fbm(p*2.0);\n    f = fbm(p*4.0);\n    f = fbm(p*8.0);\n    f = fbm(p*16.0);\n    f = fbm(p*32.0);\n    f = fbm(p*64.0);\n    f = fbm(p*128.0);\n    f = fbm(p*256.0);\n    f = fbm(p*512.0);\n    f = fbm(p*1024.0);\n    f = fbm(p*2048.0);\n    f = fbm(p*4096.0);\n    f = fbm(p*8192.0);\n    f = fbm(p*16384.0);\n    f = fbm(p*32768.0);\n    f = fbm(p*65536.0);\n    f = fbm(p*131072.0);\n    f = fbm(p*262144.0);\n    f = fbm(p*524288.0);\n    f = fbm(p*1048576.0);\n    f = fbm(p*2097152.0);\n    f = fbm(p*4194304.0);\n    f = fbm(p*8388608.0);\n    f = fbm(p*16777216.0);\n    f = fbm(p*33554432.0);\n    f = fbm(p*67108864.0);\n    f = fbm(p*134217728.0);\n    f = fbm(p*268435456.0);\n    f = fbm(p*536870912.0);\n    f = fbm(p", "\n    //It is used to calculate the color of a biomorph\n    //The biomorph is a 2D fractal\n    //The biomorph is a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fract", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    vec2 p2 = vec2(p.x, p.z);\n    float r = length(p2);\n    float theta = atan(p2.y, p2.x);\n    float phi = atan(p.y, p.x);\n    \n    // The bump mapping function.\n    float bump = sin(r * 10.0) * 0.5 + 0.5;\n    bump = clamp(bump, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump2 = sin(r * 10.0) * 0.5 + 0.5;\n    bump2 = clamp(bump2, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump3 = sin(r * 10.0) * 0.5 + 0.5;\n    bump3 = clamp(bump3, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump4 = sin(r * 10.0) * 0.5 + 0.5;\n    bump4 = clamp(bump4, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump5 = sin(r * 10.0) * 0.5 + 0.5;\n    bump5 = clamp(bump5, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump6 = sin(r * 10.0) * 0.5 + 0.5;\n    bump6 = clamp(bump6, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump7 = sin(r * 10.0) * 0.5 + 0.5;\n    bump7 = clamp(bump7, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump8 = sin(r *", "\n    //\n    // scr_pt is in screen space, and is in the range [0,1]x[0,1].\n    //\n    // view_inv is the inverse of the view matrix.\n    //\n    // proj_inv is the inverse of the projection matrix.\n    //\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray", "\n    if (rounded > thick.y) {\n        rounded = thick.y;\n    }\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, pB);\n\n    // Get the distance from the point to the line.\n    float d2 = distance(uv, pA);\n\n    // Get the distance from the point to the line.\n    float d3 = distance(uv, pB);\n\n    // Get the distance from the point to the line.\n    float d4 = distance(uv, pA + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d5 = distance(uv, pB + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d6 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d7 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d8 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d9 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d10 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  vec3 light_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 light_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 light_specular = vec3(1.0, 1.0, 1.0);\n  float light_shininess = 100.0;\n\n  // material\n  vec3 material_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 material_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 material_specular = vec3(1.0, 1.0, 1.0);\n  float material_shininess = 100.0;\n\n  // ambient\n  vec3 ambient = light_ambient * material_ambient;\n\n  // diffuse\n  float diff = max(dot(light_dir, n), 0.0);\n  vec3 diffuse = light_diffuse * diff * material_diffuse;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material_shininess);\n  vec3 specular = light_specular * spec * material_specular;\n\n  // combine\n  vec3 result = (ambient + diffuse + specular) * light_color;\n  return result;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat", "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec", "\n  return sin(x * PI) * (a + (b - a) * 0.5 * (1.0 + cos(x * TWO_PI)));\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\n// z * z\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize(ab);\n    // center the cylinder\n    vec3 oc = ro - pa;\n    // ray-cylinder intersection\n    float tca = dot(oc, abn);\n    if( tca < 0.0 ) return vec4(0.0);\n    float d2 = dot(oc, oc) - tca*tca;\n    if( d2 > ra*ra ) return vec4(0.0);\n    float thc = sqrt( ra*ra - d2 );\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    // find the nearest t value\n    float t = t0 < 0.0? t1 : t0;\n    if( t < 0.0 ) return vec4(0.0);\n    // get the normal\n    vec3 n = abn * sign(tca - ra) + abn * sign(tca + ra);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n\n\tfloat d = length(P-U);\n\tfloat r2 = r*r;\n\tfloat d2 = d*d;\n\tfloat d3 = d2*d;\n\tfloat d4 = d3*d;\n\tfloat d5 = d4*d;\n\tfloat d6 = d5*d;\n\tfloat d7 = d6*d;\n\tfloat d8 = d7*d;\n\tfloat d9 = d8*d;\n\tfloat d10 = d9*d;\n\tfloat d11 = d10*d;\n\tfloat d12 = d11*d;\n\tfloat d13 = d12*d;\n\tfloat d14 = d13*d;\n\tfloat d15 = d14*d;\n\tfloat d16 = d15*d;\n\tfloat d17 = d16*d;\n\tfloat d18 = d17*d;\n\tfloat d19 = d18*d;\n\tfloat d20 = d19*d;\n\tfloat d21 = d20*d;\n\tfloat d22 = d21*d;\n\tfloat d23 = d22*d;\n\tfloat d24 = d23*d;\n\tfloat d25 = d24*d;\n\tfloat d26 = d25*d;\n\tfloat d27 = d26*d;\n\tfloat d28 = d27*d;\n\tfloat d29 = d28*d;\n\tfloat d30 = d29*d;\n\tfloat d31 = d30*d;\n\tfloat d32 = d31*d;\n\tfloat d33 = d32*d;\n\tfloat d34 = d33*d;\n\tfloat d35 = d34*d;\n\tfloat d36 = d35*d;\n\tfloat d37 = d36*d;\n\tfloat d38 = d37*d;\n\tfloat d39 = d38*d;\n\tfloat d40 = d39*d;\n", "\n    p.xz *= mat2(1.0, 0.5, 0.5, 1.0);\n    p.y *= 0.5;\n\n    // calculate the distance to the scene\n    float d = length(p.xz) - 0.5;\n\n    // calculate the distance to the camera\n    float d2 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d3 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d4 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d5 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d6 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d7 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d8 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d9 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d10 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d11 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d12 = length(p.", "\n    float scale = (1.0/float(scaleCount))*layerID;\n    float scale2 = (1.0/float(scaleCount))*(layerID+1);\n\n    // The scale is a percentage of the grid size.\n    // The scale2 is a percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the", "\n    float scale = 0.005;\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(scale, 0.0);\n    vec2 p2 = p + vec2(0.0, scale);\n    vec2 p3 = p + vec2(-scale, 0.0);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p4 = p + vec2(scale, scale);\n    vec2 p5 = p + vec2(0.0, scale) + vec2(scale, scale);\n    vec2 p6 = p + vec2(scale, 0.0) + vec2(scale, scale);\n    vec2 p7 = p + vec2(0.0, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p8 = p + vec2(-scale, scale);\n    vec2 p9 = p + vec2(-scale, 0.0) + vec2(scale, scale);\n    vec2 p10 = p + vec2(-scale, 0.0) + vec2(0.0, scale);\n    vec2 p11 = p + vec2(-scale, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p12 = p + vec2(-scale, -scale);\n    vec2 p13 = p + vec2(-scale, -scale) + vec2(scale, scale);\n    vec2 p14 = p + vec2(-scale, -scale) + vec2(0.0, scale);\n    vec2 p15 = p + vec2(-scale, -scale) + vec2(-scale, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p16 = p + vec2(scale, -scale);\n", "\n\n    // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b\n    float distance = length(currentRayPosition.xz) - 0.5;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u043c\u0435\u043d\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.5)\n    {\n        return 0.0;\n    }\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0431\u043e\u043b\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    return 1.0 - distance;\n}\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0441 \u044d\u0444\u0444\u0435\u043a\u0442\u043e\u043c \u043f\u043b\u0430\u043c\u0435\u043d\u0438\nfloat", "\n    // \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0442\u044c\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043e\u043b\u0433\u043e\n    // \u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n    return abs(flameDistance(currentRayPosition));\n}\n\n// ray marching\n// ray - \u043b\u0443\u0447, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u0442 \u043f\u043e \u0441\u0446\u0435\u043d\u0435\n// rayDirection - \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n// rayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430\n// currentRayPosition - \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u043b\u0443\u0447\u0430\n// currentRayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043f\u0440\u043e\u0448\u043b\u043e\n// currentRayColor - \u0446\u0432\u0435\u0442 \u043b\u0443\u0447\u0430\n// currentRayStep - \u0448\u0430\u0433 \u043b\u0443\u0447\u0430\n// currentRayStepLength - \u0434\u043b\u0438\u043d\u0430 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepColor - \u0446\u0432\u0435\u0442 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepCount - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b", "\n    float s = sm;\n    \n    // Get the integer part of the input.\n    float i = floor(x);\n    \n    // Get the fractional part of the input.\n    float f = x - i;\n    \n    // Get the fractional part of the integer part.\n    float fInt = f - floor(f);\n    \n    // Get the fractional part of the integer part.\n    float fFrac = fInt - floor(fInt);\n    \n    // Get the fractional part of the integer part.\n    float fFrac2 = fFrac - floor(fFrac);\n    \n    // Get the fractional part of the integer part.\n    float fFrac3 = fFrac2 - floor(fFrac2);\n    \n    // Get the fractional part of the integer part.\n    float fFrac4 = fFrac3 - floor(fFrac3);\n    \n    // Get the fractional part of the integer part.\n    float fFrac5 = fFrac4 - floor(fFrac4);\n    \n    // Get the fractional part of the integer part.\n    float fFrac6 = fFrac5 - floor(fFrac5);\n    \n    // Get the fractional part of the integer part.\n    float fFrac7 = fFrac6 - floor(fFrac6);\n    \n    // Get the fractional part of the integer part.\n    float fFrac8 = fFrac7 - floor(fFrac7);\n    \n    // Get the fractional part of the integer part.\n    float fFrac9 = fFrac8 - floor(fFrac8);\n    \n    // Get the fractional part of the integer part.\n    float fFrac10 = fFrac9 - floor(fFrac9);\n    \n    // Get the fractional part of the integer part.\n    float fFrac11 = fFrac10 - floor(fFrac10);\n    \n    // Get the fractional part of the integer part.\n    float fFrac12 = fFrac11 - floor(fFrac11);\n    \n    // Get the fractional part of the integer", "\n\n    // p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    // p += dot(p, p.yxz + 19.19);\n    // return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n\n    // This is the original, but it's a bit more complicated. It's a bit more complicated, but it's\n    // more accurate. It's also more accurate, but it's slower.\n\n    p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    p += dot(p, p.yxz + 19.19);\n    return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n}\n\n// This is a simple noise function, that I've found on the internet. It's not as accurate as the\n// hash33 function, but it's faster.\nfloat", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // Determining the first vertice and the fractional position.\n    vec3 v = p - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v2 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v3 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v4 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v5 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v6 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v7 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v8 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v9 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v10 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v11 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v12 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v13 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v14 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v15 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v1", "\n    float n = 0.0;\n    \n    // The number of octaves.\n    int octaves = 10;\n    \n    // The frequency of the noise.\n    float freq = 1.0;\n    \n    // The amplitude of the noise.\n    float amp = 0.5;\n    \n    // The persistence.\n    float persistence = 0.5;\n    \n    // The scale.\n    float scale = 0.5;\n    \n    // The offset.\n    float offset = 0.0;\n    \n    // The total amplitude.\n    float totalAmp = 0.0;\n    \n    // The total frequency.\n    float totalFreq = freq;\n    \n    // The total persistence.\n    float totalPersistence = persistence;\n    \n    // The total scale.\n    float totalScale = scale;\n    \n    // The total offset.\n    float totalOffset = offset;\n    \n    // The total noise.\n    float totalNoise = 0.0;\n    \n    // The total noise.\n    float totalNoise2 = 0.0;\n    \n    // The total noise.\n    float totalNoise3 = 0.0;\n    \n    // The total noise.\n    float totalNoise4 = 0.0;\n    \n    // The total noise.\n    float totalNoise5 = 0.0;\n    \n    // The total noise.\n    float totalNoise6 = 0.0;\n    \n    // The total noise.\n    float totalNoise7 = 0.0;\n    \n    // The total noise.\n    float totalNoise8 = 0.0;\n    \n    // The total noise.\n    float totalNoise9 = 0.0;\n    \n    // The total noise.\n    float totalNoise10 = 0.0;\n    \n    // The total noise.\n    float totalNoise11 = 0.0;\n    \n    // The total noise.\n    float totalNoise12 = 0.0;\n    \n    // The total noise.\n    float totalNoise13 = 0.0;\n    \n    // The total noise.\n    float totalNoise14 = 0.", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // We calculate the distance between the current ray position and the balloon position\n  float distance = length( currentRayPosition - balloonPosition );\n  \n  // If the distance is smaller than the balloon radius, we return the distance and the color of the balloon\n  if( distance < balloonRadius ){\n    return vec2( distance, vec3( 0.0, 0.0, 1.0 ) );\n  }\n  \n  // If the distance is larger than the balloon radius, we return the distance and the color of the background\n  return vec2( distance, vec3( 0.0, 0.0, 0.0 ) );\n}\n\n//'TAG: BALL'\nvec", "\n\tvec3 tmin = (rad-ro)/rd;\n\tvec3 tmax = (rad-ro-1.0)/rd;\n\tvec3 t1 = min(tmin,tmax);\n\tvec3 t2 = max(tmin,tmax);\n\tfloat t0 = max(max(t1.x,t1.y),t1.z);\n\tfloat t3 = min(min(t2.x,t2.y),t2.z);\n\tif(t0>t3) return vec4(0.0);\n\tt0 = max(t0,t1.x);\n\tt3 = min(t3,t2.x);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.y);\n\tt3 = min(t3,t2.y);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.z);\n\tt3 = min(t3,t2.z);\n\tif(t3<t0) return vec4(0.0);\n\treturn vec4(t0,t1.x,t1.y,t1.z);\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 v = p - f + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v0 = v + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v1 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v2 = v + vec3(u.x, 1.0-u.y, u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v3 = v + vec3(1.0-u.x, u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v4 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v5 = v + vec3(1.0-u.x, 1.0-u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v6 = v + vec3(u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v7 = v + vec3(1.0-u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v8 = v + vec3(u.x, u.y, 1.0-u.x-", "\n vec3 col=vec3(0);\n vec2 v=vec2(0);\n float d=0;\n float d2=0;\n float d3=0;\n float d4=0;\n float d5=0;\n float d6=0;\n float d7=0;\n float d8=0;\n float d9=0;\n float d10=0;\n float d11=0;\n float d12=0;\n float d13=0;\n float d14=0;\n float d15=0;\n float d16=0;\n float d17=0;\n float d18=0;\n float d19=0;\n float d20=0;\n float d21=0;\n float d22=0;\n float d23=0;\n float d24=0;\n float d25=0;\n float d26=0;\n float d27=0;\n float d28=0;\n float d29=0;\n float d30=0;\n float d31=0;\n float d32=0;\n float d33=0;\n float d34=0;\n float d35=0;\n float d36=0;\n float d37=0;\n float d38=0;\n float d39=0;\n float d40=0;\n float d41=0;\n float d42=0;\n float d43=0;\n float d44=0;\n float d45=0;\n float d46=0;\n float d47=0;\n float d48=0;\n float d49=0;\n float d50=0;\n float d51=0;\n float d52=0;\n float d53=0;\n float d54=0;\n float d55=0;\n float d56=0;\n float d57=0;\n float d58=0;\n float d59=0;\n float d60=0;\n float d61=0;\n float d62=0;\n float d6", "\n    //Use a float instead.\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float i = 0.0;\n    float zr = 0.0;\n    float zi = 0.0;\n    float zr2 = 0.0;\n    float zi2 = 0.0;\n    float zr3 = 0.0;\n    float zi3 = 0.0;\n    float zr4 = 0.0;\n    float zi4 = 0.0;\n    float zr5 = 0.0;\n    float zi5 = 0.0;\n    float zr6 = 0.0;\n    float zi6 = 0.0;\n    float zr7 = 0.0;\n    float zi7 = 0.0;\n    float zr8 = 0.0;\n    float zi8 = 0.0;\n    float zr9 = 0.0;\n    float zi9 = 0.0;\n    float zr10 = 0.0;\n    float zi10 = 0.0;\n    float zr11 = 0.0;\n    float zi11 = 0.0;\n    float zr12 = 0.0;\n    float zi12 = 0.0;\n    float zr13 = 0.0;\n    float zi13 = 0.0;\n    float zr14 = 0.0;\n    float zi14 = 0.0;\n    float zr15 = 0.0;\n    float zi15 = 0.0;\n    float zr16 = 0.0;\n    float zi16 = 0.0;\n    float zr17 = 0.0;\n    float zi17 = 0.0;\n    float zr18 = 0.0;\n    float zi18 = 0.0;\n    float zr19 = 0.0;\n    float zi19 = 0.0;\n    float zr20 = 0.0;\n    float zi20 = 0.0;\n    float zr21 = ", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the new coord system\n    mat4 m;\n    m[0] = vec4(x, 0.0);\n    m[1] = vec4(y, 0.0);\n    m[2] = vec4(z, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    return m;\n}\n\n//view matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / iResolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 q = p;\n    vec2 r = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tt = 0.0;\n    float ttt = 0.0;\n    float tttt = 0.0;\n    float ttttt = 0.0;\n    float tttttt = 0.0;\n    float ttttttt = 0.0;\n    float tttttttt = 0.0;\n    float ttttttttt = 0.0;\n    float tttttttttt = 0.0;\n    float ttttttttttt = 0.0;\n    float tttttttttttt = 0.0;\n    float ttttttttttttt = 0.0;\n    float tttttttttttttt = 0.0;\n    float ttttttttttttttt = 0.0;\n    float tttttttttttttttt = 0.0;\n    float ttttttttttttttttt = 0.0;\n    float tttttttttttttttttt = 0.0;\n    float ttttttttttttttttttt = 0.0;\n    float tttttttttttttttttttt = 0.0;\n    float", "\n    float d = w / 10.0;\n    float d2 = d / 2.0;\n    float d3 = d2 / 2.0;\n    float d4 = d3 / 2.0;\n    float d5 = d4 / 2.0;\n    float d6 = d5 / 2.0;\n    float d7 = d6 / 2.0;\n    float d8 = d7 / 2.0;\n    float d9 = d8 / 2.0;\n    float d10 = d9 / 2.0;\n    float d11 = d10 / 2.0;\n    float d12 = d11 / 2.0;\n    float d13 = d12 / 2.0;\n    float d14 = d13 / 2.0;\n    float d15 = d14 / 2.0;\n    float d16 = d15 / 2.0;\n    float d17 = d16 / 2.0;\n    float d18 = d17 / 2.0;\n    float d19 = d18 / 2.0;\n    float d20 = d19 / 2.0;\n    float d21 = d20 / 2.0;\n    float d22 = d21 / 2.0;\n    float d23 = d22 / 2.0;\n    float d24 = d23 / 2.0;\n    float d25 = d24 / 2.0;\n    float d26 = d25 / 2.0;\n    float d27 = d26 / 2.0;\n    float d28 = d27 / 2.0;\n    float d29 = d28 / 2.0;\n    float d30 = d29 / 2.0;\n    float d31 = d30 / 2.0;\n    float d32 = d31 / 2.0;\n    float d33 = d32 / 2.0;\n    float d3", "\n    if (a == b)\n        return 0.0;\n\n    // clamp x to [0, 1]\n    x = clamp(x, 0.0, 1.0);\n\n    // lerp between a and b\n    return lerp(a, b, x);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2, float curve3)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 x", "\n float a=j*3.1415926535897932384626433832795;\n float b=j*3.1415926535897932384626433832795+0.5;\n float c=j*3.1415926535897932384626433832795+1.5;\n float d=j*3.1415926535897932384626433832795+2.5;\n float e=j*3.1415926535897932384626433832795+3.5;\n // random offsets of neighbors (counter-clockwise starting south)\n float f=j*3.1415926535897932384626433832795-0.5;\n float g=j*3.1415926535897932384626433832795-1.5;\n float h=j*3.1415926535897932384626433832795-2.5;\n float i=j*3.1415926535897932384626433832795-3.5;\n // random offsets of neighbors (clockwise starting east)\n float j=j*3.1415926535897932384626433832795+4.5;\n float k=j*3.1415926535897932384626433832795+5.5;\n float l=", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n return f;\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat", ", but it's a good start\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299;\n    rgb.g = c.g * 0.587;\n    rgb.b = c.b * 0.114;\n    return rgb;\n}\n\n//this is a pretty good way to get a color that is a bit more\n//\"natural\" than the default color, but it's not as good as\n//EnChromaRgb()\nvec", "\n  vec4 d=vec4(0.);\n  vec3 q=abs(p)-s;\n  d.x=min(max(q.x,0.),min(q.y,q.z));\n  d.y=min(max(q.y,0.),min(q.z,q.x));\n  d.z=min(max(q.z,0.),min(q.x,q.y));\n  d.w=max(max(q.x,q.y),max(q.y,q.z));\n  return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4", "\n    Material mat = distScene(pos, depth, steps);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t, t2);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2, float t3)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + ", "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp((x * (0.055f * (x * (x * 0.3f + 0.5f)) + 0.05f)) / (x * (0.119192f * (x * 0.3f + 0.5f) + 0.332f) + 0.18055f), 0.0f, 1.0f);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec", "\n    p.z += 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    if (p.x*p.x + p.y*p.y + p.z*p.z < 1.0) {\n        return vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    //plane\n    else if (p.x == 0.0 && p.y == 0.0 && p.z == 0.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    //cube\n    else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n//scene light at position p\nvec", "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 100 );\n    // rotate point p by 45 degrees\n    p = m * p;\n    // add noise to each axis\n    for ( int i = 0; i < 5; i++ ) {\n        f += a * noise( p );\n        p = m * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    \n    // The first point is the wrapped point.\n    vec2 p0 = p;\n    \n    // The second point is the wrapped point rotated 90 degrees.\n    vec2 p1 = vec2(p0.y, -p0.x);\n    \n    // The third point is the wrapped point rotated 180 degrees.\n    vec2 p2 = vec2(-p0.y, p0.x);\n    \n    // The fourth point is the wrapped point rotated 270 degrees.\n    vec2 p3 = vec2(-p0.x, -p0.y);\n    \n    // The fifth point is the wrapped point rotated 360 degrees.\n    vec2 p4 = p0;\n    \n    // The sixth point is the wrapped point rotated 45 degrees.\n    vec2 p5 = vec2(-p0.y, -p0.x);\n    \n    // The seventh point is the wrapped point rotated 135 degrees.\n    vec2 p6 = vec2(p0.x, -p0.y);\n    \n    // The eighth point is the wrapped point rotated 225 degrees.\n    vec2 p7 = vec2(-p0.x, p0.y);\n    \n    // The ninth point is the wrapped point rotated 315 degrees.\n    vec2 p8 = vec2(-p0.y, -p0.x);\n    \n    // The tenth point is the wrapped point rotated 45 degrees.\n    vec2 p9 = vec2(p0.y, p0.x);\n    \n    // The eleventh point is the wrapped point rotated 135 degrees.\n    vec2 p10 = vec2(-p0.x, p0.y);\n    \n    // The twelfth point is the wrapped point rotated 225 degrees.\n    vec2 p11 = vec2(p0.x, -p0.y);\n    \n    // The thirteenth point is the wrapped point rotated 315 degrees.\n    vec", "\n return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", " to define a line.\n //return length(u-d)-.1;\n return length(u-m.xy)-.1;\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n ", "\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}", "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec", "\n\tfloat alpha = acos(dot(normalize(A - B), normalize(C - B)));\n\tfloat beta = acos(dot(normalize(A - C), normalize(B - C)));\n\tfloat gamma = acos(dot(normalize(B - C), normalize(A - C)));\n\n\t//calculate the solid angle of the spherical triangle\n\tfloat solidAngle = alpha + beta + gamma - M_PI;\n\n\t//calculate the solid angle of the triangle\n\tfloat solidAngleTriangle = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of", "\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In", "\n    \n    // The tube is a cylinder with a radius of 1.\n    float r = 1.0;\n    \n    // The tube is a cylinder with a radius of 1.\n    float h = 0.5;\n    \n    // The tube is a cylinder with a radius of 1.\n    float d = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float a = 0.1;\n    \n    // The tube is a cylinder with a radius of 1.\n    float b = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float c = 0.01;\n    \n    // The tube is a cylinder with a radius of 1.\n    float e = 0.001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float f = 0.0001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float g = 0.00001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hh = 0.000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhh = 0.0000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhh = 0.00000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhh = 0.000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhh = 0.0000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhh = 0.00000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhhh = 0.000000000001;\n    \n    // The tube is a cylinder with a", "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.0005;\n\n    // Tube color.\n    vec4 tubeColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube inner color.\n    vec4 tubeInnerColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands color.\n    vec4 tubeBandsColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness", "\n    float g = floor(gID);\n    \n    // The distance from the point to the grid cell.\n    float d = p.x - g;\n    \n    // The distance from the point to the grid cell.\n    float d2 = p.y - g;\n    \n    // The distance from the point to the grid cell.\n    float d3 = p.z - g;\n    \n    // The distance from the point to the grid cell.\n    float d4 = p.x - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d5 = p.y - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d6 = p.z - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d7 = p.x - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d8 = p.y - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d9 = p.z - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d10 = p.x - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d11 = p.y - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d12 = p.z - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d13 = p.x - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d14 = p.y - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d15 = p.z - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d16 = p.x - g + 5.0;\n    \n    // The distance from the point to the", "\n    float t = 0., tmin = 1e10;\n    \n    // Loop until we reach the maximum ray distance or the object is hit.\n    for(int i = 0; i < 100; i++){\n        \n        // Get the current ray position.\n        vec3 p = o + r * t;\n        \n        // Get the distance to the object at the current ray position.\n        float d = length(p - object_position);\n        \n        // If the ray is closer than the current nearest distance, update the nearest distance.\n        if(d < tmin){\n            tmin = d;\n        }\n        \n        // If the ray is closer than the maximum ray distance, stop the ray.\n        if(t + d > max_ray_distance){\n            break;\n        }\n        \n        // Update the ray position.\n        t += d;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the nearest distance.\n    if(t < max_ray_distance){\n        return tmin;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the maximum ray distance.\n    return max_ray_distance;\n}\n\n// Calculate the color of the ray.\nvec", "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm", "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting", "\n    vec3 w = abs(m[0] * p3) + abs(m[1] * p3) + abs(m[2] * p3);\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // compute barycentric coordinates\n    return vec4(1.0 - w.x - w.y - w.z, w.x, w.y, w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID2 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID3 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID4 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID5 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID6 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID7 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID8 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID9 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID10 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID11 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hex", "\n    vec2 uv = vec2(df_truchet(p), dir);\n    \n    // The Truchet distance field is a 2D texture, so we need to sample it.\n    // The second argument is the \"wrap\" mode, which is set to clamp.\n    return texture2D(df_texture, uv).r;\n}\n\n// The Truchet distance field is a 2D texture, so we need to sample it.\n// The second argument is the \"wrap\" mode, which is set to clamp.\nfloat", "\n    // q is the pixel position.\n    // dir is the direction of the arc.\n    //\n    // The direction is in radians.\n    //\n    // The polar coordinate is the angle of the arc.\n    //\n    // The polar coordinate is in radians.\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar", "\n    vec3 w = abs(n[0].xyz) * dot(p3, n[0].xyz);\n    w += abs(n[1].xyz) * dot(p3, n[1].xyz);\n    w += abs(n[2].xyz) * dot(p3, n[2].xyz);\n    return vec4(w, 1.0) / dot(w, t);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // If the line is parallel to the plane, then\n  // the distance is zero.\n  if (abs(r.w) < EPSILON) {\n    return 0.0;\n  }\n\n  // Compute the distance to the line.\n  float t = (p.w - q.w) / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (t < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the plane.\n  float d = dot(r, q) - dot(r, p);\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (d < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the point.\n  float s = d / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (s < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the squared distance to the point.\n  float d2 = s * s;\n\n  // Compute the squared distance to the line.\n  float d3 = d2 + t * t;\n\n  // Return the squared distance to the line.\n  return d3;\n}\n\n// Find the (squared) distance to the line in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float t = tru(p, lW);\n    float t2 = tru(p, lW*2.0);\n    float t3 = tru(p, lW*3.0);\n    float t4 = tru(p, lW*4.0);\n    float t5 = tru(p, lW*5.0);\n    float t6 = tru(p, lW*6.0);\n    float t7 = tru(p, lW*7.0);\n    float t8 = tru(p, lW*8.0);\n    float t9 = tru(p, lW*9.0);\n    float t10 = tru(p, lW*10.0);\n    float t11 = tru(p, lW*11.0);\n    float t12 = tru(p, lW*12.0);\n    float t13 = tru(p, lW*13.0);\n    float t14 = tru(p, lW*14.0);\n    float t15 = tru(p, lW*15.0);\n    float t16 = tru(p, lW*16.0);\n    float t17 = tru(p, lW*17.0);\n    float t18 = tru(p, lW*18.0);\n    float t19 = tru(p, lW*19.0);\n    float t20 = tru(p, lW*20.0);\n    float t21 = tru(p, lW*21.0);\n    float t22 = tru(p, lW*22.0);\n    float t23 = tru(p, lW*23.0);\n    float t24 = tru(p, lW*24.0);\n    float t25 = tru(p, lW*25.0);\n    float t26 = tru(p, lW*26.0);\n    float t27 = tru(p, lW*", "\n\tfloat k = 1.0 / ( 2.0 * ( ddx.x * ddy.y - ddy.x * ddx.y ) );\n\n\t// sample texture\n\tvec2 dp = ddx * ddy;\n\tvec2 dp2 = dp * dp;\n\tvec2 dp3 = dp2 * dp;\n\tvec2 dp4 = dp3 * dp;\n\tvec2 dp5 = dp4 * dp;\n\tvec2 dp6 = dp5 * dp;\n\tvec2 dp7 = dp6 * dp;\n\tvec2 dp8 = dp7 * dp;\n\tvec2 dp9 = dp8 * dp;\n\tvec2 dp10 = dp9 * dp;\n\tvec2 dp11 = dp10 * dp;\n\tvec2 dp12 = dp11 * dp;\n\tvec2 dp13 = dp12 * dp;\n\tvec2 dp14 = dp13 * dp;\n\tvec2 dp15 = dp14 * dp;\n\tvec2 dp16 = dp15 * dp;\n\tvec2 dp17 = dp16 * dp;\n\tvec2 dp18 = dp17 * dp;\n\tvec2 dp19 = dp18 * dp;\n\tvec2 dp20 = dp19 * dp;\n\tvec2 dp21 = dp20 * dp;\n\tvec2 dp22 = dp21 * dp;\n\tvec2 dp23 = dp22 * dp;\n\tvec2 dp24 = dp23 * dp;\n\tvec2 dp25 = dp24 * dp;\n\tvec2 dp26 = dp25 * dp;\n\tvec2 dp27 = dp26 * dp;\n\tvec2 dp28 = dp27 * dp;\n\tvec2 dp29 = dp28 * dp", " of query point\n    vec2 q = floor(n);\n    // take half-cell position of query point\n    vec2 qf = floor(f);\n    // take half-cell position of query point\n    vec2 qn = floor(n+1.0);\n    // take half-cell position of query point\n    vec2 qnf = floor(f+1.0);\n    // take half-cell position of query point\n    vec2 qnq = floor(n+q);\n    // take half-cell position of query point\n    vec2 qnqf = floor(f+q);\n    // take half-cell position of query point\n    vec2 qnqn = floor(n+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnf = floor(f+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnq = floor(n+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqf = floor(f+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqn = floor(n+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnf = floor(f+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnq = floor(n+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqf = floor(f+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqn = floor(n+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqnf = floor(f+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqn", "\n    return vec2(\n        mix(p1.x,p2.x,t),\n        mix(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec", "\n\n    // p = p*2891336453.0 + 1.0;\n    // return fract(sin(p)*43758.5453123);\n\n    // This is a much more accurate version of the above, but it's slower.\n    // It's also more accurate, but it's not as nice.\n\n    p = p*2891336453.0 + 1.0;\n    return fract(sin(p)*43758.5453123);\n}\n\n// vec3 to vec3 hash.\nvec", "\n\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Incenter.\n    vec2 incenter = (p0 + p1 + p2) / 3.0;\n    \n    // Rotate incenter.\n    incenter = rotate(incenter, alpha);\n    incenter = rotate(incenter, beta);\n    incenter = rotate(incenter, gamma);\n    \n    return incenter;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec", "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumradius.\n    float r = (a * b * c) / (4.0 * area);\n\n    return r;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat", "\n   // Returns distance of origin to a plane crossing projected triangle.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1", "\n    vec2 v0 = vec2(0.0);\n    vec2 v1 = vec2(0.0);\n    vec2 v2 = vec2(0.0);\n    vec2 v3 = vec2(0.0);\n    vec2 v4 = vec2(0.0);\n    vec2 v5 = vec2(0.0);\n    vec2 v6 = vec2(0.0);\n    vec2 v7 = vec2(0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t0 = triObj(0.0, 0.0, 0.0);\n    triObj t1 = triObj(0.0, 0.0, 0.0);\n    triObj t2 = triObj(0.0, 0.0, 0.0);\n    triObj t3 = triObj(0.0, 0.0, 0.0);\n    triObj t4 = triObj(0.0, 0.0, 0.0);\n    triObj t5 = triObj(0.0, 0.0, 0.0);\n    triObj t6 = triObj(0.0, 0.0, 0.0);\n    triObj t7 = triObj(0.0, 0.0, 0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t8 = triObj(0.0, 0.0, 0.0);\n    triObj t9 = triObj(0.0, 0.0, 0.0);\n    triObj t10 = triObj(0.0, 0.0, 0.0);\n    triObj t11 = triObj(0.0, 0.0, 0.0);\n    triObj t12 = triObj(0", "\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color2 = texture(iChannel1, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color3 = texture(iChannel2, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color4 = texture(iChannel3, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color5 = texture(iChannel4, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color6 = texture(iChannel5, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color7 = texture(iChannel6, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color8 = texture(iChannel7, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color9 = texture(iChannel8, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color10 = texture(iChannel9, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color11 = texture(iChannel10, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color12 = texture(iChannel11, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color13 = texture(iChannel12, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color14 = texture(iChannel13, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color15 = texture(iChannel14, uv).rgb;\n\n    //get the color of the pixel\n    vec", "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////\n    // 1. Compute the intersection between the ray and the sphere.\n    // 2. If there is an intersection, return true.\n    // 3. If there is no intersection, return false.\n    // 4. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 5. If there is no intersection, return false.\n    // 6. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 7. If there is no intersection, return false.\n    // 8. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 9. If there is no intersection, return false.\n    // 10. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 11. If there is no intersection, return false.\n    // 12. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 13. If there is no intersection, return false.\n    // 14. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 15. If there is no intersection, return false.\n    // 16. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 17. If there is no intersection, return false.\n    // 18. If there is one or two intersections, output the value of the smaller t, the position of the intersection (", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true", "\n    // If there is no hit, return the background color.\n    // If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    // 1. Find the nearest hit point.\n    // 2. If there is no hit, return the background color.\n    // 3. If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    float t_min = INFINITY;\n    float t_max = -INFINITY;\n    bool hit = false;\n    for (int i = 0; i < num_objects; i++) {\n        float t = IntersectRay(ray, objects[i]);\n        if (t < t_min) {\n            t_min = t;\n        }\n        if (t > t_max) {\n            t_max = t;\n        }\n        if (t > 0.0) {\n            hit = true;\n            hitPos_ = ray.origin + t * ray.dir;\n            hitNormal_ = objects[i].normal(hitPos_);\n            k_rg_ = objects[i].k_rg;\n        }\n    }\n    if (hit) {\n        hasHit = true;\n        hitPos = hitPos_;\n        hitNormal = hitNormal_;\n        k_rg = k_rg_;\n    } else {\n        hasHit = false;\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p20 = mix(p2, p0, 0.5);\n\n    // midpoints\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p120 = mix(p12, p20, 0.5);\n    vec2 p201 = mix(p20, p01, 0.5);\n\n    // corners\n    vec2 p0120 = mix(p012, p120, 0.5);\n    vec2 p1201 = mix(p120, p201, 0.5);\n    vec2 p2010 = mix(p201, p012, 0.5);\n\n    // return the bbox\n    return vec4(p0120, p1201, p2010);\n}\n\n// Approximate BBox to a quadratic bezier\nvec", "\n    vec3 bmin = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 bmax = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 bcenter = 0.5 * ( bmin + bmax );\n\n    // diagonal\n    vec3 bdiag = bmax - bmin;\n\n    // return\n    return bound3( bcenter - 0.5 * bdiag, bcenter + 0.5 * bdiag );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TAU = 2.0 * PI;\n    const float PI_OVER_2 = PI / 2.0;\n    const float PI_OVER_4 = PI / 4.0;\n    const float PI_OVER_6 = PI / 6.0;\n    const float PI_OVER_8 = PI / 8.0;\n    const float PI_OVER_16 = PI / 16.0;\n    const float PI_OVER_32 = PI / 32.0;\n    const float PI_OVER_64 = PI / 64.0;\n    const float PI_OVER_128 = PI / 128.0;\n    const float PI_OVER_256 = PI / 256.0;\n    const float PI_OVER_512 = PI / 512.0;\n    const float PI_OVER_1024 = PI / 1024.0;\n    const float PI_OVER_2048 = PI / 2048.0;\n    const float PI_OVER_4096 = PI / 4096.0;\n    const float PI_OVER_8192 = PI / 8192.0;\n    const float PI_OVER_16384 = PI / 16384.0;\n    const float PI_OVER_32768 = PI / 32768.0;\n    const float PI_OVER_65536 = PI / 65536.0;\n    const float PI_OVER_131072 = PI / 131072.0;\n    const float PI_OVER_262144 = PI / ", "\n    return cos( k * PI / 2.0 ); // EaseInOut\n}\n\n/**\n * Easing Curve\n */\nfloat", "\n    vec4 b = vec4(v.x - floor(v.x + 0.5), v.x - floor(v.x - 0.5),\n                  v.y - floor(v.y + 0.5), v.y - floor(v.y - 0.5));\n\n    // Gradients\n    // (N*5 - 1) / 4 used to avoid 0s in the gradient.\n    vec4 o = vec4(0.041970724, 0.024665052, 0.014403290, 0.009360530) - b;\n\n    // Mix final noise value\n    vec4 n0 = vec4(dot(b, vec4(dot(o, vec4(1.000000, 57.000000, 113.000000, 259.000000)))));\n    vec4 n1 = vec4(dot(b, vec4(dot(o, vec4(33.000000, 21.000000, 3.000000, 9.000000)))));\n\n    return 49.000000 * (dot(n0, v) + dot(n1, v + vec4(1.000000, 1.000000, 0.000000, 0.000000)));\n}\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n", "\n    coord -= vec2(0.5);\n\n    // Scale the coordinate to the size of the screen.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5);\n\n    return coord;\n}\n\n// Remap the OpenGL space to the space where the julia set is defined ( [(-2;-2),(2;2)] ).\nvec", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f", "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 2.04040323 - 0.5;\n    rgb2hcv.xz *= mat2(1.0, 1.0, -1.0, -1.0);\n    rgb2hcv.y = sqrt(rgb2hcv.y);\n    return rgb2hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but still not as nicely dispersed.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise.\nfloat", "\n    const float eps = 0.0001;\n    return normalize(\n        vec3(\n            map( p + vec3( eps, 0.0, 0.0 ) ) - map( p - vec3( eps, 0.0, 0.0 ) ),\n            map( p + vec3( 0.0, eps, 0.0 ) ) - map( p - vec3( 0.0, eps, 0.0 ) ),\n            map( p + vec3( 0.0, 0.0, eps ) ) - map( p - vec3( 0.0, 0.0, eps ) )\n        )\n    );\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    float angle = TWO_PI / width;\n    float x = radius * cos(angle);\n    float y = radius * sin(angle);\n    return DrawPoint(pos + vec2(x, y), 0.001);\n}\n\n// Draw a piece of leaf points to LEFT ((0,0)->(-1,0))\n// width (0.,1.)\nfloat", "\n    vec4 v3 = vec4(v.x - floor(v.x + 0.5), v.y - floor(v.y + 0.5), 0.0, 0.0);\n    vec4 i3 = floor(v3 + 0.5);\n\n    // Replicate v3 to full 4x4 grid of v\n    vec4 v4 = smoothstep(vec4(0.0), vec4(1.0, 1.0, 1.0, 1.0), v3);\n\n    // Linearly interpolate between four corners of a tile\n    vec4 i = vec4(i3.x + i3.y * 57.0, i3.x + 1.0 + i3.y * 57.0, i3.x + i3.y * 113.0, i3.x + 1.0 + i3.y * 113.0);\n    vec4 x = v4.xzxy + v4.ywys;\n\n    // Mix final noise value in range 0-1\n    return mix(mix(mix(dot(x, vec4(1.0, 57.0, 57.0, 113.0)), x.y), x.z, x.w), x.x, v4.y);\n}\n\n//SNOISE\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the ray direction\n\tvec3 rayDir = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n\t\n\t// get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\t\n\t// get the ray color\n\tvec3 rayColor = vec3(0.0);\n\t\n\t// get the ray distance\n\tfloat rayDistance = 0.0;\n\t\n\t// get the ray depth\n\tfloat rayDepth = 0.0;\n\t\n\t// get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\t\n\t// get the ray material\n\tvec3 rayMaterial = vec3(0.0);\n\t\n\t// get the ray light\n\tvec3 rayLight = vec3(0.0);\n\t\n\t// get the ray reflections\n\tvec3 rayReflections = vec3(0.0);\n\t\n\t// get the ray refractions\n\tvec3 rayRefractions = vec3(0.0);\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex2 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex3 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex4 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex5 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex6 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex7 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex8 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex9 = 0.0;\n\t\n\t// get the ray refractive index", "\n    float n = noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\n// Thanks Shane.\nfloat", "\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\t// Apply the forward log-spherical map\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`", "\n    float d = length(p.xy) - 0.5;\n    //distance to plane = distance to center of plane minus height\n    //x-pos and height vary over time in some sin/cos pattern\n    float d2 = p.z - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d3 = length(p.xy) - 0.5;\n    //distance to cone = distance to center of cone minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d4 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d5 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d6 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d7 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d8 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d9 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d10 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d11 = length(p.xy) - 0.", "\n  return vec2(z.x*w.x-z.y*w.y, z.y*w.x+z.x*w.y);\n}\n\n// Complex functions\nvec", "\n\tret += vec3(p.x, p.y, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\n\t// T to R\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\n\t// R to B\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\n\t// B to L\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y, 0.0);\n}\n\n/*\nConstruct a Penrose triangle in 3D by manually placing a bunch of angled\nsquares. Nothing really magic.\n*/\nvoid drawPen", "\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, sin(time)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(time), 0.0, cos(time))\n    );\n\n    // rotate the position of the box\n    vec3 rotatedPos = rot * pos;\n\n    // get the distance to the box\n    vec2 dist = vec2(length(rotatedPos.xz) - 0.5, rotatedPos.y);\n\n    // get the material ID of the box\n    vec2 materialID = vec2(0.0, 0.0);\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox.x) {\n        closestBox = dist;\n        materialID = vec2(1.0, 0.0);\n    }\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox2.x) {\n        closestBox2 = dist;\n        materialID = vec2(1.0, 1.0);\n    }\n\n    // return the distance to the box and the material ID\n    return dist;\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec", "\n    float dist = length(pos.xz) - 0.5;\n\n    // if the sphere is closer to the camera, make it darker\n    float darken = smoothstep(0.0, 0.05, dist);\n\n    // return the distance to the sphere and the material ID\n    return vec2(dist, darken);\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(1.0);\n    res.x = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.5);\n    res.y = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n// this is the combined scene sdf function for the shadow ray.\n// it returns a vec2 containing a depth value for the x coordinate, and a material ID for the y coordinate.\nvec", "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march the ray in the scene\n    vec4 color = vec4(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = camPos + rayDir * t;\n        vec4 s = scene(p);\n        color += s;\n        t += s.a;\n        if (t > MAX_DIST || s.a < 0.001) break;\n    }\n    \n    // return the color of the ray\n    return color;\n}\n\n// raymarches our scene with a provided camera position, camera direction, and simple directional light\nvec", "\n\tvec3 bmin = rad;\n\tvec3 bmax = -rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(max(t1.x, t1.y), t1.z);\n\tfloat tN = min(min(t2.x, t2.y), t2.z);\n\tif (t0 > tN) return vec2(-1.0);\n\treturn vec2(t0, tN);\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// raymarching\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n", "\n    return dot(plane.normal, pos) - plane.distance;\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat", " cell coordinates\n    ivec3 gx = ix;\n    // grid cell coordinates offset by 1\n    ivec3 gy = ix + ivec3(1, 1, 1);\n    // grid cell coordinates offset by 2\n    ivec3 gz = ix + ivec3(2, 2, 2);\n    // grid cell coordinates offset by 3\n    ivec3 gw = ix + ivec3(3, 3, 3);\n    // grid cell coordinates offset by 4\n    ivec3 gx1 = ix + ivec3(4, 4, 4);\n    // grid cell coordinates offset by 5\n    ivec3 gy1 = ix + ivec3(5, 5, 5);\n    // grid cell coordinates offset by 6\n    ivec3 gz1 = ix + ivec3(6, 6, 6);\n    // grid cell coordinates offset by 7\n    ivec3 gw1 = ix + ivec3(7, 7, 7);\n    // grid cell coordinates offset by 8\n    ivec3 gx2 = ix + ivec3(8, 8, 8);\n    // grid cell coordinates offset by 9\n    ivec3 gy2 = ix + ivec3(9, 9, 9);\n    // grid cell coordinates offset by 10\n    ivec3 gz2 = ix + ivec3(10, 10, 10);\n    // grid cell coordinates offset by 11\n    ivec3 gw2 = ix + ivec3(11, 11, 11);\n    // grid cell coordinates offset by 12\n    ivec3 gx3 = ix + ivec3(12, 12, 12);\n    // grid cell coordinates offset by 13\n    ivec3 gy3 = ix + ivec3(13, 13, 13);\n    // grid cell coordinates offset by 14\n    ivec3 gz3 = ix + ivec3(14, 14, 14);\n    // grid cell coordinates", "\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we", "\n    float s = sin(p.x);\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    float d = length(p) - r;\n\n    // Slice shift effect (only applied on instance of capsule)\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    d = max(d, -p.x);\n\n    // Return the distance to the capsule\n    return d;\n}\n\nfloat", "\n     p.xz = mat2(cos(time),sin(time),-sin(time),cos(time))*p.xz;\n     p.xz += vec2(sin(time),cos(time))*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2", "\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.  , 0.001)\n  // eps.xyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxy <=> vec3(0.  , 0.001, 0.001)\n  // eps.yyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.yyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0", "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat", "\n    vec4 q = vec4( rd.x, rd.y, rd.z, -ra*ra );\n    vec4 k = vec4( 1.0, 1.0, 1.0, -4.0 );\n    vec4 u = solveQuartic( q, k );\n\n    // -----------------------------\n    // check if ray intersects sphere\n    // -----------------------------\n    float tmin = u.x;\n    float tmax = u.y;\n    if( tmin > tmax )\n    {\n        return -1.0;\n    }\n\n    // -----------------------------\n    // compute sphere intersection\n    // -----------------------------\n    float t = tmin;\n    vec3 p = ro + t*rd;\n    float d = length( p );\n    if( d > ra )\n    {\n        return -1.0;\n    }\n\n    return t;\n}\n\n// -----------------------------\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // gradient\n    vec2 g = dpdx*f.x + dpdy*f.y;\n    g = f*f*(3.0-2.0*f);\n\n    // sum\n    return dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[5].center.x = -1.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = 0.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[6].center.x = 1.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and t", "\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n", "\n    vec3 nearestHitPos = vec3(0.0);\n    vec3 nearestHitNormal = vec3(0.0);\n    vec3 nearestHitK_rg = vec3(0.0);\n    float nearestHitT = INFINITY;\n    for ( int i = 0; i < scene.numObjects; i++ ) {\n        Intersection_t hit = IntersectRay( ray, scene.objects[i] );\n        if ( hit.t < nearestHitT ) {\n            nearestHitT = hit.t;\n            nearestHitPos = hit.pos;\n            nearestHitNormal = hit.normal;\n            nearestHitK_rg = hit.k_rg;\n        }\n    }\n\n    // If there is no intersection, return the background color.\n    if ( nearestHitT == INFINITY ) {\n        hasHit = false;\n        hitPos = vec3(0.0);\n        hitNormal = vec3(0.0);\n        k_rg = vec3(0.0);\n        return scene.backgroundColor;\n    }\n\n    // If there is intersection, compute the color at the hit point.\n    hasHit = true;\n    hitPos = nearestHitPos;\n    hitNormal = nearestHitNormal;\n    k_rg = nearestHitK_rg;\n\n    // Compute the color at the hit point using Phong Lighting Model.\n    vec3 color = vec3(0.0);\n    for ( int i = 0; i < scene.numLights; i++ ) {\n        // Compute the shadow ray.\n        Ray_t shadowRay = Ray_t( nearestHitPos, scene.lights[i].pos - nearestHitPos );\n\n        // Find whether the shadow ray hits any object.\n        bool shadowHit = false;\n        for ( int j = 0; j < scene.numObjects; j++ ) {\n            Intersection_t shadowHit = IntersectRay( shadowRay, scene.objects[j] );\n            if ( shadowHit.t < scene.objects[j].radius ) {\n                shadowHit = true;\n                break;\n            }\n        }\n\n        // If the shadow", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n\n    // shadow accumulator\n    float shade = 0.0;\n\n    // number of steps\n    const int steps = 100;\n\n    // step size\n    float d = 1.0 / float(steps);\n\n    // step count\n    int i = 0;\n\n    // loop\n    for( ; i < steps; i++ )\n    {\n        // get the current position\n        vec3 p = ro + rd * tmax;\n\n        // get the current depth\n        float t = texture( shadowMap, p.xy ).x;\n\n        // if the current depth is greater than the current bounding volume\n        // then we have a shadow\n        if( t > bv.z )\n        {\n            // add the current depth to the accumulator\n            shade += t - bv.z;\n\n            // if the current depth is less than the minimum depth then we\n            // have a shadow\n            if( t < mint )\n            {\n                // we are done\n                break;\n            }\n\n            // update the bounding volume\n            bv = bv + vec4(rd * d, 0.0);\n        }\n\n        // update the maximum depth\n        tmax -= d;\n    }\n\n    // return the shadow\n    return shade / float(i);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat", "\n    start += planet_position;\n\n    // the color of the rayleigh scattering\n    vec3 rayleigh_color = vec3(0.0);\n\n    // the color of the mie scattering\n    vec3 mie_color = vec3(0.0);\n\n    // the color of the absorption\n    vec3 absorption_color = vec3(0.0);\n\n    // the color of the ambient\n    vec3 ambient_color = vec3(0.0);\n\n    // the color of the final result\n    vec3 final_color = vec3(0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0);\n\n    // the color of the atmosphere\n    vec3 atmosphere_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_2 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_2 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_3 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_3 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_4 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_4 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_5 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_5 = vec3(0", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // sample the skylight\n    vec3 skylight_sample = texture(skylight_tex, sample_pos.xy).rgb;\n\n    // sample the skylight in the direction of the light direction\n    vec3 skylight_sample_light = texture(skylight_tex, sample_pos.xy + light_dir_bend * 0.001).rgb;\n\n    // mix the skylight samples\n    vec3 skylight_mix = mix(skylight_sample, skylight_sample_light, 0.5);\n\n    // mix the skylight with the background color\n    vec3 skylight_mix_background = mix(skylight_mix, background_col, 0.5);\n\n    return skylight_mix_background;\n}\n\n/*\nThe atmosphere function takes in a sample position and a surface normal and returns the color of the atmosphere\n*/\nvec", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the distance to the surface\n    float dist = length(pos);\n    \n    // the color of the sphere\n    vec3 sphere_color = vec3(0.0, 1.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_2 = vec3(0.0, 0.0, 1.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_3 = vec3(1.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_4 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_5 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_6 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_7 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_8 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_9 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_10 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_11 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_12 = vec3(0.0, 0.0", " and position\n    vec3 camPos = cameraPos;\n    vec3 camDir = cameraDir;\n    \n    // get the light dir\n    vec3 lightDir = normalize(lightDir);\n    \n    // get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // get the ray origin\n    vec3 rayOrigin = camPos;\n    \n    // get the ray length\n    float rayLength = 1000.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray step\n    float rayStep = 0.001;\n    \n    // get the ray step\n    float rayStep2 = 0.0001;\n    \n    // get the ray step\n    float rayStep3 = 0.00001;\n    \n    // get the ray step\n    float rayStep4 = 0.000001;\n    \n    // get the ray step\n    float rayStep5 = 0.0000001;\n    \n    // get the ray step\n    float rayStep6 = 0.00000001;\n    \n    // get the ray step\n    float rayStep7 = 0.000000001;\n    \n    // get the ray step\n    float rayStep8 = 0.0000000001;\n    \n    // get the ray step\n    float rayStep9 = 0.00000000001;\n    \n    // get the ray step\n    float rayStep10 = 0.000000000001;\n    \n    // get the ray step\n    float rayStep11 = 0.0000000000001;\n    \n    // get the ray step\n    float rayStep12 = 0.00000000000001;\n    \n    // get the ray step\n    float rayStep13 = 0.000000000000001;\n    \n    //", "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float d = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (d < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the two roots\n    float root1 = -b - sqrt(d);\n    float root2 = -b + sqrt(d);\n\n    // Return the smaller root\n    if (root1 < 0.0) {\n        return root2;\n    }\n    if (root2 < 0.0) {\n        return root1;\n    }\n    return min(root1, root2);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat", "ialize variables\n    vec4 finalColor = vec4(0.0);\n    vec3 rayDir = normalize(cameraRayDir);\n    vec3 rayPos = cameraPos;\n    vec3 rayPos2 = cameraPos;\n    vec3 rayPos3 = cameraPos;\n    vec3 rayPos4 = cameraPos;\n    vec3 rayPos5 = cameraPos;\n    vec3 rayPos6 = cameraPos;\n    vec3 rayPos7 = cameraPos;\n    vec3 rayPos8 = cameraPos;\n    vec3 rayPos9 = cameraPos;\n    vec3 rayPos10 = cameraPos;\n    vec3 rayPos11 = cameraPos;\n    vec3 rayPos12 = cameraPos;\n    vec3 rayPos13 = cameraPos;\n    vec3 rayPos14 = cameraPos;\n    vec3 rayPos15 = cameraPos;\n    vec3 rayPos16 = cameraPos;\n    vec3 rayPos17 = cameraPos;\n    vec3 rayPos18 = cameraPos;\n    vec3 rayPos19 = cameraPos;\n    vec3 rayPos20 = cameraPos;\n    vec3 rayPos21 = cameraPos;\n    vec3 rayPos22 = cameraPos;\n    vec3 rayPos23 = cameraPos;\n    vec3 rayPos24 = cameraPos;\n    vec3 rayPos25 = cameraPos;\n    vec3 rayPos26 = cameraPos;\n    vec3 rayPos27 = cameraPos;\n    vec3 rayPos28 = cameraPos;\n    vec3 rayPos29 = cameraPos;\n    vec3 rayPos30 = cameraPos;\n    vec3 rayPos31 = cameraPos;\n    vec3 rayPos32 = cameraPos;\n    vec3 rayPos33 = cameraPos;\n    vec3 rayPos34 = cameraPos;\n    vec3 rayPos35 = cameraPos;\n    vec3 rayPos36 = cameraPos;\n    vec3 rayPos37 = cameraPos;\n    vec3 ray", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    vec3 ray_path[MAX_PATHS];\n    ray_path[0] = ray_origin;\n\n    // Initialize the sample color -\n    // the color of the sample ray\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the sample depth -\n    // the depth of the sample ray\n    float sample_depth = 0.0;\n\n    // Initialize the sample index -\n    // the index of the sample ray in the ray path list\n    int sample_index = 0;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray = ray_target;\n\n    // Initialize the sample ray direction -\n    // the direction of the sample ray\n    vec3 sample_ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the sample ray length -\n    // the length of the sample ray\n    float sample_ray_length = length(ray_target - ray_origin);\n\n    // Initialize the sample ray length squared -\n    // the length of the sample ray squared\n    float sample_ray_length_squared = sample_ray_length * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed = sample_ray_length_squared * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root = sqrt(sample_ray_length_cubed);\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv = 1.0 / sample_ray_length_cubed_root;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv_2 = sample_ray_length_cubed_root_inv * sample_", "\n    int cellID = int(p.x) + int(p.y) * 10;\n    vec2 cellCoords = vec2(p.x, p.y);\n    \n    // Local cell coordinates.\n    vec2 cellCoordsLocal = cellCoords - vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1].\n    vec2 cellCoordsLocalRange = cellCoordsLocal / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset.\n    vec2 cellCoordsLocalOffset = cellCoordsLocalRange + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenter = cellCoordsLocalOffset + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange = cellCoordsLocalOffsetCenter / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange2 = cellCoordsLocalOffsetCenterRange * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange3 = cellCoordsLocalOffsetCenterRange2 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange4 = cellCoordsLocalOffsetCenterRange3 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange5 = cellCoordsLocalOffset", "\n    vec3 sphere_loc = vec3(0.0, 0.0, 0.0);\n    float sphere_rad = 1.0;\n\n    // calculate distance from sphere\n    float dist = length(p - sphere_loc) - sphere_rad;\n\n    return dist;\n}\n\n// Get the color of the sphere\nvec", "\n    vec3 Pi0 = floor( P );\n    vec3 Pf0 = fract( P );\n\n    // calculate the distance from each corner to the point\n    vec3 uv0 = Pf0*Pf0*(3.0-2.0*Pf0);\n\n    // calculate the distance from each corner to the point\n    vec3 uv1 = Pf0*(1.0-Pf0)*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv2 = 1.0-Pf0*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv3 = 1.0-uv0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv4 = Pf0*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv5 = 1.0-uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv6 = Pf0*(1.0-uv4);\n\n    // calculate the distance from each corner to the point\n    vec3 uv7 = 1.0-uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv8 = Pf0*uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv9 = 1.0-uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv10 = Pf0*uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv11 = 1.0-uv10;\n\n    // calculate the distance from each corner to the point\n    vec3 uv12 = Pf0*uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv13 = 1.0-uv12;\n\n    // calculate the distance from each corner to the point\n    vec3 uv14 = Pf0", "\n    float n = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    // return noise\n    return mix(\n        noise(n),\n        noise(n + 1.0),\n        f\n    );\n}\n\n// 2D Perlin Noise\nfloat", "\n    vec3 ground = vec3(0.0, -0.001, 0.0);\n    vec3 ground_size = vec3(100.0, 0.001, 100.0);\n    vec3 ground_pos = vec3(0.0, -0.001, 0.0);\n    vec3 ground_rot = vec3(0.0, 0.0, 0.0);\n    vec3 ground_scale = vec3(1.0, 1.0, 1.0);\n    vec3 ground_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_normal = vec3(0.0, 1.0, 0.0);\n    vec3 ground_specular = vec3(0.0, 0.0, 0.0);\n    vec3 ground_shininess = 1.0;\n    vec3 ground_transparency = 1.0;\n    vec3 ground_reflection = 0.0;\n    vec3 ground_refraction = 0.0;\n    vec3 ground_emission = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light = vec3(0.0, 0.0, 0.0);\n    vec3 ground_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light_intensity = 0.0;\n    vec3 ground_light_radius = 0.0;\n    vec3 ground_light_angle = 0.0;\n    vec3 ground_light_falloff = 0.0;\n    vec3 ground_light_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color_attenuation = vec3(1.0, ", "\n    vec3 world = p;\n\n    // world to camera\n    vec3 cam = world - vec3(0.0, 0.0, 10.0);\n\n    // camera to screen\n    vec2 screen = cam.xy / cam.z * 0.5 + 0.5;\n\n    // screen to world\n    vec3 worldScreen = vec3(screen, 1.0);\n\n    // world to screen\n    vec2 worldScreen2 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen3 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen4 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen5 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen6 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen7 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen8 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen9 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen10 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen11 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen12 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen13 = worldScreen.xy / world", " from a to b\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return d + pix * length(pa - ba * t);\n}\n\nfloat", "\n\tvec2 st = fragCoord/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*st;\n\tfloat d = length(p);\n\tfloat a = atan(p.y,p.x);\n\tfloat r = (d-0.01)/0.02;\n\tfloat t = iTime*0.2;\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\tfloat m = mod(t,1.0);\n\tfloat n = mod(t,2.0);\n\tfloat k = mod(t,3.0);\n\tfloat l = mod(t,4.0);\n\tfloat o = mod(t,5.0);\n\tfloat p = mod(t,6.0);\n\tfloat q = mod(t,7.0);\n\tfloat r = mod(t,8.0);\n\tfloat s = mod(t,9.0);\n\tfloat t = mod(t,10.0);\n\tfloat u = mod(t,11.0);\n\tfloat v = mod(t,12.0);\n\tfloat w = mod(t,13.0);\n\tfloat x = mod(t,14.0);\n\tfloat y = mod(t,15.0);\n\tfloat z = mod(t,16.0);\n\tfloat a = mod(t,17.0);\n\tfloat b = mod(t,18.0);\n\tfloat c = mod(t,19.0);\n\tfloat d = mod(t,20.0);\n\tfloat e = mod(t,21.0);\n\tfloat f = mod(t,22.0);\n\tfloat g = mod(t,23.0);\n\tfloat h = mod(t,24.0);\n\tfloat i = mod(t,25.0);\n\tfloat j = mod(t,26.0);\n\tfloat k = mod(t,27.0);\n\tfloat l = mod(t,28.0);\n\tfloat m = mod(t,29.0);\n\tfloat n = mod(t,", "\n    if(p.y > 0.0){\n        return abs(p.x) + abs(p.y);\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    else{\n        return abs(p.x) + abs(p.y);\n    }\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat", "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\n// yea i basically spammed random stuff\nfloat", "\n    // by theta and phi to get the surface\n    float theta = atan(p.y, p.x);\n    float phi = asin(p.z);\n    float r = length(p);\n    float t = theta / 3.1415926535897932384626433832795;\n    float s = phi / 3.1415926535897932384626433832795;\n    // compute the color\n    return vec3(0.5 + 0.5 * cos(t + s), 0.5 + 0.5 * sin(t + s), 0.5 + 0.5 * cos(t - s));\n}\n\n// compute the color of a ray\nvec", "\n    p = p * 0.001;\n    // scale to 0-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p);\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, 1.0 - the integer coordinates of the four corners of T */\n\t vec3 i1 = step(vec3(0.0), x - vec3(0.0, 0.0, 1.0));\n\t vec3 i2 = step(vec3(1.0), x - vec3(1.0, 0.0, 1.0));\n\t vec3 i3 = step(vec3(1.0), x - vec3(1.0, 1.0, 1.0));\n\t vec3 i4 = step(vec3(0.0), x - vec3(0.0, 1.0, 1.0));\n\t \n\t /* calculate the contribution from the four corners */\n\t vec3 x1 = x - i1 + (i2 - i1) * vec3(0.0, 0.0, 1.0);\n\t vec3 x2 = x - i2 + (i3 - i2) * vec3(0.0, 0.0, 1.0);\n\t vec3 x3 = x - i3 + (i4 - i3) * vec3(0.0, 0.0, 1.0);\n\t vec3 x4 = x - i4 + (i1 - i4) * vec3(0.0, 0.0, 1.0);\n\t \n\t /* calculate the contribution from the four vertices */\n\t vec3 y0 = x - vec3(0.0, 0.0, 0.0);\n\t vec3 y1 = x - vec3(1.0, 0.0, 0.0);\n\t vec3 y2 = x - vec3(1.0, 1.0, 0.0);\n\t vec3 y3 = x - vec3(0.0, 1.0, 0.0);\n\t vec3 y4 = x - vec3(0.0, 0.", " of the rings\n    float ring = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet2 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet3 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet4 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet5 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet6 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet7 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet8 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet9 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet10 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet11 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet12 = sin( p.x * 10.0 ) * 0.5 + 0.5;", " in the final image\n    p.xz *= 0.5;\n    p.y -= 0.001;\n\n    // add some noise to the space\n    p.xz += noise( p.xy );\n    p.y += noise( p.xz );\n\n    // add some more noise to the space\n    p.xz += noise( p.yx );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add", "\n    float k = floor(rp.x*.75)*.25;\n    float s = sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.01);\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000005));\n    s = min(s, sd", "\n\tfloat t = clamp((end - d) / (end - start), 0.0, 1.0);\n\treturn mix(start, end, t);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat", "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    if (abs(p.x - floor(p.x)) < abs(p.y - floor(p.y)))\n    {\n        hexagonCenter = vec4(p.x, 0.0, 0.0, hexagonID);\n    }\n    else\n    {\n        hexagonCenter = vec4(0.0, p.y, 0.0, hexagonID);\n    }\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    return hexagonCenter;\n}\n\n//\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    vec2 r = vec2(random(p), random(p+vec2(1.0)));\n    \n    // The distance field.\n    vec2 d = vec2(0.0);\n    \n    // The distance field.\n    for(int i=0; i<2; i++){\n        for(int j=0; j<2; j++){\n            d += abs(r[j]-0.5);\n        }\n        r = rotate(r);\n    }\n    \n    // The distance field.\n    return d;\n}\n\n// The distance field.\nvec", "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0 && scale < 1.0) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 1.0 && scale < 2.0) {\n        color2 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 2.0 && scale < 3.0) {\n        color3 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color4 = vec3(0.0, 0.0, 0.0);\n    if (scale > 3.0 && scale < 4.0) {\n        color4 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (", " from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the", "\n    return smoothstep(pct-EPSILON, pct, st.y) - smoothstep(pct, pct+EPSILON, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat", "\n    //\n    // I'm not going to go into the details of the hyperbolic geometry here,\n    // but I'll say that the hyperbolic geometry is a bit more involved than\n    // the Euclidean geometry, so I'll leave that to you.\n\n    // The following is the number of polygon sides (N) and the number of adjacent\n    // polygons (Q) that meet at a vertex point.\n    int N = int(gl_FragCoord.x);\n    int Q = int(gl_FragCoord.y);\n\n    // The following is the radius of the initial circle.\n    float r = float(N);\n\n    // The following is the distance from the center of the initial circle to the\n    // center of the circle that runs adjacent to the current domain edges.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float a = float(Q);\n\n    // The following is the angle of the initial circle.\n    float b = float(Q);\n\n    // The following is the angle of the initial circle.\n    float c = float(Q);\n\n    // The following is the angle of the initial circle.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float e = float(Q);\n\n    // The following is the angle of the initial circle.\n    float f = float(Q);\n\n    // The following is the angle of the initial circle.\n    float g = float(Q);\n\n    // The following is the angle of the initial circle.\n    float h = float(Q);\n\n    // The following is the angle of the initial circle.\n    float i = float(Q);\n\n    // The following is the angle of the initial circle.\n    float j = float(Q);\n\n    // The following is the angle of the initial circle.\n    float k = float(Q);\n\n    // The following is the angle of the initial circle.\n    float l = float(Q);\n\n    // The following is the angle of the initial circle.\n    float m = float(Q);\n\n    // The following is the angle of the initial circle.\n    float n = float(", "\n    float ia =.5/float(N);\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = mod(a + ia, 2.0*pi);\n    float s = sign(c - a);\n    float r2 = sqrt(r);\n    float c2 = mod(c + ia, 2.0*pi);\n    float s2 = sign(c2 - c);\n    float r3 = sqrt(r2);\n    float c3 = mod(c2 + ia, 2.0*pi);\n    float s3 = sign(c3 - c2);\n    float r4 = sqrt(r3);\n    float c4 = mod(c3 + ia, 2.0*pi);\n    float s4 = sign(c4 - c3);\n    float r5 = sqrt(r4);\n    float c5 = mod(c4 + ia, 2.0*pi);\n    float s5 = sign(c5 - c4);\n    float r6 = sqrt(r5);\n    float c6 = mod(c5 + ia, 2.0*pi);\n    float s6 = sign(c6 - c5);\n    float r7 = sqrt(r6);\n    float c7 = mod(c6 + ia, 2.0*pi);\n    float s7 = sign(c7 - c6);\n    float r8 = sqrt(r7);\n    float c8 = mod(c7 + ia, 2.0*pi);\n    float s8 = sign(c8 - c7);\n    float r9 = sqrt(r8);\n    float c9 = mod(c8 + ia, 2.0*pi);\n    float s9 = sign(c9 - c8);\n    float r10 = sqrt(r9);\n    float c10 = mod(c9 + ia, 2.0*pi);\n    float s10 = sign(c10 - c9);\n    float r11 = sqrt(r10);\n    float c11", "\n    vec2 m = vec2(mouseX, mouseY);\n    \n    // Mouse position inverted.\n    vec2 mInv = vec2(1.0 - m.x, 1.0 - m.y);\n    \n    // Mouse position inverted.\n    return mInv - p;\n}\n\n// Mouse pointer inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t// Camera\n\tvec3 ro = vec3( 0.0, 0.0, 1.0 );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n\tvec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 vv = normalize( cross(uu,ww));\n\t\n\t// Camera Movement\n\tfloat speed = 0.01;\n\tfloat rotSpeed = 0.002;\n\tfloat zoomSpeed = 0.0001;\n\tfloat zoom = 1.0;\n\t\n\t// Camera Rotation\n\tfloat rotX = iTime * rotSpeed;\n\tfloat rotY = iTime * rotSpeed;\n\t\n\t// Camera Zoom\n\tfloat zoomAmount = iMouse.z * zoomSpeed;\n\t\n\t// Camera Movement\n\tfloat moveSpeed = speed * zoom;\n\t\n\t// Camera Movement\n\tro += moveSpeed * ( p.x*uu + p.y*vv );\n\t\n\t// Camera Rotation\n\trotY += p.x * rotSpeed;\n\trotX += p.y * rotSpeed;\n\t\n\t// Camera Rotation\n\tvec3 vp = vec3( sin(rotY)*cos(rotX), cos(rotY), sin(rotY)*sin(rotX) );\n\tww = normalize( ta - ro );\n\tuu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvv = normalize( cross(uu,ww));\n\t\n\t// Light\n\tvec3 light = vec3( 0.0, 0.0, 1.0 );\n\t\n\t// Light\n\tvec3 col = vec3( 0.0 );\n\t\n\t// Light\n\tvec3 n = normalize( vec3", "\n\n    // Get the position of the pixel in the image.\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the polar coordinate system.\n    vec2 q = vec2(\n        atan(p.y - 0.5, p.x - 0.5) / 3.1415926535897932384626433832795,\n        length(p - 0.5)\n    );\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb = hsv2rgb(hsb);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb2 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb2 = hsv2rgb(hsb2);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb3 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb3 = hsv2rgb(hsb3);\n\n    // Get the position of the pixel in the HSB colour space.\n   ", " axis\n    vec3 v = vec3(\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0\n    );\n    \n    // Gradient set is a normalized expanded rhombic dodecahedron\n    return normalize(v);\n}\n\n// Hash function\nfloat", "\n    vec3 Y = normalize(cross(X.xy, X.zx));\n    vec3 Z = normalize(cross(Y, X));\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(", "\n  float d = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d5 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d6 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d8 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d9 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d11 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d12 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d13 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d14 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d15 = length(p.xy) - 1.0;\n  // distance from", "\n    float t = dot( targetPos - ray.ro, ray.rd ) / dot( ray.rd, ray.rd );\n    return ray.ro + t * ray.rd;\n}\n\n// \uc810\uc5d0\uc11c \ubc18\uc0ac\ub418\ub294 \uc0c9\uc0c1\uc744 \uad6c\ud55c\ub2e4.\nvec", "\n\tmat2 rot = mat2(cos(iGlobalTime), -sin(iGlobalTime), sin(iGlobalTime), cos(iGlobalTime));\n\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the pixel color\n\tvec3 color = vec3(0.0);\n\tcolor += texture(iChannel0, uv).rgb;\n\tcolor += texture(iChannel1, uv).rgb;\n\tcolor += texture(iChannel2, uv).rgb;\n\tcolor += texture(iChannel3, uv).rgb;\n\tcolor += texture(iChannel4, uv).rgb;\n\tcolor += texture(iChannel5, uv).rgb;\n\tcolor += texture(iChannel6, uv).rgb;\n\tcolor += texture(iChannel7, uv).rgb;\n\tcolor += texture(iChannel8, uv).rgb;\n\tcolor += texture(iChannel9, uv).rgb;\n\tcolor += texture(iChannel10, uv).rgb;\n\tcolor += texture(iChannel11, uv).rgb;\n\tcolor += texture(iChannel12, uv).rgb;\n\tcolor += texture(iChannel13, uv).rgb;\n\tcolor += texture(iChannel14, uv).rgb;\n\tcolor += texture(iChannel15, uv).rgb;\n\tcolor += texture(iChannel16, uv).rgb;\n\tcolor += texture(iChannel17, uv).rgb;\n\tcolor += texture(iChannel18, uv).rgb;\n\tcolor += texture(iChannel19, uv).rgb;\n\tcolor += texture(iChannel20, uv).rgb;\n\tcolor += texture(iChannel21, uv).rgb;\n\tcolor += texture(iChannel22, uv).rgb;\n\tcolor += texture(iChannel23, uv).rgb;\n\tcolor += texture(iChannel24, uv).rgb;\n\tcolor += texture(iChannel25, uv).rgb", "-Normal-TexCoord\n    vec4 pos = vec4(p, 1.0);\n    pos.xyz += vec3(0.0, 0.0, 0.0);\n    pos.w = 1.0;\n    return pos;\n}\n\n//---Essential Fragment Function\nvec", "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, lightDir ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotV2 = NdotV * NdotV;\n    float NdotV4 = NdotV2 * NdotV2;\n    float NdotV6 = NdotV4 * NdotV2;\n    float NdotV8 = NdotV6 * NdotV2;\n    \n    float NdotL2 = NdotL * NdotL;\n    float NdotL4 = NdotL2 * NdotL2;\n    float NdotL6 = NdotL4 * NdotL2;\n    float NdotL8 = NdotL6 * NdotL2;\n    \n    float NdotH2_4 = NdotH2 * NdotH4;\n    float NdotH2_6 = NdotH2_4 * NdotH6;\n    float NdotH2_8 = NdotH2_6 * NdotH8;\n    \n    float NdotV2_4 = NdotV2 * NdotV4;\n    float NdotV2_6 = NdotV2_4 * NdotV6;\n    float NdotV2_8 = NdotV2_6 * NdotV8;\n    \n    float NdotL", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / ", "\n    float n0 = 0.0; // noise accumulator\n    float n1 = 0.0;\n    float n2 = 0.0;\n    float n3 = 0.0;\n    float n4 = 0.0;\n    float n5 = 0.0;\n    float n6 = 0.0;\n    float n7 = 0.0;\n    float n8 = 0.0;\n    float n9 = 0.0;\n    float n10 = 0.0;\n    float n11 = 0.0;\n    float n12 = 0.0;\n    float n13 = 0.0;\n    float n14 = 0.0;\n    float n15 = 0.0;\n    float n16 = 0.0;\n    float n17 = 0.0;\n    float n18 = 0.0;\n    float n19 = 0.0;\n    float n20 = 0.0;\n    float n21 = 0.0;\n    float n22 = 0.0;\n    float n23 = 0.0;\n    float n24 = 0.0;\n    float n25 = 0.0;\n    float n26 = 0.0;\n    float n27 = 0.0;\n    float n28 = 0.0;\n    float n29 = 0.0;\n    float n30 = 0.0;\n    float n31 = 0.0;\n    float n32 = 0.0;\n    float n33 = 0.0;\n    float n34 = 0.0;\n    float n35 = 0.0;\n    float n36 = 0.0;\n    float n37 = 0.0;\n    float n38 = 0.0;\n    float n39 = 0.0;\n    float n40 = 0.0;\n    float n41 = 0.0;\n    float n42 = 0.0;\n    float n43 = 0.0;\n    float n44 = 0.0;\n    float n45 = 0.0;\n    float n46 = 0.0;\n", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    \n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    \n    return (v >= 0.0f && v <= 1.0f && w >= 0.0f && w <= 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec", "\n    float n = log(start_radius)/log(1.5);\n    \n    //Find the closest hexagon to the point\n    int closest_hex = (int)n;\n    for(int i=0; i<closest_hex; i++){\n        n = log(start_radius)/log(1.5);\n        closest_hex = (int)n;\n    }\n    \n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint", ".\n    //n-2 of next hexagon, and n-1 of cur hexagon.\n    //n-3 of next hexagon, and n of cur hexagon.\n    //n-4 of next hexagon, and n-1 of next hexagon.\n    //n-5 of next hexagon, and n-2 of next hexagon.\n    //n-6 of next hexagon, and n-3 of next hexagon.\n    //n-7 of next hexagon, and n-4 of next hexagon.\n    //n-8 of next hexagon, and n-5 of next hexagon.\n    //n-9 of next hexagon, and n-6 of next hexagon.\n    //n-10 of next hexagon, and n-7 of next hexagon.\n    //n-11 of next hexagon, and n-8 of next hexagon.\n    //n-12 of next hexagon, and n-9 of next hexagon.\n    //n-13 of next hexagon, and n-10 of next hexagon.\n    //n-14 of next hexagon, and n-11 of next hexagon.\n    //n-15 of next hexagon, and n-12 of next hexagon.\n    //n-16 of next hexagon, and n-13 of next hexagon.\n    //n-17 of next hexagon, and n-14 of next hexagon.\n    //n-18 of next hexagon, and n-15 of next hexagon.\n    //n-19 of next hexagon, and n-16 of next hexagon.\n    //n-20 of next hexagon, and n-17 of next hexagon.\n    //n-21 of next hexagon, and n-18 of next hexagon.\n    //n-22 of next hexagon, and n-19 of next hexagon.\n    //n-23 of next hexagon, and n-20 of next hexagon.\n    //n-24 of next hexagon, and n-21 of next hexagon.\n    //n-25 of next hexagon, and n-22 of next hexagon.\n    //n", ".\n    //n+2 of cur hexagon, n+3 of cur hexagon, and n+4 of cur hexagon.\n    //n+5 of cur hexagon, n+6 of cur hexagon, and n+7 of cur hexagon.\n    //n+8 of cur hexagon, n+9 of cur hexagon, and n+10 of cur hexagon.\n    //n+11 of cur hexagon, n+12 of cur hexagon, and n+13 of cur hexagon.\n    //n+14 of cur hexagon, n+15 of cur hexagon, and n+16 of cur hexagon.\n    //n+17 of cur hexagon, n+18 of cur hexagon, and n+19 of cur hexagon.\n    //n+20 of cur hexagon, n+21 of cur hexagon, and n+22 of cur hexagon.\n    //n+23 of cur hexagon, n+24 of cur hexagon, and n+25 of cur hexagon.\n    //n+26 of cur hexagon, n+27 of cur hexagon, and n+28 of cur hexagon.\n    //n+29 of cur hexagon, n+30 of cur hexagon, and n+31 of cur hexagon.\n    //n+32 of cur hexagon, n+33 of cur hexagon, and n+34 of cur hexagon.\n    //n+35 of cur hexagon, n+36 of cur hexagon, and n+37 of cur hexagon.\n    //n+38 of cur hexagon, n+39 of cur hexagon, and n+40 of cur hexagon.\n    //n+41 of cur hexagon, n+42 of cur hexagon, and n+43 of cur hexagon.\n    //n+44 of cur hexagon, n+45 of cur hexagon, and n+46 of cur hexagon.\n    //n+47 of cur hexagon, n+48 of cur hexagon, and n+49 of cur hexagon.\n    //n+50 of cur hexagon, n+51 of cur hexagon, and n", "\n    float p = exp(-d);\n    float sum = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        float x = InverseTransformSampling(U);\n        sum += x;\n    }\n    return sum / 1000.0;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "'s implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash6(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);", "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n  const float epsilon = 0.0001;\n\n  // compute normal vector\n  vec3 normal = vec3(0.0);\n  normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n  normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n  normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n  return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat", "\n  vec3 p = castRay(ro, rd);\n  // get color of nearest object\n  vec3 col = getColor(p);\n  // get normal of nearest object\n  vec3 n = getNormal(p);\n  // get specular value of nearest object\n  float s = getSpecular(p);\n  // get diffuse value of nearest object\n  float d = getDiffuse(p);\n  // get ambient value of nearest object\n  float a = getAmbient(p);\n  // get reflection value of nearest object\n  float r = getReflection(p);\n  // get refraction value of nearest object\n  float t = getRefraction(p);\n  // get refractive index of nearest object\n  float i = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get", "\n    const float epsilon = 0.0001;\n    vec3 normal = vec3(0.0);\n    normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n    normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n    normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n    return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat", "\n    vec3 p = castRay(ro, rd);\n    // get color of nearest object\n    vec3 col = getColor(p);\n    // get normal of nearest object\n    vec3 n = getNormal(p);\n    // get specular value of nearest object\n    float s = getSpecular(p);\n    // get diffuse value of nearest object\n    float d = getDiffuse(p);\n    // get ambient value of nearest object\n    float a = getAmbient(p);\n    // get reflection value of nearest object\n    vec3 r = getReflection(p, rd);\n    // get refraction value of nearest object\n    vec3 t = getRefraction(p, rd);\n    // get refractive index of nearest object\n    float i = getRefractiveIndex(p);\n    // get refractive index of nearest object\n    float rf = getRefractiveFactor(p);\n    // get refractive index of nearest object\n    float rt = getRefractiveTransmittance(p);\n    // get refractive index of nearest object\n    float rt2 = getRefractiveTransmittance2(p);\n    // get refractive index of nearest object\n    float rt3 = getRefractiveTransmittance3(p);\n    // get refractive index of nearest object\n    float rt4 = getRefractiveTransmittance4(p);\n    // get refractive index of nearest object\n    float rt5 = getRefractiveTransmittance5(p);\n    // get refractive index of nearest object\n    float rt6 = getRefractiveTransmittance6(p);\n    // get refractive index of nearest object\n    float rt7 = getRefractiveTransmittance7(p);\n    // get refractive index of nearest object\n    float rt8 = getRefractiveTransmittance8(p);\n    // get refractive index of nearest object\n    float rt9 = getRefractiveTransmittance9(p);\n    // get refractive index of nearest object\n    float rt10 = getRefractiveTransmittance10(p);\n    //", "\n    vec3 color = texture(texture_diffuse1, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color2 = texture(texture_diffuse2, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color3 = texture(texture_diffuse3, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color4 = texture(texture_diffuse4, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color5 = texture(texture_diffuse5, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color6 = texture(texture_diffuse6, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color7 = texture(texture_diffuse7, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color8 = texture(texture_diffuse8, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color9 = texture(texture_diffuse9, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color10 = texture(texture_diffuse10, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color11 = texture(texture_diffuse11, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color12 = texture(texture_diffuse12, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color13 = texture(texture_diffuse13, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color14 = texture(texture_diffuse14, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color15 = texture(texture_diffuse15, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color", "\n    // This is a simple hash function for 2D integer coordinates.\n    // It is not optimized for speed, but it is good enough for our purposes.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it", "el\n\tvec2 texel = vec2( 1.0 / 16.0 );\n\tvec2 coord1 = coord;\n\tvec2 coord2 = coord + texel;\n\tvec2 coord3 = coord + texel * 2.0;\n\tvec2 coord4 = coord + texel * 3.0;\n\tvec2 coord5 = coord + texel * 4.0;\n\tvec2 coord6 = coord + texel * 5.0;\n\tvec2 coord7 = coord + texel * 6.0;\n\tvec2 coord8 = coord + texel * 7.0;\n\tvec2 coord9 = coord + texel * 8.0;\n\tvec2 coord10 = coord + texel * 9.0;\n\tvec2 coord11 = coord + texel * 10.0;\n\tvec2 coord12 = coord + texel * 11.0;\n\tvec2 coord13 = coord + texel * 12.0;\n\tvec2 coord14 = coord + texel * 13.0;\n\tvec2 coord15 = coord + texel * 14.0;\n\tvec2 coord16 = coord + texel * 15.0;\n\n\tvec3 color1 = texture( texture1, coord1 ).rgb;\n\tvec3 color2 = texture( texture1, coord2 ).rgb;\n\tvec3 color3 = texture( texture1, coord3 ).rgb;\n\tvec3 color4 = texture( texture1, coord4 ).rgb;\n\tvec3 color5 = texture( texture1, coord5 ).rgb;\n\tvec3 color6 = texture( texture1, coord6 ).rgb;\n\tvec3 color7 = texture( texture1, coord7 ).rgb;\n\tvec3 color8 = texture( texture1, coord8 ).rgb;\n\tvec3 color9 = texture( texture1, coord9 ).rgb;\n\tvec3 color10 = texture( texture1, coord10 ).rgb;\n\tvec3 color11 = texture( texture1, coord11 ).rg", "\n    p.x = abs(p.x);\n\n    // rotate\n    float c = cos(p.y);\n    float s = sin(p.y);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    p = fract(p * 0.1031);\n    p *= 33.33;\n    p += fract(p * 2.02);\n    return fract(vec3(p, p + 2.33, p + 3.23));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the pixel\n    vec2 pixel = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy", "\n    float t = 0.0;\n    float tmin = 1000000.0;\n    float tmax = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t43 = 0.0;\n    float", "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t - s, cn*sn),\n        vec3(sn*ct, sn*s, cn*ct*t + s)\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray-Marching\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.0;\n    float tmin_tmax = 0.0;\n    float tmin_tmax_t = 0.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t", "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Origin of the Ray\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n", "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Origin\n    raypos = rayori;\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n    // Set the Ray Length\n    float raylen = 100.0;\n    // Set the Ray Step Size\n    float raystep = 0.01;\n    // Set the Ray Step Count\n    float raystepcount = 0.0;\n    // Set the Ray Color\n    vec3 raycolor = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Distance\n    float raydist = 0.0;\n    // Set the Ray Distance Threshold\n    float raydistthresh = 0.001;\n    // Set the Ray Distance Threshold\n    float raydistthresh2 = 0.0001;\n    // Set the Ray Distance Threshold\n    float raydistthresh3 = 0.00001;\n    // Set the Ray Distance Threshold\n    float raydistthresh4 = 0.000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh5 = 0.0000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh6 = 0.00000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh7 = 0.000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh8 = 0.0000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh9 = 0.00000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh10 = 0.000000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh11 = 0.0000000000001;\n    // Set the Ray Distance Threshold\n", "\n    float seed = iTime;\n    float rng = rand(seed);\n\n    // Initialize the image\n    vec3 color = vec3(0.0);\n\n    // Calculate the position of the pixel\n    vec2 pos = fragCoord.xy / iResolution.xy;\n\n    // Calculate the position of the pixel in the 3D space\n    vec3 p = vec3(pos.xy, rng);\n\n    // Calculate the ray direction\n    vec3 ray = normalize(vec3(pos.xy, 1.0));\n\n    // Calculate the ray origin\n    vec3 origin = vec3(0.0);\n\n    // Calculate the ray length\n    float length = 100.0;\n\n    // Calculate the ray color\n    vec3 rayColor = vec3(0.0);\n\n    // Calculate the ray step\n    float step = 0.001;\n\n    // Calculate the ray step\n    float step2 = 0.0001;\n\n    // Calculate the ray step\n    float step3 = 0.00001;\n\n    // Calculate the ray step\n    float step4 = 0.000001;\n\n    // Calculate the ray step\n    float step5 = 0.0000001;\n\n    // Calculate the ray step\n    float step6 = 0.00000001;\n\n    // Calculate the ray step\n    float step7 = 0.000000001;\n\n    // Calculate the ray step\n    float step8 = 0.0000000001;\n\n    // Calculate the ray step\n    float step9 = 0.00000000001;\n\n    // Calculate the ray step\n    float step10 = 0.000000000001;\n\n    // Calculate the ray step\n    float step11 = 0.0000000000001;\n\n    // Calculate the ray step\n    float step12 = 0.", "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the ray's direction\n    vec2 rayDir = vec2(travelRate, 0.0);\n\n    // Get the ray's position\n    vec2 rayPos = vec2(coord.x, 0.0);\n\n    // Get the ray's intensity\n    float rayIntensity = rayIntensity(rayPos, rayDir, frequency, travelRate, maxStrength);\n\n    // Return the ray's intensity\n    return rayIntensity * fade;\n}\n\n// rayIntensity: (position, direction, frequency, travel rate, max strength)\n// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// -----------------------------------------------\n", "\n\tvec2 d2 = d / 2.0;\n\tvec2 p2 = p - d2;\n\tvec2 p3 = p + d2;\n\tvec2 p4 = p + d;\n\tvec2 p5 = p - d;\n\tvec2 p6 = p + d2.yx;\n\tvec2 p7 = p - d2.yx;\n\tvec2 p8 = p + d2.xy;\n\tvec2 p9 = p - d2.xy;\n\tvec2 p10 = p + d.yx;\n\tvec2 p11 = p - d.yx;\n\tvec2 p12 = p + d.xy;\n\tvec2 p13 = p - d.xy;\n\tvec2 p14 = p + d2.yx + d2.xy;\n\tvec2 p15 = p - d2.yx + d2.xy;\n\tvec2 p16 = p + d2.yx - d2.xy;\n\tvec2 p17 = p - d2.yx - d2.xy;\n\tvec2 p18 = p + d2.xy + d2.yx;\n\tvec2 p19 = p - d2.xy + d2.yx;\n\tvec2 p20 = p + d2.xy - d2.yx;\n\tvec2 p21 = p - d2.xy - d2.yx;\n\tvec2 p22 = p + d.yx + d.xy;\n\tvec2 p23 = p - d.yx + d.xy;\n\tvec2 p24 = p + d.yx - d.xy;\n\tvec2 p25 = p - d.yx - d.xy;\n\tvec2 p26 = p + d.xy + d.yx;\n\tvec2 p27 = p - d.xy + d.yx;\n\tvec2 p28 = p + d.xy - d.yx;\n\tvec2 p29 = p - d.xy - d.yx;\n\tvec2 p30 = p + d2.yx +", "\n    return pow(color, vec3(2.2));\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n\n    // head\n    float d = length( ap - ab*h ) - w2;\n\n    // shaft\n    float s = length( ap - ab*h ) - w1;\n\n    return min(d,s);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    uv = uv - 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x);\n\n    //", "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX =", "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n", "\n   p = fract(p * 0.1031);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   return fract(vec3(p, p + 1.0, p + 2.0));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (", ", but I don't remember where.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //", "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Get the radius of the circle\n    float radius = iTime * 0.01;\n\n    // Get the distance from the center of the circle\n    float dist = distance(uv, vec2(0.5));\n\n    // Get the brightness of the circle\n    float brightness = (1.0 - dist) / radius;\n\n    // Set the color based on the brightness\n    col = vec3(brightness);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n"], "input_comment": ["\n\treturn (cos(a*TAU)+1)/2;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    float d = length(p);\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n    return length(p - voxelPos);\n}\n\n// Distance to the voxel\nfloat", "\n    vec3 q = p - scene.position;\n    float d = dot(q, q);\n    P = scene.position + q * scene.radius;\n    return vec2(d, scene.radius);\n}\n\n// Distance to the scene and color of the closest point\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        for (int j = 0; j < 10; j++) {\n            q = vec2(q.x * q.x - q.y * q.y, 2.0 * q.x * q.y) + vec2(0.0, 0.0);\n            d = length(q);\n            if (d > 2.0) break;\n        }\n        col += vec3(d < 1.0? 1.0 : 0.0);\n        p = q;\n    }\n    col /= 10.0;\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n// this is the main function that will be called by the shader\nvoid main()\n{\n    // get the position of the vertex\n    vec4 pos = gl_Vertex;\n\n    // get the position of the vertex in the texture\n    vec2 tex = (pos.xy / pos.w) * 0.5 + 0.5;\n\n    // get the color of the vertex\n    vec4 color = texture2D(tex_color, tex);\n\n    // get the color of the vertex\n    vec4 gradient_color = gradient(tex.x);\n\n    // get the color of the vertex\n    vec4 final_color = color * gradient_color;\n\n    // set the color of the vertex\n    gl_FragColor = final_color;\n}\n", "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// shade a point based on distance\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    vec3 lightColor = vec3(1.0);\n    float lightRadius = 0.0;\n    float lightIntensity = 0.0;\n    float lightFade = 0.0;\n    float lightFadeEnd = 0.0;\n    float lightFadeStart = 0.0;\n    float lightFadeStep = 0.0;\n    float lightFadeStepEnd = 0.0;\n    float lightFadeStepStart = 0.0;\n    float lightFadeStepStartEnd = 0.0;\n    float lightFadeStepStartEndEnd = 0.0;\n    float lightFadeStepStartEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        float a = 0.0;\n        for (int j = 0; j < 10; j++) {\n            q = abs(q);\n            q = q - 0.5;\n            a += length(q);\n        }\n        d = min(d, a);\n        p = p * 2.0 - 1.0;\n    }\n    col = vec3(d);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float n = 0.0;\n    float f = 1.0;\n    for (int i = 0; i < NUM_LAYERS; i++) {\n        n += f * fbm(p);\n        p *= 2.0;\n        f *= 0.5;\n    }\n    return n;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(i,vec2(1.0,0.0)),i.y,u.x),\n                   mix(dot(i+vec2(0.0,1.0),vec2(1.0,0.0)),i.x,u.x),u.y),\n               mix(mix(dot(i+vec2(1.0,1.0),vec2(1.0,1.0)),i.y,u.x),\n                   mix(dot(i+vec2(1.0,0.0),vec2(1.0,1.0)),i.x,u.x),u.y),f.y);\n}\n\n//\n// This is a modified version of the Voronoi3Tap function. It is used to generate a\n// 3D Voronoi noise field.\n//\n// The original Voronoi3Tap function is a 2D function. This modified version is a 3D\n// function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a", "\n    // The 2D Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point", "\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n   ", "\n    // find the closest object\n    float t = -1.0;\n    vec2 closest = vec2(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < objects[i].radius && d < t)\n        {\n            t = d;\n            closest = objects[i].position;\n        }\n    }\n\n    // move the object/shape by messing with p\n    if (t > 0.0)\n    {\n        p = closest;\n    }\n\n    // find the closest point on the plane\n    float t2 = -1.0;\n    vec2 closest2 = vec2(0.0);\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float d = distance(p, planes[i].position);\n        if (d < planes[i].radius && d < t2)\n        {\n            t2 = d;\n            closest2 = planes[i].position;\n        }\n    }\n\n    // move the plane by messing with p\n    if (t2 > 0.0)\n    {\n        p = closest2;\n    }\n\n    // find the closest point on the circle\n    float t3 = -1.0;\n    vec2 closest3 = vec2(0.0);\n    for (int i = 0; i < NUM_CIRCLES; i++)\n    {\n        float d = distance(p, circles[i].position);\n        if (d < circles[i].radius && d < t3)\n        {\n            t3 = d;\n            closest3 = circles[i].position;\n        }\n    }\n\n    // move the circle by messing with p\n    if (t3 > 0.0)\n    {\n        p = closest3;\n    }\n\n    // find the closest point on the triangle\n    float t4 = -1.0;\n    vec2 closest4 = vec2(0.0);\n    for (int i = 0; i <", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\t", "\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/", "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n\n    // ray-triangle intersection\n    vec3 pt2 = ro + t * rd;\n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 n = cross(e1, e2);\n    vec3 p1 = sphere.xyz + n * sphere.w;\n    vec3 p2 = sphere.xyz - n * sphere.w;\n    vec3 p3 = pt2;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    vec3 v3 = pt2 - p1;\n    float s = sign(dot(n, cross(v1, v2)));\n    if (s < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.", "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(texture_normal, p2).rgb;\n                n += oN2 - oN;\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// output --> averaged? out normal vector at point p\nvec", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Four corners in 3D space\n    float a = dot(i, vec3(1.0));\n    float b = dot(i, vec3(5.0));\n    float c = dot(i, vec3(7.0));\n    float d = dot(i, vec3(11.0));\n\n    // Smooth values of the four corners\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    // Mix 4 coords together to create a value between 0 and 1.\n    vec4 x = mix(vec4(a, b, c, d), vec4(b, c, d, a), u.z);\n    vec4 y = mix(vec4(d, a, b, c), vec4(c, a, b, d), u.y);\n    vec4 z0 = mix(vec4(a, b, c, d), vec4(c, a, b, d), u.x);\n    vec4 z1 = mix(vec4(d, a, b, c), vec4(a, b, c, d), u.x);\n\n    // Mix 4 values together to create a value between 0 and 1.\n    vec4 z = mix(z0, z1, u.z);\n    float z2 = mix(z.x, z.y, u.y);\n    return mix(z2, z.z, u.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value", "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = vec2(0.0);\n    float t = 0.0;\n    float step = 1.0 / 1024.0;\n    for (int i = 0; i < 1024; i++) {\n        texCoord.x = (i + 0.5) * step;\n        t = Raymarch(rayDir, texCoord);\n        if (t < 1.0) {\n            color += texture(u_envMap, texCoord).rgb * (1.0 - blur) + texture(u_envMap, texCoord + vec2(blur, 0.0)).rgb * blur;\n        }\n    }\n    return color;\n}\n\n// from https://www.shadertoy.com/view/XljGDz\nvec", "\n    float d = distance(coords, A);\n    float d1 = distance(coords, B);\n    float t = clamp(d / (d1 + d), 0.0, 1.0);\n    return height * t;\n}\n\n//============================================================\nfloat", "\n    float dot = dot(start, end);\n    float theta = acos(dot);\n    float sinTheta = sin(theta);\n    if (sinTheta < 0.0001)\n    {\n        return normalize(start + end);\n    }\n    float theta2 = theta * percent;\n    float sinTheta2 = sin(theta2);\n    float cosTheta2 = cos(theta2);\n    return normalize(start * cosTheta2 + end * sinTheta2 / sinTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract(", "\n    //http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n    vec2 v = b - a;\n    vec2 w = p - a;\n    float c1 = dot(w, v);\n    if (c1 <= 0.0)\n        return length(w);\n    vec2 vv = v;\n    normalize(vv);\n    float c2 = dot(vv, w);\n    if (c2 >= 0.0 && c2 <= length(v))\n        return length(w - v * c2);\n    return min(length(w - v * c1), length(w - v * c2));\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float lightIntensity = dot(lightDir, rayDir);\n    color = vec3(lightIntensity);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The distance to the nearest surface.\n    float d = length(p.xz) - 1.0;\n\n    // The material index.\n    int m = 0;\n\n    // The distance to the nearest surface.\n    if (d < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = -d;\n\n        // The material index.\n        m = 1;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.y + 1.0);\n\n        // The material index.\n        m = 2;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.y - 1.0);\n\n        // The material index.\n        m = 3;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.x + 1.0);\n\n        // The material index.\n        m = 4;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.x - 1.0);\n\n        // The material index.\n        m = 5;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.z + 1.0);\n\n        // The material index.\n        m = 6;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.z - 1.0);\n\n        // The material index.", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org - vec3(0.0, 0.0, 0.0));\n    float c = dot(org - vec3(0.0, 0.0, 0.0), org - vec3(0.0, 0.0, 0.0)) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    d = sqrt(d);\n    float t0 = (-b - d) / (2.0 * a);\n    float t1 = (-b + d) / (2.0 * a);\n    if (t0 > t1)\n    {\n        near = t1;\n        far = t0;\n    }\n    else\n    {\n        near = t0;\n        far = t1;\n    }\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat", "\n    vec3 q = p - vec3(r.x, r.y, r.z);\n    vec3 q1 = q;\n    q.y -= s.y;\n    vec3 q2 = q;\n    q.y -= s.w;\n    vec3 q3 = q;\n    q.y -= s.z;\n    vec3 q4 = q;\n    q.y -= s.x;\n    vec3 q5 = q;\n    q.y -= s.y;\n    vec3 q6 = q;\n    q.y -= s.w;\n    vec3 q7 = q;\n    q.y -= s.z;\n    vec3 q8 = q;\n    q.y -= s.x;\n    vec3 q9 = q;\n    q.y -= s.y;\n    vec3 q10 = q;\n    q.y -= s.w;\n    vec3 q11 = q;\n    q.y -= s.z;\n    vec3 q12 = q;\n    q.y -= s.x;\n    vec3 q13 = q;\n    q.y -= s.y;\n    vec3 q14 = q;\n    q.y -= s.w;\n    vec3 q15 = q;\n    q.y -= s.z;\n    vec3 q16 = q;\n    q.y -= s.x;\n    vec3 q17 = q;\n    q.y -= s.y;\n    vec3 q18 = q;\n    q.y -= s.w;\n    vec3 q19 = q;\n    q.y -= s.z;\n    vec3 q20 = q;\n    q.y -= s.x;\n    vec3 q21 = q;\n    q.y -= s.y;\n    vec3 q22 = q;\n    q.y -= s.w;\n    vec3 q23 = q;\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = i.x + i.y*57.0 + 113.0*i.z;\n\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)),\n                        dot(f, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                   mix(dot(f, vec3(17.0, 113.0, 57.0)),\n                       dot(f, vec3(57.0, 17.0, 113.0)),\n                       f.y),\n                   f.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)),\n                       dot(f, vec3(17.0, 57.0, 113.0)),\n                       f.z),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)),\n                       dot(f, vec3(57.0, 113.0, 17.0)),\n                       f.z),\n                   f.x),\n               f.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 1.0) * 0.5;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (d - 1.0) * 0.5;\n    float x = r * c;\n    float y = r * s;\n    float z = t;\n    float w = (d - 1.0) * 0.5;\n    float u = (d - 1.0) * 0.5;\n    float v = (d - 1.0) * 0.5;\n    float r2 = r * r;\n    float s2 = s * s;\n    float t2 = t * t;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float w2 = w * w;\n    float u2 = u * u;\n    float v2 = v * v;\n    float r3 = r2 * r;\n    float s3 = s2 * s;\n    float t3 = t2 * t;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float z3 = z2 * z;\n    float w3 = w2 * w;\n    float u3 = u2 * u;\n    float v3 = v2 * v;\n    float r4 = r3 * r;\n    float s4 = s3 * s;\n    float t4 = t3 * t;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float z4 = z3 * z;\n    float w4 = w3 * w;\n    float u4 = u3 * u;\n    float v4 = v3 * v;\n    float r5 = r4 * r;\n    float s5 = s4 * s;\n    float t5 = t4 * t;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float z5 =", "\n    vec3 bump = texture(bumpMap, sp.xy).rgb;\n    bump = normalize(bump * 2.0 - 1.0);\n    bump = normalize(bump * bumpFactor + sn);\n    return bump;\n}\n\n//\n// Standard bump function.\n//\nvec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    // Ambient\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n\n    // Diffuse\n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = vec3(0.5, 0.5, 0.5) * diff;\n\n    // Specular\n    vec3 viewDir = normalize(vec3(0, 0, 1));\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(n, halfDir), 0.0), 32.0);\n    vec3 specular = vec3(1, 1, 1) * spec;\n\n    return (ambient + diffuse + specular) * 0.3;\n}\n\n// Raymarching\n// p : point,\n// n : normal at point\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    vec2 uv = vec2(atan(rd.z, rd.x), asin(rd.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dp;\n    float dp2;\n    float dp3;\n    float dp4;\n    float dp5;\n    float dp6;\n    float dp7;\n    float dp8;\n    float dp9;\n    float dp10;\n    float dp11;\n    float dp12;\n    float dp13;\n    float dp14;\n    float dp15;\n    float dp16;\n    float dp17;\n    float dp18;\n    float dp19;\n    float dp20;\n    float dp21;\n    float dp22;\n    float dp23;\n    float dp24;\n    float dp25;\n    float dp26;\n    float dp27;\n    float dp28;\n    float dp29;\n    float dp30;\n    float dp31;\n    float dp32;\n    float dp33;\n    float dp34;\n    float dp35;\n    float dp36;\n    float dp37;\n    float dp38;\n    float dp39;\n    float dp40;\n    float dp41;\n    float dp42;\n    float dp43;\n    float dp44;\n    float dp45;\n    float dp46;\n    float dp47;\n    float dp48;\n    float dp49;\n    float dp50;\n    float dp51;\n    float dp52;\n    float dp53;\n    float dp54;\n    float dp55;\n    float dp56;\n    float dp57;\n    float dp58;\n    float dp59;\n    float dp60;", "\n    return length(p)-rad;\n}\n\n//cylinder\nfloat", "\n    float d = length(p);\n    float t = param.x;\n    float r = param.y;\n    float s = param.z;\n    float a = param.w;\n    float b = param.z;\n    float c = param.w;\n    float d1 = (d - r) / s;\n    float d2 = (d - a) / b;\n    float d3 = (d - c) / b;\n    float d4 = (d - c) / a;\n    float d5 = (d - b) / a;\n    float d6 = (d - b) / c;\n    float d7 = (d - a) / c;\n    float d8 = (d - t) / a;\n    float d9 = (d - t) / b;\n    float d10 = (d - t) / c;\n    float d11 = (d - t) / d;\n    float d12 = (d - t) / s;\n    float d13 = (d - t) / a;\n    float d14 = (d - t) / b;\n    float d15 = (d - t) / c;\n    float d16 = (d - t) / d;\n    float d17 = (d - t) / s;\n    float d18 = (d - t) / a;\n    float d19 = (d - t) / b;\n    float d20 = (d - t) / c;\n    float d21 = (d - t) / d;\n    float d22 = (d - t) / s;\n    float d23 = (d - t) / a;\n    float d24 = (d - t) / b;\n    float d25 = (d - t) / c;\n    float d26 = (d - t) / d;\n    float d27 = (d - t) / s;\n    float d28 = (d - t) / a;\n    float d29 = (d - t) / b;\n    float d30 = (d - t) / c;\n    float d31 = (", "\n    float d = DE_scene(p, param);\n    d = min(d, DE_light(p, param));\n    return d;\n}\n\n// scene distant with light gathering\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 bg = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 kaliset = vec3(0.0);\n    vec3 kaliset2 = vec3(0.0);\n    vec3 kaliset3 = vec3(0.0);\n    vec3 kaliset4 = vec3(0.0);\n    vec3 kaliset5 = vec3(0.0);\n    vec3 kaliset6 = vec3(0.0);\n    vec3 kaliset7 = vec3(0.0);\n    vec3 kaliset8 = vec3(0.0);\n    vec3 kaliset9 = vec3(0.0);\n    vec3 kaliset10 = vec3(0.0);\n    vec3 kaliset11 = vec3(0.0);\n    vec3 kaliset12 = vec3(0.0);\n    vec3 kaliset13 = vec3(0.0);\n    vec3 kaliset14 = vec3(0.0);\n    vec3 kaliset15 = vec3(0.0);\n    vec3 kaliset16 = vec3(0.0);\n    vec3 kaliset17 = vec3(0.0);\n    vec3 kaliset18 = vec3(0.0);\n    vec3 kaliset19 = vec3(0.0);\n    vec3 kaliset20 = vec3(0.0);\n    vec3 kaliset21 = vec3(0.0);\n    vec3 kaliset22 = vec3(0.0);\n    vec3 kaliset23 = vec3(0.0);\n    vec3 kaliset24 = vec3(0.0);\n    vec3 kaliset25 = vec3(0.0);\n   ", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float d = length(p);\n    if (d < 0.001)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 muv = uv * 2.0 - 1.0;\n    muv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(muv, 1.0));\n\n    float ti = 0.0;\n    float tf = 1000.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        ti = tmin;\n        tf = tmax;\n        float t = (ti + tf) * 0.5;\n        vec3 p = ro + rd * t;\n        float d = length(p);\n        if (d < 0.001)\n        {\n            break;\n        }\n        if (d < ti)\n        {\n            ti = d;\n        }\n        if (d > tf)\n        {\n            tf = d;\n        }\n    }\n\n    vec3 col = rayColor(ro, rd, ti);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col,", "\n    vec2 q = abs(p - diamond.xy);\n    return min(max(q.x, q.y), diamond.z);\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat", "\n    vec3 color = vec3(0.0);\n    float t = time * 0.01;\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 1.0) * 10.0;\n    float n = floor(d);\n    float f = fract(d);\n    float p = n + f;\n    float w = p * 0.1;\n    float h = p * 0.1;\n    float x = w * c;\n    float y = h * s;\n    float z = w * s;\n    float rx = x * 0.1;\n    float ry = y * 0.1;\n    float rz = z * 0.1;\n    float rw = r * 0.1;\n    float rx2 = rx * 0.1;\n    float ry2 = ry * 0.1;\n    float rz2 = rz * 0.1;\n    float rw2 = rw * 0.1;\n    float rx3 = rx2 * 0.1;\n    float ry3 = ry2 * 0.1;\n    float rz3 = rz2 * 0.1;\n    float rw3 = rw2 * 0.1;\n    float rx4 = rx3 * 0.1;\n    float ry4 = ry3 * 0.1;\n    float rz4 = rz3 * 0.1;\n    float rw4 = rw3 * 0.1;\n    float rx5 = rx4 * 0.1;\n    float ry5 = ry4 * 0.1;\n    float rz5 = rz4 * 0.1;\n    float rw5 = rw4 * 0.1;\n    float rx6 = rx5 * 0.1;\n    float ry6 = ry5 * 0.1;\n   ", "\n    return length( pos - vec3( 0.5, 0.5, 0.5 ) );\n}\n\n// get distance in the world\nfloat", "\n    vec3 l = normalize(v - eye);\n    vec3 r = reflect(-l, n);\n    vec3 h = normalize(l + eye);\n    float s = pow(max(dot(n, l), 0.0), 10.0);\n    float t = pow(max(dot(n, h), 0.0), 10.0);\n    return (0.2 * s + 0.8 * t) * vec3(1.0, 1.0, 1.0);\n}\n\n// phong shading with specular highlights\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    float d = distance(p, vec2(0.5));\n    return pow(d, 1.0 - offset) * 0.5;\n}\n\n// 2D noise function. \nfloat", "\n    float xmts = x.x;\n    float xmts_a = x.y;\n    float xmts_b = x.z;\n    float xmts_c = x.w;\n    float xmts_d = x.z;\n    float xmts_e = x.w;\n    float xmts_f = x.w;\n    float xmts_g = x.w;\n    float xmts_h = x.w;\n    float xmts_i = x.w;\n    float xmts_j = x.w;\n    float xmts_k = x.w;\n    float xmts_l = x.w;\n    float xmts_m = x.w;\n    float xmts_n = x.w;\n    float xmts_o = x.w;\n    float xmts_p = x.w;\n    float xmts_q = x.w;\n    float xmts_r = x.w;\n    float xmts_s = x.w;\n    float xmts_t = x.w;\n    float xmts_u = x.w;\n    float xmts_v = x.w;\n    float xmts_w = x.w;\n    float xmts_x = x.w;\n    float xmts_y = x.w;\n    float xmts_z = x.w;\n    float xmts_aa = x.w;\n    float xmts_ab = x.w;\n    float xmts_ac = x.w;\n    float xmts_ad = x.w;\n    float xmts_ae = x.w;\n    float xmts_af = x.w;\n    float xmts_ag = x.w;\n    float xmts_ah = x.w;\n    float xmts_ai = x.w;\n    float xmts_aj = x.w;\n    float xmts_ak = x.w;\n    float xmts_al = x.w;\n    float xmts_", "\n    vec2 d = abs(vec2(length(p.xz) - r, p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat", "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.yz *= mat2(1.0, 0.0, 0.0, 1.0);\n    return length(q) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    return 0.5 + 0.5*sin(p.x*100.0+p.y*100.0+p.z*100.0);\n}\n\n// my noise\nfloat", "\n\tvec4 color = vec4(0.0);\n\t\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\t\n\tfloat x1 = x - morphConstant.x;\n\tfloat y1 = y - morphConstant.y;\n\t\n\tfloat x2 = x + morphConstant.x;\n\tfloat y2 = y + morphConstant.y;\n\t\n\tfloat x3 = x - morphConstant.x;\n\tfloat y3 = y + morphConstant.y;\n\t\n\tfloat x4 = x + morphConstant.x;\n\tfloat y4 = y - morphConstant.y;\n\t\n\tfloat x5 = x - morphConstant.x;\n\tfloat y5 = y + morphConstant.y;\n\t\n\tfloat x6 = x + morphConstant.x;\n\tfloat y6 = y - morphConstant.y;\n\t\n\tfloat x7 = x - morphConstant.x;\n\tfloat y7 = y + morphConstant.y;\n\t\n\tfloat x8 = x + morphConstant.x;\n\tfloat y8 = y - morphConstant.y;\n\t\n\tfloat x9 = x - morphConstant.x;\n\tfloat y9 = y + morphConstant.y;\n\t\n\tfloat x10 = x + morphConstant.x;\n\tfloat y10 = y - morphConstant.y;\n\t\n\tfloat x11 = x - morphConstant.x;\n\tfloat y11 = y + morphConstant.y;\n\t\n\tfloat x12 = x + morphConstant.x;\n\tfloat y12 = y - morphConstant.y;\n\t\n\tfloat x13 = x - morphConstant.x;\n\tfloat y13 = y + morphConstant.y;\n\t\n\tfloat x14 = x + morphConstant.x;\n\tfloat y14 = y - morphConstant.y;\n\t\n\tfloat x15 = x - morphConstant.x;\n\tfloat y15 = y + morphConstant.y;\n\t\n\tfloat x16 = x + morphConstant.x;\n\tfloat y16 = y - morphConstant.y;\n\t\n\tfloat x17 = x - morphConstant.x;", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float f = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n    f = f * f * (3.0 - 2.0 * f);\n    return f;\n}\n\n// The bump mapping function.\nfloat", "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = view_inv * ray_nds;\n    vec4 ray_eye = viewp_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dp = dot(d, uv - p);\n    float dl2 = dl * dl;\n    float dp2 = dp * dp;\n    float dl4 = dl2 * dl2;\n    float dp4 = dp2 * dp2;\n    float dl8 = dl4 * dl4;\n    float dp8 = dp4 * dp4;\n    float dl16 = dl8 * dl8;\n    float dp16 = dp8 * dp8;\n    float dl32 = dl16 * dl16;\n    float dp32 = dp16 * dp16;\n    float dl64 = dl32 * dl32;\n    float dp64 = dp32 * dp32;\n    float dl128 = dl64 * dl64;\n    float dp128 = dp64 * dp64;\n    float dl256 = dl128 * dl128;\n    float dp256 = dp128 * dp128;\n    float dl512 = dl256 * dl256;\n    float dp512 = dp256 * dp256;\n    float dl1024 = dl512 * dl512;\n    float dp1024 = dp512 * dp512;\n    float dl2048 = dl1024 * dl1024;\n    float dp2048 = dp1024 * dp1024;\n    float dl4096 = dl2048 * dl2048;\n    float dp4096 = dp2048 * dp2048;\n    float dl8192 = dl", "\n    // TODO: implement this function\n    // You can use the following variables:\n    //   p : the point at which the shading is performed\n    //   n : the normal at the point\n    //   light : the light source\n    //   light.position : the position of the light source\n    //   light.intensity : the intensity of the light source\n    //   light.color : the color of the light source\n    //   light.attenuation : the attenuation factor of the light source\n    //   light.type : the type of the light source (ambient, point, spot, directional)\n    //   light.spot.direction : the direction of the spotlight\n    //   light.spot.cutoff : the cutoff angle of the spotlight\n    //   light.spot.exponent : the exponent of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n  return sin(x * a) * 0.5 + sin(x * b) * 0.5 + 0.5;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n    return vec2(a.x * b.x, a.y * b.y);\n}\n\n// z * z\nvec", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n    vec3 P0 = O.xyz;\n    vec3 P1 = O.xyz + vec3(U.x, U.y, 0.0);\n    vec3 P2 = O.xyz + vec3(U.x, 0.0, U.y);\n    vec3 P3 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P4 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P5 = O.xyz + vec3(U.x, U.y, U.x);\n    vec3 P6 = O.xyz + vec3(U.x, U.x, U.y);\n    vec3 P7 = O.xyz + vec3(U.x, U.x, 0.0);\n    vec3 P8 = O.xyz + vec3(0.0, U.x, U.y);\n    vec3 P9 = O.xyz + vec3(0.0, U.x, 0.0);\n    vec3 P10 = O.xyz + vec3(U.x, 0.0, 0.0);\n    vec3 P11 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P12 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P13 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P14 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P15 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P16 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P17 = O.xyz +", "\n    float d = dot(p, p);\n    return sqrt(d);\n}\n\n// distance estimation of the scene\nfloat", "\n    vec3 color = vec3(0.0);\n    float scale = 1.0;\n    float scaleFactor = 1.0;\n    float scaleFactor2 = 1.0;\n    float scaleFactor3 = 1.0;\n    float scaleFactor4 = 1.0;\n    float scaleFactor5 = 1.0;\n    float scaleFactor6 = 1.0;\n    float scaleFactor7 = 1.0;\n    float scaleFactor8 = 1.0;\n    float scaleFactor9 = 1.0;\n    float scaleFactor10 = 1.0;\n    float scaleFactor11 = 1.0;\n    float scaleFactor12 = 1.0;\n    float scaleFactor13 = 1.0;\n    float scaleFactor14 = 1.0;\n    float scaleFactor15 = 1.0;\n    float scaleFactor16 = 1.0;\n    float scaleFactor17 = 1.0;\n    float scaleFactor18 = 1.0;\n    float scaleFactor19 = 1.0;\n    float scaleFactor20 = 1.0;\n    float scaleFactor21 = 1.0;\n    float scaleFactor22 = 1.0;\n    float scaleFactor23 = 1.0;\n    float scaleFactor24 = 1.0;\n    float scaleFactor25 = 1.0;\n    float scaleFactor26 = 1.0;\n    float scaleFactor27 = 1.0;\n    float scaleFactor28 = 1.0;\n    float scaleFactor29 = 1.0;\n    float scaleFactor30 = 1.0;\n    float scaleFactor31 = 1.0;\n    float scaleFactor32 = 1.0;\n    float scaleFactor33 = 1.0;\n    float scaleFactor34 = 1.0;\n    float scaleFactor35 = 1.0;\n    float scaleFactor36 = 1.0;\n    float scaleFactor37 = 1.0;\n    float scaleFactor38 = 1.0;\n    float scale", "\n    vec3 color = vec3(0.0);\n    vec2 q = p;\n    float r = length(q);\n    if(r < 0.5){\n        color = vec3(1.0);\n    }\n    else{\n        float t = (r-0.5) * 2.0;\n        color = vec3(0.5 + 0.5 * cos(t * 3.1415926535897932384626433832795));\n    }\n    return color;\n}\n\n// The decrotated scale tiles. Render one set of decorated fans, combine them with the\n// other set, then add some highlighting and postprocessing.\nvec", "\n    float flameRadius = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.", "\n    return fract(x * sm) - 0.5 * sm;\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat", "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 137.19), dot(p, p + 269.59), dot(p, p + 41.71)));\n}\n\n// 3D noise function.\nfloat", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y),\n        mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), f.y), f.z),\n        mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), f.y),\n        mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y), f.z),\n        f.x);\n}\n\n// 3D Simplex noise.\nfloat", "\n    return 0.5*sin(p.x*10.0)+0.5*sin(p.y*10.0);\n}\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat", "\n    vec2 balloon = vec2( 0.0 );\n    float balloonRadius = 0.001;\n    float balloonHeight = 0.001;\n    float balloonWidth = 0.001;\n    float balloonDepth = 0.001;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonX2 = balloonX + balloonWidth;\n    float balloonY2 = balloonY + balloonHeight;\n    float balloonZ2 = balloonZ + balloonDepth;\n    float balloonX3 = balloonX - balloonWidth;\n    float balloonY3 = balloonY - balloonHeight;\n    float balloonZ3 = balloonZ - balloonDepth;\n    float balloonX4 = balloonX + balloonWidth;\n    float balloonY4 = balloonY - balloonHeight;\n    float balloonZ4 = balloonZ + balloonDepth;\n    float balloonX5 = balloonX - balloonWidth;\n    float balloonY5 = balloonY + balloonHeight;\n    float balloonZ5 = balloonZ - balloonDepth;\n    float balloonX6 = balloonX + balloonWidth;\n    float balloonY6 = balloonY + balloonHeight;\n    float balloonZ6 = balloonZ - balloonDepth;\n    float balloonX7 = balloonX - balloonWidth;\n    float balloonY7 = balloonY - balloonHeight;\n    float balloonZ7 = balloonZ + balloonDepth;\n    float balloonX8 = balloonX + balloonWidth;\n    float balloonY8 = balloonY - balloonHeight;\n    float balloonZ8 = balloonZ + balloonDepth;\n    float balloonX9 = balloonX - balloonWidth;\n    float balloonY9 = balloonY + balloonHeight;\n    float balloonZ9 = balloonZ - balloonDepth;\n    float balloonX10 = balloonX + balloonWidth", "\n    vec3 n = sign(rd);\n    vec3 k = abs(n) - rad;\n    vec3 t1 = k / rd;\n    vec3 t2 = k / ro;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    vec4 r = vec4(tmin.x, tmin.yz);\n    if(tmax.x < 0.0) discard;\n    r.yz = max(r.yz, tmax.yx);\n    return r;\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y + p.z;\n    return -1.0 + 2.0*f.x + f.y + f.z + f.x + f.y + f.z + f.x + f.y + f.z;\n}\n\n// 3D Simplex noise.\nfloat", "\n    vec2 ab = b-a;\n    vec2 ac = c-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    vec2 cp = p-c;\n    vec2 apxb = cross(ap,ab);\n    vec2 apxc = cross(ap,ac);\n    vec2 bpxc = cross(bp,ac);\n    vec2 bpxa = cross(bp,ab);\n    vec2 cpxa = cross(cp,ab);\n    vec2 cpxb = cross(cp,bc);\n    float d1 = dot(apxb,ab);\n    float d2 = dot(apxc,ac);\n    float d3 = dot(bpxa,ab);\n    float d4 = dot(bpxc,ac);\n    float d5 = dot(cpxa,ab);\n    float d6 = dot(cpxb,bc);\n    float denom = d1*d4 - d3*d2;\n    float v1 = (d5*d4 - d3*d6)/denom;\n    float v2 = (d2*d1 - d4*d3)/denom;\n    return c + v1*ab + v2*ac;\n}\n\n//coloring lineAO()\nvec", "\n    float a = 0.0;\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\n//Fractal calculation loop\nfloat", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\n//perspective matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//color space\nvec", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = w / 2.0;\n    float c = cos(a);\n    float s = sin(a);\n    float x = r * c;\n    float y = r * s;\n    float t = (x * c + y * s) / d;\n    float u = (x * s - y * c) / d;\n    return t * u;\n}\n\n// This is the main function. It's a bit of a mess, but it's pretty easy to understand.\n// The first thing it does is check if the mouse is inside the circle. If it is, it\n// returns 1. If it's not, it returns 0.\nfloat", "\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;", "\n    float d=1.0;\n    for(int i=0;i<4;i++){\n        d=min(d,length(p-voronoi(p+vec2(0.0,j*i*0.1),j)));\n    }\n    return d;\n}\n\nfloat", "\n    return smoothstep(0.0,1.0,f);\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat", "\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n    rgb.g = c.r * 0.5957 + c.g * 0.332 + c.b * 0.131;\n    rgb.b = c.r * 0.2115 + c.g * 0.7152 + c.b * 0.0722;\n    return rgb;\n}\n\n//enhance the hue of a color\nvec", "\n    vec4 d = vec4(0.0);\n    d.x = max(abs(p.x)-s.x,0.0);\n    d.y = max(abs(p.y)-s.y,0.0);\n    d.z = max(abs(p.z)-s.z,0.0);\n    return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n    vec4 rv = vec4(0.0);\n    if(s==0) {\n        rv.x = sdSphere(p,r.x);\n        rv.y = sdBox(p,vec3(r.x,r.y,r.y));\n        rv.z = sdCylinder(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCone(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==1) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==2) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==3) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(", "\n    Material mat = Material(vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 sourceMaterial = vec3(0.0);\n    vec3 targetMaterial = vec3(0.0);\n    float interpolant = 0.0;\n\n    // If we're at the end of the scene, return the final material\n    if (steps == 0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 0.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 1.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 2.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 3.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 4.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 5.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 6.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 7.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n", "\n    return clamp(x * (2.51 * x + 0.04), 0.0, 1.0);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;\n    float bd = 0.0", "\n    vec3 n = normal(p);\n    vec3 r = reflect(lightDir(p), n);\n    float s = max(0.0, dot(r, viewDir));\n    return vec4(vec3(s), 1.0);\n}\n\n//scene light at position p\nvec", "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        f += a * noise(p);\n        p = rot * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    p = p*2.-1.;\n    float a = dot(p,p);\n    float b = dot(p,vec2(p.y, -p.x));\n    float c = dot(p,vec2(-p.y, p.x));\n    float d = dot(p,vec2(p.y,-p.y));\n    float e = dot(p,vec2(-p.x,-p.x));\n    float f = dot(p,vec2(p.x,-p.x));\n    float g = dot(p,vec2(-p.x,p.x));\n    float h = dot(p,vec2(p.x,p.x));\n    float i = dot(p,vec2(p.y,p.y));\n    float j = dot(p.xz,p.xz);\n    float k = dot(p.yz,p.yz);\n    float l = dot(p.xz,p.yz);\n    float m = dot(p.xz,p.xz);\n    float n = dot(p.yz,p.xz);\n    float o = dot(p.yz,p.yz);\n    float p = dot(p.xz,p.yz);\n    float q = dot(p.xz,p.xz);\n    float r = dot(p.yz,p.xz);\n    float s = dot(p.yz,p.yz);\n    float t = dot(p.xz,p.yz);\n    float u = dot(p.xz,p.xz);\n    float v = dot(p.yz,p.xz);\n    float w = dot(p.yz,p.yz);\n    float x = dot(p.xz,p.yz);\n    float y = dot(p.xz,p.xz);\n    float z = dot(p.yz,p.xz);\n    float aa = a*a;\n    float ab = a*b;\n    float ac = a*c;\n    float ad = a*d;\n    float a", "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat", "\n    float d = dot(u,m);\n    return d;\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n    vec2 d = u - m.xy;\n    vec2 d1 = abs(d) - m.zw;\n    return length(max(d,0.0)) + min(max(d1.x,d1.y),0.0);\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;", "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U", "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec", "\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot(v2, v0) / (a * length(v2)));\n    float s = sin(alpha);\n    float c = cos(alpha);\n    float t = sin(beta);\n    float u = cos(beta);\n    float p = sin(gamma);\n    float q = cos(gamma);\n    float r = sqrt(Xi1);\n    float sigma = sqrt(Xi2);\n    float z = r * c * t;\n    float x = r * s * p;\n    float y = r * s * q;\n    w = vec3(x, y, z);\n    wPdf = (a * sigma * s) / (4.0 * PI);\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangle(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot(", "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U", "\n    float d = length(p);\n    if(d < 0.5){\n        return 1.0;\n    }\n    return 0.0;\n}\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat", "\n    vec4 res = vec4(0.0);\n    float d = length(p.xy);\n    if(d < 0.5){\n        res.rgb = vec3(0.0);\n        res.a = 1.0;\n    }\n    else{\n        res.rgb = vec3(0.0);\n        res.a = 0.0;\n    }\n    return res;\n}\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec", "\n    float d = distance(p, vec3(0.0));\n    float t = gID;\n    float a = t * 0.01;\n    float b = t * 0.02;\n    float c = t * 0.03;\n    float d1 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d2 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d3 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d4 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d5 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d6 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d7 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d8 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d9 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d10 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d11 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d12 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d13 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d14 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d15 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d16 = distance(p, vec3(0.0, 0.", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\tfloat tmax18 = 1000.0;\n", "\n    float d = length(lp - ro);\n    float f = k / (d * d);\n    return f * exp(-t * f);\n}\n\n// The main raymarching function.\nfloat", "\n    vec3 q = p;\n    vec3 d = vec3(0.0);\n    float dd = 0.0;\n    float ddd = 0.0;\n    float dddd = 0.0;\n    float ddddd = 0.0;\n    float dddddd = 0.0;\n    float ddddddd = 0.0;\n    float dddddddd = 0.0;\n    float ddddddddd = 0.0;\n    float dddddddddd = 0.0;\n    float ddddddddddd = 0.0;\n    float dddddddddddd = 0.0;\n    float ddddddddddddd = 0.0;\n    float dddddddddddddd = 0.0;\n    float ddddddddddddddd = 0.0;\n    float dddddddddddddddd = 0.0;\n    float ddddddddddddddddd = 0.0;\n    float dddddddddddddddddd = 0.0;\n    float ddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddddd = 0.0;\n   ", "\n    vec3 p0 = m[0] * p3;\n    vec3 p1 = m[1] * p3;\n    vec3 p2 = m[2] * p3;\n    vec3 p4 = m[3] * p3;\n    vec3 p5 = m[4] * p3;\n    vec3 p6 = m[5] * p3;\n    vec3 p7 = m[6] * p3;\n    vec3 p8 = m[7] * p3;\n    vec3 p9 = m[8] * p3;\n    vec3 p10 = m[9] * p3;\n    vec3 p11 = m[10] * p3;\n    vec3 p12 = m[11] * p3;\n    vec3 p13 = m[12] * p3;\n    vec3 p14 = m[13] * p3;\n    vec3 p15 = m[14] * p3;\n    vec3 p16 = m[15] * p3;\n    vec3 p17 = m[16] * p3;\n    vec3 p18 = m[17] * p3;\n    vec3 p19 = m[18] * p3;\n    vec3 p20 = m[19] * p3;\n    vec3 p21 = m[20] * p3;\n    vec3 p22 = m[21] * p3;\n    vec3 p23 = m[22] * p3;\n    vec3 p24 = m[23] * p3;\n    vec3 p25 = m[24] * p3;\n    vec3 p26 = m[25] * p3;\n    vec3 p27 = m[26] * p3;\n    vec3 p28 = m[27] * p3;\n    vec3 p29 = m[28] * p3;\n    vec3 p30 =", "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0) - 1.0;\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float b = atan(p.y, -p.x);\n    float c = atan(p.x, p.y);\n    float d1 = abs(a - dir);\n    float d2 = abs(b - dir);\n    float d3 = abs(c - dir);\n    return min(d1, min(d2, d3));\n}\n\n// Truchet pattern distance field.\nfloat", "\n    return atan2(q.y, q.x) + dir;\n}\n\n// Get the polar coordinate of the arc pixel.\nfloat", "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    vec3 v3 = p3 - t;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d02 = dot(v0, v2);\n    float d11 = dot(v1, v1);\n    float d12 = dot(v1, v2);\n    float d22 = dot(v2, v2);\n    float inv_det = 1.0 / (d00 * d11 * d22 + d01 * d12 * d02 + d02 * d10 * d01 - d00 * d12 * d11 - d01 * d10 * d22 - d02 * d11 * d00);\n    return vec4(\n        (d11 * d22 - d12 * d12) * inv_det,\n        (d02 * d22 - d01 * d22) * inv_det,\n        (d01 * d12 - d02 * d11) * inv_det,\n        1.0\n    );\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 s = cross(q, p);\n    float d = dot(s, r);\n    return d * d;\n}\n\n// Find the (squared) distance to the plane in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float d = length(p);\n    return smoothstep(lW, lW+0.01, d);\n}\n\n// A simple 2D noise function.\nfloat", "\n    vec2 d = ddx * ddy;\n    return 0.25 * (\n        (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x + p.y) * (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * (p.x + p.y) * d.x * d.y\n    );\n}\n\n// grid ratio\nfloat", "\n    float d = dot( n, n );\n    if( d > 0.0 )\n    {\n        float d2 = dot( f, f );\n        if( d2 > d )\n        {\n            float d3 = d2 - d;\n            float d4 = d3 * d3;\n            float d5 = d4 * d4;\n            float d6 = d5 * d5;\n            float d7 = d6 * d6;\n            float d8 = d7 * d7;\n            float d9 = d8 * d8;\n            float d10 = d9 * d9;\n            float d11 = d10 * d10;\n            float d12 = d11 * d11;\n            float d13 = d12 * d12;\n            float d14 = d13 * d13;\n            float d15 = d14 * d14;\n            float d16 = d15 * d15;\n            float d17 = d16 * d16;\n            float d18 = d17 * d17;\n            float d19 = d18 * d18;\n            float d20 = d19 * d19;\n            float d21 = d20 * d20;\n            float d22 = d21 * d21;\n            float d23 = d22 * d22;\n            float d24 = d23 * d23;\n            float d25 = d24 * d24;\n            float d26 = d25 * d25;\n            float d27 = d26 * d26;\n            float d28 = d27 * d27;\n            float d29 = d28 * d28;\n            float d30 = d29 * d29;\n            float d31 = d30 * d30;\n            float d32 = d31 * d31;\n            float d33 = d32 * d32;\n            float d34 = d33 * d33;\n            float d35 = d", "\n    return vec2(\n        lerp(p1.x,p2.x,t),\n        lerp(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nfloat", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p0;\n    float d = dot(a, a);\n    float e = dot(b, b);\n    float f = dot(a, b);\n    float D = d * e - f * f;\n    if(D == 0.0) return c;\n    float sc = (dot(a, a) - dot(b, b) + D) / 2.0;\n    float tc = (dot(b, b) - dot(a, a) + D) / 2.0;\n    return c + a * sc + b * tc;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec", "\n    float a = dist(p0, p1);\n    float b = dist(p1, p2);\n    float c = dist(p2, p0);\n    float s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// The area of the triangle:\nfloat", "\n    vec2 v1 = h1 - h2;\n    vec2 v2 = h3 - h2;\n    vec2 v3 = h1 - h3;\n    vec2 v4 = h2 - h3;\n    vec2 v5 = h1 - h1;\n    vec2 v6 = h2 - h2;\n    vec2 v7 = h3 - h3;\n    vec2 v8 = h1 - h1;\n    vec2 v9 = h2 - h2;\n    vec2 v10 = h3 - h3;\n    vec2 v11 = h1 - h1;\n    vec2 v12 = h2 - h2;\n    vec2 v13 = h3 - h3;\n    vec2 v14 = h1 - h1;\n    vec2 v15 = h2 - h2;\n    vec2 v16 = h3 - h3;\n    vec2 v17 = h1 - h1;\n    vec2 v18 = h2 - h2;\n    vec2 v19 = h3 - h3;\n    vec2 v20 = h1 - h1;\n    vec2 v21 = h2 - h2;\n    vec2 v22 = h3 - h3;\n    vec2 v23 = h1 - h1;\n    vec2 v24 = h2 - h2;\n    vec2 v25 = h3 - h3;\n    vec2 v26 = h1 - h1;\n    vec2 v27 = h2 - h2;\n    vec2 v28 = h3 - h3;\n    vec2 v29 = h1 - h1;\n    vec2 v30 = h2 - h2;\n    vec2 v31 = h3 - h3;\n    vec2 v32 = h1 - h1;\n    vec2 v33 = h2 - h2;\n    vec2 v34 = h3 - h3;\n    vec2 v35 = h1", "\n    triObj t;\n    t.p = p;\n    t.c = vec3(0.0);\n    t.n = vec3(0.0);\n    t.t = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.q = vec3(0.0);\n    t.r = vec3(0.0);\n    t.s = vec3(0.0);\n    t.t = vec3(0.0);\n    t.u = vec3(0.0);\n    t.v = vec3(0.0);\n    t.w = vec3(0.0);\n    t.x = vec3(0.0);\n    t.y = vec3(0.0);\n    t.z = vec3(0.0);\n    t.a = vec3(0.0);\n    t.b = vec3(0.0);\n    t.c = vec3(0.0);\n    t.d = vec3(0.0);\n    t.e = vec3(0.0);\n    t.f = vec3(0.0);\n    t.g = vec3(0.0);\n    t.h = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.p = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.01) / 0.08;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n   ", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return false;\n    else\n    {\n        float temp = sqrt( discriminant );\n        float q = ( b > 0.0 )? ( -0.5 * ( b + temp ) ) : ( -0.5 * ( b - temp ) );\n        t = q / a;\n        if ( t < tmin || tmax < t )\n            return false;\n        else\n        {\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction", "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.", "\n    //////////////////////////////////////////////////////////////////////////\n    // Replace with your code:\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    hasHit = false;\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of a point light source at a given point.\n// The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n//\u8ba1\u7b97\u70b9\u5149\u6e90\u7684\u989c\u8272\u3002\n//\u989c\u8272\u662f\u6765\u81ea\u6240\u6709\u5149\u6e90\u7684\u5149\u7684\u603b\u548c\uff0c\u6bcf\u4e2a\u5149\u6e90\u4f7f\u7528Phong\u7167\u660e\u6a21\u578b\u8ba1\u7b97\uff0c\u5e76\u8003\u8651\u662f\u5426\u4ece\u5149\u7ebf\u906e\u853d\u4e86\u622a\u9762\u70b9\u3002\n//\u5982\u679c\u6ca1\u6709interesection\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3afalse\u3002\n//\u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u8ba1\u7b97\u7684\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3atrue\uff0c\u4ea4\u70b9\u76843D\u4f4d\u7f6e\uff08hitPos\uff09\uff0c\n//\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u4ee5\u53ca\u76f8\u4ea4\u5bf9\u8c61\u7684\u6750\u8d28\u7684k_rg\u503c\u3002\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = (p + q) * 0.5;\n    vec2 t = (q + r) * 0.5;\n    vec2 u = (s + t) * 0.5;\n    vec2 v = (t + r) * 0.5;\n    vec2 w = (u + v) * 0.5;\n    vec2 x = (v + w) * 0.5;\n    vec2 y = (w + u) * 0.5;\n    vec2 z = (u + x) * 0.5;\n    vec2 a = (x + y) * 0.5;\n    vec2 b = (y + z) * 0.5;\n    vec2 c = (z + a) * 0.5;\n    vec2 d = (a + b) * 0.5;\n    vec2 e = (b + c) * 0.5;\n    vec2 f = (c + d) * 0.5;\n    vec2 g = (d + e) * 0.5;\n    vec2 h = (e + f) * 0.5;\n    vec2 i = (f + g) * 0.5;\n    vec2 j = (g + h) * 0.5;\n    vec2 k = (h + i) * 0.5;\n    vec2 l = (i + j) * 0.5;\n    vec2 m = (j + k) * 0.5;\n    vec2 n = (k + l) * 0.5;\n    vec2 o = (l + m) * 0.5;\n    vec2 p1 = (m + n) * 0.5;\n    vec2 q1 = (n + o) * 0.5;\n    vec2 r1 = (o + p) * 0.5;\n    vec2 s1 = (p +", "\n    vec3 bmin = vec3( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ),\n                      min( min( p0.y, p1.y ), min( p2.y, p3.y ) ),\n                      min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    vec3 bmax = vec3( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ),\n                      max( max( p0.y, p1.y ), max( p2.y, p3.y ) ),\n                      max( max( p0.z, p1.z ), max( p2.z, p3.z ) ) );\n    return bound3( bmin, bmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t1 = dot( ap, ab );\n    float t2 = dot( bp, ab );\n    float t3 = dot( ap, ab );\n    float t4 = dot( bp, ab );\n    float tmin = max( max( t1, t2 ), max( t3, t4 ) );\n    float tmax = min( min( t1, t2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s", "\n    return 0.5 * ( 1.0 - cos( k * PI ) );\n}\n\n/**\n * Cubic InOut Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x", "\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - 0.5;\n    float t = iTime;\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float f = (r - 0.5) * 0.5;\n    float g = (r - 0.5) * 0.5;\n    float h = (r - 0.5) * 0.5;\n    float i = (r - 0.5) * 0.5;\n    float j = (r - 0.5) * 0.5;\n    float k = (r - 0.5) * 0.5;\n    float l = (r - 0.5) * 0.5;\n    float m = (r - 0.5) * 0.5;\n    float n = (r - 0.5) * 0.5;\n    float o = (r - 0.5) * 0.5;\n    float p = (r - 0.5) * 0.5;\n    float q = (r - 0.5) * 0.5;\n    float r = (r - 0.5) * 0.5;\n    float s = (r - 0.5) * 0.5;\n    float t = (r - 0.5) * 0.5;\n    float u = (r - 0.5) * 0.5;\n    float v = (r - 0.5) * 0.5;\n    float w = (r - 0.5) * 0.5;\n    float x = (r - 0.5) * 0.5;\n    float y = (r - 0.5) * 0.5;\n    float z = (r - 0.5) * 0.5;\n    float aa =", "\n    return (coord * 2.0) / res - 1.0;\n}\n\n// Calculate the value of the julia set at the given coordinate.\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 hcv = vec3(0.0);\n    float max = max(rgb.r, max(rgb.g, rgb.b));\n    float min = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = max - min;\n    if (delta == 0.0) {\n        hcv.r = hcv.g = hcv.b = 0.0;\n    } else {\n        if (max == rgb.r) {\n            hcv.r = (rgb.g - rgb.b) / delta;\n        } else if (max == rgb.g) {\n            hcv.r = 2.0 + (rgb.b - rgb.r) / delta;\n        } else {\n            hcv.r = 4.0 + (rgb.r - rgb.g) / delta;\n        }\n        hcv.r *= 60.0;\n        if (hcv.r < 0.0) {\n            hcv.r += 360.0;\n        }\n        hcv.g = delta / max;\n        hcv.b = 0.0;\n    }\n    return hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise\nfloat", "\n    vec3 e = vec3( 0.0001, 0.0, 0.0 );\n    return normalize( vec3(\n        p.y - surface( p + e.yxx ).y,\n        p.z - surface( p + e.zzx ).z,\n        p.x - surface( p + e.xyx ).x ) );\n}\n\n// Tetrahedral surface, to save a couple of \"map\" calls. Courtesy of IQ.\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// --------------------------------------------------------\n// Simplex 3D Noise - fractal noise with an interesting\n// property\n// --------------------------------------------------------\n\nfloat", "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float rr = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float ww = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float x13 = 0.0;\n    float y13 = 0.0;\n    float", "\n    return snoise(v.x, v.y);\n}\n\n//SNOISE\nfloat", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n    vec3 col = vec3(0.0);\n\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n\n    float radius = 0.5;\n    float dist = 0.0;\n\n    for(int i = 0; i < 100; i++){\n        pos = vec3(0.0, 0.0, 0.0);\n        dist = 0.0;\n\n        for(int j = 0; j < 10; j++){\n            pos = vec3(0.0, 0.0, 0.0);\n            dist = 0.0;\n\n            for(int k = 0; k < 10; k++){\n                pos = vec3(0.0, 0.0, 0.0);\n                dist = 0.0;\n\n                pos.x = (float(i) / 10.0) - 0.5;\n                pos.y = (float(j) / 10.0) - 0.5;\n                pos.z = (float(k) / 10.0) - 0.5;\n\n                dist = length(pos);\n\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0 + 113.0*i.z;\n    return mix(mix(mix(dot(C.xyz, f+vec3(0.0,0.0,0.0)),\n                        dot(C.xyz, f+vec3(1.0,0.0,0.0)),\n                        f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,0.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,0.0)),\n                       f.x),\n                   f.y),\n               mix(mix(dot(C.xyz, f+vec3(0.0,0.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,0.0,1.0)),\n                       f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,1.0)),\n                       f.x),\n                   f.y),\n               f.z);\n}\n\n// Thanks Shane.\nfloat", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n", "\n    vec2 d = vec2(0.0);\n    d.x = length(p.xy) - 0.5;\n    d.y = p.z + 0.5;\n    return d;\n}\n\n//the second scalar represents the object type, the first the actual distance\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Complex functions\nvec", "\n    float aa = aaSize / 2.0;\n    float aa2 = aa * aa;\n    float aa3 = aa2 * aa;\n    float aa4 = aa3 * aa;\n    float aa5 = aa4 * aa;\n    float aa6 = aa5 * aa;\n    float aa7 = aa6 * aa;\n    float aa8 = aa7 * aa;\n    float aa9 = aa8 * aa;\n    float aa10 = aa9 * aa;\n    float aa11 = aa10 * aa;\n    float aa12 = aa11 * aa;\n    float aa13 = aa12 * aa;\n    float aa14 = aa13 * aa;\n    float aa15 = aa14 * aa;\n    float aa16 = aa15 * aa;\n    float aa17 = aa16 * aa;\n    float aa18 = aa17 * aa;\n    float aa19 = aa18 * aa;\n    float aa20 = aa19 * aa;\n    float aa21 = aa20 * aa;\n    float aa22 = aa21 * aa;\n    float aa23 = aa22 * aa;\n    float aa24 = aa23 * aa;\n    float aa25 = aa24 * aa;\n    float aa26 = aa25 * aa;\n    float aa27 = aa26 * aa;\n    float aa28 = aa27 * aa;\n    float aa29 = aa28 * aa;\n    float aa30 = aa29 * aa;\n    float aa31 = aa30 * aa;\n    float aa32 = aa31 * aa;\n    float aa33 = aa32 * aa;\n    float", "\n    vec2 d = vec2(0.0);\n    vec3 q = pos - vec3(0.0, 0.0, 0.0);\n    d.x = length(q) - 0.01;\n    d.y = boxID(q);\n    return d;\n}\n\n// returns the distance to our rotating box and the associated material ID\nvec", "\n    vec2 d = vec2(0.0);\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n    float sphereDist = distance(pos, spherePos);\n    if (sphereDist < sphereRadius) {\n        d.x = sphereDist - sphereRadius;\n        d.y = sphereRadius;\n    }\n    return d;\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(1000.0);\n    // add your scene here\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 0.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 1.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 2.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 3.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 4.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 5.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 6.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 7.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 8.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 9.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 10.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 11.0;\n    // res.", "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    for (int i = 0; i < 100; i++) {\n        if (t > tMax) break;\n        t += rayMarch(rayPos, rayDir);\n        if (t > tMax) break;\n        vec3 hitPos = rayPos + rayDir * t;\n        vec3 hitNormal = getNormal(hitPos);\n        vec3 lightColor = vec3(0.0);\n        if (dot(hitNormal, lightDir) > 0.0) {\n            lightColor = vec3(1.0);\n        }\n        color += vec4(lightColor, 1.0);\n    }\n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec4 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = color;\n}\n", "\n    vec2 res = vec2(0.);\n    vec3 q = abs(rd) - rad;\n    vec3 m = max(q, vec3(0.0));\n    res.x = min(max(m.x, m.y), m.z);\n    res.y = length(max(m, 0.0));\n    return res;\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + r * r;\n        t = s;\n    }\n\n    vec3 color = vec3(0.0);\n    if (dot(q, q) > 4.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "\n    return dot(plane.normal, pos - plane.position);\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat", "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    ix = ix + ivec3(gl_GlobalInvocationID.xyz);\n    float res = 0.0;\n    for(int j=-1; j<=1; j++){\n        for(int k=-1; k<=1; k++){\n            for(int l=-1; l<=1; l++){\n                ivec3 c = ix + ivec3(j,k,l);\n                vec4 v = texelFetch(noise, c, 0);\n                res += v.x*p.x;\n                res += v.y*p.y;\n                res += v.z*p.z;\n                res += v.w*(1.0-p.x)*(1.0-p.y)*(1.0-p.z);\n            }\n        }\n    }\n    return res;\n}\n\n// High Precision 3D Gradient Noise\n// ix: integer coordinate, fx: float offset to the integer coordinate\nfloat", "\n    float fractal = 0.0;\n    for(int i = 0; i < 10; i++){\n        fractal += fractal_brownian(fxyz, ixyz, i);\n    }\n    return fractal;\n}\n\n// Fractal Brownian Motion \nfloat", "\n    vec2 d = vec2( length(p.xz) - r, p.y );\n    return length(max(d,0.0)) - h;\n}\n\nfloat", "\n    //The distance of the point from the center of the sphere\n    float d = length(p) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d2 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d3 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d4 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d5 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d6 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d7 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d8 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d9 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d10 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d11 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n", "\n    vec3 normal = vec3(0.0);\n    float d = get_distance(p);\n    normal.x = d - get_distance(p + vec3(1.0, 0.0, 0.0));\n    normal.y = d - get_distance(p + vec3(0.0, 1.0, 0.0));\n    normal.z = d - get_distance(p + vec3(0.0, 0.0, 1.0));\n    return normalize(normal);\n}\n\n// Compute the color at a position p on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat", "\n    vec3 p = ro + rd*ra;\n    return dot(p,p) - ra*ra;\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * dot(q,q);\n    float h = f * (f + f - 16.0 * dot(f,f) + 10.0 * dot(f,f) * dot(f,f));\n    return 0.25 * (h * (h + h + 1.0) + g * (g + g + 1.0) * (g + g + 1.0));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\tglClearDepth(1.0f);\n\tglEnable(GL_DEPTH_TEST);\n\tglDepthFunc(GL_LEQUAL);\n\tglShadeModel(GL_SMOOTH);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Draws the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid DrawScene()\n{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLoadIdentity();\n\n\tgluLookAt(0.0f, 0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n\n\tglColor3f(1.0f, 1.0f, 1.0f);\n\tglBegin(GL_QUADS);\n\tglVertex3f(-1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, 1.0f, 0.0f);\n\tglVertex3f(-1.0f, 1.0f, 0.0f);\n\tglEnd();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Main function.\n/////////////////////////////////////////////////////////////////////////////\nint", "\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    ///////////////////////////////////////////////////////////////////////////\n    //\n    // Hint:\n    //\n    //   - You can use the dot product to compute the distance between a\n    //     point and a line.\n    //\n    //   - You can use the cross product to compute the normal vector of a\n    //     plane.\n    //\n    //   - You can use the length of a vector to compute the distance between\n    //     two points.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n   ", "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.", "\n    vec3 color = vec3(0.0);\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat", "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 light_color = vec3(0.0);\n\tvec3 light_start = planet_position;\n\tvec3 light_end = planet_position + light_dir * max_dist;\n\tvec3 light_ray_dir = normalize(light_end - light_start);\n\tvec3 light_ray_start = light_start;\n\tvec3 light_ray_end = light_start + light_ray_dir * max_dist;\n\tvec3 light_ray_color = vec3(0.0);\n\tvec3 light_ray_dir_2 = normalize(light_end - light_start);\n\tvec3 light_ray_start_2 = light_start;\n\tvec3 light_ray_end_2 = light_start + light_ray_dir_2 * max_dist;\n\tvec3 light_ray_color_2 = vec3(0.0);\n\tvec3 light_ray_dir_3 = normalize(light_end - light_start);\n\tvec3 light_ray_start_3 = light_start;\n\tvec3 light_ray_end_3 = light_start + light_ray_dir_3 * max_dist;\n\tvec3 light_ray_color_3 = vec3(0.0);\n\tvec3 light_ray_dir_4 = normalize(light_end - light_start);\n\tvec3 light_ray_start_4 = light_start;\n\tvec3 light_ray_end_4 = light_start + light_ray_dir_4 * max_dist;\n\tvec3 light_ray_color_4 = vec3(0.0);\n\tvec3 light_ray_dir_5 = normalize(light_end - light_start);\n\tvec3 light_ray_start_5 = light_start;\n\tvec3 light_ray_end_5 = light_start +", "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir_norm = normalize(sample_pos - light_dir_norm);\n    float cos_theta = dot(light_dir_norm, view_dir_norm);\n    float cos_theta_sq = cos_theta * cos_theta;\n    float cos_theta_sq_inv = 1.0 - cos_theta_sq;\n    float cos_theta_sq_inv_sq = cos_theta_sq_inv * cos_theta_sq_inv;\n    float cos_theta_sq_inv_sq_inv = cos_theta_sq_inv_sq * cos_theta_sq_inv_sq;\n    float cos_theta_sq_inv_sq_inv_inv = cos_theta_sq_inv_sq_inv * cos_theta_sq_inv_sq_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv * cos_theta_sq_inv_sq_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_", "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_attenuation = vec3(1.0);\n    vec3 light_ambient = vec3(0.0);\n    vec3 light_diffuse = vec3(0.0);\n    vec3 light_specular = vec3(0.0);\n    vec3 light_spot_dir = vec3(0.0);\n    vec3 light_spot_color = vec3(0.0);\n    vec3 light_spot_attenuation = vec3(0.0);\n    vec3 light_spot_ambient = vec3(0.0);\n    vec3 light_spot_diffuse = vec3(0.0);\n    vec3 light_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n\n    //get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n\n    //get the ray origin\n    vec3 rayOrigin = camPos;\n\n    //get the ray color\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n\n    //get the ray length\n    float rayLength = 1.0;\n\n    //get the ray step\n    float rayStep = 0.001;\n\n    //get the ray step\n    float rayStep2 = 0.001;\n\n    //get the ray step\n    float rayStep3 = 0.001;\n\n    //get the ray step\n    float rayStep4 = 0.001;\n\n    //get the ray step\n    float rayStep5 = 0.001;\n\n    //get the ray step\n    float rayStep6 = 0.001;\n\n    //get the ray step\n    float rayStep7 = 0.001;\n\n    //get the ray step\n    float rayStep8 = 0.001;\n\n    //get the ray step\n    float rayStep9 = 0.001;\n\n    //get the ray step\n    float rayStep10 = 0.001;\n\n    //get the ray step\n    float rayStep11 = 0.001;\n\n    //get the ray step\n    float rayStep12 = 0.001;\n\n    //get the ray step\n    float rayStep13 = 0.001;\n\n    //get the ray step\n    float rayStep14 = 0.001;\n\n    //get the ray step\n    float rayStep15 = 0.00", "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat", "\n\tvec4 finalColor = vec4(0.0);\n\tvec3 rayDir = normalize(cameraRayDir);\n\tvec3 rayPos = cameraPos;\n\tvec3 rayPosInc = rayDir;\n\tvec3 rayPosInc2 = rayDir;\n\tvec3 rayPosInc3 = rayDir;\n\tvec3 rayPosInc4 = rayDir;\n\tvec3 rayPosInc5 = rayDir;\n\tvec3 rayPosInc6 = rayDir;\n\tvec3 rayPosInc7 = rayDir;\n\tvec3 rayPosInc8 = rayDir;\n\tvec3 rayPosInc9 = rayDir;\n\tvec3 rayPosInc10 = rayDir;\n\tvec3 rayPosInc11 = rayDir;\n\tvec3 rayPosInc12 = rayDir;\n\tvec3 rayPosInc13 = rayDir;\n\tvec3 rayPosInc14 = rayDir;\n\tvec3 rayPosInc15 = rayDir;\n\tvec3 rayPosInc16 = rayDir;\n\tvec3 rayPosInc17 = rayDir;\n\tvec3 rayPosInc18 = rayDir;\n\tvec3 rayPosInc19 = rayDir;\n\tvec3 rayPosInc20 = rayDir;\n\tvec3 rayPosInc21 = rayDir;\n\tvec3 rayPosInc22 = rayDir;\n\tvec3 rayPosInc23 = rayDir;\n\tvec3 rayPosInc24 = rayDir;\n\tvec3 rayPosInc25 = rayDir;\n\tvec3 rayPosInc26 = rayDir;\n\tvec3 rayPosInc27 = rayDir;\n\tvec3 rayPosInc28 = rayDir;\n\tvec3 rayPosInc29 = rayDir;\n\tvec3 rayPosInc30 = rayDir;\n\tvec3 rayPosInc31 = rayDir;\n\tvec3 rayPosInc32 = rayDir;\n\tvec3 rayPosInc33 = rayDir;\n\tvec3 rayPosInc34 = rayDir;\n\tvec3 ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float dd = d * d;\n    float ddd = dd * d;\n    float dddd = ddd * d;\n    float ddddd = dddd * d;\n    float dddddd = ddddd * d;\n    float ddddddd = dddddd * d;\n    float dddddddd = ddddddd * d;\n    float ddddddddd = dddddddd * d;\n    float dddddddddd = ddddddddd * d;\n    float ddddddddddd = dddddddddd * d;\n    float dddddddddddd = ddddddddddd * d;\n    float ddddddddddddd = dddddddddddd * d;\n    float dddddddddddddd = ddddddddddddd * d;\n    float ddddddddddddddd = dddddddddddddd * d;\n    float dddddddddddddddd = ddddddddddddddd * d;\n    float ddddddddddddddddd = dddddddddddddddd * d;\n    float dddddddddddddddddd = ddddddddddddddddd * d;\n    float ddddddddddddddddddd = dddddddddddddddddd * d;\n    float dddddddddddddddddddd = ddddddddddddddddddd * d;\n   ", "\n    vec3 color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    for (int i = 0; i < MAX_PATHS; i++) {\n        vec3 hit_position = ray_position;\n        vec3 hit_normal = vec3(0.0);\n        vec3 hit_color = vec3(0.0);\n        vec3 hit_reflection = vec3(0.0);\n        vec3 hit_refraction = vec3(0.0);\n        vec3 hit_refraction_color = vec3(0.0);\n        vec3 hit_reflection_color = vec3(0.0);\n        vec3 hit_refraction_normal = vec3(0.0);\n        vec3 hit_reflection_normal = vec3(0.0);\n        vec3 hit_refraction_position = vec3(0.0);\n        vec3 hit_reflection_position = vec3(0.0);\n        vec3 hit_reflection_direction = vec3(0.0);\n        vec3 hit_refraction_direction = vec3(0.0);\n        vec3 hit_refraction_normal_direction = vec3(0.0);\n        vec3 hit_reflection_normal_direction = vec3(0.0);\n        vec3 hit_refraction_normal_position = vec3(0.0);\n        vec3 hit_reflection_normal_position = vec3(0.0);\n        vec3 hit_reflection_direction_position = vec3(0.0);\n        vec3 hit_refraction_direction_position = vec3(0.0);\n        vec3 hit_reflection_direction_normal = vec3(0.0);\n        vec3 hit_refraction_direction_normal = vec3(0.0);\n        vec3 hit_reflection_direction_normal_position = vec3(0.0);\n", "\n    vec3 c = vec3(0.0);\n    vec2 q = p;\n    float d = 0.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b2 = 0.0;\n    float a2 = 0.0;\n    float r2 = 0.0;\n    float g2 = 0.0;\n    float b3 = 0.0;\n    float a3 = 0.0;\n    float r3 = 0.0;\n    float g3 = 0.0;\n    float b4 = 0.0;\n    float a4 = 0.0;\n    float r4 = 0.0;\n    float g4 = 0.0;\n    float b5 = 0.0;\n    float a5 = 0.0;\n    float r5 = 0.0;\n    float g5 = 0.0;\n    float b6 = 0.0;\n    float a6 = 0.0;\n    float r6 = 0.0;\n    float g6 = 0.0;\n    float b7 = 0.0;\n    float a7 = 0.0;\n    float r7 = 0.0;\n    float g7 = 0.0;\n    float b8 = 0.0;\n    float a8 = 0.0;\n    float r8 = 0.0;\n    float g8 = 0.0;\n    float b9 = 0.0;\n    float a9 = 0.0;\n    float r9 = 0.0;\n    float g9 = 0.0;\n    float b10 = 0.0;\n    float a10 = 0.0;\n    float r10 = 0.0;\n    float g10 = 0.0;\n    float b11 = 0.0;\n    float a11 = 0.0;\n    float r11 = 0.0;\n    float g11 = 0.0;\n    float b12 = 0.0;\n    float a12 = 0.0;\n    float r", "\n    return length(p) - 1.0;\n}\n\n// Get the normal of the sphere\nvec", "\n    vec3 Pi0 = floor( P );\n    vec3 Pi1 = Pi0 + vec3( 1.0 );\n    vec3 Pf0 = fract( P );\n    vec3 Pf1 = Pf0 - vec3( 1.0 );\n\n    vec4 x0 = vec4( Pf0.x, Pf1.x, Pi0.x, Pi1.x );\n    vec4 x1 = vec4( Pf0.y, Pf1.y, Pi0.y, Pi1.y );\n    vec4 x2 = vec4( Pf0.z, Pf1.z, Pi0.z, Pi1.z );\n\n    vec4 w0 = vec4( dot( x0, vec4( 1.0 ) ), dot( x1, vec4( 1.0 ) ),\n                    dot( x2, vec4( 1.0 ) ), 1.0 );\n\n    return dot( w0, vec4( 1.0 ) );\n}\n\n// from: https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - d;\n}\n\n// segment with disc ends: seamless distance to segment\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract(", "\n    return abs(p.x) + abs(p.y);\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat", "\n    float n = noise(ix, iy);\n    return n;\n}\n\n// yea i basically spammed random stuff\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if ( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, t );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// Return the color of the pixel\nvec", "\n    return sin(p * 10.0) * 0.5 + 0.5;\n}\n\n// Fifth scene (many elements)\nfloat", "\n    return vec2(atan(z.y, z.x), length(z));\n}\n\n// coordinate change \nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// returns the magnitude of a complex number\nfloat", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.y),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), u.y), u.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), u.x),\n                   mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.x), u.z),\n               u.x);\n}\n\n/* 3d simplex noise */\nfloat", "\n\tfloat t = time * 0.025;\n\tfloat d = distance( p, vec3( 0.0 ) );\n\tfloat r = ( 1.0 - d ) * 0.0001;\n\tfloat a = cos( t * 0.05 ) * 0.0001;\n\tfloat b = cos( t * 0.02 ) * 0.0001;\n\tfloat c = cos( t * 0.01 ) * 0.0001;\n\tfloat d1 = cos( t * 0.005 ) * 0.0001;\n\tfloat d2 = cos( t * 0.002 ) * 0.0001;\n\tfloat d3 = cos( t * 0.001 ) * 0.0001;\n\tfloat d4 = cos( t * 0.0005 ) * 0.0001;\n\tfloat d5 = cos( t * 0.0002 ) * 0.0001;\n\tfloat d6 = cos( t * 0.0001 ) * 0.0001;\n\tfloat d7 = cos( t * 0.00005 ) * 0.0001;\n\tfloat d8 = cos( t * 0.00002 ) * 0.0001;\n\tfloat d9 = cos( t * 0.00001 ) * 0.0001;\n\tfloat d10 = cos( t * 0.000005 ) * 0.0001;\n\tfloat d11 = cos( t * 0.000002 ) * 0.0001;\n\tfloat d12 = cos( t * 0.000001 ) * 0.0001;\n\tfloat d13 = cos( t * 0.0000005 ) * 0.0001;\n\tfloat d14 = cos( t * 0.0000002", "\n    float d = sdf( p );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0", "\n    float s = 0.0;\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec", "\n    return clamp((d - start) / (end - start), 0.0, 1.0);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat", "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0);\n    hex.zw = floor(hex.xy);\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\n// The distance field for the truchet.\nvec", "\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.", "\n    float theta = atan(pc.y, pc.x);\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r", "\n    return smoothstep(pct, pct+0.01, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat", "\n    vec3 domain;\n    float angle = 2.0 * PI / float(N);\n    float radius = R * sqrt(1.0 - cos(angle));\n    domain.x = radius * cos(angle);\n    domain.y = radius * sin(angle);\n    domain.z = 0.0;\n    return domain;\n}\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x - circ.x, p.y - circ.y);\n    return vec2(\n        circ.x + r.x * circ.w + r.y * circ.z,\n        circ.y + r.x * circ.z - r.y * circ.w\n    );\n}\n\n// Returns the distance from a point to a circle.\nfloat", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 shadow = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 fogColor = vec3(0.0);\n    vec3 fogStart = vec3(0.0);\n    vec3 fogEnd = vec3(0.0);\n    vec3 fogDensity = vec3(0.0);\n    vec3 fogColor2 = vec3(0.0);\n    vec3 fogDensity2 = vec3(0.0);\n    vec3 fogColor3 = vec3(0.0);\n    vec3 fogDensity3 = vec3(0.0);\n    vec3 fogColor4 = vec3(0.0);\n    vec3 fogDensity4 = vec3(0.0);\n    vec3 fogColor5 = vec3(0.0);\n    vec3 fogDensity5 = vec3(0.0);\n    vec3 fogColor6 = vec3(0.0);\n    vec3 fogDensity6 = vec3(0.0);\n    vec3 fogColor7 = vec3(0.0);\n    vec3 fogDensity7 = vec3(0.0);\n    vec3 fogColor8 = vec3(0.0);\n    vec3 fogDensity8 = vec3(0.0);\n    vec3 fogColor9 = vec3(0.0);\n    vec3 fogDensity9 = vec3(0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    if (d < 1.0) {\n        float t = (1.0 - d) * 10.0;\n        col = vec3(1.0 - t, t, 0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", " // Input (r, g, b, a) pixel color \n\n    // Get the coordinates of the pixel in the polar coordinate system.\n    vec2 polarCoord = polarCoord(fragCoord);\n\n    // Get the colour of the pixel in the polar coordinate system.\n    vec3 polarColour = polarColour(polarCoord);\n\n    // Get the colour of the pixel in the HSB colour space.\n    vec3 hsbColour = hsbColour(polarColour);\n\n    // Get the colour of the pixel in the RGB colour space.\n    vec3 rgbColour = rgbColour(hsbColour);\n\n    // Output the colour of the pixel.\n    fragColor = vec4(rgbColour, 1.0);\n}\n\n// Polar coordinate system.\n// https://thebookofshaders.com/06/\nvec", "\n    return normalize(vec3(\n        hash * 2.0 - 1.0,\n        hash * 4.0 - 2.0,\n        hash * 8.0 - 4.0\n    ));\n}\n\n// Hash function\nfloat", "\n    vec2 XY = bccNoise_Plane(X);\n    return vec2(XY.x, XY.y + X.z);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec", "\n  float d = length(p.xz) - 1.0;\n  d = max(d, abs(p.y) - 0.9);\n  return d;\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat", "\n    vec3 rayDir = ray.direction;\n    vec3 rayOrigin = ray.origin;\n    vec3 rayPos = rayOrigin + rayDir * ray.t;\n    vec3 rayDirNorm = normalize( rayDir );\n    vec3 rayPosNorm = normalize( rayPos );\n    vec3 rayPosToTarget = targetPos - rayPos;\n    float rayPosToTargetDot = dot( rayPosToTarget, rayDirNorm );\n    float rayPosToTargetDotSq = rayPosToTargetDot * rayPosToTargetDot;\n    float rayPosToTargetDotCos = dot( rayPosToTarget, rayPosNorm );\n    float rayPosToTargetDotSqCos = rayPosToTargetDotCos * rayPosToTargetDotCos;\n    float rayPosToTargetDotSqCosSq = rayPosToTargetDotSqCos * rayPosToTargetDotSqCos;\n    float rayPosToTargetDotSqCosSqSq = rayPosToTargetDotSqCosSq * rayPosToTargetDotSqCosSq;\n    float rayPosToTargetDotSqCosSqSqSq = rayPosToTargetDotSqCosSqSq * rayPosToTargetDotSqCosSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSq = rayPosToTargetDotSqCosSqSqSq * rayPosToTargetDotSqCosSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSqSq;\n    float ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 pos = vec4(p, 1.0);\n    vec4 res = vec4(0.0);\n    res.xyz = p;\n    res.w = 1.0;\n    return res;\n}\n\n//---Essential Geometry Function\nvec", "\n\n    float t = ray.t;\n    float t0 = t;\n    float t1 = t + lightDiameter;\n\n    float t2 = t - lightDiameter;\n    float t3 = t + lightDiameter;\n\n    float t4 = t - lightDiameter;\n    float t5 = t + lightDiameter;\n\n    float t6 = t - lightDiameter;\n    float t7 = t + lightDiameter;\n\n    float t8 = t - lightDiameter;\n    float t9 = t + lightDiameter;\n\n    float t10 = t - lightDiameter;\n    float t11 = t + lightDiameter;\n\n    float t12 = t - lightDiameter;\n    float t13 = t + lightDiameter;\n\n    float t14 = t - lightDiameter;\n    float t15 = t + lightDiameter;\n\n    float t16 = t - lightDiameter;\n    float t17 = t + lightDiameter;\n\n    float t18 = t - lightDiameter;\n    float t19 = t + lightDiameter;\n\n    float t20 = t - lightDiameter;\n    float t21 = t + lightDiameter;\n\n    float t22 = t - lightDiameter;\n    float t23 = t + lightDiameter;\n\n    float t24 = t - lightDiameter;\n    float t25 = t + lightDiameter;\n\n    float t26 = t - lightDiameter;\n    float t27 = t + lightDiameter;\n\n    float t28 = t - lightDiameter;\n    float t29 = t + lightDiameter;\n\n    float t30 = t - lightDiameter;\n    float t31 = t + lightDiameter;\n\n    float t32 = t - lightDiameter;\n    float t33 = t + lightDiameter;\n\n    float t34 = t - lightDiameter;\n    float t35 = t + lightDiameter;\n\n    float t36 = t - lightDiameter;\n    float t37 = t + lightDiameter;\n\n    float", "\n    return vec2(length(p.xy), p.z);\n}\n\n// \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193", "\n    return fract(sin(x)*1e4);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0.0f && v >= 0.0f && u + v < 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec", "\n    int closest_hex = -1;\n    float closest_dist = INFINITY;\n    for(int i = 0; i < hex_count; i++){\n        float dist = distance(uv, hex_pos[i]);\n        if(dist < closest_dist){\n            closest_dist = dist;\n            closest_hex = i;\n        }\n    }\n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint", "\n    //Check if uv is on an edge of the hexagon\n    if(abs(uv.x) + abs(uv.y) <= circumradius){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is on the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2 * (1 + sqrt(3))){\n        return ON_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", "\n    //Check if uv is on an edge of the hexagon.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is outside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return OUT_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", "\n    float p = exp(-d);\n    float sum = p;\n    float r = U.x;\n    for (int i = 1; i < d; i++) {\n        r *= U.y;\n        sum += p / float(i);\n        if (r < sum)\n            return i - 1;\n        p *= (d - i) / float(i);\n    }\n    return d - 1;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n =", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.0) / (1.0 - 0.0);\n    float t = mod(a, 2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = (x * x + y * y) * 4.0;\n    float g = (x * x - y * y) * 4.0;\n    float h = (x * x + y * y) * 4.0;\n    float i = (x * x - y * y) * 4.0;\n\n    float j = (f + g + h + i) / 4.0;\n\n    col = vec3(j);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.02) / 0.01;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (r + 1.0) * 0.5;\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float m = smoothstep(0.0, 1.0, t);\n    float k = smoothstep(0.0, 1.0, t - 1.0);\n    float b = (n + m) * 0.5;\n    float g = (k + m) * 0.5;\n    float y = (b + g) * 0.5;\n    float rr = (r + 1.0) * 0.5;\n    float gg = (g + 1.0) * 0.5;\n    float bb = (b + 1.0) * 0.5;\n    float rr2 = rr * rr;\n    float gg2 = gg * gg;\n    float bb2 = bb * bb;\n    float rr3 = rr2 * rr;\n    float gg3 = gg2 * gg;\n    float bb3 = bb2 * bb;\n    float rr4 = rr3 * rr;\n    float gg4 = gg3 * gg;\n    float bb4 = bb3 * bb;\n    float rr5 = rr4 * rr;\n    float gg5 = gg4 * gg;\n    float bb5 = bb4 * bb;\n    float rr6 = rr5 * rr;\n    float gg6 = gg5 * gg;\n", "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 e = vec2(1.0, -1.0) * DELTA;\n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n    ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec", "\n    ivec2 p = ivec2(q.x,q.y);\n    p = (p<<13) ^ p;\n    return (float((p.x*p.x+p.y*p.y)*(p.x*p.x+p.y*p.y+p.x*p.x))*(p.y*p.y+p.x*p.x) + p.x) + p.y;\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\nfloat", "\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular, out float emissive ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    emissive = material_emissives[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec", "\n    vec2 q = p - ab;\n    float k = dot(q, q) / dot(ab, ab);\n    return vec3(k - 0.5, 2.0 * k * (1.0 - k), 1.0 - k);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 c = vec2(0.5);\n    float r = 0.0;\n    float a = 1.0;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tau = 1.0;\n    float tau2 = 1.0;\n    float tau3 = 1.0;\n    float tau4 = 1.0;\n    float tau5 = 1.0;\n    float tau6 = 1.0;\n    float tau7 = 1.0;\n    float tau8 = 1.0;\n    float tau9 = 1.0;\n    float tau10 = 1.0;\n    float tau11 = 1.0;\n    float tau12 = 1.0;\n    float tau13 = 1.0;\n    float tau14 = 1.0;\n    float tau15 = 1.0;\n    float tau16 = 1.0;\n    float tau17 = 1.0;\n    float tau18 = 1.0;\n    float tau19 = 1.0;\n    float tau20 = 1.0;\n    float tau21 = 1.0;\n    float tau22 = 1.0;\n    float tau23 = 1.0;\n    float tau24 = 1.0;\n    float tau25 = 1.0;\n    float tau26 = 1.0;\n    float tau27 = 1.0;\n    float tau28 = 1.0;\n    float tau29 = 1.0;\n    float tau30 = 1.0;\n    float tau31 = 1.0;\n    float tau32 = 1.0;\n    float tau", "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 =", "\n    return mat3(\n        vec3(cos(rotation.x)*cos(rotation.y), cos(rotation.x)*sin(rotation.y), sin(rotation.x)),\n        vec3(-sin(rotation.y), cos(rotation.y), 0),\n        vec3(sin(rotation.x)*cos(rotation.y), -sin(rotation.x)*sin(rotation.y), cos(rotation.x))\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    vec3 raypos = rayori.xyz;\n    vec3 raydir_ = raydir.xyz;\n    vec3 raydir_n = raydir.w;\n    vec3 raydir_n_ = raydir.w;\n    vec3 raydir_n_n = raydir.w;\n    vec3 raydir_n_n_ = raydir.w;\n    vec3 raydir_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n", "\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 dir = vec3(0.0);\n    vec3 ray = vec3(0.0);\n    vec3 ray_dir = vec3(0.0);\n    vec3 ray_dir_inv = vec3(0.0);\n    vec3 ray_dir_inv_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir", "\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    for(int i = 0; i < 100; i++){\n        pos = pos + raydir * dist;\n        dist += 0.01;\n        if(pos.y > 0.0) break;\n    }\n    return pos;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 raydir = normalize(vec3(p, 2.0));\n    vec3 rayori = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0);\n    vec3 pos = raymarch(raydir, rayori);\n    if(pos.y > 0.0) col = vec3(1.0, 0.0, 0.0);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}", "\n    // get the distance from the ray to the edge of the texture\n    float dist = texture(textureSampler, coord).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist2 = texture(textureSampler, coord + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist3 = texture(textureSampler, coord + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist4 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist5 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist6 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist7 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist8 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist9 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = vec3(0.0);\n        p.x = sin(d * 10.0) * 0.5 + 0.5;\n        p.y = cos(d * 10.0) * 0.5 + 0.5;\n        p.z = sin(d * 10.0) * 0.5 + 0.5;\n        d = length(p);\n        light += vec3(0.0, 0.0, 1.0) * exp(-d * 0.001);\n    }\n\n    col = light;\n\n    fragColor = vec4(col, 1.0);\n}\n// -----------------------------------------------\n", "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n    e6 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4,", "\n    vec3 x = max(vec3(0.0), color - vec3(0.004));\n    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 q = uv - p;\n    float d = length(q);\n    return vec3(d, d, d);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n\tfloat t = falloff * rnd.x;\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = s * s;\n\tfloat b = c * c;\n\tfloat c2 = a * b;\n\tfloat d = a * c2;\n\tfloat e = b * c2;\n\tfloat f = c2 * c2;\n\tfloat g = d * d;\n\tfloat h = e * e;\n\tfloat i = f * f;\n\tfloat j = g * g;\n\tfloat k = h * h;\n\tfloat l = i * i;\n\tfloat m = j * j;\n\tfloat n = k * k;\n\tfloat o = l * l;\n\tfloat p = m * m;\n\tfloat q = n * n;\n\tfloat r = o * o;\n\tfloat s2 = p * p;\n\tfloat t2 = q * q;\n\tfloat u2 = r * r;\n\tfloat v2 = s2 * s2;\n\tfloat w2 = t2 * t2;\n\tfloat x2 = u2 * u2;\n\tfloat y2 = v2 * v2;\n\tfloat z2 = w2 * w2;\n\tfloat a2 = x2 * x2;\n\tfloat b2 = y2 * y2;\n\tfloat c2 = z2 * z2;\n\tfloat d2 = a2 * a2;\n\tfloat e2 = b2 * b2;\n\tfloat f2 = c2 * c2;\n\tfloat g2 = d2 * d2;\n\tfloat h2 = e2 * e2;\n\tfloat i2 = f2 * f2;\n\tfloat j2 = g2 * g2;\n\tfloat k2 = h2 * h2;\n\tfloat l2 = i2 * i2;\n\tfloat m2 = j2 * j2;\n\tfloat n2 = k2 * k2;\n\tfloat o2 = l2 * l2;\n\tfloat p2 = m2 * m2;\n\tfloat q2 = n2 * n2;\n\tfloat r2 = o2 * o2;\n\tfloat s2 = p2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.01;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    return mix(col, vec3(c), r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    vec3 col = vec3(c);\n    col = postProcess(col, q);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 q = abs(p) - vec3(1.0);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 mouse_offset = mouse - uv;\n\n    float radius = length(mouse_offset);\n    float brightness = radius / iResolution.x;\n\n    vec3 color = vec3(brightness);\n\n    fragColor = vec4(color, 1.0);\n}\n"], "input_docstring": ["\n\treturn cos( a );\n}\n\nfloat", "\n    vec3 rotated = Rotate(p, rotDir);\n\n    // Scale to the size of the object\n    vec3 scaled = rotated * scale;\n\n    // Translate to the center of the object\n    vec3 translated = scaled + center;\n\n    // Get the distance to the object\n    float dist = length(translated);\n\n    return dist;\n}\n\nvoid main()\n{\n    // Get the position of the pixel\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    // Get the position of the pixel in world space\n    vec3 p = vec3(uv * 2.0 - 1.0, 1.0);\n\n    // Get the distance to the object\n    float dist = DistanceToObject(p);\n\n    // Get the color of the object\n    vec3 color = GetColor(dist);\n\n    // Set the color of the pixel\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tfloat glow = max(0.0, glowCounter - 0.001);\n\n\t// Calculate the distance to the voxel\n\tfloat d = length(p - voxelPos);\n\n\t// Calculate the distance to the voxel's center\n\tfloat dc = length(p - voxelCenter);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de = length(p - voxelEdge);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc2 = length(p - voxelCorner);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de2 = length(p - voxelEdge2);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc3 = length(p - voxelCorner2);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de3 = length(p - voxelEdge3);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc4 = length(p - voxelCorner3);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de4 = length(p - voxelEdge4);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc5 = length(p - voxelCorner4);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de5 = length(p - voxelEdge5);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc6 = length(p - voxelCorner5);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de6 = length(p - voxelEdge6);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc7 = length(p - voxelCorner6);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de7 = length(p - voxelEdge7);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc8 = length", "\n\tvec3 glow = vec3(0.0);\n\tfloat glowIntensity = 0.0;\n\n\t// Update the distance to the scene\n\tfloat dist = 1000000.0;\n\n\t// Update the position of the point\n\tP = p;\n\n\t// Update the distance to the scene\n\tdist = length(p);\n\n\t// Update the glow intensity\n\tglowIntensity = (1.0 - dist) * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " position in the screen\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the world\n\tvec3 pos = vec3(p * 2.0 - 1.0, 1.0);\n\n\t// Get the ray direction\n\tvec3 rayDir = normalize(vec3(p * 2.0 - 1.0, 1.0));\n\n\t// Get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\n\t// Get the ray color\n\tvec3 rayColor = vec3(0.0);\n\n\t// Get the ray depth\n\tfloat rayDepth = 0.0;\n\n\t// Get the ray distance\n\tfloat rayDistance = 0.0;\n\n\t// Get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\n\t// Get the ray material\n\tfloat rayMaterial = 0.0;\n\n\t// Get the ray material color\n\tvec3 rayMaterialColor = vec3(0.0);\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal2 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth2 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance2 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal3 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth3 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance3 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal4 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth4 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance4 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal5 = ve", "\n\tstatic const float c[4] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\treturn vec4(c[0], c[1], c[2], c[3]);\n}\n\n//src/main.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstd", "\n\tvec4 color = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tcolor.rgb = pow(color.rgb, vec3(1.0/2.2));\n\t\n\treturn color;\n}\n\nvoid main()\n{\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\tvec4 color = shade(d);\n\t\n\tgl_FragColor = color;\n}\n", " and forth\n    float fade = clamp(0.5 - dot(rayDir, sunDir), 0.0, 1.0);\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec", "\n    float t = ( coords.x - 2.0 ) / 2.0;\n    float a = sin( t * 3.1415926535897932384626433832795 );\n    return a;\n}\n\nvoid main()\n{\n    vec2 coords = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    float d = distance( coords, vec2( 0.0 ) );\n    float a = atan( coords.y, coords.x );\n    float r = ( 1.0 - d ) * 0.5;\n    float h = ( 1.0 - d ) * 0.5;\n    float s = ( 1.0 - d ) * 0.5;\n    vec3 color = vec3( 0.0 );\n    color += vec3( 1.0, 0.0, 0.0 );\n    color += vec3( 0.0, 1.0, 0.0 );\n    color += vec3( 0.0, 0.0, 1.0 );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), h );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), s );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), r );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), a );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float t = (coords.x - 2.0) / 4.0;\n    float a = sin(t) * 4.0 + 2.0;\n    float b = cos(t) * 4.0 + 2.0;\n    return sin(a) * sin(b);\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    float d = F(coords);\n    float a = atan(coords.y, coords.x);\n    float r = length(coords);\n    float t = (a + PI) / (2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n    float z = d;\n    vec3 n = vec3(x, y, z);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 h = normalize(v + l);\n    vec3 color = vec3(0.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, l)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, h)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, v)), 10.0);\n    color = pow(color, vec3(1.0 / 2.2));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float t = ( coords.x - 1.0 ) / 3.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n", "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float n = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        n += a;\n        a *= 0.5;\n        p = rot * p * 2.0 + shift;\n        p = mod(p, 289.0) - 155.0;\n    }\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat", "\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // p = p*p*(3.0-2.0*p.", "\n    // This is a simplex grid implementation that is based on the\n    // work of John H. Curtis and John A. Henstridge.\n    //\n    // The grid is a 2D array of 3D vectors.  The grid is a 2D array\n    // of 3D vectors.  The grid is a 2D array of 3D vectors.  The\n    // grid is a 2D array of 3D vectors.  The grid is a 2D array of\n    // 3D vectors.  The grid is a 2D array of 3D vectors.  The grid\n    // is a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors", "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n\n    // Compute the distance from the cell center to the point.\n    vec2 dist = abs(p - cell + (0.5 - cell_offset)) - cell_size * 0.5;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    vec2 closest_edge = min(dist, vec2(0.0));\n\n    // Compute the distance from the point to the closest corner of the cell.\n    vec2 closest_corner = min(closest_edge, min(dist.yx, dist.xy));\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist = min(closest_edge.x, closest_edge.y);\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist = min(closest_corner.x, closest_corner.y);\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq = closest_edge_dist * closest_edge_dist;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq = closest_corner_dist * closest_corner_dist;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq_sq = closest_edge_dist_sq * closest_edge_dist_sq;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq_sq = closest_corner_dist_sq * closest_corner_dist_sq;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_cube = closest_edge_dist_sq_sq * closest_edge_dist;\n\n    // Compute the distance from the", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "\n    vec2 res;\n\n    // map the point to the unit cube\n    res.x = (p.x + 1.0) * 0.5;\n    res.y = (p.y + 1.0) * 0.5;\n\n    // map the point to the unit sphere\n    res.x = res.x * 2.0 - 1.0;\n    res.y = res.y * 2.0 - 1.0;\n\n    // map the point to the unit disk\n    if (res.x * res.x + res.y * res.y > 1.0)\n        discard;\n\n    // map the point to the unit disk\n    res.x = res.x * sqrt(1.0 - res.y * res.y);\n    res.y = res.y * sqrt(1.0 - res.x * res.x);\n\n    // map the point to the unit disk\n    res.x *= resolution;\n    res.y *= resolution;\n\n    return res;\n}\n\n// compute the ray direction\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin2 = 0.0;\n\tfloat tmax2 = 10000.0;\n\tfloat tmin3 = 0.0;\n\tfloat tmax3 = 10000.0;\n\tfloat tmin4 = 0.0;\n\tfloat tmax4 = 10000.0;\n\tfloat tmin5 = 0.0;\n\tfloat tmax5 = 10000.0;\n\tfloat tmin6 = 0.0;\n\tfloat tmax6 = 10000.0;\n\tfloat tmin7 = 0.0;\n\tfloat tmax7 = 10000.0;\n\tfloat tmin8 = 0.0;\n\tfloat tmax8 = 10000.0;\n\tfloat tmin9 = 0.0;\n\tfloat tmax9 = 10000.0;\n\tfloat tmin10 = 0.0;\n\tfloat tmax10 = 10000.0;\n\tfloat tmin11 = 0.0;\n\tfloat tmax11 = 10000.0;\n\tfloat tmin12 = 0.0;\n\tfloat tmax12 = 10000.0;\n\tfloat tmin13 = 0.0;\n\tfloat tmax13 = 10000.0;\n\tfloat tmin14 = 0.0;\n\tfloat tmax14 = 10000.0;\n\tfloat tmin15 = 0.0;\n\tfloat tmax15 = 10000.0;\n\tfloat tmin16 = 0.0;\n\tfloat tmax16 = 10000.0;\n\tfloat tmin17 = 0.0;\n\tfloat tmax17 = 10000.0;\n\tfloat tmin18 = 0.0;\n\tfloat tmax18 = 10000.0;\n\tfloat tmin19 = 0.0;\n\tfloat tmax19", "\n    vec4 res;\n\n    // map the point to the unit cube\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit sphere\n    p.y = abs(p.y);\n\n    // map the point to the unit disk\n    if (p.x * p.x + p.y * p.y > 1.0)\n        return res;\n\n    // map the point to the unit square\n    p.x = abs(p.x);\n\n    // map the point to the unit rectangle\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y > 1.0)\n        return res;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 dp;\n    vec3 dp2;\n    vec3 dp3;\n    vec3 dp4;\n    vec3 dp5;\n    vec3 dp6;\n    vec3 dp7;\n    vec3 dp8;\n    vec3 dp9;\n    vec3 dp10;\n    vec3 dp11;\n    vec3 dp12;\n    vec3 dp13;\n    vec3 dp14;\n    vec3 dp15;\n    vec3 dp16;\n    vec3 dp17;\n    vec3 dp18;\n    vec3 dp19;\n    vec3 dp20;\n    vec3 dp21;\n    vec3 dp22;\n    vec3 dp23;\n    vec3 dp24;\n    vec3 dp25;\n    vec3 dp26;\n    vec3 dp27;\n    vec3 dp28;\n    vec3 dp29;\n    vec3 dp30;\n    vec3 dp31;\n    vec3 dp32;\n    vec3 dp33;\n    vec3 dp34;\n    vec3 dp35;\n    vec3 dp36;\n    vec3 dp37;\n    vec3 dp38;\n    vec3 dp39;\n    vec3 dp40;\n    vec3 dp41;\n    vec3 dp42;\n    vec3 dp43;\n    vec3 dp44;\n    vec3 dp45;\n    vec3 dp46;\n    vec3 dp47;\n    vec3 dp48;\n    vec3 dp49;\n    vec3 dp50;\n    ve", "\n    vec3 wp = (modelMatrix * vec4(p, 1.0)).xyz;\n    vec3 wo = (modelMatrix * vec4(oN, 0.0)).xyz;\n    vec3 wd = wp - wo;\n\n    // world pos diff\n    vec3 wp2 = (modelMatrix * vec4(p + wd, 1.0)).xyz;\n    vec3 wo2 = (modelMatrix * vec4(oN + wd, 0.0)).xyz;\n    vec3 wd2 = wp2 - wo2;\n\n    // world pos diff\n    vec3 wp3 = (modelMatrix * vec4(p + wd2, 1.0)).xyz;\n    vec3 wo3 = (modelMatrix * vec4(oN + wd2, 0.0)).xyz;\n    vec3 wd3 = wp3 - wo3;\n\n    // world pos diff\n    vec3 wp4 = (modelMatrix * vec4(p + wd3, 1.0)).xyz;\n    vec3 wo4 = (modelMatrix * vec4(oN + wd3, 0.0)).xyz;\n    vec3 wd4 = wp4 - wo4;\n\n    // world pos diff\n    vec3 wp5 = (modelMatrix * vec4(p + wd4, 1.0)).xyz;\n    vec3 wo5 = (modelMatrix * vec4(oN + wd4, 0.0)).xyz;\n    vec3 wd5 = wp5 - wo5;\n\n    // world pos diff\n    vec3 wp6 = (modelMatrix * vec4(p + wd5, 1.0)).xyz;\n    vec3 wo6 = (modelMatrix * vec4(oN + wd5, 0.0)).xyz;\n    vec3 wd6 = wp6 - wo6;\n\n    // world pos diff\n    vec3", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0", "\n\t//pR(rayDir.xz, sin(-t * 2.));\n\t//pR(rayDir.xy, sin(-t * 3.));\n\t//pR(rayDir.xz, sin(-t * 4.));\n\t//pR(rayDir.yz, sin(-t * 5.));\n\t//pR(rayDir.xy, sin(-t * 6.));\n\t//pR(rayDir.xz, sin(-t * 7.));\n\t//pR(rayDir.yz, sin(-t * 8.));\n\t//pR(rayDir.xy, sin(-t * 9.));\n\t//pR(rayDir.xz, sin(-t * 10.));\n\t//pR(rayDir.yz, sin(-t * 11.));\n\t//pR(rayDir.xy, sin(-t * 12.));\n\t//pR(rayDir.xz, sin(-t * 13.));\n\t//pR(rayDir.yz, sin(-t * 14.));\n\t//pR(rayDir.xy, sin(-t * 15.));\n\t//pR(rayDir.xz, sin(-t * 16.));\n\t//pR(rayDir.yz, sin(-t * 17.));\n\t//pR(rayDir.xy, sin(-t * 18.));\n\t//pR(rayDir.xz, sin(-t * 19.));\n\t//pR(rayDir.yz, sin(-t * 20.));\n\t//pR(rayDir.xy, sin(-t * 21.));\n\t//pR(rayDir.xz, sin(-t * 22.));\n\t//pR(rayDir.yz, sin(-t * 23.));\n\t//pR(rayDir.xy, sin(-t * 24.));\n\t//pR(rayDir.xz, sin(-t * 25.));\n\t//pR(rayDir.yz, sin(-t * 26.));\n\t//pR(rayDir.xy, sin(-t * 27.));\n\t//pR(rayDir.x", "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float line_dist = distance(coords, vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)));\n    // calculate the height of the line\n    float line_height = height * line_dist / box.x;\n    // calculate the y axis of the line\n    float line_y = coords.y - line_height;\n    // calculate the x axis of the line\n    float line_x = coords.x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x, line_y));\n    // calculate the height of the line\n    float line_height_to_box = height * line_dist_to_box / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box = line_y - line_height_to_box;\n    // calculate the x axis of the line\n    float line_x_to_box = line_x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box_2 = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x_to_box, line_y_to_box));\n    // calculate the height of the line\n    float line_height_to_box_2 = height * line_dist_to_box_2 / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box_2 = line_y_to_box - line_height_to_box_2;\n    // calculate the x axis of the line\n    float line_x_to_box_2 = line_x_to_box;\n    //", "\n     float dot = dot(start, end);\n     // If the dot is 1, the vectors are the same.\n     if (dot > 0.9999)\n     {\n          return end;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot < -0.9999)\n     {\n          return -end;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle = acos(dot);\n     // Compute the sin of the angle.\n     float sin = sin(angle);\n     // Compute the ratio of the sin of the angle.\n     float ratio = sin / sin(angle);\n     // Compute the cross product.\n     vec2 cross = cross(start, end);\n     // Compute the cross product.\n     vec2 result = cross * ratio;\n     // Compute the dot product.\n     float dot2 = dot(start, result);\n     // If the dot is 1, the vectors are the same.\n     if (dot2 > 0.9999)\n     {\n          return result;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot2 < -0.9999)\n     {\n          return -result;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot2 == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle2 = acos(dot2);\n     // Compute the sin of the angle.\n     float sin2 = sin(angle2);\n     // Compute the ratio of the sin of the angle.\n     float ratio2 = sin2 / sin(angle2);\n     // Compute the cross product.\n     vec2 cross2 = cross(start, result);\n     // Compute the cross product.\n     vec2 result2 = cross2 * ratio2;\n     // Compute the", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float d = map( pos );\n        t += d;\n        if( t>tmax || d<tmin ) break;\n    }\n\n    // lighting\n    vec3 light = vec3(0.0,0.0,1.0);\n    vec3 n = normal( pos );\n    vec3 l = normalize( light - pos );\n    vec3 v = normalize( -pos );\n    float dif = max( dot( n, l ), 0.0 );\n    vec3 col = vec3( dif );\n\n    // tone mapping\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    //", "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b", " and forth\n    float fade = (1.0 - abs(rayDir.y)) * 0.5;\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec", "\n    // The cylinder is a circle with a radius of 1.\n    // The space is a box with a width of 2.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is", "^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.z + dir.z) / dir.z;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 + z^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 + (org.z + t*dir.z)^2 = 0.5^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool plane(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool triangle(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) /", "\n    vec3 q = p - s.xyz;\n    vec3 qx = q.xzy;\n    vec3 qy = q.yzx;\n    vec3 qz = q.zxy;\n    vec3 qw = q.wxy;\n    vec3 qx2 = qx*2.0;\n    vec3 qy2 = qy*2.0;\n    vec3 qz2 = qz*2.0;\n    vec3 qw2 = qw*2.0;\n    vec3 qx3 = qx*3.0;\n    vec3 qy3 = qy*3.0;\n    vec3 qz3 = qz*3.0;\n    vec3 qw3 = qw*3.0;\n    vec3 qx4 = qx*4.0;\n    vec3 qy4 = qy*4.0;\n    vec3 qz4 = qz*4.0;\n    vec3 qw4 = qw*4.0;\n    vec3 qx5 = qx*5.0;\n    vec3 qy5 = qy*5.0;\n    vec3 qz5 = qz*5.0;\n    vec3 qw5 = qw*5.0;\n    vec3 qx6 = qx*6.0;\n    vec3 qy6 = qy*6.0;\n    vec3 qz6 = qz*6.0;\n    vec3 qw6 = qw*6.0;\n    vec3 qx7 = qx*7.0;\n    vec3 qy7 = qy*7.0;\n    vec3 qz7 = qz*7.0;\n    vec3 qw7 = qw*7.0;\n    vec3 qx8 = qx*8.0;\n    vec3 qy8 = qy*8.0;\n    vec3 qz8 = qz*8.0;\n    vec3 qw8 = qw*8", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0", "\n    float d = distance(p, vec2(0.5, 0.5));\n    \n    // The circle's radius.\n    float r = 0.2;\n    \n    // The circle's thickness.\n    float t = 0.01;\n    \n    // The circle's thickness, squared.\n    float t2 = t * t;\n    \n    // The circle's thickness, squared.\n    float d2 = d * d;\n    \n    // The circle's thickness, squared.\n    float r2 = r * r;\n    \n    // The circle's thickness, squared.\n    float d4 = d2 * d2;\n    \n    // The circle's thickness, squared.\n    float r4 = r2 * r2;\n    \n    // The circle's thickness, squared.\n    float d8 = d4 * d4;\n    \n    // The circle's thickness, squared.\n    float r8 = r4 * r4;\n    \n    // The circle's thickness, squared.\n    float d16 = d8 * d8;\n    \n    // The circle's thickness, squared.\n    float r16 = r8 * r8;\n    \n    // The circle's thickness, squared.\n    float d32 = d16 * d16;\n    \n    // The circle's thickness, squared.\n    float r32 = r16 * r16;\n    \n    // The circle's thickness, squared.\n    float d64 = d32 * d32;\n    \n    // The circle's thickness, squared.\n    float r64 = r32 * r32;\n    \n    // The circle's thickness, squared.\n    float d128 = d64 * d64;\n    \n    // The circle's thickness, squared.\n    float r128 = r64 * r64;\n    \n    // The circle's thickness, squared.\n    float d256 = d128 * d128;\n    \n    // The circle's thickness,", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // sn - The normal of the surface at the point sp.\n    // snx - Change in \"sn\" in in the X-direction.\n    // sny - Change in \"sn\" in in the Y-direction.\n    // snz - Change in \"sn\" in in the Z-direction.\n    //\n    // sp - The point at which the bump mapping is being applied.\n    // spx - Change in \"sp\" in in the X-direction.\n    // spy - Change in \"sp\" in in the Y-direction.\n    // spz - Change in \"sp\" in in the Z-direction.\n    //\n    // bump - The bump mapping result.\n    //\n    // The following is the bump mapping formula.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpF", "\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * vec3(0.5, 0.5, 0.5);\n  vec3 diffuse = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  vec3 specular = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  float specular_strength = 0.5;\n  float specular_intensity = 0.5;\n  float diffuse_intensity = 0.5;\n  float attenuation = 1.0;\n  float distance = length(light - p);\n  float attenuation_factor = 1.0 / (attenuation * distance * distance);\n  float diffuse_factor = max(dot(light_dir, n), 0.0);\n  float specular_factor = pow(max(dot(view_dir, reflect_dir), 0.0), 32);\n  vec3 color = ambient * attenuation_factor;\n  color += diffuse * diffuse_factor * diffuse_intensity * attenuation_factor;\n  color += specular * specular_factor * specular_strength * specular_intensity * attenuation_factor;\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.x, gl_FragCoord.y, 0.0);\n  vec3 n = normal(p);\n  vec3 color = shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    ray.origin = vec3(0.0);\n    ray.direction = normalize(vec3(0.0, 0.0, 1.0));\n\n    //creats a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n\n    //creats a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a camera object\n    Camera camera = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\nvec", "i\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k", "\n    return length(p) - rad;\n}\n\nfloat", "\n    vec3 fp = floor(p);\n    vec3 cp = ceil(p);\n\n    // distance to the nearest point\n    vec3 d0 = p - fp;\n    vec3 d1 = cp - p;\n\n    // interpolate between the two points\n    return mix(mix(d0.x, d0.y, d0.z), mix(d1.x, d1.y, d1.z), smoothstep(0.0, 1.0, param.x));\n}\n\n// ------------------------------------------------------------\n// 2D Fractal Brownian Motion\n// ------------------------------------------------------------\n\nfloat", "\n    vec3 floor = floor(p);\n    vec3 ceiling = floor + vec3(1.0);\n\n    // get the distance to the floor and ceiling\n    vec3 dist_floor = p - floor;\n    vec3 dist_ceiling = ceiling - p;\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge = min(dist_floor, dist_ceiling);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner = min(dist_to_edge, min(dist_floor.yzx, dist_floor.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_2 = min(dist_ceiling, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_2 = min(dist_to_edge_2, min(dist_ceiling.yzx, dist_ceiling.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_3 = min(dist_to_corner_2, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_3 = min(dist_to_edge_3, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_4 = min(dist_to_corner_3, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_4 = min(dist_to_edge_4, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_5 = min(dist_to_corner_4, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_5 = min(dist_to_edge_5, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(par, rd);\n    if (t > 0.0)\n    {\n        sky = par * t;\n    }\n    return sky;\n}\n\nvec", "\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k4", "\n    float r = atan(p.y, p.x) + PI/2;\n    float a = atan(diamond.y, diamond.x);\n    float d = abs(r - a);\n    if (d > PI/2) d = PI - d;\n    return d;\n}\n\nfloat", "\n    // to avoid the need for a separate texture.\n    vec3 color = vec3(0.0);\n    color += texture(iChannel0, uv).rgb;\n    color += texture(iChannel1, uv).rgb;\n    color += texture(iChannel2, uv).rgb;\n    color += texture(iChannel3, uv).rgb;\n    color += texture(iChannel4, uv).rgb;\n    color += texture(iChannel5, uv).rgb;\n    color += texture(iChannel6, uv).rgb;\n    color += texture(iChannel7, uv).rgb;\n    color += texture(iChannel8, uv).rgb;\n    color += texture(iChannel9, uv).rgb;\n    color += texture(iChannel10, uv).rgb;\n    color += texture(iChannel11, uv).rgb;\n    color += texture(iChannel12, uv).rgb;\n    color += texture(iChannel13, uv).rgb;\n    color += texture(iChannel14, uv).rgb;\n    color += texture(iChannel15, uv).rgb;\n    color += texture(iChannel16, uv).rgb;\n    color += texture(iChannel17, uv).rgb;\n    color += texture(iChannel18, uv).rgb;\n    color += texture(iChannel19, uv).rgb;\n    color += texture(iChannel20, uv).rgb;\n    color += texture(iChannel21, uv).rgb;\n    color += texture(iChannel22, uv).rgb;\n    color += texture(iChannel23, uv).rgb;\n    color += texture(iChannel24, uv).rgb;\n    color += texture(iChannel25, uv).rgb;\n    color += texture(iChannel26, uv).rgb;\n    color += texture(iChannel27, uv).rgb;\n    color += texture(iChannel28, uv).rgb;\n   ", "\n\tfloat d = 1000000.0;\n\t\n\t//...add objects here...\n\t\n\treturn d;\n}\n\n// --------------------------------------------------------\n// \n// \tMain\n// \n// --------------------------------------------------------\n\nvoid main()\n{\n\tvec3 pos = vec3(0.0);\n\t\n\tfloat d = dist_field( pos );\n\t\n\tgl_FragColor = vec4( d );\n}\n", "\n\tvec3 light = vec3( 0.0 );\n\tvec3 diffuse = vec3( 0.0 );\n\tvec3 specular = vec3( 0.0 );\n\tvec3 ambient = vec3( 0.0 );\n\tvec3 halfV = normalize( eye + v );\n\tfloat shininess = 10.0;\n\tfloat attenuation = 1.0;\n\tfloat spotlight = 0.0;\n\tfloat spotlight_cutoff = 0.0;\n\tfloat spotlight_outercutoff = 0.0;\n\tfloat spotlight_constant = 0.0;\n\tfloat spotlight_linear = 0.0;\n\tfloat spotlight_quadratic = 0.0;\n\tfloat spotlight_cutoff_cos = 0.0;\n\tfloat spotlight_outercutoff_cos = 0.0;\n\tfloat spotlight_constant_cos = 0.0;\n\tfloat spotlight_linear_cos = 0.0;\n\tfloat spotlight_quadratic_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos_cos = 0.0;", "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n\n    // This is the original, but it's a bit slower.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float aa = a;\n    //Increase Activity Level For Better Performance\n    float aa2 = aa*aa;\n    //Increase Activity Level For Better Performance\n    float aa3 = aa*aa2;\n    //Increase Activity Level For Better Performance\n    float aa4 = aa*aa3;\n    //Increase Activity Level For Better Performance\n    float aa5 = aa*aa4;\n    //Increase Activity Level For Better Performance\n    float aa6 = aa*aa5;\n    //Increase Activity Level For Better Performance\n    float aa7 = aa*aa6;\n    //Increase Activity Level For Better Performance\n    float aa8 = aa*aa7;\n    //Increase Activity Level For Better Performance\n    float aa9 = aa*aa8;\n    //Increase Activity Level For Better Performance\n    float aa10 = aa*aa9;\n    //Increase Activity Level For Better Performance\n    float aa11 = aa*aa10;\n    //Increase Activity Level For Better Performance\n    float aa12 = aa*aa11;\n    //Increase Activity Level For Better Performance\n    float aa13 = aa*aa12;\n    //Increase Activity Level For Better Performance\n    float aa14 = aa*aa13;\n    //Increase Activity Level For Better Performance\n    float aa15 = aa*aa14;\n    //Increase Activity Level For Better Performance\n    float aa16 = aa*aa15;\n    //Increase Activity Level For Better Performance\n    float aa17 = aa*aa16;\n    //Increase Activity Level For Better Performance\n    float aa18 = aa*aa17;\n    //Increase Activity Level For Better Performance\n    float aa19 = aa*aa18;\n    //Increase Activity Level For Better Performance\n    float aa20 = aa*aa19;\n    //Increase Activity Level For Better Performance\n    float aa21 = aa*aa20;\n   ", "\n    float d = length(p.xz) - r;\n    // How far along the cylinder the point is, vertically\n    float a = p.y;\n    // If the point is inside the cylinder, return the distance to the\n    // nearest point on the cylinder. If the point is outside the cylinder,\n    // return the distance to the nearest point on the cylinder's top or\n    // bottom.\n    return max(d, -a + h);\n}\n\nfloat", "\n    float t = iGlobalTime * 0.001;\n    p.xz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p.y *= 0.5;\n\n    // SDF of the scene\n    float sdf = sceneSDF(p);\n\n    // Add some noise to the scene\n    sdf += noise(p * 10.0) * 0.01;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100.0) * 0.001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000.0) * 0.0001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000.0) * 0.00001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000.0) * 0.000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000.0) * 0.0000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000.0) * 0.00000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000000.0) * 0.000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000000.0) * 0.0000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000000.0) * 0.00000000001;\n\n    // Add some more noise to the scene\n    sdf += noise", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    mat3 m = mat3(s.x, u.x, f.x,\n                  s.y, u.y, f.y,\n                  s.z, u.z, f.z);\n\n    return m * mat3(1, 0, 0,\n                    0, 1, 0,\n                    -eye.x, -eye.y, -eye.z);\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    mat3 viewMatrix = viewMatrix(eye, center, up);\n\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    vec3 normal = normalize(inNormal);\n    vec3 lightDir = normalize(lightPos - inPosition);\n    vec3 viewDir = normalize(eye - inPosition);\n\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specularColor = specular * lightColor;\n\n    color = (diffuseColor + specularColor) * inColor;\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float t = (p.x+p.y+p.z)*0.0001;\n    return t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0);\n    p.x = tweaknoise(p);\n    p.y = tweaknoise(p);\n    p.z = tweaknoise(p);\n    gl_FragColor = vec4(p, 1.0);\n}\n", "\n    //I'm not sure if this is the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not", "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat", "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.y *= mat2(1.0, 0.0, 0.0, 1.0);\n    return q;\n}\n\n// This is the bump function that I'm using. It's a bit more complex than\n// the standard cylindrical mapping, but it's much more accurate.\nvec", "\n    // scr_pt is in screen space, and is in range [0,1]x[0,1].\n    // view_inv is the inverse of the view matrix.\n    // proj_inv is the inverse of the projection matrix.\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera", "\n    float r = length(pA - pB);\n    r = min(r, rounded);\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, uv);\n\n    // If the distance is less than the thickness, it's on the line.\n    if (d < thick.x) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the thickness, it's not on the line.\n    if (d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the thickness and the rounded radius, it's on the line.\n    if (d > thick.x && d < thick.y) {\n        return 1.0 - smoothstep(thick.x, thick.y, d);\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 half_dir = normalize(light_dir + view_dir);\n  float diffuse = max(0.0, dot(n, light_dir));\n  float specular = pow(max(0.0, dot(n, half_dir)), 16.0);\n  return vec3(diffuse, diffuse, diffuse) * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * specular;\n}\n\nvoid main()\n{\n  vec3 n = normalize(normal);\n  vec3 p = vec3(position);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < num_lights; i++)\n  {\n    color += Shade(p, n);\n  }\n  color = clamp(color, 0.0, 1.0);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t1.y, t1.z);\n\tfloat tS = max(t2.y, t2.z);\n\tfloat tFar = max(tF, tB);\n\tfloat tNear = min(tL, tS);\n\tfloat t = max(tN, tNear);\n\tif( t > tFar )\n\t\treturn vec2( -1.0 );\n\treturn vec2( t, tNear );\n}\n\n// ray-sphere intersection\nvec", "\n    float wave = (sin(x * a) + sin(x * b)) / 2;\n    return wave;\n}\n\nfloat", "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize( ab );\n    // center the cylinder\n    vec3 ca = pa + abn * 0.5;\n    // distance to cylinder\n    float d = length( rd - ca );\n    // cylinder radius\n    float r = length( pb - pa ) * 0.5;\n    // cylinder height\n    float h = length( pb - pa ) * 0.5;\n    // cylinder normal\n    vec3 n = normalize( pb - pa );\n    // cylinder normal\n    vec3 nn = normalize( n );\n    // cylinder normal\n    vec3 nn2 = normalize( nn );\n    // cylinder normal\n    vec3 nn3 = normalize( nn2 );\n    // cylinder normal\n    vec3 nn4 = normalize( nn3 );\n    // cylinder normal\n    vec3 nn5 = normalize( nn4 );\n    // cylinder normal\n    vec3 nn6 = normalize( nn5 );\n    // cylinder normal\n    vec3 nn7 = normalize( nn6 );\n    // cylinder normal\n    vec3 nn8 = normalize( nn7 );\n    // cylinder normal\n    vec3 nn9 = normalize( nn8 );\n    // cylinder normal\n    vec3 nn10 = normalize( nn9 );\n    // cylinder normal\n    vec3 nn11 = normalize( nn10 );\n    // cylinder normal\n    vec3 nn12 = normalize( nn11 );\n    // cylinder normal\n    vec3 nn13 = normalize( nn12 );\n    // cylinder normal\n    vec3 nn14 = normalize( nn13 );\n    // cylinder normal\n    vec3 nn15 = normalize( nn14 );\n    // cylinder normal\n    vec3 nn16 = normalize( nn15 );\n    // cylinder normal\n    vec3 nn17 = normalize( nn16 );\n    // cylinder normal\n    vec3 nn", "\n\n\tfloat d = length(P-U);\n\tfloat a = smoothstep(r,r+.001,d);\n\tO.xyz = mix(O.xyz,C,a);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n\tvec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n\tvec2 P = (2.*U-R)/R.y;\n\t\n\tvec3 C = vec3(0.);\n\t\n\tsphere(O,U,P,0.001,vec3(1.,0.,0.));\n\tsphere(O,U,P,0.002,vec3(0.,1.,0.));\n\tsphere(O,U,P,0.003,vec3(0.,0.,1.));\n\tsphere(O,U,P,0.004,vec3(1.,1.,0.));\n\tsphere(O,U,P,0.005,vec3(1.,0.,1.));\n\tsphere(O,U,P,0.006,vec3(0.,1.,1.));\n\tsphere(O,U,P,0.007,vec3(1.,1.,1.));\n\t\n\tO.xyz = mix(O.xyz,C,smoothstep(.9,.0,length(P-M)));\n}\n\nvoid main() {\n\tmainImage(O,U);\n}\n", "\n    float d = dot(p, p) * 100.0;\n    p.x += sin(d) * 0.01;\n    p.y += cos(d) * 0.01;\n    p.z += sin(d) * 0.01;\n\n    // map the scene\n    p = p * 0.5 + 0.5;\n    p.x = p.x * 2.0 - 1.0;\n    p.y = p.y * 2.0 - 1.0;\n    p.z = p.z * 2.0 - 1.0;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.", "\n    vec2 grid = floor(p);\n    vec2 f = fract(p);\n\n    // We need to scale the grid coordinates by the scale factor.\n    vec2 scale = vec2(1.0, 1.0);\n    scale.x = (grid.x + f.x) * scale.x;\n    scale.y = (grid.y + f.y) * scale.y;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleID = layerID * scale.x;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleDec = layerID * scale.y;\n\n    return vec3(scale.x, scale.y, scaleDec);\n}\n\n// This function will be used to draw the grid.\nvec", "\n    float scale = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f\n    float distance = length(currentRayPosition.xz) - 1.0;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f \u043c\u0435\u043d\u044c\u0448\u0435 0.001, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.001)\n        return 1.0;\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u043f\u043b\u0430\u043c\u044f\n    float k = (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0);\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = vec3(0.0);\n    color.r = k * 0.5;\n    color.g = k * 0.5;\n    color.b = k * 0.5;\n\n    // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    return color;\n}\n\nvoid main()\n{\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\n    vec3 currentRayPosition = vec3(gl_FragCoord.xy, 0.0);\n\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = flame(currentRayPosition);\n\n    // \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    gl_FragColor = vec4(color, 1.0);\n}", "\n    float flameDistance = abs(scene(currentRayPosition));\n    // \u0435\u0441\u043b\u0438 \u043f\u043b\u0430\u043c\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u043f\u0440\u0435\u0434\u0435\u043b\u0430\u0445 \u0441\u0446\u0435\u043d\u044b, \u0442\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n    if (flameDistance < 0.001)\n    {\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n        vec3 color = vec3(0.0, 0.0, 0.0);\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0441\u0432\u0435\u0442\u043b\u0435\u043d\u0438\u044f\n        float lightIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float shadowIntensity = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float specularIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio2 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio3 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio4 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio5 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio6 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio7 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio8 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c", "\n    float s = sm;\n    \n    // The fractal function.\n    float f = fract(x);\n    \n    // The fractal function.\n    float f2 = f * f;\n    \n    // The fractal function.\n    float f3 = f2 * f;\n    \n    // The fractal function.\n    float f4 = f3 * f;\n    \n    // The fractal function.\n    float f5 = f4 * f;\n    \n    // The fractal function.\n    float f6 = f5 * f;\n    \n    // The fractal function.\n    float f7 = f6 * f;\n    \n    // The fractal function.\n    float f8 = f7 * f;\n    \n    // The fractal function.\n    float f9 = f8 * f;\n    \n    // The fractal function.\n    float f10 = f9 * f;\n    \n    // The fractal function.\n    float f11 = f10 * f;\n    \n    // The fractal function.\n    float f12 = f11 * f;\n    \n    // The fractal function.\n    float f13 = f12 * f;\n    \n    // The fractal function.\n    float f14 = f13 * f;\n    \n    // The fractal function.\n    float f15 = f14 * f;\n    \n    // The fractal function.\n    float f16 = f15 * f;\n    \n    // The fractal function.\n    float f17 = f16 * f;\n    \n    // The fractal function.\n    float f18 = f17 * f;\n    \n    // The fractal function.\n    float f19 = f18 * f;\n    \n    // The fractal function.\n    float f20 = f19 * f;\n    \n    // The fractal function.\n    float f21 = f20 * f;\n    \n    // The fractal function.\n    float f22 = f21 * f;\n    \n    // The fractal function.\n    float f23 = f22 *", "\n\n    // p = p * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // Determine the first vertice.\n    vec3 q = p - f;\n\n    // Determine the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 113.0)),\n                        dot(q, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                    mix(dot(q, vec3(113.0, 57.0, 17.0)),\n                        dot(q, vec3(17.0, 113.0, 57.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(57.0, 17.0, 113.0)),\n                        dot(q, vec3(17.0, 57.0, 113.0)),\n                        f.z),\n                   mix(dot(q, vec3(113.0, 17.0, 57.0)),\n                       dot(q, vec3(17.0, 113.0, 57.0)),\n                       f.z),\n                   f.x),\n               f.x);\n\n    // Determine the first vertice.\n    return mix(mix(mix(w.x, w.y, f.x), w.z, f.y), w.w, f.z);\n}\n\nfloat", "\n    float n = 0.0;\n    \n    // The frequency.\n    float f = 1.0;\n    \n    // The amplitude.\n    float a = 1.0;\n    \n    // The number of octaves.\n    int o = 1;\n    \n    // The persistence.\n    float p = 0.5;\n    \n    // The offset.\n    float of = 0.0;\n    \n    // The scale.\n    float s = 1.0;\n    \n    // The number of iterations.\n    int i = 0;\n    \n    // The total value.\n    float t = 0.0;\n    \n    // The total value.\n    float t2 = 0.0;\n    \n    // The total value.\n    float t3 = 0.0;\n    \n    // The total value.\n    float t4 = 0.0;\n    \n    // The total value.\n    float t5 = 0.0;\n    \n    // The total value.\n    float t6 = 0.0;\n    \n    // The total value.\n    float t7 = 0.0;\n    \n    // The total value.\n    float t8 = 0.0;\n    \n    // The total value.\n    float t9 = 0.0;\n    \n    // The total value.\n    float t10 = 0.0;\n    \n    // The total value.\n    float t11 = 0.0;\n    \n    // The total value.\n    float t12 = 0.0;\n    \n    // The total value.\n    float t13 = 0.0;\n    \n    // The total value.\n    float t14 = 0.0;\n    \n    // The total value.\n    float t15 = 0.0;\n    \n    // The total value.\n    float t16 = 0.0;\n    \n    // The total value.\n    float t17 = 0.0;\n    \n    // The total value.\n    float t18 = 0.0;\n    \n    // The total value.\n    float t19 = 0.0;\n    \n    // The total value.\n    float", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // Then we define our balloon height\n  float balloonHeight = 0.05;\n  \n  // Then we define our balloon width\n  float balloonWidth = 0.05;\n  \n  // Then we define our balloon depth\n  float balloonDepth = 0.05;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.", "\n\tvec3 tmin = (rad - ro) / rd;\n\tvec3 tmax = (rad + ro) / rd;\n\n\t// find the largest entering t value first\n\tvec3 t1 = max(tmin, tmax);\n\tvec3 t2 = min(tmin, tmax);\n\n\t// find the smallest exiting t value\n\tvec3 tmin2 = max(t2, t1);\n\tvec3 tmax2 = min(t2, t1);\n\n\t// find the largest entering t value first\n\tvec3 t3 = max(tmin2, tmax2);\n\tvec3 t4 = min(tmin2, tmax2);\n\n\t// find the smallest exiting t value\n\tvec3 tmin3 = max(t4, t3);\n\tvec3 tmax3 = min(t4, t3);\n\n\t// find the largest entering t value first\n\tvec3 t5 = max(tmin3, tmax3);\n\tvec3 t6 = min(tmin3, tmax3);\n\n\t// find the smallest exiting t value\n\tvec3 tmin4 = max(t6, t5);\n\tvec3 tmax4 = min(t6, t5);\n\n\t// find the largest entering t value first\n\tvec3 t7 = max(tmin4, tmax4);\n\tvec3 t8 = min(tmin4, tmax4);\n\n\t// find the smallest exiting t value\n\tvec3 tmin5 = max(t8, t7);\n\tvec3 tmax5 = min(t8, t7);\n\n\t// find the largest entering t value first\n\tvec3 t9 = max(tmin5, tmax5);\n\tvec3 t10 = min(tmin5, tmax5);\n\n\t// find the smallest exiting t value\n\tvec3 tmin6 = max(t10, t9);\n\tvec3 tmax6 = min(t10, t9);\n\n\t// find the largest entering t value first\n\tvec3 t11 = max(tmin6, tmax6);\n\tvec3 t12 = min(tmin6, tmax6);\n\n\t// find the", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 q = p - f;\n    \n    // Determining the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 21.0)),\n                        dot(q, vec3(57.0, 159.0, 23.0)),\n                        f.y),\n                    mix(dot(q, vec3(73.0, 91.0, 3.0)),\n                        dot(q, vec3(27.0, 19.0, 153.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(17.0, 103.0, 7.0)),\n                        dot(q, vec3(13.0, 99.0, 15.0)),\n                        f.y),\n                   dot(q, vec3(83.0, 11.0, 89.0)),\n                   f.z),\n               f.x);\n    \n    // Determining the first vertice.\n    return mix(w.x, w.y, w.z);\n}\n\nfloat", "\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monoch", "\n    //Use a for loop to make sure the loop is executed at least once.\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return vec4(i, 0.0, 0.0, 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec4 color = mandelbrot(c, c);\n    gl_FragColor = vec4(color.xyz, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the matrix\n    mat4 mat = mat4(x.x, x.y, x.z, 0.0,\n                    y.x, y.y, y.z, 0.0,\n                    z.x, z.y, z.z, 0.0,\n                    0.0, 0.0, 0.0, 1.0);\n\n    return mat;\n}\n\nvec", "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),clamp(rgb+vec3(0.0,1.0,1.0),0.0,1.0),c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= resolution.x / resolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = time * 0.005;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float h = atan(p.y, p.x) / (2.0 * 3.1415926535897932384626433832795);\n    vec3 hsv = vec3(h, s, c);\n    vec3 rgb = hsv2rgb(hsv);\n\n    col = mix(col, rgb, 0.5);\n\n    gl_FragColor = vec4(col, 1.0);\n}", "\n    float d = w / 2.0;\n    float x = floor(p.x / d);\n    float y = floor(p.y / d);\n    float xf = fract(p.x / d);\n    float yf = fract(p.y / d);\n    float xd = x + xf;\n    float yd = y + yf;\n    float xd2 = xd + xf;\n    float yd2 = yd + yf;\n    float xd3 = xd + xf + xf;\n    float yd3 = yd + yf + yf;\n    float xd4 = xd + xf + xf + xf;\n    float yd4 = yd + yf + yf + yf;\n    float xd5 = xd + xf + xf + xf + xf;\n    float yd5 = yd + yf + yf + yf + yf;\n    float xd6 = xd + xf + xf + xf + xf + xf;\n    float yd6 = yd + yf + yf + yf + yf + yf;\n    float xd7 = xd + xf + xf + xf + xf + xf + xf;\n    float yd7 = yd + yf + yf + yf + yf + yf + yf;\n    float xd8 = xd + xf + xf + xf + xf + xf + xf + xf;\n    float yd8 = yd + yf + yf + yf + yf + yf + yf + yf;\n    float xd9 = xd + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd9 = yd + yf + yf + yf + yf + yf + yf + yf + yf;\n    float xd10 = xd + xf + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd10 = yd", "\n    if (a == b)\n        return 0.0f;\n\n    // clamp x to be between a and b\n    if (x < a)\n        x = a;\n    else if (x > b)\n        x = b;\n\n    // calculate the step\n    float step = (x - a) / (b - a);\n\n    // return the step\n    return step;\n}\n\n//src/math/vec2.h\n#pragma once\n\n#include <math.h>\n\nstruct vec2\n{\n    float x, y;\n\n    vec2() : x(0.0f), y(0.0f) {}\n    vec2(float x, float y) : x(x), y(y) {}\n\n    vec2 operator+(const vec2& v) const\n    {\n        return vec2(x + v.x, y + v.y);\n    }\n\n    vec2 operator-(const vec2& v) const\n    {\n        return vec2(x - v.x, y - v.y);\n    }\n\n    vec2 operator*(const vec2& v) const\n    {\n        return vec2(x * v.x, y * v.y);\n    }\n\n    vec2 operator/(const vec2& v) const\n    {\n        return vec2(x / v.x, y / v.y);\n    }\n\n    vec2 operator*(float s) const\n    {\n        return vec2(x * s, y * s);\n    }\n\n    vec2 operator/(float s) const\n    {\n        return vec2(x / s, y / s);\n    }\n\n    vec2 operator-() const\n    {\n        return vec2(-x, -y);\n    }\n\n    vec2& operator+=(const vec2& v)\n    {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n\n    vec2& operator-=(const vec2& v)\n    {\n        x -= v", "\n    float dist = sampleFunc(xy);\n\n    // if the distance is less than the curve, then the pixel is on the curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\nvoid main()\n{\n    // get the xy coordinates of the pixel\n    vec2 xy = gl_FragCoord.xy / resolution;\n\n    // get the color of the pixel\n    vec4 baseCol = texture(tex, xy);\n\n    // draw the curve\n    drawFunc(baseCol, xy, curveCol);\n\n    // write the color to the framebuffer\n    gl_FragColor = baseCol;\n}\n", "\n float x = p.x + cos(j*2.0*3.1415926535897932384626433832795)*0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n //return f;\n //return f*f;\n //return f*f*f;\n //return f*f*f*f;\n //return f*f*f*f*f;\n //return f*f*f*f*f*f;\n //return f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*", "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec", "\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox", "\n //return sdSuperprim(p,s,r);\n //}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(", "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp(x * (2.51 * x + 0.04), vec3(0.0), vec3(1.0));\n}\n\nvec", "\n    p.z -= 10.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 v = normalize(p - cameraPos);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), v));\n    vec3 u = cross(v, r);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 c = cameraPos + v;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 rd = normalize(p - c);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    float t = 0.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    for (int i = 0; i < 100; i++) {\n        vec3 p = c + rd * t;\n        float d = map(p);\n        t += d;\n    }\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    return t;\n}\n\n// The camera is at (0,0,0) and looks at (0,0,1)\nfloat", "\n    float r = 0.5;\n    vec3 p2 = p - vec3(0.0, 0.0, 0.0);\n    float d = length(p2);\n    if (d < r) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    //plane\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float t = dot(p2, n) / dot(p2, n);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return p2 - n * t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3", "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    // scale and bias the point\n    p = p * 2.0 - 1.0;\n    p.x *= m.x;\n    p.y *= m.y;\n    // add in the axial bias\n    p.x += fbm( p + vec2( 0.0, 0.0 ) );\n    p.y += fbm( p + vec2( 0.0, 0.0 ) );\n    // return the noise value\n    return fbm( p );\n}\n\nfloat", "\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point", "\n return dot(u,m);\n}\n\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\nfloat", ".\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2", "\n /*O*/\n return v1;\n}\n\nint", "\n /*O*/\n return v1;\n}\n\nint", "\n    return cross(a, b);\n}\n\nvec", "\n\tfloat alpha = acos(dot(normalize(A), normalize(B)));\n\tfloat beta = acos(dot(normalize(B), normalize(C)));\n\tfloat gamma = acos(dot(normalize(C), normalize(A)));\n\n\t//calculate the coordinates of the point on the sphere\n\tvec3 p = vec3(cos(alpha) * cos(beta) * cos(gamma) + Xi1, cos(alpha) * cos(beta) * sin(gamma) + Xi2, sin(alpha) * cos(beta) + sin(gamma));\n\n\t//calculate the pdf of the point on the sphere\n\twPdf = (1.0 / (4.0 * PI)) * (1.0 - cos(alpha) * cos(beta) * cos(gamma)) / (p.x * p.x + p.y * p.y + p.z * p.z);\n\n\t//calculate the direction of the point on the sphere\n\tw = normalize(p);\n}\n\nvoid main() {\n\t//calculate the coordinates of the point on the sphere\n\tvec3 w;\n\tfloat wPdf;\n\tsampleSphericalTriangle(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), uv.x, uv.y, w, wPdf);\n\n\t//calculate the pdf of the point on the sphere\n\tfloat pdf = (1.0 / (4.0 * PI)) * (1.0 - w.x * w.x - w.y * w.y - w.z * w.z) / (w.x * w.x + w.y * w.y + w.z * w.z);\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosTheta = dot(w, normalize(normal));\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosPhi = dot(w, normalize(vec3(0.0", "\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n", "\n    \n    // The tube is a 1D function, so we can use the \"fract\" function to get the fractional part of the x coordinate.\n    float t = fract(p.x);\n    \n    // The tube is a 2D function, so we can use the \"fract\" function to get the fractional part of the y coordinate.\n    float t2 = fract(p.y);\n    \n    // The tube is a 3D function, so we can use the \"fract\" function to get the fractional part of the z coordinate.\n    float t3 = fract(p.z);\n    \n    // The tube is a 4D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t4 = fract(p.w);\n    \n    // The tube is a 5D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t5 = fract(p.w);\n    \n    // The tube is a 6D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t6 = fract(p.w);\n    \n    // The tube is a 7D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t7 = fract(p.w);\n    \n    // The tube is a 8D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t8 = fract(p.w);\n    \n    // The tube is a 9D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t9 = fract(p.w);\n    \n    // The tube is a 10D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t10 = fract(p.w);\n    \n    // The tube is a 11D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t1", "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.005;\n\n    // Tube offset.\n    float tubeOffset = 0.005;\n\n    // Tube offset.\n    float tubeOffset2 = 0.005;\n\n    // Tube offset.\n    float tubeOffset3 = 0.005;\n\n    // Tube offset.\n    float tubeOffset4 = 0.005;\n\n    // Tube offset.\n    float tubeOffset5 = 0.005;\n\n    // Tube offset.\n    float tubeOffset6 = 0.005;\n\n    // Tube offset.\n    float tubeOffset7 = 0.005;\n\n    // Tube offset.\n    float tubeOffset8 = 0.005;\n\n    // Tube offset.\n    float tubeOffset9 = 0.005;\n\n    // Tube offset.\n    float tubeOffset10 = 0.005;\n\n    // Tube offset.\n    float tubeOffset11 = 0.005;\n\n    // Tube offset.\n    float tubeOffset12 = 0.005;\n\n    // Tube offset.\n    float tubeOffset13 = 0.005;\n\n    // Tube offset.\n    float tubeOffset14 = 0.005;\n\n    // Tube offset.\n    float tubeOffset15 = 0.005;\n\n    // Tube offset.\n    float tubeOffset16 = 0.005;\n\n    // Tube offset.\n    float tubeOffset17 = 0.005;\n\n    // Tube offset.\n    float tubeOffset18 = 0.005;\n\n    // Tube offset.\n    float tubeOffset19 = 0.005;\n\n    // Tube offset.\n    float tubeOffset20 = 0.005;\n\n    // Tube offset", "\n    int gID_int = int(gID);\n    \n    // The cubic grid cell is a 3x3x3 cube.\n    // The grid cell is divided into 8 sub-cells.\n    // The sub-cells are divided into 8 sub-sub-cells.\n    // The sub-sub-cells are divided into 8 sub-sub-sub-cells.\n    // The sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub", "\n    float t = 0., tmin = 1e10;\n    \n    // Ray position\n    vec3 p = o;\n    \n    // Ray direction\n    vec3 d = r;\n    \n    // Ray step size\n    float dt = 0.001;\n    \n    // Ray step size\n    float dp = 0.001;\n    \n    // Ray step size\n    float ddt = 0.001;\n    \n    // Ray step size\n    float ddp = 0.001;\n    \n    // Ray step size\n    float dddt = 0.001;\n    \n    // Ray step size\n    float ddddp = 0.001;\n    \n    // Ray step size\n    float ddddt = 0.001;\n    \n    // Ray step size\n    float dddddp = 0.001;\n    \n    // Ray step size\n    float ddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddddp = 0.001;\n", "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm", "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting", "\n    vec3 w = m * p3;\n    vec3 w2 = w * w;\n    vec3 w3 = w2 * w;\n    vec3 w4 = w3 * w;\n    vec3 w5 = w4 * w;\n    vec3 w6 = w5 * w;\n    vec3 w7 = w6 * w;\n    vec3 w8 = w7 * w;\n    vec3 w9 = w8 * w;\n    vec3 w10 = w9 * w;\n    vec3 w11 = w10 * w;\n    vec3 w12 = w11 * w;\n    vec3 w13 = w12 * w;\n    vec3 w14 = w13 * w;\n    vec3 w15 = w14 * w;\n    vec3 w16 = w15 * w;\n    vec3 w17 = w16 * w;\n    vec3 w18 = w17 * w;\n    vec3 w19 = w18 * w;\n    vec3 w20 = w19 * w;\n    vec3 w21 = w20 * w;\n    vec3 w22 = w21 * w;\n    vec3 w23 = w22 * w;\n    vec3 w24 = w23 * w;\n    vec3 w25 = w24 * w;\n    vec3 w26 = w25 * w;\n    vec3 w27 = w26 * w;\n    vec3 w28 = w27 * w;\n    vec3 w29 = w28 * w;\n    vec3 w30 = w29 * w;\n    vec3 w31 = w30 * w;\n    vec3 w32 = w31 * w;\n    vec3 w33 = w32 * w;\n    vec3 w34 = w33 * w;\n    vec3 w35 = w34 * w;\n    vec3 w36", "\n    vec4 hex1 = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 hex2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints3 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints4 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints5 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints6 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints7 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some", "\n    return df_truchet(p, dir) +.1;\n}\n\n// This is the main function that does the actual rendering.\n// It's a bit of a mess, but it's basically a loop over all pixels,\n// and for each pixel, it calls the raytracing function to get the color.\n// The raytracing function is a bit more complicated than I'd like, but it's\n// basically just a raytracing function that takes a ray, and returns the color\n// of the ray.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.", "\n    float t = (q.x + q.y) * 0.5;\n    float r = (q.x - q.y) * 0.5;\n    \n    // Polar conversion.\n    float theta = atan2(r, t);\n    float phi = dir * theta;\n    \n    // Return the polar coordinates.\n    return vec2(phi, r);\n}\n\nvoid main()\n{\n    // Get the polar coordinates.\n    vec2 q = getPolarCoord(vUV, vDir);\n    \n    // Get the distance from the center.\n    float d = length(q);\n    \n    // Get the angle from the center.\n    float a = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a2 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a3 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a4 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a5 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a6 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a7 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a8 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a9 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a10 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a11 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a12 = atan(q.y, q.x);\n    \n    // Get the angle from the", "\n    vec3 w = p3 - n[0];\n    float d00 = dot(w, n[0]);\n    float d01 = dot(w, n[1]);\n    float d02 = dot(w, n[2]);\n    float d11 = dot(w, n[1] - n[0]);\n    float d22 = dot(w, n[2] - n[0]);\n    float d33 = dot(w, n[2] - n[1]);\n    float inv_denom = 1.0 / (d00 * d11 * d22 + d01 * d12 * d20 + d02 * d10 * d21 - d00 * d12 * d21 - d01 * d10 * d22 - d02 * d11 * d20);\n    vec3 v = vec3(\n        (d11 * d33 - d01 * d23) * inv_denom,\n        (d02 * d23 - d03 * d12) * inv_denom,\n        (d01 * d13 - d03 * d11) * inv_denom\n    );\n    return v;\n}\n\nvec", ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| >= |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| < |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p.", "\n    // The only difference is that the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n   ", "\n\tfloat k00 = -0.25;\n\tfloat k10 =  0.25;\n\tfloat k01 = -0.25;\n\tfloat k11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat dk00 = -0.25;\n\tfloat dk10 =  0.25;\n\tfloat dk01 = -0.25;\n\tfloat dk11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat ddx0 = dk00 * ddx.x + dk10 * ddx.y;\n\tfloat ddx1 = dk01 * ddx.x + dk11 * ddx.y;\n\tfloat ddy0 = dk00 * ddy.x + dk10 * ddy.y;\n\tfloat ddy1 = dk01 * ddy.x + dk11 * ddy.y;\n\n\t// filter kernel derivatives\n\tfloat ddx2 = ddx0 * ddx0 + ddx1 * ddx1;\n\tfloat ddy2 = ddy0 * ddy0 + ddy1 * ddy1;\n\n\t// filter kernel derivatives\n\tfloat ddx3 = ddx2 * ddx2;\n\tfloat ddy3 = ddy2 * ddy2;\n\n\t// filter kernel derivatives\n\tfloat ddx4 = ddx3 * ddx3;\n\tfloat ddy4 = ddy3 * ddy3;\n\n\t// filter kernel derivatives\n\tfloat ddx5 = ddx4 * ddx4;\n\tfloat ddy5 = ddy4 * ddy4;\n\n\t// filter kernel derivatives\n\tfloat ddx6 = ddx5 * ddx5;\n\tfloat ddy6 = ddy5 * ddy5;\n\n\t// filter kernel derivatives\n\tfloat ddx7 = ddx6 * ddx6;\n\tfloat ddy7 = ddy6 * ddy6;\n\n\t// filter kernel derivatives\n\tfloat ddx8 = ddx7 * ddx7;\n\tfloat ddy8 = ddy7 * ddy7;\n\n\t// filter kernel derivatives\n\tfloat ddx9 = ddx8", "\n    vec2 p = floor( n );\n\n    // get the fractional part of the cell position\n    vec2 fp = fract( n );\n\n    // get the distance to the closest point\n    float d = distance( f, fp );\n\n    // get the distance to the farthest point\n    float d2 = distance( fp, vec2( 1.0 ) );\n\n    // get the distance to the closest point in the x direction\n    float dx = abs( fp.x - f.x );\n\n    // get the distance to the farthest point in the x direction\n    float dx2 = abs( fp.x - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dy = abs( fp.y - f.y );\n\n    // get the distance to the farthest point in the y direction\n    float dy2 = abs( fp.y - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dz = abs( fp.z - f.z );\n\n    // get the distance to the farthest point in the x direction\n    float dz2 = abs( fp.z - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dw = abs( fp.w - f.w );\n\n    // get the distance to the farthest point in the y direction\n    float dw2 = abs( fp.w - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dxy = abs( fp.xy - f.xy );\n\n    // get the distance to the farthest point in the x direction\n    float dxy2 = abs( fp.xy - vec2( 1.0 ) );\n\n    // get the distance to the closest point in the y direction\n    float dxyz = abs( fp.xyz - f.xyz );\n\n    // get the distance to the farthest point in the y direction\n    float dxyz2 = abs( fp.xyz - vec3( 1.0 ) );\n\n    // get the distance", "\n    return (1.0f - t) * p1 + t * p2;\n}\n\nvoid main()\n{\n    vec2 pos = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_2 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_3 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_4 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_5 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_6 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_7 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_8 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_9 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_10 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_11 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_12 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_13 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_14 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_15 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_16 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_17 =", "\n\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0", "\n\n    // This is a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Centroid.\n    vec2 cent = (p0 + p1 + p2) / 3.0;\n    \n    // Return.\n    return vec4(cent, alpha, beta, gamma);\n}\n\n// Compute the area of a triangle.\nfloat", "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n\n    // Radii.\n    float r1 = a * sin(alpha);\n    float r2 = b * sin(beta);\n    float r3 = c * sin(gamma);\n\n    // Area.\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumference.\n    float c1 = r1 + r2 + r3;\n\n    // Return the area and circumference.\n    return vec2(area, c1);\n}\n\n// Returns the area and circumference of a triangle.\nvec", "\n   // Returns distance to paraboloid.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2", "\n    vec2 v0 = vec2(0.0, 0.0);\n    vec2 v1 = vec2(1.0, 0.0);\n    vec2 v2 = vec2(0.0, 1.0);\n    \n    vec2 v3 = vec2(0.0, 0.0);\n    vec2 v4 = vec2(1.0, 0.0);\n    vec2 v5 = vec2(0.0, 1.0);\n    \n    vec2 v6 = vec2(0.0, 0.0);\n    vec2 v7 = vec2(1.0, 0.0);\n    vec2 v8 = vec2(0.0, 1.0);\n    \n    vec2 v9 = vec2(0.0, 0.0);\n    vec2 v10 = vec2(1.0, 0.0);\n    vec2 v11 = vec2(0.0, 1.0);\n    \n    vec2 v12 = vec2(0.0, 0.0);\n    vec2 v13 = vec2(1.0, 0.0);\n    vec2 v14 = vec2(0.0, 1.0);\n    \n    vec2 v15 = vec2(0.0, 0.0);\n    vec2 v16 = vec2(1.0, 0.0);\n    vec2 v17 = vec2(0.0, 1.0);\n    \n    vec2 v18 = vec2(0.0, 0.0);\n    vec2 v19 = vec2(1.0, 0.0);\n    vec2 v20 = vec2(0.0, 1.0);\n    \n    vec2 v21 = vec2(0.0, 0.0);\n    vec2 v22 = vec2(1.0, 0.0);\n   ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = vec3(0.0);\n    vec2 p = uv;\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0", "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This is the original method.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n", "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the", "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p20 = p2 - p0;\n\n    // midpoints\n    vec2 p012 = p01 + p12;\n    vec2 p120 = p12 + p20;\n    vec2 p201 = p20 + p01;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // distances to midpoints\n    float d012 = length(p012);\n    float d120 = length(p120);\n    float d201 = length(p201);\n\n    // distances to extremes\n    float d012_ = d012 / d01;\n    float d120_ = d120 / d12;\n    float d201_ = d201 / d20;\n\n    // distances to midpoints\n    float d012_1 = d012_ * d012_;\n    float d120_1 = d120_ * d120_;\n    float d201_1 = d201_ * d201_;\n\n    // distances to extremes\n    float d012_2 = d012_1 * d012_;\n    float d120_2 = d120_1 * d120_;\n    float d201_2 = d201_1 * d201_;\n\n    // distances to midpoints\n    float d012_3 = d012_2 * d012_;\n    float d120_3 = d120_2 * d120_;\n    float d201_3 = d201_2 * d201_;\n\n    // distances to midpoints\n    float d012_4 = d012_3 * d012", "\n    vec3 min = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 max = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 center = ( min + max ) * 0.5;\n\n    // radius\n    vec3 radius = max( abs( p0 - center ), abs( p1 - center ) );\n    radius = max( radius, abs( p2 - center ) );\n    radius = max( radius, abs( p3 - center ) );\n\n    return BezierAABB( center, radius );\n}\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\nBezierAABB BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7, in vec3 p8, in vec3 p9, in vec3 p10, in vec3 p11, in vec3 p12, in vec3 p13, in vec3 p14, in vec3 p15, in vec3 p16, in vec3 p17, in vec3 p18, in vec3 p19, in vec3 p20, in vec3 p21, in vec3 p22, in vec3 p23, in vec3 p24, in vec3 p25, in vec3 p26, in vec3 p27, in vec3 p28, in vec3 p29, in vec3 p30, in vec3 p31, in vec3 p32, in vec3 p33, in vec3 p34, in vec3 p35, in vec3 p36, in vec3 p37, in vec3 p38, in vec3 p39, in vec3 p40, in vec3 p41, in vec", "\n    const vec2 iResolution = vec2( 1280.0, 720.0 );\n    const float iTime = TIME;\n    const float iTimeDelta = TIME_DELTA;\n    const float iFrame = FRAME;\n    const float iFrameDelta = FRAME_DELTA;\n    const float iFrameCount = FRAME_COUNT;\n    const float iFrameCountDelta = FRAME_COUNT_DELTA;\n    const float iFrameCountMax = FRAME_COUNT_MAX;\n    const float iFrameCountMaxDelta = FRAME_COUNT_MAX_DELTA;\n    const float iFrameCountMaxMax = FRAME_COUNT_MAX_MAX;\n    const float iFrameCountMaxMaxDelta = FRAME_COUNT_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxMax = FR", "\n    return k * k * ( 3.0 - 2.0 * k ); // EaseInOut\n}\n\nfloat", "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (", "\n    coord -= vec2(0.5, 0.5);\n\n    // Scale the coordinate to the screen size.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5, 0.5);\n\n    return coord;\n}\n\nvec", "\n    vec2 f = vec2( 0.0 );\n    f.x = ( 1.0 - abs( p.x ) ) * 0.5;\n    f.y = ( 1.0 - abs( p.y ) ) * 0.5;\n    return f.x * f.y;\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );\n    vec2 q = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tinc = 0.001;\n    float tinc2 = 0.0001;\n    float tinc3 = 0.00001;\n    float tinc4 = 0.000001;\n    float tinc5 = 0.0000001;\n    float tinc6 = 0.00000001;\n    float tinc7 = 0.000000001;\n    float tinc8 = 0.0000000001;\n    float tinc9 = 0.00000000001;\n    float tinc10 = 0.000000000001;\n    float tinc11 = 0.0000000000001;\n    float tinc12 = 0.00000000000001;\n    float tinc13 = 0.000000000000001;\n    float tinc14 = 0.0000000000000001;\n    float tinc15 = 0.00000000000000001;\n    float tinc16 = 0.000000000000000001;\n    float tinc1", "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 0.01f;\n    rgb2hcv = rgb2hcv * (1.0f / 12.92f) + vec3(0.055f);\n    rgb2hcv = pow(rgb2hcv, vec3(1.0f / 2.4f));\n    return rgb2hcv;\n}\n\nvec", "\n    //return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely.\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat", "\n    vec3 n = texture( iChannel0, p.yzx, 0.001 ).xyz;\n    n.xy *= 2.0;\n    return normalize( n - vec3( 0.5, 0.5, 0.5 ) );\n}\n\nvoid main()\n{\n    vec3 p = vec3( iResolution.xy * ( gl_FragCoord.xy / iResolution.xy ), 0.0 );\n    vec3 col = vec3( 0.0 );\n\n    vec3 ro = vec3( 0.0, 0.0, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, -1.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    float dist = length( ta - ro );\n    ta = normalize( ta - ro ) * dist;\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( ww, up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = normal( pos );\n        float h = texture( iChannel0, pos.yzx, 0.0 ).x;\n        float dif = max( 0.0, dot( nor, normalize( vec3( 0.0, 1.0, 0.0 ) ) ) );\n        float amb = max( 0.0, dot( nor, uv_light ) ) * 0.5 + 0.5;\n        float spe = pow( max( 0.", "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat", "\n    // width = 0.5 -> angle = PI\n    // width = 0.25 -> angle = PI/4\n    // width = 0.125 -> angle = PI/16\n    // width = 0.0625 -> angle = PI/32\n    // width = 0.03125 -> angle = PI/64\n    // width = 0.015625 -> angle = PI/128\n    // width = 0.0078125 -> angle = PI/256\n    // width = 0.00390625 -> angle = PI/512\n    // width = 0.001953125 -> angle = PI/1024\n    // width = 0.0009765625 -> angle = PI/2048\n    // width = 0.00048828125 -> angle = PI/4096\n    // width = 0.000244140625 -> angle = PI/8192\n    // width = 0.0001220703125 -> angle = PI/16384\n    // width = 0.00006103515625 -> angle = PI/32768\n    // width = 0.000030517578125 -> angle = PI/65536\n    // width = 0.0000152587890625 -> angle = PI/131072\n    // width = 0.00000762939453125 -> angle = PI/262144\n    // width = 0.000003814697265625 -> angle = PI/524288\n    // width = 0.000001907348632812", "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the color of the pixel\n\tvec4 color = texture(iChannel0, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color2 = texture(iChannel1, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color3 = texture(iChannel2, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color4 = texture(iChannel3, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color5 = texture(iChannel4, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color6 = texture(iChannel5, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color7 = texture(iChannel6, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color8 = texture(iChannel7, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color9 = texture(iChannel8, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color10 = texture(iChannel9, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color11 = texture(iChannel10, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color12 = texture(iChannel11, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color13 = texture(iChannel12, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color14 = texture(iChannel13, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color15 = texture(iChannel14, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color16 = texture(iChannel15, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color17 = texture(iChannel16, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color18 =", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nfloat", " to the position\n\tvec3 q = log(p);\n\t\n\t// Compute the spherical coordinates\n\tfloat r = length(q);\n\tfloat theta = atan(q.y, q.x);\n\tfloat phi = atan(q.z, length(q.xy));\n\t\n\t// Compute the cartesian coordinates\n\tvec3 s = vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n\t\n\t// Compute the tangent and bitangent vectors\n\tvec3 t = normalize(cross(vec3(0.0, 1.0, 0.0), s));\n\tvec3 b = cross(s, t);\n\t\n\t// Compute the scale factor\n\tmul = exp(r);\n\t\n\t// Compute the texture coordinates\n\tsp = (q.xy + 1.0) * 0.5;\n\ttp = (q.z + 1.0) * 0.5;\n\trp = (q.xy + 1.0) * 0.5;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * 2.0 - 1.0;\n\ttp = tp * 2.0 - 1.0;\n\trp = rp * 2.0 - 1.0;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * mul;\n\ttp = tp * mul;\n\trp = rp * mul;\n}\n\n// Compute the normal at a given position\nvec", "\n    float y = sin(p.x) * cos(p.z);\n    float r = cos(p.x) * cos(p.z);\n    return vec2(length(p.xy - vec2(0.0, y)) - r, 0.0);\n}\n\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tvec2 p1 = p + vec2(aaSize, 0.0);\n\tvec2 p2 = p + vec2(aaSize, aaSize);\n\tvec2 p3 = p + vec2(0.0, aaSize);\n\tvec2 p4 = p + vec2(0.0, 0.0);\n\tvec2 p5 = p + vec2(-aaSize, 0.0);\n\tvec2 p6 = p + vec2(-aaSize, aaSize);\n\tvec2 p7 = p + vec2(-aaSize, -aaSize);\n\tvec2 p8 = p + vec2(0.0, -aaSize);\n\tvec2 p9 = p + vec2(aaSize, -aaSize);\n\tvec2 p10 = p + vec2(aaSize, -aaSize);\n\tvec2 p11 = p + vec2(aaSize, 0.0);\n\tvec2 p12 = p + vec2(aaSize, aaSize);\n\tvec2 p13 = p + vec2(0.0, aaSize);\n\tvec2 p14 = p + vec2(0.0, 0.0);\n\tvec2 p15 = p + vec2(-aaSize, 0.0);\n\tvec2 p16 = p + vec2(-aaSize, aaSize);\n\tvec2 p17 = p + vec2(-aaSize, -aaSize);\n\tvec2 p18 = p + vec2(0.0, -aaSize);\n\tvec2 p19 = p + vec2(aaSize, -aaSize);\n\tvec2 p20 = p + vec2(aaSize, -aaSize);\n\tvec2 p21 = p + vec2(aaSize, 0.0);\n\tvec2 p22 = p + vec2(aaSize, aaSize);\n\tvec2 p23 = p + vec2(0.0, aaSize);\n\tvec2 p24 = p + vec2(0.0, 0.0);\n", "\n    mat4 rot = mat4(1.0);\n    rot = rotate(rot, 0.0f, vec3(0.0f, 1.0f, 0.0f));\n    rot = rotate(rot, 0.0f, vec3(1.0f, 0.0f, 0.0f));\n\n    // get a translation matrix for our box's position\n    mat4 trans = mat4(1.0);\n    trans = translate(trans, pos);\n\n    // get the box's vertices\n    vec3 vertices[] = {\n        vec3(0.0f, 0.0f, 0.0f),\n        vec3(1.0f, 0.0f, 0.0f),\n        vec3(1.0f, 1.0f, 0.0f),\n        vec3(0.0f, 1.0f, 0.0f)\n    };\n\n    // get the box's normals\n    vec3 normals[] = {\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f)\n    };\n\n    // get the box's texture coordinates\n    vec2 texCoords[] = {\n        vec2(0.0f, 0.0f),\n        vec2(1.0f, 0.0f),\n        vec2(1.0f, 1.0f),\n        vec2(0.0f, 1.0f)\n    };\n\n    // get the box's indices\n    int indices[] = {\n        0, 1, 2,\n        2, 3, 0\n    };\n\n    // get the box's vertices\n    vec3 boxVertices[] = {\n        vec3(0.", "\n    float y = sin(pos.x) * 0.5 + 0.5;\n\n    // rotate the sphere around the x-axis\n    float x = pos.y * 0.5 + 0.5;\n\n    // rotate the sphere around the z-axis\n    float z = pos.z * 0.5 + 0.5;\n\n    return vec2(x, y);\n}\n\nvoid main() {\n\n    // get the position of the vertex\n    vec3 pos = position;\n\n    // get the position of the vertex in the sphere\n    vec2 spherePos = ourSphere(pos);\n\n    // get the position of the vertex in the cube\n    vec3 cubePos = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos2 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos3 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos4 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos5 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos6 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos7 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos8 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos9 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos10 = pos * 2.0 - 1.0;\n\n    // get", "\n    vec3 p = pos;\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 0.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 0.0);\n\n    // test our shapes\n    if (p.x < -1.0) {\n        p.x = -1.0;\n    }\n    if (p.x > 1.0) {\n        p.x = 1.0;\n    }\n    if (p.y < -1.0) {\n        p.y = -1.0;\n    }\n    if (p.y > 1.0) {\n        p.y = 1.0;\n    }\n    if (p.z < -1.0) {\n        p.z = -1.0;\n    }\n    if (p.z > 1.0) {\n        p.z = 1.0;\n    }\n\n    // test our shapes\n    if (q.x < -1.0) {\n        q.x = -1.0;\n    }\n    if (q.x > 1.0) {\n        q.x = 1.0;\n    }\n    if (q.y < -1.0) {\n        q.y = -1.", "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march along the ray until we hit something\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = rayPos + rayDir * t;\n        float d = scene(p);\n        if (d < 0.001) {\n            break;\n        }\n        t += d;\n    }\n    \n    // calculate the color at the point of intersection\n    vec3 color = vec3(0.0);\n    if (t < 100.0) {\n        vec3 p = rayPos + rayDir * t;\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 bmin = rad - ro;\n\tvec3 bmax = rad + ro;\n\tvec3 tmin = (bmin - rd) / rd;\n\tvec3 tmax = (bmax - rd) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat t = max(t0, t3);\n\tif (t < 0.0) return vec2(-1.0);\n\treturn vec2(t, t0);\n}\n\n// ray-sphere intersection\nvec", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// sample the texture\n\tvec4 texColor = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor2 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor3 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor4 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor5 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor6 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor7 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor8 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor9 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor10 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor11 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor12 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor13 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor14 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor15 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor16 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor17 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor18 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor19 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec", "\n    return dot(plane.normal, pos - plane.position) / dot(plane.normal, plane.normal);\n}\n\nfloat", "Density = 0.0001;\n    // float n = perlin(ix, fx);\n    // return n;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return ", "\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors", "\n    float s = p.y - h;\n    float d = length(p.xz) - r;\n    return max(s, d);\n}\n\nfloat", "\n     p.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5", "\n  // eps.yxy <=> vec3(0.  , 0.001, 0.   )\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n ", "\n                                      //      v\n                                      //     /\n                                      //    /\n                                      //   /\n                                      //  /\n                                      // /\n                                      ///\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                     ", "\n    vec3 b = rd * ra - ro;\n    vec3 c = b * b - vec3( 1.0 );\n    vec3 d = sqrt( c );\n    vec3 t = -b - d;\n    vec3 t1 = -b + d;\n    float t0 = max( t.x, max( t.y, t.z ) );\n    float t1 = min( t.x, min( t.y, t.z ) );\n    float t2 = max( t1.x, t1.y );\n    float t3 = min( t1.x, t1.y );\n    float t4 = max( t2, t3 );\n    float t5 = min( t2, t3 );\n    float t6 = max( t4, t5 );\n    float t7 = min( t4, t5 );\n    float t8 = max( t6, t7 );\n    float t9 = min( t6, t7 );\n    float t10 = max( t8, t9 );\n    float t11 = min( t8, t9 );\n    float t12 = max( t10, t11 );\n    float t13 = min( t10, t11 );\n    float t14 = max( t12, t13 );\n    float t15 = min( t12, t13 );\n    float t16 = max( t14, t15 );\n    float t17 = min( t14, t15 );\n    float t18 = max( t16, t17 );\n    float t19 = min( t16, t17 );\n    float t20 = max( t18, t19 );\n    float t21 = min( t18, t19 );\n    float t22 = max( t20, t21 );\n    float t23 = min( t20, t21 );\n    float t24 = max( t22, t23 );\n    float t25 = min( t22, t23 );\n    float t26 =", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].center.x = 0.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = -1.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].center.x = 0.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n", "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n", "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // clamp intersection times\n    tmin = max( tmin, 0.0 );\n    tmax = min( tmax, tmax.x );\n\n    // ray-sphere intersection\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - 1.0;\n    float h = b*b - c;\n    if( h < 0.0 ) return 0.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t < tmin.x ) t = -b + h;\n    if( t > tmax.x ) return 0.0;\n\n    // shadow\n    float shadow = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float ht = t + float( i ) * 0.1;\n        vec3 p = ro + ht * rd;\n        float d = texture( shadowMap, p.xy ).x;\n        shadow += max( 0.0, ht - d );\n    }\n    shadow /= 10.0;\n\n    // soft shadow\n    float attenuation = 1.0 - exp( -shadow * 0.001 );\n    return attenuation;\n}\n\nvoid main()\n{\n    // camera\n    vec3 ro = vec3( 0.0, 0.0, 10.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0f - c;\n\n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec", "\n    vec3 offset = vec3(0.0, 0.0, 0.0);\n    offset.x = planet_position.x - start.x;\n    offset.y = planet_position.y - start.y;\n    offset.z = planet_position.z - start.z;\n\n    // the rayleigh scattering\n    vec3 rayleigh_scat = vec3(0.0, 0.0, 0.0);\n\n    // the mie scattering\n    vec3 mie_scat = vec3(0.0, 0.0, 0.0);\n\n    // the absorption\n    vec3 absorption = vec3(0.0, 0.0, 0.0);\n\n    // the ambient\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n\n    // the color of the ray\n    vec3 ray_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the atmosphere\n    vec3 atmo_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the planet\n    vec3 planet_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sun\n    vec3 sun_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the background\n    vec3 background_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sky\n    vec3 sky_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    vec3 moon_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    ve", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // calculate the cosine of the angle between the surface normal and the light direction\n    float cos_theta = dot(surface_normal, light_dir_bend);\n\n    // calculate the cosine of the angle between the surface normal and the view direction\n    float cos_alpha = dot(surface_normal, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_beta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_gamma = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_delta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_epsilon = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_zeta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_prime = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_double = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_triple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_quadruple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 ray_dir = normalize(dir);\n    \n    // the ray origin\n    vec3 ray_origin = pos;\n    \n    // the ray origin\n    vec3 light_origin = vec3(0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 light_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // get the ray direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(p.xy, 2.0));\n    \n    // get the raymarching parameters\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tinc = 0.001;\n    float tdec = 0.001;\n    float tmin_inc = 0.001;\n    float tmin_dec = 0.001;\n    float tmax_inc = 0.001;\n    float tmax_dec = 0.001;\n    float tmin_inc_dec = 0.001;\n    float tmax_inc_dec = 0.001;\n    float tmin_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc_", "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float discriminant = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the square root of the discriminant\n    float sqrtDiscriminant = sqrt(discriminant);\n\n    // Compute the smaller and larger root\n    float root1 = -b - sqrtDiscriminant;\n    float root2 = -b + sqrtDiscriminant;\n\n    // If root1 is negative, use root2 instead\n    if (root1 < 0.0) {\n        root1 = root2;\n    }\n\n    // Return the smaller root\n    return root1;\n}\n\n// Compute the intersection point of a ray and a sphere\nvec", "ialize variables\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotAmbient = vec3(0.0);\n    vec3 lightSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotAttenuation = vec3(0.0);\n    vec3 lightSpotSpotAmbient = vec3(0.0);\n    vec3 lightSpotSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotSpotAttenuation =", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    ray_queue.push_back(ray_origin);\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to", "\n    vec2 cell = floor(p);\n    vec2 f = fract(p);\n    \n    // Local cell coordinates.\n    vec2 c = cell;\n    \n    // Local cell ID.\n    float cellID = cell.x + cell.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c2 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID2 = c2.x + c2.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c3 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID3 = c3.x + c3.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c4 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID4 = c4.x + c4.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c5 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID5 = c5.x + c5.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c6 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID6 = c6.x + c6.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c7 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID7 = c7.x + c7.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c8 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID8 = c8.x + c8.y * 57.0;\n    ", "\n    vec3 sphere_center = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance from sphere center\n    float dist = length(p - sphere_center) - sphere_radius;\n\n    return dist;\n}\n\n// calculate the color of the sphere\nvec", "\n    vec3 Pi = floor( P );\n    vec3 Pf = P - Pi;\n\n    // establish our 4 corners of the grid cell\n    vec3 P0 = Pi;\n    vec3 P1 = Pi + vec3( 1.0 );\n    vec3 P2 = Pi + vec3( 1.0, 1.0 );\n    vec3 P3 = Pi + vec3( 1.0, 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P000 = P0;\n    vec3 P100 = P1;\n    vec3 P010 = P2;\n    vec3 P110 = P3;\n\n    // establish our 4 values of the corners\n    vec3 P001 = P0 + vec3( 1.0 );\n    vec3 P101 = P1 + vec3( 1.0 );\n    vec3 P011 = P2 + vec3( 1.0 );\n    vec3 P111 = P3 + vec3( 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P002 = P0 + vec3( 1.0, 1.0 );\n    vec3 P102 = P1 + vec3( 1.0, 1.0 );\n    vec3 P012 = P2 + vec3( 1.0, 1.0 );\n    vec3 P112 = P3 + vec3( 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P003 = P0 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P103 = P1 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P013 = P2 + vec3( 1.0, 1.0, 1.0 );\n   ", "\n    float t = x * 10.0;\n    float s = sin(t);\n    float r = cos(t);\n    float b = sin(t*2.0);\n    float g = cos(t*2.0);\n    float a = sin(t*3.0);\n    float n = cos(t*3.0);\n    \n    // return\n    return (s+r+b+g+a+n)/6.0;\n}\n\nfloat", "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float t = (x + y + z) / 3.0;\n    float ground = (sin(t) + 1.0) / 2.0;\n    p.y -= ground;\n\n    // water\n    t = (x + y + z) / 3.0;\n    float water = (sin(t) + 1.0) / 2.0;\n    p.y += water;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // snow\n    t = (x + y + z) / 3.0;\n    float snow = (sin(t) + 1.0) / 2.0;\n    p.y += snow;\n\n    // rock\n    t = (x + y + z) / 3.0;\n    float rock = (sin(t) + 1.0) / 2.0;\n    p.y += rock;\n\n    // sand\n    t = (x + y + z) / 3.0;\n    float sand = (sin(t) + 1.0) / 2.0;\n    p.y += sand;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin", " space to screen space\n    vec2 p2 = (p.xy / p.z) * 0.5 + 0.5;\n    // map to [-1, 1]\n    p2 = p2 * 2.0 - 1.0;\n    // map to [-0.5, 0.5]\n    p2 = p2 * 0.5 + 0.5;\n    return p2;\n}\n\nvoid main()\n{\n    vec2 p = map(gl_FragCoord.xy);\n    vec2 q = map(gl_FragCoord.xy + vec2(0.0, 1.0));\n    vec2 r = map(gl_FragCoord.xy + vec2(1.0, 0.0));\n    vec2 s = map(gl_FragCoord.xy + vec2(0.0, -1.0));\n    vec2 t = map(gl_FragCoord.xy + vec2(-1.0, 0.0));\n\n    vec2 d = fwidth(p);\n    vec2 e = fwidth(q);\n    vec2 f = fwidth(r);\n    vec2 g = fwidth(s);\n    vec2 h = fwidth(t);\n\n    vec2 i = smoothstep(d, d + e, p);\n    vec2 j = smoothstep(f, f + g, q);\n    vec2 k = smoothstep(h, h + i, r);\n    vec2 l = smoothstep(j, j + k, s);\n    vec2 m = smoothstep(l, l + m, t);\n\n    float n = max(max(m.x, m.y), max(l.x, l.y));\n    gl_FragColor = vec4(n);\n}\n", " from a to b\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    float y = a.y + t * (b.y - a.y);\n    if (y < pix) return 0.0;\n    if (y > d - pix) return 0.0;\n    return 1.0;\n}\n\nfloat", "\n\t//st.x *= iResolution.x/iResolution.y;\n\tvec2 st = fragCoord/iResolution.xy;\n\tst.x *= iResolution.x/iResolution.y;\n\tvec2 p = st;\n\tfloat t = iGlobalTime;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat", "\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat left and pointed left hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    \n    // Flat right and pointed right hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < ", "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\nfloat", "\n    vec3 p2 = rotate( p, vec3( 0.0, 0.0, 0.0 ) );\n\n    // map the solution space to the unit sphere\n    vec3 p3 = p2 / length( p2 );\n\n    // map the solution space to the unit cube\n    vec3 p4 = p3 * 0.5 + 0.5;\n\n    // map the solution space to the unit cube\n    vec3 p5 = p4 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p6 = p5 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p7 = p6 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p8 = p7 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p9 = p8 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p10 = p9 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p11 = p10 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p12 = p11 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p13 = p12 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p14 = p13 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p15 = p14 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p16 = p15 * 2.0 - 1.", "\n    return (p - 0.5) * 2.0;\n}\n\nfloat", "\n    return vec2(atan2(z.y,z.x),length(z));\n}\n\nvec", "\n    return (vec2){z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x};\n}\n\nvec", "\n\t vec3 s = p - vec3(floor(p));\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, and 1.0 - x */\n\t vec3 i1 = step(vec3(0.0), x);\n\t vec3 i2 = step(vec3(1.0), x);\n\t vec3 x3 = 1.0 - x;\n\t \n\t /* calculate T and four vertices of T */\n\t vec4 T = vec4(s, i1.x) + vec4(s, i2.x) + vec4(s, 1.0, i1.y) + vec4(s, 1.0, i2.y);\n\t vec3 v0 = vec3(T) / 4.0;\n\t vec3 v1 = v0 + vec3(i1.xyy, 0.0);\n\t vec3 v2 = v0 + vec3(i2.xyy, 0.0);\n\t vec3 v3 = v0 + vec3(1.0, i1.xyy);\n\t \n\t /* calculate w, the barycentric coordinates of p relative to T */\n\t vec3 w = x3 * (x3 * (x3 * v0) + i1.z * (x2 * v1 + x * v2)) + i2.z * (x3 * v3 + x * v0);\n\t \n\t /* return the dot product of w and n */\n\t return dot(w, vec3(0.57735026918962576450914878050195745564887086954052300113832952210791614262294101264442748062243388305015030054794086342643848110487108", " wave\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z *", " in the final image\n    p.xz *= 0.5;\n    p.y *= 0.5;\n\n    // rotate the space\n    p = rotate( p, 0.01 );\n\n    // scale the space\n    p *= 0.5;\n\n    // add some noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0", "\n    //float k = floor(rp.y*.75)*.25;\n    //float k = floor(rp.z*.75)*.25;\n    //return k;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;", "\n\tfloat t = (end - d) / (end - start);\n\treturn clamp(t, 0.0, 1.0);\n}\n\n// \u30b9\u30af\u30ea\u30fc\u30f3\u5ea7\u6a19\u304b\u3089\u30ef\u30fc\u30eb\u30c9\u5ea7\u6a19\u306b\u5909\u63db\u3059\u308b\u3002\nvec", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon center is the point that is closest to the current point.\n    if (p.x < p.y)\n    {\n        hex = vec4(p.x, p.y, 0.0, 0.0);\n    }\n    else\n    {\n        hex = vec4(p.y, p.x, 0.0, 1.0);\n    }\n    \n    // The hexagon center is unique, so we can use it to index into the hexagon array.\n    return hex;\n}\n\n// This function returns the hexagon center that is closest to the current point.\nvec", "\n    float x = fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n    float y = fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Four by four cell random value.\n    x += fract(sin(dot(p,vec2(113.1,325.4)))*43758.5453);\n    y += fract(sin(dot(p,vec2(271.5,181.3)))*23325.4236);\n    \n    // Eight by eight cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixteen by sixteen cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Thirty-two by thirty-two cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixty-four by sixty-four cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin(", "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    else if (scale < 0.0) {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse", " from the center\n    //of the spiral\n    float theta = acos(a/b);\n    \n    //Solve for the polar coordinate (r, theta)\n    //of the point pc\n    vec2 pcPolar = vec2(length(pc), theta);\n    \n    //Check if the point pc is on the spiral\n    if(pcPolar.x <= a && pcPolar.y <= b){\n        return 1.0;\n    }\n    else{\n        return 0.0;\n    }\n}\n\n//Check if the point pc is on the spiral\n//(a,b) = (a+b*theta, theta)\n//where theta is the angle between the x-axis and the\n//line from the center of the spiral to the point pc\nfloat", "\n    return smoothstep(0.0, 1.0, pct);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, u_time);\n    color = mix(vec3(0.0), vec3(1.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    //\n    // I'm not going to go into the details of the math here, but I'll say that\n    // the following is the formula for the distance from the center of the \n    // initial circle to the center of the circle that runs adjacent to the \n    // current domain edges.\n    //\n    // d = (r * sin(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the radius of the initial circle.\n    //\n    // r = (1 - cos(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the angle theta.\n    //\n    // theta = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.", "\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't", "\n    vec2 mouse = vec2(mousePos.x, mousePos.y);\n    \n    // Mouse inversion.\n    vec2 mouseInversion = (p - mouse) * -1.0;\n    \n    // Return mouse inversion.\n    return mouseInversion;\n}\n\n// Mouse inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraRight = vec3(1.0, 0.0, 0.0);\n\tfloat cameraFov = 45.0;\n\tfloat cameraNear = 0.1;\n\tfloat cameraFar = 100.0;\n\n\t// Light Orientation\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 lightUp = vec3(0.0, 1.0, 0.0);\n\tvec3 lightRight = vec3(1.0, 0.0, 0.0);\n\tfloat lightFov = 45.0;\n\tfloat lightNear = 0.1;\n\tfloat lightFar = 100.0;\n\n\t// Lighting\n\tvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\tvec3 lightAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 lightDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 lightSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat lightShininess = 10.0;\n\n\t// Material\n\tvec3 materialAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 materialDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 materialSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat materialShininess = 10.0;\n\n\t// Texture\n\tvec3 textureColor = vec3(0", "\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position", " axis\n    float x = (hash - 0.5) * 2.0;\n    float y = (hash - 0.5) * 2.0;\n    float z = (hash - 0.5) * 2.0;\n    \n    // Random gradient of a cube, +/- 1 each axis\n    float gx = (hash - 0.5) * 2.0;\n    float gy = (hash - 0.5) * 2.0;\n    float gz = (hash - 0.5) * 2.0;\n    \n    // Return the gradient\n    return vec3(gx, gy, gz);\n}\n\n// Compute the dot product of a normal and a gradient\nfloat", "\n    vec3 Y = normalize(cross(X, vec3(0.0, 1.0, 0.0)));\n    vec3 Z = cross(Y, X);\n    \n    // Rotation matrix.\n    mat3 rot = mat3(\n        Y,\n        Z,\n        X\n    );\n    \n    // Skew transform.\n    mat3 skew = mat3(\n        0.0, 1.0, 0.0,\n        -1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot = skew * rot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot2 = skewRot * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot3 = skewRot2 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot4 = skewRot3 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot5 = skewRot4 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot6 = skewRot5 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot7 = skewRot6 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot8 = skewRot7 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot9 = skewRot8 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot10 = skewRot9 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot11 = skewRot10 * skewRot;\n    \n   ", "\n  float d = p.y;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the Y plane\n  float d3 = p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = p.x * p.x + p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d8 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d9 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d11 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d12 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d", "\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ufffd", "\n\tmat2 rot = mat2(cos(time), -sin(time), sin(time), cos(time));\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv = rot * uv;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat d = length(uv);\n\t\n\tfloat a = atan(uv.y, uv.x);\n\t\n\tfloat r = (d - 0.5) * 2.0;\n\t\n\tfloat t = time * 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tfloat x = r * c;\n\tfloat y = r * s;\n\t\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\t\n\tfloat x3 = x2 * x;\n\tfloat y3 = y2 * y;\n\t\n\tfloat x4 = x3 * x;\n\tfloat y4 = y3 * y;\n\t\n\tfloat x5 = x4 * x;\n\tfloat y5 = y4 * y;\n\t\n\tfloat x6 = x5 * x;\n\tfloat y6 = y5 * y;\n\t\n\tfloat x7 = x6 * x;\n\tfloat y7 = y6 * y;\n\t\n\tfloat x8 = x7 * x;\n\tfloat y8 = y7 * y;\n\t\n\tfloat x9 = x8 * x;\n\tfloat y9 = y8 * y;\n\t\n\tfloat x10 = x9 * x;\n\tfloat y10 = y9 * y;\n\t\n\tfloat x11 = x10 * x;\n\tfloat y11 = y10 * y;\n\t\n\tfloat x12 = x11 * x;\n\tfloat y12 = y11 * y;\n\t\n\tfloat x13 = x12 * x;\n\tfloat y13 = y12 * y;\n\t\n\tfloat x", "-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos", "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, normalize( vec3( 0.0f, 1.0f, 0.0f ) ) ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotH10 = NdotH8 * NdotH2;\n    float NdotH12 = NdotH10 * NdotH2;\n    float NdotH14 = NdotH12 * NdotH2;\n    float NdotH16 = NdotH14 * NdotH2;\n    \n    float NdotH18 = NdotH16 * NdotH2;\n    float NdotH20 = NdotH18 * NdotH2;\n    float NdotH22 = NdotH20 * NdotH2;\n    float NdotH24 = NdotH22 * NdotH2;\n    \n    float NdotH26 = NdotH24 * NdotH2;\n    float NdotH28 = NdotH26 * NdotH2;\n    float NdotH30 = NdotH28 * NdotH2;\n    float NdotH32 = NdotH30 * NdotH2;\n    \n    float NdotH34 = NdotH3", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / ", "\n    float t = x * PI;\n    float s = sin(t);\n    float c = cos(t);\n    float r = fract(x);\n\n    // first octave\n    r = r * (1.0 + s * 0.5);\n\n    // second octave\n    r = r * (1.0 + s * 0.25);\n\n    // third octave\n    r = r * (1.0 + s * 0.125);\n\n    // fourth octave\n    r = r * (1.0 + s * 0.0625);\n\n    // fifth octave\n    r = r * (1.0 + s * 0.03125);\n\n    // sixth octave\n    r = r * (1.0 + s * 0.015625);\n\n    // seventh octave\n    r = r * (1.0 + s * 0.0078125);\n\n    // eighth octave\n    r = r * (1.0 + s * 0.00390625);\n\n    // ninth octave\n    r = r * (1.0 + s * 0.001953125);\n\n    // tenth octave\n    r = r * (1.0 + s * 0.0009765625);\n\n    // finaly\n    return r;\n}\n\nfloat", " to find the area of the triangle\n    float area = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_uv = abs(uv.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p1 = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p2 = abs(p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p3 = abs(p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y)) / 2.0;\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_uv){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p1){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p2){\n        \n        //Return true\n        return true;\n    }\n    ", "\n    float n = log(start_radius) / log(1.5);\n    \n    //Find the closest hexagon to the given uv\n    //https://math.stackexchange.com/a/1001000\n    float closest_hex_radius = pow(1.5, n);\n    float closest_hex_angle = atan2(uv.y, uv.x) + (2.0 * M_PI) / 6.0;\n    vec2 closest_hex_uv = vec2(closest_hex_radius * cos(closest_hex_angle), closest_hex_radius * sin(closest_hex_angle));\n    \n    return closest_hex_uv;\n}\n\n//https://www.shadertoy.com/view/4djSRW\nvec", ".\n    //\n    //The rotation of the hexagon is determined by the\n    //rotation of the equilateral.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hex", ".\n    //\n    //The circumradius of the isosceles is the distance\n    //between the two points of the isosceles.\n    //\n    //The rotation of the isosceles is the angle between\n    //the two points of the isosceles.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that", "\n    return exp(-d*d*U.x*U.x - d*d*U.y*U.y);\n}\n\nfloat", "'s implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 72) ^ (n >> 27);\n    n = n + (n << 3);\n    n = n ^ (n >> 11);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 150) ^ (n >> 10);\n    n = n + (n << 3);\n    n = n ^ (n >> 21);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 28) ^ (n >> 8);\n    n = n + (n << 3);\n    n = n ^ (n >> 14);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 18);\n    return n;\n}\n\nuint hash5(uint n)\n{", "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " to avoid division by zero\n  vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n  return normalize(\n      vec3(\n          f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n          f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n          f(pos + epsilon.yyx) - f(pos - epsilon.yyx)));\n}\n\nvoid main() {\n  vec3 pos = (gl_FragCoord.xyz / resolution.xyz) * 2.0 - 1.0;\n  vec3 dir = normalize(pos);\n  vec3 color = vec3(0.0);\n  float t = 0.0;\n  for (int i = 0; i < 100; i++) {\n    t += f(pos) * 0.5;\n    pos += dir * f(pos) * 0.5;\n  }\n  color = vec3(t);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n  vec3 p = ro;\n  float t = 0.0;\n  float tmin = 0.001;\n  float tmax = 1000.0;\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = p;\n    vec3 nor = vec3(0.0);\n    float dis = 0.0;\n    for (int j = 0; j < 10; j++) {\n      vec3 dp = p - pos;\n      float d = length(dp);\n      if (d < tmin) {\n        break;\n      }\n      if (d > tmax) {\n        break;\n      }\n      dis += d;\n      p = pos + dp;\n      nor = normalize(p);\n    }\n    if (dis < tmax) {\n      t = dis;\n    }\n    if (t < tmin) {\n      break;\n    }\n    p = pos + nor * 0.01;\n  }\n  // get color at hit point\n  vec3 col = vec3(0.0);\n  if (t < tmax) {\n    vec3 pos = p;\n    vec3 nor = normalize(pos);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 view = normalize(rd);\n    vec3 halfv = normalize(light + view);\n    float ndotl = max(0.0, dot(nor, light));\n    float ndoth = max(0.0, dot(nor, halfv));\n    float spec = pow(ndoth, 16.0);\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, ", " to avoid division by zero\n    vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n    return normalize(vec3(\n        f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n        f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n        f(pos + epsilon.yyx) - f(pos - epsilon.yyx)\n    ));\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, 0.0);\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 diffuse = max(0.0, dot(normal, lightDir)) * vec3(1.0, 1.0, 1.0);\n    vec3 specular = pow(max(0.0, dot(reflect(-lightDir, normal), viewDir)), 16.0) * vec3(1.0, 1.0, 1.0);\n    vec3 color = (diffuse + specular) * vec3(1.0, 1.0, 1.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 p = castRay(ro, rd);\n    // get normal at hit point\n    vec3 n = getNormal(p);\n    // get color at hit point\n    vec3 c = getColor(p);\n    // get light at hit point\n    vec3 l = getLight(p);\n    // get ambient color\n    vec3 a = getAmbient(p);\n    // get diffuse color\n    vec3 d = getDiffuse(p, l);\n    // get specular color\n    vec3 s = getSpecular(p, l, n);\n    // get final color\n    vec3 col = a + d + s;\n    // return final color\n    return col;\n}\n\nvoid main() {\n    // get ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n    // get ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    // get color at ray origin\n    vec3 col = render(ro, rd);\n    // set color\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 color = texture(texture_diffuse1, p).rgb;\n    //surface normal for bump mapping\n    vec3 normal = texture(texture_normal1, p).rgb;\n    normal = normalize(normal * 2.0 - 1.0);\n    return normal;\n}\n\nvoid main()\n{\n    vec3 viewDir = normalize(viewPos - fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 normal = estimateNormal(fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n    vec3 specular = spec * lightColor;\n    vec3 ambient = lightColor * 0.1;\n    vec3 diffuse = lightColor * max(dot(normal, lightDir), 0.0);\n    vec3 result = (ambient + diffuse + specular) * color;\n    FragColor = vec4(result, 1.0);\n}", "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat", "el grid\n\tvec2 texel = coord * 16.0;\n\tvec2 texel_floor = floor( texel );\n\tvec2 texel_frac = texel - texel_floor;\n\n\tvec2 texel_offset = vec2( 0.0, 0.0 );\n\ttexel_offset.x = texel_frac.x * 16.0;\n\ttexel_offset.y = texel_frac.y * 16.0;\n\n\tvec2 texel_offset_floor = floor( texel_offset );\n\tvec2 texel_offset_frac = texel_offset - texel_offset_floor;\n\n\tvec2 texel_offset_floor_texel = texel_offset_floor / 16.0;\n\tvec2 texel_offset_frac_texel = texel_offset_frac / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel = texel_offset_floor_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel = texel_offset_frac_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel = texel_offset_floor_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel = texel_offset_frac_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel = texel_offset_floor_texel_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel_texel = texel_offset_frac_texel_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel_texel = texel_", "\n    p.x = abs(p.x);\n\n    // rotate\n    p.x = cos(p.y) * p.x + sin(p.y) * p.y;\n    p.y = -sin(p.y) * p.x + cos(p.y) * p.y;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\nvec", "\n    p = fmod(p, 1.0);\n    if (p < 0.0)\n        p += 1.0;\n    p *= 10000.0;\n    return vec3(p, p + 1.0, p + 2.0);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the fragment\n    vec2 position = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the fragment in the screen\n    vec2 positionScreen = (position * 2.0) - 1.0;\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    //", "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 =", "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t, -sn*s),\n        vec3(s*ct, s*t, cn)\n    );\n}\n\n//src/main.cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cct", "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n    // raypos = vec4(raydir.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.", "\n    vec3 rayDir = normalize(cameraPos - uv);\n\n    // Calculate the distance to the plane\n    float dist = dot(uv - cameraPos, planeNormal);\n\n    // Calculate the distance to the plane\n    float distToPlane = dist / length(planeNormal);\n\n    // Calculate the distance to the plane\n    float distToCamera = length(uv - cameraPos);\n\n    // Calculate the distance to the plane\n    float distToCameraSquared = distToCamera * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraCubed = distToCameraSquared * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFourth = distToCameraCubed * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFifth = distToCameraFourth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSixth = distToCameraFifth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSeventh = distToCameraSixth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEighth = distToCameraSeventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraNinth = distToCameraEighth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTenth = distToCameraNinth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEleventh = distToCameraTenth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTwelfth = distToCameraEleventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraThirteenth = distToCameraTwelfth * distToCamera;\n\n    // Calcul", "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set", "\n    float seed = float(gl_FragCoord.x + gl_FragCoord.y);\n    float rng = rand(seed);\n\n    // Initialize variables\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    vec2 c = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 10.0;\n    float tmin = 0.0;\n    float tstep = 0.001;\n    float tstep2 = 0.0001;\n    float tstep3 = 0.00001;\n    float tstep4 = 0.000001;\n    float tstep5 = 0.0000001;\n    float tstep6 = 0.00000001;\n    float tstep7 = 0.000000001;\n    float tstep8 = 0.0000000001;\n    float tstep9 = 0.00000000001;\n    float tstep10 = 0.000000000001;\n    float tstep11 = 0.0000000000001;\n    float tstep12 = 0.00000000000001;\n    float tstep13 = 0.000000000000001;\n    float tstep14 = 0.0000000000000001;\n    float tstep15 = 0.00000000000000001;\n    float tstep16 = 0.000000000000000001;\n    float tstep17 = 0.0000000000000000001;\n    float tstep18 = 0.", "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the distance from the center of the fragment\n    float dist = distance(coord, vec2(0.5));\n\n    // Get the strength of the fragment\n    float strength = maxStrength * fade;\n\n    // Return the strength of the fragment\n    return strength;\n}\n\nvoid main()\n{\n    // Get the coordinates of the fragment\n    vec2 coord = gl_FragCoord.xy;\n\n    // Get the strength of the fragment\n    float strength = rayValue(coord, 1.0, 0.001, 1.0);\n\n    // Set the color of the fragment\n    gl_FragColor = vec4(strength, strength, strength, 1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n\tvec2 e12 = e1 - p;\n\tvec2 e23 = e2 - p;\n\tvec2 e34 = e3 - p;\n\tvec2 e41 = e4 - p;\n\tfloat d12 = dot(e12, e12);\n\tfloat d23 = dot(e23, e23);\n\tfloat d34 = dot(e34, e34);\n\tfloat d41 = dot(e41, e41);\n\tfloat d123 = dot(e12, e23);\n\tfloat d124 = dot(e12, e34);\n\tfloat d234 = dot(e23, e34);\n\tfloat d134 = dot(e13, e34);\n\tfloat d1234 = dot(e12, e34);\n\tfloat d12341 = dot(e12, e41);\n\tfloat d123412 = dot(e12, e23);\n\tfloat d1234123 = dot(e12, e34);\n\tfloat d12341234 = dot(e12, e41);\n\tfloat d2341234 = dot(e23, e34);\n\tfloat d23412341 = dot(e23, e41);\n\tfloat d34123412 = dot(e34, e41);\n\tfloat d341234123 = dot(e34, e23);\n\tfloat d3412341234 = dot(e34, e41);\n\tfloat d412341234 = dot(e41, e23);\n\tfloat d4123412341 = dot(e41, e34);\n\tfloat d41234123412 = dot(e41, e23);\n\tfloat d412341234123 = dot(e41,", "\n    return pow(color, vec3(2.2));\n}\n\nvec", "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    float d = length(p-mix(a,b,h));\n\n    // return min(d,w1);\n    return min(d,w1);\n}\n\nfloat", "\n    uv = uv * 2.0 - 1.0;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x", "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX =", "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n", "\n   p = fmod(p, 1.0);\n   if (p < 0.0) p += 1.0;\n   return vec3(p * 127.1, p * 311.7, p * 163.1);\n}\n\nfloat", "\n  //  return 1.0 - (pow(tanh(x), 2.0));\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0 - (pow(tanh(x), 2.0)) / 64.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) /", ".\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n", "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n// Compute the signed distance field of the sphere\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"], "input_none": ["\n\treturn cosf( a );\n}\n\nfloat", "\n    float d = length(p - _position);\n    return d;\n}\n\nvec", "\n    vec3 q = p - voxelPos;\n    return length(q) - voxelRadius;\n}\n\nfloat", "\n    vec3 P0 = vec3(0.0, 0.0, 0.0);\n    vec3 P1 = vec3(1.0, 0.0, 0.0);\n    vec3 P2 = vec3(0.0, 1.0, 0.0);\n    vec3 P3 = vec3(0.0, 0.0, 1.0);\n    vec3 P4 = vec3(0.0, 0.0, -1.0);\n    vec3 P5 = vec3(0.0, 1.0, 1.0);\n    vec3 P6 = vec3(1.0, 0.0, 1.0);\n    vec3 P7 = vec3(1.0, 1.0, 0.0);\n    vec3 P8 = vec3(1.0, 1.0, 1.0);\n    vec3 P9 = vec3(1.0, 0.0, 1.0);\n    vec3 P10 = vec3(1.0, 1.0, 1.0);\n    vec3 P11 = vec3(1.0, 1.0, 1.0);\n    vec3 P12 = vec3(1.0, 1.0, 1.0);\n    vec3 P13 = vec3(1.0, 1.0, 1.0);\n    vec3 P14 = vec3(1.0, 1.0, 1.0);\n    vec3 P15 = vec3(1.0, 1.0, 1.0);\n    vec3 P16 = vec3(1.0, 1.0, 1.0);\n    vec3 P17 = vec3(1.0, 1.0, 1.0);\n    vec3 P18 = vec3(1.0, 1.0, 1.0);\n    vec3 P19 =", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = (r - 0.5) * 0.5;\n    float s = sin(a + t) * 0.5 + 0.5;\n    float c = cos(a + t) * 0.5 + 0.5;\n    float dd = d * d;\n    float sd = s * s;\n    float cd = c * c;\n    float dd2 = dd * dd;\n    float sd2 = sd * sd;\n    float cd2 = cd * cd;\n    float dd3 = dd2 * dd;\n    float sd3 = sd2 * sd;\n    float cd3 = cd2 * cd;\n    float dd4 = dd3 * dd;\n    float sd4 = sd3 * sd;\n    float cd4 = cd3 * cd;\n    float dd5 = dd4 * dd;\n    float sd5 = sd4 * sd;\n    float cd5 = cd4 * cd;\n    float dd6 = dd5 * dd;\n    float sd6 = sd5 * sd;\n    float cd6 = cd5 * cd;\n    float dd7 = dd6 * dd;\n    float sd7 = sd6 * sd;\n    float cd7 = cd6 * cd;\n    float dd8 = dd7 * dd;\n    float sd8 = sd7 * sd;\n    float cd8 = cd7 * cd;\n    float dd9 = dd8 * dd;\n    float sd9 = sd8 * sd;\n    float cd9 = cd8 * cd;\n    float dd10 = dd9 * dd;\n   ", "\n    return vec4(x, x, x, 1.0);\n}\n\nvec", "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta > 0.0)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    return color;\n}\n\nvec", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    float n = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float persistence = 0.5;\n\n    for (int i = 0; i < NUM_NOISE_LAYERS; i++) {\n        n += amp * noise(p * freq);\n        freq *= 2.0;\n        amp *= persistence;\n    }\n\n    return n;\n}\n\nfloat", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec2 q = p - vec2(0.5);\n    float r = dot(q, q);\n    return r * r * (3.0 - 2.0 * r);\n}\n\nfloat", "\n    vec2 q = p - vec2(floor(p.x), floor(p.y));\n    vec2 r = vec2(fract(p.x), fract(p.y));\n    float d = dot(q, q);\n    if (d < eps) return 0.0;\n    r = r*r*(3.0 - 2.0*r);\n    return -1.0 + 2.0*dot(r, r);\n}\n\nfloat", "\n    vec3 lightPosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightDirection = normalize( lightPosition - eyePosition );\n    vec3 lightColor = vec3( 1.0, 1.0, 1.0 );\n    vec3 ambientColor = vec3( 0.2, 0.2, 0.2 );\n    vec3 diffuseColor = vec3( 0.0, 0.0, 0.0 );\n    vec3 specularColor = vec3( 0.0, 0.0, 0.0 );\n    float shininess = 10.0;\n    float attenuation = 1.0;\n    float distance = length( lightPosition - eyePosition );\n    float attenuationFactor = attenuation / ( distance * distance );\n    diffuseColor = lightColor * max( 0.0, dot( lightDirection, rayDirection ) ) * attenuationFactor;\n    vec3 eyeDirection = normalize( eyePosition - rayHitInfo );\n    vec3 reflectionDirection = reflect( -rayDirection, rayDirection );\n    float specularFactor = max( 0.0, dot( reflectionDirection, eyeDirection ) );\n    specularFactor = pow( specularFactor, shininess );\n    specularColor = lightColor * specularFactor * attenuationFactor;\n    return ( ambientColor + diffuseColor + specularColor ) * colorTheWorld;\n}\n\nvoid main()\n{\n    vec3 eyePosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 rayDirection = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheWorld = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheRay = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheLight = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorThe", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    vec2 res = vec2(0.0);\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        res.x = max(res.x, d);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return res;\n}\n\nvoid main()\n{\n    vec2 res = vec2(0.0);\n    vec2 tex = vec2(0.0);\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 amb = vec3(0.0);\n    vec3 dif = vec3(0.0);\n    vec3 spe = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 sun = vec3(0.0);\n    vec3 moon = vec3(0.0);\n    vec3 moon_col = vec3(0.0);\n    vec3 moon_amb = vec3(0.0);\n    vec3 moon_dif = vec3(0.0);\n    vec3 moon_spe = vec3(0.0);\n    vec3 moon_fog = vec3(0.0);\n    vec3 moon_sky = vec3(0.0);\n    vec3 moon_sun = vec3(0.0);\n    vec3 moon_moon = vec3(0.0);\n    vec3 moon_moon_col = vec3(0.0);\n    vec3 moon_moon_amb = vec3(0.0);\n    vec3 moon_moon_dif = vec3(", "\n    vec4 p2 = vec4(p, 1.0);\n    p2.y *= -1.0;\n    p2.x *= -1.0;\n    p2.z *= -1.0;\n    p2.w = 1.0;\n    return p2;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 refDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAttenuation2 = vec3(0.0);\n    vec3 lightAttenuation3 = vec3(0.0);\n    vec3 lightAttenuation4 = vec3(0.0);\n    vec3 lightAttenuation5 = vec3(0.0);\n    vec3 lightAttenuation6 = vec3(0.0);\n    vec3 lightAttenuation7 = vec3(0.0);\n    vec3 lightAttenuation8 = vec3(0.0);\n    vec3 lightAttenuation9 = vec3(0.0);\n    vec3 lightAttenuation10 = vec3(0.0);\n    vec3 lightAttenuation11 = vec3(0.0);\n    vec3 lightAttenuation12 = vec3(0.0);\n    vec3 lightAttenuation13 = vec3(0.0);\n    vec3 lightAttenuation14 = vec3(0.0);\n    vec3 lightAttenuation15 = vec3(0.0);\n    vec3 lightAttenuation16 = vec3(0.0);\n    vec3 lightAttenuation17 = vec3(0.0);\n    vec3 lightAttenuation18 = vec3(0.0);\n    vec3 lightAttenuation19 = vec3(0.0);\n    vec3 lightAttenuation20 = vec3(", "\n    vec3 n = normalize(oN);\n    vec3 n1 = normalize(oN + vec3(1.0, 0.0, 0.0));\n    vec3 n2 = normalize(oN + vec3(-1.0, 0.0, 0.0));\n    vec3 n3 = normalize(oN + vec3(0.0, 1.0, 0.0));\n    vec3 n4 = normalize(oN + vec3(0.0, -1.0, 0.0));\n    vec3 n5 = normalize(oN + vec3(0.0, 0.0, 1.0));\n    vec3 n6 = normalize(oN + vec3(0.0, 0.0, -1.0));\n\n    float d1 = dot(n, p - oN);\n    float d2 = dot(n1, p - oN);\n    float d3 = dot(n2, p - oN);\n    float d4 = dot(n3, p - oN);\n    float d5 = dot(n4, p - oN);\n    float d6 = dot(n5, p - oN);\n    float d7 = dot(n6, p - oN);\n\n    return vec3(d1, d2, d3) - vec3(d4, d5, d6) - vec3(d7, 0.0, 0.0);\n}\n\nvec", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 envColor = vec3(0.0);\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float blurAmount = 0.0;\n    float blurScale = 1.0;\n    float blurFactor = 1.0;\n    float blurFactor2 = 1.0;\n    float blurFactor3 = 1.0;\n    float blurFactor4 = 1.0;\n    float blurFactor5 = 1.0;\n    float blurFactor6 = 1.0;\n    float blurFactor7 = 1.0;\n    float blurFactor8 = 1.0;\n    float blurFactor9 = 1.0;\n    float blurFactor10 = 1.0;\n    float blurFactor11 = 1.0;\n    float blurFactor12 = 1.0;\n    float blurFactor13 = 1.0;\n    float blurFactor14 = 1.0;\n    float blurFactor15 = 1.0;\n    float blurFactor16 = 1.0;\n    float blurFactor17 = 1.0;\n    float blurFactor18 = 1.0;\n    float blurFactor19 = 1.0;\n    float blurFactor20 = 1.0;\n    float blurFactor21 = 1.0;\n    float blurFactor22 = 1.0;\n    float blurFactor23 = 1.0;\n    float blurFactor24 = 1.0;\n    float blurFactor25 = 1.0;\n    float blurFactor26 = 1.0;\n    float blurFactor27 = 1.0;\n    float blurFactor28 = 1.0;\n    float blurFactor29 = 1.0;\n    float blurFactor30 = 1.0;\n    float blurFactor31 = 1.0;\n    float blurFactor32 = 1.0;\n    float blurFactor33 = 1.0;\n    float blurFactor34 = 1.0;\n    float blurFactor35 = ", "\n    float d = distance(coords, A);\n    float d2 = distance(coords, B);\n    float h = height;\n    float a = (d2 - d) / (d2 - d + h);\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat", "\n    return start * (1.0f - percent) + end * percent;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 v = b - a;\n    vec2 w = p - a;\n    return dot(w, v) / dot(v, v);\n}\n\nfloat", "\n    vec3 color = vec3(0.0f);\n    vec3 lightDir = vec3(0.0f);\n    vec3 lightColor = vec3(0.0f);\n    vec3 lightPos = vec3(0.0f);\n    vec3 lightPos2 = vec3(0.0f);\n    vec3 lightPos3 = vec3(0.0f);\n    vec3 lightPos4 = vec3(0.0f);\n    vec3 lightPos5 = vec3(0.0f);\n    vec3 lightPos6 = vec3(0.0f);\n    vec3 lightPos7 = vec3(0.0f);\n    vec3 lightPos8 = vec3(0.0f);\n    vec3 lightPos9 = vec3(0.0f);\n    vec3 lightPos10 = vec3(0.0f);\n    vec3 lightPos11 = vec3(0.0f);\n    vec3 lightPos12 = vec3(0.0f);\n    vec3 lightPos13 = vec3(0.0f);\n    vec3 lightPos14 = vec3(0.0f);\n    vec3 lightPos15 = vec3(0.0f);\n    vec3 lightPos16 = vec3(0.0f);\n    vec3 lightPos17 = vec3(0.0f);\n    vec3 lightPos18 = vec3(0.0f);\n    vec3 lightPos19 = vec3(0.0f);\n    vec3 lightPos20 = vec3(0.0f);\n    vec3 lightPos21 = vec3(0.0f);\n    vec3 lightPos22 = vec3(0.0f);\n    vec3 lightPos23 = vec3(0.0f);\n    vec3 lightPos24 = vec3(0.0f);\n    vec3 lightPos25 = vec3(0.", "\n    vec3 object_center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.0;\n    return length(p - object_center) - radius;\n}\n\nfloat", "\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 = (-b - discriminant) / (2.0 * a);\n        t1 = (-b + discriminant) / (2.0 * a);\n        if (t0 > t1)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if (t0 < 0.0)\n        {\n            near = t1;\n            far = t1;\n        }\n        else if (t1 < 0.0)\n        {\n            near = t0;\n            far = t0;\n        }\n        else\n        {\n            near = t0;\n            far = t1;\n        }\n        return true;\n    }\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 =", "\n    float d = s.w;\n    vec3 q = p - s.xyz;\n    return dot(q, q) - d*d;\n}\n\nfloat", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec2 pos = p;\n    float d = 0.0;\n    for(int i = 0; i < 10; i++){\n        d += drawCircle(pos, 0.05);\n        pos.x += 0.05;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    float d = drawShape(p);\n    gl_FragColor = vec4(vec3(d), 1.0);\n}", "\n    vec3 n = normalize(sn);\n    vec3 t = normalize(cross(n, sp));\n    vec3 b = cross(t, n);\n    return (sp + b * bumpFactor) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec3 sp = vec3(0.0, 0.0, 0.0);\n    vec3 sn = vec3(0.0, 0.0, 0.0);\n    vec3 sn2 = vec3(0.0, 0.0, 0.0);\n    vec3 sn3 = vec3(0.0, 0.0, 0.0);\n    vec3 sn4 = vec3(0.0, 0.0, 0.0);\n    vec3 sn5 = vec3(0.0, 0.0, 0.0);\n    vec3 sn6 = vec3(0.0, 0.0, 0.0);\n    vec3 sn7 = vec3(0.0, 0.0, 0.0);\n    vec3 sn8 = vec3(0.0, 0.0, 0.0);\n    vec3 sn9 = vec3(0.0, 0.0, 0.0);\n    vec3 sn10 = vec3(0.0, 0.0, 0.0);\n    vec3 sn11 = vec3(0.0, 0.0, 0.0);\n    vec3 sn12 = vec3(0.0, 0.0, 0.0);\n    vec3 sn13 = vec3(0.0, 0.0, 0.0);\n    vec3 sn14 = vec3(0.0, 0.0, 0.0);\n    vec3 sn15 = vec3(0.0, 0.0, 0.0);\n    vec3 sn16 = vec3(0.0, 0", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 light = normalize(vec3(1, 1, 1));\n    vec3 v = normalize(p - eye);\n    vec3 r = reflect(-light, n);\n    float s = pow(max(dot(r, v), 0.0), 100.0);\n    return vec3(s);\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy, 0.0);\n    vec3 n = normal(p);\n    vec3 c = shade(p, n);\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44", "\n    return length(p)-rad;\n}\n\nfloat", "\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float e = 0.0;\n    float f = 1.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;", "\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    float light_intensity = 0.5;\n    float light_attenuation = 1.0;\n    float light_radius = 0.0;\n    float light_softness = 0.0;\n    float light_softness_scale = 1.0;\n    float light_softness_power = 1.0;\n    float light_softness_offset = 0.0;\n    float light_softness_falloff = 0.0;\n    float light_softness_falloff_scale = 1.0;\n    float light_softness_falloff_power = 1.0;\n    float light_softness_falloff_offset = 0.0;\n    float light_softness_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_falloff = 0.0;\n    float", "\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    col = skyColor(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float t = texture(tex, p.xy).x;\n    if (t < 0.001) {\n        col = vec3(0.0);\n    } else {\n        col = vec3(1.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = vec3(0.0);\n    float ti = 0.0;\n    for (int i = 0; i < 100; i++) {\n        col += rayColor(ro, rd, ti);\n        ti += max(0.001, 0.0001 * length(rd));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5", "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(diamond.zw)) - diamond.w;\n}\n\nfloat", "\n    return vec3(1.0) - smoothstep(0.0, 1.0, abs(sin(uv.x * 10.0) * 0.5 + sin(uv.y * 10.0) * 0.5));\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        color += pattern(uv + vec2(i, 0.0));\n    }\n    color /= 10.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 p = pos;\n    float d = 0.0;\n    for ( int i = 0; i < 10; i++ ) {\n        d += texture( iChannel0, p ).r;\n        p *= 2.0;\n        p.x += sin( p.y * 10.0 ) * 0.01;\n        p.y += cos( p.x * 10.0 ) * 0.01;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3( 0.0 );\n    float d = dist_field( p );\n    col = vec3( 1.0 - d );\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(-l, n);\n    vec3 vl = normalize(l + eye);\n    vec3 vr = reflect(vl, n);\n    float diff = max(dot(l, n), 0.0);\n    float spec = pow(max(dot(vr, vl), 0.0), 16.0);\n    return vec3(0.2, 0.2, 0.2) * diff + vec3(0.8, 0.8, 0.8) * spec;\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 n = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 color = shading(v, n, eye);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return sin(p.x + offset) * sin(p.y + offset);\n}\n\nfloat", "\n    float xmts = x.x;\n    float ymts = x.y;\n    float zmts = x.z;\n    float wmts = x.w;\n    float xmts2 = xmts * xmts;\n    float ymts2 = ymts * ymts;\n    float zmts2 = zmts * zmts;\n    float wmts2 = wmts * wmts;\n    float xmts3 = xmts2 * xmts;\n    float ymts3 = ymts2 * ymts;\n    float zmts3 = zmts2 * zmts;\n    float wmts3 = wmts2 * wmts;\n    float xmts4 = xmts3 * xmts;\n    float ymts4 = ymts3 * ymts;\n    float zmts4 = zmts3 * zmts;\n    float wmts4 = wmts3 * wmts;\n    float xmts5 = xmts4 * xmts;\n    float ymts5 = ymts4 * ymts;\n    float zmts5 = zmts4 * zmts;\n    float wmts5 = wmts4 * wmts;\n    float xmts6 = xmts5 * xmts;\n    float ymts6 = ymts5 * ymts;\n    float zmts6 = zmts5 * zmts;\n    float wmts6 = wmts5 * wmts;\n    float xmts7 = xmts6 * xmts;\n    float ymts7 = ymts6 * ymts;\n    float zmts7 = zmts6 * zmts;\n    float wmts7 = wmts6 * wmts;\n    float xmts8 = xmts7 * xmts;\n    float ymts8 = ymts7 * ymts;\n    float zmts8 = zmts7 * zmts;\n    float wmts8 = wmts7 *", "\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - h + r;\n}\n\nfloat", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec", "\n    vec3 a = vec3(12.9898,78.233,45.145);\n    vec3 b = vec3(13.302,15.0287,83.985);\n    vec3 c = vec3(8.124,6.1595,105.291);\n    vec3 d = vec3(1.0,1.0,1.0);\n    vec3 u = fract(sin(dot(p,a))*c);\n    vec3 f = fract(sin(dot(p,b))*c);\n    vec3 g = fract(sin(dot(p,c))*c);\n    return mix(mix(mix(dot(u,f),g),mix(f,g,f.x),f.y),mix(mix(u,g,u.x),mix(g,f,g.x),u.y),f.z);\n}\n\nfloat", "\n    vec4 color = texture2D(u_texture, coord);\n    vec4 color2 = texture2D(u_texture2, coord);\n    vec4 color3 = texture2D(u_texture3, coord);\n    vec4 color4 = texture2D(u_texture4, coord);\n    vec4 color5 = texture2D(u_texture5, coord);\n    vec4 color6 = texture2D(u_texture6, coord);\n    vec4 color7 = texture2D(u_texture7, coord);\n    vec4 color8 = texture2D(u_texture8, coord);\n    vec4 color9 = texture2D(u_texture9, coord);\n    vec4 color10 = texture2D(u_texture10, coord);\n    vec4 color11 = texture2D(u_texture11, coord);\n    vec4 color12 = texture2D(u_texture12, coord);\n    vec4 color13 = texture2D(u_texture13, coord);\n    vec4 color14 = texture2D(u_texture14, coord);\n    vec4 color15 = texture2D(u_texture15, coord);\n    vec4 color16 = texture2D(u_texture16, coord);\n    vec4 color17 = texture2D(u_texture17, coord);\n    vec4 color18 = texture2D(u_texture18, coord);\n    vec4 color19 = texture2D(u_texture19, coord);\n    vec4 color20 = texture2D(u_texture20, coord);\n    vec4 color21 = texture2D(u_texture21, coord);\n    vec4 color22 = texture2D(u_texture22, coord);\n    vec4 color23 = texture2D(u_texture23, coord);\n    vec4 color24 = texture2D(u_texture24, coord);\n    vec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\nfloat", "\n    vec3 q = p;\n    float f = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += a * texture(iChannel0, q.yz).r;\n        q = q * 2.0 - vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float f = bumpFunction(p);\n    col = vec3(f);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = viewp_inv * ray_nds;\n    vec4 ray_eye = view_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\nvec", "\n    float d = distance(pA, pB);\n    float l = length(pA - pB);\n    float r = rounded;\n    float dd = d - r;\n    float dd2 = d - r - thick.x;\n    float dd3 = d - r - thick.y;\n    float dd4 = d - r - thick.x - thick.y;\n    float dd5 = d - r - thick.x - thick.y - thick.x;\n    float dd6 = d - r - thick.x - thick.y - thick.y;\n    float dd7 = d - r - thick.x - thick.y - thick.x - thick.y;\n    float dd8 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd9 = d - r - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd10 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd11 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd12 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd13 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd14 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd15 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd16 = d - r - thick.x - thick.y - thick.x - thick.y - thick", "\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 0.0) - p);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float diff = max(dot(n, lightDir), 0.0);\n    float spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - diff);\n    color += vec3(0.0, 0.0, 0.0) * spec;\n    return color;\n}\n\nvoid main()\n{\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        p = vec3(0.0, 0.0, 0.0);\n        n = vec3(0.0, 0.0, 0.0);\n        for (int j = 0; j < 100; j++)\n        {\n            p += vec3(0.0, 0.0, 0.0);\n            n += vec3(0.0, 0.0, 0.0);\n        }\n        p /= 100.0;\n        n /= 100.0;\n        color += Shade(p, n);\n    }\n    color /= 100.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for( int j = 0; j < 10; j++ )\n    {\n        if( f.x < f.y )\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n        else\n            f = vec2( f.x, f.y * 2.0 );\n        i += f;\n        if( length( ro + rd * i.x - cen ) > rad.x )\n            break;\n        if( length( ro + rd * i.y - cen ) > rad.y )\n            break;\n    }\n    return i;\n}\n\nvec", "\n\tfloat wave = (sin(x) * a) + b;\n\treturn wave;\n}\n\nfloat", "\n    return (vec2){a.x * b.x, a.y * b.y};\n}\n\nvec", "\n    vec4 res = vec4(0.0);\n    vec3 ab = pb - pa;\n    float d = dot(ab, ab);\n    float e = dot(ab, rd);\n    float f = dot(ab, ro) - ra;\n    float g = d*f - e*e;\n    if (g > 0.0)\n    {\n        float h = sqrt(g);\n        float t = (e + h) / d;\n        if (t > 0.0)\n        {\n            vec3 pt = ro + t*rd;\n            float y = length(pt - pa);\n            if (y < h)\n            {\n                res.x = t;\n                res.y = y;\n                res.z = h;\n            }\n        }\n    }\n    return res;\n}\n\nvec", "\n    float d = length(P - U);\n    if (d < r) {\n        O.xyz = C;\n        O.w = 1.0;\n    }\n}\n\nvoid main() {\n    vec2 U = gl_FragCoord.xy / iResolution.xy;\n    vec2 P = -1.0 + 2.0 * U;\n    P.x *= iResolution.x / iResolution.y;\n    vec3 C = vec3(0.0);\n    sphere(C, U, P, 0.5, vec3(1.0, 0.0, 0.0));\n    sphere(C, U, P, 0.25, vec3(0.0, 1.0, 0.0));\n    sphere(C, U, P, 0.125, vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(C, 1.0);\n}\n", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float h = map(a, 0.0, 6.28318530718, 0.0, 1.0);\n    return r * h;\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 q = p + vec2(sin(i + time), cos(i + time)) * 0.01;\n        col += vec3(1.0 - map(q));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.1));\n    col = pow(col, vec3(1.0 / 0.6));\n    col = pow(col, vec3(1.0 / 0.4));\n    col = pow(col, vec3(1.0 / 0.3));\n    col = pow(col, vec3(1.0 / 0.2));\n    col = pow(col, vec3(1.0 / 0.1));\n    col = pow(col, vec3(1.0 / 0.06));\n    col = pow(col, vec3(1.0 / 0.04));\n    col = pow(col, vec3(1.0 / 0.03));\n    col = pow(col, vec3(1.0 / 0.02));\n    col = pow(col, vec3(1.0 / 0.01));\n   ", "\n    vec3 scale = vec3(1.0, 1.0, 1.0);\n    if(layerID == 0.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 1.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 2.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 3.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 4.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 5.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 6.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 7.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 8.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 9.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 10.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 11.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 12.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if", "\n    return vec3(p.x, p.y, 0.0);\n}\n\nvec", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tymin = 0.0;\n    float tymax = 1000.0;\n    float tzmin = 0.0;\n    float tzmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n", "\n    vec3 rayDirection = normalize(currentRayPosition - cameraPosition);\n    vec3 rayOrigin = cameraPosition;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return fract(x * sm);\n}\n\nfloat", "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 19.19), dot(p, p + 19.19), dot(p, p + 19.19)));\n}\n\nfloat", "\n    vec3 a = fract(p);\n    a = a * a * (3.0 - 2.0 * a);\n\n    return mix(mix(a.x, a.y, a.z), mix(a.y, a.z, a.x), a.x);\n}\n\nfloat", "\n\t\treturn length(p);\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.5;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.25;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.03125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.015625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0078125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00390625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.001953125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0009765625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00048828125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000244140625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0001220703125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00006103515625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000030517578125;\n\t}\n\t\n\tfloat func(vec", "\n    vec2 balloonPosition = vec2( 0.0, 0.0 );\n    balloonPosition.x = sdfBalloonPosition.x;\n    balloonPosition.y = sdfBalloonPosition.y;\n    return sdfBalloonPosition.z - length( currentRayPosition - balloonPosition );\n}\n\nvec", "\n    vec4 res = vec4( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 100000.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( tmax - tmin < 0.0001 )\n            break;\n        float tm = ( tmin + tmax ) * 0.5;\n        vec3 pp = p + tm * rd;\n        float d = length( pp - rad );\n        if( d < tmax )\n        {\n            tmax = d;\n            res = vec4( tm, tm, tm, 1.0 );\n        }\n        tmin = max( tmin, tm );\n        t = tm;\n    }\n    return res;\n}\n\nvec", "\n    vec3 a = fract(p);\n    a = a*a*(3.0-2.0*a);\n    return a.x*(a.y+a.z) + a.y*a.z;\n}\n\nfloat", "\n    vec3 oc = p - a;\n    vec3 ab = b - a;\n    vec3 n = cross(oc,ab);\n    float d = dot(n,c);\n    float t = dot(n,oc)/d;\n    return t;\n}\n\nfloat", "\n    vec2 z0 = z;\n    z.x = c.x;\n    z.y = c.y;\n    for(int i = 0; i < 100; i++){\n        z.x = z0.x*z0.x - z0.y*z0.y + c.x;\n        z.y = 2.0*z0.x*z0.y + c.y;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 z = vec2(0.0);\n    float m = mandelbrot(c, z);\n    gl_FragColor = vec4(m, m, m, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\nvec", "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy/iResolution.xy);\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float aa = 1.0;\n    for(int i=0;i<5;i++){\n        vec2 off = vec2(0.0);\n        off.x = i*0.1;\n        col += hsv2rgb(vec3(mod(iTime+off.x,1.0),1.0,1.0));\n    }\n    col /= 5.0;\n    col = pow(col,vec3(0.4545));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.", "\n    float c = cos(dir), s = sin(dir);\n    return ciPat(p, w, c, s);\n}\n\nfloat", "\n    return (b - a) * x + a;\n}\n\nfloat", "\n    float dist = length(xy);\n    float alpha = smoothstep(0.0, 1.0, dist);\n    baseCol = mix(baseCol, curveCol, alpha);\n}\n\nvoid main()\n{\n    vec2 xy = gl_FragCoord.xy / resolution.xy;\n    vec4 baseCol = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 curveCol = vec4(0.0, 0.0, 0.0, 0.0);\n\n    drawFunc(baseCol, xy, curveCol);\n\n    gl_FragColor = baseCol;\n}\n", "\n    return 0.5*sin(j*p.x)+0.5*sin(j*p.y);\n}\n\nfloat", "\n    return f*f;\n}\n\nint", "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec", "\n    return sdBox(p,s);\n}\n\nDAVec3 sdBox(DAVec3 p,vec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    return length(max(r,0.0))+min(max(max(r.x,r.y),r.z),0.0)+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    DAVec3 s = abs(r)-u;\n    return length(max(s,0.0))+min(max(max(max(s.x,s.y),s.z),r.x),r.y)+min(max(max(max(q.x,q.y),q.z),r.x),r.y)+min(max(max(q.x,q.y),q.z),q.z);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u,DAVec3 v){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(", "\n    vec4 sd = vec4(0.0);\n    vec4 sd1 = vec4(0.0);\n    vec4 sd2 = vec4(0.0);\n    vec4 sd3 = vec4(0.0);\n    vec4 sd4 = vec4(0.0);\n    vec4 sd5 = vec4(0.0);\n    vec4 sd6 = vec4(0.0);\n    vec4 sd7 = vec4(0.0);\n    vec4 sd8 = vec4(0.0);\n    vec4 sd9 = vec4(0.0);\n    vec4 sd10 = vec4(0.0);\n    vec4 sd11 = vec4(0.0);\n    vec4 sd12 = vec4(0.0);\n    vec4 sd13 = vec4(0.0);\n    vec4 sd14 = vec4(0.0);\n    vec4 sd15 = vec4(0.0);\n    vec4 sd16 = vec4(0.0);\n    vec4 sd17 = vec4(0.0);\n    vec4 sd18 = vec4(0.0);\n    vec4 sd19 = vec4(0.0);\n    vec4 sd20 = vec4(0.0);\n    vec4 sd21 = vec4(0.0);\n    vec4 sd22 = vec4(0.0);\n    vec4 sd23 = vec4(0.0);\n    vec4 sd24 = vec4(0.0);\n    vec4 sd25 = vec4(0.0);\n    vec4 sd26 = vec4(0.0);\n    vec4 sd27 = vec4(0.0);\n    vec4 sd28 = vec4(0.0);\n", "\n    vec3 color = vec3(0.0);\n    vec3 rayDir = normalize(pos - cameraPos);\n    vec3 rayPos = cameraPos;\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    return vec4(color, depth);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy) - 0.5;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n    vec3 rayPos = cameraPos;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return pow(x, vec3(1.0 / 2.2));\n}\n\nvec", "\n    return dot(p,p);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    return color;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float f = 0.0;\n    f += dot( p, vec2( 12.9898, 78.233 ) );\n    f += dot( p, vec2( 43.123, 53.4321 ) );\n    return fract(sin(f)*43758.5453);\n}\n\nfloat", "\n    gl_Position = vec4(p, 0.0, 1.0);\n}\n\nvoid v(vec3 p){\n    gl_Position = vec4(p, 0.0);\n}\n\nvoid v(vec4 p){\n    gl_Position = p;\n}\n\nvoid v(mat4 m){\n    gl_Position = m * vec4(a_position, 1.0);\n}\n\nvoid v(mat3 m){\n    gl_Position = vec4(m * a_position, 1.0);\n}\n\nvoid v(mat2 m){\n    gl_Position = vec4(m * a_position, 0.0, 1.0);\n}\n\nvoid v(float x, float y){\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n\nvoid v(float x, float y, float z){\n    gl_Position = vec4(x, y, z, 1.0);\n}\n\nvoid v(float x, float y, float z, float w){\n    gl_Position = vec4(x, y, z, w);\n}\n\nvoid v(float x, float y, float z, float w, float u, float v){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n    gl_PointSize = r;\n    gl_Position.w = g;\n    gl_Position.w = b;\n    gl_Position.w = a;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a, float s, float t){\n    gl_Position = vec4(x, y", "\n    return (u.x-m.x)*(u.x-m.x)+(u.y-m.y)*(u.y-m.y);\n}\n\nfloat", "\n    return 0.5*length(u-m)+0.5*length(u-m-vec2(1,0));\n}\n\nfloat", "\n    return dot(u, m.xy) + m.z;\n}\n\nfloat", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return cross(a, b);\n}\n\nvec", "\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 v2 = C;\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpTriangle(e1, e2, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfTriangle(e1, e2, Xi);\n}\n\nvoid sampleSphericalHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleSphericalHemisphere(Xi);\n    w = wo;\n    wPdf = pdfSphericalHemisphere(Xi);\n}\n\nvoid sampleCosineHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleCosineHemisphere(Xi);\n    w = wo;\n    wPdf = pdfCosineHemisphere(Xi);\n}\n\nvoid sampleCone(in vec3 A, in vec3 B, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 e1 = v1 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpCone(e1, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfCone(e1, Xi);\n}\n\nvoid", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    float d = length(p);\n    return d;\n}\n\nfloat", "\n    vec4 res = vec4(0.0);\n    res.x = p.x * p.x;\n    res.y = p.y * p.y;\n    res.z = p.z * p.z;\n    res.w = p.x * p.y;\n    return res;\n}\n\nvec", "\n    float t = time*0.01;\n    float t2 = time*0.02;\n    float t3 = time*0.03;\n    float t4 = time*0.04;\n    float t5 = time*0.05;\n    float t6 = time*0.06;\n    float t7 = time*0.07;\n    float t8 = time*0.08;\n    float t9 = time*0.09;\n    float t10 = time*0.1;\n    float t11 = time*0.11;\n    float t12 = time*0.12;\n    float t13 = time*0.13;\n    float t14 = time*0.14;\n    float t15 = time*0.15;\n    float t16 = time*0.16;\n    float t17 = time*0.17;\n    float t18 = time*0.18;\n    float t19 = time*0.19;\n    float t20 = time*0.2;\n    float t21 = time*0.21;\n    float t22 = time*0.22;\n    float t23 = time*0.23;\n    float t24 = time*0.24;\n    float t25 = time*0.25;\n    float t26 = time*0.26;\n    float t27 = time*0.27;\n    float t28 = time*0.28;\n    float t29 = time*0.29;\n    float t30 = time*0.3;\n    float t31 = time*0.31;\n    float t32 = time*0.32;\n    float t33 = time*0.33;\n    float t34 = time*0.34;\n    float t35 = time*0.35;\n    float t36 = time*0.36;\n    float t37 = time*0.37;\n    float t38 =", "\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return t;\n}\n\nfloat", "\n    vec3 rd = lp - ro;\n    float d = length(rd);\n    rd = normalize(rd);\n    float n = k / (d * d);\n    float m = t / (d * d);\n    return n * exp(-m);\n}\n\nfloat", "\n    vec3 p0 = p - vec3(0.0, 0.0, 0.0);\n    vec3 p1 = p - vec3(1.0, 0.0, 0.0);\n    vec3 p2 = p - vec3(0.0, 1.0, 0.0);\n    vec3 p3 = p - vec3(0.0, 0.0, 1.0);\n    vec3 p4 = p - vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p - vec3(1.0, 0.0, 1.0);\n    vec3 p6 = p - vec3(0.0, 1.0, 1.0);\n    vec3 p7 = p - vec3(1.0, 1.0, 1.0);\n\n    float d0 = dot(p0, p0);\n    float d1 = dot(p1, p1);\n    float d2 = dot(p2, p2);\n    float d3 = dot(p3, p3);\n    float d4 = dot(p4, p4);\n    float d5 = dot(p5, p5);\n    float d6 = dot(p6, p6);\n    float d7 = dot(p7, p7);\n\n    float d = min(d0, min(d1, min(d2, min(d3, min(d4, min(d5, min(d6, d7)))))));\n\n    if (d < edge) {\n        edge = d;\n        crv = 0.0;\n    }\n\n    if (d < t) {\n        t = d;\n        crv = 1.0;\n    }\n\n    return t;\n}\n\nfloat", "\n    vec3 p0 = m[0] * p3.x + m[1] * p3.y + m[2] * p3.z + t;\n    vec3 p1 = m[3] * p3.x + m[4] * p3.y + m[5] * p3.z + t;\n    vec3 p2 = m[6] * p3.x + m[7] * p3.y + m[8] * p3.z + t;\n    return vec4(p0, p1, p2);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return sin(p.x + p.y + dir) * 0.5 + 0.5;\n}\n\nfloat", "\n    return q.x * cos(dir) + q.y * sin(dir);\n}\n\nfloat", "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0f - v - w;\n    return vec4(u, v, w, 0.0f);\n}\n\nvec", "\n    vec4 qp = q - p;\n    vec4 qr = q - r;\n    vec4 h = cross(qp, qr);\n    float a = dot(qp, h);\n    float b = dot(qr, h);\n    float c = dot(h, h);\n    float d = a*a + b*b - c*0.25;\n    if (d < 0.0) return 0.0;\n    float e = sqrt(d);\n    return -a*b*0.25/e;\n}\n\nfloat", "\n    float d = length(p);\n    return 1.0 - smoothstep(lW, lW+0.01, d);\n}\n\nfloat", "\n    vec2 dp = ddx * ddy;\n    vec2 dp2 = dp * dp;\n    vec2 dp3 = dp2 * dp;\n    vec2 dp4 = dp3 * dp;\n    vec2 dp5 = dp4 * dp;\n    vec2 dp6 = dp5 * dp;\n    vec2 dp7 = dp6 * dp;\n    vec2 dp8 = dp7 * dp;\n    vec2 dp9 = dp8 * dp;\n    vec2 dp10 = dp9 * dp;\n    vec2 dp11 = dp10 * dp;\n    vec2 dp12 = dp11 * dp;\n    vec2 dp13 = dp12 * dp;\n    vec2 dp14 = dp13 * dp;\n    vec2 dp15 = dp14 * dp;\n    vec2 dp16 = dp15 * dp;\n    vec2 dp17 = dp16 * dp;\n    vec2 dp18 = dp17 * dp;\n    vec2 dp19 = dp18 * dp;\n    vec2 dp20 = dp19 * dp;\n    vec2 dp21 = dp20 * dp;\n    vec2 dp22 = dp21 * dp;\n    vec2 dp23 = dp22 * dp;\n    vec2 dp24 = dp23 * dp;\n    vec2 dp25 = dp24 * dp;\n    vec2 dp26 = dp25 * dp;\n    vec2 dp27 = dp26 * dp;\n    vec2 dp28 = dp27 * dp;\n    vec2 dp29 = dp28 * dp;\n    vec2 dp30 = dp", "\n    vec2 d = n - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        mr = f + t * d;\n        mg = f + ( t - 1.0 ) * d;\n    }\n    else\n    {\n        mr = f;\n        mg = f;\n    }\n}\n\nvoid main()\n{\n    vec2 f = gl_FragCoord.xy;\n    vec2 mr, mg;\n    closest( f, vec2( 0.0, 0.0 ), mr, mg );\n    vec2 d = mr - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        vec2 p = f + t * d;\n        vec2 q = f + ( t - 1.0 ) * d;\n        vec2 r = mix( p, q, 0.5 );\n        vec2 s = mix( mr, mg, 0.5 );\n        float d4 = dot( r - s, r - s );\n        if( d4 > EPSILON )\n        {\n            float d5 = sqrt( d4 );\n            float t2 = ( r.x * s.x + r.y * s.y ) / d5;\n            if( t2 < 0.0 )", "\n\t\treturn lerp(start_pos, end_pos, t);\n\t}\n\t\n\tvec2 lerp_vel(  float t){\n\t\treturn lerp(start_vel, end_vel, t);\n\t}\n\t\n\tvec2 lerp_acc(  float t){\n\t\treturn lerp(start_acc, end_acc, t);\n\t}\n\t\n\tvec2 lerp_jerk(  float t){\n\t\treturn lerp(start_jerk, end_jerk, t);\n\t}\n\t\n\tvec2 lerp_slope(  float t){\n\t\treturn lerp(start_slope, end_slope, t);\n\t}\n\t\n\tvec2 lerp_bias(  float t){\n\t\treturn lerp(start_bias, end_bias, t);\n\t}\n\t\n\tvec2 lerp_damp(  float t){\n\t\treturn lerp(start_damp, end_damp, t);\n\t}\n\t\n\tvec2 lerp_friction(  float t){\n\t\treturn lerp(start_friction, end_friction, t);\n\t}\n\t\n\tvec2 lerp_gravity(  float t){\n\t\treturn lerp(start_gravity, end_gravity, t);\n\t}\n\t\n\tvec2 lerp_friction_bias(  float t){\n\t\treturn lerp(start_friction_bias, end_friction_bias, t);\n\t}\n\t\n\tvec2 lerp_friction_damp(  float t){\n\t\treturn lerp(start_friction_damp, end_friction_damp, t);\n\t}\n\t\n\tvec2 lerp_friction_slope(  float t){\n\t\treturn lerp(start_friction_slope, end_friction_slope, t);\n\t}\n\t\n\tvec2 lerp_friction_bias_slope(  float t){\n\t\treturn lerp(start_friction_bias_slope, end_friction_bias_slope, t);", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    return (p0 + p1 + p2) / 3.0;\n}\n\nvec", "\n    float a = p1.x - p0.x;\n    float b = p1.y - p0.y;\n    float c = p2.x - p0.x;\n    float d = p2.y - p0.y;\n    return atan2(a*d-b*c, a*a+b*b);\n}\n\nfloat", "\n    vec2 h12 = h1 - h2;\n    vec2 h13 = h1 - h3;\n    vec2 h23 = h2 - h3;\n    float d12 = length(h12);\n    float d13 = length(h13);\n    float d23 = length(h23);\n    float d123 = d12 + d13 - d23;\n    float d123_ = d123 * 0.5;\n    float d123_2 = d123_ * d123_;\n    float d123_3 = d123_2 * d123_;\n    float d123_4 = d123_3 * d123_;\n    float d123_5 = d123_4 * d123_;\n    float d123_6 = d123_5 * d123_;\n    float d123_7 = d123_6 * d123_;\n    float d123_8 = d123_7 * d123_;\n    float d123_9 = d123_8 * d123_;\n    float d123_10 = d123_9 * d123_;\n    float d123_11 = d123_10 * d123_;\n    float d123_12 = d123_11 * d123_;\n    float d123_13 = d123_12 * d123_;\n    float d123_14 = d123_13 * d123_;\n    float d123_15 = d123_14 * d123_;\n    float d123_16 = d123_15 * d123_;\n    float d123_17 = d123_16 * d123_;\n    float d123_18 = d123_17 * d123", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\nvoid main() {\n    vec2 p = triangulate(gl_FragCoord.xy);\n    vec2 q = vec2(0.5);\n    vec2 r = vec2(length(p - q), atan(p.y - q.y, p.x - q.x));\n    float d = length(p - q);\n    float a = atan(p.y - q.y, p.x - q.x);\n    float b = atan(p.y, p.x);\n    float c = atan(q.y, q.x);\n    float d1 = abs(a - b);\n    float d2 = abs(a - c);\n    float d3 = abs(b - c);\n    float d4 = abs(a - d);\n    float d5 = abs(b - d);\n    float d6 = abs(c - d);\n    float d7 = abs(a - d1);\n    float d8 = abs(b - d2);\n    float d9 = abs(c - d3);\n    float d10 = abs(a - d4);\n    float d11 = abs(b - d5);\n    float d12 = abs(c - d6);\n    float d13 = abs(a - d7);\n    float d14 = abs(b - d8);\n    float d15 = abs(c - d9);\n    float d16 = abs(a - d10);\n    float d17 = abs(b - d11);\n    float d18 = abs(c - d12);\n    float d19 = abs(a - d13);\n    float d20 = abs(b - d14);\n    float d21 = abs(c - d15);\n    float d22 = abs(a - d16);\n    float d23 = abs(b - d17);\n    float", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    vec2 p = p0;\n    vec2 dp = p1 - p0;\n    vec2 dp2 = p2 - p1;\n    float t = clamp(dot(p, dp2) / dot(dp, dp2), 0.0, 1.0);\n    return vec4(mix(p0, p1, t), 0.0, 1.0);\n}\n\nvec", "\n    vec3 min = vec3( min( p0.x, min( p1.x, p2.x ) ), min( p0.y, min( p1.y, p2.y ) ), min( p0.z, min( p1.z, p2.z ) ) );\n    vec3 max = vec3( max( p0.x, max( p1.x, p2.x ) ), max( p0.y, max( p1.y, p2.y ) ), max( p0.z, max( p1.z, p2.z ) ) );\n    return BezierAABB( min, max );\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return k * k * (3 - 2 * k);\n}\n\nfloat", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return (coord - res / 2.0f) / res;\n}\n\nvec", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    return 0.5 * ( 1.0 - step( r, 0.5 ) );\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.5;\n    float t = time * 0.05;\n    float d = checkersGradBox( p );\n    float d2 = checkersGradBox( p + vec2( 0.0, 0.001 ) );\n    float d3 = checkersGradBox( p + vec2( 0.0, 0.002 ) );\n    float d4 = checkersGradBox( p + vec2( 0.0, 0.003 ) );\n    float d5 = checkersGradBox( p + vec2( 0.0, 0.004 ) );\n    float d6 = checkersGradBox( p + vec2( 0.0, 0.005 ) );\n    float d7 = checkersGradBox( p + vec2( 0.0, 0.006 ) );\n    float d8 = checkersGradBox( p + vec2( 0.0, 0.007 ) );\n    float d9 = checkersGradBox( p + vec2( 0.0, 0.008 ) );\n    float d10 = checkersGradBox( p + vec2( 0.0, 0.009 ) );\n    float d11 = checkersGradBox( p + vec2( 0.0, 0.010 ) );\n    float d12 = checkersGradBox( p + vec2( 0.0, 0.011 ) );\n    float d13 = checkersGradBox( p + vec2( 0.0, 0.012 ) );\n    float d14 = checkersGradBox( p + vec2( 0.0, 0.013 ) );\n    float d1", "\n    return vec3(\n        dot(rgb, vec3(0.2126, 0.7152, 0.0722)),\n        dot(rgb, vec3(0.2126, 0.2990, 0.5343)),\n        dot(rgb, vec3(0.0722, 0.5343, 0.2126))\n    );\n}\n\nvec", "\n    return fract(sin(p)*43758.5453);\n}\n\nfloat", "\n    vec3 e = vec3( 0.00392, 0.00195, 0.00077 );\n    return normalize( e.zyx * dot( e, p ) + e );\n}\n\nvoid main()\n{\n    vec3 p = ( gl_FragCoord.xyz / vec3( iResolution.xyz ) - 0.5 ) * 2.0;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 rd = normalize( p.xyz );\n\n    vec3 col = vec3( 0.0 );\n\n    vec3 lightDir = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 lightColor = vec3( 1.0 );\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    for ( int i = 0; i < 10; i++ )\n    {\n        vec3 h = normalize( lightDir + rd );\n        float nh = max( 0.0, dot( h, normal( p ) ) );\n        float diffuse = max( 0.0, dot( lightDir, normal( p ) ) );\n        float specular = pow( nh, 10.0 );\n        intensity = diffuse + specular;\n        col += lightColor * intensity * attenuation;\n        attenuation *= 0.5;\n        p += rd * 0.01;\n    }\n\n    col = pow( col, vec3( 0.4545 ) );\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float h = r * 2;\n    float d = r * 0.5;\n    float a = PI / 4;\n    float b = PI / 2;\n    float c = PI;\n    float s = sin(a);\n    float c = cos(a);\n    float t = sin(b);\n    float u = cos(b);\n    float v = sin(c);\n    float w = cos(c);\n    float x1 = x + r * c;\n    float y1 = y + r * s;\n    float x2 = x + r * c;\n    float y2 = y - r * s;\n    float x3 = x - r * c;\n    float y3 = y - r * s;\n    float x4 = x - r * c;\n    float y4 = y + r * s;\n    float x5 = x + r * c;\n    float y5 = y + r * s;\n    float x6 = x + r * c;\n    float y6 = y - r * s;\n    float x7 = x - r * c;\n    float y7 = y - r * s;\n    float x8 = x - r * c;\n    float y8 = y + r * s;\n    float x9 = x + r * c;\n    float y9 = y + r * s;\n    float x10 = x + r * c;\n    float y10 = y - r * s;\n    float x11 = x - r * c;\n    float y11 = y - r * s;\n    float x12 = x - r * c;\n    float y12 = y + r * s;\n    float x13 = x + r * c;\n    float y13 = y + r * s;\n    float x14 = x + r * c;\n    float y14 = y - r * s;\n    float x15 = x - r * c;\n    float y15 = y - r * s;\n   ", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in float t)\n{\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = t;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t)\n{\n    sp = p;\n    tp = p + t;\n    rp = p;\n    mul = length(t);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in float tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in float ttt)\n{\n    sp = p;\n    tp = p + t * tt * ttt;\n    rp = p;\n    mul = length(t * tt * ttt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in vec3 t", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(aaSize, 0.0);\n    vec2 p2 = p + vec2(aaSize, aaSize);\n    vec2 p3 = p + vec2(0.0, aaSize);\n    vec2 p4 = p + vec2(aaSize, aaSize);\n    vec2 p5 = p + vec2(aaSize, 0.0);\n    vec2 p6 = p + vec2(0.0, aaSize);\n    vec2 p7 = p + vec2(0.0, 0.0);\n\n    vec2 p8 = p + vec2(aaSize, aaSize);\n    vec2 p9 = p + vec2(aaSize, 0.0);\n    vec2 p10 = p + vec2(0.0, aaSize);\n    vec2 p11 = p + vec2(0.0, 0.0);\n\n    vec2 p12 = p + vec2(aaSize, aaSize);\n    vec2 p13 = p + vec2(aaSize, 0.0);\n    vec2 p14 = p + vec2(0.0, aaSize);\n    vec2 p15 = p + vec2(0.0, 0.0);\n\n    vec2 p16 = p + vec2(aaSize, aaSize);\n    vec2 p17 = p + vec2(aaSize, 0.0);\n    vec2 p18 = p + vec2(0.0, aaSize);\n    vec2 p19 = p + vec2(0.0, 0.0);\n\n    vec2 p20 = p + vec2(aaSize, aaSize);\n    vec2 p21 = p + vec2(aaSize, 0.0);\n    vec2 p22 = p + vec2(0.0, aaSize);\n    ve", "\n    vec2 box = vec2(1.0);\n    box.x = abs(pos.x) - 0.5;\n    box.y = abs(pos.y) - 0.5;\n    return box;\n}\n\nvec", "\n    return vec2(\n        (pos.x + 1.0) * 0.5,\n        (pos.y + 1.0) * 0.5\n    );\n}\n\nvec", "\n    return vec2(pos.x / pos.z, pos.y / pos.z);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayOrigin = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    float tMin = 0.001;\n    float tDelta = 0.001;\n    float tDeltaMax = 0.001;\n    float tDeltaMin = 0.001;\n    float tDeltaMax2 = 0.001;\n    float tDeltaMin2 = 0.001;\n    float tDeltaMax3 = 0.001;\n    float tDeltaMin3 = 0.001;\n    float tDeltaMax4 = 0.001;\n    float tDeltaMin4 = 0.001;\n    float tDeltaMax5 = 0.001;\n    float tDeltaMin5 = 0.001;\n    float tDeltaMax6 = 0.001;\n    float tDeltaMin6 = 0.001;\n    float tDeltaMax7 = 0.001;\n    float tDeltaMin7 = 0.001;\n    float tDeltaMax8 = 0.001;\n    float tDeltaMin8 = 0.001;\n    float tDeltaMax9 = 0.001;\n    float tDeltaMin9 = 0.001;\n    float tDeltaMax10 = 0.001;\n    float tDeltaMin10 = 0.001;\n    float tDeltaMax11 = 0.001;\n    float tDeltaMin11 = 0.001;\n    float tDeltaMax12 = 0.001;\n    float tDeltaMin12 = 0.001;\n    float tDeltaMax13 = 0.001;\n    float tDeltaMin13 = 0.001;\n    float tDeltaMax14 = 0.001;\n    float tDeltaMin14 = 0.001;\n    float tDeltaMax15 = 0.001;\n    float tDeltaMin15", "\n    vec2 iRes = vec2(0.0);\n    vec2 fRes = vec2(0.0);\n    vec2 tRes = vec2(0.0);\n    vec2 gRes = vec2(0.0);\n    vec2 bRes = vec2(0.0);\n    vec2 dRes = vec2(0.0);\n    vec2 sRes = vec2(0.0);\n    vec2 cRes = vec2(0.0);\n    vec2 eRes = vec2(0.0);\n    vec2 pRes = vec2(0.0);\n    vec2 nRes = vec2(0.0);\n    vec2 hRes = vec2(0.0);\n    vec2 jRes = vec2(0.0);\n    vec2 kRes = vec2(0.0);\n    vec2 lRes = vec2(0.0);\n    vec2 mRes = vec2(0.0);\n    vec2 oRes = vec2(0.0);\n    vec2 qRes = vec2(0.0);\n    vec2 rRes = vec2(0.0);\n    vec2 tRes2 = vec2(0.0);\n    vec2 uRes = vec2(0.0);\n    vec2 vRes = vec2(0.0);\n    vec2 wRes = vec2(0.0);\n    vec2 xRes = vec2(0.0);\n    vec2 yRes = vec2(0.0);\n    vec2 zRes = vec2(0.0);\n    vec2 aRes = vec2(0.0);\n    vec2 bRes2 = vec2(0.0);\n    vec2 cRes2 = vec2(0.0);\n    vec2 dRes2 = vec2(0.0);\n    vec2 eRes2 = vec2(0.0);\n    vec2 fRes2 = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return dot(plane.normal, pos - plane.position);\n}\n\nfloat", "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    return mix(mix(mix(dot(ix,ivec3(1,1,1)),ix.yzx,p.x),\n                  mix(ix.xz,ix.yx,p.x),p.y),\n               mix(mix(ix.zy,ix.yz,p.x),\n                   mix(ix.zx,ix.xy,p.x),p.y),p.z);\n}\n\nfloat", "\n    vec3 fxyz2 = fxyz*fxyz;\n    vec3 fxyz3 = fxyz2*fxyz;\n    vec3 fxyz4 = fxyz3*fxyz;\n    vec3 fxyz5 = fxyz4*fxyz;\n    vec3 fxyz6 = fxyz5*fxyz;\n    vec3 fxyz7 = fxyz6*fxyz;\n    vec3 fxyz8 = fxyz7*fxyz;\n    vec3 fxyz9 = fxyz8*fxyz;\n    vec3 fxyz10 = fxyz9*fxyz;\n    vec3 fxyz11 = fxyz10*fxyz;\n    vec3 fxyz12 = fxyz11*fxyz;\n    vec3 fxyz13 = fxyz12*fxyz;\n    vec3 fxyz14 = fxyz13*fxyz;\n    vec3 fxyz15 = fxyz14*fxyz;\n    vec3 fxyz16 = fxyz15*fxyz;\n    vec3 fxyz17 = fxyz16*fxyz;\n    vec3 fxyz18 = fxyz17*fxyz;\n    vec3 fxyz19 = fxyz18*fxyz;\n    vec3 fxyz20 = fxyz19*fxyz;\n    vec3 fxyz21 = fxyz20*fxyz;\n    vec3 fxyz22 = fxyz21*fxyz;\n    vec3 fxyz23 = fxyz22*fxyz;\n    vec3 fxyz24 = fxyz23*fxyz;\n    vec3 fxyz25 = fxyz24*fxyz;\n    vec3 fxyz26 = fxyz25*fxyz;\n    vec3", "\n    vec3 q = vec3( length(p.xz) - r, p.y );\n    return length(max(abs(q)-vec2(h,0.5),0.0)) - 0.5;\n}\n\nfloat", "\n    float d = sdf(p);\n    return d;\n}\n\nfloat", "\n    return normalize(cross(get_edge(p, 0), get_edge(p, 1)));\n}\n\nvec", "\n    return max(0.0,dot(n,l)*d);\n}\n\nfloat", "\n    float t0 = 0.0;\n    float t1 = 1000000.0;\n    float tmin = 0.001;\n    float tmax = 1000000.0;\n    float t = tmin;\n    float tmin2 = 0.001;\n    float tmax2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min = 0.001;\n    float t2max = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n   ", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    // Initialize the scene\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n}\n\nvoid DrawScene()\n{\n    // Draw the scene\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // Draw the scene\n    glBegin(GL_TRIANGLES);\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 0.0f, 1.0f);\n    glVertex3f(0.0f, 0.5f, 0.0f);\n    glEnd();\n}\n\nvoid Reshape(int w, int h)\n{\n    // Reshape the scene\n    glViewport(0, 0, w, h);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0f, (float)w / (float)h, 0.1f, 100.0f);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nvoid Keyboard(unsigned char key, int x, int y)\n{\n    // Handle keyboard input\n    switch (key)\n    {\n    case 27:\n        exit(0);\n        break;\n    }\n}\n\nvoid Mouse(int button, int state, int x, int y)\n{\n    // Handle mouse input\n    switch (button)\n    {\n    case GLUT_LEFT_BUTTON", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid main()\n{\n    vec3 ro = camera.position;\n    vec3 rd = normalize( camera.direction + camera.right * uv.x + camera.up * uv.y );\n\n    vec3 col = vec3( 0.0 );\n    vec3 light = vec3( 0.0 );\n\n    vec3 p = ro + rd * 10.0;\n    vec3 n = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    float t = map( p, 0.0, 100.0 );\n    p = ro + rd * t;\n    float d = map( p, 0.0, 100.0 );\n    float s = calcSoftshadow( p, rd, 0.0, 10.0 );\n    col = vec3( 0.0, 0.0, 0.0 );\n    if( d < 10.0 )\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n    else\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec", "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = ray_start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 ray_end_color = vec3(0.0);\n\tvec3 ray_end_color_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_", "\n    vec3 light_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    float light_dist = length(light_dir);\n    float attenuation = 1.0 / (light_dist * light_dist);\n    float diffuse_strength = max(0.0, dot(surface_normal, light_dir_norm));\n    vec3 diffuse_col = vec3(0.0);\n    if (diffuse_strength > 0.0) {\n        diffuse_col = vec3(1.0, 1.0, 1.0) * diffuse_strength * attenuation;\n    }\n    vec3 view_dir = normalize(sample_pos - camera_pos);\n    vec3 reflect_dir = reflect(-light_dir_norm, surface_normal);\n    float specular_strength = pow(max(0.0, dot(view_dir, reflect_dir)), 32.0);\n    vec3 specular_col = vec3(0.0);\n    if (specular_strength > 0.0) {\n        specular_col = vec3(1.0, 1.0, 1.0) * specular_strength * attenuation;\n    }\n    light_col = diffuse_col + specular_col;\n    return light_col;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 ambient_color = vec3(0.1);\n    vec3 diffuse_color = vec3(0.5);\n    vec3 specular_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_spec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv - 0.5;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.5) * 2.0;\n    float t = mod(iTime, 1.0);\n    float s = sin(t * 3.14159265359);\n    float c = cos(t * 3.14159265359);\n    float aa = a * 0.5 + 0.5;\n    float rr = r * 0.5 + 0.5;\n    float aa2 = aa * 0.5 + 0.5;\n    float rr2 = rr * 0.5 + 0.5;\n    float aa3 = aa * 0.5 + 0.5;\n    float rr3 = rr * 0.5 + 0.5;\n    float aa4 = aa * 0.5 + 0.5;\n    float rr4 = rr * 0.5 + 0.5;\n    float aa5 = aa * 0.5 + 0.5;\n    float rr5 = rr * 0.5 + 0.5;\n    float aa6 = aa * 0.5 + 0.5;\n    float rr6 = rr * 0.5 + 0.5;\n    float aa7 = aa * 0.5 + 0.5;\n    float rr7 = rr * 0.5 + 0.5;\n    float aa8 = aa * 0.5 + 0.5;\n    float rr8 = rr * 0.5 + 0.5;\n    float aa9 = aa * 0.5 + 0.5;\n    float rr9 = rr * 0.5 + 0.5;\n    float aa10 = aa * 0.5 + 0.5;\n    float rr10 = rr * ", "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotDir2 = vec3(0.0);\n    vec3 lightSpotColor2 = vec3(0.0);\n    vec3 lightSpotIntensity2 = vec3(0.0);\n    vec3 lightSpotAttenuation2 = vec3(0.0);\n    vec3 lightSpotDir3 = vec3(0.0);\n    vec3 lightSpotColor3 = vec3(0.0);\n    vec3 lightSpotIntensity3 = vec3(0.0);\n    vec3 lightSpotAttenuation3 = vec3(0.0);\n    vec3 lightSpotDir4 = vec3(0.0);\n    vec3 lightSpotColor4 = vec3(0.0);\n    vec3 lightSpotIntensity4 = vec3(0.0);\n    vec3 lightSpotAttenuation4 = vec3(0.0);\n    vec3 lightSpotDir5 = vec3(0.0);\n    vec3 lightSpotColor5 = vec3(0.0);\n    vec3 lightSpotIntensity5 = vec3(0.0);\n    vec3 lightSpotAttenuation5 = vec3(0.0);\n    vec3 lightSpotDir6 = vec3(0.0);\n    vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float t = 0.0;\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        vec3 intersection = ray_origin + t * ray_direction;\n        float distance = length(intersection - ray_origin);\n        if (distance < EPSILON) {\n            return intersection;\n        }\n        t += distance;\n    }\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 c = vec3(0.0);\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        c += jigsaw_noise(p * t) * a;\n    }\n    return c;\n}\n\nvoid main()\n{\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 p = st;\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        color += jigsaw_noise(p * t) * a;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}", "\n    return sqrt(pow(p.x, 2) + pow(p.y, 2) + pow(p.z, 2));\n}\n\nvec", "\n    vec3 Pi = floor( P );\n    vec3 Pf = fract( P );\n    vec3 Px = Pf.x + vec3( 1.0, 0.0, 1.0 );\n    vec3 Py = Pf.y + vec3( 1.0, 1.0, 0.0 );\n    vec3 Pz = Pf.z + vec3( 0.0, 1.0, 1.0 );\n    vec3 Pw = Pf.z + vec3( 1.0, 0.0, 1.0 );\n    vec3 Pn = Pf.z + vec3( -1.0, 0.0, 1.0 );\n    vec3 Pt = Pf.z + vec3( 1.0, -1.0, 0.0 );\n    vec3 Pb = Pf.z + vec3( -1.0, -1.0, 0.0 );\n    vec3 Pq = Pf.z + vec3( 1.0, 1.0, -1.0 );\n    vec3 Pr = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec3 Pu = Pf.z + vec3( 1.0, -1.0, -1.0 );\n    vec3 Pv = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec4 Pi0 = texture( iChannel0, Pi );\n    vec4 Pi1 = texture( iChannel0, Pi + vec3( 1.0, 0.0, 0.0 ) );\n    vec4 Pi2 = texture( iChannel0, Pi + vec3( 0.0, 1.0, 0.0 ) );\n    vec4 Pi3 = texture( iChannel0, Pi + vec3( 1.0, 1.0, 0.0 ) );\n    vec4 Pi4 = texture( iChannel0, Pi +", "\n    return fract(sin(x)*43758.5453);\n}\n\nfloat", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return mix(d, 0.0, 1.0 - t);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return texture2D(tex, p).r;\n}\n\nvoid main(){\n    vec2 p = (gl_FragCoord.xy / resolution.xy);\n    vec2 p2 = p * 2.0 - 1.0;\n    vec2 p3 = p2 * 2.0 - 1.0;\n    vec2 p4 = p3 * 2.0 - 1.0;\n    vec2 p5 = p4 * 2.0 - 1.0;\n    vec2 p6 = p5 * 2.0 - 1.0;\n    vec2 p7 = p6 * 2.0 - 1.0;\n    vec2 p8 = p7 * 2.0 - 1.0;\n    vec2 p9 = p8 * 2.0 - 1.0;\n    vec2 p10 = p9 * 2.0 - 1.0;\n    vec2 p11 = p10 * 2.0 - 1.0;\n    vec2 p12 = p11 * 2.0 - 1.0;\n    vec2 p13 = p12 * 2.0 - 1.0;\n    vec2 p14 = p13 * 2.0 - 1.0;\n    vec2 p15 = p14 * 2.0 - 1.0;\n    vec2 p16 = p15 * 2.0 - 1.0;\n    vec2 p17 = p16 * 2.0 - 1.0;\n    vec2 p18 = p17 * 2.0 - 1.0;\n    vec2 p19 = p18 * 2.0 - 1.0;\n    vec2 p20 = p19 * 2.0 - 1.0;\n    vec2 p21 = p20 * 2.0 - 1.0;\n    vec2 p22 = p21 * 2.0 - 1.0;\n    vec2 p", "\n    return (1.0 - cos(2.0 * PI * ix)) * (1.0 - cos(2.0 * PI * iy));\n}\n\nfloat", "\n    vec3 color = vec3( 0.0 );\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( pos );\n        t += d;\n        pos = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    return color;\n}\n\nvoid main()\n{\n    vec3 color = vec3( 0.0 );\n    vec3 p = vec3( 0.0 );\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( p );\n        t += d;\n        p = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    return 1.0 - smoothstep(0.0, 1.0, p);\n}\n\nfloat", "\n    return vec2(\n        atan(z.y, z.x),\n        sqrt(z.x * z.x + z.y * z.y)\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    return dot(p, vec3(127.1, 311.7, 723.5));\n}\n\nfloat", "\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    return wave;\n}\n\nvoid main()\n{\n    vec3 p = vec3( gl_FragCoord.xy, 0.0 );\n    vec3 color = vec3( 0.0 );\n    float wave = waveDisplacement( p );\n    color = vec3( wave );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float a = atan( p.y, p.x ) / PI;\n    float r = length( p );\n    float h = map( r );\n    return vec3( a, h, r );\n}\n\nvec", "\n    float t = dot(rp, rp) - 1.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t4", "\n    return (d - start) / (end - start);\n}\n\nfloat", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return vec2(p.x*p.x,p.y*p.y);\n}\n\nvec", "\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);", "\n    float x = pc.x;\n    float y = pc.y;\n    float r = sqrt(x*x + y*y);\n    float theta = atan2(y,x);\n    float d = (r - a) / (b - a);\n    if(d > 1) return 0;\n    if(d < 0) return 0;\n    return 1;\n}\n\nfloat", "\n    return smoothstep(0.0, 1.0, abs(st.x - pct));\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, 0.0);\n    color = mix(vec3(1.0), vec3(0.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    vec2 q = p - circ.xy;\n    float r = circ.z;\n    return vec2(\n        r * q.x * (1.0 - q.y * q.y) + circ.x,\n        r * q.y * (1.0 - q.x * q.x) + circ.y\n    );\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy / resolution.xy) - vec2(0.5);\n    vec2 q = p * 2.0;\n    vec2 r = vec2(0.0);\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n    vec2 u = vec2(0.0);\n    vec2 v = vec2(0.0);\n    vec2 w = vec2(0.0);\n    vec2 x = vec2(0.0);\n    vec2 y = vec2(0.0);\n    vec2 z = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d = vec2(0.0);\n    vec2 e = vec2(0.0);\n    vec2 f = vec2(0.0);\n    vec2 g = vec2(0.0);\n    vec2 h = vec2(0.0);\n    vec2 i = vec2(0.0);\n    vec2 j = vec2(0.0);\n    vec2 k = vec2(0.0);\n    vec2 l = vec2(0.0);\n    vec2 m = vec2(0.0);\n    vec2 n = vec2(0.0);\n    vec2 o = vec2(0.0);\n    vec2 p0 = vec2(0.0);\n", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightAttenuationQuadratic = vec3(0.0);\n    vec3 lightAttenuationLinear = vec3(0.0);\n    vec3 lightAttenuationConstant = vec3(0.0);\n    vec3 lightAmbientQuadratic = vec3(0.0);\n    vec3 lightDiffuseQuadratic = vec3(0.0);\n    vec3 lightSpecularQuadratic = vec3(0.0);\n    vec3 lightAmbientLinear = vec3(0.0);\n    vec3 lightDiffuseLinear = vec3(0.0);\n    vec3 lightSpecularLinear = vec3(0.0);\n    vec3 lightAttenuationConstantQuadratic = vec3(0.0);\n    vec3 lightAttenuationConstantLinear = vec3(0.0);\n    vec3 lightAttenuationConstantConstant = vec3(0.0);\n    vec3 lightAmbientConstant = vec3(0.0);\n    vec3 lightDiffuseConstant = vec3(0.0);\n    vec3 lightSpecularConstant = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = mod(a, 2.0 * PI);\n    float t = mod(a / (2.0 * PI), 1.0);\n    float c = cos(r);\n    float s = sin(r);\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float r2 = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float g = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float b = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n\n    col = vec3(r2, g, b);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return vec3(hash, hash, hash);\n}\n\nvec", "\n    return bccNoise_PlaneFirst(X.x, X.y, X.z);\n}\n\nvec", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n\t\tfloat t = ( targetPos - ray.origin ).Dot( ray.direction ) / ray.direction.Dot( ray.direction );\n\t\treturn ray.origin + t * ray.direction;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tfloat distance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\ttangent = ( closestPoint - targetPos ).Cross( normal ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent, out vec3 bitang", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    vec4 p4 = vec4(p, 1.0);\n    p4 = p4 * 2.0 - 1.0;\n    p4.y = -p4.y;\n    p4 = p4 * 0.5 + 0.5;\n    return p4;\n}\n\nvec", "\n    float t = ( targetPos - ray.origin ).length() / ray.direction.length();\n    float d = ( targetPos - ray.origin ).dot( ray.direction );\n    float r = lightDiameter / 2.0;\n    float a = r * r / ( r * r + ( t - d ) * ( t - d ) );\n    float b = sqrt( 1.0 - a * a );\n    float c = ( t - d ) * b;\n    float d1 = c * ( 1.0 - a ) + a;\n    float d2 = c * a - 1.0;\n    float d3 = ( t - d ) * ( 1.0 - b ) + b;\n    float d4 = ( t - d ) * b - 1.0;\n    float d5 = ( t - d ) * ( 1.0 - a ) - a;\n    float d6 = c * ( 1.0 - b ) - b;\n    float d7 = c * b - 1.0;\n    float d8 = ( t - d ) * b - 1.0;\n    float d9 = ( t - d ) * ( 1.0 - b ) - b;\n    float d10 = ( t - d ) * b - 1.0;\n    float d11 = c * ( 1.0 - a ) - a;\n    float d12 = c * a - 1.0;\n    float d13 = ( t - d ) * ( 1.0 - b ) - b;\n    float d14 = ( t - d ) * b - 1.0;\n    float d15 = ( t - d ) * ( 1.0 - a ) - a;\n    float d16 = c * ( 1.0 - b ) - b;\n    float d17 = c * b - 1.0;\n    float d18 = ( t - d ) * b - 1.0;\n    float d19 = ( t - d ) * ( 1.0 - b ) - b;\n    float d20 = ( t - d ) * b - 1.0;\n   ", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    return (v >= 0 && v <= 1) && (w >= 0 && w <= 1);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p1 = vec2(0.0, 0.0);\n    vec2 p2 = vec2(resolution.x, 0.0);\n    vec2 p3 = vec2(resolution.x, resolution.y);\n    if (in_triangle(p1, p2, p3, uv)) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    vec2 p = uv - vec2(0.5);\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    float t = atan(p.y, p.x) / (2.0 * PI);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r6 * r2;\n    float r10 = r8 * r2;\n    float r12 = r10 * r2;\n    float r14 = r12 * r2;\n    float r16 = r14 * r2;\n    float r18 = r16 * r2;\n    float r20 = r18 * r2;\n    float r22 = r20 * r2;\n    float r24 = r22 * r2;\n    float r26 = r24 * r2;\n    float r28 = r26 * r2;\n    float r30 = r28 * r2;\n    float r32 = r30 * r2;\n    float r34 = r32 * r2;\n    float r36 = r34 * r2;\n    float r38 = r36 * r2;\n    float r40 = r38 * r2;\n    float r42 = r40 * r2;\n    float r44 = r42 * r2;\n    float r46 = r44 * r2;\n    float r48 = r46 * r2;\n    float r50 = r48 * r2;\n    float r52 = r50 * r2;\n    float r54 = r52 * r2;\n    float r56 = r54 * r2;\n    float r58 = r56 * r2;\n    float r60 = r58 * r2;\n    float r62 = r60 * r2;\n    float", "\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    float angle_offset = rotation * 2.0 * PI;\n    float angle_offset_2 = angle_offset * 2.0;\n    float angle_offset_3 = angle_offset * 3.0;\n    float angle_offset_4 = angle_offset * 4.0;\n    float angle_offset_5 = angle_offset * 5.0;\n    float angle_offset_6 = angle_offset * 6.0;\n    float angle_offset_7 = angle_offset * 7.0;\n    float angle_offset_8 = angle_offset * 8.0;\n    float angle_offset_9 = angle_offset * 9.0;\n    float angle_offset_10 = angle_offset * 10.0;\n    float angle_offset_11 = angle_offset * 11.0;\n    float angle_offset_12 = angle_offset * 12.0;\n    float angle_offset_13 = angle_offset * 13.0;\n    float angle_offset_14 = angle_offset * 14.0;\n    float angle_offset_15 = angle_offset * 15.0;\n    float angle_offset_16 = angle_offset * 16.0;\n    float angle_offset_17 = angle_offset * 17.0;\n    float angle_offset_18 = angle_offset * 18.0;\n    float angle_offset_19 = angle_offset * 19.0;\n    float angle_offset_20 = angle_offset * 20.0;\n    float angle_offset_21 = angle_offset * 21.0;\n    float angle_offset_22 = angle_offset * 22.0;\n    float angle_offset_23 = angle_offset * 23.0;\n    float angle_offset_24 = angle_offset * 24.0;\n    float angle_offset_25 = angle_offset * 25.0;\n    float angle_", "\n    vec2 p = vec2(0.5) - uv;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n    p.x *= circumradius;\n    p.y *= circumradius;\n    p = abs(p);\n    float d = length(p);\n    return step(d, r);\n}\n\nfloat", "\n    float r = sqrt(U.x * U.x + U.y * U.y);\n    float phi = atan2(U.y, U.x);\n    float a = 0.0;\n    float b = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float c = (a + b) / 2.0;\n        if (r * c < d) a = c;\n        else b = c;\n    }\n    return a;\n}\n\nfloat", "\n    return (n * 11) % 1000000007;\n}\n\nuint hash2(uint n)\n{\n    return (n * 13) % 1000000007;\n}\n\nuint hash3(uint n)\n{\n    return (n * 17) % 1000000007;\n}\n\nuint hash4(uint n)\n{\n    return (n * 19) % 1000000007;\n}\n\nuint hash5(uint n)\n{\n    return (n * 23) % 1000000007;\n}\n\nuint hash6(uint n)\n{\n    return (n * 29) % 1000000007;\n}\n\nuint hash7(uint n)\n{\n    return (n * 31) % 1000000007;\n}\n\nuint hash8(uint n)\n{\n    return (n * 37) % 1000000007;\n}\n\nuint hash9(uint n)\n{\n    return (n * 41) % 1000000007;\n}\n\nuint hash10(uint n)\n{\n    return (n * 43) % 1000000007;\n}\n\nuint hash11(uint n)\n{\n    return (n * 47) % 1000000007;\n}\n\nuint hash12(uint n)\n{\n    return (n * 53) % 1000000007;\n}\n\nuint hash13(uint n)\n{\n    return (n * 59) % 1000000007;\n}\n\nuint hash14(uint n)\n{\n    return (n * 61) % 1000000007;\n}\n\nuint hash15(uint n)\n{\n   ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        estimateHeight(p + e.yxx) - estimateHeight(p - e.yxx),\n        estimateHeight(p + e.xyx) - estimateHeight(p - e.xyx),\n        estimateHeight(p + e.xxy) - estimateHeight(p - e.xxy)\n    ));\n}\n\nfloat", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    vec3 c = texture2D( material, coord ).rgb;\n    if ( c.r == 0.0 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return false;\n    }\n    color = c;\n    return true;\n}\n\nvoid main() {\n    vec3 color;\n    if ( getMaterialColor( 0, gl_TexCoord[0].st, color ) ) {\n        gl_FragColor = vec4( color, 1.0 );\n    } else {\n        gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n}\n", "\n    vec2 q = vec2( dot(p, ab), p.x );\n    return vec2( length(q) - ab.y, dot(q, q) - ab.x );\n}\n\nfloat", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float tmin = -1.0;\n    float tmax = 1.0;\n    float tymin = (1.0 - raypos.y) / raypos.z;\n    float tymax = (1.0 - raypos.y) / raypos.z;\n    if (tymin > tmax)\n        std::swap(tymin, tmax);\n    if (tymin > tymin)\n        tymin = tymin;\n    if (tymax < tmax)\n        tmax = tymax;\n    float tzmin = (1.0 - raypos.z) / raypos.w;\n    float tzmax = (1.0 - raypos.z) / raypos.w;\n    if (tzmin > tmax)\n        std::swap(tzmin, tmax);\n    if (tzmin > tzmax)\n        tzmax = tzmin;\n    if (tmin > tzmin)\n        tmin = tzmin;\n    if (tmax < tzmax)\n        tmax = tzmax;\n    return tmin;\n}\n\nvec", "\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(vec3 rotation){\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(float x, float y, float z){\n\trotmat[0][0] = cos(x) * cos(y);\n\trotmat[0][1] = cos(x) * sin(y);\n\trotmat[0][2] = -sin(x);\n\trotmat[1][0] = sin(x) * cos(y);\n\trotmat[1][1] = sin(x) * sin(y);\n\trotmat[1][2] = cos(x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2", "\n    vec4 raypos = rayori;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec4 pos = raypos;\n        pos.xyz += raydir.xyz * t;\n        if(pos.w < 0.0) break;\n        t += raydir.w;\n    }\n    return pos;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = uv.xy;\n    float time = iGlobalTime;\n    float offset = time * 0.001;\n    float offset2 = time * 0.002;\n    float offset3 = time * 0.003;\n    float offset4 = time * 0.004;\n    float offset5 = time * 0.005;\n    float offset6 = time * 0.006;\n    float offset7 = time * 0.007;\n    float offset8 = time * 0.008;\n    float offset9 = time * 0.009;\n    float offset10 = time * 0.01;\n    float offset11 = time * 0.011;\n    float offset12 = time * 0.012;\n    float offset13 = time * 0.013;\n    float offset14 = time * 0.014;\n    float offset15 = time * 0.015;\n    float offset16 = time * 0.016;\n    float offset17 = time * 0.017;\n    float offset18 = time * 0.018;\n    float offset19 = time * 0.019;\n    float offset20 = time * 0.02;\n    float offset21 = time * 0.021;\n    float offset22 = time * 0.022;\n    float offset23 = time * 0.023;\n    float offset24 = time * 0.024;\n    float offset25 = time * 0.025;\n    float offset26 = time * 0.026;\n    float offset27 = time * 0.027;\n    float offset28 = time * 0.028;\n    float offset29 = time * 0.029;\n    float offset30 = time * 0.03;\n    float offset31", "\n    vec3 raypos = rayori;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float tmin_tmax[2];\n    for(int i = 0; i < 100; i++){\n        tmin_tmax[0] = tmin;\n        tmin_tmax[1] = tmax;\n        t = raymarch(raypos, raydir, tmin_tmax);\n        if(t < tmin_tmax[0]){\n            tmin_tmax[0] = t;\n        }\n        if(t > tmin_tmax[1]){\n            tmin_tmax[1] = t;\n        }\n        if(tmin_tmax[1] - tmin_tmax[0] < 0.001){\n            break;\n        }\n        tmin = tmin_tmax[0];\n        tmax = tmin_tmax[1];\n    }\n    return raypos + raydir * t;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float strength = maxStrength * sin(frequency * coord.x + time * travelRate);\n    return strength;\n}\n\nvoid main()\n{\n    vec2 coord = gl_FragCoord.xy / resolution.xy;\n    vec2 coord2 = coord * 2.0 - 1.0;\n    vec2 coord3 = coord2 * 2.0 - 1.0;\n    vec2 coord4 = coord3 * 2.0 - 1.0;\n    vec2 coord5 = coord4 * 2.0 - 1.0;\n    vec2 coord6 = coord5 * 2.0 - 1.0;\n    vec2 coord7 = coord6 * 2.0 - 1.0;\n    vec2 coord8 = coord7 * 2.0 - 1.0;\n    vec2 coord9 = coord8 * 2.0 - 1.0;\n    vec2 coord10 = coord9 * 2.0 - 1.0;\n    vec2 coord11 = coord10 * 2.0 - 1.0;\n    vec2 coord12 = coord11 * 2.0 - 1.0;\n    vec2 coord13 = coord12 * 2.0 - 1.0;\n    vec2 coord14 = coord13 * 2.0 - 1.0;\n    vec2 coord15 = coord14 * 2.0 - 1.0;\n    vec2 coord16 = coord15 * 2.0 - 1.0;\n    vec2 coord17 = coord16 * 2.0 - 1.0;\n    vec2 coord18 = coord17 * 2.0 - 1.0;\n    vec2 coord19 = coord18 * 2.0 - 1.0;\n    vec2 coord20 = coord19 * 2.0 - 1.0;\n    vec2 coord21 = coord20 * 2.0 - 1.0;\n    vec2 coord22 = coord21 * ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 p1 = p + d;\n    vec2 p2 = p + d + vec2(0.0, 1.0);\n    vec2 p3 = p + d + vec2(1.0, 0.0);\n    vec2 p4 = p + d + vec2(1.0, 1.0);\n    vec2 p5 = p + d + vec2(0.0, 2.0);\n    vec2 p6 = p + d + vec2(1.0, 2.0);\n    vec2 p7 = p + d + vec2(2.0, 1.0);\n    vec2 p8 = p + d + vec2(2.0, 0.0);\n    vec2 p9 = p + d + vec2(2.0, 2.0);\n    vec2 p10 = p + d + vec2(3.0, 1.0);\n    vec2 p11 = p + d + vec2(3.0, 0.0);\n    vec2 p12 = p + d + vec2(3.0, 2.0);\n    vec2 p13 = p + d + vec2(4.0, 1.0);\n    vec2 p14 = p + d + vec2(4.0, 0.0);\n    vec2 p15 = p + d + vec2(4.0, 2.0);\n    vec2 p16 = p + d + vec2(5.0, 1.0);\n    vec2 p17 = p + d + vec2(5.0, 0.0);\n    vec2 p18 = p + d + vec2(5.0, 2.0);\n    vec2 p19 = p + d + vec2(6.0, 1.0);\n    vec2 p20 = p + d + vec2(6.0, 0.0);\n    vec2 p21 = p + d + ve", "\n    return color * (1.0 - filmic_exposure) + vec3(1.0) * filmic_exposure;\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texcoord).rgb;\n    vec3 filmic_color = filmic(color);\n    vec3 gamma = vec3(1.0 / 2.2);\n    vec3 gamma_color = pow(filmic_color, gamma);\n    out_color = vec4(gamma_color, 1.0);\n}\n", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    return sdSegment( p, a, b ) - w1 * ( 1.0 - t ) - w2 * t;\n}\n\nfloat", "\n    vec2 q = uv - p;\n    return vec3( length(q) - 0.02, 0.0, 0.0 );\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 col = vec3(0.0);\n    col += blob(uv, p);\n    col += blob(uv, p + vec2(0.0, 1.0));\n    col += blob(uv, p + vec2(1.0, 0.0));\n    col += blob(uv, p + vec2(1.0, 1.0));\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n\tfloat t = falloff * rnd.x;\n\treturn vec3( 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ) );\n}\n\nvoid main()\n{\n\tvec3 rnd = vec3( 0.0 );\n\trnd.x = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.y = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.z = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\n\tvec3 color = vec3( 0.0 );\n\tcolor += pulse( 0.0, rnd );\n\tcolor += pulse( 0.1, rnd );\n\tcolor += pulse( 0.2, rnd );\n\tcolor += pulse( 0.3, rnd );\n\tcolor += pulse( 0.4, rnd );\n\tcolor += pulse( 0.5, rnd );\n\tcolor += pulse( 0.6, rnd );\n\tcolor += pulse( 0.7, rnd );\n\tcolor += pulse( 0.8, rnd );\n\tcolor += pulse( 0.9, rnd );\n\tcolor += pulse( 1.0, rnd );\n\n\tgl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    return (1.0f - expf(-2.0f * x)) / (1.0f + expf(-2.0f * x));\n}\n\nfloat", "\n    vec2 uv = q;\n    uv.y = 1.0 - uv.y;\n    vec3 c = texture2D(u_texture, uv).rgb;\n    return mix(col, c, 0.2);\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n\n    col = postProcess(col, q);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), q.z) - 1.0;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s ="]}