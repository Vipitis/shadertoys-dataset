{"generations": [" return 0.282095; }\nfloat SH_1_1( in vec3 s ) { return 0.488603 * s.x; }\nfloat SH_1_0( in vec3 s ) { return 0.488603 * s.y; }\nfloat SH_0_1( in vec3 s ) { return 0.488603 * s.z; }\nfloat SH_2_2( in vec3 s ) { return 1.092548 * s.x * s.x - 0.315392 * s.y * s.y - 0.546274 * s.z * s.z; }\nfloat SH_2_1( in vec3 s ) { return 1.092548 * s.x * s.y + 0.546274 * s.z * s.y; }\nfloat SH_2_0( in vec3 s ) { return 1.092548 * s.x * s.z - 0.546274 * s.y * s.z; }\nfloat SH_1_2( in vec3 s ) { return 1.092548 * s.y * s.z + 0.315392 * s.x * s.y; }\nfloat SH_0_2( in vec3 s ) { return 1.092548 * s.z * s.z - 0.546274 * s.x * s.z; }\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n", "\n    return length(a-p)+length(b-p)-length(a-b);\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, out float t )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    t = h;\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, out float t, out float d )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    t = h;\n    d = length( pa - ba*h );\n    return d;\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, out float t, out float d, out float e )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    t = h;\n    d = length( pa - ba*h );\n    e = abs(length(pa)-d);\n    return d;\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p, out float t, out float d, out float e, out float f )\n{\n    vec2 pa = p-a, ba = b-a;", "\n    return (dot(v,r)<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return (dot(v,r)<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return (dot(v,r)<0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfPos( in vec2 v, in vec2 r )\n{\n    return (dot(v,r)>0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfPos( in vec3 v, in vec3 r )\n{\n    return (dot(v,r)>0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfPos( in vec4 v, in vec4 r )\n{\n    return (dot(v,r)>0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfZero( in vec2 v, in vec2 r )\n{\n    return (dot(v,r)==0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfZero( in vec3 v, in vec3 r )\n{\n    return (dot(v,r)==0.0)? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3", "\n    return (dot(v,r)<0.0)? v : -v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return (dot(v,r)<0.0)? v : -v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return (dot(v,r)<0.0)? v : -v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in float r )\n{\n    return (dot(v,r)<0.0)? v : -v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in float r )\n{\n    return (dot(v,r)>0.0)? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too", "\n    return (v.x < r.x)? vec2(-1.0, -1.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return (v.x > r.y)? vec2(-1.0, -1.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    return (v.x < r.x)? vec3(-1.0, -1.0, -1.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return (v.x > r.y)? vec3(-1.0, -1.0, -1.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    return (v.x < r.x)? vec4(-1.0, -1.0, -1.0, -1.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return (v.x > r.y)? vec4(-1.0, -1.0, -1.0, -1.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec3 r )\n{\n    return (v.x < r.x)? vec4(-1.0, -1.0, -1.0, -1.0) : v;\n}\n", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 + w2*h;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow( p, a, b, 0.05, 0.05 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, float w )\n{\n    return sdArrow( p, a, vec2(0.0), w, w );\n}\n\nfloat sdArrow( in vec2 p, float w )\n{\n    return sdArrow( p, vec2(0.0), vec2(0.0), w, w );\n}\n\nfloat sdArrow( in vec2 p )\n{\n    return sdArrow( p, vec2(0.0), vec2(0.0), 0.05, 0.05 );\n}\n\n// https://www.shadertoy.com/view/4sSSzf\nfloat sdArrow2( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 + w2*h;\n}\n\nfloat sdArrow2( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow2( p, a, b, w, w );\n}\n\nfloat sdArrow2( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow2( p, a, b", "\n\tfloat rayDirDotSunDir = dot(rayDir, sunDir);\n\tfloat rayDirDotSunDirSqr = rayDirDotSunDir * rayDirDotSunDir;\n\tfloat rayDirDotSunDirCub = rayDirDotSunDirSqr * rayDirDotSunDir;\n\tfloat rayDirDotSunDirPow = pow(rayDirDotSunDir, 10.0);\n\tfloat rayDirDotSunDirPow2 = rayDirDotSunDirPow * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow3 = rayDirDotSunDirPow2 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow4 = rayDirDotSunDirPow3 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow5 = rayDirDotSunDirPow4 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow6 = rayDirDotSunDirPow5 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow7 = rayDirDotSunDirPow6 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow8 = rayDirDotSunDirPow7 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow9 = rayDirDotSunDirPow8 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow10 = rayDirDotSunDirPow9 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow11 = rayDirDotSunDirPow10 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow12 = rayDirDotSunDirPow11 * rayDirDotSunDirPow;\n\tfloat rayDirDotSunDirPow1", "\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    return 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension)\n{\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    return 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, float tension, float strength)\n{\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n    return 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1,", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tn += amp * sin(freq * p.x + iGlobalTime);\n\t\tn += amp * sin(freq * p.y + iGlobalTime);\n\t\tn += amp * sin(freq * p.z + iGlobalTime);\n\t\tfreq *= 1.8;\n\t\tamp *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D noise function that uses a 2D noise function to create a 3D noise function.\n// It's a bit slower than the other noise functions, but it's a lot more flexible.\n// It's also a bit more complicated, so you might want to use a simpler noise function if you don't need the flexibility.\nfloat Noise3D(vec3 p)\n{\n\tvec2 n = Noise2D(p.xy);\n\treturn n.x * n.y;\n}\n\n// This is a 3D noise function that uses a 2D noise function to create a 3D noise function.\n// It's a bit slower than the other noise functions, but it's a lot more flexible.\n// It's also a bit more complicated, so you might want to use a simpler noise function if you don't need the flexibility.\nfloat Noise3D(vec3 p, float freq)\n{\n\tvec2 n = Noise2D(p.xy * freq);\n\treturn n.x * n.y;\n}\n\n// This is a 3D noise function that uses a 2D noise function to create a 3D noise function.\n// It's a bit slower than the other noise functions, but it's a lot more flexible.\n// It's also a bit more complicated, so you might want to use a simpler noise function if you don't need the flexibility.\nfloat Noise3D(vec3 p, float freq, float amp)\n{\n\tvec2 n = Noise2D", "\n\tvec4 p0 = camPath[0];\n\tvec4 p1 = camPath[1];\n\tvec4 p2 = camPath[2];\n\tvec4 p3 = camPath[3];\n\n\tvec4 p = p0 * 0.5 + p1 * 0.5;\n\tvec4 q = p1 * 0.5 + p2 * 0.5;\n\tvec4 r = p2 * 0.5 + p3 * 0.5;\n\n\tvec4 a = p * 0.5 + q * 0.5;\n\tvec4 b = q * 0.5 + r * 0.5;\n\tvec4 c = a * 0.5 + b * 0.5;\n\n\tvec4 d = c * 0.5 + p * 0.5;\n\n\treturn d * t + (c * t * t * 2.0) + (b * t * t) + (a * t);\n}\n\n// from a time t, this finds where in the camera path you are\n// It uses Catmull-Rom splines\nvec4 CamRot(float t)\n{\n\tvec4 p0 = camPathRot[0];\n\tvec4 p1 = camPathRot[1];\n\tvec4 p2 = camPathRot[2];\n\tvec4 p3 = camPathRot[3];\n\n\tvec4 p = p0 * 0.5 + p1 * 0.5;\n\tvec4 q = p1 * 0.5 + p2 * 0.5;\n\tvec4 r = p2 * 0.5 + p3 * 0.5;\n\n\tvec4 a = p * 0.5 + q * 0.5;\n\tvec4 b = q * 0.5 + r * 0.5;\n\tvec4 c = a * 0.5 + b * 0.5;\n\n\tvec4 d = c * 0.5 + p * 0.5;\n\n\treturn d * t + (c * t * t * 2.0) + (b * t * t) + (a * t);\n}\n\n", "\n    return fract(sin(u * 12345.6789) * 43758.5453);\n}\n\nfloat Hash1d(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(123.456, 678.901))) * 43758.5453);\n}\n\nfloat Hash1d(vec3 uv)\n{\n    return fract(sin(dot(uv, vec3(123.456, 678.901, 222.222))) * 43758.5453);\n}\n\nfloat Hash1d(vec4 uv)\n{\n    return fract(sin(dot(uv, vec4(123.456, 678.901, 222.222, 333.333))) * 43758.5453);\n}\n\nfloat Noise1d(float u)\n{\n    float i = floor(u);\n    float f = fract(u);\n    return mix(Hash1d(i), Hash1d(i + 1.0), f);\n}\n\nfloat Noise1d(vec2 uv)\n{\n    float i = floor(uv.x);\n    float f = fract(uv.x);\n    return mix(Hash1d(vec2(i, uv.y)), Hash1d(vec2(i + 1.0, uv.y)), f);\n}\n\nfloat Noise1d(vec3 uv)\n{\n    float i = floor(uv.x);\n    float f = fract(uv.x);\n    return mix(Hash1d(vec3(i, uv.y, uv.z)), Hash1d(vec3(i + 1.0, uv.y, uv.z)), f);\n}\n\nfloat Noise1d(vec4 uv)\n{\n    float i = floor(uv.x);\n    float f = fract(uv.x", "\n\tfloat n = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tn += amp * sin(p.x*freq + iTime*freq*0.1);\n\t\tn += amp * sin(p.y*freq + iTime*freq*0.1);\n\t\tn += amp * sin(p.z*freq + iTime*freq*0.1);\n\t\tfreq *= 1.9;\n\t\tamp *= 0.5;\n\t}\n\treturn n;\n}\n\n// This is a function that returns a value between 0 and 1 based on the distance from a point.\n// It's a good function to use for a heightmap.\nfloat DistanceNoise3D(vec3 p)\n{\n\treturn 1.0 - smoothstep(0.0, 0.01, length(p));\n}\n\n// This is a function that returns a value between 0 and 1 based on the distance from a point.\n// It's a good function to use for a heightmap.\nfloat DistanceNoise3D(vec3 p, float freq)\n{\n\treturn 1.0 - smoothstep(0.0, 0.01, length(p*freq));\n}\n\n// This is a function that returns a value between 0 and 1 based on the distance from a point.\n// It's a good function to use for a heightmap.\nfloat DistanceNoise3D(vec3 p, float freq, float amp)\n{\n\treturn 1.0 - smoothstep(0.0, 0.01, length(p*freq)*amp);\n}\n\n// This is a function that returns a value between 0 and 1 based on the distance from a point.\n// It's a good function to use for a heightmap.\nfloat DistanceNoise3D(vec3 p, float freq, float amp, float persistence)\n{\n\treturn 1.0 - smoothstep(0.0, 0.0", "\n    float d = 0.0;\n    float scale = 1.0;\n    float prevd = 0.0;\n    float prevscale = 1.0;\n    float prevprevd = 0.0;\n    float prevprevscale = 1.0;\n    float prevprevprevd = 0.0;\n    float prevprevprevscale = 1.0;\n    float prevprevprevprevd = 0.0;\n    float prevprevprevprevscale = 1.0;\n    float prevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevprevscale = 1.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevprevprevd = 0.0;\n    float prevprevprevprevprevprevprevprevprevprevprevprevprevprevscale = 1.0;\n   ", "\n    vec3 envColor = vec3(0.0);\n\n    // Get the ray's starting position.\n    vec3 rayPos = vec3(0.0);\n    float rayLength = 0.0;\n    float rayLength2 = 0.0;\n    float rayLength3 = 0.0;\n    float rayLength4 = 0.0;\n    float rayLength5 = 0.0;\n    float rayLength6 = 0.0;\n    float rayLength7 = 0.0;\n    float rayLength8 = 0.0;\n    float rayLength9 = 0.0;\n    float rayLength10 = 0.0;\n    float rayLength11 = 0.0;\n    float rayLength12 = 0.0;\n    float rayLength13 = 0.0;\n    float rayLength14 = 0.0;\n    float rayLength15 = 0.0;\n    float rayLength16 = 0.0;\n    float rayLength17 = 0.0;\n    float rayLength18 = 0.0;\n    float rayLength19 = 0.0;\n    float rayLength20 = 0.0;\n    float rayLength21 = 0.0;\n    float rayLength22 = 0.0;\n    float rayLength23 = 0.0;\n    float rayLength24 = 0.0;\n    float rayLength25 = 0.0;\n    float rayLength26 = 0.0;\n    float rayLength27 = 0.0;\n    float rayLength28 = 0.0;\n    float rayLength29 = 0.0;\n    float rayLength30 = 0.0;\n    float rayLength31 = 0.0;\n    float rayLength32 = 0.0;\n    float rayLength33 = 0.0;\n    float rayLength34 = 0.0;\n    float rayLength35 = 0.0;\n    float rayLength36 = 0.0;\n    float rayLength37 = 0.0;\n", "\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec2 smax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nvec3 smin( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(", "\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 posToSphere = pos - spherePos;\n\tfloat a = dot(dirVec, dirVec);\n\tfloat b = 2.0 * dot(dirVec, posToSphere);\n\tfloat c = dot(posToSphere, posToSphere) - rad * rad;\n\tfloat disc = b * b - 4.0 * a * c;\n\tif (disc < 0.0)\n\t{\n\t\treturn -1.0;\n\t}\n\telse\n\t{\n\t\tfloat t1 = (-b - sqrt(disc)) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrt(disc)) / (2.0 * a);\n\t\tif (t1 < 0.0)\n\t\t{\n\t\t\treturn t2;\n\t\t}\n\t\telse if (t2 < 0.0)\n\t\t{\n\t\t\treturn t1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn min(t1, t2);\n\t\t}\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat PlaneIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos, vec3 planeNormal)\n{\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tfloat denom = dot(planeNormal, dirVec);\n\tif (denom > 0.0)\n\t{\n\t\treturn -1.0;\n\t}\n\telse\n\t{\n\t\treturn dot(planeNormal, pos - planePos) / denom;\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat CylinderIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 cylinderPos, vec3 cylinderDir, float cylinderRad)\n{\n\tvec3 dirVec = dirVecPLZNormalizeMeFirst;\n\tvec3 posToCylinder = pos - cylinderPos;\n\tfloat a = dot(", "\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance field is a function of the position.\n    // The distance", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41", "\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat t4 = t3 * t;\n\tfloat t5 = t4 * t;\n\tfloat t6 = t5 * t;\n\tfloat t7 = t6 * t;\n\tfloat t8 = t7 * t;\n\tfloat t9 = t8 * t;\n\tfloat t10 = t9 * t;\n\tfloat t11 = t10 * t;\n\tfloat t12 = t11 * t;\n\tfloat t13 = t12 * t;\n\tfloat t14 = t13 * t;\n\tfloat t15 = t14 * t;\n\tfloat t16 = t15 * t;\n\tfloat t17 = t16 * t;\n\tfloat t18 = t17 * t;\n\tfloat t19 = t18 * t;\n\tfloat t20 = t19 * t;\n\tfloat t21 = t20 * t;\n\tfloat t22 = t21 * t;\n\tfloat t23 = t22 * t;\n\tfloat t24 = t23 * t;\n\tfloat t25 = t24 * t;\n\tfloat t26 = t25 * t;\n\tfloat t27 = t26 * t;\n\tfloat t28 = t27 * t;\n\tfloat t29 = t28 * t;\n\tfloat t30 = t29 * t;\n\tfloat t31 = t30 * t;\n\tfloat t32 = t31 * t;\n\tfloat t33 = t32 * t;\n\tfloat t34 = t33 * t;\n\tfloat t35 = t34 * t;\n\tfloat t36 = t35 * t;\n\tfloat t37 = t36 * t;\n\tfloat t38 = t37 * t;\n\tfloat t39 = t38 * t;\n\tfloat t40 = t39 * t;\n\tfloat t41 = t40 * t;\n\tfloat t42 = t41", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t41 = t40 * t;\n    float t42 = t41", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return pa*pa - ba*ba*h;\n}\n\n// signed distance between point and segment\nfloat sdistPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance between point and triangle\nfloat sdistPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n    vec3 nor = cross( ab, ac );\n\n    float s = clamp( dot(ap,nor)/dot(ab,nor), 0.0, 1.0 );\n    float t = clamp( dot(bp,nor)/dot(ab,nor), 0.0, 1.0 );\n    float u = clamp( dot(cp,nor)/dot(ab,nor), 0.0, 1.0 );\n\n    float d = abs( dot(nor,ap) );\n    float e = abs( dot(nor,bp) );\n    float f = abs( dot(nor,cp) );\n\n    if( (s+t+u) <= 1.0 )\n    {\n        if( s < 0.0 )\n        {\n            if( t < 0.0 )\n            {\n                if( u < 0.0 )\n                    return d;\n                else\n                    return f;\n            }\n            else\n            {\n                if( u < 0.0 )\n                    return e;\n                else\n                    return min( d, e );\n            }\n        }\n       ", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    float e = dot(d,ab);\n    float f = dot(d,ao);\n    float g = dot(ab,ao);\n    float a = 1.0 - clamp( e / dot(ab,ab), 0.0, 1.0 );\n    float b = clamp( ( f / dot(ab,ab) + a * g ) / ( g + e ), 0.0, 1.0 );\n    vec2 s = vec2( a, b );\n    return -s * vec2( e ) + vec2( f ) - vec2( g );\n}\n\n// signed distance between ray and segment\nfloat sdistLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n    vec2 s = usqdLineSegment( a, b, o, d );\n    return -sqrt( s.x ) + sqrt( s.y );\n}\n\n// signed distance between ray and triangle\nfloat sdistTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n    vec3 e1 = b - a;\n    vec3 e2 = c - a;\n    vec3 p = cross( d, e2 );\n    float det = dot( e1, p );\n    vec3 t = o - a;\n    float invDet = 1.0 / det;\n    float u = dot( t, p ) * invDet;\n    vec3 q = cross( t, e1 );\n    float v = dot( d, q ) * invDet;\n    float w = 1.0 - u - v;\n    if( u < 0.0 || v < 0.0 || w < 0.0 )\n        return 1000000.0;\n    return dot( e1, q ) * invDet;\n}\n\n// signed distance between ray and quad\nfloat sdistQuad( vec3 a, vec3 b, vec3 c, vec3 d, vec3 o, vec3 d )\n{\n    float s1 = sdistTriangle( a, b", "\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdRoundBox( in vec2 p, in vec2 b, in float rx, in float ry ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - rx;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdRoundBox( in vec2 p, in vec2 b, in float rx, in float ry, in float rz, in float rw ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - rx;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat sdRoundBox( in vec2 p, in vec2 b, in float rx, in float ry, in float rz ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - rx;\n}\n\n// https://www.shadertoy.com/", "\n\tfloat rayDirDotSunDir = dot(rayDir, sunDir);\n\tfloat rayDirDotSunDirSqr = rayDirDotSunDir * rayDirDotSunDir;\n\tfloat rayDirDotSunDirCub = rayDirDotSunDirSqr * rayDirDotSunDir;\n\tfloat rayDirDotSunDirPow = pow(rayDirDotSunDir, 10.0);\n\tfloat rayDirDotSunDirPow2 = pow(rayDirDotSunDir, 20.0);\n\tfloat rayDirDotSunDirPow3 = pow(rayDirDotSunDir, 30.0);\n\tfloat rayDirDotSunDirPow4 = pow(rayDirDotSunDir, 40.0);\n\tfloat rayDirDotSunDirPow5 = pow(rayDirDotSunDir, 50.0);\n\tfloat rayDirDotSunDirPow6 = pow(rayDirDotSunDir, 60.0);\n\tfloat rayDirDotSunDirPow7 = pow(rayDirDotSunDir, 70.0);\n\tfloat rayDirDotSunDirPow8 = pow(rayDirDotSunDir, 80.0);\n\tfloat rayDirDotSunDirPow9 = pow(rayDirDotSunDir, 90.0);\n\tfloat rayDirDotSunDirPow10 = pow(rayDirDotSunDir, 100.0);\n\tfloat rayDirDotSunDirPow11 = pow(rayDirDotSunDir, 110.0);\n\tfloat rayDirDotSunDirPow12 = pow(rayDirDotSunDir, 120.0);\n\tfloat rayDirDotSunDirPow13 = pow(rayDirDotSunDir, 130.0);\n\tfloat rayDirDotSunDirPow14 = pow(rayDirDotSunDir, 140.0);\n\t", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// This function is used to calculate the rays that are going to be casted\n// from the camera.\nvoid calculateEyeRay( in vec3 ro, in vec3 ta, in float roll, in float fov, in vec2 q, out vec3 rayo, out vec3 rayd )\n{\n    mat3 camMat = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    vec3 dir = normalize( camMat * vec3( q.x, q.y, -1.0 ) );\n    rayo = ro;\n    rayd = dir;\n}\n\n// This function is used to calculate the rays that are going to be casted\n// from the camera.\nvoid calculateEyeRay( in vec3 ro, in vec3 ta, in float roll, in float fov, in vec2 q, out vec3 rayo, out vec3 rayd, out vec3 rayo2, out vec3 rayd2 )\n{\n    mat3 camMat = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    vec3 dir = normalize( camMat * vec3( q.x, q.y, -1.0 ) );\n    rayo = ro;\n    rayd = dir;\n    rayo2 = ro;\n    rayd2 = dir;\n}\n\n// This function is used to calculate the rays that are going to be casted\n// from the camera.\nvoid calculateEyeRay( in vec3 ro, in vec3 ta, in float roll, in float fov, in vec2 q, out vec3 rayo, out vec3 rayd, out vec3 rayo2, out vec3 rayd2, out vec3 rayo3, out vec3 rayd3 )\n{\n    mat3 camMat = calculateEyeRayTransformationMatrix( ro, ta, roll );\n    vec3 dir = normalize", "\n    float radius = 1.0;\n    float height = 1.0;\n    float thickness = 0.1;\n    float scale = 1.0;\n    float t = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n   ", "\n    // The distance to each thing\n    float dist1 = distance( thing1, u_mouse );\n    float dist2 = distance( thing2, u_mouse );\n    // If the distance to thing1 is less than the distance to thing2\n    // then return thing1\n    if( dist1 < dist2 ){\n        return thing1;\n    }\n    // If the distance to thing2 is less than the distance to thing1\n    // then return thing2\n    else if( dist2 < dist1 ){\n        return thing2;\n    }\n    // If they are equal, then return the one that is closest to the mouse\n    else{\n        return thing2;\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1, vec2 thing2, vec2 thing3 ){\n    // The distance to each thing\n    float dist1 = distance( thing1, u_mouse );\n    float dist2 = distance( thing2, u_mouse );\n    float dist3 = distance( thing3, u_mouse );\n    // If the distance to thing1 is less than the distance to thing2\n    // then return thing1\n    if( dist1 < dist2 ){\n        if( dist1 < dist3 ){\n            return thing1;\n        }\n        else{\n            return thing3;\n        }\n    }\n    // If the distance to thing2 is less than the distance to thing1\n    // then return thing2\n    else if( dist2 < dist1 ){\n        if( dist2 < dist3 ){\n            return thing2;\n        }\n        else{\n            return thing3;\n        }\n    }\n    // If they are equal, then return the one that is closest to the mouse\n    else{\n        if( dist3 < dist1 ){\n            return thing3;\n        }\n        else{\n            return thing1;\n        }\n    }\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in", "\n\n    // The distance to the closest object\n    float closestDistance = 1000000.0;\n\n    // The object that is closest\n    int closestObject = -1;\n\n    // Loop through all the objects\n    for( int i = 0; i < numObjects; i++ ){\n\n        // Get the object\n        Object object = objects[i];\n\n        // Get the distance to the object\n        float distance = distanceToObject( object, currentRayPosition );\n\n        // If the distance is closer than the closest distance\n        if( distance < closestDistance ){\n\n            // Set the closest distance\n            closestDistance = distance;\n\n            // Set the closest object\n            closestObject = i;\n        }\n    }\n\n    // Return the closest distance and object\n    return vec2( closestDistance, closestObject );\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition, vec3 currentRayDirection ){\n\n    // The distance to the closest object\n    float closestDistance = 1000000.0;\n\n    // The object that is closest\n    int closestObject = -1;\n\n    // Loop through all the objects\n    for( int i = 0; i < numObjects; i++ ){\n\n        // Get the object\n        Object object = objects[i];\n\n        // Get the distance to the object\n        float distance = distanceToObject( object, currentRayPosition, currentRayDirection );\n\n        // If the distance is closer than the closest distance\n        if( distance < closestDistance ){\n\n            // Set the closest distance\n            closestDistance = distance;\n\n            // Set the closest object\n            closestObject = i;\n        }\n    }\n\n    // Return the closest distance and object\n    return vec2( closestDistance, closestObject );\n}\n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec", "\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map( positionOfHit + e.xyy ).x - map( positionOfHit - e.xyy ).x,\n        map( positionOfHit + e.yxy ).x - map( positionOfHit - e.yxy ).x,\n        map( positionOfHit + e.yyx ).x - map( positionOfHit - e.yyx ).x );\n    return normalize(nor);\n}\n\n// This function is used to calculate the lighting of the surface\n// It is a simple function that takes in the position of the surface,\n// the normal of the surface, and the direction of the light.\n// It then returns the color of the light.\nvec3 getLighting( in vec3 positionOfHit, in vec3 normalOfSurface, in vec3 directionOfLight ){\n    vec3 lightColor = vec3( 1.0 );\n    float lightIntensity = 1.0;\n    float lightDistance = 1.0;\n    float lightAttenuation = 1.0;\n    float lightAngle = 1.0;\n    float lightSpot = 1.0;\n    float lightShadow = 1.0;\n    vec3 lightDirection = normalize( directionOfLight );\n    vec3 lightReflect = reflect( lightDirection, normalOfSurface );\n    vec3 lightDiffuse = max( dot( normalOfSurface, lightDirection ), 0.0 ) * lightColor;\n    vec3 lightSpecular = pow( max( dot( lightReflect, normalize( -positionOfHit ) ), 0.0 ), 16.0 ) * lightColor;\n    vec3 lightAmbient = vec3( 0.1 );\n    vec3 lighting = ( lightAmbient + lightDiffuse + lightSpecular ) * lightIntensity / ( lightDistance * lightAttenuation + lightSpot * lightShadow );\n    return lighting;\n}\n\n// This function is used to calculate the color of the surface\n// It is a simple function that takes in the position of the surface,", "\n    return vec3(0.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord){\n    // we'll just return a solid color for now\n    return vec3(1.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord, vec2 fragCoordPrev){\n    // we'll just return a solid color for now\n    return vec3(1.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord, vec2 fragCoordPrev, vec2 fragCoordNext){\n    // we'll just return a solid color for now\n    return vec3(1.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord, vec2 fragCoordPrev, vec2 fragCoordNext, vec2 fragCoordNextNext){\n    // we'll just return a solid color for now\n    return vec3(1.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord, vec2 fragCoordPrev, vec2 fragCoordNext, vec2 fragCoordNextNext, vec2 fragCoordNextNextNext){\n    // we'll just return a solid color for now\n    return vec3(1.0);\n}\n\n// this is the function that will be called for each pixel to be rasterized\n// it is responsible for returning the color of the pixel\nvec3 doPixel(vec2 fragCoord, vec2 fragCoordPrev, vec2 fragCoordNext, vec2 fragCoordNextNext, vec2 fragCoordNextNextNext, vec2 fragCoordNextNext", "\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doTorusColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doPlaneColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doTriangleColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// This is the function that is called when we hit something.\n// It is called with the position of the hit, and the normal of the surface.\n// It returns a color.\nvec3 doQuadColor(vec3 positionOfHit, vec3 normalOfSurface ){", "\n\n    // This is the color of the world!\n    vec3 color = vec3( 0.0 );\n\n    // This is the color of the sky!\n    vec3 skyColor = vec3( 0.5, 0.7, 1.0 );\n\n    // This is the color of the ground!\n    vec3 groundColor = vec3( 0.4, 0.4, 0.4 );\n\n    // This is the color of the water!\n    vec3 waterColor = vec3( 0.0, 0.3, 0.6 );\n\n    // This is the color of the grass!\n    vec3 grassColor = vec3( 0.0, 0.5, 0.0 );\n\n    // This is the color of the sand!\n    vec3 sandColor = vec3( 0.9, 0.9, 0.7 );\n\n    // This is the color of the rock!\n    vec3 rockColor = vec3( 0.5, 0.5, 0.5 );\n\n    // This is the color of the snow!\n    vec3 snowColor = vec3( 1.0, 1.0, 1.0 );\n\n    // This is the color of the ice!\n    vec3 iceColor = vec3( 0.0, 0.5, 1.0 );\n\n    // This is the color of the lava!\n    vec3 lavaColor = vec3( 1.0, 0.0, 0.0 );\n\n    // This is the color of the fire!\n    vec3 fireColor = vec3( 1.0, 0.3, 0.0 );\n\n    // This is the color of the wood!\n    vec3 woodColor = vec3( 0.5, 0.3, 0.0 );\n\n    // This is the color of the metal!\n    vec3 metalColor = vec3( 0.7, 0.7, 0.7 );\n\n    // This is the color of the plastic!\n    vec3 plasticColor = vec3( 0.5, 0.5, 0.5 );\n", "\n    return x / (1.0 - b) / (1.0 + b);\n}\n\n// blends between 0.0 and 1.0\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/xhxqyqhxqd\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat blend(float x, float b) {\n    return x / (1.0 - b) / (1.0 + b);\n}\n\n// blends between 0.0 and 1.0\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/xhxqyqhxqd\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat blend(float x, float b, float c) {\n    return x / (1.0 - b) / (1.0 + b) / (1.0 - c) / (1.0 + c);\n}\n\n// blends between 0.0 and 1.0\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/xhxqyqhxqd\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat blend(float x, float b, float c, float d) {\n    return x / (1.0 - b) / (1.0 + b) / (1.0 - c) / (1.0 + c) / (1.0 - d) / (1.0 + d);\n}\n\n// bl", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 45.543, 1.0))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec2 p, float seed){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 * seed);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(float p, float seed){\n    return fract(sin(p * 12.9898) * 43758.5453 * seed);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p, float seed){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453 * seed);\n}\n\n// creates", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec2 p){\n    return rand_inclusive(p) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(float p){\n    return rand_inclusive(vec2(p, p)) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec3 p){\n    return rand_inclusive(vec2(p.x, p.z)) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec4 p){\n    return rand_inclusive(vec2(p.x, p.z)) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec2 p, float seed){\n    return rand_inclusive(vec2(p.x, p.y) + seed) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(float p, float seed){\n    return rand_inclusive(vec2(p, p) + seed) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec3 p, float seed){\n    return rand_inclusive(vec2(p.x, p.z) + seed) - 0.5;\n}\n\n// creates white noise in the range 0..1 excluding 0 excluding 1\nfloat rand(vec4 p, float seed){\n    return rand_inclusive(vec2(p.x, p.z) + seed) - 0.5;\n}\n\n// creates white", "\n    return length(p) - r;\n}\n\n// ~~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to radius of sphere\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to radius of sphere\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~~ signed fistance fuction for cone\n// input r1 --> is cone base radius\n// input r2 --> is cone tip radius\n// input h --> is cone height\n// pretty simple, just compare point to radius of sphere\nfloat sdCone(vec3 p, float r1, float r2, float h)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - h;\n    float d2 = max(dot(q, vec2(r2, r2)), q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// ~~~~~~~~ signed fistance fuction for capsule\n// input r1 --> is capsule base radius\n// input r2 --> is capsule tip radius\n// input h --> is capsule height\n// pretty simple, just compare point to radius of sphere\nfloat sdCapsule(vec3 p, float r1, float r2, float h)\n{\n    vec2 d = vec2(length(p.x", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\n//  \n// think of the sphere as a circle in 3d space\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\n// ~~~~~~~~ signed distance function for box\n// input b --> box specs where:\n// \tb.x = box width\n//\tb.y = box height\n//\tb.z = box depth\n//  \n// think of the box as a cube in 3d space\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n// \tc.x = cylinder radius\n//\tc.y = cylinder height\n//  \n// think of the cylinder as a circle in 3d space\nfloat sdCylinder(vec3 p, vec2 c)\n{\n\tfloat d = length(p.xz) - c.x;\n\treturn max(d, abs(p.y) - c.y);\n}\n\n// ~~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n// \tc.x = cone radius\n//\tc.y = cone height\n//  \n// think of the cone as a circle in 3d space\nfloat sdCone(vec3 p, vec2 c)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat d1 = -q.y;\n\tfloat d2 = max(dot(q, q) - c.x * c.x, -q.y);\n\treturn length(max(vec2(d1", "\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / fwidth( d1 + d2), 0.0, 1.0 );\n    return mix( d2, d1, h );\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothness factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / fwidth( d1 + d2 ), 0.0, 1.0 );\n    return mix( d2, d1, smoothstep( 0.0, 1.0, k * h ) );\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothness factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float m )\n{\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / fwidth( d1 + d2 ), 0.0, 1.0 );\n    return mix( d2, d1, smoothstep( 0.0, 1.0, k * h * m ) );\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> smoothness factor\n// output --> smoothed/blended output\nfloat smin( float d1, float", "\n    return min(d1, d2);\n}\n\n// ~~~~~~~~ union, returns the smallest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> smallest distance\nfloat opUnion( float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n// ~~~~~~~~ intersection, returns the biggest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> biggest distance\nfloat opIntersection( float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n// ~~~~~~~~ difference, returns the biggest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> biggest distance\nfloat opDifference( float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\n// ~~~~~~~~ soft union, returns the smallest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> smallest distance\nfloat opSoftUnion( float d1, float d2)\n{\n    return -log2(exp2(-d1) + exp2(-d2));\n}\n\n// ~~~~~~~~ smooth union, returns the smallest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> smallest distance\nfloat opSmoothUnion( float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d1, d2, h) - k * h * (1.0 - h);\n}\n\n// ~~~~~~~~ smooth intersection, returns the biggest distance\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> biggest distance\nfloat opSmoothIntersection( float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 *", "\n\tfloat c = cos(yaw);\n\tfloat s = sin(yaw);\n\tmat2  m = mat2(c, -s, s, c);\n\tvec2  q = vec2(m * p.xz);\n\treturn vec3(q.x, p.y, q.y);\n}\n\n// ~~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t )\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\tmat2  m = mat2(c, -s, s, c);\n\tvec2  q = vec2(m * p.xz);\n\treturn vec3(q.x, p.y, q.y);\n}\n\n// ~~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n\tfloat c = cos(yaw);\n\tfloat s = sin(yaw);\n\tmat2  m = mat2(c, -s, s, c);\n\tvec2  q = vec2(m * p.xz);\n\tp.xz = q;\n\t\n\tc = cos(pitch);\n\ts = sin(pitch);\n\tm = mat2(c, -s, s, c);\n\tq = vec2(m * p.xy);\n\tp.xy = q;\n\t\n\treturn p;\n}\n\n// ~~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist", "\n\treturn (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n\treturn (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opD(vec2 o1, vec2 o2)\n{\n\treturn (o1.x > o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do SmoothUnion / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSU(vec2 o1, vec2 o2)\n{\n\treturn (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do SmoothIntersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSI(vec2 o1, vec2 o2)\n{\n\treturn (o1.x < o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do SmoothDifference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSD(vec2 o1, vec2 o2)\n{\n\treturn (o1.x > o2.x)? o1 : o2;\n}\n\n// ~~~~~~~ do SmoothSubtraction / combine 2 sd objects\n", "\n    // ~~~~~~~~ sphere\n    // sphere(vec3 p, float r)\n    // return vec2(length(p) - r, 0.0);\n\n    // ~~~~~~~~ box\n    // box(vec3 p, vec3 b)\n    // return vec2(max(abs(p.x) - b.x, 0.0) +\n    //              max(abs(p.y) - b.y, 0.0) +\n    //              max(abs(p.z) - b.z, 0.0),\n    //              0.0);\n\n    // ~~~~~~~~ plane\n    // plane(vec3 p, vec3 n, float d)\n    // return vec2(dot(p, n) + d, 0.0);\n\n    // ~~~~~~~~ cylinder\n    // cylinder(vec3 p, float r, float h)\n    // return vec2(length(p.xy - vec2(0.0, h)) - r, 0.0);\n\n    // ~~~~~~~~ cone\n    // cone(vec3 p, float r1, float r2, float h)\n    // return vec2(length(p.xy - vec2(0.0, h)) - r1,\n    //             max(abs(p.z) - r2, 0.0));\n\n    // ~~~~~~~~ torus\n    // torus(vec3 p, float r1, float r2)\n    // return vec2(length(vec2(length(p.xy) - r1, p.z)) - r2, 0.0);\n\n    // ~~~~~~~~ tube\n    // tube(vec3 p, float r, float r2, float h)\n    // return vec2(length(p.xy - vec2(0.0, h)) - r,\n    //             max(abs(p.z) - r2, 0.0));\n\n    // ~~~~~~~~ capsule\n    // capsule(vec3 p, float r, float h)\n    // return vec2(length(p.xy - vec2(0.0, h)) - r,\n    //            ", "\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\tfloat precis = 0.001;\n\tfloat h = precis*2.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\tif( abs(h)<precis || t>tmax ) break;\n\t\tm = map( ro+rd*t );\n\t\th = m*t;\n\t\tt += h;\n\t}\n\tif( t>tmax ) m=-1.0;\n\treturn vec2( t, m );\n}\n\n// ~~~~~~~~ get normal by taking a very small distance,\n//          remapping the function, and getting normal for\n//          that\n//\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// ~~~~~~~~ main function that's automatically run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// screen coordinates (2D)\n\tvec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n\t// camera/view transform\n\tvec3 ro = vec3(0.0, 0.0, 1.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n\t\n\t// raymarch\n\tvec2 p = castRay( ro, rd );\n\tfloat t = p.x;\n\tfloat m = p.y;\n\t\n\t// lighting\n\tvec3 col = vec3", "\n    // ~~~~~~~~ find closest surface\n    float t = 0.0;\n    float t_min = 0.0;\n    float t_max = 1000.0;\n    float t_step = 0.01;\n    float t_prev = 0.0;\n    float t_next = 0.0;\n    float t_hit = 0.0;\n    float t_hit_prev = 0.0;\n    float t_hit_next = 0.0;\n    float t_hit_step = 0.0;\n    float t_hit_step_prev = 0.0;\n    float t_hit_step_next = 0.0;\n    float t_hit_step_prev_prev = 0.0;\n    float t_hit_step_next_next = 0.0;\n    float t_hit_step_prev_next = 0.0;\n    float t_hit_step_next_prev = 0.0;\n    float t_hit_step_prev_prev_prev = 0.0;\n    float t_hit_step_next_next_next = 0.0;\n    float t_hit_step_prev_next_next = 0.0;\n    float t_hit_step_next_prev_next = 0.0;\n    float t_hit_step_prev_prev_next = 0.0;\n    float t_hit_step_next_next_prev = 0.0;\n    float t_hit_step_prev_next_prev = 0.0;\n    float t_hit_step_next_prev_prev = 0.0;\n    float t_hit_step_prev_prev_prev_prev = 0.0;\n    float t_hit_step_next_next_next_next = 0.0;\n    float t_hit_step_prev_next_next_next = 0.0;\n    float t_hit_step_next_prev_next_next = 0.0;\n    float t_hit_step_prev_prev_next_next = 0.0;", "\n    vec3 f = normalize(targetPos - camPos);\n    vec3 r = vec3(sin(roll), cos(roll), 0.0);\n    vec3 u = normalize(cross(f, r));\n    vec3 v = normalize(cross(u, f));\n    return mat3( u, v, -f );\n}\n\n// ~~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up, float roll )\n{\n    vec3 f = normalize(targetPos - camPos);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 v = normalize(cross(f, u));\n    return mat3( u, v, -f );\n}\n\n// ~~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up, float roll, float fov )\n{\n    vec3 f = normalize(targetPos - camPos);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 v = normalize(cross(f, u));\n    return mat3( u, v, -f );\n}\n\n// ~~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 up, float roll, float fov, float aspect )\n{\n    vec3 f = normalize(targetPos - camPos);\n    vec3 r = normalize(cross(", "\n    if(id < 1.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id < 2.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id < 3.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id < 4.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id < 5.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id < 6.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if(id < 7.0)\n    {\n        return vec3(1.0, 0.5, 0.0);\n    }\n    else if(id < 8.0)\n    {\n        return vec3(0.0, 0.5, 1.0);\n    }\n    else if(id < 9.0)\n    {\n        return vec3(0.5, 0.0, 1.0);\n    }\n    else if(id < 10.0)\n    {\n        return vec3(1.0, 0.5, 0.5);\n    }\n    else if(id < 11.0)\n    {\n        return vec3(0.5, 1.0, 0.5);\n    }\n    else if(id < 12.0)\n    {\n        return vec3(0.5, 0.5, 1.0);\n    }\n    else if(id < 13.0)\n    {\n        return vec3(1.0, 1.0, 0.5);\n    }\n    else if(id < 14.0)\n   ", "\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n//  s.x = sphere radius\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// ~~~~~~~~ signed distance function for box\n// input b --> box specs where:\n//  b.x = box width\n//  b.y = box height\n//  b.z = box depth\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// ~~~~~~~~ signed distance function for cylinder\n// input c --> cylinder specs where:\n//  c.x = cylinder radius\n//  c.y = cylinder height\nfloat sdCylinder(vec3 p, vec2 c)\n{\n    float d = length(p.xz) - c.x;\n    d = max(d, abs(p.y) - c.y);\n    return d;\n}\n\n// ~~~~~~~~ signed distance function for cone\n// input c --> cone specs where:\n//  c.x = cone base radius\n//  c.y = cone height\n//  c.z = cone angle (in radians)\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xy);\n    return dot(c, vec2(q, abs(p.z)));\n}\n\n// ~~~~~~~~ signed distance function for plane\n// input p --> plane specs where:\n//  p.x = plane normal\n//  p.y = plane distance\nfloat sdPlane(vec3 p, vec2 pn)\n{\n    return dot(p, vec3(pn.x, pn.y, 0.0));\n}\n\n// ~~~~~~~~ signed distance", "\n    return p.y;\n}\n\n// ~~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size z\n//        ps.z --> size y\n// box extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdBox(vec3 p, vec3 ps)\n{\n    vec3 d = abs(p) - ps;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n// sphere extends indefinately in all directions\nfloat sdSphere(vec3 p, vec3 ps)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\n// cylinder extends indefinately in z direction\nfloat sdCylinder(vec3 p, vec3 ps)\n{\n    float d = length(p.xy) - ps.x;\n    return max(d, abs(p.z) - ps.y);\n}\n\n// ~~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> height\n// cone extends indefinately in z direction\nfloat sdCone(vec3 p, vec3 ps)\n{\n    float q = length(p.xy);\n    return dot(p, vec3(p.x, p.y, ps.y));\n}\n\n// ~~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> thickness\n// torus extends indefinately in z direction\nfloat sdTorus(vec3 p, vec3 ps)\n{\n    vec2 q = vec2(length(p.xz) - ps.x,", "\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nvec2 smin( vec2 d1, vec2 d2, float k)\n{\n    float h = clamp( 0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2( mix( d2.x, d1.x, h ) - k*h*(1.0-h), mix( d2.y, d1.y, h ) - k*h*(1.0-h) );\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nvec3 smin( vec3 d1, vec3 d2, float k)\n{\n    float h = clamp( 0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec3( mix( d2.x, d1.x, h ) - k*h*(1.0-h), mix( d2.y, d1.y, h ) - k*h*(1.0-h), mix( d2.z, d1.z, h ) - k*h*(1.0-h) );\n}\n\n// ~~~~~~~~ smooth minimum function (polynomial version) from iq's page\n", "\n    float d = min(o1.w, o2.w);\n    vec4 c = mix(o1, o2, bf);\n    return vec4(c.rgb, d);\n}\n\n// ~~~~~~~~ union, returns the distance to the closest object\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> distance to the closest object\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opUnion( vec4 o1, vec4 o2)\n{\n    return opBlend(o1, o2, min(o1.w, o2.w));\n}\n\n// ~~~~~~~~ intersection, returns the distance to the farthest object\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> distance to the farthest object\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opIntersection( vec4 o1, vec4 o2)\n{\n    return opBlend(o1, o2, max(o1.w, o2.w));\n}\n\n// ~~~~~~~~ difference, returns the distance to the closest object\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> distance to the closest object\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opDifference( vec4 o1, vec4 o2)\n{\n    return opBlend(o1, o2, max(o1.w, -o2.w));\n}\n\n// ~~~~~~~~ smith, returns the distance to the closest object\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// output --> distance to the closest object\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opSmith( vec4 o1, vec4 o2)\n{\n    return", "\n\treturn max(-d2,d1);\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2)\n{\n\treturn min(d1,d2);\n}\n\n// ~~~~~~~ do shape union, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n\treturn min(d1,-d2);\n}\n\n// ~~~~~~~ do shape xor, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opXor(float d1,float d2)\n{\n\treturn -abs(d1-d2);\n}\n\n// ~~~~~~~ do shape divide, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDivide(float d1,float d2)\n{\n\treturn -abs(d1/d2);\n}\n\n// ~~~~~~~ do shape multiply, cuts d1 out of d2\n// by using  the negative of d1, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opMultiply(float d1,float d2)\n{\n\treturn -abs(d1*d2);\n}\n\n// ~~~~~~~ do shape power, cuts d1 out of d2\n//", "\n\tvec3 lightPos;\n\tlightPos.x = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.y = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.z = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos2()\n{\n\tvec3 lightPos;\n\tlightPos.x = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.y = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.z = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos3()\n{\n\tvec3 lightPos;\n\tlightPos.x = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.y = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\tlightPos.z = (float(rand() % 100) / 100.0f) * 2.0f - 1.0f;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec3 generateLightPos4()\n{\n\tvec3 lightPos;\n", "\n    vec4 res = vec4(0.0);\n    float d = 100000.0;\n    float d2 = 100000.0;\n    float d3 = 100000.0;\n    float d4 = 100000.0;\n    float d5 = 100000.0;\n    float d6 = 100000.0;\n    float d7 = 100000.0;\n    float d8 = 100000.0;\n    float d9 = 100000.0;\n    float d10 = 100000.0;\n    float d11 = 100000.0;\n    float d12 = 100000.0;\n    float d13 = 100000.0;\n    float d14 = 100000.0;\n    float d15 = 100000.0;\n    float d16 = 100000.0;\n    float d17 = 100000.0;\n    float d18 = 100000.0;\n    float d19 = 100000.0;\n    float d20 = 100000.0;\n    float d21 = 100000.0;\n    float d22 = 100000.0;\n    float d23 = 100000.0;\n    float d24 = 100000.0;\n    float d25 = 100000.0;\n    float d26 = 100000.0;\n    float d27 = 100000.0;\n    float d28 = 100000.0;\n    float d29 = 100000.0;\n    float d30 = 100000.0", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float precis = 0.0001;\n    float h = 1.0;\n    float m = -1.0;\n    float n = 0.0;\n    float id = -1.0;\n    float t0 = 0.0;\n    float t1 = 1.0;\n    float t2 = 2.0;\n    float t3 = 3.0;\n    float t4 = 4.0;\n    float t5 = 5.0;\n    float t6 = 6.0;\n    float t7 = 7.0;\n    float t8 = 8.0;\n    float t9 = 9.0;\n    float t10 = 10.0;\n    float t11 = 11.0;\n    float t12 = 12.0;\n    float t13 = 13.0;\n    float t14 = 14.0;\n    float t15 = 15.0;\n    float t16 = 16.0;\n    float t17 = 17.0;\n    float t18 = 18.0;\n    float t19 = 19.0;\n    float t20 = 20.0;\n    float t21 = 21.0;\n    float t22 = 22.0;\n    float t23 = 23.0;\n    float t24 = 24.0;\n    float t25 = 25.0;\n    float t26 = 26.0;\n    float t27 = 27.0;\n    float t28 = 28.0;\n    float t29 = 29.0;\n    float t30 = 30.0;\n    float t31 = 31.0;\n    float t32 = 32.0;\n    float t33 = 33.0;\n   ", "\n    float t = 0.0;\n    float res = 1.0;\n    float k = 0.0;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map_Height(sp + lp * t);\n        k += clamp(0.0, 1.0, -h) * (1.0 - clamp(0.0, 1.0, h));\n        t += clamp(0.0, 1.0, -h) * 0.5;\n        res = min(res, k * 1.2);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    float t = 0.0;\n    float res = 1.0;\n    float k = 0.0;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map_Height(sp + lp * t);\n        k += clamp(0.0, 1.0, -h) * (1.0 - clamp(0.0, 1.0, h));\n        t += clamp(0.0, 1.0, -h) * 0.5;\n        res = min(res, k * 1.2);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www", "\n    float t = 0.0;\n    float t_max = 100.0;\n    float t_step = 0.05;\n    float t_min = 0.0;\n    float t_hit = 0.0;\n    float t_prev = 0.0;\n    float t_next = 0.0;\n    float t_diff = 0.0;\n    float t_diff_prev = 0.0;\n    float t_diff_next = 0.0;\n    float t_diff_avg = 0.0;\n    float t_diff_avg_prev = 0.0;\n    float t_diff_avg_next = 0.0;\n    float t_diff_avg_avg = 0.0;\n    float t_diff_avg_avg_prev = 0.0;\n    float t_diff_avg_avg_next = 0.0;\n    float t_diff_avg_avg_avg = 0.0;\n    float t_diff_avg_avg_avg_prev = 0.0;\n    float t_diff_avg_avg_avg_next = 0.0;\n    float t_diff_avg_avg_avg_avg = 0.0;\n    float t_diff_avg_avg_avg_avg_prev = 0.0;\n    float t_diff_avg_avg_avg_avg_next = 0.0;\n    float t_diff_avg_avg_avg_avg_avg = 0.0;\n    float t_diff_avg_avg_avg_avg_avg_prev = 0.0;\n    float t_diff_avg_avg_avg_avg_avg_next = 0.0;\n    float t_diff_avg_avg_avg_avg_avg_avg = 0.0;\n    float t_diff_avg_avg_avg_avg_avg_", "\n\tvec3 n = vec3(0.0);\n\tfloat w = 0.0;\n\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tvec3 p1 = p + vec3(0.0, 0.0, 0.0);\n\t\tvec3 p2 = p + vec3(0.0, 0.0, 0.0);\n\t\tvec3 p3 = p + vec3(0.0, 0.0, 0.0);\n\t\t\n\t\tif(i == 0)\n\t\t{\n\t\t\tp1 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp2 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp3 = p + vec3(0.0, 0.0, 0.0);\n\t\t}\n\t\telse if(i == 1)\n\t\t{\n\t\t\tp1 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp2 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp3 = p + vec3(0.0, 0.0, 0.0);\n\t\t}\n\t\telse if(i == 2)\n\t\t{\n\t\t\tp1 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp2 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp3 = p + vec3(0.0, 0.0, 0.0);\n\t\t}\n\t\telse if(i == 3)\n\t\t{\n\t\t\tp1 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp2 = p + vec3(0.0, 0.0, 0.0);\n\t\t\tp3 = p + vec3(0.0, 0.0, 0.0);", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n    return pow(c, vec3(1.0 / gamma));\n}\n\n// ~~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, vec3 gamma)\n{\n    return pow(c, gamma);\n}\n\n// ~~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float gamma2)\n{\n    return pow(c, vec3(1.0 / gamma, 1.0 / gamma2, 1.0 / gamma));\n}\n\n// ~~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma, float gamma2, float gamma3)\n{\n    return pow(c, vec3(1.0 / gamma, 1.0 / gamma2, 1.0 / gamma3));\n}\n\n// ~~~~~~~~ do gamma correction\n// from i", "\n    float f = 1.0 / fs.x;\n    float fd = f * d;\n    float fd2 = fd * fd;\n    float fd4 = fd2 * fd2;\n    float fd8 = fd4 * fd4;\n    float fd16 = fd8 * fd8;\n    float fd24 = fd16 * fd8;\n    float fd32 = fd24 * fd8;\n    float fd40 = fd32 * fd8;\n    float fd48 = fd40 * fd8;\n    float fd56 = fd48 * fd8;\n    float fd64 = fd56 * fd8;\n    float fd72 = fd64 * fd8;\n    float fd80 = fd72 * fd8;\n    float fd88 = fd80 * fd8;\n    float fd96 = fd88 * fd8;\n    float fd104 = fd96 * fd8;\n    float fd112 = fd104 * fd8;\n    float fd120 = fd112 * fd8;\n    float fd128 = fd120 * fd8;\n    float fd136 = fd128 * fd8;\n    float fd144 = fd136 * fd8;\n    float fd152 = fd144 * fd8;\n    float fd160 = fd152 * fd8;\n    float fd168 = fd160 * fd8;\n    float fd176 = fd168 * fd8;\n    float fd184 = fd176 * fd8;\n    float fd192 = fd184 * fd8;\n    float fd200 = fd192 * fd8;\n    float fd208 = fd20", "\n\tfloat attn = 1.0;\n\tif (d > 0.0)\n\t{\n\t\tattn = cF + lF * d + qF * d * d;\n\t}\n\treturn attn;\n}\n\n// ~~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist)\n{\n\tfloat attn = 1.0;\n\tif (d > 0.0 && d < maxDist)\n\t{\n\t\tattn = cF + lF * d + qF * d * d;\n\t}\n\treturn attn;\n}\n\n// ~~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist, float minDist)\n{\n\tfloat attn = 1.0;\n\tif (d > 0.0 && d < maxDist && d > minDist)\n\t{\n\t\tattn = cF + lF * d + qF * d * d;\n\t}\n\treturn attn;\n}\n\n// ~~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic", "\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat4 cMatrix)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat4 cMatrix, float zNear, float zFar)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat4 cMatrix, float zNear, float zFar, float aspectRatio)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat4 cMatrix, float zNear, float zFar, float aspectRatio, float fov)\n{\n    vec3 rayDir = cMatrix * vec3(fCoord, 1.0);\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction,", "\n    // ~~~~~~~~ get pixel's march count\n    float marchCount = texture(marchCountTex,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount = texture(itterCountTex,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount2 = texture(marchCountTex2,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount2 = texture(itterCountTex2,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount3 = texture(marchCountTex3,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount3 = texture(itterCountTex3,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount4 = texture(marchCountTex4,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount4 = texture(itterCountTex4,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount5 = texture(marchCountTex5,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount5 = texture(itterCountTex5,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount6 = texture(marchCountTex6,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount6 = texture(itterCountTex6,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount7 = texture(marchCountTex7,fCoord).r;\n    // ~~~~~~~~ get pixel's itteration count\n    float itterCount7 = texture(itterCountTex7,fCoord).r;\n    // ~~~~~~~~ get pixel's march count\n    float marchCount8 = texture(marchCountTex", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.5;\n    uv.x += 0.5;\n    uv.y += 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv.y += 0.5;\n    uv.y *= 1.5;\n    uv.y -= 0.5;\n    uv.y *= -1.0;\n    uv", "\n    vec3 q = abs(p) - radius;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 radius)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - radius;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// cone distance field\nfloat sdCone(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    return dot(q, radius);\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// torus distance field\nfloat sdTorus82(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// cylinder distance field\nfloat sdCylinder6(vec3 p, vec2 radius)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - radius;\n    return min(max(d.x, d.y), 0.0)", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// simple capsule distance field\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// simple cone distance field\nfloat cone(vec3 p, vec3 c, float r1, float r2)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - r1;\n    float d2 = max(r1 - length(q), abs(q.x) - r2);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// simple torus distance field\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// simple tube distance field\nfloat tube(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// simple rounded box distance field\nfloat roundedBox(vec3 p, vec3", "\n\t// The distance to the nearest surface\n\tfloat d = 100000.0;\n\t\n\t// The material number\n\tint mat = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d2 = 100000.0;\n\t\n\t// The material number\n\tint mat2 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d3 = 100000.0;\n\t\n\t// The material number\n\tint mat3 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d4 = 100000.0;\n\t\n\t// The material number\n\tint mat4 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d5 = 100000.0;\n\t\n\t// The material number\n\tint mat5 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d6 = 100000.0;\n\t\n\t// The material number\n\tint mat6 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d7 = 100000.0;\n\t\n\t// The material number\n\tint mat7 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d8 = 100000.0;\n\t\n\t// The material number\n\tint mat8 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d9 = 100000.0;\n\t\n\t// The material number\n\tint mat9 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d10 = 100000.0;\n\t\n\t// The material number\n\tint mat10 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d11 = 100000.0;\n\t\n\t// The material number\n\tint mat11 = 0;\n\t\n\t// The distance to the nearest surface\n\tfloat d12 = 100000.0;", "\n    vec2 z = c;\n    for (int i = 0; i < 5; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 6; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 7; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 8; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 9\nvec2 complexPower9(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < 9; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return z;\n}\n\n//Function that returns a complex number to power of 10\nvec2 complex", "\n\tvec4 color = vec4(0.0);\n\tvec2 pos = coord;\n\tfloat angle = 0.0;\n\tfloat radius = 0.0;\n\tfloat radius2 = 0.0;\n\tfloat radius3 = 0.0;\n\tfloat radius4 = 0.0;\n\tfloat radius5 = 0.0;\n\tfloat radius6 = 0.0;\n\tfloat radius7 = 0.0;\n\tfloat radius8 = 0.0;\n\tfloat radius9 = 0.0;\n\tfloat radius10 = 0.0;\n\tfloat radius11 = 0.0;\n\tfloat radius12 = 0.0;\n\tfloat radius13 = 0.0;\n\tfloat radius14 = 0.0;\n\tfloat radius15 = 0.0;\n\tfloat radius16 = 0.0;\n\tfloat radius17 = 0.0;\n\tfloat radius18 = 0.0;\n\tfloat radius19 = 0.0;\n\tfloat radius20 = 0.0;\n\tfloat radius21 = 0.0;\n\tfloat radius22 = 0.0;\n\tfloat radius23 = 0.0;\n\tfloat radius24 = 0.0;\n\tfloat radius25 = 0.0;\n\tfloat radius26 = 0.0;\n\tfloat radius27 = 0.0;\n\tfloat radius28 = 0.0;\n\tfloat radius29 = 0.0;\n\tfloat radius30 = 0.0;\n\tfloat radius31 = 0.0;\n\tfloat radius32 = 0.0;\n\tfloat radius33 = 0.0;\n\tfloat radius34 = 0.0;\n\tfloat radius35 = 0.0;\n\tfloat radius36 = 0.0;\n\tfloat radius37 = 0.0;\n\tfloat radius38 = 0.0;\n\tfloat radius39 = 0.0;\n\tfloat radius40 = 0.0;\n\tfloat radius41 = 0.0", "\n\tvec4 color = vec4(0.0);\n\tvec2 uv_offset = vec2(0.0);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 uv_offset_i = uv_offset + vec2(i, j) * constant;\n\t\t\tcolor += texture(iChannel0, uv + uv_offset_i);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, float scale)\n{\n\tvec4 color = vec4(0.0);\n\tvec2 uv_offset = vec2(0.0);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 uv_offset_i = uv_offset + vec2(i, j) * constant;\n\t\t\tcolor += texture(iChannel0, uv + uv_offset_i);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, float scale, float scale_x, float scale_y)\n{\n\tvec4 color = vec4(0.0);\n\tvec2 uv_offset = vec2(0.0);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tvec2 uv_offset_i = uv_offset + vec2(i, j) * constant;\n\t\t\tcolor += texture(iChannel0", "\n  return abs(fract(x + 0.5) * 2.0 - 1.0);\n}\n\n// A simple sine wave\nfloat sine(float x) {\n  return sin(x * PI);\n}\n\n// A simple saw wave\nfloat saw(float x) {\n  return 2.0 * abs(fract(x + 0.5) * 2.0 - 1.0) - 1.0;\n}\n\n// A simple square wave\nfloat square(float x) {\n  return step(0.5, fract(x + 0.5) * 2.0);\n}\n\n// A simple triangle wave\nfloat triangle(float x) {\n  return abs(fract(x + 0.5) * 2.0 - 1.0);\n}\n\n// A simple pulse wave\nfloat pulse(float x) {\n  return 0.5 + 0.5 * sin(x * PI);\n}\n\n// A simple noise wave\nfloat noise(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise2(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise3(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise4(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise5(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise6(float x) {\n  return fract(sin(x * PI) * 10000.0);\n}\n\n// A simple noise wave\nfloat noise7(float x) {\n  return fract(sin(x * PI) * 1", "\n    vec2 line = pB - pA;\n    vec2 perp = vec2(-line.y, line.x);\n    vec2 dist = abs(vec2(uv.x * line.x + uv.y * line.y, uv.x * perp.x + uv.y * perp.y)) - thick;\n    float distOnLine = min(max(dist.x, dist.y), 0.0);\n    float distOffLine = max(dist.x, dist.y);\n    float lineRounded = smoothstep(0.0, rounded, abs(dist.x));\n    float lineDashed = step(0.5, mod(distOnLine + dashOn, 1.0));\n    return min(distOffLine, lineRounded * lineDashed);\n}\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float dashOn) {\n    vec2 line = pB - pA;\n    vec2 perp = vec2(-line.y, line.x);\n    vec2 dist = abs(vec2(uv.x * line.x + uv.y * line.y, uv.x * perp.x + uv.y * perp.y)) - thick;\n    float distOnLine = min(max(dist.x, dist.y), 0.0);\n    float distOffLine = max(dist.x, dist.y);\n    float lineRounded = smoothstep(0.0, rounded, abs(dist.x));\n    float lineDashed = step(0.5, mod(dist", "\n    vec2 line = pB - pA;\n    vec2 perp = vec2(-line.y, line.x);\n    vec2 dist = abs(perp * (uv - pA));\n    float t = clamp(dot(perp, line) / dot(line, line), 0.0, 1.0);\n    float d = clamp(length(dist), 0.0, thick.x);\n    float alpha = smoothstep(0.0, thick.y, d);\n    float w = smoothstep(0.0, 1.0 - rounded, t);\n    return alpha * w;\n}\n\n// This makes a filled line in normalized device coordinates. A 1.0 thick line will be 1 pixel thick.\nfloat FillLineNdc(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 line = pB - pA;\n    vec2 perp = vec2(-line.y, line.x);\n    vec2 dist = abs(perp * (uv - pA));\n    float t = clamp(dot(perp, line) / dot(line, line), 0.0, 1.0);\n    float d = clamp(length(dist), 0.0, thick.x);\n    float alpha = smoothstep(0.0, thick.y, d);\n    float w = smoothstep(0.0, 1.0 - rounded, t);\n    return alpha * w;\n}\n\n// This makes a filled line in normalized device coordinates. A 1.0 thick line will be 1 pixel thick.\nfloat FillLineNdc(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    return FillLineNdc(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a filled line in normalized device coordinates. A 1.0 thick line will be 1 pixel thick.\nfloat FillLineNdc(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return FillLineNdc(uv, pA, pB, thick, ", "\n    vec2 p = uv - pA;\n    vec2 v = pB - pA;\n    float angle = atan(v.y, v.x);\n    float d = abs(dot(p, v)) / length(v);\n    float f = smoothstep(rounded - outlineThick, rounded + outlineThick, d);\n    return f * (1.0 - step(0.0, angle));\n}\n\n// This makes an outlined line in normalized device coordinates. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlineNdc(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    vec2 p = uv - pA;\n    vec2 v = pB - pA;\n    float angle = atan(v.y, v.x);\n    float d = abs(dot(p, v)) / length(v);\n    float f = smoothstep(rounded - outlineThick, rounded + outlineThick, d);\n    return f * (1.0 - step(0.0, angle));\n}\n\n// This makes an outlined line in normalized device coordinates. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlineNdc(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded, float outlineThick) {\n    vec2 p = uv - pA;\n    vec2 v = pB - pA;\n    float angle = atan(v.y, v.x);\n    float d = abs(dot(p, v)) / length(v);\n    float f = smoothstep(rounded - outlineThick, rounded + outlineThick, d);\n    return f * (1.0 - step(0.0, angle));\n}\n\n// This makes an outlined line in normalized device coordinates. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlineNdc(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    vec2 p = uv - pA;\n    vec2 v = pB -", "\n    vec2 line = pB - pA;\n    vec2 normal = normalize(vec2(-line.y, line.x));\n    vec2 perp = vec2(-normal.y, normal.x);\n    vec2 dist = abs(perp * (uv - pA));\n    float d = min(dist.x, dist.y);\n    float lineWidth = thick.x + thick.y;\n    float alpha = smoothstep(lineWidth - rounded, lineWidth + rounded, d);\n    return alpha;\n}\n\n// This makes a rectangle in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillRect(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float alpha = 1.0;\n    alpha *= FillLine(uv, pA, pB, thick, rounded);\n    alpha *= FillLine(uv, pA + vec2(0.0, thick.y), pB + vec2(0.0, thick.y), thick, rounded);\n    alpha *= FillLine(uv, pA + vec2(thick.x, 0.0), pB + vec2(thick.x, 0.0), thick, rounded);\n    alpha *= FillLine(uv, pA + vec2(0.0, 0.0), pB + vec2(0.0, 0.0), thick, rounded);\n    return alpha;\n}\n\n// This makes a rounded rectangle in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillRoundedRect(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float radius) {\n    float alpha = 1.0;\n    alpha *= FillLine(uv, pA, pB, thick, radius);\n    alpha *= FillLine(uv, pA + vec2(0.0, thick.y), pB + vec2(0.0, thick.y), thick, radius);\n    alpha *= FillLine(uv, pA + vec2(thick.x", "\n    vec2 line = pB - pA;\n    vec2 perp = vec2(-line.y, line.x);\n    vec2 dist = uv - pA;\n    float distPerp = dot(dist, perp);\n    float distLine = dot(dist, line);\n    float distLineAbs = abs(distLine);\n    float distLineSign = sign(distLine);\n    float distLineClamp = clamp(distLine, 0.0, length(line));\n    float distLineNorm = distLineClamp / length(line);\n    float distLineNormRounded = round(distLineNorm * (rounded + 1.0)) / (rounded + 1.0);\n    float distLineNormRoundedSign = sign(distLineNormRounded);\n    float distLineNormRoundedClamp = clamp(distLineNormRounded, 0.0, 1.0);\n    float distLineNormRoundedClampSign = sign(distLineNormRoundedClamp);\n    float distLineNormRoundedClampAbs = abs(distLineNormRoundedClamp);\n    float distLineNormRoundedClampAbsSign = sign(distLineNormRoundedClampAbs);\n    float distLineNormRoundedClampAbsClamp = clamp(distLineNormRoundedClampAbs, 0.0, 1.0);\n    float distLineNormRoundedClampAbsClampSign = sign(distLineNormRoundedClampAbsClamp);\n    float distLineNormRoundedClampAbsClampClamp = clamp(distLineNormRoundedClampAbsClamp, 0.0, 1.0);\n    float distLineNormRoundedClampAbsClampClampSign = sign(distLineNormRoundedClampAbsClampClamp);\n    float distLineNormRoundedClampAbsClampClampClamp = clamp(distLineNormRoundedClampAbsClampClamp, 0.0, 1.0);\n    float distLineNormRoundedClampAbsCl", "\n    vec2 p = uv - pA;\n    vec2 v = pB - pA;\n    float d = abs(dot(p, normalize(v)));\n    float r = length(v);\n    float a = atan(v.y, v.x);\n    float pa = atan(p.y, p.x);\n    float af = a - pa;\n    float raf = rounded / r;\n    float afi = floor(af / raf + 0.5);\n    float afc = cos(afi * raf - af);\n    float w = min(d, min(d - r * (1.0 - afc), r * (1.0 - afc) - d));\n    return smoothstep(0.5 - outlineThick, 0.5 + outlineThick, w);\n}\n\n// This makes a rounded rectangle in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawRoundedRect(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    vec2 p = uv - pA;\n    vec2 v = pB - pA;\n    float d = abs(dot(p, normalize(v)));\n    float r = length(v);\n    float a = atan(v.y, v.x);\n    float pa = atan(p.y, p.x);\n    float af = a - pa;\n    float raf = rounded / r;\n    float afi = floor(af / raf + 0.5);\n    float afc = cos(afi * raf - af);\n    float w = min(d, min(d - r * (1.0 - afc), r * (1.0 - afc) - d));\n    return smoothstep(0.5 - thick.x, 0.5 + thick.x, w);\n}\n\n// This makes a rounded rectangle in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawRoundedRect(vec2 uv, vec2 pA, vec2 pB, vec2 thick,", "\n    float d = length(p - uv);\n    col = mix(col, vec3(1.0), smoothstep(0.0, 0.01, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 col = vec3(0.0);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position.", "\n    float h = dot( ro - cen, nor );\n    float a = dot( rd, nor );\n    float b = dot( ro - cen, rd );\n    float c = h*h - b*b;\n    float d = b*b - a*rad;\n    if( d < 0.0 ) return -1.0;\n    return max( -h - sqrt( d ), 0.0 );\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 sp, float sr )\n{\n    vec3 oc = ro - sp;\n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sr*sr;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 plane )\n{\n    float denom = dot( plane.xyz, rd );\n    if( abs(denom) < 0.0001 ) return -1.0;\n    return -( dot( plane.xyz, ro ) + plane.w ) / denom;\n}\n\n// ray-box intersection\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 box )\n{\n    vec3 m = vec3( 1.0 ) / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * box;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    float t1m = max( max( tmin.x, tmin.y ), tmin.z );\n    float t2m = min( min( tmax.x, tmax.y ), tmax.z );\n    return max( t1m, t2m );\n}\n\n// ray-cylinder intersection", "\n    vec3 m = rad - (ro-cen);\n    vec3 n = 1.0/rd;\n    vec3 k = abs(n);\n    vec3 t1 = -m*n + k;\n    vec3 t2 = -m*n - k;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    float t0 = max( max( tmin.x, tmin.y ), tmin.z );\n    float t1 = min( min( tmax.x, tmax.y ), tmax.z );\n    return vec2( t0, t1 );\n}\n\n// ray-sphere intersection (simplified)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt(h);\n    return vec2( -b - h, -b + h );\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 n ) \n{\n    float denom = dot( n.xyz, rd );\n    if( abs(denom)<0.0001 ) return vec2(-1.0); // no intersection\n    float t = -(dot( n.xyz, ro ) + n.w) / denom;\n    return vec2( t, t );\n}\n\n// ray-cylinder intersection\nvec2 iCylinder( in vec3 ro, in vec3 rd, in vec2 cen, in float rad ) \n{\n    vec2 h = vec2( clamp( (ro.x-cen.x)*rd.x,-1.0,1.0 ), clamp( (ro.z-cen.y)*rd.z,-1.0,1.0 ) );\n   ", "\n    vec3 ba = pb - pa;\n    float h = length(ba);\n    float r = ra;\n    float d = min(h, r);\n    float r2 = r*r;\n    float h2 = h*h;\n    float d2 = d*d;\n    float a = r2 - h2;\n    float b = 2.0*d*r;\n    float c = r2 - d2;\n    float d1 = b*b - 4.0*a*c;\n    float d2a = sqrt(d1);\n    float d2b = -sqrt(d1);\n    float d3 = 2.0*a;\n    float d4 = b + d2a;\n    float d5 = b + d2b;\n    float d6 = b - d2a;\n    float d7 = b - d2b;\n    float d8 = a*d4 - d3*d5;\n    float d9 = a*d6 - d3*d7;\n    float d10 = a*d5 - d3*d4;\n    float d11 = a*d7 - d3*d6;\n    float d12 = a*d4 - d3*d4;\n    float d13 = a*d5 - d3*d5;\n    float d14 = a*d6 - d3*d6;\n    float d15 = a*d7 - d3*d7;\n    float d16 = d4*d4 - d2a*d4;\n    float d17 = d5*d5 - d2a*d5;\n    float d18 = d6*d6 - d2a*d6;\n    float d19 = d7*d7 - d2a*d7;\n    float d20 = d4*d4 - d2b*d4;\n    float d21 = d5*d5 - d2b*d5;\n    float d22 = d6*d6 - d2b*d6;\n    float d23 = d7*d7 - d2b*d7;", "\n    vec3  u = normalize( pb - pa );\n    float h = dot( ro - pa, u );\n    float a = dot( rd, u );\n    float k = ra*ra - dot( ro - pa - u*h, ro - pa - u*h );\n    if( k < 0.0 ) return vec4( 0.0 );\n    float d = h*h - k;\n    if( d < 0.0 ) return vec4( 0.0 );\n    d = -h - sqrt( d );\n    if( d < 0.0 ) return vec4( 0.0 );\n    return vec4( d, u );\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec4 n ) // normal\n{\n    float d = dot( ro, n.xyz ) + n.w;\n    float t = -d / dot( rd, n.xyz );\n    return vec4( t, n );\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec4 s ) // sphere: (center x,y,z, radius)\n{\n    vec3  oc = ro - s.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - s.w*s.w;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec4( 0.0 );\n    h = -b - sqrt( h );\n    if( h < 0.0 ) return vec4( 0.0 );\n    return vec4( h, normalize( ro + h*rd - s.xyz ) );\n}\n\n// ray-triangle intersection test (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3  e1 = v1 - v0;\n    vec3  e2 = v2 - v0", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    vec2 res = vec2( tmin.x, tmax.x );\n    res.x = max( res.x, tmin.y );\n    res.x = max( res.x, tmin.z );\n    res.y = min( res.y, tmax.y );\n    res.y = min( res.y, tmax.z );\n    return res;\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 sp, in float sr )\n{\n    vec3 oc = ro - sp;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sr*sr;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// ray-plane intersection\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 n )\n{\n    return (-n.w - dot(ro,n.xyz)) / dot(rd,n.xyz);\n}\n\n// ray-cylinder intersection\nvec2 iCylinder( in vec3 ro, in vec3 rd, in vec2 c )\n{\n    vec2 h = vec2( c.x, c.y*0.5 );\n    vec2 uv = vec2( length(rd.xy), rd.z );\n    vec2 d = abs(vec2( dot(rd.xy,rd.xy), rd.z ))*h;\n    vec2 s = sign(rd.xy);\n    vec2 q = (s.yx*rd.xy-s.xy*", "\n    vec3  m = pa - ro;\n    float b = dot( m, rd );\n    float c = dot( m, m ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return max( -b - h, -b + h );\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  m = pa - ro;\n    float b = dot( m, rd );\n    float c = dot( m, m ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return max( -b - h, -b + h );\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb, out float h )\n{\n    vec3  m = pa - ro;\n    float b = dot( m, rd );\n    float c = dot( m, m ) - ra*ra;\n    h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return max( -b - h, -b + h );\n}\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb, out float h, out float d )\n{\n    vec3  m = pa - ro;\n    float b", "\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float h2 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float h2, in float h3 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float h2, in float h3, in float h4 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float h2, in float h3, in float h4, in float h5 )\n{\n    vec3 n = normalize( cross( a - pos, b - pos ) );\n    return normalize( n + r * normalize( pos - a ) );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h, in float h2, in float h", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    vec2 t = max( tmin.xx, tmin.yz );\n    t = min( t, tmax.xx );\n    t = max( t, tmin.yz );\n    t.x = max( t.x, t.y );\n    return t;\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in mat4 model ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*vec3( model * vec4( ro, 1.0 ) );\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    vec2 t = max( tmin.xx, tmin.yz );\n    t = min( t, tmax.xx );\n    t = max( t, tmin.yz );\n    t.x = max( t.x, t.y );\n    return t;\n}\n\n// ray-sphere intersection in world space\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) \n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2( -1.0 );\n    h = sqrt( h );\n    return vec2( -b - h, -b + h );\n}\n\n// ray", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 100.0;\n    float precis = 0.0001;\n    float h = precis*2.0;\n    float res = -1.0;\n    for( int i=0; i<32; i++ )\n    {\n        if( abs(h)<precis || t>tmax ) break;\n        h = map( ro+rd*t );\n        t += h;\n    }\n    if( t>tmax ) res = -1.0;\n    else res = t;\n    return vec4( res, tmin, tmax, h );\n}\n\n// raymarch\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4( 1.0, 0.0, 0.0, 0.0 );\n    vec4 h = interesect( ro, rd );\n    if( h.x>-0.5 )\n    {\n        res.x = 0.0;\n        res.yzw = h.yzw;\n    }\n    return res;\n}\n\n// main\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec2 mo = m - 0.5;\n    mo.x *= iResolution.x/iResolution.y;\n    vec2 mt = mo * 2.0;\n    vec2 mp = mo * 0.5;\n    vec2 mr = mo * 0.25;\n    vec2 ms = mo * 0.125;\n    vec2 mb = mo * 0.0625;\n    vec2 ml = mo * 0.03125;\n    vec2 mt2 = mo * 0.015625;\n    vec2 mt3 = mo * 0.0078125;\n    vec2 mt4 = mo *", "\n    float phi = 2.0 * PI * i / n;\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return vec3(cos_phi, sin_phi, sqrt(1.0 - cos_phi * cos_phi));\n}\n\n// inverse of forwardSF\nvec3 inverseSF( vec3 p )\n{\n    float phi = atan(p.y, p.x);\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    float r = sqrt(1.0 - cos_phi * cos_phi);\n    return vec3(phi, r, cos_phi);\n}\n\n// convert from spherical to cartesian\nvec3 sphericalToCartesian(vec3 p)\n{\n    return vec3(p.x * p.z, p.y, p.x * p.y);\n}\n\n// convert from cartesian to spherical\nvec3 cartesianToSpherical(vec3 p)\n{\n    return vec3(length(p), atan(p.y, p.x), atan(p.z, length(p)));\n}\n\n// convert from cartesian to spherical\nvec3 cartesianToSpherical(vec2 p)\n{\n    return vec3(length(p), atan(p.y, p.x), atan(0.0, length(p)));\n}\n\n// convert from spherical to cartesian\nvec2 sphericalToCartesian(vec3 p)\n{\n    return vec2(p.x * p.y, p.x * p.z);\n}\n\n// convert from cartesian to spherical\nvec2 cartesianToSpherical(vec2 p)\n{\n    return vec2(length(p), atan(p.y, p.x));\n}\n\n// convert from cartesian to spherical\nvec2 cartesianToSpherical(vec3 p)\n{\n    return vec2(length(p.xy), atan(p.y, p.x));\n}\n\n// convert from cartesian to spherical\nvec2 cartesianToSpherical(vec4 p)\n", "\n    vec4 res = vec4( 0.0, 0.0, 0.0, 0.0 );\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float precis = 0.0001;\n    float h = 1.0;\n    float tprev = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs( h )<precis || t>tmax ) break;\n        tprev = t;\n        resS = mat3( 1.0 );\n        res = map( ro+rd*t, resS );\n        h = res.x;\n        t += h;\n        tmin = max( tmin, t );\n        tmax = min( tmax, t );\n    }\n    if( t<tmax )\n    {\n        return vec4( t, tprev, tmin, tmax );\n    }\n    return vec4( -1.0, -1.0, -1.0, -1.0 );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd, out mat3 resS )\n{\n    vec4 res = vec4( 0.0, 0.0, 0.0, 0.0 );\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float precis = 0.0001;\n    float h = 1.0;\n    float tprev = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs( h )<precis || t>tmax ) break;\n        tprev = t;\n        resS = mat3( 1.0 );\n        res = map( ro+rd*t, resS );\n        h = res.x;\n        t += h;\n        tmin = max( tmin, t );\n        tmax = min(", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = hash( i );\n    float b = hash( i + vec2( 1.0, 0.0 ) );\n    float c = hash( i + vec2( 0.0, 1.0 ) );\n    float d = hash( i + vec2( 1.0, 1.0 ) );\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3( mix( mix( a, b, smoothstep( 0.0, 1.0, f.x ) ),\n    //                    mix( c, d, smoothstep( 0.0, 1.0, f.x ) ),\n    //                    smoothstep( 0.0, 1.0, f.y ) ) );\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return vec3( mix( mix( a, b, u.x ), mix( c, d, u.x ), u.y ) );\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = hash( i );\n    float b = hash( i + vec3( 1.0, 0.0, 0.0 ) );\n    float c = hash( i + vec3( 0.0, 1.0, 0.0 ) );\n    float d = hash( i + vec3( 1.0, 1.0, 0.0 ) );\n    float e = hash( i + vec3( 0.0, 0.0, 1.0 ) );\n    float f = hash( i + vec3( 1.0, 0.0, 1.", "\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - radius;\n}\n\nfloat boxDist(vec3 p, vec3 size, float radius)\n{\n    vec3 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0) - radius;\n}\n\nfloat sphereDist(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat torusDist(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat cylinderDist(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat cylinderDist(vec3 p, float r, float h)\n{\n    return length(vec2(length(p.xz) - r, p.y)) - h;\n}\n\nfloat capsuleDist(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat capsuleDist(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 ma = pa - ba * h;\n    if (length(ma)", "\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float f = fract(a / (PI * 2.0) + 0.5);\n    float c = cos(f * PI * 2.0);\n    float s = sin(f * PI * 2.0);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n    p *= r;\n    p += 0.5;\n    p -= 0.5;\n    p *= 2.0;\n    p.x *= orient.x;\n    p.y *= orient.y;\n    return p;\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float f = fract(a / (PI * 2.0) + 0.5);\n    float c = cos(f * PI * 2.0);\n    float s = sin(f * PI * 2.0);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n    p *= r;\n    p += 0.5;\n    p -= 0.5;\n    p *= 2.0;\n    p.x *= orient.x;\n    p.y *= orient.y;\n    return p;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float f = fract(a / (PI * 2.0) + 0.5);\n    float c = cos(f * PI * 2", "\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= aspect;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = floor(a / PI * 2.0);\n    float m = mod(a / PI * 2.0, 1.0);\n    float c = cos(PI * m);\n    float s = sin(PI * m);\n    mat2 m2 = mat2(c, -s, s, c);\n    p = m2 * p;\n    p *= r;\n    p += vec2(0.0, 0.0);\n    p.x *= aspect;\n    p.y += 0.0;\n    p.x += 0.0;\n    return vec3(p, f);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= aspect;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = floor(a / PI * 2.0);\n    float m = mod(a / PI * 2.0, 1.0);\n    float c = cos(PI * m);\n    float s = sin(PI * m);\n    mat2 m2 = mat2(c, -s, s, c);\n    p = m2 * p;\n    p *= r;\n    p += vec2(0.0, 0.0);\n    p.x *= aspect;\n    p.y += 0.0;\n    p.x += 0.0;\n    return vec3(p, f);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= aspect;\n    float a = atan(p.y, p.x);\n    float r = length", "\n    vec2 g = floor(p + 0.5);\n    vec2 f = fract(p + 0.5);\n    vec2 m = max(ddx, ddy);\n    vec2 m2 = m*m;\n    vec2 g2 = g*g;\n    vec2 p2 = p*p;\n    float r = 0.0;\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5 * (1.0 - m2.x) * (1.0 - m2.y) * (1.0 - p2.x) * (1.0 - p2.y);\n    r += 0.5", "\n    vec3 d = vec3( 0.0 );\n    d.x = dmap( p.x );\n    d.y = dmap( p.y );\n    d.z = dmap( p.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap( p.x, n.x );\n    d.y = dmap( p.y, n.y );\n    d.z = dmap( p.z, n.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 uvw )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap( p.x, n.x, uvw.x );\n    d.y = dmap( p.y, n.y, uvw.y );\n    d.z = dmap( p.z, n.z, uvw.z );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 uvw, in float f )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap( p.x, n.x, uvw.x, f );\n    d.y = dmap( p.y, n.y, uvw.y, f );\n    d.z = dmap( p.z, n.z, uvw.z, f );\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 uvw, in float f, in float g )\n{\n    vec3 d = vec3( 0.0 );\n    d.x = dmap( p.x, n.", "\n\tv33 c;\n\tc.x=a.x*b.x.x+a.y*b.x.y+a.z*b.x.z;\n\tc.y=a.x*b.y.x+a.y*b.y.y+a.z*b.y.z;\n\tc.z=a.x*b.z.x+a.y*b.z.y+a.z*b.z.z;\n\ta=c;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c){\n\tv33 d;\n\td.x=a.x*b.x.x+a.y*b.x.y+a.z*b.x.z;\n\td.y=a.x*b.y.x+a.y*b.y.y+a.z*b.y.z;\n\td.z=a.x*b.z.x+a.y*b.z.y+a.z*b.z.z;\n\ta=d;\n\td.x=a.x*c.x.x+a.y*c.x.y+a.z*c.x.z;\n\td.y=a.x*c.y.x+a.y*c.y.y+a.z*c.y.z;\n\td.z=a.x*c.z.x+a.y*c.z.y+a.z*c.z.z;\n\ta=d;\n}\n\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c,inout v33 d){\n\tv33 e;\n\te.x=a.x*b.x.x+a.y*b.x.y+a.z*b.x.z;\n\t", "\n\treturn v33(a.b-b,a.a-b);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(vec3 a,v33 b){\n\treturn v33(a-b.b,a-b.a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b){\n\treturn v33(a.b-b.b,a.a-b.a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c){\n\treturn v33(a.b-b.b-c.b,a.a-b.a-c.a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,v33 d){\n\treturn v33(a.b-b.b-c.b-d.b,a.a-b.a-c.a-d.a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn v33(a.b-b.b-c.b-d.b-e.b,a.a-b.a-c.a-d.a-e.a);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn v33(a.b-b.b-c.b-d.b-e.b-f.b,a.a-b.a-c.a-d.a-e.a-", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,float b){\n\tv33 c;\n\tc.x=a.x-b;\n\tc.y=a.y-b;\n\tc.z=a.z-b;\n\treturn c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(float a,v33 b){\n\tv33 c;\n\tc.x=a-b.x;\n\tc.y=a-b.y;\n\tc.z=a-b.z;\n\treturn c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(float a,float b){\n\tv33 c;\n\tc.x=a-b;\n\tc.y=a-b;\n\tc.z=a-b;\n\treturn c;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b,v33 c){\n\tv33 d;\n\td.x=a.x-b.x-c.x;\n\td.y=a.y-b.y-c.y;\n\td.z=a.z-b.z-c.z;\n\treturn d;\n}\n\n//substract b from all ray components\n//component wise ray substraction(this one", "return vec2(a.x-b.x,a.y-b.y);}\nvec2 dp(v33 a,v33 b){return vec2(a.z-b.z,a.w-b.w);}\nvec2 dp(v33 a,v33 b,v33 c){return vec2(a.z-b.z,a.w-b.w)-vec2(b.z-c.z,b.w-c.w);}\nvec2 dp(v33 a,v33 b,v33 c,v33 d){return vec2(a.z-b.z,a.w-b.w)-vec2(b.z-c.z,b.w-c.w)-vec2(c.z-d.z,c.w-d.w);}\nvec2 dp(v33 a,v33 b,v33 c,v33 d,v33 e){return vec2(a.z-b.z,a.w-b.w)-vec2(b.z-c.z,b.w-c.w)-vec2(c.z-d.z,c.w-d.w)-vec2(d.z-e.z,d.w-e.w);}\nvec2 dp(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){return vec2(a.z-b.z,a.w-b.w)-vec2(b.z-c.z,b.w-c.w)-vec2(c.z-d.z,c.w-d.w)-vec2(d.z-e.z,d.w-e.w)-vec2(e.z-f.z,e.w-f.w);}\nvec2 dp(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){return vec2(a.z-b.z,a.w-b.w)-vec2(b.", "\n\treturn vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n\treturn vec2(dot(a.xy,b.xy),dot(a.zw,b.zw));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n\treturn vec2(dot(a.xy,b.xy),dot(a.zw,b.zw))+vec2(dot(a.xy,c.xy),dot(a.zw,c.zw));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n\treturn vec2(dot(a.xy,b.xy),dot(a.zw,b.zw))+vec2(dot(a.xy,c.xy),dot(a.zw,c.zw))+vec2(dot(a.xy,d.xy),dot(a.zw,d.zw));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n\treturn vec2(dot(a.xy,b.xy),dot(a.zw,b.zw))+vec2(dot(a.xy,c.xy),dot(a.zw,c.zw))+vec2(dot(a.xy,d.xy),dot(a.zw,d.zw))+vec2(dot(a.xy,e.xy),dot(a.zw,e.zw));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n\treturn vec2(dot(a.xy,b.xy),dot(a.zw,b.zw))+vec2(dot(a.xy,c", "\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.w*b.x,a.v*b.x,a.u*b.x,a.t*b.x,a.s*b.x,a.r*b.x,a.q*b.x,a.p*b.x,a.o*b.x,a.n*b.x,a.m*b.x,a.l*b.x,a.k*b.x,a.j*b.x,a.i*b.x,a.h*b.x,a.g*b.x,a.f*b.x,a.e*b.x,a.d*b.x,a.c*b.x,a.b*b.x,a.a*b.x);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.w*b.x,a.v*b.x,a.u*b.x,a.t*b.x,a.s*b.x,a.r*b.x,a.q*b.x,a.p*b.x,a.o*b.x,a.n*b.x,a.m*b.x,a.l*b.x,a.k*b.x,a.j*b.x,a.i*b.x,a.h*b.x,a.g*b.x,a.f*b.x,a.e*b.x,a.d*b.x,a.c*b.x,a.b*b.x,a.a*b.x);\n}\n\n//dual mult\nv33 mul(v33 a,vec4 b){\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.w*b", "\n\tvec3 q=abs(p);\n\tvec3 r=q-2.0*min(q.x,min(q.y,q.z))+vec3(0.0,0.0,0.0);\n\tvec2 s=max(dot(w,r.xyz-w.xyz),0.0);\n\treturn 0.5+0.5*cos(6.28318530718*s);\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,float s){\n\tvec3 q=abs(p);\n\tvec3 r=q-2.0*min(q.x,min(q.y,q.z))+vec3(0.0,0.0,0.0);\n\tvec2 t=max(dot(w,r.xyz-w.xyz),0.0);\n\treturn 0.5+0.5*cos(6.28318530718*s*t);\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,float s,float t){\n\tvec3 q=abs(p);\n\tvec3 r=q-2.0*min(q.x,min(q.y,q.z))+vec3(0.0,0.0,0.0);\n\tvec2 u=max(dot(w,r.xyz-w.xyz),0.0);\n\treturn 0.5+0.5*cos(6.28318530718*s*t*u);\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,float s,float t,float u){\n\tvec3 q=abs(p);\n\tvec3 r=q-2.0*min(q.x,min(q.y,q.z))+vec3", "\n\tvec3 q=abs(p);\n\tfloat r=max(max(q.x,q.y),q.z);\n\tfloat s=max(max(abs(p.x+p.y),abs(p.x+p.z)),max(abs(p.y+p.z),abs(p.x+p.y+p.z)));\n\treturn max(0.0,1.0-s/r);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF4(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat r=max(max(q.x,q.y),q.z);\n\tfloat s=max(max(abs(p.x+p.y),abs(p.x+p.z)),max(abs(p.y+p.z),abs(p.x+p.y+p.z)));\n\treturn max(0.0,1.0-s/r);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF5(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat r=max(max(q.x,q.y),q.z);\n\tfloat s=max(max(abs(p.x+p.y),abs(p.x+p.z)),max(abs(p.y+p.z),abs(p.x+p.y+p.z)));\n\treturn max(0.0,1.0-s/r);\n}\n\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF6(vec3 p,vec3 w){\n\tvec3 q=abs(p);\n\tfloat r=max(max(q.x,q.y", "\n\tfloat b=dot(r.xyz,s.xyz);\n\tfloat c=dot(r.xyz,r.xyz)-s.w*s.w;\n\tfloat d=b*b-c;\n\tif(d<0.)return 1.;\n\treturn clamp(0.,1.,(b-sqrt(d))/s.w);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat b=dot(r.xyz,s.xyz);\n\tfloat c=dot(r.xyz,r.xyz)-s.w*s.w;\n\tfloat d=b*b-c;\n\tif(d<0.)return 1.;\n\treturn clamp(0.,1.,(b-sqrt(d))/s.w);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat b=dot(r.xyz,s.xyz);\n\tfloat c=dot(r.xyz,r.xyz)-s.w*s.w;\n\tfloat d=b*b-c;\n\tif(d<0.)return 1.;\n\treturn clamp(0.,1.,(b-sqrt(d))/s.w);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat b=dot(r.xyz,s.xyz);\n\tfloat c=dot(r.xyz,r.xyz)-s.w*s.w;\n\tfloat d=b*b-c;\n\tif(d<0.)return 1.;\n\treturn clamp(0.,1.,(b-sqrt(d))/s.w);\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){\n\tfloat b=dot(r.xyz,s.xyz);\n\tfloat c=dot(r.xyz,r.xyz)-s.w*s.w;\n\tfloat d=b*b-c;\n\tif", "\n    float d = length(u-s.xyz)-s.w;\n    return smoothstep(0.0,1.0,d/s.w);\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n    float d = length(u-s.xyz)-s.w;\n    return smoothstep(0.0,1.0,d/s.w);\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 s){\n    float d = dot(u-s.xyz,n);\n    return smoothstep(0.0,1.0,d/s.w);\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 s){\n    vec3 d = abs(u-s.xyz)-s.w;\n    return smoothstep(0.0,1.0,min(max(d.x,max(d.y,d.z)),0.0));\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 s){\n    vec2 d = vec2(length(u.xy-s.xy)-s.x,length(u.xy)-s.z);\n    return smoothstep(0.0,1.0,d.x/d.y);\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 s){\n    float d = length(u-s.xyz)-s.w;\n    return smoothstep(0.0,1.0,d/s.w);\n}\n\n//torusKnot occlusion\nfloat occTorusKnot(vec3 u,vec3 n,vec4 s){\n    vec2 d = vec2(length(u.xy-s.xy)-s.x,length(u.xy)-s.z);\n    return smoothstep(0.0,1.0,d.x/d.y);\n}\n\n//disc occlusion\nfloat occDisc(vec3 u,vec3 n,vec4 s){\n    float", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p012 = p12 - p01;\n    vec2 p012_2 = p012 * 2.0;\n    vec2 p012_3 = p012 * 3.0;\n    vec2 p012_6 = p012 * 6.0;\n    vec2 p012_12 = p012 * 12.0;\n    vec2 p012_24 = p012 * 24.0;\n    vec2 p012_36 = p012 * 36.0;\n    vec2 p012_48 = p012 * 48.0;\n    vec2 p012_60 = p012 * 60.0;\n    vec2 p012_72 = p012 * 72.0;\n    vec2 p012_84 = p012 * 84.0;\n    vec2 p012_96 = p012 * 96.0;\n    vec2 p012_108 = p012 * 108.0;\n    vec2 p012_120 = p012 * 120.0;\n    vec2 p012_132 = p012 * 132.0;\n    vec2 p012_144 = p012 * 144.0;\n    vec2 p012_156 = p012 * 156.0;\n    vec2 p012_168 = p012 * 168.0;\n    vec2 p012_180 = p012 * 180.0;\n    vec2 p012_192 = p012 * 192.0;\n    vec2 p012_204 = p012 * 2", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p012 = p12 - p01;\n    vec2 p012_2 = p012 * 2.0;\n    vec2 p012_3 = p012 * 3.0;\n    vec2 p012_6 = p012 * 6.0;\n    vec2 p012_12 = p012 * 12.0;\n    vec2 p012_24 = p012 * 24.0;\n    vec2 p012_36 = p012 * 36.0;\n    vec2 p012_48 = p012 * 48.0;\n    vec2 p012_60 = p012 * 60.0;\n    vec2 p012_72 = p012 * 72.0;\n    vec2 p012_84 = p012 * 84.0;\n    vec2 p012_96 = p012 * 96.0;\n    vec2 p012_108 = p012 * 108.0;\n    vec2 p012_120 = p012 * 120.0;\n    vec2 p012_132 = p012 * 132.0;\n    vec2 p012_144 = p012 * 144.0;\n    vec2 p012_156 = p012 * 156.0;\n    vec2 p012_168 = p012 * 168.0;\n    vec2 p012_180 = p012 * 180.0;\n    vec2 p012_192 = p012 * 192.0;\n    vec2 p012_204 = p012 * 2", "\n    vec3 bmin = min(p0, min(p1, min(p2, p3)));\n    vec3 bmax = max(p0, max(p1, max(p2, p3)));\n    return bound3(bmin, bmax);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 bmin = min(p0, min(p1, min(p2, p3)));\n    vec3 bmax = max(p0, max(p1, max(p2, p3)));\n    return bound3(bmin, bmax);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4 )\n{\n    vec3 bmin = min(p0, min(p1, min(p2, min(p3, p4))));\n    vec3 bmax = max(p0, max(p1, max(p2, max(p3, p4))));\n    return bound3(bmin, bmax);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in float t )\n{\n    vec3 bmin = min(p0, min(p1, min(p2, min(p3,", "\n    vec2 p01 = (p0 + p1) * 0.5;\n    vec2 p12 = (p1 + p2) * 0.5;\n    vec2 p23 = (p2 + p3) * 0.5;\n    vec2 p012 = (p01 + p12) * 0.5;\n    vec2 p123 = (p12 + p23) * 0.5;\n    vec2 p0123 = (p012 + p123) * 0.5;\n\n    vec2 p0123_ = (p0123 + p0123) * 0.5;\n\n    vec2 p0123_2 = (p0123_ + p0123_) * 0.5;\n\n    vec2 p0123_4 = (p0123_2 + p0123_2) * 0.5;\n\n    vec2 p0123_8 = (p0123_4 + p0123_4) * 0.5;\n\n    vec2 p0123_16 = (p0123_8 + p0123_8) * 0.5;\n\n    vec2 p0123_32 = (p0123_16 + p0123_16) * 0.5;\n\n    vec2 p0123_64 = (p0123_32 + p0123_32) * 0.5;\n\n    vec2 p0123_128 = (p0123_64 + p0123_64) * 0.5;\n\n    vec2 p0123_256 = (p0123_128 + p0123_128) * 0.5;\n\n    vec2 p0123_512 = (p0123_256 + p0123_256) * 0.5", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p1;\n    vec2 c = p3 - p2;\n    vec2 d = p0 - p1 - a;\n    vec2 e = p2 - p0 - a - b;\n    vec2 f = pos - p0;\n\n    float a2 = dot(a, a);\n    float b2 = dot(b, b);\n    float c2 = dot(c, c);\n    float d2 = dot(d, d);\n    float e2 = dot(e, e);\n    float f2 = dot(f, f);\n\n    float a3 = dot(a, a2);\n    float b3 = dot(b, b2);\n    float c3 = dot(c, c2);\n    float d3 = dot(d, d2);\n    float e3 = dot(e, e2);\n    float f3 = dot(f, f2);\n\n    float a4 = dot(a, a3);\n    float b4 = dot(b, b3);\n    float c4 = dot(c, c3);\n    float d4 = dot(d, d3);\n    float e4 = dot(e, e3);\n    float f4 = dot(f, f3);\n\n    float a5 = dot(a, a4);\n    float b5 = dot(b, b4);\n    float c5 = dot(c, c4);\n    float d5 = dot(d, d4);\n    float e5 = dot(e, e4);\n    float f5 = dot(f, f4);\n\n    float a6 = dot(a, a5);\n    float b6 = dot(b, b5);\n    float c6 = dot(c, c5);\n    float d6 = dot(d, d5);\n    float e6 = dot(e, e5);\n    float f6 = dot(f, f5);\n\n    float a7 = dot(a, a6);\n    float b7 = dot(b, b6);\n    float c7 = dot(c, c6);\n    float d7 =", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p  = cross( rd, e2 );\n    float det = dot( e1, p );\n    if( det < 0.0001 ) return vec3( -1.0 );\n    vec3 tvec = ro - v0;\n    float u = dot( tvec, p ) / det;\n    if( u < 0.0 || u > 1.0 ) return vec3( -1.0 );\n    vec3 q = cross( tvec, e1 );\n    float v = dot( rd, q ) / det;\n    if( v < 0.0 || u + v > 1.0 ) return vec3( -1.0 );\n    float t = dot( e2, q ) / det;\n    return vec3( t, u, v );\n}\n\n// Ray marching\nfloat rayMarch( in vec3 ro, in vec3 rd, in float start, in float end )\n{\n    float precis = 0.001;\n    float h = start;\n    for( int i = 0; i < 64; i++ )\n    {\n        if( abs( h ) < precis || h > end ) break;\n        h = map( ro + rd * h );\n    }\n    return h;\n}\n\n// Ray marching with shadows\nfloat rayMarchShadow( in vec3 ro, in vec3 rd, in float start, in float end )\n{\n    float precis = 0.001;\n    float h = start;\n    for( int i = 0; i < 64; i++ )\n    {\n        if( abs( h ) < precis || h > end ) break;\n        h = map( ro + rd * h );\n    }\n    return h;\n}\n\n// Ray marching with shadows\nfloat rayMarchShadow( in vec3 ro, in vec3 rd, in float start, in float end, in float maxd )\n{\n    float precis = 0.001;\n    float h = start;", "\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 nor0 = cross( v0v1, v0v2 );\n    float d = dot( nor0, nor );\n    float a = length( v0v1 );\n    float b = length( v0v2 );\n    float c = length( v0 - pos );\n    float s = ( a + b + c ) / 2.0;\n    float area = sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) );\n    float occ = area / length( v0v1 );\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n// Shadowing\nfloat shadowing( in vec3 pos, in vec3 nor, in vec3 lightPos, in float lightRadius, in float lightFalloff )\n{\n    float occ = 1.0;\n    float dist = length( pos - lightPos );\n    if ( dist < lightRadius )\n    {\n        float atten = 1.0 - smoothstep( 0.0, lightRadius, dist );\n        occ = atten * atten;\n        occ *= triOcclusion( pos, nor, lightPos - lightRadius * lightFalloff * lightDir, lightPos + lightRadius * lightFalloff * lightDir, lightPos );\n    }\n    return occ;\n}\n\n// Lighting\nvec3 lighting( in vec3 pos, in vec3 nor, in vec3 lightPos, in float lightRadius, in float lightFalloff )\n{\n    vec3 lighting = vec3( 0.0 );\n    float occ = shadowing( pos, nor, lightPos, lightRadius, lightFalloff );\n    lighting += occ * lightColor * ( 1.0 - smoothstep( 0.0, lightRadius, length( pos - lightPos ) ) );\n    return lighting;\n}\n\n// Lighting\nvec3 lighting( in vec3 pos, in vec3 nor, in vec3 lightPos, in float lightRadius, in float lightFalloff, in vec3 light", "\n    vec2 p0 = pos - A;\n    vec2 p1 = B - A;\n    vec2 p2 = C - A;\n    float kk = 1.0 / dot( p0, p0 );\n    float k1 = 3.0 * kk * dot( p1, p0 );\n    float k2 = 3.0 * kk * dot( p2, p1 );\n    float k3 = kk * dot( p2, p2 );\n    float a = k3 + k1 - k2;\n    float b = k3 - 2.0 * k2 + k1;\n    float c = k3 - k2;\n    float k = 2.0 * (b * b - 4.0 * a * c);\n    if ( k < 0.0 ) return 1e20;\n    k = sqrt( k );\n    float t1 = (-b + k) / (2.0 * a);\n    float t2 = (-b - k) / (2.0 * a);\n    float t = min( t1, t2 );\n    if ( t1 > t2 ) t = max( t1, t2 );\n    if ( t < 0.0 ) t = 0.0;\n    return dot( p0 + t * p1, p0 + t * p1 ) / dot( p0, p0 );\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 p0 = pos - A;\n    vec2 p1 = B - A;\n    vec2 p2 = C - A;\n    vec2 p3 = D - A;\n    float kk = 1.0 / dot( p0, p0 );\n    float k1 = 3.0 * kk * dot( p1, p0 );\n    float k2 = 3.0 * kk * dot( p2, p1 );\n    float k3 = 3.0 * kk * dot( p3, p2 );\n    float k4 = kk *", "\n    vec2 d = abs(vec2(p.x,p.y-he)) - vec2(r1,r2);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------------------------\n// 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    return length(p/ab) - 1.0;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D circle\nfloat sdCircle( in vec2 p, in float s )\n{\n    return length(p) - s;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D line segment\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//----------------------------------------------------------------------------------------\n// 2D bezier\nfloat sdBezier( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 bc = c - b;\n    vec2 cd = a - c;\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n    vec2 pc = p - c;\n    float k = 1.0/6.0;\n    return k * ( sdBezier( pa, a, a + k * ab, b ) +\n                 sdBezier( pb, b, b + k * bc, c ) +\n                 sdBezier( pc, c, c + k * cd, a ) );\n}\n\n//----------------------------------------------------------------------------------------\n// 2D quadratic bezier\nfloat sdQuadBezier( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 bc = c - b", "\n    vec2 pa = p - a, ba = b - a;\n    float k = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*k ) * sign( k - 0.5 );\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    return length( p/ab ) - 1.0;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Arc\nfloat sdArc( in vec2 p, in float r, in float a0, in float a1 )\n{\n    float a = atan(p.y, p.x) + PI;\n    float d = abs(a - a0) - a1;\n    return length(p) - r*d;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D Polygon\nfloat sdPolygon( in vec2 p, in int n, in float r, in float a0 )\n{\n    float a = atan2(p.y, p.x) + PI;\n    float d = cos(floor(0.5 + a/a0)*a0 - a)*length(p);\n    return d - r;\n}\n\n//----------------------------------------------------------------------------------------\n// 2D N-Gon\nfloat sdNGon( in vec2 p, in int n, in float r )\n{\n    float a = atan2(p.y, p.x) + PI;\n", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in vec2 d )\n{\n    return normalize( d.xyy*map( pos + d.xyy ).x +\n                      d.yyx*map( pos + d.yyx ).x +\n                      d.yxy*map( pos + d.yxy ).x +\n                      d.xxx*map( pos + d.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in vec2 d, in float k )\n{\n    return normalize( d.xyy*map( pos + d.xyy*k ).x +\n                      d.yyx*map( pos + d.yyx*k ).x +\n                      d.yxy*map( pos + d.yxy*k ).x +\n                      d.xxx*map( pos + d.xxx*k ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float k )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*k ).x +\n                      e.yyx*map( pos + e.yyx*k ).x +\n                      e.yxy*map( pos + e.yxy*k ).x +\n", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/", "\n    return fract( sin( dot( q, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453 );\n}\n\n// random float\nfloat rand( in vec2 p )\n{\n    return fract( sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453 );\n}\n\n// random float\nfloat rand( in float x )\n{\n    return fract( sin( x * 12.9898 ) * 43758.5453 );\n}\n\n// random vec2\nvec2 rand2( in vec2 p )\n{\n    return fract( sin( vec2( sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453, sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453 ) ) * 43758.5453 );\n}\n\n// random vec3\nvec3 rand3( in vec2 p )\n{\n    return fract( sin( vec3( sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453, sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453, sin( dot( p, vec2( 12.9898, 4.1414 ) ) ) * 43758.5453 ) ) * 43758.5453 );\n}\n\n// random vec4\nvec4 rand4( in vec2 p )\n{\n    return fract( sin( vec4( sin( dot( p, vec2( 12.9898, 4.1", "\n    vec2 p2 = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p2.x + p2.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0), f.x),\n                     mix( hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\n// 2D value noise with smoothing (2nd derivative)\nfloat noise( in vec2 x, in float p )\n{\n    vec2 p2 = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p2.x + p2.y*57.0;\n    float res = mix(mix( n+  0.0, n+  1.0, f.x),\n                     mix( n+ 57.0, n+ 58.0, f.x), f.x);\n    res = mix(res, mix( n+  57.0, n+  58.0, f.x), f.y);\n    return res;\n}\n\n// 3D value noise with smoothing (2nd derivative)\nfloat noise( in vec3 x, in float p )\n{\n    vec3 p2 = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p2.x + p2.y*57.0 + 113.0*p2.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0), f.x),\n                         mix( hash(n+ 57.0), hash(n+ 58.0), f.x), f.x),\n                     mix(mix( hash(n+113.0), hash(n+1", "\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.3;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        a *= b;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec3 x, in int p )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.3;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        a *= b;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec4 x, in int p )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.3;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        a *= b;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in float a, in float b, in int p )\n{\n    float f = 0.0;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        a *= b;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fractal noise\nfloat fbm( in vec3 x, in float a, in float b, in int p )\n{\n    float f = 0.0;\n    for( int i = 0; i < p; i++ )\n    {\n        f += a * noise( x );\n        a *= b;\n        x *= 2.0;\n    }\n    return f;\n}\n\n// fractal noise\nfloat", "\n    return (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) / min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) / min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) / min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) / min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    return (length( p/r ) - 1.0) / min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/4dS3Wd\nfloat sdEllipsoid( in vec3 p, in vec3 r", "\n    return (length(p.xy)-r.x)*(length(p.xy)-r.x)+p.z*p.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    return (length(p.xy/r.xy)-1.0)*(length(p.xy/r.xy)-1.0)+p.z/r.z;\n}\n\n// asymmetric ellipsoid -", "\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good2( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good3( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good4( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good5( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good6( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - good approximated distance\nfloat sdEllipsoid_Good7( in vec3 p, in vec3 r ) \n{\n    return (length(p/r) - 1.0)", "\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z) - e;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e, in float m ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z) - e * m;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e, in float m, in float n ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z) - e * m * n;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e, in float m, in float n, in float o ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z) - e * m * n * o;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e, in float m, in float n, in float o, in float p ) \n{\n    return (length(p/r) - 1.0) * min(min(r.x, r.y), r.z) - e * m * n * o * p;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float e, in float m, in float n,", "\n    vec2 w = fwidth(p);\n    vec2 i = 2.0*min(dFdx(p), dFdy(p))/w;\n    vec2 j = 2.0*min(dFdy(p), dFdx(p))/w;\n    vec2 x = abs(i);\n    vec2 y = abs(j);\n    vec2 k = abs(i+j);\n    vec2 l = abs(i-j);\n    float m = max(max(x.x, x.y), max(y.x, y.y));\n    float n = min(min(k.x, k.y), min(l.x, l.y));\n    return max(0.5 - m + n, 0.0);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec3 p )\n{\n    vec3 w = fwidth(p);\n    vec3 i = 2.0*min(dFdx(p), dFdy(p))/w;\n    vec3 j = 2.0*min(dFdy(p), dFdx(p))/w;\n    vec3 x = abs(i);\n    vec3 y = abs(j);\n    vec3 k = abs(i+j);\n    vec3 l = abs(i-j);\n    float m = max(max(x.x, x.y), max(x.z, max(y.x, y.y)));\n    float n = min(min(k.x, k.y), min(k.z, min(l.x, l.y)));\n    return max(0.5 - m + n, 0.0);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec4 p )\n{\n    vec4 w = fwidth(p);\n    vec4 i = 2.0*min(dFdx(p), dFdy(p))/w;\n    vec4 j = 2.", "\n\treturn a / ( a + x );\n}\n\n// Schlick power function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat power( float a, float x )\n{\n\treturn a * x;\n}\n\n// Schlick Fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 fresnel( vec3 f0, vec3 f90, float cosTheta )\n{\n\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosTheta, 5.0 );\n}\n\n// Schlick Fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 fresnel( vec3 f0, vec3 f90, float cosTheta, float bias, float power )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( bias, cosTheta ), power );\n}\n\n// Schlick Fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 fresnel( vec3 f0, vec3 f90, float cosTheta, float bias, float power, float scale )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( bias, cosTheta ), power ) * scale;\n}\n\n// Schlick Fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nvec3 fresnel( vec3 f0, vec3 f90, float cosTheta, float bias, float power, float scale, float offset )\n{\n\treturn f0 + ( f90 - f0 ) * pow( bias( bias, cosTheta ), power ) * scale + offset;\n}\n\n// Schlick Fresnel function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps", "\n    return (x - floor(x)) * p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return 1.0 - abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased ramp wave\nfloat my_rmp( float x, float p )\n{\n    return (x - floor(x)) * p * (1.0 - floor(x));\n}\n\n// biased sawtooth wave\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x)) * p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return 1.0 - abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased ramp wave\nfloat my_rmp( float x, float p )\n{\n    return (x - floor(x)) * p * (1.0 - floor(x));\n}\n\n// biased sawtooth wave\nfloat my_saw( float x, float p )\n{\n    return (x - floor(x)) * p;\n}\n\n// biased triangle wave\nfloat my_tri( float x, float p )\n{\n    return 1.0 - abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased square wave\nfloat my_sqr( float x, float p )\n{\n    return abs(x - floor(x) * 2.0 - 1.0) * p;\n}\n\n// biased ramp wave\nfloat my_rmp( float x, float", "\n    float h2 = h * h;\n    float h4 = h2 * h2;\n    float h6 = h4 * h2;\n    float h8 = h4 * h4;\n    float h10 = h8 * h2;\n    float h12 = h8 * h4;\n    float h14 = h8 * h6;\n    float h16 = h8 * h8;\n    float h18 = h8 * h10;\n    float h20 = h8 * h12;\n    float h22 = h8 * h14;\n    float h24 = h8 * h16;\n    float h26 = h8 * h18;\n    float h28 = h8 * h20;\n    float h30 = h8 * h22;\n    float h32 = h8 * h24;\n    float h34 = h8 * h26;\n    float h36 = h8 * h28;\n    float h38 = h8 * h30;\n    float h40 = h8 * h32;\n    float h42 = h8 * h34;\n    float h44 = h8 * h36;\n    float h46 = h8 * h38;\n    float h48 = h8 * h40;\n    float h50 = h8 * h42;\n    float h52 = h8 * h44;\n    float h54 = h8 * h46;\n    float h56 = h8 * h48;\n    float h58 = h8 * h50;\n    float h60 = h8 * h52;\n    float h62 = h8 * h54;\n    float h64 = h8 * h56;\n    float h66 = h8 * h58;\n    float h68 = h8 * h60;\n    float h70 = h8 * h62;\n    float h72 = h8 * h64;\n    float h74 = h8 * h66;\n    float h76 = h", "\n    vec3  m = pa - ro;\n    float t = dot( m, rd );\n    vec3  n = m - t*rd;\n    float k = dot( n, n );\n    float l = dot( pa - pb, pa - pb );\n    float s = dot( pa - pb, rd );\n    float d = l*l - s*s;\n    if( d<0.0 ) return -1.0;\n    d = sqrt( d );\n    float t1 = t - d;\n    float t2 = t + d;\n    if( t1>t2 ) t1 = t2;\n    if( t1<0.0 ) return -1.0;\n    if( t1>1.0 ) return -1.0;\n    return t1;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3  m = pa - ro;\n    float t = dot( m, rd );\n    vec3  n = m - t*rd;\n    float k = dot( n, n );\n    float l = dot( pa - pb, pa - pb );\n    float s = dot( pa - pb, rd );\n    float d = l*l - s*s;\n    if( d<0.0 ) return -1.0;\n    d = sqrt( d );\n    float t1 = t - d;\n    float t2 = t + d;\n    if( t1>t2 ) t1 = t2;\n    if( t1<0.0 ) return -1.0;\n    if( t1>1.0 ) return -1.0;\n    return t1;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - ra + h * (rb - ra);\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max", "\n    float res = 1.0;\n    float t = 0.0;\n    float h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = clamp( dot( ro+rd*t, a ) / dot( rd, a ), 0.0, 1.0 );\n        t += clamp( h, 0.0, 0.1 );\n        res = min( res, k*h*(1.0-clamp( dot( ro+rd*t, b ), 0.0, 1.0 ))/t );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    return capShadow( ro, rd, a, b, r, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n    return capShadow( ro, rd, a, b, 0.02, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k, in float p )\n{\n    float res = 1.0;\n    float t = 0.0;\n    float h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = clamp( dot( ro+rd*t, a ) / dot( rd, a ), 0.0, 1.0 );\n        t += clamp( h, 0.0, 0.1 );\n        res = min( res, k*h*(1.0-clamp( dot( ro+rd*t, b ), 0.0, 1.0 ))/t );\n    }\n   ", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float d = 0.5 * (r - rad1);\n    float e = 0.5 * (r - rad2);\n    float f = 0.5 * (r - th);\n    float g = 0.5 * (r + th);\n    float h = 0.5 * (r + rad1);\n    float k = 0.5 * (r + rad2);\n    float l = 0.5 * (r + rad1 + rad2);\n    float m = 0.5 * (r + rad1 + rad2 + th);\n    float n = 0.5 * (r + rad1 + rad2 + th + th);\n    float o = 0.5 * (r + rad1 + rad2 + th + th + th);\n    float p = 0.5 * (r + rad1 + rad2 + th + th + th + th);\n    float q = 0.5 * (r + rad1 + rad2 + th + th + th + th + th);\n    float s = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th);\n    float t = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th);\n    float u = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th + th);\n    float v = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th + th + th);\n    float w = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th + th + th + th);\n    float x = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th + th + th + th + th);\n    float y = 0.5 * (r + rad1 + rad2 + th + th + th + th + th + th + th", "\n    // angle of p\n    float a = atan(p.y, p.x);\n    // distance to center\n    float d = length(p);\n    // distance to center + distance to edge\n    return d - r * (1.0 - step(abs(a), r * c.x));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r )\n{\n    return sdPie(p, vec2(c, c), r);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r, in float angle )\n{\n    return sdPie(p, vec2(c, c), r, angle);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r, in float angle, in float angle2 )\n{\n    return sdPie(p, vec2(c, c), r, angle, angle2);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r, in float angle, in float angle2, in float angle3 )\n{\n    return sdPie(p, vec2(c, c), r, angle, angle2, angle3);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r, in float angle, in float angle2, in float angle3, in float angle4 )\n{\n    return sdPie(p, vec2(c, c), r, angle, angle2, angle3, angle4);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in float c, in float r, in float angle, in float angle2, in float angle3, in float angle4, in float angle5 )\n{\n    return sdPie(p, vec2(c, c", "\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 4.0 * p;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^5 + y^5 + z^5 - ra^5\nvec3 nSphere5( in vec3 pos )\n{\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 5.0 * p;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^6 + y^6 + z^6 - ra^6\nvec3 nSphere6( in vec3 pos )\n{\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 6.0 * p;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^7 + y^7 + z^7 - ra^7\nvec3 nSphere7( in vec3 pos )\n{\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 7.0 * p;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^8 + y^8 + z^8 - ra^8\nvec3 nSphere8( in vec3 pos )\n{\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 8.0 * p;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^9 + y^9 + z^9 - ra^9\nvec3 nSphere9( in vec3 pos )\n{\n    vec3 p = pos - vec3( 0.0, 0.0, 0.0 );\n    return 9.0 * p;\n}\n\n// df/dx,df/dy,df/dx", "\n    float r = length( p );\n    float a = atan( p.y, p.x );\n    float sa = sin( a );\n    float ca = cos( a );\n    float h = clamp( dot( sca, vec2( sa, ca ) ), -1.0, 1.0 );\n    float k = clamp( dot( scb, vec2( sa, ca ) ), -1.0, 1.0 );\n    float pa = sa * ra;\n    float pb = sa * rb;\n    float d = abs( h * r - pa );\n    d = min( d, abs( k * r - pb ) );\n    return d;\n}\n\n//--------------------------------------------------------------------------------------------------\n// 2D Arc\n//--------------------------------------------------------------------------------------------------\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc2( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    float r = length( p );\n    float a = atan( p.y, p.x );\n    float sa = sin( a );\n    float ca = cos( a );\n    float h = clamp( dot( sca, vec2( sa, ca ) ), -1.0, 1.0 );\n    float k = clamp( dot( scb, vec2( sa, ca ) ), -1.0, 1.0 );\n    float pa = sa * ra;\n    float pb = sa * rb;\n    float d = abs( h * r - pa );\n    d = min( d, abs( k * r - pb ) );\n    return d;\n}\n\n//--------------------------------------------------------------------------------------------------\n// 2D Arc\n//--------------------------------------------------------------------------------------------------\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc2( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc )\n{\n    float r = length(", "\n    // we use this construction to avoid self-intersections\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, out float res )\n{\n    res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*eps;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x +\n                      e.yyx*map( pos + e.yyx, time ).x +\n                      e.yxy*map( pos + e.yxy, time ).x +\n                      e.xxx*map( pos + e.xxx, time ).x );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time, in float eps, in float strength )\n{\n    vec2 e = vec2(1.0,-1.0)*eps;\n    return normalize( (strength*2.0)*( e.xyy*map( pos + e.xyy, time ).x +\n                                      e.yyx*map( pos + e.yyx, time ).x +\n                                      e.yxy*map( pos + e.yxy, time ).x +\n                                      e.xxx*map( pos + e.xxx, time ).x ) );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float time, in float eps, in float strength, in float minDist )\n{\n    vec2 e = vec2(1.0,-1.0)*", "\n    // we use this constant for all light directions, so we can optimize it once\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return", "\n    vec2 w = max( abs( dpdx ), abs( dpdy ) );\n    return checkers( p, w );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGrad( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 w = max( abs( dpdx ), abs( dpdy ) );\n    return checkers( p, w );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGrad( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float jitter )\n{\n    vec2 w = max( abs( dpdx ), abs( dpdy ) );\n    return checkers( p, w, jitter );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGrad( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float jitter, in float scale )\n{\n    vec2 w = max( abs( dpdx ), abs( dpdy ) );\n    return checkers( p, w, jitter, scale );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGrad( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float jitter, in float scale, in float offset )\n{\n    vec2 w = max( abs( dpdx ), abs( dpdy ) );\n    return checkers( p, w, jitter, scale, offset );\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGrad( in vec2 p, in vec2 dpdx, in vec2 dpdy, in float jitter, in float scale, in float offset, in float threshold )\n{\n    vec2 w = max( abs( dpdx ), abs( dp", "\n    return (x<0.5)? x : (x<1.0)? 1.0 : (x<2.0)? 2.0 : (x<3.0)? 3.0 : (x<4.0)? 4.0 : (x<5.0)? 5.0 : (x<6.0)? 6.0 : (x<7.0)? 7.0 : (x<8.0)? 8.0 : (x<9.0)? 9.0 : (x<10.0)? 10.0 : (x<11.0)? 11.0 : (x<12.0)? 12.0 : (x<13.0)? 13.0 : (x<14.0)? 14.0 : (x<15.0)? 15.0 : (x<16.0)? 16.0 : (x<17.0)? 17.0 : (x<18.0)? 18.0 : (x<19.0)? 19.0 : (x<20.0)? 20.0 : (x<21.0)? 21.0 : (x<22.0)? 22.0 : (x<23.0)? 23.0 : (x<24.0)? 24.0 : (x<25.0)? 25.0 : (x<26.0)? 26.0 : (x<27.0)? 27.0 : (x<28.0)? 28.0 : (x<29.0)? 29.0 : (x<30.0)? 30.0 : (x<31.0)? 31.0 : (x<32.0)? 32.0 : (x<33.0)? 33.0 : (x<34.0)? 34.0 : (x<35.0", "\n    vec3 sky_col = background_col;\n    float sky_intensity = 0.0;\n\n    // Sample the atmosphere\n    vec3 atmosphere_sample = texture(atmosphere_texture, sample_pos).rgb;\n\n    // Calculate the intensity of the atmosphere\n    float atmosphere_intensity = max(0.0, dot(surface_normal, light_dir));\n\n    // Calculate the intensity of the sky\n    float sky_intensity = max(0.0, dot(surface_normal, -light_dir));\n\n    // Calculate the final colour\n    vec3 final_col = mix(atmosphere_sample, sky_col, atmosphere_intensity);\n\n    return final_col;\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col, float atmosphere_intensity) {\n    vec3 sky_col = background_col;\n    float sky_intensity = 0.0;\n\n    // Sample the atmosphere\n    vec3 atmosphere_sample = texture(atmosphere_texture, sample_pos).rgb;\n\n    // Calculate the intensity of the atmosphere\n    float atmosphere_intensity = max(0.0, dot(surface_normal, light_dir));\n\n    // Calculate the intensity of the sky\n    float sky_intensity = max(0.0, dot(surface_normal, -light_dir));\n\n    // Calculate the final colour\n    vec3 final_col = mix(atmosphere_sample, sky_col, atmosphere_intensity);\n\n    return final_col;\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_", "\n\tvec4 color = vec4(0.0);\n\tfloat depth = 0.0;\n\tfloat t = 0.0;\n\tfloat t_min = 0.0;\n\tfloat t_max = 100000.0;\n\tfloat t_step = 0.01;\n\tfloat t_step_max = 0.01;\n\tfloat t_step_min = 0.01;\n\tfloat t_step_mult = 1.0;\n\tfloat t_step_mult_max = 1.0;\n\tfloat t_step_mult_min = 1.0;\n\tfloat t_step_mult_threshold = 0.01;\n\tfloat t_step_mult_threshold_max = 0.01;\n\tfloat t_step_mult_threshold_min = 0.01;\n\tfloat t_step_mult_threshold_mult = 1.0;\n\tfloat t_step_mult_threshold_mult_max = 1.0;\n\tfloat t_step_mult_threshold_mult_min = 1.0;\n\tfloat t_step_mult_threshold_mult_threshold = 0.01;\n\tfloat t_step_mult_threshold_mult_threshold_max = 0.01;\n\tfloat t_step_mult_threshold_mult_threshold_min = 0.01;\n\tfloat t_step_mult_threshold_mult_threshold_mult = 1.0;\n\tfloat t_step_mult_threshold_mult_threshold_mult_max = 1.0;\n\tfloat t_step_mult_threshold_mult_threshold_mult_min = 1.0;\n\tfloat t_step_mult_threshold_mult_threshold_mult_threshold = 0.01;\n\tfloat t_step_mult_threshold_mult_threshold_mult_threshold_max = 0.01;\n\tfloat t_step_mult_threshold_mult_threshold_mult_threshold_min = 0.01;\n\tfloat t_", "\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0));\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the view vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_view_vector(vec3 resolution, vec2 coord) {\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0));\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the world vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_world_vector(vec3 resolution, vec2 coord) {\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0));\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the world vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_world_vector(vec3 resolution, vec2 coord, vec3 camera_position) {\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0) - camera_position);\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the world vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_world_vector(vec3 resolution, vec2 coord, vec3 camera_position, vec3 camera_direction) {\n    vec2 xy = (coord - resolution / 2.0) / resolution.y;\n    return normalize(vec3(xy, 1.0) - camera_position + camera_direction);\n}\n\n/*\nnext, we", "\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb)\n{\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra, rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc)\n{\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra, rb, rc);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd)\n{\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra, rb, rc, rd);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd, float re)\n{\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra, rb, rc, rd, re);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd, float re, float rf)\n{\n    vec3 q = p;\n    q.xy *= c.y;\n    q.z *= c.x;\n    return sdCone(q, ra", "\n    vec3 color = vec3(0.0);\n    switch (material) {\n        case 0:\n            color = vec3(1.0);\n            break;\n        case 1:\n            color = vec3(0.0);\n            break;\n        case 2:\n            color = vec3(1.0);\n            break;\n        case 3:\n            color = vec3(1.0);\n            break;\n        case 4:\n            color = vec3(1.0);\n            break;\n        case 5:\n            color = vec3(1.0);\n            break;\n        case 6:\n            color = vec3(1.0);\n            break;\n        case 7:\n            color = vec3(1.0);\n            break;\n        case 8:\n            color = vec3(1.0);\n            break;\n        case 9:\n            color = vec3(1.0);\n            break;\n        case 10:\n            color = vec3(1.0);\n            break;\n        case 11:\n            color = vec3(1.0);\n            break;\n        case 12:\n            color = vec3(1.0);\n            break;\n        case 13:\n            color = vec3(1.0);\n            break;\n        case 14:\n            color = vec3(1.0);\n            break;\n        case 15:\n            color = vec3(1.0);\n            break;\n        case 16:\n            color = vec3(1.0);\n            break;\n        case 17:\n            color = vec3(1.0);\n            break;\n        case 18:\n            color = vec3(1.0);\n            break;\n        case 19:\n            color = vec3(1.0);\n            break;\n        case 20:\n            color = vec3(1.0);\n            break;\n        case 21:\n            color = vec3(1.0);\n            break;\n        case 22:\n            color = vec3(1.0);", "\n    switch (material) {\n        case MATERIAL_GLASS:\n            return 0.9;\n        case MATERIAL_WOOD:\n            return 0.5;\n        case MATERIAL_PLASTIC:\n            return 0.1;\n        case MATERIAL_METAL:\n            return 0.8;\n        case MATERIAL_PAPER:\n            return 0.0;\n        case MATERIAL_ROCK:\n            return 0.2;\n        case MATERIAL_CARDBOARD:\n            return 0.0;\n        case MATERIAL_RUBBER:\n            return 0.0;\n        case MATERIAL_GLASS_CLEAR:\n            return 0.9;\n        case MATERIAL_GLASS_BLACK:\n            return 0.9;\n        case MATERIAL_GLASS_WHITE:\n            return 0.9;\n        case MATERIAL_GLASS_RED:\n            return 0.9;\n        case MATERIAL_GLASS_GREEN:\n            return 0.9;\n        case MATERIAL_GLASS_BLUE:\n            return 0.9;\n        case MATERIAL_GLASS_YELLOW:\n            return 0.9;\n        case MATERIAL_GLASS_ORANGE:\n            return 0.9;\n        case MATERIAL_GLASS_PURPLE:\n            return 0.9;\n        case MATERIAL_GLASS_PINK:\n            return 0.9;\n        case MATERIAL_GLASS_BROWN:\n            return 0.9;\n        case MATERIAL_GLASS_GREY:\n            return 0.9;\n        case MATERIAL_GLASS_BLACK_PLASTIC:\n            return 0.9;\n        case MATERIAL_GLASS_WHITE_PLASTIC:\n            return 0.9;\n        case", "\n    return materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat get_material_reflection(int material) {\n    return materials[material].reflection;\n}\n\n// Get index of refraction of a material.\nfloat get_material_transparency(int material) {\n    return materials[material].transparency;\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular(int material) {\n    return materials[material].specular;\n}\n\n// Get index of refraction of a material.\nfloat get_material_shininess(int material) {\n    return materials[material].shininess;\n}\n\n// Get index of refraction of a material.\nfloat get_material_ior(int material) {\n    return materials[material].ior;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission(int material) {\n    return materials[material].emission;\n}\n\n// Get index of refraction of a material.\nfloat get_material_ambient(int material) {\n    return materials[material].ambient;\n}\n\n// Get index of refraction of a material.\nfloat get_material_diffuse(int material) {\n    return materials[material].diffuse;\n}\n\n// Get index of refraction of a material.\nfloat get_material_specular_color(int material) {\n    return materials[material].specular_color;\n}\n\n// Get index of refraction of a material.\nfloat get_material_diffuse_color(int material) {\n    return materials[material].diffuse_color;\n}\n\n// Get index of refraction of a material.\nfloat get_material_ambient_color(int material) {\n    return materials[material].ambient_color;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission_color(int material) {\n    return materials[material].emission_color;\n}\n\n// Get index of refraction of a material.\nfloat get_material_transparency_color(int material) {\n    return materials[material].transparency", "\n    return materials[material].opacity;\n}\n\n// Get the color of a material.\nvec3 get_material_color(int material) {\n    return materials[material].color;\n}\n\n// Get the color of a material.\nvec3 get_material_emission(int material) {\n    return materials[material].emission;\n}\n\n// Get the color of a material.\nvec3 get_material_ambient(int material) {\n    return materials[material].ambient;\n}\n\n// Get the color of a material.\nvec3 get_material_diffuse(int material) {\n    return materials[material].diffuse;\n}\n\n// Get the color of a material.\nvec3 get_material_specular(int material) {\n    return materials[material].specular;\n}\n\n// Get the color of a material.\nfloat get_material_shininess(int material) {\n    return materials[material].shininess;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index(int material) {\n    return materials[material].refractive_index;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index_ratio(int material) {\n    return materials[material].refractive_index_ratio;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index_exponent(int material) {\n    return materials[material].refractive_index_exponent;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index_absorption(int material) {\n    return materials[material].refractive_index_absorption;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index_transmission(int material) {\n    return materials[material].refractive_index_transmission;\n}\n\n// Get the color of a material.\nfloat get_material_refractive_index_transparency(int material) {\n    return materials[material].refractive_index_transparency;\n}\n\n// Get the color", "\n    vec3 v0 = tri_b - tri_a;\n    vec3 v1 = tri_c - tri_a;\n    vec3 v2 = line_b - line_a;\n    vec3 v3 = line_a - tri_a;\n\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float d30 = dot(v3, v0);\n    float d31 = dot(v3, v1);\n    float d32 = dot(v3, v2);\n\n    float denom = d00 * d11 - d01 * d01;\n    float u = (d11 * d32 - d01 * d31) / denom;\n    float v = (d00 * d31 - d01 * d30) / denom;\n\n    return vec3(u >= 0.0 && v >= 0.0 && u + v <= 1.0, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v0 = tri_b - tri_a;\n    vec3 v1 = tri_c - tri_a;\n    vec3 v2 = line_b - line_a;\n    vec3 v3 = line_a - tri_a;\n\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_normal) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_normal, vec3 tri_normal_tangent) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_normal, vec3 tri_normal_tangent, vec3 tri_normal_bitangent) {\n    vec3 ab = tri_b - tri", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat3(x_axis, y_axis, z_axis);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect, float near, float far) {\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    return mat4(\n        f / aspect, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (near + far) / (near - far), -1.0,\n        0.0, 0.0, (2.0 * near * far) / (near - far), 0.0\n    );\n}\n\n// Generate an orthographic projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-orthographic-projection-matrix\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near, float far) {\n    return mat4(\n        2.0 / (right - left), 0.0, 0.0, 0.0,\n        0.0, 2.0 / (top - bottom), 0.0, 0.0,\n        0.0, 0.0, -2.0 / (far - near), 0.0,\n        -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1.0\n   ", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = INFINITY;\n    result.triangle_index = -1;\n    result.triangle_normal = vec3(0.0);\n    result.triangle_position = vec3(0.0);\n    result.triangle_uv = vec2(0.0);\n\n    // Check all triangles in the scene for intersection with a ray.\n    for (int i = 0; i < num_triangles; i++) {\n        vec3 a = vertices[triangles[i].a];\n        vec3 b = vertices[triangles[i].b];\n        vec3 c = vertices[triangles[i].c];\n\n        // Calculate the plane of the triangle.\n        vec3 ab = b - a;\n        vec3 ac = c - a;\n        vec3 normal = cross(ab, ac);\n\n        // Calculate the distance from the ray origin to the plane of the triangle.\n        float distance = dot(normal, a) - dot(normal, ray_origin);\n\n        // If the ray is on the same side of the plane as the triangle,\n        // then it can't possibly intersect the triangle.\n        if (distance < 0.0) {\n            continue;\n        }\n\n        // Calculate the distance from the ray origin to the plane of the triangle.\n        float distance = dot(normal, a) - dot(normal, ray_origin);\n\n        // If the ray is on the same side of the plane as the triangle,\n        // then it can't possibly intersect the triangle.\n        if (distance < 0.0) {\n            continue;\n        }\n\n        // Calculate the distance from the ray origin to the plane of the triangle.\n        float distance = dot(normal, a) - dot(normal, ray_origin);\n\n        // If the ray is on the same side of the plane as the triangle,\n        // then it can't possibly intersect the triangle.\n        if (distance < 0.0) {\n            continue;\n        }\n\n        // Calculate the distance from the ray origin to the plane of the triangle.\n        float distance = dot(normal, a) - dot", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float ray_length = length(ray_target - ray_origin);\n    float ray_step_size = 0.01;\n    float ray_step_count = ray_length / ray_step_size;\n    float ray_step_count_floor = floor(ray_step_count);\n    float ray_step_count_fraction = ray_step_count - ray_step_count_floor;\n    float ray_step_count_ceil = ceil(ray_step_count);\n    float ray_step_count_ceil_fraction = ray_step_count_ceil - ray_step_count;\n    float ray_step_count_ceil_fraction_inv = 1.0 - ray_step_count_ceil_fraction;\n    float ray_step_count_floor_fraction = ray_step_count_floor - ray_step_count;\n    float ray_step_count_floor_fraction_inv = 1.0 - ray_step_count_floor_fraction;\n    float ray_step_count_inv = 1.0 / ray_step_count;\n    float ray_step_count_inv_fraction = 1.0 - ray_step_count_inv;\n    float ray_step_count_inv_fraction_inv = 1.0 - ray_step_count_inv_fraction;\n    float ray_step_count_inv_fraction_inv_inv = 1.0 - ray_step_count_inv_fraction_inv;\n    float ray_step_count_inv_fraction_inv_inv_inv = 1.0 - ray_step_count_inv_fraction_inv_inv;\n    float ray_step_count_inv_fraction_inv_inv_inv_inv = 1.0 - ray_step_count_inv_fraction_inv_inv_inv;\n    float ray_step_count_inv_fraction_inv_inv_inv_inv_inv = 1.0 - ray_step_count_inv_fraction_inv_inv_inv_inv;\n    float ray_step_count", "\n    float i = floor(x);\n    float f = fract(x);\n    return mix(bnoise(i), bnoise(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\n// 2D noise\nfloat bnoise( in vec2 x )\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = bnoise(i);\n    float b = bnoise(i + vec2(1.0, 0.0));\n    float c = bnoise(i + vec2(0.0, 1.0));\n    float d = bnoise(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n    //                 mix(c, d, smoothstep(0.0, 1.0, f.x)),\n    //                 smoothstep(0.0, 1.0, f.y)));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// 3D noise\nfloat bnoise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the\n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = bnoise(i.x + i.y * 57.0 + 113.0 * i.z);\n\n    // The", "\n    float fl = floor( p );\n    float fc = fract( p );\n    return mix( gnoise( fl ), gnoise( fl + 1.0 ), fc );\n}\n\n// Simplex noise\nfloat snoise( in vec2 p )\n{\n    vec2 f = fract( p );\n    vec2 fl = floor( p );\n    f = f * f * ( 3.0 - 2.0 * f );\n    fl = fl * fl;\n    return mix( mix( gnoise( fl ), gnoise( fl + vec2( 1.0, 0.0 ) ), f.x ),\n                mix( gnoise( fl + vec2( 0.0, 1.0 ) ), gnoise( fl + vec2( 1.0, 1.0 ) ), f.x ),\n                f.y );\n}\n\n// Simplex noise\nfloat snoise( in vec3 p )\n{\n    vec3 f = fract( p );\n    vec3 fl = floor( p );\n    f = f * f * ( 3.0 - 2.0 * f );\n    fl = fl * fl;\n    return mix( mix( mix( gnoise( fl ), gnoise( fl + vec3( 1.0, 0.0, 0.0 ) ), f.x ),\n                    mix( gnoise( fl + vec3( 0.0, 1.0, 0.0 ) ), gnoise( fl + vec3( 1.0, 1.0, 0.0 ) ), f.x ),\n                    f.y ),\n                mix( mix( gnoise( fl + vec3( 0.0, 0.0, 1.0 ) ), gnoise( fl + vec3( 1.0, 0.0, 1.0 ) ), f.x ),\n                    mix( gnoise( fl + vec3( 0.0, 1.0, 1.0 ) ), gnoise( fl + vec3( 1.0, 1.0, 1.0 ) ), f.x ),\n                    f.", "\n    return fract(sin(float(n))*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat noise( in vec3 x ) \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// float hash copied from Hugo Elias\nfloat noise( in vec2 x ) \n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n// float hash copied from Hugo Elias\nfloat noise( in float x ) \n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0", "\n    float fl = floor( p );\n    float fc = fract( p );\n    return mix( gnoise( fl ), gnoise( fl + 1.0 ), fc );\n}\n\n// 3D gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fc = fract( p );\n    return mix( mix( mix( gnoise( fl ), gnoise( fl + vec3( 1.0, 0.0, 0.0 ) ), fc.x ),\n                    mix( gnoise( fl + vec3( 0.0, 1.0, 0.0 ) ), gnoise( fl + vec3( 1.0, 1.0, 0.0 ) ), fc.x ),\n                    fc.y ),\n                mix( mix( gnoise( fl + vec3( 0.0, 0.0, 1.0 ) ), gnoise( fl + vec3( 1.0, 0.0, 1.0 ) ), fc.x ),\n                    mix( gnoise( fl + vec3( 0.0, 1.0, 1.0 ) ), gnoise( fl + vec3( 1.0, 1.0, 1.0 ) ), fc.x ),\n                    fc.y ),\n                fc.z );\n}\n\n// 4D gradient noise\nfloat gnoise( in vec4 p )\n{\n    vec4 fl = floor( p );\n    vec4 fc = fract( p );\n    return mix( mix( mix( mix( gnoise( fl ), gnoise( fl + vec4( 1.0 ) ), fc.x ),\n                        mix( gnoise( fl + vec4( 0.0, 1.0 ) ), gnoise( fl + vec4( 1.0, 1.0 ) ), fc.x ),\n                        fc.y ),\n                    mix( mix( gnoise( fl + vec4( 0.0, 0.0, 1.0 ) ), g", "\n    float f = 0.0;\n    float G2 = G * G;\n    for( int i = 0; i < 4; i++ )\n    {\n        f += noise( x ) * G2;\n        x *= 2.0;\n        G2 *= G2;\n    }\n    return f;\n}\n\n// fbm\nvec2 fbm( in vec2 x, in float G )\n{\n    vec2 f = vec2( 0.0 );\n    float G2 = G * G;\n    for( int i = 0; i < 4; i++ )\n    {\n        f += noise( x ) * G2;\n        x *= 2.0;\n        G2 *= G2;\n    }\n    return f;\n}\n\n// fbm\nvec3 fbm( in vec3 x, in float G )\n{\n    vec3 f = vec3( 0.0 );\n    float G2 = G * G;\n    for( int i = 0; i < 4; i++ )\n    {\n        f += noise( x ) * G2;\n        x *= 2.0;\n        G2 *= G2;\n    }\n    return f;\n}\n\n// fbm\nvec4 fbm( in vec4 x, in float G )\n{\n    vec4 f = vec4( 0.0 );\n    float G2 = G * G;\n    for( int i = 0; i < 4; i++ )\n    {\n        f += noise( x ) * G2;\n        x *= 2.0;\n        G2 *= G2;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n    float f = 0.0;\n    float G2 = G * G;\n    for( int i = 0; i < 4; i++ )\n    {\n        f += noise( x ) * G2;\n        x *= 2.0;\n        G2 *= G2;\n    }\n    return f;\n}\n\n//", "\n    float r = length(p);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r10 = r8*r2;\n    float r12 = r8*r4;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r16*r2;\n    float r20 = r16*r4;\n    float r22 = r18*r2;\n    float r24 = r18*r4;\n    float r26 = r22*r2;\n    float r28 = r22*r4;\n    float r30 = r24*r2;\n    float r32 = r24*r4;\n    float r34 = r26*r2;\n    float r36 = r26*r4;\n    float r38 = r28*r2;\n    float r40 = r28*r4;\n    float r42 = r30*r2;\n    float r44 = r30*r4;\n    float r46 = r32*r2;\n    float r48 = r32*r4;\n    float r50 = r34*r2;\n    float r52 = r34*r4;\n    float r54 = r36*r2;\n    float r56 = r36*r4;\n    float r58 = r38*r2;\n    float r60 = r38*r4;\n    float r62 = r40*r2;\n    float r64 = r40*r4;\n    float r66 = r42*r2;\n    float r68 = r42*r4;\n    float r70 = r44*r2;\n    float r72 = r44*r4;\n    float r74 = r46*", "\n    // The cubic polynomial is\n    // a + b*x + c*x^2 + d*x^3\n    // where x is the 4D point in the unit sphere\n    // and the coefficients are determined by the\n    // 3 angles of the point in the unit box.\n    // The coefficients are determined by the\n    // 3 angles of the point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are the 3 components of the\n    // point in the unit box.\n    // The 3 angles are", "\n    vec3 m = clamp((cen-ro)/rd, 0.0, 1.0);\n    vec3 n = clamp((ro+rd*m-cen)/rd, 0.0, 1.0);\n    vec3 k = n-m;\n    vec4 res;\n    res.x = max( max(k.x,k.y), k.z);\n    res.y = min( min(k.x,k.y), k.z);\n    res.z = length(max(vec3(0.0),n-res.y*rd));\n    res.w = length(max(vec3(0.0),m-res.x*rd));\n    return res;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r", "\n    vec3 r = ro - cen;\n    vec3 rd2 = rd * rd;\n    vec3 r2 = r * r;\n    vec3 rr = r2 * rad;\n    float k = dot( rd2, rad );\n    float k2 = k * 2.0;\n    float k3 = k * k2;\n    float k4 = k * k3;\n    float k5 = k * k4;\n    float k6 = k * k5;\n    float k7 = k * k6;\n    float k8 = k * k7;\n    float k9 = k * k8;\n    float k10 = k * k9;\n    float k11 = k * k10;\n    float k12 = k * k11;\n    float k13 = k * k12;\n    float k14 = k * k13;\n    float k15 = k * k14;\n    float k16 = k * k15;\n    float k17 = k * k16;\n    float k18 = k * k17;\n    float k19 = k * k18;\n    float k20 = k * k19;\n    float k21 = k * k20;\n    float k22 = k * k21;\n    float k23 = k * k22;\n    float k24 = k * k23;\n    float k25 = k * k24;\n    float k26 = k * k25;\n    float k27 = k * k26;\n    float k28 = k * k27;\n    float k29 = k * k28;\n    float k30 = k * k29;\n    float k31 = k * k30;\n    float k32 = k * k31;\n    float k33 = k * k32;\n    float k34 = k * k33;\n    float k35 = k * k34;\n    float k36 = k * k35;\n    float k37 = k * k3", "\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*t);\n        res = min( res, w*h/t );\n        t += clamp( h, 0.02, 0.1 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n        float h = map(ro + rd*t);\n        res = min( res, w*h/t );\n        t += clamp( h, 0.02, 0.1 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( pow( res, k ), 0.0, 1.0 );\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float k, float p)\n{\n    float res = 1.0;\n    float t = mint;\n   ", " seed = fract(sin(seed) * 13.1415926535897932384626433832795); return seed; }\nfloat rand(float x) { return fract(sin(x) * 13.1415926535897932384626433832795); }\nfloat rand(float2 x) { return fract(sin(dot(x, float2(12.9898, 78.233))) * 13.1415926535897932384626433832795); }\nfloat rand(float3 x) { return fract(sin(dot(x, float3(12.9898, 78.233, 14.47))) * 13.1415926535897932384626433832795); }\nfloat rand(float4 x) { return fract(sin(dot(x, float4(12.9898, 78.233, 14.47, 1.61803398874989484820458681))) * 13.1415926535897932384626433832795); }\n\nfloat3 shadow_montecarlo(float3 pos, float3 light_dir, float3 normal, float3 albedo, float roughness, float metalness, float shadow_bias, float shadow_softness)\n{\n    float3 shadow_pos = pos + light_dir * shadow_bias;\n    float3 shadow_normal = normal;\n    float3 shadow_albedo = albedo;\n    float shadow_roughness = roughness;\n    float shadow_metalness = metalness;\n\n    float shadow_depth = length(shadow_pos);\n    float", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Noise Function\n//https://www.shadertoy.com/view/4djSRW\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0), f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0), f.x),\n                        mix( hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\n//Inigo Quilez's Hash Function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash( float p )\n{\n    vec2 p2 = fract(vec2(p)*vec2(234.34, 435.345));\n    p2 += dot(p2.yx, p2.xy+19.19);\n    return fract(p2.x*p2.y);\n}\n\n//Inigo Quilez's 3D Noise Function\n//https://www.shadertoy.com/view/4djSRW\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.", "\n    vec3 q = abs(p);\n    return max(q.y - h, max(q.x*sin(ra) + q.z*cos(ra), q.x*cos(ra) + q.z*sin(ra)) - la) - lb;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb)\n{\n    vec3 q = abs(p);\n    return max(q.y - h, max(q.x*sin(ra) + q.z*cos(ra), q.x*cos(ra) + q.z*sin(ra)) - la) - lb;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb, float rc)\n{\n    vec3 q = abs(p);\n    return max(q.y - h, max(q.x*sin(ra) + q.z*cos(ra), q.x*cos(ra) + q.z*sin(ra)) - la) - lb;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb, float rc, float rd)\n{\n    vec3 q = abs(p);\n    return max(q.y - h, max(q.x*sin(ra) + q.z*cos(ra), q.x*cos(ra) + q.z*sin(ra)) - la) - lb;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra, float rb, float rc, float rd, float re)\n{\n    vec3 q = abs(p);\n    return max(q.y - h, max(q.x*sin(ra) + q", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 c = a + h * ba;\n\tvec2 w = p - c;\n\tfloat d = length( w );\n\tfloat e = length( pa );\n\tfloat f = length( ba );\n\tfloat g = f * f;\n\tfloat r2 = r * r;\n\tfloat k = ( g - r2 ) / g;\n\tfloat l = sqrt( r2 - k * k * r2 );\n\tfloat m = r - l;\n\tfloat n = r + l;\n\tfloat o = min( m, d );\n\tfloat p = max( n, e );\n\tfloat q = min( p, f );\n\tfloat s = max( q - o, 0.0 );\n\tfloat t = min( f, q );\n\tfloat u = max( t - o, 0.0 );\n\tfloat v = min( p, t );\n\tfloat w = max( v - o, 0.0 );\n\tfloat x = min( f, v );\n\tfloat y = max( w - o, 0.0 );\n\tfloat z = min( x, e );\n\tfloat A = 2.0 * ( o + u );\n\tfloat B = 2.0 * ( o + w );\n\tfloat C = 2.0 * ( o + y );\n\tfloat D = 2.0 * ( o + z );\n\tfloat E = 2.0 * ( o + v );\n\tfloat F = 2.0 * ( o + q );\n\tfloat G = 2.0 * ( o + s );\n\tfloat H = 2.0 * ( o + t );\n\tfloat I = 2.0 * ( o + r );\n\tfloat J = 2.0 * ( o + p );\n\tfloat K = 2.0 * ( o + e );\n\tfloat L = 2.0 * ( o + d );\n\tfloat M = 2.0 * ( o + f );\n\tfloat N = 2", "\n    vec2 d = abs(p) - b;\n    vec4 res = vec4(d.x,d.y,d.x+d.y,s);\n    res.y *= r;\n    res.z = min(res.z, length(max(d,0.0)) + r);\n    return res;\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCylinder( in vec2 p, \n                 in float r, \n                 in float s )\n{\n    vec2 d = abs(p) - vec2(r);\n    vec4 res = vec4(d.x,d.y,d.x+d.y,s);\n    res.y *= r;\n    res.z = min(res.z, length(max(d,0.0)) + r);\n    return res;\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCapsule( in vec2 p, \n                in float r, \n                in float s )\n{\n    vec2 d = abs(p) - vec2(r);\n    vec4 res = vec4(d.x,d.y,d.x+d.y,s);\n    res.y *= r;\n    res.z = min(res.z, length(max(d,0.0)) + r);\n    return res;\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCone( in vec2 p, \n             in float r, \n             in float s )\n{\n    vec2 d = abs(p) - vec2(r);\n    vec4 res = vec4(d.x,d.y,d.x+d.y,s);\n    res.y *= r;\n    res.z = min(res.z, length(max(d,0.0)) + r);\n", "\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                 0.0,\n                 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0),\n                 0.0,\n                 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0),\n                 0.0,\n                 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) - r,\n                 0.0,\n                 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z", "\n\tfloat d = length(p) - r;\n\tfloat c = smoothstep(0.0, band, d);\n\treturn vec4(d, d, d, c);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r ) \n{\n\tfloat d = length(p) - r;\n\tfloat c = smoothstep(0.0, 0.01, d);\n\treturn vec4(d, d, d, c);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float band2 ) \n{\n\tfloat d = length(p) - r;\n\tfloat c = smoothstep(0.0, band, d);\n\tc *= smoothstep(band2, band2 + 0.01, d);\n\treturn vec4(d, d, d, c);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float band2, float band3 ) \n{\n\tfloat d = length(p) - r;\n\tfloat c = smoothstep(0.0, band, d);\n\tc *= smoothstep(band2, band2 + 0.01, d);\n\tc *= smoothstep(band3, band3 + 0.01, d);\n\treturn vec4(d, d, d, c);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float band2, float band3, float band4 ) \n{\n\tfloat d = length(p) - r;\n\tfloat c = smoothstep(0.0, band, d);\n", "\n    float d = dot(p,p);\n    float e = 1.0;\n    for( int i=0; i<5; i++ ) \n    {\n        vec2 v = verts[i];\n        e = min( e, dot(p,v) );\n        d = min( d, dot(p,v) );\n    }\n    return sqrt(d)-r*e;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5] ) \n{\n    return sdPoly( p, verts, 1.0 );\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t ) \n{\n    float d = dot(p,p);\n    float e = 1.0;\n    for( int i=0; i<5; i++ ) \n    {\n        vec2 v = verts[i];\n        e = min( e, dot(p,v) );\n        d = min( d, dot(p,v) );\n    }\n    return sqrt(d)-r*e*t;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s ) \n{\n    float d = dot(p,p);\n    float e = 1.0;\n    for( int i=0; i<5; i++ ) \n    {\n        vec2 v = verts[i];\n        e = min( e, dot(p,v) );\n        d = min( d, dot(p,v) );\n    }\n    return sqrt(d)-r*e*t*s;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float t, in float s, in float a ) \n{\n    float d = dot(p,p);\n    float e = 1.0;\n    for( int i=0; i<5; i++ ) \n    {\n        vec2 v = verts[i];\n        e = min( e, dot(p,v", "\n    vec2 v0 = verts[0] - p;\n    vec2 v1 = verts[1] - p;\n    vec2 v2 = verts[2] - p;\n    vec2 v3 = verts[3] - p;\n    vec2 v4 = verts[4] - p;\n    float d0 = dot( v0, v0 );\n    float d1 = dot( v1, v1 );\n    float d2 = dot( v2, v2 );\n    float d3 = dot( v3, v3 );\n    float d4 = dot( v4, v4 );\n    float k0 = max( d0, max( d1, max( d2, max( d3, d4 ) ) ) );\n    float k1 = 1.0 / k0;\n    float k2 = inversesqrt( k1 );\n    float k3 = k2 * k2 * r;\n    float k4 = 1.0 / ( 1.0 + k3 );\n    float k5 = k4 * k4;\n    float k6 = k5 * k4;\n    float k7 = k6 * k4;\n    float k8 = k7 * k4;\n    float k9 = k8 * k4;\n    float k10 = k9 * k4;\n    float k11 = k10 * k4;\n    float k12 = k11 * k4;\n    float k13 = k12 * k4;\n    float k14 = k13 * k4;\n    float k15 = k14 * k4;\n    float k16 = k15 * k4;\n    float k17 = k16 * k4;\n    float k18 = k17 * k4;\n    float k19 = k18 * k4;\n    float k20 = k19 * k4;\n    float k21 = k20 * k4;\n    float k22 = k21 * k4;\n    float k23 = k22 * k4;\n    float k24 = k23 * k4;\n    float", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return vec3( pa + ba * h, 1.0 - h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return vec3( pa + ba * h, 1.0 - h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    float k = clamp( dot( pa, ca ) / dot( ca, ca ), 0.0, 1.0 );\n    return vec3( pa + ba * h + ca * k, 1.0 - h - k );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 a,", "\n    vec3 q = vec3( p, 1.0 );\n    vec3 s = vec3( 1.0, 1.0, 1.0 );\n    vec3 t = abs( q );\n    vec3 m = max( s, t );\n    vec3 n = min( s, t );\n    vec3 r = n * 0.57735027;\n    vec3 u = max( m, n * 0.57735027 );\n    vec3 v = u * 0.57735027;\n    vec3 w = v * 0.57735027;\n    vec3 x = w * 0.57735027;\n    vec3 y = x * 0.57735027;\n    vec3 z = y * 0.57735027;\n    vec3 a = z * 0.57735027;\n    vec3 b = a * 0.57735027;\n    vec3 c = b * 0.57735027;\n    vec3 d = c * 0.57735027;\n    vec3 e = d * 0.57735027;\n    vec3 f = e * 0.57735027;\n    vec3 g = f * 0.57735027;\n    vec3 h = g * 0.57735027;\n    vec3 i = h * 0.57735027;\n    vec3 j = i * 0.57735027;\n    vec3 k = j * 0.57735027;\n    vec3 l = k * 0.57735027;\n    vec3 m = l * 0.57735027;\n    vec3 n = m * 0.57735027;\n    vec3 o = n * 0.577", "\n    vec3 x = p - X[0];\n    vec3 y = p - X[1];\n    vec3 z = p - X[2];\n    float a = dot(x, x);\n    float b = dot(x, y);\n    float c = dot(y, y);\n    float d = dot(y, z);\n    float e = dot(z, z);\n    float f = dot(x, z);\n    float g = 2.0 * dot(x, y);\n    float h = 2.0 * dot(y, z);\n    float i = 2.0 * dot(x, z);\n    float j = dot(x, x) + dot(y, y) - 1.0;\n    float k = dot(x, y) + dot(y, z) + dot(z, x);\n    float l = dot(x, z) + dot(z, y) + dot(y, x);\n    float m = dot(x, x) + dot(z, z) - 1.0;\n    float n = dot(y, z) + dot(z, x) + dot(x, y);\n    float o = dot(y, x) + dot(x, z) + dot(z, y);\n    float p = dot(z, z) + dot(x, x) - 1.0;\n    float q = dot(z, x) + dot(y, z) + dot(z, x);\n    float r = dot(z, y) + dot(x, z) + dot(y, x);\n    float s = dot(z, z) + dot(y, y) - 1.0;\n    float t = dot(z, x) + dot(z, y) + dot(y, z);\n    float u = dot(z, z) + dot(z, x) + dot(x, z);\n    float v = dot(z, z) + dot(z, y) + dot(y, z);\n    float w = dot(z, z) + dot(z, x) + dot(x, z);\n    float x1 = a * (c * e - d * d", "\n    return a / (b + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\nvec3 Rotate(vec3 p, float a, vec3 axis)\n{\n    if (axis.x == 1.0)\n        return RotateX(p, a);\n    if (axis.y == 1.0)\n        return RotateY(p, a);\n    if (axis.z == 1.0)\n        return RotateZ(p, a);\n    return p;\n}\n\n// Distances\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Cylinder(vec3 p, float r, float h)\n{\n    float d = length(p.xy) - r;\n    d = max(d, abs(p.z) - h);\n    return d;\n}\n\nfloat Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat Torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(", "\n\treturn 1.0 - pow(1.0 - x / R, 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float R)\n{\n\treturn 1.0 - pow(1.0 - length(x) / R, 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R)\n{\n\treturn 1.0 - pow(1.0 - length(x - R) / length(R), 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R, float3 C)\n{\n\treturn 1.0 - pow(1.0 - length(x - R) / length(R), 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R, float3 C, float3 N)\n{\n\treturn 1.0 - pow(1.0 - length(x - R) / length(R), 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R, float3 C, float3 N, float3 L)\n{\n\treturn 1.0 - pow(1.0 - length(x - R) / length(R), 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R, float3 C, float3 N, float3 L, float3 V)\n{\n\treturn 1.0 - pow(1.0 - length(x - R) / length(R), 3.0);\n}\n\n// Spherical falloff\n// x: distance\n// R: radius\nfloat Falloff(float3 x, float3 R, float3 C, float3 N, float3 L, float3 V, float", "\n\treturn 1.0f / (e * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0)\n{\n\treturn 1.0f / (e * R0);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1)\n{\n\treturn 1.0f / (e * R0 * R1);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1, float R2)\n{\n\treturn 1.0f / (e * R0 * R1 * R2);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1, float R2, float R3)\n{\n\treturn 1.0f / (e * R0 * R1 * R2 * R3);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1, float R2, float R3, float R4)\n{\n\treturn 1.0f / (e * R0 * R1 * R2 * R3 * R4);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R0, float R1, float R2, float R3, float R4, float R5)\n{\n\treturn 1.0f / (e * R0 * R1 * R2 * R3 * R4 * R5);\n}\n\n// Computes the global lipschitz bound of the", "\n\tfloat k = 0.0;\n\tfloat r = R;\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31*r;\n\tfloat r33 = r32*r;\n\tfloat r34 = r33*r;\n\tfloat r35 = r34*r;\n\tfloat r36 = r35*r;\n\tfloat r37 = r36*r;\n\tfloat r38 = r37*r;\n\tfloat r39 = r38*r;\n\tfloat r40 = r39*r;\n\tfloat r41", "\n\treturn 1.0 - smoothstep(R, R + e, length(p - c));\n}\n\n// Sphere\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Box\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Cylinder\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Torus\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// TorusKnot\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat TorusKnot(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Cone\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Capsule\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Capsule(vec3 p, vec3 c, float R, float e)\n{\n\treturn Vertex(p, c, R, e);\n}\n\n// Plane\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, float", "\n\tvec3 d = b - a;\n\tfloat l = length(d);\n\tfloat t = dot(c - a, d) / l;\n\tfloat s = clamp(t, 0.0, 1.0);\n\tvec3 p = a + d * s;\n\treturn VertexKPoint(c, R, e, p);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a triangle [a, b, c]\n// c: center\n// R: radius\n// e: energy\n// a: triangle start\n// b: triangle end\n// c: triangle end\nfloat VertexKTriangle(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 d = b - a;\n\tfloat l = length(d);\n\tfloat t = dot(c - a, d) / l;\n\tfloat s = clamp(t, 0.0, 1.0);\n\tvec3 p = a + d * s;\n\treturn VertexKPoint(c, R, e, p);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a tetrahedron [a, b, c, d]\n// c: center\n// R: radius\n// e: energy\n// a: tetrahedron start\n// b: tetrahedron end\n// c: tetrahedron end\n// d: tetrahedron end\nfloat VertexKTetrahedron(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\tvec3 d1 = b - a;\n\tvec3 d2 = c - a;\n\tvec3 d3 = d - a;\n\tfloat l1 = length(d1);\n\tfloat l2 = length(d2);\n\tfloat l3 = length(d3);\n\tfloat t1 = dot(c - a, d1) / l1;\n\tfloat t2 = dot(d - a, d2) / l2;\n\tfloat t3 = dot(d - a, d3) / l3;\n\tfloat s1 = clamp", "\n    float d = 1.0;\n    float t = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float c = 0.0;\n    float h = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n   ", "\n    vec3 r = b - a;\n    return dot(r, r);\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b)\n{\n    return sqrt(KSegment(a, b));\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r)\n{\n    return sqrt(KSegment(a, b)) - r;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2, float r3)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2 - r3;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2, float r3, float r4)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2 - r3 - r4;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2, float r3, float r4, float r5)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2 - r3 - r4 - r5;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2, float r3, float r4, float r5, float r6)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2 - r3 - r4 - r5 - r6;\n}\n\n// K distance\nfloat KDistance(vec3 a, vec3 b, float r1, float r2, float r3, float r4, float r5, float r6, float r7)\n{\n    return sqrt(KSegment(a, b)) - r1 - r2 - r3 - r4 - r5 - r6 - r7;\n}\n\n", "\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tObjectDistance(p + e.xyy) - ObjectDistance(p - e.xyy),\n\t\tObjectDistance(p + e.yxy) - ObjectDistance(p - e.yxy),\n\t\tObjectDistance(p + e.yyx) - ObjectDistance(p - e.yyx)) );\n}\n\n// Ray-marching\nfloat RayMarch(in vec3 ro, in vec3 rd, in float start, in float end, in float precis)\n{\n\tfloat res = -1.0;\n\tfloat t = start;\n\tfor(int i = 0; i < 128; i++)\n\t{\n\t\tfloat h = ObjectDistance(ro + rd * t);\n\t\tif(abs(h) < precis || t > end)\n\t\t{\n\t\t\tres = t;\n\t\t\tbreak;\n\t\t}\n\t\tt += h;\n\t}\n\treturn res;\n}\n\n// Ray-marching with shadows\nfloat RayMarchShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float precis)\n{\n\tfloat res = -1.0;\n\tfloat t = start;\n\tfor(int i = 0; i < 128; i++)\n\t{\n\t\tfloat h = ObjectDistance(ro + rd * t);\n\t\tif(abs(h) < precis || t > end)\n\t\t{\n\t\t\tres = t;\n\t\t\tbreak;\n\t\t}\n\t\tt += h;\n\t}\n\treturn res;\n}\n\n// Lighting\nvec3 Lighting(in vec3 p, in vec3 n, in vec3 l, in vec3 v, in vec3 c)\n{\n\tvec3 r = reflect(l, n);\n\tfloat dif = clamp(dot(n, l), 0.0, 1.0);\n\tfloat bac = clamp(dot(n, normalize(vec3(-l.x, l.y", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tstep = 0.0;\n    float tnext = 0.0;\n    float tprev = 0.0;\n    float tcur = 0.0;\n    float tlast = 0.0;\n    float tray = 0.0;\n    float traystep = 0.0;\n    float traynext = 0.0;\n    float trayprev = 0.0;\n    float traycur = 0.0;\n    float traylast = 0.0;\n    float traystep2 = 0.0;\n    float traynext2 = 0.0;\n    float trayprev2 = 0.0;\n    float traycur2 = 0.0;\n    float traylast2 = 0.0;\n    float traystep3 = 0.0;\n    float traynext3 = 0.0;\n    float trayprev3 = 0.0;\n    float traycur3 = 0.0;\n    float traylast3 = 0.0;\n    float traystep4 = 0.0;\n    float traynext4 = 0.0;\n    float trayprev4 = 0.0;\n    float traycur4 = 0.0;\n    float traylast4 = 0.0;\n    float traystep5 = 0.0;\n    float traynext5 = 0.0;\n    float trayprev5 = 0.0;\n    float traycur5 = 0.0;\n    float traylast5 = 0.0;\n    float traystep6 = 0.0;\n    float traynext6 = 0.0;\n    float trayprev6 = 0.0;\n    float traycur6 = 0.0;\n    float traylast6 = 0.0;\n    float traystep7 = 0.0;\n    float traynext7 = 0.0;", "\n    float t = 0.0;\n    s = 0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = o + t * u;\n        float d = DistanceField(p);\n        t += d;\n        s++;\n        if (d < 0.001)\n        {\n            h = true;\n            return t;\n        }\n    }\n    h = false;\n    return t;\n}\n\n// Ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayMarching(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = 0.0;\n    s = 0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = o + t * u;\n        float d = DistanceField(p);\n        t += d;\n        s++;\n        if (d < 0.001)\n        {\n            h = true;\n            return t;\n        }\n    }\n    h = false;\n    return t;\n}\n\n// Ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayMarching(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n    float t = 0.0;\n    s = 0;\n    for (int i = 0; i < 128; i++)\n    {\n        p = o + t * u;\n        float d = DistanceField(p);\n        t += d;\n        s++;\n        if (d < 0.001)\n        {\n            h = true;\n            return t;\n        }\n    }\n    h = false;\n    return t;\n}\n\n// Ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayMarching(vec3 o, vec3 u,", "\n\tvec3 c = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat weight = 0.0;\n\tfloat density = 0.0;\n\tfloat gradient = 0.0;\n\tfloat intercept = 0.0;\n\tfloat offset = 0.0;\n\tfloat previousDensity = 0.0;\n\tfloat previousOffset = 0.0;\n\tfloat previousGradient = 0.0;\n\tfloat previousIntercept = 0.0;\n\tfloat previousWeight = 0.0;\n\tfloat previousT = 0.0;\n\tfloat previousC = 0.0;\n\tfloat previousC2 = 0.0;\n\tfloat previousC3 = 0.0;\n\tfloat previousC4 = 0.0;\n\tfloat previousC5 = 0.0;\n\tfloat previousC6 = 0.0;\n\tfloat previousC7 = 0.0;\n\tfloat previousC8 = 0.0;\n\tfloat previousC9 = 0.0;\n\tfloat previousC10 = 0.0;\n\tfloat previousC11 = 0.0;\n\tfloat previousC12 = 0.0;\n\tfloat previousC13 = 0.0;\n\tfloat previousC14 = 0.0;\n\tfloat previousC15 = 0.0;\n\tfloat previousC16 = 0.0;\n\tfloat previousC17 = 0.0;\n\tfloat previousC18 = 0.0;\n\tfloat previousC19 = 0.0;\n\tfloat previousC20 = 0.0;\n\tfloat previousC21 = 0.0;\n\tfloat previousC22 = 0.0;\n\tfloat previousC23 = 0.0;\n\tfloat previousC24 = 0.0;\n\tfloat previousC25 = 0.0;\n\tfloat previousC26 = 0.0;\n\tfloat previousC27 = 0.0;\n\tfloat previousC28 = 0.0;\n\tfloat previousC29 = 0.0;\n\t", "\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 ba = b - a;\n  float h = clamp(dot(p - a, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(vec3(h, h * h, h * h * h)) - r;\n}\n\n// arbitrary orientation\nfloat sdConeSection(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 ba = b - a;\n  float h = clamp(dot(p - a, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(vec3(h, h * h, h * h * h)) - r;\n}\n\n// arbitrary orientation\nfloat sdConeFrustum(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 ba = b - a;\n  float h = clamp(dot(p - a, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(vec3(h, h * h, h * h * h)) - r;\n}\n\n// arbitrary orientation\nfloat sdConeFrustumSection(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 ba = b - a;\n  float h = clamp(dot(p - a, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(vec3(h, h * h, h * h * h)) - r;\n}\n\n// arbitrary orientation\nfloat sdConeFrustumSection(vec3 p, vec3 a, vec3 b, float r, float h)\n{\n  vec3 ba = b - a;\n  float h = clamp(", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y", "\n    return coord / vec2(textureSize(tex, 0));\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return coord / size;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return (coord - offset) / size;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord - offset) / size * scale;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation) {\n    vec2 center = size / 2.0;\n    vec2 p = (coord - offset) / size * scale;\n    p = rotate(p, rotation);\n    return p + center;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation, float angle) {\n    vec2 center = size / 2.0;\n    vec2 p = (coord - offset) / size * scale;\n    p = rotate(p, rotation);\n    p = rotate(p, angle);\n    return p + center;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation, float angle, float angle2) {\n    vec2 center = size / 2.0;\n    vec2 p = (coord - offset) / size * scale;\n    p = rotate(p, rotation);\n    p = rotate(p, angle);\n    p = rotate(p, angle2);\n    return p + center;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, float rotation, float angle, float angle2, float angle3) {\n    vec2 center = size / 2.0;\n    vec2 p = (coord - offset", "\n    vec2 a = p - q;\n    vec2 b = p - vec2(0.0, 1.0);\n    vec2 c = q - vec2(0.0, 1.0);\n    float s = clamp( dot(b,c)/dot(c,c), 0.0, 1.0 );\n    vec2  d = mix( b, c, s );\n    vec2  e = mix( a, d, s );\n    float f = clamp( dot(e,e), 0.0, 1.0 );\n    return vec3( f, e.x, e.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleEquilateral( in vec2 p, in vec2 q )\n{\n    vec2 a = p - q;\n    vec2 b = p - vec2(0.0, 1.0);\n    vec2 c = q - vec2(0.0, 1.0);\n    float s = clamp( dot(b,c)/dot(c,c), 0.0, 1.0 );\n    vec2  d = mix( b, c, s );\n    vec2  e = mix( a, d, s );\n    float f = clamp( dot(e,e), 0.0, 1.0 );\n    return vec3( f, e.x, e.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangleRight( in vec2 p, in vec2 q )\n{\n    vec2 a = p - q;\n    vec2 b = p - vec2(0.0, 1.0);\n    vec2 c = q - vec2(0.0,", "\n    float a = atan(p.y, p.x);\n    float r2 = r * r;\n    float d2 = d * d;\n    float rd = r * d;\n    float rd2 = rd * rd;\n    float a2 = a * a;\n    float a3 = a2 * a;\n    float a4 = a3 * a;\n    float a5 = a4 * a;\n    float a6 = a5 * a;\n    float a7 = a6 * a;\n    float a8 = a7 * a;\n    float a9 = a8 * a;\n    float a10 = a9 * a;\n    float a11 = a10 * a;\n    float a12 = a11 * a;\n    float a13 = a12 * a;\n    float a14 = a13 * a;\n    float a15 = a14 * a;\n    float a16 = a15 * a;\n    float a17 = a16 * a;\n    float a18 = a17 * a;\n    float a19 = a18 * a;\n    float a20 = a19 * a;\n    float a21 = a20 * a;\n    float a22 = a21 * a;\n    float a23 = a22 * a;\n    float a24 = a23 * a;\n    float a25 = a24 * a;\n    float a26 = a25 * a;\n    float a27 = a26 * a;\n    float a28 = a27 * a;\n    float a29 = a28 * a;\n    float a30 = a29 * a;\n    float a31 = a30 * a;\n    float a32 = a31 * a;\n    float a33 = a32 * a;\n    float a34 = a33 * a;\n    float a35 = a34 * a;\n    float a36 = a35 * a;\n    float a37 = a36 * a;\n    float", "\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float f = r * (1.0 - d / r) * (1.0 - d / r);\n    return vec3(f * c.x, f * c.y, f);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float f )\n{\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    float g = r * (1.0 - d / r) * (1.0 - d / r);\n    return vec3(g * c.x, g * c.y, g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float f, in float g )\n{\n    float a = atan(p.y, p.x);\n    float d = length(p);\n    return vec3(g * c.x, g * c.y, g);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float f, in float g, in float h )", "\n    vec3 e[3], n, t, b, r;\n    e[0] = vec3(v[1].x-v[0].x, v[1].y-v[0].y, 0.0);\n    e[1] = vec3(v[2].x-v[0].x, v[2].y-v[0].y, 0.0);\n    e[2] = vec3(p.x-v[0].x, p.y-v[0].y, 0.0);\n    n = cross(e[0], e[1]);\n    t = cross(e[2], e[1]);\n    b = cross(e[2], e[0]);\n    r = t*dot(n, vec3(0.0, 0.0, 1.0)) + b*dot(n, vec3(0.0, 1.0, 0.0)) + n*dot(n, vec3(1.0, 0.0, 0.0));\n    return r;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTriangle( in vec2 p, in vec2 v[3], in vec2 uv[3] )\n{\n    vec3 e[3], n, t, b, r;\n    e[0] = vec3(v[1].x-v[0].x, v[1].y-v[0].y, 0.0);\n    e[1] = vec3(v[2].x-v[0].x, v[2].y-v[0].y, 0.0);\n    e[2] = vec3(p.x-v[0].x, p.y-v[0].y, 0.0);\n    n = cross(e[0], e[1]);\n    t = cross(e[2], e[1]);\n    b = cross(e[2], e[", "\n    vec2 q = p - vec2(0.5);\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float b = atan(scb.y, scb.x);\n    float c = atan(sca.y, sca.x);\n    float d = atan(scb.y, scb.x) - atan(sca.y, sca.x);\n    float e = (a - b) / d;\n    float f = (r - ra) / (rb - ra);\n    float g = (r - ra) / (rb - ra);\n    float h = (r - ra) / (rb - ra);\n    float i = (r - ra) / (rb - ra);\n    float j = (r - ra) / (rb - ra);\n    float k = (r - ra) / (rb - ra);\n    float l = (r - ra) / (rb - ra);\n    float m = (r - ra) / (rb - ra);\n    float n = (r - ra) / (rb - ra);\n    float o = (r - ra) / (rb - ra);\n    float p = (r - ra) / (rb - ra);\n    float q = (r - ra) / (rb - ra);\n    float r = (r - ra) / (rb - ra);\n    float s = (r - ra) / (rb - ra);\n    float t = (r - ra) / (rb - ra);\n    float u = (r - ra) / (rb - ra);\n    float v = (r - ra) / (rb - ra);\n    float w = (r - ra) / (rb - ra);\n    float x = (r - ra) / (rb - ra);\n    float y = (r - ra) / (rb - ra);\n    float z = (r - ra) / (rb - ra);\n    float A = (r - ra) / (rb - ra);\n    float B = (r - ra) / (rb - ra);\n    float C = (r - ra) / (rb - ra);\n    float D = (r", "\n    return clamp( dot( a, b ) / dot( b, b ), 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) {\n    return clamp( dot( a, b ) / dot( b, b ), 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec4 a, in vec4 b ) {\n    return clamp( dot( a, b ) / dot( b, b ), 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec3 b ) {\n    return clamp( dot( a, b ) / dot( b, b ), 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) {\n    return clamp( dot( a, b ) / dot( b, b ), 0.0, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n    vec2 uv = p / ab;\n    float r = length( uv );\n    float a = atan( uv.y, uv.x );\n    float b = 1.0 - r;\n    float c = sqrt( 1.0 - b * b );\n    float x = a * c;\n    float y = b * c;\n    return vec3( x, y, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab, in vec2 cd )\n{\n    vec2 uv = p / ab;\n    float r = length( uv );\n    float a = atan( uv.y, uv.x );\n    float b = 1.0 - r;\n    float c = sqrt( 1.0 - b * b );\n    float x = a * c;\n    float y = b * c;\n    return vec3( x, y, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef )\n{\n    vec2 uv = p / ab;\n    float r = length( uv );\n    float a = atan( uv.y, uv.x );\n    float b = 1.0 - r;\n    float c = sqrt( 1.0 - b * b );\n    float x = a * c;\n    float y = b * c;\n    return vec3( x, y, 1.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f", "\n    vec3 q = vec3( length(p.xy)-ra, p.z );\n    return vec4( q.xy, rb-length(q), 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float r )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r);\n    return vec4( length(max(d,0.0)), d.x, d.y, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = max(r1-length(q), 0.0);\n    float d2 = max(r2-length(q), 0.0);\n    return vec4( (r2-r1)*d1-d2, q.x, q.y, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCapsule( vec3 p, float r1, float r2, float h )\n{\n    vec3 q = vec3( length(p.xz), p.y, abs(p.z)-h );\n", "\n    vec3 v = b - a;\n    float l = length( v );\n    vec3 n = v / l;\n    vec3 w = cross( n, vec3( 0.0, 0.0, 1.0 ) );\n    vec3 u = cross( w, n );\n    vec3 q = a + r * n;\n    vec3 s = p - q;\n    float c = dot( s, n );\n    float d = dot( s, u );\n    float e = dot( s, w );\n    float f = dot( s, s );\n    float g = dot( v, u );\n    float h = dot( v, w );\n    float i = dot( v, v );\n    float j = c * g - d * h;\n    float k = c * h - d * g;\n    float l = 1.0 / ( i * j - k * k );\n    float m = l * -k * e;\n    float n = l * ( i * f - j * d );\n    float o = l * j * c;\n    float p = l * ( j * d - i * f );\n    float q = l * k * c;\n    float r = l * ( k * e - j * d );\n    float s = l * i * c;\n    float t = l * ( i * d - j * e );\n    float u = l * j * e;\n    float v = l * ( j * e - k * d );\n    float w = l * k * e;\n    float x = l * ( k * d - i * e );\n    float y = l * i * e;\n    float z = l * ( i * e - j * d );\n    float A = m * m + n * n + o * o;\n    float B = m * p + n * q + o * r;\n    float C = m * s + n * t + o * u;\n    float D = m * v + n * w + o * x;\n    float E = m * y + n * z + o * A;\n    float F = m * B + n * C + o * D;\n    float G = m", "\n    vec2 p0 = vec2(-wi*.5,he*.5);\n    vec2 p1 = vec2( wi*.5,he*.5);\n    vec2 p2 = vec2( wi*.5,-he*.5);\n    vec2 p3 = vec2(-wi*.5,-he*.5);\n    vec2 q = vec2(sk*p.y,p.x);\n    vec2 d0 = p0 - q;\n    vec2 d1 = p1 - q;\n    vec2 d2 = p2 - q;\n    vec2 d3 = p3 - q;\n    vec2 m = max(vec2(d0.x,d2.x),vec2(d1.x,d3.x));\n    vec2 n = min(vec2(d0.x,d2.x),vec2(d1.x,d3.x));\n    vec2 e = max(vec2(d0.y,d2.y),vec2(d1.y,d3.y));\n    vec2 f = min(vec2(d0.y,d2.y),vec2(d1.y,d3.y));\n    float s = max(max(m.x,m.y),max(n.x,n.y));\n    float t = min(min(e.x,e.y),min(f.x,f.y));\n    return s-t;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2 p0 = vec2(-wi*.5,he*.5);\n    vec2 p1 = vec2( wi*.5,he*.5);\n    vec2 p2 = vec2( wi*.5,-he*.5);\n    vec2 p3 = vec2(-wi*.5,-he*.5);\n    vec2 q = vec2(sk*p.y,p.x);\n    vec2 d0 = p0 - q;\n    vec2 d1 = p1 - q;\n    vec2 d2", "\n    vec2 uv = p/vec2(wi,he);\n    vec2 uv2 = uv*2.0-1.0;\n    vec2 uv3 = uv2*vec2(1.0,sk);\n    vec3 p3 = vec3(uv3.x,uv3.y,1.0);\n    vec3 p4 = vec3(uv3.x,uv3.y,0.0);\n    vec3 p5 = vec3(uv3.x,uv3.y,sk);\n    vec3 p6 = vec3(uv3.x,uv3.y,-sk);\n    vec3 p7 = vec3(uv3.x,uv3.y,sk*2.0);\n    vec3 p8 = vec3(uv3.x,uv3.y,-sk*2.0);\n    vec3 p9 = vec3(uv3.x,uv3.y,sk*3.0);\n    vec3 p10 = vec3(uv3.x,uv3.y,-sk*3.0);\n    vec3 p11 = vec3(uv3.x,uv3.y,sk*4.0);\n    vec3 p12 = vec3(uv3.x,uv3.y,-sk*4.0);\n    vec3 p13 = vec3(uv3.x,uv3.y,sk*5.0);\n    vec3 p14 = vec3(uv3.x,uv3.y,-sk*5.0);\n    vec3 p15 = vec3(uv3.x,uv3.y,sk*6.0);\n    vec3 p16 = vec3(uv3.x,uv3.y,-sk*6.0);\n    vec3 p17 = vec3(uv3.x,uv3.y,sk*7.0);\n    vec3 p18 = vec3(uv3.x,uv3.y,-sk*7.0);\n    vec3 p19 = vec3(uv3.x,uv3.y,sk*8.0);\n    vec3 p20 = vec3(uv3.x,", "\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep7D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep8D( float p, float c )\n\t{\n\t\tfloat r = 0.0;\n\t\tfor( int i = 0; i < c; i++ )\n\t\t\tr += p;\n\t\treturn r;\n\t}\n\nfloat opRep9D( float p, float c )\n\t{\n\t\tfloat r = 0", "\n    return a * (1.0 - k) + b * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return a * (1.0 - k) + b * k;\n}\n\n// IQ's smoothstep\nfloat smoothstep(float a, float b, float x) {\n    float y = clamp((x - a) / (b - a), 0.0, 1.0);\n    return y * y * (3.0 - 2.0 * y);\n}\n\n// IQ's smoothmin\nfloat smoothmin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / (abs(b - a) + k), 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's smoothmax\nfloat smoothmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / (abs(b - a) + k), 0.0, 1.0);\n    return a + (b - a) * h * h * (3.0 - 2.0 * h);\n}\n\n// IQ's smoothmix\nfloat smoothmix(float a, float b, float x) {\n    float y = clamp((x - a) / (b - a), 0.0, 1.0);\n    return a + (b - a) * y * y * (3.0 - 2.0 * y);\n}\n\n// IQ's smoothtrianglemix\nfloat smoothtrianglemix(float a, float b, float x) {\n    float y = clamp((x - a) / (b - a), 0.0, 1.0);\n    return a + (b - a) * y * abs(y * 2.0 - 1.0);\n}\n\n// IQ's smoothsquaremix\nfloat smoothsquaremix(float a", "\n    vec2 halfsize = size * 0.5;\n    p = abs(p - halfsize) - halfsize;\n    return p;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - c.y;\n    float d2 = max(dot(q, c), q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1,", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsv(vec4 c) {\n    return rgb2hsv(c.rgb);\n}\n\nvec4 hsv2rgb(vec4 c) {\n    return vec4(hsv2rgb(c.rgb), c.a);\n}\n\nvec4 hsv2rgb(vec3 c) {\n    return vec4(hsv2rgb(c), 1.0);\n}\n\nvec3 rgb2hsl(vec3 c) {\n    vec3 rgb = c;\n    vec3 hsl = rgb;\n    float fmin = min(min(rgb.r, rgb.g), rgb.b);\n    float fmax = max(max(rgb.r, rgb.g), rgb.b);\n    float delta = fmax - fmin", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 s) {\n    float b = dot(ro - s.xyz, rd);\n    return vec2(b, b + s.w);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 bb) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * bb;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    float tN = max(max(tmin.x, tmin.y), tmin.z);\n    float tF = min(min(tmax.x, tmax.y), tmax.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2(tN, tF);\n}\n\n// IQ's ray capsule intersection\nvec2 rayCapsule(vec3 ro, vec3 rd, vec4 s) {\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n//", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n    float t = tNear;\n    if (tNear > tFar) {\n        t = tFar;\n        outNormal = -sign(rd) * step(tmin.yzx, tmin.xyz) * step(tmin.zxy, tmin.xyz);\n    } else {\n        outNormal = -sign(rd) * step(tmax.yzx, tmax.xyz) * step(tmax.zxy, tmax.xyz);\n    }\n    return vec2(t, tNear > tFar);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sp, float sr, out vec3 outNormal ) {\n    vec3 oc = ro - sp;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0, 0.0);\n    float t = -b - sqrt(h);\n    if (t < 0.0) return vec2(-1.0, 0.0);\n    outNormal = normalize(ro + t * rd - sp);\n    return vec2(t, 0.0);\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec3 planeNormal, float planeD, out vec3 outNormal ) {\n    float denom = dot(planeNormal, r", "\n    e1 = vec2(p.x - d.x, p.y);\n    e2 = vec2(p.x, p.y - d.y);\n    e3 = vec2(p.x + d.x, p.y);\n    e4 = vec2(p.x, p.y + d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    e1 = vec3(p.x - d.x, p.y, p.z);\n    e2 = vec3(p.x, p.y - d.y, p.z);\n    e3 = vec3(p.x + d.x, p.y, p.z);\n    e4 = vec3(p.x, p.y + d.y, p.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec4 p, vec4 d, inout vec4 e1, inout vec4 e2, inout vec4 e3, inout vec4 e4) {\n    e1 = vec4(p.x - d.x, p.y, p.z, p.w);\n    e2 = vec4(p.x, p.y - d.y, p.z, p.w);\n    e3 = vec4(p.x + d.x, p.y, p.z, p.w);\n    e4 = vec4(p.x, p.y + d.y, p.z, p.w);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, in", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    return linedist(p, a, b);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w) {\n    return linedist(p, a, b) - w;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2) {\n    return linedist(p, a, b) - w - w2;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2, float w3) {\n    return linedist(p, a, b) - w - w2 - w3;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2, float w3, float w4) {\n    return linedist(p, a, b) - w - w2 - w3 - w4;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2, float w3, float w4, float w5) {\n    return linedist(p, a, b) - w - w2 - w3 - w4 - w5;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2, float w3, float w4, float w5, float w6) {\n    return linedist(p, a, b) - w - w2 - w3 - w4 - w5 - w6;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w, float w2, float w3, float w4, float w5, float w6, float w7) {\n    return linedist(p, a, b) - w - w2 - w3 - w4 - w5 - w6 - w7;\n}", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max( length(pa-ba*h) - w1, abs(h*w2) - w2 );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow2( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max( length(pa-ba*h) - w1, abs(h*w2) - w2 );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow3( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max( length(pa-ba*h) - w1, abs(h*w2) - w2 );\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow4( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max( length(pa-ba*h) - w1, abs(h*w2) - w2 );\n}\n\n// The arrow goes from a to b. It's thickness is w1", "\n    vec2 q = vec2(length(rd.xz) - tor.x, rd.y);\n    vec2 k = vec2(rd.x, -rd.z);\n    vec2 d = q*vec2(k.y, k.x)/dot(k,k);\n    vec2 c = vec2(tor.x*tor.x - q.x*q.x, -q.y*q.y);\n    vec2 id = sign(d)*pow(abs(d), vec2(1.0));\n    float s = id.x*id.y/dot(k,k);\n    float t = s*q.x - id.y*c.x;\n    float u = s*q.y + id.x*c.y;\n    return (u < 0.0 || u > s)? -1.0 : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayCylinder(vec3 ro, vec3 rd, float rad) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    float h = b*b - a*c;\n    if (h < 0.0) return -1.0;\n    return (-b - sqrt(h))/a;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles", "\n    vec2 p = pos.xy - tor;\n    return normalize(vec3(length(p) - tor.x, pos.z, dot(p, p) - tor.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torus(vec3 ro, vec3 rd, vec2 tor) {\n    vec3 res = vec3(1e20, -1.0, 0.0);\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = ro + t * rd;\n        float l = length(p.xy) - tor.x;\n        float d = abs(p.z) - tor.y;\n        float s = l * l + d * d;\n        if (s < res.x) {\n            res.x = s;\n            res.y = t;\n            res.z = sign(d);\n        }\n        t += clamp(0.1 * s / dot(rd.xy, rd.xy), 0.025, 0.25);\n    }\n    return res;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torus(vec3 ro, vec3 rd, vec2 tor, float r) {\n    vec3 res = vec3(1e20, -1.0, 0.0);\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = ro + t * rd;\n        float l = length(p.xy) - tor.x;\n        float d = abs(p.z) - tor.y;\n        float s = l * l + d * d;\n        if (s < res.x) {\n            res.x = s;\n            res.y = t;", "\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_2(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_3(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_4(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_5(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_6(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_7(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_8(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_9(float x) {\n    return x * (27 + x * x) / (27 + 9 * x * x);\n}\n\n// License: Unknown, author: Unknown,", "\n    float gamma = 2.2;\n    float exposure = 1.0;\n    vec3 ret = pow(col, vec3(1.0 / gamma));\n    ret = ret * (exposure / (1.0 + ret));\n    return pow(ret, vec3(gamma));\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 z = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    vec3 c = ro + 1.5 * z;\n\n    // ray direction\n    vec3 rd = normalize(p.x * x + p.y * y + 1.5 * z);\n\n    // render\n    vec3 col = render(ro, rd);\n\n    // post process\n    col = postProcess(col, q);\n\n    // gamma\n    col = pow(col, vec3(0.4545));\n\n    // vignette\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2);\n\n    // output\n    gl_FragColor = vec4(col, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);", "\n    vec2 halfsize = size * 0.5;\n    p = abs(p - halfsize) - halfsize;\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat sdCone(vec3 p, vec2 c) {\n   ", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.0;\n    f += 0.5000 * noise(uv); uv *= 2.02;\n    f += 0.2500 * noise(uv); uv *= 2.03;\n    f += 0.1250 * noise(uv); uv *= 2.01;\n    f += 0.0625 * noise(uv); uv *= 2.02;\n    f += 0.0312 * noise(uv); uv *= 2.03;\n    f += 0.0156 * noise(uv); uv *= 2.01;\n    f += 0.0078 * noise(uv); uv *= 2.02;\n    f += 0.0039 * noise(uv); uv *= 2.03;\n    f += 0.0019 * noise(uv);\n    return f;\n}\n\nfloat fbm(vec2 uv, float lacunarity, float gain) {\n", "\n    return length(p-c)-r;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// signed distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec3 v0 = vec3(p1-p0, p2-p0);\n    vec3 v1 = vec3(p-p0, p-p1);\n    vec3 v2 = vec3(p-p1, p-p2);\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float width )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return abs( length( pa - ba*h ) - width );\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float width, float width2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return abs( length( pa - ba*h ) - width ) - width2;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float width, float width2, float width3 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return abs( length( pa - ba*h ) - width ) - width2 - width3;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float width, float width2, float width3, float width4 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return abs( length( pa - ba*h ) - width ) - width2 - width3 - width4;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec", "\n    vec2 p = a - b;\n    return dot(p, vec2(1.0, -1.0));\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ab = b - a;\n    vec2 bc = c - b;\n    vec2 ca = a - c;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    vec2 abp = cross(ab, ap);\n    vec2 bcp = cross(bc, cp);\n    vec2 cap = cross(ca, ap);\n    float s = sign(abp.x * bcp.y - bcp.x * abp.y);\n    return s * (abp.x * cap.y - cap.x * abp.y);\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float w) {\n    float d = tri(p, a, b, c);\n    return clamp(d / w, -1.0, 1.0);\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float w, in float h) {\n    float d = tri(p, a, b, c);\n    return clamp(d / (w * h), -1.0, 1.0);\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float w, in float h, in float d) {\n    float d1 = tri(p, a, b, c, w, h);\n    float d2 = tri(p, a, b, c, w, h, d);\n    return clamp(d1 - d2, -1.0, 1.0);\n}\n\nfloat tri(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float w, in float h, in float d, in float e) {\n    float d1 = tri(p, a, b, c", "\n    vec2 d = abs(p) - s + r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in float r ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in float a ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x - a;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in vec2 a ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x - a.x - a.y;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundRect( in vec2 p, in vec2 s, in vec2 r, in vec2 a, in float b ) \n{\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x", "\n    return x * (x * (x * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 tone_map(vec3 color)\n{\n    return s_curve(color);\n}\n\nvec3 reinhard(vec3 color)\n{\n    return color / (color + vec3(1.0));\n}\n\nvec3 uncharted2(vec3 color)\n{\n    const float W = 11.2;\n    const float exposureBias = 2.0;\n    const float whiteScale = 1.0 / 1.2;\n    const float linearWhite = 11.2;\n    vec3 curr = uncharted2_tonemap(exposureBias * color);\n    vec3 whiteScaleVec = vec3(1.0) / uncharted2_tonemap(vec3(W));\n    vec3 colorVec = curr * whiteScaleVec;\n    vec3 whiteScaleVec2 = vec3(1.0) / uncharted2_tonemap(vec3(linearWhite));\n    vec3 ret = uncharted2_tonemap(colorVec * whiteScaleVec2);\n    return ret;\n}\n\nvec3 filmic(vec3 color)\n{\n    const float a = 0.15;\n    const float b = 0.50;\n    const float c = 0.10;\n    const float d = 0.20;\n    const float e = 0.02;\n    const float f = 0.30;\n    const float w = 11.2;\n    return ((color*(a*color+b))/(color*(c*color+d)+e))-f/w;\n}\n\nvec3 srgb_to_linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}\n\nvec3 linear_to_srgb(vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\nvec3", "\n    return vec3(\n        x.y * (x.z + x.y - 1.0),\n        x.z * (1.0 - x.y),\n        x.y * (1.0 - x.z)\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y)\n{\n    return vec3(\n        y.y * (y.z + y.y - 1.0),\n        y.z * (1.0 - y.y),\n        y.y * (1.0 - y.z)\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z)\n{\n    return vec3(\n        z.y * (z.z + z.y - 1.0),\n        z.z * (1.0 - z.y),\n        z.y * (1.0 - z.z)\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z, vec3 w)\n{\n    return vec3(\n        w.y * (w.z + w.y - 1.0),\n        w.z * (1.0 - w.y),\n        w.y * (1.0 - w.z)\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z, vec3 w, vec3 v)\n{\n    return vec3(\n        v.y * (v.z + v.y - 1.0),\n        v.z * (1.0 - v.y),\n        v.y * (1.0 - v.z)\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z, vec3 w, vec3 v, vec3 u)\n{\n    return vec3(\n        u.y * (u.z + u.y - ", "\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = abs(a) - w*k;\n    return d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, float s )\n{\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = abs(a) - w*k;\n    return d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, float s, float t )\n{\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = abs(a) - w*k;\n    return d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, float s, float t, float b )\n{\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = abs(a) - w*k;\n    return d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, float s, float t, float b, float c )\n{\n    float a = atan(p.x, p.y);\n    float r = length(p);\n    float d = abs(a) - w*k;\n    return d;\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, float s, float t, float b, float c, float d )\n{\n    float a = atan(p.x, p.y);\n    float r = length(p);\n   ", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g)\n{\n    return exp(-opticalDepth * g);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g)\n{\n    return exp(-opticalDepth * g);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float g2)\n{\n    return exp(-opticalDepth * vec3(g, g, g2));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g2)\n{\n    return exp(-opticalDepth * vec3(g, g, g2));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float g2, float g3)\n{\n    return exp(-opticalDepth * vec3(g, g2, g3));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g2, vec3 g3)\n{\n    return exp(-opticalDepth * vec3(g, g2, g3));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float g, float g2, float g3, float g4)\n{\n    return exp(-opticalDepth * vec3(g, g2, g3, g4));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 g, vec3 g2, vec3 g3, vec3 g4)\n{\n    return exp(-opticalDepth * vec3(g, g2, g3, g4));\n}", "\n    // Initialize the scattering and transmittance to zero.\n    vec3 scattering = vec3(0.0);\n    transmittance = vec3(1.0);\n\n    // Initialize the optical depth accumulator.\n    float opticalDepth = 0.0;\n\n    // Initialize the step size of the ray march.\n    float stepSize = 1.0;\n\n    // Initialize the number of steps.\n    int numSteps = 0;\n\n    // Initialize the distance to the surface.\n    float distToSurface = 0.0;\n\n    // Initialize the distance to the light source.\n    float distToLight = 0.0;\n\n    // Initialize the distance to the next surface.\n    float distToNextSurface = 0.0;\n\n    // Initialize the distance to the next light source.\n    float distToNextLight = 0.0;\n\n    // Initialize the distance to the next step.\n    float distToNextStep = 0.0;\n\n    // Initialize the distance to the next transmittance step.\n    float distToNextTransmittanceStep = 0.0;\n\n    // Initialize the distance to the next scattering step.\n    float distToNextScatteringStep = 0.0;\n\n    // Initialize the distance to the next extinction step.\n    float distToNextExtinctionStep = 0.0;\n\n    // Initialize the distance to the next absorption step.\n    float distToNextAbsorptionStep = 0.0;\n\n    // Initialize the distance to the next scattering event.\n    float distToNextScatteringEvent = 0.0;\n\n    // Initialize the distance to the next absorption event.\n    float distToNextAbsorptionEvent = 0.0;\n\n    // Initialize the distance to the next transmittance event.\n    float distToNextTransmittanceEvent = 0.0;\n\n    // Initialize the distance to the next extinction event.\n    float distToNextExtinctionEvent = 0.0;\n\n    // Initialize the distance to the next light source event.\n    float distToNextLightEvent = 0.0;\n\n    // Initialize the distance to the", "\n    vec3 p = p2;\n    float r = ra;\n    float r2 = rb;\n    float d2 = d;\n    float b = 2.0 * (r - r2) / d2;\n    float a = sqrt( 1.0 - b * b );\n    vec3 p1 = p - vec3( a, 0.0, 0.0 );\n    vec3 p2 = p - vec3( 0.0, 0.0, a );\n    vec3 p3 = p - vec3( 0.0, a, 0.0 );\n    vec3 p4 = p - vec3( a, 0.0, 0.0 );\n    vec3 p5 = p - vec3( 0.0, 0.0, a );\n    vec3 p6 = p - vec3( 0.0, a, 0.0 );\n    float d1 = length( p1 ) - r;\n    float d2 = length( p2 ) - r;\n    float d3 = length( p3 ) - r;\n    float d4 = length( p4 ) - r;\n    float d5 = length( p5 ) - r;\n    float d6 = length( p6 ) - r;\n    float dmin = min( min( min( min( min( d1, d2 ), d3 ), d4 ), d5 ), d6 );\n    return dmin;\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d )\n{\n    return sdDeathStar( p, ra, rb, d );\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, in float rb )\n{\n    return sdDeathStar( p, ra, rb, 1.0 );\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d", "\n    float d = sdSphere( p, r );\n    return d - h - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    float d = sdSphere( p, r );\n    return d - h;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\n    float d = sdCylinder( p, r, h );\n    return d - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutCylinder( vec3 p, float r, float h, float t )\n{\n    float d = sdCylinder( p, r, h );\n    return d - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCone( vec3 p, float r, float h, float t )\n{\n    float d = sdCone( p, r, h );\n    return d - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutCone( vec3 p, float r, float h, float t )\n{\n    float d = sdCone( p, r, h );\n    return d - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowTorus( vec3 p, float r, float h, float t )\n{\n    float d = sdTorus( p, r, h );\n    return d - t;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutTorus( vec3 p, float r, float", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/", "\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    return length(p-vec3(0.0,h,0.0))-r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec3(q,p.z,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( vec3 p", "\n    return length(p)-r-h;\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec3 p, in float r, in float h )\n{\n    return max(length(p.xy)-r, abs(p.z)-h);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec3 p, in float r, in float h )\n{\n    float q = length(p.xy);\n    return max(q-r, abs(p.z)-h);\n}\n\n// r=radius, h=height\nfloat sdCutTorus( in vec3 p, in float r, in float h )\n{\n    return length(vec2(length(p.xy)-r, abs(p.z)-h));\n}\n\n// r=radius, h=height\nfloat sdCutCapsule( in vec3 p, in float r, in float h )\n{\n    return max(length(p.xy)-r, abs(p.z)-h);\n}\n\n// r=radius, h=height\nfloat sdCutCapsule( in vec3 p, in float r, in float h, in float c )\n{\n    return max(length(p.xy)-r, abs(p.z)-h-c);\n}\n\n// r=radius, h=height\nfloat sdCutCapsule( in vec3 p, in float r, in float h, in float c, in float a )\n{\n    return max(length(p.xy)-r, abs(p.z)-h-c-a);\n}\n\n// r=radius, h=height\nfloat sdCutCapsule( in vec3 p, in float r, in float h, in float c, in float a, in float b )\n{\n    return max(length(p.xy)-r, abs(p.z)-h-c-a-b);\n}\n\n// r=radius, h=height\nfloat sdCutCapsule( in vec3 p, in float r, in float h, in float c, in float a, in float b, in float d )\n{\n    return max(length", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// 3d fractal noise function\nfloat fractalNoise( in vec3 x )\n{\n    float f = 0.0;\n    float w = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += w*noise(x);\n        w *= 0.5;\n        x = x*2.01;\n    }\n    return f;\n}\n\n// 3d fractal noise function\nfloat fractalNoise( in vec3 x, float w )\n{\n    float f = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += w*noise(x);\n        w *= 0.5;\n        x = x*2.01;\n    }\n    return f;\n}\n\n// 3d fractal noise function\nfloat fractalNoise( in vec3 x, float w, float f )\n{\n    float f = 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        f += w*noise(x);\n        w *= f;\n        x = x*2.01;\n    }", "\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * 2.02;\n    f += 0.2500 * noise( p ); p = m * p * 2.03;\n    f += 0.1250 * noise( p ); p = m * p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * 2.02;\n    f += 0.2500 * noise( p ); p = m * p * 2.03;\n    f += 0.1250 * noise( p ); p = m * p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec4 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * 2.02;\n    f += 0.2500 * noise( p ); p = m * p * 2.03;\n    f += 0.1250 * noise( p ); p = m * p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec2 p, float freq )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * freq;\n    f += 0.2500", "\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash32(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash33(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash34(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash35(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash36(vec3 p3)\n{\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise hash\nfloat hash37(vec3 p3)\n{\n    p3  = fract", "\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float u", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsv(vec3 c, float max, float min) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.", "\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = fract(p + halfsize + size * c);\n    return c;\n}\n\nfloat mod2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size * 0.5;\n    vec2 c = floor((p + halfsize) / size);\n    p = fract(p + halfsize + size * c);\n    return c.x * size.y + c.y;\n}\n\nfloat mod2(inout vec2 p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p.x + halfsize) / size);\n    p.x = fract(p.x + halfsize + size * c);\n    return c;\n}\n\nfloat mod3(inout vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    vec3 c = floor((p + halfsize) / size);\n    p = fract(p + halfsize + size * c);\n    return c.x * size.y + c.y * size.z + c.z;\n}\n\nfloat mod3(inout vec3 p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p.x + halfsize) / size);\n    p.x = fract(p.x + halfsize + size * c);\n    return c;\n}\n\nfloat mod4(inout vec4 p, vec4 size) {\n    vec4 halfsize = size * 0.5;\n    vec4 c = floor((p + halfsize) / size);\n    p = fract(p + halfsize + size * c);\n    return c.x * size.y + c.y * size.z + c.z * size.w + c.w;\n}\n\nfloat mod4(inout vec4 p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p.x + halfsize) / size);\n    p.x", "\n    return fract(sin(co) * 10000.0);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0;\n    float res = mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n    return res;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nfloat fbm(vec2 p, float freq) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * freq;\n    f += 0.2500 * noise(p); p = p * freq;\n    f += 0.1250 * noise(p); p = p * freq;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nfloat fbm(vec2 p, float freq, float amp) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * freq;\n    f += 0.2500 * noise(p); p = p * freq;\n    f += 0.1250 * noise(p); p", "\n    return t < 0.0031308? t * 12.92 : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec3 sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return pow(t, vec3(gamma));\n}\n\nvec3 sRGB(vec3 t, vec3 gamma) {\n    return pow(t, gamma);\n}\n\nvec3 sRGB(vec3 t, float gammaR, float gammaG, float gammaB) {\n    return vec3(sRGB(t.r, gammaR), sRGB(t.g, gammaG), sRGB(t.b, gammaB));\n}\n\nvec3 sRGB(vec3 t, vec3 gammaR, vec3 gammaG, vec3 gammaB) {\n    return vec3(sRGB(t.r, gammaR), sRGB(t.g, gammaG), sRGB(t.b, gammaB));\n}\n\nvec3 sRGB(vec3 t, float gammaR, float gammaG, float gammaB, float offsetR, float offsetG, float offsetB) {\n    return vec3(sRGB(t.r, gammaR, offsetR), sRGB(t.g, gammaG, offsetG), sRGB(t.b, gammaB, offsetB));\n}\n\nvec3 sRGB(vec3 t, vec3 gammaR, vec3 gammaG, vec3 gammaB, vec3 offsetR, vec3 offsetG, vec3 offsetB) {\n    return vec3(sRGB(t.r, gammaR, offsetR), sRGB(t.g, gammaG, offsetG), sRGB(t.b, gammaB, offsetB));\n}\n\nvec3 sRGB(vec3 t, float gammaR, float gammaG, float gammaB, float offsetR, float offsetG", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec3 sRGB(in vec3 c, in float gamma) {\n    return pow(c, vec3(1.0 / gamma));\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma) {\n    return pow(c, gamma);\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float exposure) {\n    return sRGB(c * exposure, gamma);\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma, in float exposure) {\n    return sRGB(c * exposure, gamma);\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in vec3 exposure) {\n    return sRGB(c * exposure, gamma);\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma, in vec3 exposure) {\n    return sRGB(c * exposure, gamma);\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float exposure, in float offset) {\n    return sRGB(c * exposure + offset, gamma);\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma, in float exposure, in float offset) {\n    return sRGB(c * exposure + offset, gamma);\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in vec3 exposure, in float offset) {\n    return sRGB(c * exposure + offset, gamma);\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma, in vec3 exposure, in float offset) {\n    return sRGB(c * exposure + offset, gamma);\n}\n\nvec3 sRGB(in vec3 c, in float gamma, in float exposure, in vec3 offset) {\n    return sRGB(c * exposure + offset, gamma);\n}\n\nvec3 sRGB(in vec3 c, in vec3 gamma, in float exposure, in vec3 offset) {\n    return s", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * (1.0 - h) * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * (1.0 - h) * (1.0 - h) * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * h * (3.0 - 2.0 * h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0.0, 1.0);\n    return mix(b.x, a.x, h) - k * (1", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    return h > dbuffer? h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat spheres(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    return h > dbuffer? h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat spheres(vec3 ro, vec3 rd, vec4 sph, float dbuffer, out float t) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    t = h > dbuffer? h : -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat spheres(vec3 ro, vec3 rd, vec4 sph, float dbuffer, out float t, out float id) {\n    vec3 oc = ro - sph.xyz;\n", "\n    float t = iTime;\n    float a = 0.5;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.5;\n    float e = 0.5;\n    float f = 0.5;\n    float g = 0.5;\n    float h = 0.5;\n    float i = 0.5;\n    float j = 0.5;\n    float k = 0.5;\n    float l = 0.5;\n    float m = 0.5;\n    float n = 0.5;\n    float o = 0.5;\n    float p = 0.5;\n    float q = 0.5;\n    float r = 0.5;\n    float s = 0.5;\n    float t = 0.5;\n    float u = 0.5;\n    float v = 0.5;\n    float w = 0.5;\n    float x = 0.5;\n    float y = 0.5;\n    float z = 0.5;\n    float aa = 0.5;\n    float bb = 0.5;\n    float cc = 0.5;\n    float dd = 0.5;\n    float ee = 0.5;\n    float ff = 0.5;\n    float gg = 0.5;\n    float hh = 0.5;\n    float ii = 0.5;\n    float jj = 0.5;\n    float kk = 0.5;\n    float ll = 0.5;\n    float mm = 0.5;\n    float nn = 0.5;\n    float oo = 0.5;\n    float pp = 0.5;\n    float qq = 0.5;\n    float rr = 0.5;\n    float ss = 0.5;\n    float tt = 0.5;\n    float uu = 0.5;\n    float vv = 0.5;\n    float ww = 0.5;\n   ", "\n    vec3 q = p / r;\n    vec4 v = vec4( q.x, q.y, q.z, 1.0 );\n    v.xyz = normalize( v.xyz );\n    v.w = length( p );\n    return v;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, vec3 c )\n{\n    vec3 q = p / r;\n    vec4 v = vec4( q.x, q.y, q.z, 1.0 );\n    v.xyz = normalize( v.xyz );\n    v.w = length( p - c );\n    return v;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, vec3 c, vec3 n )\n{\n    vec3 q = p / r;\n    vec4 v = vec4( q.x, q.y, q.z, 1.0 );\n    v.xyz = normalize( v.xyz );\n    v.w = length( p - c );\n    return v;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r, vec3 c, vec3 n, float b )\n{\n    vec3 q = p /", "\n    return front * front.a + back * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 additiveBlend(vec4 back, vec4 front) {\n    return front + back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 subtractiveBlend(vec4 back, vec4 front) {\n    return back - front;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 multiplyBlend(vec4 back, vec4 front) {\n    return back * front;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 screenBlend(vec4 back, vec4 front) {\n    return back + front - back * front;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 overlayBlend(vec4 back, vec4 front) {\n    return vec4(\n        back.r < 0.5? 2.0 * back.r * front.r : 1.0 - 2.0 * (1.0 - back.r) * (1.0 - front.r),\n        back.g < 0.5? 2.0 * back.g * front.g : 1.0 - 2.0 * (1.0 - back.g) * (1.0 - front.g),\n        back.b < 0.5? 2.0 * back.b * front.b : 1.0 - 2.0 * (1.0 - back.b) * (1.0 - front.b),\n        back.a\n    );\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 softLightBlend(vec4 back, vec4 front) {\n    return vec4(\n        back.r < 0.5? back.r * (1.0 - front.r) * (1.0 - front.r) * 2.0 + front.r : back.r * (sqrt(back.r) -", "\n    return back * (1.0 - front.a) + front.rgb * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return back * (1.0 - front.a) + front * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n    return back * (1.0 - front.a) + front;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front) {\n    return back * (1.0 - front.a) + vec4(front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec2 front) {\n    return back * (1.0 - front.a) + vec4(front, 0.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, float front) {\n    return back * (1.0 - front) + vec4(front, front, front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, int front) {\n    return back * (1.0 - front) + vec4(front, front, front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, bool front) {\n    return back * (1.0 - front) + vec4(front, front, front, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n    return back * (1.0 - front.a) + front.rgb * front.a", "\n    p = abs(p);\n    return max(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, 0.5)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h ) {\n    p = abs(p);\n    return max(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, 0.5)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s ) {\n    p = abs(p);\n    return max(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, 0.5)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s, float a ) {\n    p = abs(p);\n    return max(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, 0.5)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s, float a, float b ) {\n    p = abs(p);\n    return max(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, 0.5)));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s, float a, float b, float c ) {\n    p = abs(p", "\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard(vec3 v) {\n    return v / (1.0f + v);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 reinhard_extended(vec3 v) {\n    const float white = 4.0f;\n    return v / (1.0f + v/white);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 uncharted2(vec3 v) {\n    const float A = 0.15f;\n    const float B = 0.50f;\n    const float C = 0.10f;\n    const float D = 0.20f;\n    const float E = 0.02f;\n    const float F = 0.30f;\n    const float W = 11.2f;\n    return ((v*(A*v+C*B)+D*E)/(v*(A*v+B)+D*F))-E/F;\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 filmic(vec3 v) {\n    const float W = 11.2f;\n    const float exposure_adjust = 2.0f;\n    vec3 curr = max((v", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash2(i);\n    float b = hash2(i + vec2(1.0, 0.0));\n    float c = hash2(i + vec2(0.0, 1.0));\n    float d = hash2(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n    //                 mix(c, d, smoothstep(0.0, 1.0, f.x)),\n    //                 smoothstep(0.0, 1.0, f.y)));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p", "\n    float t = Temp;\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t2*t4;\n    float t7 = t2*t5;\n    float t8 = t2*t6;\n    float t9 = t2*t7;\n    float t10 = t2*t8;\n    float t11 = t2*t9;\n    float t12 = t2*t10;\n    float t13 = t2*t11;\n    float t14 = t2*t12;\n    float t15 = t2*t13;\n    float t16 = t2*t14;\n    float t17 = t2*t15;\n    float t18 = t2*t16;\n    float t19 = t2*t17;\n    float t20 = t2*t18;\n    float t21 = t2*t19;\n    float t22 = t2*t20;\n    float t23 = t2*t21;\n    float t24 = t2*t22;\n    float t25 = t2*t23;\n    float t26 = t2*t24;\n    float t27 = t2*t25;\n    float t28 = t2*t26;\n    float t29 = t2*t27;\n    float t30 = t2*t28;\n    float t31 = t2*t29;\n    float t32 = t2*t30;\n    float t33 = t2*t31;\n    float t34 = t2*t32;\n    float t35 = t2*t33;\n    float t36 = t2*t34;\n    float t37 = t2*t35;\n    float t38 = t2*t36;\n    float t39 = t", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n    //                 mix(c, d, smoothstep(0.0, 1.0, f.x)),\n    //                 smoothstep(0.0, 1.0, f.y)));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat turbulence(vec2 p) {\n    float f = 0.0;", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, float rad) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, float rad, out float t) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    t = -b - h;\n    return vec2(t, t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, float rad, out float t1, out float t2) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad * rad;\n    float h = b * b - c;\n    if (", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float b = 1.0 / n;\n    float c = r - b;\n    float d = r + b;\n    float e = a - b;\n    float f = a + b;\n    float g = c * c * c * c * c;\n    float h = d * d * d * d * d;\n    float i = e * e * e * e * e;\n    float j = f * f * f * f * f;\n    float k = g * h * i * j;\n    float l = 1.0 / k;\n    float m = 1.0 / (1.0 + l);\n    float n = 1.0 - m;\n    float o = 1.0 / (1.0 + l * l);\n    float p = 1.0 - o;\n    float q = 1.0 / (1.0 + l * l * l);\n    float r = 1.0 - q;\n    float s = 1.0 / (1.0 + l * l * l * l);\n    float t = 1.0 - s;\n    float u = 1.0 / (1.0 + l * l * l * l * l);\n    float v = 1.0 - u;\n    float w = 1.0 / (1.0 + l * l * l * l * l * l);\n    float x = 1.0 - w;\n    float y = 1.0 / (1.0 + l * l * l * l * l * l * l);\n    float z = 1.0 - y;\n    float A = 1.0 / (1.0 + l * l * l * l * l * l * l * l);\n    float B = 1.0 - A;\n    float C = 1.0 / (1.0 + l * l * l * l * l * l * l * l * l);\n    float D = 1.0 - C;\n    float E = 1.0 / (1.0 + l * l * l *", "\n    float a = 0.5 * (x + t);\n    float b = 0.5 * (x - t);\n    return 0.5 * (cantor(a, t) + cantor(b, t));\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x )\n{\n    return cantor(x, 0.125);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t, float n )\n{\n    float a = 0.5 * (x + t);\n    float b = 0.5 * (x - t);\n    return 0.5 * (cantor(a, t, n) + cantor(b, t, n));\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float n )\n{\n    return cantor(x, 0.125, n);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t, float n, float m )\n{\n    float a = 0.5 * (x + t);\n    float b = 0.5 * (x - t);\n    return 0.5 * (cantor(a, t, n, m) + cantor(b, t, n, m));\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float n, float m )\n{\n    return cantor(x, 0.125, n, m);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t, float n, float m, float p )\n{\n    float a = 0.5 * (x + t);\n    float b = 0.5 * (x - t);\n    return 0.5 * (cantor(a, t, n, m, p) + cantor(b, t, n, m, p));\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float n, float m, float p", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    vec2 k1 = vec2( ab.x, 0.0 );\n    vec2 k2 = vec2( 0.0, ab.y );\n    vec2 ca = vec2( ab.x*ab.x, ab.y*ab.y );\n    vec2 pk = vec2( dot(p,k1), dot(p,k2) );\n    vec2 d = vec2( ca.x*ab.y*ab.y - ca.y*ab.x*ab.x,\n                   ca.x*ab.x*ab.x + ca.y*ab.y*ab.y );\n    float a = dot(pk,pk)/dot(d,d);\n    float b = dot(pk,d);\n    float c = dot(d,d);\n    float h = clamp( 0.5 - a/(3.0*c), 0.0, 1.0 );\n    float r = clamp( sqrt( clamp( h, 0.0, 1.0 )*(2.0*c - 3.0*b + 2.0*a*h)/(3.0*a - b - b*h) ), 0.0, 1.0 );\n    return length(p-r*k1) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n", "\n    float d = 0.0;\n    float t = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.", "\n    float k = 0.1591;\n    float f = 0.3275;\n    float g = 5.4773;\n    float a = 0.785398;\n    float b = 1.82125;\n    float c = 1.33225;\n    float d = 0.930733;\n    float e = 0.459467;\n    float h = 0.205287;\n    float i = 0.036955;\n    float j = 0.004277;\n    float l = 0.000182;\n    float m = 0.000012;\n    float n = 0.00000012;\n    float p = 0.00000000072;\n    float q = 0.00000000000045;\n    float r = 0.00000000000000021;\n    float s = 0.00000000000000000067;\n    float t = 0.0000000000000000000009;\n    float u = 0.0000000000000000000000015;\n    float v = 0.000000000000000000000000003;\n    float w = 0.0000000000000000000000000000007;\n    float x1 = 1.0 / (1.0 + k * abs(y));\n    float x2 = 1.0 / (1.0 + f * abs(y));\n    float x3 = 1.0 / (1.0 + g * abs(y));\n    float", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\nvec2 catanh(vec2 z) {\n    return vec2(log(z.x + sqrt(1.0 + z.x*z.x)), atan(z.y, z.x));\n}\nvec2 ctanh(vec2 z) {\n    return vec2(log(1.0 + z.x), z.y);\n}\nvec2 ctan(vec2 z) {\n    return vec2(z.y, z.x);\n}\nvec2 csinh(vec2 z) {\n    return vec2(z.x, z.y + log(1.0 + z.x));\n}\nvec2 ccosh(vec2 z) {\n    return vec2(z.x + log(1.0 + z.x), z.y);\n}\nvec2 csin(vec2 z) {\n    return vec2(z.y, -z.x);\n}\nvec2 ccos(vec2 z) {\n    return vec2(-z.y, z.x);\n}\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x), z.y);\n}\nvec2 clog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\nvec2 cpow(vec2 z, vec2 w) {\n    return cexp(w*clog(z));\n}\nvec2 csqrt(vec2 z) {\n    return cexp(0.5*clog(z));\n}\nvec2 cabs(vec2 z) {\n    return vec2(length(z), atan(z.y, z.x));\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x*w.x - z.y*", "\n    return vec2(0.5) * log((vec2(1.0) + z) / (vec2(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z) {\n    return vec3(0.5) * log((vec3(1.0) + z) / (vec3(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z) {\n    return vec4(0.5) * log((vec4(1.0) + z) / (vec4(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z, out vec2 dz_over_dz) {\n    dz_over_dz = vec2(0.5) * (vec2(1.0) - z) * (vec2(1.0) + z);\n    return vec2(0.5) * log((vec2(1.0) + z) / (vec2(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec3 catanh(vec3 z, out vec3 dz_over_dz) {\n    dz_over_dz = vec3(0.5) * (vec3(1.0) - z) * (vec3(1.0) + z);\n    return vec3(0.5) * log((vec3(1.0) + z) / (vec3(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec4 catanh(vec4 z, out vec4 dz_over_dz) {\n    dz_over_dz = vec4(0.5) * (vec4(1.0) - z) * (vec4(1.0) + z);\n    return vec4(0.5) * log((vec4(1.0) + z) / (vec4(1.0) - z));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z, out dvec2 dz_over_dz) {\n    dz_", "\n    float x = z.x;\n    float y = z.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float r = sqrt(x2 + y2);\n    float phi = atan(y, x);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r4 * r4;\n    float r10 = r8 * r2;\n    float r12 = r8 * r4;\n    float r14 = r12 * r2;\n    float r16 = r12 * r4;\n    float r18 = r16 * r2;\n    float r20 = r16 * r4;\n    float r22 = r18 * r2;\n    float r24 = r18 * r4;\n    float r26 = r22 * r2;\n    float r28 = r22 * r4;\n    float r30 = r24 * r2;\n    float r32 = r24 * r4;\n    float r34 = r26 * r2;\n    float r36 = r26 * r4;\n    float r38 = r28 * r2;\n    float r40 = r28 * r4;\n    float r42 = r30 * r2;\n    float r44 = r30 * r4;\n    float r46 = r32 * r2;\n    float r48 = r32 * r4;\n    float r50 = r34 * r2;\n    float r52 = r34 * r4;\n    float r54 = r36 * r2;\n    float r56 = r36 * r4;\n    float r58 = r38 * r2;\n    float r60 = r38 * r4;\n    float r62 = r40 * r2;\n    float r64 = r40 * r4;\n    float r66 = r42 *", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\nvec2 cpow(vec2 z, float n) {\n    vec2 w = vec2(cos(n), sin(n));\n    return cmul(z, w);\n}\nvec2 catanh(vec2 z) {\n    vec2 w = vec2(1.0, 1.0);\n    vec2 z2 = cmul(z, z);\n    vec2 z3 = cmul(z2, z);\n    vec2 z4 = cmul(z3, z);\n    vec2 z5 = cmul(z4, z);\n    vec2 z6 = cmul(z5, z);\n    vec2 z7 = cmul(z6, z);\n    vec2 z8 = cmul(z7, z);\n    vec2 z9 = cmul(z8, z);\n    vec2 z10 = cmul(z9, z);\n    vec2 z11 = cmul(z10, z);\n    vec2 z12 = cmul(z11, z);\n    vec2 z13 = cmul(z12, z);\n    vec2 z14 = cmul(z13, z);\n    vec2 z15 = cmul(z14, z);\n    vec2 z16 = cmul(z15, z);\n    vec2 z17 = cmul(z16, z);\n    vec2 z18 = cmul(z17, z);\n    vec2 z19 = cmul(z18, z);\n    vec2 z20 = cmul(z19, z);\n    vec2 z21 = cmul(z20, z);\n    vec2 z22 = cmul(z21, z);\n    vec2 z23 = cmul(z22, z);\n    vec2 z24 = cmul(z23, z);\n    vec2 z25 = cmul(z24, z);\n    vec2 z26 = cmul", "\n    float x = z.x;\n    float y = z.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float r = sqrt(x2 + y2);\n    float phi = atan(y, x);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r4 * r4;\n    float r10 = r8 * r2;\n    float r12 = r8 * r4;\n    float r14 = r12 * r2;\n    float r16 = r12 * r4;\n    float r18 = r16 * r2;\n    float r20 = r16 * r4;\n    float r22 = r18 * r2;\n    float r24 = r18 * r4;\n    float r26 = r22 * r2;\n    float r28 = r22 * r4;\n    float r30 = r24 * r2;\n    float r32 = r24 * r4;\n    float r34 = r26 * r2;\n    float r36 = r26 * r4;\n    float r38 = r28 * r2;\n    float r40 = r28 * r4;\n    float r42 = r30 * r2;\n    float r44 = r30 * r4;\n    float r46 = r32 * r2;\n    float r48 = r32 * r4;\n    float r50 = r34 * r2;\n    float r52 = r34 * r4;\n    float r54 = r36 * r2;\n    float r56 = r36 * r4;\n    float r58 = r38 * r2;\n    float r60 = r38 * r4;\n    float r62 = r40 * r2;\n    float r64 = r40 * r4;\n    float r66 = r42 *", "\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, vec3 contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n  return (alpha - 0.5) * contrast + 0.5;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calcul", "\n    float d = 1.0;\n    float r = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    float r4 = 1.0;\n    float r5 = 1.0;\n    float r6 = 1.0;\n    float r7 = 1.0;\n    float r8 = 1.0;\n    float r9 = 1.0;\n    float r10 = 1.0;\n    float r11 = 1.0;\n    float r12 = 1.0;\n    float r13 = 1.0;\n    float r14 = 1.0;\n    float r15 = 1.0;\n    float r16 = 1.0;\n    float r17 = 1.0;\n    float r18 = 1.0;\n    float r19 = 1.0;\n    float r20 = 1.0;\n    float r21 = 1.0;\n    float r22 = 1.0;\n    float r23 = 1.0;\n    float r24 = 1.0;\n    float r25 = 1.0;\n    float r26 = 1.0;\n    float r27 = 1.0;\n    float r28 = 1.0;\n    float r29 = 1.0;\n    float r30 = 1.0;\n    float r31 = 1.0;\n    float r32 = 1.0;\n    float r33 = 1.0;\n    float r34 = 1.0;\n    float r35 = 1.0;\n    float r36 = 1.0;\n    float r37 = 1.0;\n    float r38 = 1.0;\n    float r39 = 1.0;\n    float r40 = 1.0;\n    float r41 = 1.0;\n    float r42 = 1.0;\n    float r43 = ", "\n    float u = uvw.x;\n    float v = uvw.y;\n    float w = uvw.z;\n    float u2 = u*u;\n    float v2 = v*v;\n    float w2 = w*w;\n    float uv = u*v;\n    float uw = u*w;\n    float vw = v*w;\n    float uv2 = uv*uv;\n    float uw2 = uw*uw;\n    float vw2 = vw*vw;\n    float uvw = uv*w;\n    float uvw2 = uvw*uvw;\n    float uvw3 = uvw2*uvw;\n    float uvw4 = uvw3*uvw;\n    float uvw5 = uvw4*uvw;\n    float uvw6 = uvw5*uvw;\n    float uvw7 = uvw6*uvw;\n    float uvw8 = uvw7*uvw;\n    float uvw9 = uvw8*uvw;\n    float uvw10 = uvw9*uvw;\n    float uvw11 = uvw10*uvw;\n    float uvw12 = uvw11*uvw;\n    float uvw13 = uvw12*uvw;\n    float uvw14 = uvw13*uvw;\n    float uvw15 = uvw14*uvw;\n    float uvw16 = uvw15*uvw;\n    float uvw17 = uvw16*uvw;\n    float uvw18 = uvw17*uvw;\n    float uvw19 = uvw18*uvw;\n    float uvw20 = uvw19*uvw;\n    float uvw21 = uvw20*uvw;\n    float uvw22 = uvw21*uvw;\n    float uvw23 = u", "\n    float scale = 1.0 / gridRes;\n    float offsetX = offset.x * scale;\n    float offsetY = offset.y * scale;\n    float offsetZ = offset.z * scale;\n    float x = uvw.x * scale + offsetX;\n    float y = uvw.y * scale + offsetY;\n    float z = uvw.z * scale + offsetZ;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float xy = x * y;\n    float xz = x * z;\n    float yz = y * z;\n    float x2y2 = x2 + y2;\n    float x2z2 = x2 + z2;\n    float y2z2 = y2 + z2;\n    float x2y2z2 = x2 + y2 + z2;\n    float xy2z2 = xy + yz + z2;\n    float x2y2z22 = x2y2 + y2z2;\n    float x2y2z222 = x2y2z2 + z2 * z2;\n    float x2y2z2222 = x2y2z22 + z2 * z2;\n    float x2y2z22222 = x2y2z222 + z2 * z2;\n    float x2y2z222222 = x2y2z2222 + z2 * z2;\n    float x2y2z2222222 = x2y2z22222 + z2 * z2;\n    float x2y2z22222222 = x2y2z222222 + z2 * z2;\n    float x2y2z222222222 = x2y2z2222222 + z2 * z2;\n    float x2y2z2222222222 = x2y2z22222222 + z2 * z2", "\n    uvw = fract(uvw * gridRes);\n    float m = max(uvw.x, max(uvw.y, uvw.z));\n    float d = max(1.0 - m, 0.0);\n    return vec3(uvw.xy * d, uvw.z * d) * contrast;\n}\n\n// 5 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float offset) {\n    uvw = fract(uvw * gridRes + offset);\n    float m = max(uvw.x, max(uvw.y, uvw.z));\n    float d = max(1.0 - m, 0.0);\n    return vec3(uvw.xy * d, uvw.z * d) * contrast;\n}\n\n// 6 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float offset, float offset2) {\n    uvw = fract(uvw * gridRes + offset + offset2);\n    float m = max(uvw.x, max(uvw.y, uvw.z));\n    float d = max(1.0 - m, 0.0);\n    return vec3(uvw.xy * d, uvw.z * d) * contrast;\n}\n\n// 7 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float offset, float offset2, float offset3) {\n    uvw = fract(uvw * gridRes + offset + offset2 + offset3);\n    float m = max(uvw.x, max(uvw.y, uvw.z));\n    float d = max(1.0 - m, 0.0);\n    return vec3(uvw.xy * d, uvw.z * d) * contrast;\n}\n\n// 8", "\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec2 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(float p) {\n    return max(abs(p) - 1., -p);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1., -r);\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec4 p) {\n    float r = length(p);\n    return max(abs(r) - 1.,", "\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), t);\n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    vec3 r = vec3(c * v.x + s * v.y, v.y * c - v.x * s, v.z);\n    s = sin(a.y);\n    c = cos(a.y);\n    v = vec3(c * r.x + s * r.z, r.y, r.z * c - r.x * s);\n    s = sin(a.z);\n    c = cos(a.z);\n    return vec3(c * v.x + s * v.y, v.y * c - v.x * s, v.z);\n}\n\n// returns the normal of a triangle\nvec3 normal(vec3 p1, vec3 p2, vec3 p3)\n{\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    return normalize(cross(v1, v2));\n}\n\n// returns the normal of a quad\nvec3 normal(vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n{\n    vec3 n1 = normal(p1, p2, p3);\n    vec3 n2 = normal(p1, p3, p4);\n    return normalize(n1 + n2);\n}\n\n// returns the normal of a quad\nvec3 normal(vec3 p1, vec3 p2, vec3 p3, vec3 p4, vec3 p5, vec3 p6, vec3 p7, vec3 p8)\n{\n    vec3 n1 = normal(p1, p2, p3);\n    vec3 n2 = normal(p1, p3, p4);\n    vec3 n3 = normal(p1, p4, p5);\n    vec3 n4 = normal(p1, p5, p6);\n    vec3 n5 = normal(p1, p6, p7);\n    vec3 n6 = normal(p1, p7, p8);\n    vec3 n7 = normal(p1, p8, p2);\n", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n\n    // 4 corners of a rectangle surrounding our point\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 co) {\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (int i = 0; i < 7; i++) {\n        value += noise(co) * scale;\n        // the smaller the scale, the bigger the waves\n        scale *= 0.5;\n        co *= 2.0;\n    }\n\n    return value;\n}\n\nfloat fbm(vec2 co, float scale) {\n    float value = 0.0;\n\n    for (int i = 0; i < 7; i++) {\n        value += noise(co) * scale;\n        // the smaller the scale, the bigger the waves\n        scale *= 0.5;\n        co *= 2.0;\n    }\n\n    return value;\n}\n\nfloat fbm(vec2 co, float scale, int octaves) {\n    float value = 0.0;\n\n    for (int i = 0; i < octaves; i++) {\n        value += noise(co) * scale;\n        // the smaller the scale, the bigger the waves\n        scale", "\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, float size) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p, float size) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec4 p, float size) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 size) {\n    p = abs(p);\n    return (p.x > p.y)? sqrt(3)*p.x : sqrt(3)*p.y;\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec3 p, vec3 size) {\n    p = abs(p);\n    return (", "\n    uv *= 2.0;\n    vec2 p = vec2(0.0, 1.0) - uv;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = 0.0;\n    float s = 0.0;\n    float c = 0.0;\n    float t = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X", "\n    return mix(vec3(0.2, 0.8, 0.2), vec3(0.0, 0.8, 0.0), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, float min, float max) {\n    return mix(viridis(min), viridis(max), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, vec3 min, vec3 max) {\n    return mix(min, max, t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, vec3 min, vec3 max, float min_t, float max_t) {\n    return mix(viridis(min_t), viridis(max_t), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, vec3 min, vec3 max, float min_t, float max_t, float min_t_2, float max_t_2) {\n    return mix(viridis(min_t, min_t_2), viridis(max_t, max_t_2), t);\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t, vec3 min, vec3 max, float min_t, float max_t, float min_t_2, float max_t_2, float min_t_3, float max_t_3) {\n    return mix(viridis(min_t, min_t_2, min_t_3), viridis(max_t,", "\n  return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) {\n  return (x * 2.0) - 1.0;\n}\n\n//shifts value range from 0-1 to 0-255\nfloat make0to255(float x) {\n  return (x * 255.0);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1(int x) {\n  return (x / 255.0);\n}\n\n//shifts value range from 0-255 to -1-1\nfloat makeMinus1to1(int x) {\n  return (x / 127.5) - 1.0;\n}\n\n//shifts value range from 0-255 to 0-256\nfloat make0to256(int x) {\n  return (x / 255.0) + 1.0;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1(byte x) {\n  return (x / 255.0);\n}\n\n//shifts value range from 0-255 to -1-1\nfloat makeMinus1to1(byte x) {\n  return (x / 127.5) - 1.0;\n}\n\n//shifts value range from 0-255 to 0-256\nfloat make0to256(byte x) {\n  return (x / 255.0) + 1.0;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1(int x, int max) {\n  return (x / max) * 2.0;\n}\n\n//shifts value range from 0-255 to -1-1\nfloat makeMinus1to1(int x, int max) {\n  return (x / max", "\n    float cell = floor(mod(uv.x * gridRes, 1.0));\n    float cell2 = floor(mod(uv.y * gridRes, 1.0));\n    float cell3 = floor(mod(uv.x * gridRes + uv.y * gridRes, 1.0));\n    float cell4 = floor(mod(uv.x * gridRes + uv.y * gridRes + time, 1.0));\n    float cell5 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 2.0, 1.0));\n    float cell6 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 3.0, 1.0));\n    float cell7 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 4.0, 1.0));\n    float cell8 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 5.0, 1.0));\n    float cell9 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 6.0, 1.0));\n    float cell10 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 7.0, 1.0));\n    float cell11 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 8.0, 1.0));\n    float cell12 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 9.0, 1.0));\n    float cell13 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 10.0, 1.0));\n    float cell14 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 11.0, 1.0));\n    float cell15 = floor(mod(uv.x * gridRes + uv.y * gridRes + time * 1", "\n    float grid = floor(gridRes * uv.x);\n    float grid2 = floor(gridRes * uv.y);\n    float grid3 = floor(gridRes * uv.x + uv.y);\n    float grid4 = floor(gridRes * uv.y + uv.x);\n    float grid5 = floor(gridRes * uv.x - uv.y);\n    float grid6 = floor(gridRes * uv.y - uv.x);\n    float grid7 = floor(gridRes * uv.x + uv.y + uv.x);\n    float grid8 = floor(gridRes * uv.y + uv.x + uv.y);\n    float grid9 = floor(gridRes * uv.x - uv.y + uv.x);\n    float grid10 = floor(gridRes * uv.y - uv.x - uv.y);\n    float grid11 = floor(gridRes * uv.x + uv.y - uv.x);\n    float grid12 = floor(gridRes * uv.y + uv.x - uv.y);\n    float grid13 = floor(gridRes * uv.x - uv.y - uv.x);\n    float grid14 = floor(gridRes * uv.y - uv.x + uv.y);\n    float grid15 = floor(gridRes * uv.x + uv.y + uv.x + uv.y);\n    float grid16 = floor(gridRes * uv.y + uv.x + uv.y + uv.x);\n    float grid17 = floor(gridRes * uv.x - uv.y + uv.x + uv.y);\n    float grid18 = floor(gridRes * uv.y - uv.x - uv.y + uv.x);\n    float grid19 = floor(gridRes * uv.x + uv.y - uv.x - uv.y);\n    float grid20 = floor(gridRes * uv.y + uv.x - uv", "\n    vec2 flow = vec2(0.0);\n    float total = 0.0;\n    for (float i = 0.0; i < 1.0; i += 0.01) {\n        float angle = i * 2.0 * PI;\n        vec2 offset = vec2(cos(angle), sin(angle));\n        float dist = distance(point, offset);\n        if (dist < radius) {\n            float weight = 1.0 - smoothstep(radius - 0.01, radius, dist);\n            float speed = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed2 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed3 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed4 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed5 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed6 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed7 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed8 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed9 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed10 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed11 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed12 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed13 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed14 = 1.0 - smoothstep(0.0, 0.01, dist);\n            float speed15 = 1.0 - smoothstep(0", "\n  return floor(pos / 256.0);\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos) {\n  return floor(pos / 256.0);\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize) {\n  return floor(pos / tileSize);\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset) {\n  return floor((pos - tileOffset) / tileSize);\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileExtent) {\n  return floor((pos - tileOffset) / tileSize) * tileExtent;\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileExtent, vec2 tileResolution) {\n  return floor((pos - tileOffset) / tileSize) * tileExtent * tileResolution;\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileExtent, vec2 tileResolution, float tileBuffer) {\n  return floor((pos - tileOffset) / tileSize) * tileExtent * tileResolution + tileBuffer;\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tileExtent, vec2 tileResolution, float tileBuffer, float tileOverlap) {\n  return floor((pos - tileOffset) / tileSize) * tileExtent * tileResolution + tileBuffer - tileOverlap;\n}\n\n// Computes the tile coordinate of the tile containing pixel pos\nvec2 arrowTileCoord(vec2 pos, vec2 tileSize, vec2 tileOffset, vec2 tile", "\n    vec2 r = p2 - p1;\n    vec2 v = p - p1;\n    float t = clamp(dot(v, r) / dot(r, r), 0.0, 1.0);\n    return length(v - r * t);\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float width) {\n    float d = line(p, p1, p2);\n    return d - width / 2.0;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float width, float width2) {\n    float d = line(p, p1, p2);\n    return d - width / 2.0 - width2 / 2.0;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float width, float width2, float width3) {\n    float d = line(p, p1, p2);\n    return d - width / 2.0 - width2 / 2.0 - width3 / 2.0;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float width, float width2, float width3, float width4) {\n    float d = line(p, p1, p2);\n    return d - width / 2.0 - width2 / 2.0 - width3 / 2.0 - width4 / 2.0;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2, float width, float width2, float width3, float width4, float width5) {\n    float d = line(p, p1, p2);\n    return d - width / 2.0 - width2 / 2.0 - width3 / 2.0 - width4 / 2.0 - width5 / 2.0;\n}\n\n// Computes the signed distance from a", "\n  float arrowLength = length(v);\n  float arrowWidth = arrowLength * 0.05;\n  float arrowHeadLength = arrowLength * 0.2;\n  float arrowHeadWidth = arrowWidth * 0.5;\n  float arrowHeadAngle = 0.2;\n  float arrowHeadAngle2 = arrowHeadAngle * 0.5;\n  float arrowHeadAngle3 = arrowHeadAngle * 0.33;\n  float arrowHeadAngle4 = arrowHeadAngle * 0.66;\n  float arrowHeadAngle5 = arrowHeadAngle * 0.75;\n  float arrowHeadAngle6 = arrowHeadAngle * 0.8;\n  float arrowHeadAngle7 = arrowHeadAngle * 0.85;\n  float arrowHeadAngle8 = arrowHeadAngle * 0.9;\n  float arrowHeadAngle9 = arrowHeadAngle * 0.95;\n  float arrowHeadAngle10 = arrowHeadAngle * 1.0;\n  float arrowHeadAngle11 = arrowHeadAngle * 1.05;\n  float arrowHeadAngle12 = arrowHeadAngle * 1.1;\n  float arrowHeadAngle13 = arrowHeadAngle * 1.15;\n  float arrowHeadAngle14 = arrowHeadAngle * 1.2;\n  float arrowHeadAngle15 = arrowHeadAngle * 1.25;\n  float arrowHeadAngle16 = arrowHeadAngle * 1.3;\n  float arrowHeadAngle17 = arrowHeadAngle * 1.35;\n  float arrowHeadAngle18 = arrowHeadAngle * 1.4;\n  float arrowHeadAngle19 = arrowHeadAngle * 1.45;\n  float arrowHeadAngle20 = arrowHeadAngle * 1.5;\n  float arrowHeadAngle21 = arrowHeadAngle * 1.55;\n  float arrowHeadAngle22 = arrowHeadAngle * 1.6;\n  float arrowHeadAngle23 = arrowHeadAngle * 1.65;\n  float arrowHeadAngle24 = arrowHeadAngle * 1.7;\n  float arrowHeadAngle25 = arrowHeadAngle * 1.75;\n  float arrowHeadAngle26", "\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from -1-1 to 0-1\nvec3 make0to1(vec3 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from -1-1 to 0-1\nvec4 make0to1(vec4 x) {\n    return x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make0to1(vec3 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 make0to1(vec4 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make0to1(vec3 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 make0to1(vec4 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 make0to1(vec2 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 make0to1(vec3 x) {\n    return x * 2.0 - 1.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 make0to1(", "\n    vec2 p = point - vec2(0.5);\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float angle2 = atan(p.y, p.x) + offset;\n    float angle3 = atan(p.y, p.x) - offset;\n    float r2 = r + spread;\n    float r3 = r - spread;\n    float r4 = r + spread * 2.0;\n    float r5 = r - spread * 2.0;\n    float r6 = r + spread * 3.0;\n    float r7 = r - spread * 3.0;\n    float r8 = r + spread * 4.0;\n    float r9 = r - spread * 4.0;\n    float r10 = r + spread * 5.0;\n    float r11 = r - spread * 5.0;\n    float r12 = r + spread * 6.0;\n    float r13 = r - spread * 6.0;\n    float r14 = r + spread * 7.0;\n    float r15 = r - spread * 7.0;\n    float r16 = r + spread * 8.0;\n    float r17 = r - spread * 8.0;\n    float r18 = r + spread * 9.0;\n    float r19 = r - spread * 9.0;\n    float r20 = r + spread * 10.0;\n    float r21 = r - spread * 10.0;\n    float r22 = r + spread * 11.0;\n    float r23 = r - spread * 11.0;\n    float r24 = r + spread * 12.0;\n    float r25 = r - spread * 12.0;\n    float r26 = r + spread * 13.0;\n    float r27 = r - spread * 13.0;\n    float r28 = r + spread * 14.0;\n    float r29 = r -", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdConeSection( in vec3 p, in vec2 c, in float h )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z))-h;\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x*0.866025 + p.y*0.5, -p.y) - h.y\n        + max(q.x*0.5 + q.y*0.866025 - h.x, 0.);\n", "\n    float t = time * 0.1;\n    float a = 0.5;\n    float b = 0.5;\n    float c = 0.5;\n    float d = 0.5;\n    float e = 0.5;\n    float f = 0.5;\n    float g = 0.5;\n    float h = 0.5;\n    float i = 0.5;\n    float j = 0.5;\n    float k = 0.5;\n    float l = 0.5;\n    float m = 0.5;\n    float n = 0.5;\n    float o = 0.5;\n    float p = 0.5;\n    float q = 0.5;\n    float r = 0.5;\n    float s = 0.5;\n    float t = 0.5;\n    float u = 0.5;\n    float v = 0.5;\n    float w = 0.5;\n    float x = 0.5;\n    float y = 0.5;\n    float z = 0.5;\n    float aa = 0.5;\n    float bb = 0.5;\n    float cc = 0.5;\n    float dd = 0.5;\n    float ee = 0.5;\n    float ff = 0.5;\n    float gg = 0.5;\n    float hh = 0.5;\n    float ii = 0.5;\n    float jj = 0.5;\n    float kk = 0.5;\n    float ll = 0.5;\n    float mm = 0.5;\n    float nn = 0.5;\n    float oo = 0.5;\n    float pp = 0.5;\n    float qq = 0.5;\n    float rr = 0.5;\n    float ss = 0.5;\n    float tt = 0.5;\n    float uu = 0.5;\n    float vv = 0.5;\n    float ww = 0.", "\n    float r = ra * 0.5;\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    float k = (r / sp);\n    float t = time * 0.1;\n    float d = length(vec2(c, s)) - r;\n    float d2 = d - k * (sin(t + c * k) + sin(t + s * k));\n    return d2;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp )\n{\n    return sdCircularRepetition(p, ra, sp, 0.0);\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra )\n{\n    return sdCircularRepetition(p, ra, 1.0);\n}\n\nfloat sdCircularRepetition( in vec2 p )\n{\n    return sdCircularRepetition(p, 1.0);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset )\n{\n    float r = ra * 0.5;\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    float k = (r / sp);\n    float t = time * 0.1;\n    float d = length(vec2(c, s)) - r;\n    float d2 = d - k * (sin(t + c * k) + sin(t + s * k));\n    return d2 - offset;\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float offset )\n{\n    return sdCircularRepetition(p, ra, sp, 0.0, offset);\n}\n\nfloat sdCircularRepetition( in vec2 p, float ra, float offset )\n{\n    return sdCircularRepetition(p, ra, 1.0, offset);\n}\n\nfloat sdCircularRepetition( in", "\n    float d = 0.0;\n    d = min(d, length(abs(uvw) - vec3(1.0)));\n    return d;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    float d = 0.0;\n    d = min(d, length(abs(uvw.xy) - vec2(1.0)) - uvw.z);\n    return d;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    float d = 0.0;\n    d = min(d, length(uvw.xy - vec2(0.0, 1.0)) - uvw.z);\n    return d;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    float d = 0.0;\n    vec2 p = vec2(length(uvw.xy) - 1.0, uvw.z);\n    d = min(d, length(p) - 0.2);\n    return d;\n}\n\n//edge distance of a Tetrahedron\nfloat tetrahedronDist(vec3 uvw) {\n    float d = 0.0;\n    d = min(d, abs(uvw.x + uvw.y + uvw.z - 1.0));\n    return d;\n}\n\n//edge distance of a Octahedron\nfloat octahedronDist(vec3 uvw) {\n    float d = 0.0;\n    d = min(d, abs(uvw.x + uvw.y + uvw.z - 1.0));\n    d = min(d, abs(uvw.x + uvw.y - uvw.z));\n    d = min(d, abs(uvw.x - uvw.y + uvw.z));\n    d = min(d, abs(uvw.x + uvw.y + uvw.z));\n    return d;\n}\n\n//edge distance of a Dodecahed", "\n    vec3 f = fract(uvw);\n    vec3 p = floor(uvw);\n    vec3 w = p - f + 0.5;\n    vec3 u = abs(f - 0.5);\n    vec3 v = 1.0 - u;\n    vec3 a = u.x * u.y * u.z;\n    vec3 b = v.x * v.y * v.z;\n    return vec4(a.x + b.x, a.y + b.y, a.z + b.z, a.x * b.y + a.y * b.z + a.z * b.x);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, float lod) {\n    vec3 f = fract(uvw);\n    vec3 p = floor(uvw);\n    vec3 w = p - f + 0.5;\n    vec3 u = abs(f - 0.5);\n    vec3 v = 1.0 - u;\n    vec3 a = u.x * u.y * u.z;\n    vec3 b = v.x * v.y * v.z;\n    return vec4(a.x + b.x, a.y + b.y, a.z + b.z, a.x * b.y + a.y * b.z + a.z * b.x);\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw, float lod, float lodBias) {\n    vec3 f = fract(uvw);\n    vec3 p = floor(uvw);\n    vec3 w = p - f + 0.5;\n    vec3 u = abs(f - 0.5);\n    vec3 v = 1.0 - u;\n    vec3 a = u.x * u.y * u.z;\n    vec3 b = v.x * v.y * v.z;\n    return vec4(a.x + b.x, a.y + b.y, a.z + b.z, a.x * b.y + a.y", "\n    vec3 uvwScaled = uvw * gridRes;\n    vec3 uvwScaledOffset = uvwScaled + offset;\n    vec3 uvwScaledOffsetFloor = floor(uvwScaledOffset);\n    vec3 uvwScaledOffsetFract = fract(uvwScaledOffset);\n    vec3 uvwScaledOffsetFract2 = uvwScaledOffsetFract * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract3 = uvwScaledOffsetFract2 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract4 = uvwScaledOffsetFract3 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract5 = uvwScaledOffsetFract4 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract6 = uvwScaledOffsetFract5 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract7 = uvwScaledOffsetFract6 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract8 = uvwScaledOffsetFract7 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract9 = uvwScaledOffsetFract8 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract10 = uvwScaledOffsetFract9 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract11 = uvwScaledOffsetFract10 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract12 = uvwScaledOffsetFract11 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract13 = uvwScaledOffsetFract12 * uvwScaledOffsetFract;\n    vec3 uvwScaledOffsetFract14 = uvwScaledOffsetFract13 * uvwScaled", "\n    return clamp(vec3(t, t * 0.5 + 0.5, t * 0.5), 0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(vec3 t) {\n    return clamp(vec3(t.x, t.y * 0.5 + 0.5, t.y * 0.5), 0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(vec4 t) {\n    return clamp(vec3(t.x, t.y * 0.5 + 0.5, t.y * 0.5), 0.0, 1.0);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float min, float max) {\n    return clamp(vec3(t, t * 0.5 + 0.5, t * 0.5), min, max);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(vec3 t, float min, float max) {\n    return clamp(vec3(t.x, t.y * 0.5 + 0.5, t.y * 0.5), min, max);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(vec4 t, float min, float max) {\n    return cl", "\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Icosidodecahedron\nfloat icododecDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Truncated Icosahedron\nfloat tricosaDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Truncated Cuboctahedron\nfloat tricubocDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Truncated Icosidodecahedron\nfloat tricododecDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Truncated Dodecahedron\nfloat tridodecDist(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - 1.0;\n}\n\n//Distance from the Edge of Truncated Tetrahedron\nfloat", "\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0, t)\n    );\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    return vec3(\n        mix(0.0, 0.0, t),\n        mix(0.0, 0.0,", "\n    vec2 tile = floor(uv * 2.0);\n    vec2 frac = fract(uv * 2.0);\n    float tileSize = 1.0 / 2.0;\n    float tileSize2 = tileSize * 2.0;\n    float tileSize4 = tileSize2 * 2.0;\n    float tileSize8 = tileSize4 * 2.0;\n    float tileSize16 = tileSize8 * 2.0;\n    float tileSize32 = tileSize16 * 2.0;\n    float tileSize64 = tileSize32 * 2.0;\n    float tileSize128 = tileSize64 * 2.0;\n    float tileSize256 = tileSize128 * 2.0;\n    float tileSize512 = tileSize256 * 2.0;\n    float tileSize1024 = tileSize512 * 2.0;\n    float tileSize2048 = tileSize1024 * 2.0;\n    float tileSize4096 = tileSize2048 * 2.0;\n    float tileSize8192 = tileSize4096 * 2.0;\n    float tileSize16384 = tileSize8192 * 2.0;\n    float tileSize32768 = tileSize16384 * 2.0;\n    float tileSize65536 = tileSize32768 * 2.0;\n    float tileSize131072 = tileSize65536 * 2.0;\n    float tileSize262144 = tileSize131072 * 2.0;\n    float tileSize524288 = tileSize262144 * 2.0;\n    float tileSize1048576 = tileSize524288 * 2.0;\n    float tileSize2097152 = tileSize1048576 * 2.0;\n    float tileSize4194304 = tileSize", "\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = 1.0 - r;\n    float t = 1.0 - smoothstep(0.0, 0.01, d);\n    float c = 1.0 - smoothstep(0.0, 0.01, abs(a));\n    return vec3(t * c);\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile2(vec2 uv) {\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = 1.0 - r;\n    float t = 1.0 - smoothstep(0.0, 0.01, d);\n    float c = 1.0 - smoothstep(0.0, 0.01, abs(a));\n    return vec3(t * c);\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile3(vec2 uv) {\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = 1.0 - r;\n    float t = 1.0 - smoothstep(0.0, 0.01, d);\n    float c = 1.0 - smoothstep(0.0, 0.01, abs(a));\n    return vec3(t * c);\n}\n\n//rhombic shape form Euclidean distance\nvec3 rhomTile4(vec2 uv) {\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = 1.0 - r;\n    float t = 1.0 - smoothstep(0.0, ", "\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid.x + grid.y, 2.0);\n    return vec3(index);\n}\n\n// nakes a checkerboard pattern\nvec3 checkerboard(vec2 uv, float gridRes, vec2 offset) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid.x + grid.y, 2.0);\n    return vec3(index);\n}\n\n// nakes a checkerboard pattern\nvec3 checkerboard(vec2 uv, float gridRes, vec2 offset, float threshold) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid.x + grid.y, 2.0);\n    return vec3(index > threshold? 1.0 : 0.0);\n}\n\n// nakes a checkerboard pattern\nvec3 checkerboard(vec2 uv, float gridRes, vec2 offset, float threshold, float threshold2) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid.x + grid.y, 2.0);\n    return vec3(index > threshold? 1.0 : index > threshold2? 0.5 : 0.0);\n}\n\n// nakes a checkerboard pattern\nvec3 checkerboard(vec2 uv, float gridRes, vec2 offset, float threshold, float threshold2, float threshold3) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid.x + grid.y, 2.0);\n    return vec3(index > threshold? 1.0 : index > threshold2? 0.5 : index > threshold3? 0.25 : 0.0);\n}\n\n// nakes a checkerboard pattern\nvec3 checkerboard(vec2 uv, float gridRes, vec2 offset, float threshold, float threshold2, float threshold3, float threshold4) {\n    vec2 grid = floor(uv * gridRes) + offset;\n    float index = mod(grid", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 off = vec2(0.5) - f;\n    float d = min(off.x, off.y);\n    return vec3(d);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 off = vec2(0.5) - f;\n    float d = min(off.x, off.y);\n    return vec3(d);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2, float gridRes3) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 off = vec2(0.5) - f;\n    float d = min(off.x, off.y);\n    return vec3(d);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2, float gridRes3, float gridRes4) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 off = vec2(0.5) - f;\n    float d = min(off.x, off.y);\n    return vec3(d);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes, float gridRes2, float gridRes3, float gridRes4, float gridRes5) {\n    vec2 grid = floor(uv * gridRes);\n    vec2 f = fract(uv * gridRes);\n    vec2 off = vec2(0.5) - f;\n    float d = min(off.x, off.y);\n    return vec3(d);", "\n    float cellSize = 1.0 / gridRes;\n    float cellIndex = floor(uv.x * gridRes + uv.y * gridRes * 0.5);\n    float cellTime = time * 0.1 + cellIndex * 0.01;\n    float cellOffset = cellTime * 0.01;\n    float cellUV = cellIndex * cellSize;\n    float cellUVOffset = cellUV + cellOffset;\n    float cellUVOffset2 = cellUV + cellOffset * 2.0;\n    float cellUVOffset3 = cellUV + cellOffset * 3.0;\n    float cellUVOffset4 = cellUV + cellOffset * 4.0;\n    float cellUVOffset5 = cellUV + cellOffset * 5.0;\n    float cellUVOffset6 = cellUV + cellOffset * 6.0;\n    float cellUVOffset7 = cellUV + cellOffset * 7.0;\n    float cellUVOffset8 = cellUV + cellOffset * 8.0;\n    float cellUVOffset9 = cellUV + cellOffset * 9.0;\n    float cellUVOffset10 = cellUV + cellOffset * 10.0;\n    float cellUVOffset11 = cellUV + cellOffset * 11.0;\n    float cellUVOffset12 = cellUV + cellOffset * 12.0;\n    float cellUVOffset13 = cellUV + cellOffset * 13.0;\n    float cellUVOffset14 = cellUV + cellOffset * 14.0;\n    float cellUVOffset15 = cellUV + cellOffset * 15.0;\n    float cellUVOffset16 = cellUV + cellOffset * 16.0;\n    float cellUVOffset17 = cellUV + cellOffset * 17.0;\n    float cellUVOffset18 = cellUV + cellOffset * 18.0;\n    float cellUVOffset19 = cellUV + cellOffset * 19.0;\n    float cellUVOffset", "\n    float cellSize = 1.0 / gridRes;\n    float cellId = floor(uv.x * gridRes);\n    float cellOffset = cellId * cellSize;\n    float cellFrac = fract(uv.x * gridRes);\n    float cellFrac2 = cellFrac * cellFrac;\n    float cellFrac3 = cellFrac2 * cellFrac;\n    float cellFrac4 = cellFrac3 * cellFrac;\n    float cellFrac5 = cellFrac4 * cellFrac;\n    float cellFrac6 = cellFrac5 * cellFrac;\n    float cellFrac7 = cellFrac6 * cellFrac;\n    float cellFrac8 = cellFrac7 * cellFrac;\n    float cellFrac9 = cellFrac8 * cellFrac;\n    float cellFrac10 = cellFrac9 * cellFrac;\n    float cellFrac11 = cellFrac10 * cellFrac;\n    float cellFrac12 = cellFrac11 * cellFrac;\n    float cellFrac13 = cellFrac12 * cellFrac;\n    float cellFrac14 = cellFrac13 * cellFrac;\n    float cellFrac15 = cellFrac14 * cellFrac;\n    float cellFrac16 = cellFrac15 * cellFrac;\n    float cellFrac17 = cellFrac16 * cellFrac;\n    float cellFrac18 = cellFrac17 * cellFrac;\n    float cellFrac19 = cellFrac18 * cellFrac;\n    float cellFrac20 = cellFrac19 * cellFrac;\n    float cellFrac21 = cellFrac20 * cellFrac;\n    float cellFrac22 = cellFrac21 * cellFrac;\n    float cellFrac23 = cellFrac22 * cellFrac;\n    float cellFrac24 = cellFrac23 * cellFrac;\n    float cellFrac25 = cellFrac24 * cellFrac;\n    float cellFrac26 = cellFrac25 * cell", "\n    vec2 w = max(abs(ddx), abs(ddy)) + fwidth(p);\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    return -clamp( dot(a,a)-dot(b,b), 0.0, 1.0 );\n}\n\nfloat gridTexture( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    return gridTextureGradBox( p, ddx, ddy );\n}\n\nfloat gridTexture( in vec2 p )\n{\n    return gridTexture( p, dFdx(p), dFdy(p) );\n}\n\nfloat gridTexture( in vec2 p, in float d )\n{\n    return gridTexture( p, vec2(d), vec2(d) );\n}\n\nfloat gridTexture( in vec2 p, in float d, in float d2 )\n{\n    return gridTexture( p, vec2(d,d2) );\n}\n\nfloat gridTexture( in vec2 p, in float d, in float d2, in float d3 )\n{\n    return gridTexture( p, vec2(d,d2), vec2(d3) );\n}\n\nfloat gridTexture( in vec2 p, in float d, in float d2, in float d3, in float d4 )\n{\n    return gridTexture( p, vec2(d,d2), vec2(d3,d4) );\n}\n\nfloat gridTexture( in vec2 p, in float d, in float d2, in float d3, in float d4, in float d5 )\n{\n    return gridTexture( p, vec2(d,d2), vec2(d3,d4), vec2(d5) );\n}\n\nfloat gridTexture( in vec2 p, in float d, in float d2, in float d3, in float d4, in float d5, in float d6 )\n{\n    return gridTexture( p, vec2(d,d2), vec2(d3,d4), vec2(d5,d6) );\n}\n\nfloat gridTexture( in", "\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), k.z*p.x);\n    p -= vec2(clamp(p.x, -r*0.5, r*0.5), r);\n    return length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), k.z*p.x);\n    p -= vec2(clamp(p.x, -r*0.5, r*0.5), r);\n    return length(p)*sign(p.y-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r, float h, float a) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy, p), k.z*p.x);\n    p -= vec2(clamp(p.x, -r*0.5, r*0.5), r);\n    return length(p)*sign(p.y-h-a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec", "\n    vec2 q = floor(p);\n    vec2 r = p - q;\n    vec2 s = vec2(0.5, 0.5) - r;\n    vec2 t = step(s, vec2(0.0));\n    vec2 m = t * s + t * (1.0 - s);\n    vec2 o = m * m * (3.0 - 2.0 * m);\n    p = q + o;\n    return o;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.shadertoy.com/view/4djSRW\nvec2 hexgrid(inout vec2 p) {\n    vec2 q = floor(p);\n    vec2 r = p - q;\n    vec2 s = vec2(0.5, 0.5) - r;\n    vec2 t = step(s, vec2(0.0));\n    vec2 m = t * s + t * (1.0 - s);\n    vec2 o = m * m * (3.0 - 2.0 * m);\n    p = q + o;\n    return o;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.shadertoy.com/view/4djSRW\nvec2 hexgrid(inout vec2 p, float size) {\n    vec2 q = floor(p);\n    vec2 r = p - q;\n    vec2 s = vec2(0.5, 0.5) - r;\n    vec2 t = step(s, vec2(0.0));\n    vec2 m = t * s + t * (1.0 - s);\n    vec2 o = m * m * (3.0 - 2.0 * m);\n    p = q + o;\n    return o;\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.shadertoy.com/view/4djSRW\nvec2 hexgrid(inout vec2 p, float size, float angle) {\n    vec2 q = floor(p);\n    vec2 r = p", "\n    return 0.5 * x * (1.0 - abs(x));\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f*(3.0 - 2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( in vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p * 2.02;\n    f += 0.2500 * noise( p ); p = p * 2.03;\n    f += 0.1250 * noise( p ); p = p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\nfloat fbm( in vec3 p, float f )\n{\n    float f2 = f*f;\n    float f3 = f2*f;\n    float f4 = f2*f2;\n    float f5 = f2*f3;\n    float f6 = f3*f3;\n    float f7 = f4*f3;\n    float f8 = f4*f4;\n    float f9 = f5*f4;\n    float f10 = f6*f4;\n    float f11 = f7*f3", "\n    return pow(t, vec3(1.0 / 2.2));\n}\n\nvec3 sRGB(vec3 t, float gamma) {\n    return pow(t, vec3(1.0 / gamma));\n}\n\nvec3 sRGB(vec3 t, vec3 gamma) {\n    return pow(t, gamma);\n}\n\nvec3 sRGB(vec3 t, float gamma, float exposure) {\n    return sRGB(t * exposure, gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, float exposure) {\n    return sRGB(t * exposure, gamma);\n}\n\nvec3 sRGB(vec3 t, float gamma, vec3 exposure) {\n    return sRGB(t * exposure, gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, vec3 exposure) {\n    return sRGB(t * exposure, gamma);\n}\n\nvec3 sRGB(vec3 t, float gamma, vec3 exposure, float exposure_gamma) {\n    return sRGB(t * exposure, gamma, exposure_gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, vec3 exposure, float exposure_gamma) {\n    return sRGB(t * exposure, gamma, exposure_gamma);\n}\n\nvec3 sRGB(vec3 t, float gamma, vec3 exposure, vec3 exposure_gamma) {\n    return sRGB(t * exposure, gamma, exposure_gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, vec3 exposure, vec3 exposure_gamma) {\n    return sRGB(t * exposure, gamma, exposure_gamma);\n}\n\nvec3 sRGB(vec3 t, float gamma, float exposure, float exposure_gamma) {\n    return sRGB(t * exposure, gamma, exposure_gamma);\n}\n\nvec3 sRGB(vec3 t, vec3 gamma, float exposure, float exposure_gamma) {\n    return sRGB(t * expos", "\n    float d = 0.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    return d;\n}\n\n// Classic truchet pattern with a hole in the middle\nfloat df1(vec2 p) {\n    float d = 0.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    d = max(d, abs(p.x) - 0.25);\n    d = max(d, abs(p.y) - 0.25);\n    return d;\n}\n\n// Classic truchet pattern with a hole in the middle and a hole in the corner\nfloat df2(vec2 p) {\n    float d = 0.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    d = max(d, abs(p.x) - 0.25);\n    d = max(d, abs(p.y) - 0.25);\n    d = max(d, abs(p.x) - 0.125);\n    d = max(d, abs(p.y) - 0.125);\n    return d;\n}\n\n// Classic truchet pattern with a hole in the middle and a hole in the corner\nfloat df3(vec2 p) {\n    float d = 0.0;\n    d = max(d, abs(p.x) - 0.5);\n    d = max(d, abs(p.y) - 0.5);\n    d = max(d, abs(p.x) - 0.25);\n    d = max(d, abs(p.y) - 0.25);\n    d = max(d, abs(p.x) - 0.125);\n    d = max(d, abs(p.y) -", "\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, 0.5 + 0.5 * abs(sin(p.x + i * 0.1) + sin(p.y + i * 0.1)));\n        p = 2.0 * p;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, 0.5 + 0.5 * abs(sin(p.x + i * 0.1) + sin(p.y + i * 0.1)));\n        p = 2.0 * p;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, 0.5 + 0.5 * abs(sin(p.x + i * 0.1) + sin(p.y + i * 0.1)));\n        p = 2.0 * p;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, 0.5 + 0.5 * abs(sin(p.x + i * 0.1) + sin(p.y + i * 0.1)));\n        p = 2.0 * p;\n    }\n    return d;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        d = min(d, 0.5 + 0.5 * abs", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n    float dot00 = dot(e0, e0);\n    float dot01 = dot(e0, e1);\n    float dot02 = dot(e0, v0);\n    float dot11 = dot(e1, e1);\n    float dot12 = dot(e1, v1);\n    float dot22 = dot(v2, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return length(vec2(u, v)) * sign(u * v0.x + v * e0.x);\n}\n\n// signed distance to a 2D quad\nfloat sdQuad( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p3 - p2;\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n    vec2 v3 = p - p3;\n    float dot00 = dot(e0, e0);\n    float dot01 = dot(e0, e1);\n    float dot02 = dot(e0, v0);\n    float dot11 = dot(e1, e1);\n    float dot12 = dot(e1, v1);\n    float dot22 = dot(e2, e2);\n    float dot23 = dot(e2, v2);\n    float dot33", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    return h > dbuffer? h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spheres(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    return h > dbuffer? h : -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spheres(vec3 ro, vec3 rd, vec4 sph, float dbuffer, out float t) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return -1.0;\n    h = -b - sqrt(h);\n    t = h > dbuffer? h : -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat spheres(vec3 ro, vec3 rd, vec4", "\n    return length(max(abs(p) - w, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float w, float r) {\n    return length(max(abs(p) - w, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedZ(vec2 p, float w, float r) {\n    return length(max(abs(p) - w, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float r) {\n    return length(max(abs(p) - w, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float r, float h) {\n    return length(max(abs(p) - vec2(w, h), 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float r, float h, float d) {\n    return length(max(abs(p) - vec3(w, h, d), 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float r, float h, float", "\n    float x = p.x;\n    float y = p.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float xy = x*y;\n    float r = sqrt(x2 + y2);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r10 = r8*r2;\n    float r12 = r8*r4;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r16*r2;\n    float r20 = r16*r4;\n    float r22 = r18*r2;\n    float r24 = r18*r4;\n    float r26 = r22*r2;\n    float r28 = r22*r4;\n    float r30 = r24*r2;\n    float r32 = r24*r4;\n    float r34 = r26*r2;\n    float r36 = r26*r4;\n    float r38 = r28*r2;\n    float r40 = r28*r4;\n    float r42 = r30*r2;\n    float r44 = r30*r4;\n    float r46 = r32*r2;\n    float r48 = r32*r4;\n    float r50 = r34*r2;\n    float r52 = r34*r4;\n    float r54 = r36*r2;\n    float r56 = r36*r4;\n    float r58 = r38*r2;\n    float r60 = r38*r4;\n    float r62 = r40*r2;\n    float r64 = r40*r4;\n    float r66 = r42*r2;", "\n    return abs( p.y - 1.0/p.x );\n}\n\n// distance to y=x^3\nfloat sdOOXX( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.y;\n}\n\n// distance to y=x^3-1\nfloat sdOOXX1( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - 1.0 - p.y;\n}\n\n// distance to y=x^3+1\nfloat sdOOXX11( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - 1.0 + p.y;\n}\n\n// distance to y=x^3-x\nfloat sdOOXX1X( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.x - p.y;\n}\n\n// distance to y=x^3-x^2\nfloat sdOOXX1XX( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.x*p.x - p.y;\n}\n\n// distance to y=x^3-x^2+x-1\nfloat sdOOXX1XX1( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.x*p.x - p.x - 1.0 - p.y;\n}\n\n// distance to y=x^3-x^2+x-1/2\nfloat sdOOXX1XX12( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.x*p.x - p.x - 0.5 - p.y;\n}\n\n// distance to y=x^3-x^2+x-1/2+1/x\nfloat sdOOXX1XX121( in vec2 p )\n{\n    return pow( p.x, 3.0 ) - p.x*p.x - p.x - 0.5 - 1.0", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * (1.0 - h) * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * (1.0 - h) * (1.0 - h) * (1.0 - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) + k * h * h * (3.0 - 2.0 * h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k, float t) {\n    float h = clamp(0.5 + 0.5 * (b - a)", "\n    return (a < 0.0)? -pow(-a, k) : pow(a, k);\n}\n\nfloat pabs(float a) {\n    return pabs(a, 1.0);\n}\n\nvec2 pabs(vec2 a, float k) {\n    return vec2(pabs(a.x, k), pabs(a.y, k));\n}\n\nvec2 pabs(vec2 a) {\n    return pabs(a, 1.0);\n}\n\nvec3 pabs(vec3 a, float k) {\n    return vec3(pabs(a.x, k), pabs(a.y, k), pabs(a.z, k));\n}\n\nvec3 pabs(vec3 a) {\n    return pabs(a, 1.0);\n}\n\nvec4 pabs(vec4 a, float k) {\n    return vec4(pabs(a.x, k), pabs(a.y, k), pabs(a.z, k), pabs(a.w, k));\n}\n\nvec4 pabs(vec4 a) {\n    return pabs(a, 1.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float k) {\n    return (a < 0.0)? -pow(-a, k) : pow(a, k);\n}\n\nfloat psign(float a) {\n    return psign(a, 1.0);\n}\n\nvec2 psign(vec2 a, float k) {\n    return vec2(psign(a.x, k), psign(a.y, k));\n}\n\nvec2 psign(vec2 a) {\n    return psign(a, 1.0);\n}\n\nvec3 psign(vec3 a, float k) {\n    return vec3(psign(a.x, k), psign(a.y, k), psign(a.z, k));\n}\n\nvec3 psign(vec3 a)", "\n    p = abs(p);\n    p -= 0.5;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = abs(sin(a)) * r;\n    return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat square(vec2 p, float s) {\n    return max(abs(p.x), abs(p.y)) - s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length( pa - ba * h );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat cross(vec2 p, float s) {\n    vec2 ba = vec2(s, 0.0);\n    vec2 pa = p - ba * clamp( dot(p, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length( pa - ba * clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 ) );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = fract(p * vec2(5.3983, 6.4427));\n    p += dot(p.yx, p.xy + vec2(3.7472, 15.5393));\n    return fract(p.x * p.y * 95.4337);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 6.4427, 3.7472));\n    p3 += dot(p3.yxz, p3.xyz + vec3(3.7472, 15.5393, 15.3475));\n    return fract(p3.x * p3.y * p3.z * 95.4337);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec4 p4) {\n    p4 = fract(p4 * vec4(5.3983, 6.4427, 3.7472, 15.5393));\n    p4 += dot(p4.yxzw, p4.xyzw + vec4(3.7472, 15.5393, 15.3475, 2.1406));\n    return fract(p4.x * p4.y * p4.z * p4.w * 95.4337);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nvec2 hash22(", "\n    vec2 p = pos - A;\n    vec2 a = B - A;\n    vec2 b = C - A;\n    vec2 r = a * b.y - b * a.y;\n    float s = 0.0;\n    float t = 0.0;\n    if (abs(r.x) > abs(r.y)) {\n        s = clamp(-a.y / r.x, 0.0, 1.0);\n        t = (b - a * s).x / b.x;\n    } else {\n        t = clamp(-b.y / r.y, 0.0, 1.0);\n        s = (a - b * t).y / a.y;\n    }\n    vec2 p1 = A + s * a + t * b;\n    return vec3(length((p - p1) / a), normalize(vec2(a.y, -a.x)), normalize(vec2(b.y, -b.x)));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 p = pos - A;\n    vec2 a = B - A;\n    vec2 b = C - A;\n    vec2 c = D - A;\n    vec2 r = a * c.y - c * a.y;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    if (abs(r.x) > abs(r.y)) {\n        s = clamp(-a.y / r.x, 0.0, 1.0);\n        t = (c - a * s).x / c.x;\n        u = (b - a * s - c * t).x / b.x;\n    } else {", "\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float d = 0.0;\n    d = (y*y)/(wi*wi) - x;\n    return vec3(d, d/wi, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float wf, in float hf )\n{\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float d = 0.0;\n    d = (y*y)/(wi*wi) - x;\n    d = d + (wf*wf)/(hf*hf) - y;\n    return vec3(d, d/wi, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec2 pos, in float wi, in float he, in float wf, in float hf, in float wg, in float hg )\n{\n    vec2 p = pos - vec2(wi,he);\n    float x = p.x;\n    float y = p.y;\n    float d = 0.0;\n    d = (y*y)/(wi*wi) - x;\n    d = d + (wf*wf)/(hf*hf) - y;\n    d = d + (wg*wg)/(hg*hg) - x;\n    return vec3(d, d/wi, 0.0);\n}\n\n//.x = f(p)", "\n    vec2 p = pos - vec2( 0.5 );\n    float x = p.x;\n    float y = p.y;\n    float d = k * x * x + y * y;\n    return vec3( d, 2.0 * k * x, 2.0 * y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdHyperbola( in vec2 pos, in float k )\n{\n    vec2 p = pos - vec2( 0.5 );\n    float x = p.x;\n    float y = p.y;\n    float d = k * x * x - y * y;\n    return vec3( d, 2.0 * k * x, -2.0 * y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdEllipse( in vec2 pos, in vec2 k )\n{\n    vec2 p = pos - vec2( 0.5 );\n    float x = p.x;\n    float y = p.y;\n    float d = k.x * x * x + k.y * y * y;\n    return vec3( d, 2.0 * k.x * x, 2.0 * k.y * y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdCircle( in vec2 pos, in float k )\n{\n    vec2 p = pos - vec2( 0.5 );\n    float x = p.x;\n    float y = p.y;\n    float d = k *", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float b = atan(p.y, p.x);\n    float c = r - d;\n    float d = r - d;\n    float e = r - d;\n    float f = r - d;\n    float g = r - d;\n    float h = r - d;\n    float i = r - d;\n    float j = r - d;\n    float k = r - d;\n    float l = r - d;\n    float m = r - d;\n    float n = r - d;\n    float o = r - d;\n    float p = r - d;\n    float q = r - d;\n    float r = r - d;\n    float s = r - d;\n    float t = r - d;\n    float u = r - d;\n    float v = r - d;\n    float w = r - d;\n    float x = r - d;\n    float y = r - d;\n    float z = r - d;\n    float aa = r - d;\n    float bb = r - d;\n    float cc = r - d;\n    float dd = r - d;\n    float ee = r - d;\n    float ff = r - d;\n    float gg = r - d;\n    float hh = r - d;\n    float ii = r - d;\n    float jj = r - d;\n    float kk = r - d;\n    float ll = r - d;\n    float mm = r - d;\n    float nn = r - d;\n    float oo = r - d;\n    float pp = r - d;\n    float qq = r - d;\n    float rr = r - d;\n    float ss = r - d;\n    float tt = r - d;\n    float uu = r - d;\n    float vv = r - d;\n    float ww = r - d;\n    float xx = r - d;\n    float yy = r - d;\n    float zz = r - d;\n    float aa = r -", "\n    v = v * 1664525 + 1013904223;\n    return v;\n}\n\nfloat Pcg2Float(ivec2 v)\n{\n    v = Pcg2(v);\n    return float(v.x) * (1.0 / float(0xffffffff));\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max)\n{\n    return min + Pcg2Float(v) * (max - min);\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias)\n{\n    return min + Pcg2Float(v, min, max) - bias;\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias, float scale)\n{\n    return min + Pcg2Float(v, min, max, bias) * scale;\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias, float scale, float offset)\n{\n    return min + Pcg2Float(v, min, max, bias, scale) + offset;\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias, float scale, float offset, float exponent)\n{\n    return min + Pcg2Float(v, min, max, bias, scale, offset) * pow(2.0, exponent);\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias, float scale, float offset, float exponent, float exponentBias)\n{\n    return min + Pcg2Float(v, min, max, bias, scale, offset, exponent) - exponentBias;\n}\n\nfloat Pcg2Float(ivec2 v, float min, float max, float bias, float scale, float offset, float exponent, float exponentBias, float exponentScale)\n{\n    return min + Pcg2Float(v, min, max, bias, scale, offset, exponent, exponentBias) * exponentScale;\n}\n\nfloat Pcg2Float(ivec", "\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int i)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z + i;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int i, int j)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z + i;\n    v.y += v.z * v.x + j;\n    v.z += v.x * v.y;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int i, int j, int k)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z + i;\n    v.y += v.z * v.x + j;\n    v.z += v.x * v.y + k;\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int i, int j, int k, int l)\n{\n    v = v * 1664525 + 1013904223;\n    v.x += v.y * v.z + i;\n    v.y += v.z * v.x + j;\n    v.z += v.x * v.y + k;\n    v.x += v.y * v.z + l;\n    v.y += v", "\n    vec2 p = pos - A;\n    vec2 a = B - A;\n    vec2 b = C - A;\n    vec2 r = a - b + b - a;\n    vec2 s = a * b;\n    vec2 q = p - s * 0.5;\n    float k = dot(q, r) / dot(a, r);\n    if (k < 0.0) {\n        return length(p);\n    }\n    if (k > 1.0) {\n        vec2 t = p - a - b;\n        return length(t);\n    }\n    vec2 pp = q + k * r;\n    return length(pp);\n}\n\n// signed distance to a cubic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D) {\n    vec2 p = pos - A;\n    vec2 a = B - A;\n    vec2 b = C - A;\n    vec2 c = D - A;\n    vec2 r = a - b - c + b + c;\n    vec2 s = a * b - a * c - b * c;\n    vec2 q = p - s * 0.5;\n    float k = dot(q, r) / dot(a, r);\n    if (k < 0.0) {\n        return length(p);\n    }\n    if (k > 1.0) {\n        vec2 t = p - a - b - c;\n        return length(t);\n    }\n    vec2 pp = q + k * r;\n    return length(pp);\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in vec2 E) {\n    vec2 p = pos - A;\n    vec2 a = B - A;\n    vec2 b = C - A;\n    vec2 c = D - A;\n    vec2 d = E - A;\n    vec2 r = a - b - c - d + b + c + d;", "\n    return (b.x - a.x) * (p.y - a.y) - (p.x - a.x) * (b.y - a.y);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) + winding_sign(p, b, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) + winding_sign(p, b, c, d, e);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) + winding_sign(p, b, c, d, e, f);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b, c, d, e, f) + winding_sign(p, b, c, d, e, f, g);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h) {\n    return winding_sign(p, a, b, c, d, e, f, g) + winding_sign(p, b, c, d, e", "\n    vec3  m = 1.0 - abs(rd);\n    float n = min(min(m.x, m.y), m.z);\n    vec3  q = ro + rd * n;\n    vec3  k = abs(q) - s;\n    vec3  p = max(k, 0.0);\n    float d = min(max(p.x, max(p.y, p.z)), 0.0) + length(max(k, 0.0));\n    return vec4(d, normalize(sign(q)));\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = sphere radius\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iSphere( in vec3 ro, in vec3 rd, in float s )\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - s*s;\n    float h = b*b - c;\n    if (h < 0.0) return vec4(1e20, vec3(0.0));\n    h = sqrt(h);\n    vec4 res = vec4(b - h, vec3(0.0));\n    res = min(res, vec4(b + h, vec3(0.0)));\n    res.yzw = normalize(ro + rd * res.x) * sign(res.x);\n    return res;\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = sphere radius\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3  m = 1.0 - abs(rd);\n    float n = min(min(m.x, m.y), m.z);\n    vec3  q = ro + rd * n;\n    vec3  k = abs(q) - s;\n    vec3  p = max(k", "\n    float a_f = float(a);\n    float a_f_abs = abs(a_f);\n    float a_f_abs_m1 = a_f_abs - 1.0;\n    float a_f_abs_m1_f = float(a_f_abs_m1);\n    float a_f_abs_m1_f_abs = abs(a_f_abs_m1_f);\n    float a_f_abs_m1_f_abs_m1 = a_f_abs_m1_f_abs - 1.0;\n    float a_f_abs_m1_f_abs_m1_f = float(a_f_abs_m1_f_abs_m1);\n    float a_f_abs_m1_f_abs_m1_f_abs = abs(a_f_abs_m1_f_abs_m1_f);\n    float a_f_abs_m1_f_abs_m1_f_abs_m1 = a_f_abs_m1_f_abs_m1_f_abs - 1.0;\n    float a_f_abs_m1_f_abs_m1_f_abs_m1_f = float(a_f_abs_m1_f_abs_m1_f_abs_m1);\n    float a_f_abs_m1_f_abs_m1_f_abs_m1_f_abs = abs(a_f_abs_m1_f_abs_m1_f_abs_m1_f);\n    float a_f_abs_m1_f_abs_m1_f_abs_m1_f_abs_m1 = a_f_abs_m1_f_abs_m1_f_abs_m1_f_abs - 1.0;\n    float a_f_abs_m1_f_abs_m1_f_abs_m1_f_abs_m1_f = float(a_f_abs_m1_f_abs_m1_f_abs_m1_f_abs_", "\n    vec3 d = b.xyz - a.xyz;\n    float d2 = dot(d, d);\n    float h = clamp( 0.5 - 0.5 * (d2 - k * k), 0.0, 1.0 );\n    return a.xyz + h * d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    vec3 d = b.xyz - a.xyz;\n    float d2 = dot(d, d);\n    float h = clamp( 0.5 + 0.5 * (d2 - k * k), 0.0, 1.0 );\n    return a.xyz + h * d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSClamp( in vec3 a, in vec3 b, in float k )\n{\n    vec3 d = b.xyz - a.xyz;\n    float d2 = dot(d, d);\n    float h = clamp( 0.5 - k * k / d2, 0.0, 1.0 );\n    return a.xyz + h * d;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSRepeat( in vec3 a, in vec3 b, in float k )\n{\n    vec3 d = b.xyz - a.xyz;\n    float d2 = dot(d, d);\n    float h", "\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float x2 = x*x;\n    float y2 = y*y;\n    float xy = x*y;\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    float a2b2x2 = a2b2*x2;\n    float a2b2y2 = a2b2*y2;\n    float a2b2xy = a2b2*xy;\n    float a2b2x2y2 = a2b2x2 + a2b2y2;\n    float a2b2x2y2xy = a2b2x2y2*xy;\n    float a2b2x2y2xy2 = a2b2x2y2*xy;\n    float a2b2x2y2xy2x2 = a2b2x2y2xy2*x2;\n    float a2b2x2y2xy2x2y2 = a2b2x2y2xy2x2*y2;\n    float a2b2x2y2xy2x2y2xy = a2b2x2y2xy2x2y2*xy;\n    float a2b2x2y2xy2x2y2xy2 = a2b2x2y2xy2x2y2*xy;\n    float a2b2x2y2xy2x2y2xy2x2 = a2b2x2y2xy2x2y2xy2*x2;\n    float a2b2x2y2xy2x2y2xy2x2y2 = a2b2x2y2xy2x2y2xy2x2*y2;\n    float a2b2x2y2xy2x2y2xy2x2y2xy = a2b2x2y2xy2x2y2xy2x2y2*xy;\n    float a2b2x2y2xy", "\n    return a + b;\n}\n\n//precision loss testing\nfloat sub_ploss(in float a, in float b){\n    return a - b;\n}\n\n//precision loss testing\nfloat mul_ploss(in float a, in float b){\n    return a * b;\n}\n\n//precision loss testing\nfloat div_ploss(in float a, in float b){\n    return a / b;\n}\n\n//precision loss testing\nfloat mod_ploss(in float a, in float b){\n    return a % b;\n}\n\n//precision loss testing\nfloat pow_ploss(in float a, in float b){\n    return pow(a, b);\n}\n\n//precision loss testing\nfloat sqrt_ploss(in float a){\n    return sqrt(a);\n}\n\n//precision loss testing\nfloat exp_ploss(in float a){\n    return exp(a);\n}\n\n//precision loss testing\nfloat log_ploss(in float a){\n    return log(a);\n}\n\n//precision loss testing\nfloat sin_ploss(in float a){\n    return sin(a);\n}\n\n//precision loss testing\nfloat cos_ploss(in float a){\n    return cos(a);\n}\n\n//precision loss testing\nfloat tan_ploss(in float a){\n    return tan(a);\n}\n\n//precision loss testing\nfloat asin_ploss(in float a){\n    return asin(a);\n}\n\n//precision loss testing\nfloat acos_ploss(in float a){\n    return acos(a);\n}\n\n//precision loss testing\nfloat atan_ploss(in float a){\n    return atan(a);\n}\n\n//precision loss testing\nfloat sinh_ploss(in float a){\n    return sinh(a);\n}\n\n//precision loss testing\nfloat cosh_ploss(in float a){\n    return cosh(a);\n}\n\n//precision loss testing\nfloat tanh_ploss(in float a){\n    return tanh(a);\n}\n\n//precision loss testing\n", "\n    vec2 a = ab;\n    vec2 b = ab;\n    float a2 = dot( a, a );\n    float b2 = dot( b, b );\n    float a2b2 = a2 * b2;\n    float a2b2_2 = a2b2 * 0.5;\n    float a2b2_4 = a2b2 * a2b2;\n    float a2b2_8 = a2b2 * a2b2_2;\n    float a2b2_16 = a2b2 * a2b2_4;\n    float a2b2_32 = a2b2 * a2b2_8;\n    float a2b2_64 = a2b2 * a2b2_16;\n    float a2b2_128 = a2b2 * a2b2_32;\n    float a2b2_256 = a2b2 * a2b2_64;\n    float a2b2_512 = a2b2 * a2b2_128;\n    float a2b2_1024 = a2b2 * a2b2_256;\n    float a2b2_2048 = a2b2 * a2b2_512;\n    float a2b2_4096 = a2b2 * a2b2_1024;\n    float a2b2_8192 = a2b2 * a2b2_2048;\n    float a2b2_16384 = a2b2 * a2b2_4096;\n    float a2b2_32768 = a2b2 * a2b2_8192;\n    float a2b2_65536 = a2b2 * a2b2_16384;\n    float a2b2_131072 = a2b2 * a2b2_32768;\n    float a2b2_262144 = a2b2 * a", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 c = a + h * ba;\n    float r = length(pa - c);\n    float d = length(pa) - ra - h * (rb - ra);\n    return vec4(d, c);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float d = length(pa) - ra - h * (rb - ra);\n    return vec4(d, a + h * ba);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float angle)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float d = length(pa) - ra - h * (rb - ra);\n    return vec4(d, a + h * ba);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float angle, float angle2)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float d = length(pa) - ra - h * (rb - ra);\n    return vec4(d, a + h * ba);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h, float angle, float angle2, float angle3)\n{\n    vec3 pa = p - a;\n    vec3 ba = b", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 ba = b - a;\n    float l = length(ba);\n    vec3 pa = p - a;\n    float x = dot(pa,ba);\n    float y = l*l - x*x;\n    float s = sign(y);\n    y = max(y,0.0);\n    return sqrt(s*x*x/l/l + (s*y - r*r)/l) * s;\n}\n\nfloat sdConeSection( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n    vec3 ba = b - a;\n    float l = length(ba);\n    vec3 pa = p - a;\n    float x = dot(pa,ba);\n    float y = l*l - x*x;\n    float s = sign(y);\n    y = max(y,0.0);\n    float k = pa.z*ba.y - pa.y*ba.z;\n    float d = (y - r2*r2 + r1*r1*l*l)/(2.0*l*r1);\n    d = min( d, (y + r2*r2 - r1*r1*l*l)/(2.0*l*r2) );\n    d = min( d, k/l );\n    d = min( d, sqrt(s*x*x/l/l + (s*", "\n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,q) - c.x*c.x, p.y );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x*0.866025 + p.y*0.5, -p.y) - h.y + max(q.z*0.5 - h.x, 0.);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdConeSection( in vec3 p, in vec3 c )\n{\n    float q = p.y;\n    float d1 = -q;\n    float d2 = max( dot(p.x", "\n    vec2 e = vec2( 0.001, 0.0 );\n    vec3 n = vec3(\n        map( pos + e.xyy ).dist - map( pos - e.xyy ).dist,\n        map( pos + e.yxy ).dist - map( pos - e.yxy ).dist,\n        map( pos + e.yyx ).dist - map( pos - e.yyx ).dist );\n    return normalize( n );\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    vec3 n = vec3(\n        map( pos + e.xyy ).dist - map( pos - e.xyy ).dist,\n        map( pos + e.yxy ).dist - map( pos - e.yxy ).dist,\n        map( pos + e.yyx ).dist - map( pos - e.yyx ).dist );\n    return normalize( n );\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    vec3 n = vec3(\n        map( pos + e.xyy ).dist - map( pos - e.xyy ).dist,\n        map( pos + e.yxy ).dist - map( pos - e.yxy ).dist,\n        map( pos + e.yyx ).dist - map( pos - e.yyx ).dist );\n    return normalize( n );\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in bool showSurface, in vec3 samplePoint, in float scale )\n{\n    vec2 e = vec2( 0.001, 0.0 );\n    vec3 n = vec3(\n        map(", "\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint, float k, float t1 )\n{\n    float res", "\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(ra, 0.0);\n    vec2 p2 = vec2(ra, he);\n    vec2 p3 = vec2(0.0, he);\n\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float bb = 0.0;\n    float cc = 0.0;\n    float dd = 0.0;\n\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n\n    float qq = 0", "\n    vec3 q = vec3( length(p.xz) - ra, p.y );\n    return vec4( length(q) - rb, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCapsule( vec3 p, float ra, float rb )\n{\n    return vec4( length(p) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n    return vec4( length(p.xz) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n    return vec4( length(p.xz) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgConeSection( vec3 p, float ra, float rb )\n{\n    return vec4( length(p.xz) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCapsuleSection( vec3 p, float ra, float rb )\n{\n    return vec4( length(p) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCylinderSection( vec3 p, float ra, float rb )\n{\n    return vec4( length(p.xz) - ra, 4.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgConeSection( vec3 p, float ra, float rb )\n{\n    return vec4( length(p.xz) - ra, 4.0 );\n}\n\n//where", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    return udSegment( p, a, b ) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w )\n{\n    return udSegment( p, a, b, r ) - w;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h )\n{\n    return udSegment( p, a, b, r, w ) - h;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h, in float d )\n{\n    return udSegment( p, a, b, r, w, h ) - d;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h, in float d, in float e )\n{\n    return udSegment( p, a, b, r, w, h, d ) - e;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h, in float d, in float e, in float f )\n{\n    return udSegment( p, a, b, r, w, h, d, e ) - f;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float w, in float h, in float d, in float e, in float f, in float g )\n{\n    return udSegment( p, a, b, r, w, h, d, e, f ) - g;\n}\n\nfloat udSeg", " return dot(v, v); }\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot2(ba), 0.0, 1.0 );\n    return length( pa - ba * h ) - r;\n}\n\n// Rounded cylinder https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Rounded cone https://iquilezles.org/articles/distfunctions/\nfloat sdCone(in vec3 p, in vec3 c)\n{\n  vec2 q = vec2(length(p.xz), p.y);\n  float d1 = -q.y-c.z;\n  float d2 = max(dot(q,c.xy), q.y);\n  return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Rounded cone https://iquilezles.org/articles/distfunctions/\nfloat sdConeSection(in vec3 p, in vec3 c, in float h)\n{\n  // c must be normalized\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)), q-c.z)*h;\n}\n\n// Rounded cone https://iquilezles.org/articles/distfunctions/\nfloat sdCone(in vec3 p, in float h, in float ra, in float rb)\n{\n  vec2 q = vec2(length(p.xz), p.y);\n  float d1 = max(dot(q, vec2(ra, h)), q.y);\n  float d2 =", "\n    vec2 d = maxCorner - minCorner;\n    vec2 q = abs(p) - d;\n    return max(q.x,q.y);\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 d = maxCorner - minCorner;\n    vec3 q = abs(p) - d;\n    return max(q.x,max(q.y,q.z));\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 d = maxCorner - minCorner;\n    vec4 q = abs(p) - d;\n    return max(q.x,max(q.y,max(q.z,q.w)));\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, out vec2 normal ) \n{\n    vec2 d = maxCorner - minCorner;\n    vec2 q = abs(p) - d;\n    float dis = max(q.x,q.y);\n    if (dis > 0.0)\n    {\n        normal = normalize(q);\n    }\n    else\n    {\n        normal = vec2(0.0);\n    }\n    return dis;\n}\n\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, out vec3 normal ) \n{\n    vec3 d = maxCorner - minCorner;\n    vec3 q = abs(p) - d;\n    float dis = max(q.x,max(q.y,q.z));\n    if (dis > 0.0)\n    {\n", "\n    vec3 col = vec3(0.0);\n    float time = iTime * 0.3 + uv.x * 0.1;\n    float speed = 0.05;\n    float amp = 0.05;\n    float freq = 0.05;\n    float dist = 0.0;\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0", "\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    ray.x *= 2.0;\n    ray.y *= 2.0;\n    ray.x -= 1.0;\n    ray.y -= 1.0;\n    ray.x *= aspect;\n    ray.y *= 1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z)\n{\n    vec3 ray = vec3(uv.x, uv.y, z);\n    ray.x *= 2.0;\n    ray.y *= 2.0;\n    ray.x -= 1.0;\n    ray.y -= 1.0;\n    ray.x *= aspect;\n    ray.y *= 1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 size)\n{\n    vec3 ray = vec3(uv.x, uv.y, 1.0);\n    ray.x *= size.x;\n    ray.y *= size.y;\n    ray.x -= 1.0;\n    ray.y -= 1.0;\n    ray.x *= aspect;\n    ray.y *= 1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, vec2 size, float z)\n{\n    vec3 ray = vec3(uv.x, uv.y, z);\n    ray.x *= size.x;\n    ray.y *= size.y;\n    ray.x -= 1.0;\n    ray.y -= 1.0;\n    ray.x *= aspect;\n    ray.y *= 1.0;\n    ray.z = -", "\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,\n        q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,\n        q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y *", "\n    vec2 q = p - c;\n    return length(q) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    vec2 k1 = vec2(ab.x, 0.0);\n    vec2 k2 = vec2(0.0, ab.y);\n    vec2 ca = vec2(ab.x * ab.x, ab.y * ab.y);\n    vec2 q = vec2( dot(k1, k1), dot(k2, k2) );\n    vec2 w = vec2( dot(k1, p), dot(k2, p) );\n    vec2 v = vec2( dot(k1, w), dot(k2, w) );\n    vec2 vv = vec2( dot(v,v) );\n    vec2 qv = vec2( dot(q,v) );\n    float d = abs(q.x*q.y) - dot(ca, qv);\n    float e = abs(q.y*vv.x - q.x*vv.y) + dot(ab, vv);\n    return length(max(e,d,0.0)) + min(max(e,d,0.0), 0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n    vec2 pq0 = v0 - e0 * clamp( dot(v0,e0) / dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1 * clamp( dot(v1,e1) / dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2 * cl", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x*0", "\n    return vec2( min( m.x, d ), m.y + a );\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    return vec2( min( m.x, d ), m.y + a * ( 1.0 - smoothstep( 0.0, 1.0, m.x / d ) ) );\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y - a );\n}\n\nvec2 opSmoothSubtraction( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y - a * ( 1.0 - smoothstep( 0.0, 1.0, d / m.x ) ) );\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y - a );\n}\n\nvec2 opSmoothIntersection( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y - a * ( 1.0 - smoothstep( 0.0, 1.0, m.x / d ) ) );\n}\n\nvec2 opDifference( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y + a );\n}\n\nvec2 opSmoothDifference( vec2 m, float d, float a )\n{\n    return vec2( max( m.x, d ), m.y + a * ( 1.0 - smoothstep( 0.0, 1.0, d / m.x ) ) );\n}\n\nvec2 opUnion( vec2 m, float d, float a )\n{\n    return vec2( min( m.x, d ), m.y + a );\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    return vec2( min( m.x,", "\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( ro, rd );\n    float c = dot( ro, ro ) - rad*rad;\n    float d = b*b - 4.0*a*c;\n    if( d<0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n    }\n    else\n    {\n        d = sqrt( d );\n        p1 = vec4( -b - d, a );\n        p2 = vec4( -b + d, a );\n    }\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,", "\n    vec2 d = abs(p - c) - r;\n    return vec3(length(max(d,0.0)), d.x*sign(p.x - c.x), d.y*sign(p.y - c.y));\n}\n\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r ) \n{\n    vec2 d = abs(p - c) / r;\n    return vec3(length(max(d,0.0)), d.x*sign(p.x - c.x), d.y*sign(p.y - c.y));\n}\n\nvec3 sdgLine( in vec2 p, in vec2 a, in vec2 b ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length( pa - ba*h ), sign(ba.y*pa.x - ba.x*pa.y), h );\n}\n\nvec3 sdgRect( in vec2 p, in vec2 b ) \n{\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)), sign(p.x), sign(p.y) );\n}\n\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c ) \n{\n    vec3 d = vec3( sdTriangle(p,a,b,c), sdTriangle(p,b,c,a), sdTriangle(p,c,a,b) );\n    return min(d,0.0);\n}\n\nvec3 sdgPolygon( in vec2 p, in int n, in vec2 r ) \n{\n    vec2 a = vec2(0.0,0.0);\n    vec2 b = vec2(0.0,0.0);\n    vec2 c = vec2(0.0,0.0);\n    vec2 d = vec2(0.0,0.0);\n    float m =", "\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)), sign(p.x)*sign(p.y), 0.0 );\n}\n\nvec3 sdgSphere( in vec3 p, in float s )\n{\n    return vec3( length(p)-s, 0.0, 0.0 );\n}\n\nvec3 sdgTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return vec3( length(q)-t.y, 0.0, 0.0 );\n}\n\nvec3 sdgHexPrism( in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q-h.xxzz,vec3(clamp(p.z,0.0,h.x),0.0,0.0));\n}\n\nvec3 sdgCylinder( in vec3 p, in float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h*vec2(1.0,0.5);\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), 0.0, 0.0 );\n}\n\nvec3 sdgCone( in vec3 p, in float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return vec3( max(q.x*cos(q.y),abs(q.y)-h), 0.0, 0.0 );\n}\n\nvec3 sdgCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h)-r, 0.", "\n    vec2 q = vec2( p.x, p.y );\n    vec2 r = vec2( p.y, p.x );\n    vec2 s = vec2( p.x, -p.y );\n    vec2 t = vec2( -p.y, p.x );\n    vec2 u = vec2( -p.x, p.y );\n    vec2 v = vec2( -p.y, -p.x );\n    vec2 w = vec2( p.x, 0.0 );\n    vec2 x = vec2( 0.0, p.y );\n    vec2 y = vec2( -p.x, 0.0 );\n    vec2 z = vec2( 0.0, -p.y );\n    vec2 a = vec2( p.x, p.x );\n    vec2 b = vec2( p.y, p.y );\n    vec2 c = vec2( p.x, -p.x );\n    vec2 d = vec2( p.y, -p.y );\n    vec2 e = vec2( -p.x, p.x );\n    vec2 f = vec2( -p.y, p.y );\n    vec2 g = vec2( -p.x, -p.x );\n    vec2 h = vec2( -p.y, -p.y );\n    vec2 i = vec2( p.x, 0.0 );\n    vec2 j = vec2( p.y, 0.0 );\n    vec2 k = vec2( 0.0, p.y );\n    vec2 l = vec2( 0.0, -p.y );\n    vec2 m = vec2( -p.x, 0.0 );\n    vec2 n = vec2( -p.y, 0.0 );\n    vec2 o = vec2( 0.0, p.x );\n    vec2 p = vec2( 0.0, -p.x );\n    vec2 q = vec2( p.x, p.y );\n    vec2 r = vec2( p.y, p.x );\n    vec2 s", "\n  return (a1 * x + b1) * x + (a2 * x + b2);\n}\n\nfloat g(float a1, float b1, float a2, float b2, float x, float y) {\n  return (a1 * x + b1) * x + (a2 * x + b2) * y;\n}\n\nfloat g(float a1, float b1, float a2, float b2, float a3, float b3, float x, float y) {\n  return (a1 * x + b1) * x + (a2 * x + b2) * y + (a3 * x + b3) * x * y;\n}\n\nfloat g(float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4, float x, float y) {\n  return (a1 * x + b1) * x + (a2 * x + b2) * y + (a3 * x + b3) * x * y + (a4 * x + b4) * x * x * y;\n}\n\nfloat g(float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4, float a5, float b5, float x, float y) {\n  return (a1 * x + b1) * x + (a2 * x + b2) * y + (a3 * x + b3) * x * y + (a4 * x + b4) * x * x * y + (a5 * x + b5) * x * x * x * y;\n}\n\nfloat g(float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4, float a5, float b5, float a6, float b6, float x, float y) {\n  return (a1 * x + b1) * x + (a2 * x + b2) * y + (a3 * x + b3) * x * y + (a4 * x + b4) * x * x * y + (", "\n  float y = 0.0;\n  float x2 = x * x;\n  float x4 = x2 * x2;\n  float x6 = x4 * x2;\n  float x8 = x4 * x4;\n  float x10 = x8 * x2;\n  float x12 = x8 * x4;\n  float x14 = x12 * x2;\n  float x16 = x12 * x4;\n  float x18 = x16 * x2;\n  float x20 = x16 * x4;\n  float x22 = x20 * x2;\n  float x24 = x20 * x4;\n  float x26 = x24 * x2;\n  float x28 = x24 * x4;\n  float x30 = x28 * x2;\n  float x32 = x28 * x4;\n  float x34 = x32 * x2;\n  float x36 = x32 * x4;\n  float x38 = x36 * x2;\n  float x40 = x36 * x4;\n  float x42 = x40 * x2;\n  float x44 = x40 * x4;\n  float x46 = x44 * x2;\n  float x48 = x44 * x4;\n  float x50 = x48 * x2;\n  float x52 = x48 * x4;\n  float x54 = x52 * x2;\n  float x56 = x52 * x4;\n  float x58 = x56 * x2;\n  float x60 = x56 * x4;\n  float x62 = x60 * x2;\n  float x64 = x60 * x4;\n  float x66 = x64 * x2;\n  float x68 = x64 * x4;\n  float x70 = x68 * x2;\n  float x72 = x68 * x4;\n  float x74 = x72", "\n                float time = iTime;\n                float t = time * 0.01;\n                float t2 = time * 0.001;\n                float t3 = time * 0.0001;\n                float t4 = time * 0.00001;\n                float t5 = time * 0.000001;\n                float t6 = time * 0.0000001;\n                float t7 = time * 0.00000001;\n                float t8 = time * 0.000000001;\n                float t9 = time * 0.0000000001;\n                float t10 = time * 0.00000000001;\n                float t11 = time * 0.000000000001;\n                float t12 = time * 0.0000000000001;\n                float t13 = time * 0.00000000000001;\n                float t14 = time * 0.000000000000001;\n                float t15 = time * 0.0000000000000001;\n                float t16 = time * 0.00000000000000001;\n                float t17 = time * 0.000000000000000001;\n                float t18 = time * 0.0000000000000000001;\n                float t19 = time * 0.00000000000000000001;\n                float t20 = time * 0.000000000000000000001;\n                float t21 = time * 0.000000000000", "\n    vec3 color = vec3( 0.0 );\n    vec2 p = vec2( x, y ) / iResolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.3 + p.x * 0.1;\n    float a = atan( p.y, p.x );\n    float r = length( p );\n    float f = 0.0;\n    float w = 0.0;\n    for( int i = 0; i < 10; i ++ )\n    {\n        float v = float( i );\n        float k = v / 10.0;\n        float d = abs( k - a / 6.28318530718 );\n        if( d < f )\n        {\n            f = d;\n            w = k;\n        }\n    }\n    float s = 0.0;\n    for( int i = 0; i < 10; i ++ )\n    {\n        float v = float( i );\n        float k = v / 10.0;\n        float d = abs( k - w );\n        s += d;\n    }\n    s = s / 10.0;\n    float c = cos( s * 6.28318530718 );\n    float s = sin( s * 6.28318530718 );\n    mat2 m = mat2( c, -s, s, c );\n    p = m * p * 1.5;\n    p *= 0.5;\n    p += 0.5;\n    p.x += t;\n    p *= 2.0;\n    float d = 0.0;\n    for( int i = 0; i < 10; i ++ )\n    {\n        float v = float( i );\n        float k = v / 10.0;\n        float a = k * 6.28318530718", "\n    vec2 d = p - c;\n    return length(d) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    vec2 d = abs(p) - ab;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e = vec2(0.0,0.001);\n    vec2 a = p - p0;\n    vec2 b = p - p1;\n    vec2 c = p - p2;\n    vec2 ab = vec2(length(a+e)-length(a-e),length(b+e)-length(b-e));\n    vec2 bc = vec2(length(b+e)-length(b-e),length(c+e)-length(c-e));\n    vec2 ca = vec2(length(c+e)-length(c-e),length(a+e)-length(a-e));\n    vec2 cb = vec2(length(c+e)-length(c-e),length(b+e)-length(b-e));\n    vec2 ac = vec2(length(a+e)-length(a-e),length(c+e)-length(c-e));\n    float s = (sign(p.x)*0.5+0.5)*sign(p.y);\n    return s*min(min(dot(ab,ab),dot(bc,bc)),dot(ca,ca)) + (1.0-s)*min(min(dot(cb,cb),dot(ac,ac)),dot(ab,ab));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRect( in vec2", "\n    vec2 d = abs(p)-c-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) - r + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec2 p, in vec2 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2),0.0);\n}\n\nfloat sdCylinder2( in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone2( in vec3 p, in vec2 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.x*c.x;\n    float d2 = max( dot(q,c.xy), q.", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.5;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    vec2 k1 = vec2(ab.x, 0.0);\n    vec2 k2 = vec2(0.0, ab.y);\n    vec2 ca = vec2(p.x*ab.x, p.y*ab.y);\n    vec2 ba = vec2(ab.x*ab.x, ab.y*ab.y);\n    vec2 r = ca/ba;\n    vec2 k3 = vec2(r.x, r.y)/vec2(ab.x*ab.x + ab.y*ab.y, ab.x*ab.y);\n    vec2 a = k1*k3*k1;\n    vec2 b = k2*k3*k2;\n    vec2 c = vec2(p.x*p.x, p.y*p.y) - vec2(ab.x*ab.x, ab.y*ab.y);\n    vec2 r2 = (a*a*b*b - 4.0*a*b*c - 4.0*a", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h * h;\n    float k = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d2 = dot(pa,pa) - h2 * (1.0 - k*k);\n    return vec2( d2, d2min );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h * h;\n    float k = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d2 = dot(pa,pa) - h2 * (1.0 - k*k);\n    return sqrt(d2);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min, float d2max )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h * h;\n    float k = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d2 = dot(pa,pa) - h2 * (1.0 - k*k);\n    return clamp( sqrt(d2), d2min, d2max );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min, float d2max, float d2max2 )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h", "\n    float d = 0.0;\n    float d0 = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = ", "\n    float d = sdEllipse( p, vec2( 0.5 ) );\n    d = min( d, sdEllipse( p, vec2( 0.5, 0.2 ) ) );\n    d = min( d, sdEllipse( p, vec2( 0.2, 0.5 ) ) );\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\n    float d = sdEllipse( p, vec2( 0.5 ) );\n    d = min( d, sdEllipse( p, vec2( 0.5, 0.2 ) ) );\n    d = min( d, sdEllipse( p, vec2( 0.2, 0.5 ) ) );\n    return d;\n}\n\n// correct inside and outside\nfloat sdC( in vec2 p )\n{\n    float d = sdEllipse( p, vec2( 0.5 ) );\n    d = min( d, sdEllipse( p, vec2( 0.5, 0.2 ) ) );\n    d = min( d, sdEllipse( p, vec2( 0.2, 0.5 ) ) );\n    return d;\n}\n\n// correct outside, incorrect inside\nfloat sdD( in vec2 p )\n{\n    float d = sdEllipse( p, vec2( 0.5 ) );\n    d = max( d, sdEllipse( p, vec2( 0.5, 0.2 ) ) );\n    d = max( d, sdEllipse( p, vec2( 0.2, 0.5 ) ) );\n    return d;\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\n    float d = sdEllipse( p, vec2( 0.5 ) );\n    d = max( d, sdEllipse( p, vec2( 0.5, 0.2 ) ) );\n    d = max( d, sdEllipse( p, vec2( 0.2, 0.5 ) ) );\n    return d;\n}\n\n// correct inside and outside\n", "\n    float b = sdBox( p, vec2( 0.5 ) );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), 0.25 );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b )\n{\n    float b = sdBox( p, b );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), 0.25 );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b, in float r )\n{\n    float b = sdBox( p, b );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), r );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b, in float r, in float e )\n{\n    float b = sdBox( p, b );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), r );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b, in float r, in float e, in float f )\n{\n    float b = sdBox( p, b );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), r );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b, in float r, in float e, in float f, in float g )\n{\n    float b = sdBox( p, b );\n    float d = sdDisc( p - vec2( 0.0, 0.5 ), r );\n    return min( b, d );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p, in vec2 b, in float r, in float e, in float f, in float g", "\n    vec3 color = vec3(0.0);\n    float pct = 0.0;\n    float w = 0.25;\n    float sw = 0.025;\n    float c = 1.0 - smoothstep(0.0, w, abs(sin(uv.y * 3.14159265358979323846)));\n    color += c * vec3(0.0, 0.0, 1.0);\n    c = 1.0 - smoothstep(0.0, w, abs(sin(uv.y * 3.14159265358979323846 + 1.57079632679489661923)));\n    color += c * vec3(0.0, 1.0, 0.0);\n    c = 1.0 - smoothstep(0.0, w, abs(sin(uv.y * 3.14159265358979323846 + 3.14159265358979323846)));\n    color += c * vec3(1.0, 0.0, 0.0);\n    c = 1.0 - smoothstep(0.0, w, abs(sin(uv.y * 3.14159265358979323846 + 4.71238898038468985769)));\n    color += c * vec3(1.0, 1.0, 0.0);\n    c = 1.0 - smoothstep(0.0, w, abs(sin(uv.y * 3.14159265358979323846 + 6.28318530717958647693)));\n    color += c * vec3(0.0, 1.0, 1.0);\n    c", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    if( t < 0.0 ) return a;\n    if( t > 1.0 ) return b;\n    return a + t * ab;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    return a + dot( p - a, ab ) / dot( ab, ab ) * ab;\n}\n\n// Closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, in float r )\n{\n    return c + normalize( p - c ) * r;\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 apmin = min( ap, bp );\n    vec2 apmax = max( ap, bp );\n    return a + clamp( apmin, -ab, ab );\n}\n\n// Closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ap = p - a;\n    vec2 bp = p - b;\n    vec2 cp = p - c;\n    vec2 apmin = min( ap, bp );\n    vec2 apmax = max( ap, bp );\n    vec2 bpmin = min( bp, cp );\n    vec2 bpmax = max( bp, cp );\n    vec2 cpmin = min( cp, ap );\n    vec2 cpmax = max( cp, ap );\n    vec2 abmin = min( apmin, bpmin );\n    vec2 abmax = max( apmax, bpmax );\n    vec2 ac", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p) - r;\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec3 pa = vec3(p.x,p.y,0.0) - vec3(a.x,a.y,0.0);\n    vec3 ba = vec3(b.x,b.y,0.0) - vec3(a.x,a.y,0.0);\n    vec3 ca = vec3(c.x,c.y,0.0) - vec3(a.x,a.y,0.0);\n    vec3 pb = cross(pa,ba);\n    vec3 pc = cross(pb,ca);\n    vec3 n = ca.z < 0", "\n    vec2 q = abs(p) - b;\n    return -clamp( q, vec2(-r), vec2(r) );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in vec2 r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q, -r, r );\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in float b, in float r )\n{\n    vec2 q = abs(p) - b;\n    return -clamp( q,", "\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// distance to line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    float x = length(p.xz)-ab.x;\n    float y = p.y-ab.y;\n    return length(vec2(x,y));\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec3 q = vec3( p.x, p.y, 1.0 );\n    vec3 a = vec3( p0.x, p0.y, 1.0 );\n    vec3 b = vec3( p1.x, p1.y, 1.0 );\n    vec3 c = vec3( p2.x, p2.y, 1.0 );\n    vec3 ab = b - a;\n    vec", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float s )\n{\n    return length(p)-s;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    float k = (ab.y*ab.y)/(ab.x*ab.x);\n    return length(p*k-ab)*sqrt(k);\n}\n\n// distance to line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in int n, in vec2 *v )\n{\n    float d = dot(v[0],p-v[0]);\n    for( int i = 1; i < n; i++ )\n        d = min( d, dot(v[i],p-v[i]) );\n    return d;\n}\n\n// distance to polyline\nfloat sdPolyline( in vec2 p, in int n, in vec2 *v )\n{\n    float d = dot(v[0],p-v[0]);\n    for( int i = 1; i < n; i++ )\n        d = min( d, dot(v[i],p-v[i]) );\n    return d;\n}\n\n// distance to rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b + vec2(r,r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2", "\n    p  = fract(p *.1031);\n    p += dot(p, p + 31.31);\n    return fract(p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    p  = fract(p *.1031);\n    p += dot(p, p + 31.31);\n    return fract(p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    p  = fract(p *.1031);\n    p += dot(p, p + 31.31);\n    return fract(p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    p  = fract(p *.1031);\n    p += dot(p, p + 31.31);\n    return fract(p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n    p  = fract(p *.1031);\n    p += dot(p, p + 31.31);\n    return fract(p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 45.543))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 45.543, 1.0))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, float y)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x, float y)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 45.543))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x, float y)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 45.543, 1.0))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, vec2 y)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = random2(i);\n    float b = random2(i + vec2(1.0, 0.0));\n    float c = random2(i + vec2(0.0, 1.0));\n    float d = random2(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n    //                 mix(c, d, smoothstep(0.0, 1.0, f.x)),\n    //                 smoothstep(0.0, 1.0, f.y)));\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)*u.y * (1.0 - u.x) +\n            (d - b)*u.x * u.y;\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p * 2.02;\n    f += 0.2500 * noise( p ); p = p * 2.", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat triValueNoise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n        (c - a) * u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y +\n        (e - c) * u.y * (1.0 -", "\n    float f = 0.0;\n    f += 0.5000 * noise(x); x = x * 2.02;\n    f += 0.2500 * noise(x); x = x * 2.03;\n    f += 0.1250 * noise(x); x = x * 2.01;\n    f += 0.0625 * noise(x); x = x * 2.02;\n    f += 0.0312 * noise(x); x = x * 2.03;\n    f += 0.0156 * noise(x); x = x * 2.01;\n    f += 0.0078 * noise(x); x = x * 2.02;\n    f += 0.0039 * noise(x); x = x * 2.03;\n    f += 0.0019 * noise(x); x = x * 2.01;\n    f += 0.0009 * noise(x); x = x * 2.02;\n    f += 0.0004 * noise(x); x = x * 2.03;\n    f += 0.0002 * noise(x); x = x * 2.01;\n    f += 0.0001 * noise(x);\n    return f / 0.9808;\n}\n\n// 2D simplex noise\nfloat simplex(vec2 p)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    f = f * f*(3.0 - 2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix(dot(hash(n+  0.0), f -  0.0),\n                   dot(hash(n+  1.0), f -  1.0), u.x),\n               mix(dot(hash(n+ 57.0), f -  57.0),\n                   dot(hash(n+", "\n    float a = 0.0;\n    float k = 0.142857142857;\n    a += abs(sin(k*x.x)*sin(k*x.y));\n    a += abs(sin(k*x.y)*sin(k*x.x));\n    a /= 2.0;\n    a = 1.0 - a;\n    return a;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x, float t)\n{\n    float a = 0.0;\n    float k = 0.142857142857;\n    a += abs(sin(k*x.x+t)*sin(k*x.y+t));\n    a += abs(sin(k*x.y+t)*sin(k*x.x+t));\n    a /= 2.0;\n    a = 1.0 - a;\n    return a;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x, float t, float s)\n{\n    float a = 0.0;\n    float k = 0.142857142857;\n    a += abs(sin(k*x.x+t)*sin(k*x.y+t+s));\n    a += abs(sin(k*x.y+t)*sin(k*x.x+t+s));\n    a /= 2.0;\n    a = 1.0 - a;\n    return a;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x, float t, float s, float r)\n{\n    float a = 0.0;\n    float k = 0.142857142857;\n    a += abs(sin(k*x.x+t)*sin(k*x.y+t+s)*sin", "\n    float r = sqrt(x * x + y * y);\n    return r * M_PI;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float r = sqrt(x * x + y * y);\n    return M_PI * (1.0 - r * r);\n}\n\n//\n// Compute the solid angle of a texel in a cubemap.\n//\n// The cubemap is assumed to be a square texture with a size of 2^level.\n//\n// The texel is specified by its coordinates in the cubemap.\n//\n// The level of the cubemap is specified by level.\n//\n// The return value is the solid angle of the texel.\n//\nfloat texelSolidAngle(float x, float y, int level)\n{\n    float size = 1.0;\n    float size2 = size * size;\n    float size4 = size2 * size2;\n\n    float area = areaElement(x, y);\n    float solidAngle = texelSolidAngle(x, y);\n\n    float texelSolidAngle = solidAngle * size4 / area;\n\n    return texelSolidAngle;\n}\n\n//\n// Compute the solid angle of a texel in a cubemap.\n//\n// The cubemap is assumed to be a square texture with a size of 2^level.\n//\n// The texel is specified by its coordinates in the cubemap.\n//\n// The level of the cubemap is specified by level.\n//\n// The return value is the solid angle of the texel.\n//\nfloat texelSolidAngle(int x, int y, int level)\n{\n    float size = 1.0;\n    float size2 = size * size;\n    float size4 = size2 * size2;\n\n    float area = areaElement(x, y);\n    float solidAngle = texelSolidAngle(x, y);\n\n    float texelSolidAngle = solidAngle * size4 / area;\n\n    return texelSolidAngle;\n}\n\n//\n// Compute the solid angle of a texel in a cubemap.\n//", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise33(vec3 p) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the\n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 uvw = f * f * (3.0 - 2.0 * f);\n\n    // The base input to the 1D hash\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), uvw.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), uvw.x), uvw.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), uvw.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), uvw.x), uvw.y), uvw.z);\n}\n\n// From David Hoskins (MIT licensed): https://www.sh", "\n    const vec3 s = vec3(7, 157, 113);\n    vec3 i = floor(p + dot(p, s));\n    vec3 f = fract(p + dot(p, s));\n    f *= f * (3.0 - 2.0 * f);\n    vec4 v = vec4(0.6, 0.59, 0.6, 0.6);\n    v = mix(v, vec4(0.5, 0.5, 0.6, 0.6), clamp(dot(i, vec3(1.0)), 0.0, 1.0));\n    return mix(mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y), mix(v.y, v.w, f.y), f.z);\n}\n\nfloat simplex2d(vec2 p) {\n    const vec2 s = vec2(7, 157);\n    vec2 i = floor(p + dot(p, s));\n    vec2 f = fract(p + dot(p, s));\n    f *= f * (3.0 - 2.0 * f);\n    vec3 v = vec3(0.6, 0.59, 0.6);\n    v = mix(v, vec3(0.5, 0.5, 0.6), clamp(dot(i, vec2(1.0)), 0.0, 1.0));\n    return mix(mix(v.x, v.y, f.x), v.z, f.y);\n}\n\nfloat simplex1d(float p) {\n    const float s = 7;\n    float i = floor(p + dot(p, s));\n    float f = fract(p + dot(p, s));\n    f *= f * (3.0 - 2.0 * f);\n    float v = 0.6;\n    v = mix(v, 0.5, clamp(dot(i, 1.0), 0.0, ", "\n    vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// iq's noise\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0), f.x),\n                     mix( hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0), f.x),\n                         mix( hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                     mix(mix( hash(n+113.0), hash(n+114.0), f.x),\n                         mix( hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\n// iq's noise\nfloat noise( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float w )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float w, float w2 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w - w2;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float w, float w2, float w3 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r - w - w2 - w3;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float w, float w2, float w3, float w4 )\n{\n    vec2 pa = p - a, ba = b - a;\n    float", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - r.x;\n}\n\n// This is the final form\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdCylinder( vec3 p, float r, float h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec3(q,p.z,0.0));\n}\n\n// This is the final form\nfloat sdCone( in vec3 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p.xy),p.z);\n    return dot(vec3(r,h,0.0),normalize(q));\n}\n\n// This is the final form\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba", "\n    // The projection is a conic section.\n    // The center of the projection is the center of the disk.\n    // The major axis is the normal of the disk.\n    // The minor axis is the normal of the disk rotated 90 degrees.\n    // The major and minor axes are perpendicular to each other.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated 90 degrees.\n    // The major axis is the axis of the ellipse.\n    // The minor axis is the axis of the ellipse rotated ", "\n    p = fract(p * vec2(234.34, 345.34));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nfloat Hash12(vec3 p3)\n{\n    p3 = fract(p3 * vec3(234.34, 345.34, 456.34));\n    p3 += dot(p3, p3 + 34.23);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nfloat Hash12(vec4 p4)\n{\n    p4 = fract(p4 * vec4(234.34, 345.34, 456.34, 567.34));\n    p4 += dot(p4, p4 + 34.23);\n    return fract(p4.x * p4.y * p4.z * p4.w);\n}\n\nfloat Hash12(float p)\n{\n    return fract(sin(p * 123.45) * 435.34);\n}\n\nfloat Hash12(vec2 p)\n{\n    return fract(sin(dot(p, vec2(123.45, 345.34))) * 435.34);\n}\n\nfloat Hash12(vec3 p)\n{\n    return fract(sin(dot(p, vec3(123.45, 345.34, 456.34))) * 435.34);\n}\n\nfloat Hash12(vec4 p)\n{\n    return fract(sin(dot(p, vec4(123.45, 345.34, 456.34, 567.34))) * 435.34);\n}\n\nfloat Hash12(float p)\n{\n    return fract(sin(p * 1", "\n    float d = 0.0;\n    float an2 = an * an;\n    float bn2 = bn * bn;\n    float anbn = an * bn;\n    float anbn2 = anbn * anbn;\n    float anbn3 = anbn * anbn2;\n    float anbn4 = anbn2 * anbn2;\n    float anbn5 = anbn3 * anbn2;\n    float anbn6 = anbn4 * anbn2;\n    float anbn7 = anbn5 * anbn2;\n    float anbn8 = anbn6 * anbn2;\n    float anbn9 = anbn7 * anbn2;\n    float anbn10 = anbn8 * anbn2;\n    float anbn11 = anbn9 * anbn2;\n    float anbn12 = anbn10 * anbn2;\n    float anbn13 = anbn11 * anbn2;\n    float anbn14 = anbn12 * anbn2;\n    float anbn15 = anbn13 * anbn2;\n    float anbn16 = anbn14 * anbn2;\n    float anbn17 = anbn15 * anbn2;\n    float anbn18 = anbn16 * anbn2;\n    float anbn19 = anbn17 * anbn2;\n    float anbn20 = anbn18 * anbn2;\n    float anbn21 = anbn19 * anbn2;\n    float anbn22 = anbn20 * anbn2;\n    float anbn23 = anbn21 * anbn2;\n    float anbn24 = anbn22 * anbn2;\n    float anbn25 = anbn23 * anbn2;\n    float anbn26 = anbn24 * anbn2;\n    float anbn27 = anbn25 * anbn2;\n    float anbn28 = anbn26 * anbn2;\n    float anbn29 = anbn27 * anbn2;\n    float anbn30 = anbn28 *", "\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( vec3(\n        map( p + e.xyy ).x - map( p - e.xyy ).x,\n        map( p + e.yxy ).x - map( p - e.yxy ).x,\n        map( p + e.yyx ).x - map( p - e.yyx ).x ) );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p, float r )\n{\n    const float k = 1.73205080756887729; // (1 + sqrt(5))/2\n    p.x = abs( p.x );\n    p.y = abs( p.y );\n    p.z = abs( p.z );\n    float d = max( p.x + p.y + p.z - k, -p.x );\n    d = max( d, -p.y );\n    d = max( d, -p.z );\n    return d;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p )\n{\n    return sdTetrahedron( p, 1.0 );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p, vec3 h )\n{\n    return sdTetrahedron( p, length( h ) );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p, vec3 h, float r )\n{\n    return sdTetrahedron( p, length( h ) - r );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTetrahedron( vec3 p, float r, float h )\n{\n    return sdTetrahedron( p, vec3", "\n    float res = 1.0;\n    float t = t0;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//-----------------------------------------------------------------------\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy) +\n                     e.yyx*map(p + e.yyx) +\n                     e.yxy*map(p + e.yxy) +\n                     e.xxx*map(p + e.xxx));\n}\n\n//-----------------------------------------------------------------------\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 e = vec3(0.0, EPSILON, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n//-----------------------------------------------------------------------\n\nvec3 calcNormal2(vec3 p)\n{\n    vec3 e = vec3(0.0, EPSILON, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n//-----------------------------------------------------------------------\n\nvec3 calcNormal3(vec", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 pos, in float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( pos + t*rd ).x;\n        res = min( res, k*h/t );\n        t += h;\n        if( h<0.001 || t>100.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    vec3 nor = calcNormal( pos );\n    float occ = calcAO( pos, nor );\n   ", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Helper function generating a rotation matrix around the X axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c);\n}\n\n// Helper function generating a rotation matrix around the Y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(c, 0.0, -s,\n                0.0, 1.0, 0.0,\n                s, 0.0, c);\n}\n\n// Helper function generating a rotation matrix around the Z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Helper function generating a rotation matrix around the X axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float s = sin(angle);\n    float", "\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv.x, uv.y, -1.0));\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv.x, uv.y, -1.0));\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float aspect) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv.x, uv.y, -1.0));\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float aspect, float fov) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv.x, uv.y, -1.0));\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse, float aspect, float fov, float near, float far) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv.x, uv.y, -1.0));\n    return ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec2 mouse,", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 45.543))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4dTime(vec4 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 45.543))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 45.543))) * 43758.5453);\n}\n\n// Standard 4d noise\nfloat rand4d(vec4 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233, 45.543))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float time){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453 + time);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float time){\n    return fract(sin(dot(co.xyz,vec", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p * 12.9898) * 43758.5453);\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n    return fract(sin(dot(p, vec4(12.9898, 78.233, 45.5432, 1.0))) * 43758.5453);\n}\n\n// Hash for 5d vectors\nfloat rand5d(vec5 p){\n    return fract(sin(dot(p, vec5(12.9898, 78.233, 45.5432, 1.0, 1.0))) * 43758.5453);\n}\n\n// Hash for 6d vectors\nfloat rand6d(vec6 p){\n    return fract(sin(dot(p, vec6(12.9898, 78.233, 45.5432, 1.0, 1.0, 1.0))) * 43758.5453);\n}\n\n// Hash for 7d vectors\nfloat rand7d(vec7 p){\n    return fract(sin(dot(p, vec7(12.9898, 78.233, 45.5432, 1.0, 1.0, 1.0, 1.0))) * 43758.5", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D gradient noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D gradient noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D gradient noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.", "\n    vec3 s = floor(p);\n    vec3 x = p - s;\n    x = x*x*(3.0-2.0*x);\n\n    vec4 h = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for(int i = 0; i <= 3; i++)\n    for(int j = 0; j <= 3; j++)\n    for(int k = 0; k <= 3; k++)\n    {\n        vec3 g = vec3(i, j, k);\n        vec3 o = step(g, x);\n        vec3 r = x - o;\n        vec3 b = 1.0 - o;\n        float c = dot(r, r);\n        float d = dot(g, b);\n        h += o*b*b*b*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*", "\n    float fbm = 0.0;\n    float scale = 0.001;\n    float weight = 0.5;\n    for(int i = 0; i < 5; i++){\n        fbm += weight * noise(p * scale);\n        scale *= 2.0;\n        weight *= 0.5;\n    }\n    return fbm;\n}\n\n// This is the main function that is called for each pixel\nvoid main() {\n    // Get the position of the pixel in the world\n    vec3 p = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p3 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p2 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p1 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p0 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p4 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p5 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p6 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p7 = vec3(gl_FragCoord.xy, 0.0) / resolution.xy;\n    // Get the position of the pixel in the world\n    vec3 p8 = vec3(gl_FragCoord.xy,", "\n\tvec2 res = vec2(0.0);\n\tfloat d = 0.0;\n\tfloat t = 0.0;\n\tfloat tt = 0.0;\n\tfloat ttt = 0.0;\n\tfloat tttt = 0.0;\n\tfloat ttttt = 0.0;\n\tfloat tttttt = 0.0;\n\tfloat ttttttt = 0.0;\n\tfloat tttttttt = 0.0;\n\tfloat ttttttttt = 0.0;\n\tfloat tttttttttt = 0.0;\n\tfloat ttttttttttt = 0.0;\n\tfloat tttttttttttt = 0.0;\n\tfloat ttttttttttttt = 0.0;\n\tfloat tttttttttttttt = 0.0;\n\tfloat ttttttttttttttt = 0.0;\n\tfloat tttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttttttttttt = 0.0;\n\tfloat tttttttttttttttttttttttttttt = 0.0;\n\tfloat ttttttttttttttttttt", "\n    vec3 color = vec3(0.0);\n    vec3 dir = normalize(point);\n    float coverage = 0.0;\n    float step = 0.0;\n    float maxDist = 1000.0;\n    float minDist = 0.0;\n    float maxCoverage = 1.0;\n    float minCoverage = 0.0;\n    float maxStep = 1.0;\n    float minStep = 0.0;\n    float maxRandom = 1.0;\n    float minRandom = 0.0;\n    float maxSmooth = 1.0;\n    float minSmooth = 0.0;\n    float maxSmoothStep = 1.0;\n    float minSmoothStep = 0.0;\n    float maxSmoothStep2 = 1.0;\n    float minSmoothStep2 = 0.0;\n    float maxSmoothStep3 = 1.0;\n    float minSmoothStep3 = 0.0;\n    float maxSmoothStep4 = 1.0;\n    float minSmoothStep4 = 0.0;\n    float maxSmoothStep5 = 1.0;\n    float minSmoothStep5 = 0.0;\n    float maxSmoothStep6 = 1.0;\n    float minSmoothStep6 = 0.0;\n    float maxSmoothStep7 = 1.0;\n    float minSmoothStep7 = 0.0;\n    float maxSmoothStep8 = 1.0;\n    float minSmoothStep8 = 0.0;\n    float maxSmoothStep9 = 1.0;\n    float minSmoothStep9 = 0.0;\n    float maxSmoothStep10 = 1.0;\n    float minSmoothStep10 = 0.0;\n    float maxSmoothStep11 = 1.0;\n    float minSmoothStep11 = 0.0;\n    float maxSmoothStep12 = 1.0", "\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float tStep = 0.01;\n    float tMax = 100.0;\n    float tMin = 0.0;\n    float tCurrent = tMin;\n    float tPrevious = tMin;\n    float tNext = tMin;\n    float tNextNext = tMin;\n    float tNextNextNext = tMin;\n    float tNextNextNextNext = tMin;\n    float tNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = tMin;\n    float tNext", "\n    color *= 1.0 - 0.004 * color;\n    return (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 reinhard_tonemap(vec3 color) {\n    return color / (1.0 + color);\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 uncharted2_tonemap(vec3 color) {\n    const float A = 0.15;\n    const float B = 0.50;\n    const float C = 0.10;\n    const float D = 0.20;\n    const float E = 0.02;\n    const float F = 0.30;\n    const float W = 11.2;\n    return ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 filmic_tonemap(vec3 color) {\n    const float W = 11.2;\n    const float exposure_bias = 2.0;\n    const float white_point = 11.2;\n    const float linear_exposure = 2.0;\n    const float shoulder = 0.9;\n    const float linear_shoulder = 0.9;\n    const float linear_mid = 0.1;\n    const float linear_stop = 0.01;\n    const float linear_high = 0.0;\n    const float linear_low = 0.0;\n    const float toe_amount = 0.05;\n    const float toe_linear = 0.05;\n"]}