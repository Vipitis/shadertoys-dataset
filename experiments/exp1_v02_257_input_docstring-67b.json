{"input_docstring": ["\n\treturn cos( a );\n}\n\nfloat", "\n    //vec3 rotDir = vec3(0.0, 1.0, 0.0);\n    //vec3 rotAxis = normalize(cross(rotDir, vec3(0.0, 0.0, 1.0)));\n    //float rotAngle = -0.5*PI;\n    //p = p*mat3(rotAngle, rotAxis);\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Get the distance to the voxel\n\tfloat d = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d2 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d3 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d4 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d5 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d6 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d7 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d8 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d9 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d10 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d11 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d12 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d13 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d14 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d15 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d16 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d17 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d18 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d19 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d", "\n\tglowCounter = glowCounter + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the screen size\n\tvec2 screenSize = iResolution.xy;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1", "\n\tvec4 colors[4];\n\tcolors[0] = vec4(0.0, 0.0, 1.0, 1.0);\n\tcolors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n\tcolors[2] = vec4(1.0, 1.0, 0.0, 1.0);\n\tcolors[3] = vec4(1.0, 0.0, 0.0, 1.0);\n\n\tfloat steps[4];\n\tsteps[0] = 0.0;\n\tsteps[1] = 0.25;\n\tsteps[2] = 0.5;\n\tsteps[3] = 1.0;\n\n\tvec4 color1 = mix(colors[0], colors[1], smoothstep(steps[0], steps[1], x));\n\tvec4 color2 = mix(colors[1], colors[2], smoothstep(steps[1], steps[2], x));\n\tvec4 color3 = mix(colors[2], colors[3], smoothstep(steps[2], steps[3], x));\n\n\treturn mix(color1, color2, smoothstep(steps[1], steps[2], x));\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= resolution.x / resolution.y;\n\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat f = cos(a * 12.0) * pow(r, 2.0) + 0.5;\n\n\tgl_FragColor = gradient(f);\n}\n", "\n\tvec4 color = texture(colorGradient, vec2(d, 0.0));\n\t\n\t// lookup in normal gradient\n\tvec3 normal = texture(normalGradient, vec2(d, 0.0)).rgb;\n\t\n\t// lookup in specular gradient\n\tfloat specular = texture(specularGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in emissive gradient\n\tvec3 emissive = texture(emissiveGradient, vec2(d, 0.0)).rgb;\n\t\n\t// lookup in opacity gradient\n\tfloat opacity = texture(opacityGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in roughness gradient\n\tfloat roughness = texture(roughnessGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in metallic gradient\n\tfloat metallic = texture(metallicGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in ambient occlusion gradient\n\tfloat ambientOcclusion = texture(ambientOcclusionGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmission = texture(transmissionGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionRoughness = texture(transmissionRoughnessGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionIOR = texture(transmissionIORGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionAnisotropy = texture(transmissionAnisotropyGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionSpecular = texture(transmissionSpecularGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionMetallic = texture(transmissionMetallicGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat", " up\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t);\n\n    // sun color\n    vec3 sunColor = vec3(1.0, 0.9, 0.8);\n\n    // sky color\n    vec3 skyColor = vec3(0.0, 0.0, 0.0);\n\n    // mix the two colors\n    return mix(skyColor, sunColor, t);\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec3 rayDir = normalize(v_texCoord.xyz);\n\n    // get the sun direction\n    vec3 sunDir = normalize(vec3(0.0, 1.0, 0.0));\n\n    // get the color\n    vec3 color = GetEnvColor2(rayDir, sunDir);\n\n    // output the color\n    out_color = vec4(color, 1.0);\n}\n", "\n    float t = mod ( time, 6.0 ) - 2.0;\n\n    // if t is negative, we're before the curve\n    if ( t < 0.0 )\n        return 0.0;\n\n    // if t is greater than 2.0, we're after the curve\n    if ( t > 2.0 )\n        return 0.0;\n\n    // if t is between 0.0 and 2.0, we're in the curve\n    return 1.0;\n}\n\nvoid main ( void )\n{\n    // get the texture coordinates\n    vec2 coords = gl_TexCoord[0].st;\n\n    // get the current pixel\n    vec4 pixel = texture2D ( texture, coords );\n\n    // get the current pixel's color\n    vec3 color = pixel.rgb;\n\n    // get the current pixel's alpha\n    float alpha = pixel.a;\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2", "\n    float t = mod ( time, 10.0 ) - 2.0;\n    if ( t < 0.0 ) t += 10.0;\n\n    // the curve is a sine wave with a period of 10.0\n    float x = coords.x - 0.5;\n    float y = coords.y - 0.5;\n    float r = sqrt ( x * x + y * y );\n    float a = atan ( y, x );\n    float s = sin ( 10.0 * a );\n    float f = s * r;\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a", "\n    float t = mod ( time, 5.0 ) - 1.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0", " by changing the value of the variable\n    float speed = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing the value of the variable\n    float size = 0.001;\n    \n    //change the shape of the animation by changing the value of the variable\n    float shape = 0.001;\n    \n    //change the position of the animation by changing the value of the variable\n    float position = 0.001;\n    \n    //change the rotation of the animation by changing the value of the variable\n    float rotation = 0.001;\n    \n    //change the scale of the animation by changing the value of the variable\n    float scale = 0.001;\n    \n    //change the opacity of the animation by changing the value of the variable\n    float opacity = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    float color2 = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing the value of the variable\n    float size2 = 0.001;\n    \n    //change the shape of the animation by changing the value of the variable\n    float shape2 = 0.001;\n    \n    //change the position of the animation by changing the value of the variable\n    float position2 = 0.001;\n    \n    //change the rotation of the animation by changing the value of the variable\n    float rotation2 = 0.001;\n    \n    //change the scale of the animation by changing the value of the variable\n    float scale2 = 0.001;\n    \n    //change the opacity of the animation by changing the value of the variable\n    float opacity2 = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    float color3 = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing", "\n    float n = p.x + p.y + p.z + iTime * 0.1;\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin", "\n    // p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    // Slower, but more evenly disperses things.\n    p = p*127.1 + p.yx*269.5;\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec", "vec2 grid = floor(p);\n    //vec2 grid_offset = vec2(37.0, 17.0);\n    //float grid_id = dot(grid, grid_offset);\n    \n    //vec2 grid_offset_2 = vec2(1.0, 1.0);\n    //float grid_id_2 = dot(grid, grid_offset_2);\n    \n    //vec2 grid_offset_3 = vec2(1.0, 0.0);\n    //float grid_id_3 = dot(grid, grid_offset_3);\n    \n    //vec2 grid_offset_4 = vec2(0.0, 1.0);\n    //float grid_id_4 = dot(grid, grid_offset_4);\n    \n    //vec2 grid_offset_5 = vec2(0.0, 0.0);\n    //float grid_id_5 = dot(grid, grid_offset_5);\n    \n    //vec2 grid_offset_6 = vec2(1.0, 1.0);\n    //float grid_id_6 = dot(grid, grid_offset_6);\n    \n    //vec2 grid_offset_7 = vec2(1.0, 0.0);\n    //float grid_id_7 = dot(grid, grid_offset_7);\n    \n    //vec2 grid_offset_8 = vec2(0.0, 1.0);\n    //float grid_id_8 = dot(grid, grid_offset_8);\n    \n    //vec2 grid_offset_9 = vec2(0.0, 0.0);\n    //float grid_id_9 = dot(grid, grid_offset_9);\n    \n    //vec2 grid_offset_10 = vec2(1.0, 1.0);\n    //float grid_id_10 = dot(grid, grid_offset_10);\n    \n    //vec2 grid_offset_11 = vec2(1.0, 0.0);\n    //float grid_id_11 = dot(grid, grid_offset_1", "\n    vec2 cell = floor(p);\n    // Get the position of the cell in the space.\n    vec2 cell_pos = cell * 0.5;\n    // Get the position of the cell in the space.\n    vec2 cell_pos_1 = cell * 0.5 + 0.5;\n    // Get the position of the cell in the space.\n    vec2 cell_pos_2 = cell * 0.5 + vec2(0.5, 0.0);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_3 = cell * 0.5 + vec2(0.0, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_4 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_5 = cell * 0.5 + vec2(0.25, 0.25);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_6 = cell * 0.5 + vec2(0.75, 0.25);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_7 = cell * 0.5 + vec2(0.25, 0.75);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_8 = cell * 0.5 + vec2(0.75, 0.75);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_9 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_10 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_11 = cell * 0.5 +", "\n  vec3 color = vec3(0.0,0.0,0.0);\n\n  // get the normal\n  vec3 normal = getNormal( rayHitInfo );\n\n  // get the position\n  vec3 position = getPosition( rayHitInfo );\n\n  // get the material\n  Material material = getMaterial( rayHitInfo );\n\n  // get the light\n  Light light = getLight();\n\n  // get the ambient\n  vec3 ambient = material.ambient;\n\n  // get the diffuse\n  vec3 diffuse = material.diffuse;\n\n  // get the specular\n  vec3 specular = material.specular;\n\n  // get the shininess\n  float shininess = material.shininess;\n\n  // get the light position\n  vec3 lightPosition = light.position;\n\n  // get the light color\n  vec3 lightColor = light.color;\n\n  // get the light attenuation\n  vec3 lightAttenuation = light.attenuation;\n\n  // get the light direction\n  vec3 lightDirection = normalize( lightPosition - position );\n\n  // get the view direction\n  vec3 viewDirection = normalize( eyePosition - position );\n\n  // get the halfway direction\n  vec3 halfwayDirection = normalize( lightDirection + viewDirection );\n\n  // get the diffuse factor\n  float diffuseFactor = max( dot( normal, lightDirection ), 0.0 );\n\n  // get the specular factor\n  float specularFactor = pow( max( dot( normal, halfwayDirection ), 0.0 ), shininess );\n\n  // get the attenuation factor\n  float attenuationFactor = 1.0 / ( lightAttenuation.x + lightAttenuation.y * length( lightPosition - position ) + lightAttenuation.z * length( lightPosition - position ) * length( lightPosition - position ) );\n\n  // get the color\n  color = ambient + attenuationFactor * ( diffuse * diffuseFactor + specular * specularFactor ) * lightColor;\n\n  // return the color\n", "\n    vec2 res = vec2(0.0);\n\n    // distance to the sphere\n    float d = length(p) - 1.0;\n\n    // distance to the plane\n    float d2 = p.y;\n\n    // distance to the box\n    float d3 = length(max(abs(p.xz) - vec2(0.5), 0.0));\n\n    // distance to the torus\n    float d4 = length(vec2(length(p.xz) - 0.5, p.y)) - 0.1;\n\n    // distance to the union\n    float d5 = min(d, min(d2, min(d3, d4)));\n\n    // distance to the intersection\n    float d6 = max(d, max(d2, max(d3, d4)));\n\n    // distance to the subtraction\n    float d7 = max(d, -d2);\n\n    // distance to the smooth union\n    float d8 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d9 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d10 = max(d, -d2);\n\n    // distance to the smooth union\n    float d11 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d12 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d13 = max(d, -d2);\n\n    // distance to the smooth union\n    float d14 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d15 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d16 = max(d, -d2);\n\n    // distance to the smooth union\n    float d17 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d18 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d19 = max(d, -d2);\n\n    // distance to the", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat eps = 0.001;\n\tfloat maxd = 100.0;\n\tfloat precis = 0.001;\n\t\n\t// marching loop\n\tfor(int i = 0; i < 100; i++)\n\t{\n\t\t// get the distance to the scene\n\t\td = map(ro + rd * t);\n\t\t\n\t\t// if the distance is smaller than the precision, we are done\n\t\tif(d < precis || t > maxd) break;\n\t\t\n\t\t// march along the ray\n\t\tt += d;\n\t}\n\t\n\t// if we are close enough to the surface, return the color\n\tif(d < precis)\n\t{\n\t\t// get the normal\n\t\tvec3 n = calcNormal(ro + rd * t);\n\t\t\n\t\t// get the color\n\t\tvec3 col = getColor(ro + rd * t, n);\n\t\t\n\t\t// return the color\n\t\treturn vec2(t, col);\n\t}\n\t\n\t// if we are not close enough to the surface, return the background color\n\treturn vec2(t, vec3(0.0));\n}\n\nvoid main()\n{\n\t// get the screen position\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\t// get the ray direction\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\t\n\t// get the ray origin\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\t\n\t// cast the ray\n\tvec2 res = castRay(ro, rd);\n\t\n\t// get the distance\n\tfloat t = res.x;\n\t\n\t// get the color\n\tvec3 col = res.y;\n\t\n\t// set the fragment color\n\tgl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec4 res = vec4(0.0);\n\n    // distance to the scene\n    float d = sdScene(p);\n\n    // if the distance is less than the threshold, we are inside the scene\n    if (d < EPSILON)\n    {\n        // get the normal\n        vec3 n = calcNormal(p);\n\n        // get the material\n        res = getMaterial(n);\n    }\n\n    return res;\n}\n\n// ray marching\nvec", "\n    float t = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    float m2 = 0.0;\n    float m3 = 0.0;\n    float m4 = 0.0;\n    float m5 = 0.0;\n    float m6 = 0.0;\n    float m7 = 0.0;\n    float m8 = 0.0;\n    float m9 = 0.0;\n    float m10 = 0.0;\n    float m11 = 0.0;\n    float m12 = 0.0;\n    float m13 = 0.0;\n    float m14 = 0.0;\n    float m15 = 0.0;\n    float m16 = 0.0;\n    float m17 = 0.0;\n    float m18 = 0.0;\n    float m19 = 0.0;\n    float m20 = 0.0;\n    float m21 = 0.0;\n    float m22 = 0.0;\n    float m23 = 0.0;\n    float m24 = 0.0;\n    float m25 = 0.0;\n    float m26 = 0.0;\n    float m27 = 0.0;\n    float m28 = 0.0;\n    float m29 = 0.0;\n    float m30 = 0.0;\n    float m31 = 0.0;\n    float m32 = 0.0;\n    float m33 = 0.0;\n    float m34 = 0.0;\n    float m35 = 0.0;\n    float m36 = 0.0;\n    float m37 = 0.0;\n    float m38 = 0.0;\n    float m39 = 0.0;\n    float m40 = 0.0;\n    float m41 = 0.0;\n    float m42 = 0.0;\n    float m43 = 0.0;\n    float m44 = 0.0;\n    float m45 = 0.0;\n    float m46 = 0.", "\n    vec3 wp = p * u_worldMatrix;\n    vec3 wpDiff = wp - u_worldPosition;\n    // normal diff\n    vec3 nDiff = oN - u_worldNormal;\n    // normal diff in world space\n    vec3 wnDiff = normalize(mat3(u_worldMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vnDiff = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff2 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff2 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff3 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff3 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff4 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff4 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff5 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff5 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff6 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff6 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff7 = normalize(mat3(u_view", "\n    float x = p.x * 12.9898 + p.y * 78.233 + p.z * 45.5432;\n    float y = p.x * 37.4545 + p.y * 23.3745 + p.z * 89.234;\n    float z = p.x * 19.3745 + p.y * 99.4567 + p.z * 14.987;\n    \n    // Get the fractional part of the numbers\n    float s = mod(x, 1.0);\n    float t = mod(y, 1.0);\n    float u = mod(z, 1.0);\n    \n    // Get the integer part of the numbers\n    int i = int(floor(x));\n    int j = int(floor(y));\n    int k = int(floor(z));\n    \n    // Get the vectors\n    vec3 v1 = vec3(i, j, k);\n    vec3 v2 = vec3(i + 1, j, k);\n    vec3 v3 = vec3(i, j + 1, k);\n    vec3 v4 = vec3(i + 1, j + 1, k);\n    vec3 v5 = vec3(i, j, k + 1);\n    vec3 v6 = vec3(i + 1, j, k + 1);\n    vec3 v7 = vec3(i, j + 1, k + 1);\n    vec3 v8 = vec3(i + 1, j + 1, k + 1);\n    \n    // Get the dot products\n    float d1 = dot(v1, p);\n    float d2 = dot(v2, p);\n    float d3 = dot(v3, p);\n    float d4 = dot(v4, p);\n    float d5 = dot(v5, p);\n    float d6 = dot(v6, p);\n    float d7 = dot(v7, p);\n    float d8 = dot", "\n\t//pR(rayDir.xz, sin(-t * 1.));\n\t//pR(rayDir.xy, sin(-t * 1.));\n\n\tvec3 color = vec3(0.);\n\tfloat weight = 1.;\n\tfloat weightSum = 0.;\n\tfloat weightSum2 = 0.;\n\tfloat weightSum3 = 0.;\n\tfloat weightSum4 = 0.;\n\tfloat weightSum5 = 0.;\n\tfloat weightSum6 = 0.;\n\tfloat weightSum7 = 0.;\n\tfloat weightSum8 = 0.;\n\tfloat weightSum9 = 0.;\n\tfloat weightSum10 = 0.;\n\tfloat weightSum11 = 0.;\n\tfloat weightSum12 = 0.;\n\tfloat weightSum13 = 0.;\n\tfloat weightSum14 = 0.;\n\tfloat weightSum15 = 0.;\n\tfloat weightSum16 = 0.;\n\tfloat weightSum17 = 0.;\n\tfloat weightSum18 = 0.;\n\tfloat weightSum19 = 0.;\n\tfloat weightSum20 = 0.;\n\tfloat weightSum21 = 0.;\n\tfloat weightSum22 = 0.;\n\tfloat weightSum23 = 0.;\n\tfloat weightSum24 = 0.;\n\tfloat weightSum25 = 0.;\n\tfloat weightSum26 = 0.;\n\tfloat weightSum27 = 0.;\n\tfloat weightSum28 = 0.;\n\tfloat weightSum29 = 0.;\n\tfloat weightSum30 = 0.;\n\tfloat weightSum31 = 0.;\n\tfloat weightSum32 = 0.;\n\tfloat weightSum33 = 0.;\n\tfloat weightSum34 = 0.;\n\tfloat weightSum35 = 0.;\n\tfloat weightSum36 = 0.;\n\tfloat weightSum37 = 0.;\n\tfloat weightSum38 = 0.;\n\tfloat weightSum39 = 0.;\n\tfloat weightSum40 = 0.;\n\tfloat weightSum41 = 0.;\n\tfloat weightSum42 = 0.;\n\tfloat weightSum43 = 0.;\n\tfloat weightSum44 = 0.;\n\tfloat weightSum45 = 0.;\n\tfloat weightSum46 = 0.;\n\tfloat weight", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    vec2 AB_normal = vec2(-AB.y, AB.x);\n    vec2 AC_normal = vec2(-AC.y, AC.x);\n\n    // calculate distance from line segment\n    float distance = dot(AC, AB_normal) / length(AB);\n\n    // calculate distance from line segment\n    float distance_normal = dot(AC_normal, AB_normal) / length(AB);\n\n    // calculate distance from line segment\n    float distance_normal_abs = abs(distance_normal);\n\n    // calculate distance from line segment\n    float distance_abs = abs(distance);\n\n    // calculate distance from line segment\n    float distance_abs_normal = abs(distance_normal);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs = abs(distance_normal_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs = abs(distance_abs_normal_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs = abs(distance_abs_normal_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal", "\n     float dot = dot(start, end);\n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot);\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\nvoid main()\n{\n    vec2 start = vec2(0.0, 0.0);\n    vec2 end = vec2(1.0, 1.0);\n    vec2 result = slerp(start, end, 0.5);\n    gl_FragColor = vec4(result, 0.0, 1.0);\n}\n", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    vec3 camCenter = camPos + camDir;\n    vec3 rayDir = normalize(camCenter + uv.x * camRight + uv.y * camUp);\n\n    // set up our scene\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n    vec3 diffuseColor = vec3(0.5, 0.5, 0.5);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float specularPower = 10.0;\n\n    // set up our raymarching\n    float maxDist = 100.0;\n    float minDist = 0.001;\n    float dist = maxDist;\n    vec3 pos = camPos;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    // raymarching loop\n    for (int i = 0; i < 100; i++) {\n        dist = sceneSDF(pos);\n        if (dist < minDist) {\n            break;\n        }\n        pos +=", "\n    //\n    //e = a + e * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a", " and forth\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = t * t * t * (t * (6.0 * t - 15.0) + 10.0);\n    return mix(vec3(0.0), vec3(0.0, 0.0, 0.05), t);\n}\n\nvec", "\n    // The ball-roller is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.", "^2\n\t// => t^2*dir.x^2 + 2*t*dir.x*org.x + org.x^2 + t^2*dir.y^2 + 2*t*dir.y*org.y + org.y^2 = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.5^2 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x", "\n    vec3 q = p - s.xyz;\n    float k = s.w;\n    float h = length(q) - k;\n    float d = max(h, dot(q, r));\n    return d;\n}\n\nfloat", "\n    float x = p.x * 12.9898 + p.y * 78.233 + p.z * 45.5432;\n    float y = p.x * 37.4545 + p.y * 23.3745 + p.z * 89.234;\n    float z = p.x * 19.3745 + p.y * 99.4567 + p.z * 14.987;\n    \n    // Get the fractional part of the numbers\n    float s = mod(x, 1.0);\n    float t = mod(y, 1.0);\n    float u = mod(z, 1.0);\n    \n    // Get the integer part of the numbers\n    int i = int(floor(x));\n    int j = int(floor(y));\n    int k = int(floor(z));\n    \n    // Get the vectors\n    vec3 v1 = vec3(i, j, k);\n    vec3 v2 = vec3(i + 1, j, k);\n    vec3 v3 = vec3(i, j + 1, k);\n    vec3 v4 = vec3(i + 1, j + 1, k);\n    vec3 v5 = vec3(i, j, k + 1);\n    vec3 v6 = vec3(i + 1, j, k + 1);\n    vec3 v7 = vec3(i, j + 1, k + 1);\n    vec3 v8 = vec3(i + 1, j + 1, k + 1);\n    \n    // Get the dot products\n    float d1 = dot(v1, p);\n    float d2 = dot(v2, p);\n    float d3 = dot(v3, p);\n    float d4 = dot(v4, p);\n    float d5 = dot(v5, p);\n    float d6 = dot(v6, p);\n    float d7 = dot(v7, p);\n    float d8 = dot", "\n    float d = length(p) - 0.5;\n    \n    // The shape is a circle.\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    // Draw the shape.\n    float d = drawShape(uv - 0.5);\n    \n    // The shape is a circle.\n    col = vec3(d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // df - Change in \"f\" in in the X-direction.\n    // dg - Change in \"f\" in in the Y-direction.\n    // dh - Change in \"f\" in in the Z-direction.\n    //\n    // dfx - Change in \"df\" in in the X-direction.\n    // dfy - Change in \"df\" in in the Y-direction.\n    // dfz - Change in \"df\" in in the Z-direction.\n    //\n    // dgx - Change in \"dg\" in in the X-direction.\n    // dgy - Change in \"dg\" in in the Y-direction.\n    // dgz - Change in \"dg\" in in the Z-direction.\n    //\n    // dhx - Change in \"dh\" in in the X-direction.\n    // dhy - Change in \"dh\" in in the Y-direction.\n    // dhz - Change in \"dh\" in in the Z-direction.\n    //\n    // dfxdx - Change in \"dfx\" in in the X-direction.\n    // dfxdy - Change in \"dfx\" in in the Y-direction.\n    // dfxdz - Change in \"dfx\" in in the Z-direction.\n    //\n    // dfydx - Change in \"dfy\" in in the X-direction.\n    // dfydy - Change in \"dfy\" in in the Y-direction.\n    // dfydz - Change in \"dfy\" in in the Z-direction.\n    //\n    // dfzdx - Change in \"dfz\" in in the X-direction.\n    // dfzdy - Change in \"dfz\" in in the Y-direction.\n    // dfzdz - Change in \"dfz\" in in the Z-direction.\n    //\n    // dgxdx - Change in \"dgx\" in in the X-direction.\n    // dgxdy - Change in \"dgx\" in in the Y-direction.\n    // dgxdz - Change in \"dgx\" in in the Z-direction.\n    //\n    //", "\n    //vec2 n = vec2(0.0);\n    //n.x = p.x + p.y * 157.0;\n    //n.y = p.y + p.x * 157.0;\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract", "\n  vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 h = normalize(l + normalize(vec3(0.0, 0.0, 1.0)));\n  float ndotl = max(dot(n, l), 0.0);\n  float ndoth = max(dot(n, h), 0.0);\n  float spec = pow(ndoth, 10.0);\n  vec3 color = vec3(0.5, 0.5, 0.5) * ndotl + vec3(1.0, 1.0, 1.0) * spec;\n\n  // ambient light\n  color += vec3(0.1, 0.1, 0.1);\n\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.xy / resolution.xy, 0.0);\n  vec3 n = normal(p);\n  vec3 color = shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    Ray ray = createRay(fragCoord);\n    //creates a color object\n    vec3 color = vec3(0.0);\n    //creates a distance object\n    float distance = INFINITY;\n    //creates a hit object\n    Hit hit;\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //creates a plane object\n    Plane plane = Plane(vec3(0.0, 1.0, 0.0), 0.0);\n    //creates a triangle object\n    Triangle triangle = Triangle(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    //creates a box object\n    Box box = Box(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    //creates a cylinder object\n    Cylinder cylinder = Cylinder(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a cone object\n    Cone cone = Cone(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a torus object\n    Torus torus = Torus(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a torus knot object\n    TorusKnot torusKnot = TorusKnot(vec3(0.0, 0.0, 0.0), 1.0, 1.0, 1.0);\n    //creates a torus knot object\n    TrefoilKnot trefoilKnot = TrefoilKnot(vec3(0.0, 0.0, 0.0), 1.0", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.0055;\n    float kd = 0.7;\n    float ks = 0.3;\n    float sh = 16.0;\n\n    // raymarch\n    float t = march(ro, rd);\n\n    // if march failed, return background color\n    if (t > MAX_DIST) return vec3(0.0);\n\n    // get the surface normal\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // get the material color\n    vec3 col = vec3(0.8, 0.9, 1.0);\n\n    // ambient\n    vec3 amb = ka * col;\n\n    // diffuse\n    vec3 lig = normalize(vec3(1.0, 1.0, 1.0));\n    float dif = kd * max(dot(nor, lig), 0.0);\n    vec3 difCol = dif * col;\n\n    // specular\n    vec3 ref = reflect(rd, nor);\n    float spe = ks * pow(max(dot(ref, lig), 0.0), sh);\n    vec3 speCol = spe * vec3(1.0, 1.0, 1.0);\n\n    // combine\n    vec3 lin = amb + difCol + speCol;\n\n    // fog\n    float fogAmount = exp(-0.0005 * t * t);\n    vec3 fogCol = vec3(0.5, 0.6, 0.7);\n    vec3 col2 = mix(fogCol, lin, fogAmount);\n\n    // return\n    return vec3(col2);\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3", "\n    return length(p) - rad;\n}\n\nfloat", "\n    float d = p.y;\n    float e = length(p.xz) - param.x;\n    float f = length(p.xz - vec2(param.y, 0.0)) - param.z;\n    float g = length(p.xz - vec2(param.y, param.z)) - param.x;\n    float h = length(p.xz - vec2(0.0, param.z)) - param.x;\n    d = max(d, -e);\n    d = max(d, -f);\n    d = max(d, -g);\n    d = max(d, -h);\n    return d;\n}\n\nfloat", "\n    float d = p.y;\n    float d2 = length(p.xz) - param.x;\n    float d3 = length(p.xz) - param.y;\n    float d4 = length(p.xz) - param.z;\n    float d5 = length(p.xz) - param.w;\n    float d6 = length(p.xz) - param.y;\n    float d7 = length(p.xz) - param.z;\n    float d8 = length(p.xz) - param.w;\n    float d9 = length(p.xz) - param.z;\n    float d10 = length(p.xz) - param.w;\n    float d11 = length(p.xz) - param.w;\n    float d12 = length(p.xz) - param.w;\n    float d13 = length(p.xz) - param.w;\n    float d14 = length(p.xz) - param.w;\n    float d15 = length(p.xz) - param.w;\n    float d16 = length(p.xz) - param.w;\n    float d17 = length(p.xz) - param.w;\n    float d18 = length(p.xz) - param.w;\n    float d19 = length(p.xz) - param.w;\n    float d20 = length(p.xz) - param.w;\n    float d21 = length(p.xz) - param.w;\n    float d22 = length(p.xz) - param.w;\n    float d23 = length(p.xz) - param.w;\n    float d24 = length(p.xz) - param.w;\n    float d25 = length(p.xz) - param.w;\n    float d26 = length(p.xz) - param.w;\n    float d27 = length(p.xz) - param.w;\n    float d28 = length(p.xz) - param.", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.005;\n    float ks = 0.005;\n    float kr = 0.005;\n    float kt = 0.005;\n    float kf = 0.005;\n    float ka2 = 0.005;\n    float kd2 = 0.005;\n    float ks2 = 0.005;\n    float kr2 = 0.005;\n    float kt2 = 0.005;\n    float kf2 = 0.005;\n    float ka3 = 0.005;\n    float kd3 = 0.005;\n    float ks3 = 0.005;\n    float kr3 = 0.005;\n    float kt3 = 0.005;\n    float kf3 = 0.005;\n    float ka4 = 0.005;\n    float kd4 = 0.005;\n    float ks4 = 0.005;\n    float kr4 = 0.005;\n    float kt4 = 0.005;\n    float kf4 = 0.005;\n    float ka5 = 0.005;\n    float kd5 = 0.005;\n    float ks5 = 0.005;\n    float kr5 = 0.005;\n    float kt5 = 0.005;\n    float kf5 = 0.005;\n    float ka6 = 0.005;\n    float kd6 = 0.005;\n    float ks6 = 0.005;\n    float kr6 = 0.005;\n    float kt6 = 0.005;\n    float kf6 = 0.005;\n    float ka7 = 0.005;\n    float kd7 = 0.005;\n    float ks7 = 0.005;\n    float kr7 = 0.00", "\n    p = mat2(0.70710678118654757, -0.70710678118654757, 0.70710678118654757, 0.70710678118654757) * p;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    //", "\n    // so that the background is not transformed.\n    vec3 background = vec3(0.0);\n    background += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    background += sin(uv.x * 10.0) * 0.05;\n    background += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern.\n    vec3 pattern = vec3(0.0);\n    pattern += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern += sin(uv.x * 10.0) * 0.05;\n    pattern += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern2 = vec3(0.0);\n    pattern2 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern2 += sin(uv.x * 10.0) * 0.05;\n    pattern2 += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern3 = vec3(0.0);\n    pattern3 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern3 += sin(uv.x * 10.0) * 0.05;\n    pattern3 += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern4 = vec3(0.0);\n    pattern4 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.0", "\n\tfloat d = sdSphere( pos, 1.0 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, -2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 2.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, -2.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 2.0, 0.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( -2.0, 0.0, 0.0 ), 1.0 ), 0.5 );\n\treturn d;\n}\n\nvec", "\n\tvec3 light = vec3( 0.0 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, ", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.", "\n    // 0.0    0.0   |    0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float aa = a * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaa = aa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaa = aaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaa = aaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaa = aaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaa = aaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaa = aaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaa = aaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaa = aaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaa = aaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaa = aaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaa = aaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaa = aaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaa = aaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaaa * 1.0;\n    //Increase", "\n    float d = length(p.xz) - r;\n    // How far inside or outside the cylinder the point is, along the height\n    float t = abs(p.y) - h;\n    // Return the smallest distance to the cylinder\n    return min(max(d, t), 0.0) + length(max(vec2(d, t), 0.0));\n}\n\nfloat", "\n    float t = iTime * 0.5;\n    mat3 rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(s, u, -f);\n}\n\nmat", "\n    float n = snoise(p);\n    n = n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*", "\n    //but the color is based on the distance to the nearest point\n    //in the set.\n    //The distance is calculated using the distance function\n    //and the color is calculated using the color function.\n    //The color function is a simple linear interpolation between\n    //two colors.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //", "\n    // The \"w\" parameter is the \"width\" of the pattern.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n", "\n    float r = length(p.xz);\n    float h = p.y;\n    \n    // The bump function.\n    float bump = sin(r*10.0)*sin(h*10.0);\n    \n    // The bump function is multiplied by a smoothstep function.\n    // This is a function that smoothly goes from 0 to 1 as the\n    // distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    //", "\n    //\n    // view_inv: inverse of the view matrix\n    // proj_inv: inverse of the projection matrix\n    // viewp_inv: inverse of the view-projection matrix\n    // scr_pt: screen coordinates of a point\n    //\n    // Returns: vec4(world_pt, 0)\n\n    vec4 scr_pt_hom = vec4(scr_pt, 0.0, 1.0);\n    vec4 viewp_pt = viewp_inv * scr_pt_hom;\n    viewp_pt /= viewp_pt.w;\n    vec4 world_pt = view_inv * viewp_pt;\n    return world_pt;\n}\n\nvec", "\n    rounded = min(rounded, 1.0);\n\n    // Get the distance to the line.\n    float dist = LineDist(uv, pA, pB);\n\n    // Get the distance to the rounded end caps.\n    float capDist = min(LineDist(uv, pA, pB), LineDist(uv, pB, pA));\n    capDist = min(capDist, LineDist(uv, pA, pB));\n\n    // Get the distance to the dash.\n    float dashDist = LineDist(uv, pA, pB);\n    dashDist = min(dashDist, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist2 = LineDist(uv, pA, pB);\n    dashDist2 = min(dashDist2, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist3 = LineDist(uv, pA, pB);\n    dashDist3 = min(dashDist3, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist4 = LineDist(uv, pA, pB);\n    dashDist4 = min(dashDist4, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist5 = LineDist(uv, pA, pB);\n    dashDist5 = min(dashDist5, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist6 = LineDist(uv, pA, pB);\n    dashDist6 = min(dashDist6, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist7 = LineDist(uv, pA, pB);\n    dashDist7 = min(dashDist7, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist8 = LineDist(uv, pA, pB);\n    dashDist8 = min(dashDist8, LineDist(uv,", "\n  vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 h = normalize(l + vec3(0.0, 0.0, 1.0));\n  float ndotl = max(dot(n, l), 0.0);\n  float ndoth = max(dot(n, h), 0.0);\n  float spec = pow(ndoth, 10.0);\n  vec3 color = vec3(0.5, 0.5, 0.5) * ndotl + vec3(1.0, 1.0, 1.0) * spec;\n\n  // ambient light\n  color += vec3(0.1, 0.1, 0.1);\n\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.xy / resolution.xy, 0.0);\n  vec3 n = normalize(vec3(0.0, 0.0, 1.0));\n  vec3 color = Shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs( m ) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0 ) return vec2( -1.0 );\n\treturn vec2( tN, tF );\n}\n\n// ray-sphere intersection\nfloat", "          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          _", "\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\nvec", "\n    vec3 pa2 = pa - ro;\n    vec3 pb2 = pb - ro;\n    vec3 ba = pb2 - pa2;\n    vec3 oa = ro - pa2;\n    vec3 ob = ro - pb2;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float bard2 = bard*bard;\n    float baoa2 = baoa*baoa;\n    float rard2 = ra*ra*bard2;\n    float rard22 = rard2*rard2;\n    float rard222 = rard22*rard22;\n    float rard222_baba = rard222/baba;\n    float rard222_baba_bard = rard222_baba*bard;\n    float rard222_baba_bard2 = rard222_baba*bard2;\n    float rard222_baba_bard2_baoa = rard222_baba_bard2*baoa;\n    float rard222_baba_bard2_baoa2 = rard222_baba_bard2*baoa2;\n    float rard222_baba_bard2_baoa2_baba = rard222_baba_bard2_baoa2/baba;\n    float rard222_baba_bard2_baoa2_baba_bard = rard222_baba_bard2_baoa2_baba*bard;\n    float rard222_baba_bard2_baoa2_baba_bard2 = rard222_baba_bard2_baoa2_baba*bard2;\n    float rard222_baba_bard2_baoa2_baba_bard2_baoa = rard222_baba_", "\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-1.,d));\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s) { // O, U, pos, radius, color, smoothness\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-s,d));\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s, float a) { // O, U, pos, radius, color, smoothness, alpha\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-s,d)*a);\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s, float a, float t) { // O, U, pos, radius, color, smoothness, alpha, time\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U", "\n    p.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05", "\n    float scale = (1.0 - layerID) * 0.5;\n    float scale2 = scale * scale;\n    float scale4 = scale2 * scale2;\n    float scale8 = scale4 * scale4;\n    float scale16 = scale8 * scale8;\n    float scale32 = scale16 * scale16;\n    float scale64 = scale32 * scale32;\n    float scale128 = scale64 * scale64;\n    float scale256 = scale128 * scale128;\n    float scale512 = scale256 * scale256;\n    float scale1024 = scale512 * scale512;\n    float scale2048 = scale1024 * scale1024;\n    float scale4096 = scale2048 * scale2048;\n    float scale8192 = scale4096 * scale4096;\n    float scale16384 = scale8192 * scale8192;\n    float scale32768 = scale16384 * scale16384;\n    float scale65536 = scale32768 * scale32768;\n    float scale131072 = scale65536 * scale65536;\n    float scale262144 = scale131072 * scale131072;\n    float scale524288 = scale262144 * scale262144;\n    float scale1048576 = scale524288 * scale524288;\n    float scale2097152 = scale1048576 * scale1048576;\n    float scale4194304 = scale2097152 * scale2097152;\n    float scale8388608 = scale4194304 * scale4194304;\n    float scale16777216 = scale8", "\n    p = p*1.15;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p", "\n\n    // \u043f\u043e\u0432\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u043f\u043e \u043e\u0441\u0438 X\n    currentRayPosition.yz = rotate(currentRayPosition.yz, iTime);\n\n    // \u043f\u043e\u0432\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u043f\u043e \u043e\u0441\u0438 Z\n    currentRayPosition.xy = rotate(currentRayPosition.xy, iTime);\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.", "\n    float flameDistance = abs(currentRayPosition.y);\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint2 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint3 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint4 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint5 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint6 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint7 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint8 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint9 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n   ", "\n    float sf = 1.0;\n    \n    // Smoothing factor.\n    float s = sf * sm;\n    \n    // Return the fractal value.\n    return fract(x * s);\n}\n\nfloat", "\n    //\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, ", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n\n    // Determining the first vertice.\n    float n = dot(i, vec3(0.0, 0.0, 1.0));\n    float a = dot(i, vec3(0.0, 1.0, 0.0));\n    float b = dot(i, vec3(1.0, 0.0, 0.0));\n    float c = dot(i, vec3(1.0, 1.0, 1.0));\n\n    // Determining the second vertice.\n    float k0 = n;\n    float k1 = a - n;\n    float k2 = b - n;\n    float k3 = c - n;\n    float k4 = a + b - k1 - k2;\n    float k5 = a + c - k1 - k3;\n    float k6 = b + c - k2 - k3;\n    float k7 = a + b + c - k0 - k1 - k2 - k3;\n\n    // Determining the noise value.\n    float n0 = k0;\n    float n1 = k1 + f.x;\n    float n2 = k2 + f.y;\n    float n3 = k3 + f.z;\n    float n4 = k4 + f.x + f.y;\n    float n5 = k5 + f.x + f.z;\n    float n6 = k6 + f.y + f.z;\n    float n7 = k7 + f.x + f.y + f.z;\n\n    // Determining the final noise value.\n    float n8 = n0;\n    n8 = mix(n8, n1, f.x);\n    n8 = mix(n8, n2, f.y);\n    n8 = mix(n8, n3, f.z);\n    n8 = mix(n8, n4, f", "\n    float n = snoise(p);\n    \n    // The color.\n    vec3 c = vec3(n);\n    \n    // The final color.\n    return vec4(c, 1.0);\n}\n\nvoid main(){\n    // The pixel coordinates.\n    vec2 p = gl_FragCoord.xy / u_resolution.xy;\n    \n    // The final color.\n    vec4 c = func(p);\n    \n    // Output the final color.\n    gl_FragColor = c;\n}", " and radius\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  float balloonRadius = 1.0;\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs( m ) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n\t// return the intersection t value\n\tif( tN > tF || tF < 0.0 ) return vec4( -1.0 );\n\n\treturn vec4( tN, tF, tN / ( tN - tF ), tF / ( tN - tF ) );\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    vec3 s = vec3(1.0, 1.0, 1.0) - 1.5 * abs(p);\n    vec3 t = s * s * s;\n    vec3 f = s * t;\n    \n    // Calculating the gradients at the vertices.\n    vec3 g0 = vec3(0.0, 0.0, 0.0);\n    vec3 g1 = vec3(0.0, 0.0, 0.0);\n    vec3 g2 = vec3(0.0, 0.0, 0.0);\n    vec3 g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g", "\n vec2 pa=p-a, ba=b-a;\n float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n return c*(1.-h)+c*h*2.;\n}\n\nvoid main(void)\n{\n\tvec2 p = (gl_FragCoord.xy * 2.0 - RENDERSIZE.xy) / min(RENDERSIZE.x, RENDERSIZE.y);\n\tvec3 c = vec3(0);\n\t\n\tvec2 a = vec2(0.5,0.5);\n\tvec2 b = vec2(0.5,0.5);\n\t\n\tfloat t = TIME;\n\t\n\ta.x = sin(t) * 0.5 + 0.5;\n\ta.y = cos(t) * 0.5 + 0.5;\n\t\n\tb.x = sin(t + 1.0) * 0.5 + 0.5;\n\tb.y = cos(t + 1.0) * 0.5 + 0.5;\n\t\n\tc = lineAOc(p,a,b,c);\n\t\n\tgl_FragColor = vec4(c,1.0);\n}", "\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 1.0;\n}\n\nvoid main(){\n    vec2 c = vec2(gl_FragCoord.x/1000.0, gl_FragCoord.y/1000.0);\n    vec2 z = vec2(0.0, 0.0);\n    float m = mandelbrot(c, z);\n    gl_FragColor = vec4(m, m, m, 1.0);\n}", "\n    vec3 z = normalize(focusPoint - cam);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    return mat4(\n        x.x, x.y, x.z, 0.0,\n        y.x, y.y, y.z, 0.0,\n        z.x, z.y, z.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ) * translate(-cam);\n}\n\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(){\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n    float t = u_time * 0.5;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float d = abs(a - t);\n    float f = cos(d * 10.0);\n    float g = sin(d * 10.0);\n    float b = sin(d * 10.0);\n    float c = cos(d * 10.0);\n    float e = sin(d * 10.0);\n    float h = cos(d * 10.0);\n    float i = sin(d * 10.0);\n    float j = cos(d * 10.0);\n    float k = sin(d * 10.0);\n    float l = cos(d * 10.0);\n    float m = sin(d * 10.0);\n    float n = cos(d * 10.0);\n    float o = sin(d * 10.0);\n    float p = cos(d * 10.0);\n    float q = sin(d * 10.0);\n    float r = cos(d * 10.0);\n    float s = sin(d * 10.0);\n    float t = cos(d * 10.0);\n    float u = sin(d * 10.0);\n    float v = cos(d *", "\n    p = mod(p, 2.0);\n    p = abs(p - 1.0);\n    \n    // Get the distance to the closest edge.\n    float d = min(p.x, p.y);\n    \n    // Get the distance to the closest corner.\n    d = min(d, length(p));\n    \n    // Get the distance to the closest edge in the direction of the pattern.\n    d = min(d, abs(p.x - w) + abs(p.y - w));\n    \n    // Get the distance to the closest corner in the direction of the pattern.\n    d = min(d, length(p - vec2(w, w)));\n    \n    // Return the distance to the closest edge in the direction of the pattern.\n    return d;\n}\n\nfloat", "\n    return (x - a) / (b - a);\n}\n\nfloat", "\n    float dist = distance(xy, vec2(0.0, 0.0));\n    float dist2 = distance(xy, vec2(0.0, 0.0));\n    float dist3 = distance(xy, vec2(0.0, 0.0));\n    float dist4 = distance(xy, vec2(0.0, 0.0));\n    float dist5 = distance(xy, vec2(0.0, 0.0));\n    float dist6 = distance(xy, vec2(0.0, 0.0));\n    float dist7 = distance(xy, vec2(0.0, 0.0));\n    float dist8 = distance(xy, vec2(0.0, 0.0));\n    float dist9 = distance(xy, vec2(0.0, 0.0));\n    float dist10 = distance(xy, vec2(0.0, 0.0));\n    float dist11 = distance(xy, vec2(0.0, 0.0));\n    float dist12 = distance(xy, vec2(0.0, 0.0));\n    float dist13 = distance(xy, vec2(0.0, 0.0));\n    float dist14 = distance(xy, vec2(0.0, 0.0));\n    float dist15 = distance(xy, vec2(0.0, 0.0));\n    float dist16 = distance(xy, vec2(0.0, 0.0));\n    float dist17 = distance(xy, vec2(0.0, 0.0));\n    float dist18 = distance(xy, vec2(0.0, 0.0));\n    float dist19 = distance(xy, vec2(0.0, 0.0));\n    float dist20 = distance(xy, vec2(0.0, 0.0));\n    float dist21 = distance(xy, vec2(0.0, 0.0));\n    float dist22 = distance(xy, vec2(0.0", "\n vec2 o1 = vec2(0.0,1.0);\n vec2 o2 = vec2(1.0,0.0);\n vec2 o3 = vec2(0.0,-1.0);\n vec2 o4 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o5 = vec2(0.0,1.0);\n vec2 o6 = vec2(1.0,0.0);\n vec2 o7 = vec2(0.0,-1.0);\n vec2 o8 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o9 = vec2(0.0,1.0);\n vec2 o10 = vec2(1.0,0.0);\n vec2 o11 = vec2(0.0,-1.0);\n vec2 o12 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o13 = vec2(0.0,1.0);\n vec2 o14 = vec2(1.0,0.0);\n vec2 o15 = vec2(0.0,-1.0);\n vec2 o16 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o17 = vec2(0.0,1.0);\n vec2 o18 = vec2(1.0,0.0);\n vec2 o19 = vec2(0.0,-1.0);\n vec2 o20 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o21 = vec2(0.0,1.0);\n vec2 o22 = vec2(1.0,0.0);\n vec2 o23 = vec2(0.0,-", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.z*5.);\n return f;\n}\n\nfloat", ", but it works\n    float r = c.r;\n    float g = c.g;\n    float b = c.b;\n    float max = max(r, max(g, b));\n    float min = min(r, min(g, b));\n    float delta = max - min;\n    float hue = 0.0;\n    if(delta > 0.0){\n        if(max == r){\n            hue = (g - b) / delta;\n        }else if(max == g){\n            hue = 2.0 + (b - r) / delta;\n        }else{\n            hue = 4.0 + (r - g) / delta;\n        }\n        hue *= 60.0;\n        if(hue < 0.0){\n            hue += 360.0;\n        }\n    }\n    float sat = (max > 0.0)? (delta / max) : 0.0;\n    return vec3(hue, sat, max);\n}\n\nvec", "\n  vec3 d=abs(p)-s;\n  return vec4(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),1.0,1.0,1.0);\n}\n\nvec", "\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5", "\n    float dist = distScene(pos);\n    int matrIndex = int(mod(dist, 7.0));\n    Material mat = materials[matrIndex];\n    return mat;\n}\n\nvec", "\n    const vec3 a = vec3(2.51f, 0.03f, 2.43f);\n    const vec3 b = vec3(0.34f, 0.94f, 0.14f);\n    const vec3 c = vec3(-1.65f, 2.50f, 0.15f);\n    const vec3 d = vec3(1.67f, -0.39f, 0.52f);\n    const vec3 e = vec3(-0.60f, 0.04f, 0.15f);\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec", "\n    p.x -= 1.0;\n    \n    // The scene is a sphere.\n    // The sphere is centered at the origin.\n    // The radius is 1.0.\n    // The distance to the sphere is the distance to the surface.\n    float d = length(p) - 1.0;\n    \n    // The color of the sphere is red.\n    // The color is a vec3, with each component being a float between 0.0 and 1.0.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n", "\n    float d = length(p) - 1.0;\n    float r = 0.1;\n    float s = smoothstep(r, r - 0.01, d);\n    return mat(s, vec3(1.0));\n}\n\nmat", "\n    mat2 m = mat2 ( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000 * noise ( p ); p = m * p * 2.02;\n    f += 0.2500 * noise ( p ); p = m * p * 2.03;\n    f += 0.1250 * noise ( p ); p = m * p * 2.01;\n    f += 0.0625 * noise ( p );\n    return f / 0.9375;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    float t = iTime * 0.5;\n    vec2 q = p + vec2 ( cos ( t ), sin ( t ) );\n    float f = fbm ( q * 0.5 );\n    vec3 col = vec3 ( f );\n    fragColor = vec4 ( col, 1.0 );\n}", "\n    \n    // The first point is the cell point, which is wrapped to the cell.\n    vec2 cell = floor(p);\n    vec2 cellPoint = cell + vec2(0.5);\n    \n    // The second point is the cell point rotated 90 degrees.\n    vec2 cellPointRotated = cellPoint.yx;\n    \n    // The third point is the cell point rotated 180 degrees.\n    vec2 cellPointRotated180 = cellPoint.yx * vec2(-1.0, 1.0);\n    \n    // The fourth point is the cell point rotated 270 degrees.\n    vec2 cellPointRotated270 = cellPoint.yx * vec2(1.0, -1.0);\n    \n    // The fifth point is the cell point rotated 360 degrees.\n    vec2 cellPointRotated360 = cellPoint.yx * vec2(-1.0, -1.0);\n    \n    // The sixth point is the cell point rotated 45 degrees.\n    vec2 cellPointRotated45 = cellPoint.yx * vec2(1.0, 1.0);\n    \n    // The seventh point is the cell point rotated 135 degrees.\n    vec2 cellPointRotated135 = cellPoint.yx * vec2(-1.0, 1.0);\n    \n    // The eighth point is the cell point rotated 225 degrees.\n    vec2 cellPointRotated225 = cellPoint.yx * vec2(1.0, -1.0);\n    \n    // The ninth point is the cell point rotated 315 degrees.\n    vec2 cellPointRotated315 = cellPoint.yx * vec2(-1.0, -1.0);\n    \n    // The tenth point is the cell point rotated 45 degrees.\n    vec2 cellPointRotated45 = cellPoint.yx * vec2(1.0, 1.0);\n    \n    // The eleventh point is the cell", "\n return u.x*m.y-u.y*m.x;\n}\n\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),dot(m,u)>0.);//branchless\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m = vec2(0.5,0.5);\n    float d = ils(uv,m);\n    fragColor = vec4(d,d,d,1.0);\n}", "\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n\tfloat a = acos(dot(A, B));\n\tfloat b = acos(dot(B, C));\n\tfloat c = acos(dot(C, A));\n\n\t//calculate area of spherical triangle\n\tfloat area = a + b + c;\n\n\t//calculate probability of each triangle edge\n\tfloat pA = a / area;\n\tfloat pB = b / area;\n\tfloat pC = c / area;\n\n\t//calculate probability of each triangle edge\n\tfloat p1 = pA / (pA + pB + pC);\n\tfloat p2 = pB / (pA + pB + pC);\n\tfloat p3 = pC / (pA + pB + pC);\n\n\t//calculate probability of each triangle edge\n\tfloat p12 = p1 + p2;\n\tfloat p23 = p2 + p3;\n\tfloat p31 = p3 + p1;\n\n\t//calculate probability of each triangle edge\n\tfloat p123 = p12 + p3;\n\tfloat p231 = p23 + p1;\n\tfloat p312 = p31 + p2;\n\n\t//calculate probability of each triangle edge\n\tfloat p1231 = p123 + p1;\n\tfloat p2312 = p231 + p2;\n\tfloat p3123 = p312 + p3;\n\n\t//calculate probability of each triangle edge\n\tfloat p12312 = p1231 + p2;\n\tfloat p23123 = p2312 + p3;\n\tfloat p31231 = p3123 + p1;\n\n\t//calculate probability of each triangle edge\n\tfloat p123123 = p12312 + p3;\n\tfloat p231231 = p23123 + p1;\n\tfloat p312312 = p31231 + p2;\n\n\t//calculate probability of each triangle edge\n\tfloat p1231231 = p123123 + p1;\n\tfloat p2", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n    \n    // The tube is a circle with a radius of 0.5.\n    // The tube is centered at the origin.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n", "\n    float r = 0.1;\n\n    // Torus parameters.\n    float R = 0.5;\n    float r1 = 0.2;\n\n    // Torus equation.\n    float d = length(vec2(length(p.xz) - R, p.y)) - r1;\n\n    // Torus normal.\n    vec3 n = normalize(vec3(p.x, p.y, p.z));\n\n    return vec4(d, n);\n}\n\n// Torus with a hole.\nvec", "\n    vec3 id = floor(p);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos = mod(p, 1.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos2 = mod(p, 2.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos3 = mod(p, 3.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos4 = mod(p, 4.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos5 = mod(p, 5.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos6 = mod(p, 6.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos7 = mod(p, 7.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos8 = mod(p, 8.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos9 = mod(p, 9.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos10 = mod(p, 10.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos11 = mod(p, 11.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos12 = mod(p, 12.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos13 = mod(p, 13.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos14 = mod(p, 14.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos15 = mod(p, 15.0);\n    \n    // Get the position of the", "\n    float t = 0., d;\n    \n    // Loop through the ray marching steps.\n    for(int i = 0; i < 100; i++){\n        \n        // Get the distance to the scene.\n        d = map(o + r * t);\n        \n        // If the distance is less than the minimum distance, return the current ray distance.\n        if(d < 0.001){\n            return t;\n        }\n        \n        // Increment the ray distance.\n        t += d;\n    }\n    \n    // Return the maximum ray distance.\n    return 100.;\n}\n\nvec", "\n    float s = 0.0;\n    float tt = 0.0;\n    for(int i = 0; i < 10; i++){\n        tt += t;\n        s += exp(-k*tt);\n    }\n    return s;\n}\n\nfloat", "\n    float eps =.0001 * (1.0 / t);\n    \n    // The derivative of the function is the gradient of the function.\n    // The gradient is the direction of the steepest ascent.\n    // The normal is the direction of the steepest descent.\n    // The normal is the negative of the gradient.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    //", "\n    vec3 w = vec3(dot(p3, m[0]), dot(p3, m[1]), dot(p3, m[2]));\n    // normalize weights\n    w = normalize(w);\n    // scale weights by triangle area\n    w *= t.x;\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\nvoid main() {\n    // get the current pixel\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    // get the current pixel's position in world space\n    vec3 p = texture(u_position, uv).xyz;\n    // get the current pixel's normal in world space\n    vec3 n = texture(u_normal, uv).xyz;\n    // get the current pixel's color\n    vec3 c = texture(u_color, uv).xyz;\n\n    // get the current pixel's position in view space\n    vec4 p_view = u_view * vec4(p, 1.0);\n    // get the current pixel's normal in view space\n    vec4 n_view = u_view * vec4(n, 0.0);\n\n    // get the current pixel's position in clip space\n    vec4 p_clip = u_projection * p_view;\n    // get the current pixel's normal in clip space\n    vec4 n_clip = u_projection * n_view;\n\n    // get the current pixel's position in ndc space\n    vec4 p_ndc = p_clip / p_clip.w;\n    // get the current pixel's normal in ndc space\n    vec4 n_ndc = n_clip / n_clip.w;\n\n    // get the current pixel's position in screen space\n    vec4 p_screen = p_ndc * 0.5 + 0.5;\n    // get the current pixel's normal in screen space\n    vec4 n_screen = n_ndc * 0.5 + 0", "\n    vec4 hexCenters = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(", "\n    vec2 uv = vec2(df_truchet(p, dir), atan(p.y, p.x) / 3.1415926535897932384626433832795);\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is", "\n    q.x += sin(q.y * 0.01 + iTime * 0.01) * 0.01;\n    q.y += cos(q.x * 0.01 + iTime * 0.01) * 0.01;\n    \n    // Polar conversion\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    \n    // The actual animation. You perform that after polar conversion.\n    a += r * 0.01;\n    \n    // Convert back to cartesian\n    q.x = r * cos(a);\n    q.y = r * sin(a);\n    \n    // Return the distance to the center\n    return length(q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    q.x *= iResolution.x / iResolution.y;\n    \n    float d = getPolarCoord(q, 0.0);\n    \n    fragColor = vec4(d, d, d, 1.0);\n}", "\n    vec3 w = vec3(dot(p3, n[0]), dot(p3, n[1]), dot(p3, n[2]));\n    // normalize weights\n    w = normalize(w);\n    // scale weights by distance to triangle plane\n    w *= dot(t, w);\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\nvec", ".\n  if (abs(r.w) < 0.000001 && abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.00", "\n    // The first tile is a square with a diagonal line.\n    // The second tile is a square with a diagonal line.\n    // The third tile is a square with a diagonal line.\n    // The fourth tile is a square with a diagonal line.\n    // The fifth tile is a square with a diagonal line.\n    // The sixth tile is a square with a diagonal line.\n    // The seventh tile is a square with a diagonal line.\n    // The eighth tile is a square with a diagonal line.\n    // The ninth tile is a square with a diagonal line.\n    // The tenth tile is a square with a diagonal line.\n    // The eleventh tile is a square with a diagonal line.\n    // The twelfth tile is a square with a diagonal line.\n    // The thirteenth tile is a square with a diagonal line.\n    // The fourteenth tile is a square with a diagonal line.\n    // The fifteenth tile is a square with a diagonal line.\n    // The sixteenth tile is a square with a diagonal line.\n    // The seventeenth tile is a square with a diagonal line.\n    // The eighteenth tile is a square with a diagonal line.\n    // The nineteenth tile is a square with a diagonal line.\n    // The twentieth tile is a square with a diagonal line.\n    // The twenty-first tile is a square with a diagonal line.\n    // The twenty-second tile is a square with a diagonal line.\n    // The twenty-third tile is a square with a diagonal line.\n    // The twenty-fourth tile is a square with a diagonal line.\n    // The twenty-fifth tile is a square with a diagonal line.\n    // The twenty-sixth tile is a square with a diagonal line.\n    // The twenty-seventh tile is a square with a diagonal line.\n    // The twenty-eighth tile is a square with a diagonal line.\n    // The twenty-ninth tile is a square with a diagonal line.\n    // The thirty-first tile is a square with a diagonal line.\n    // The thirty-second tile is a square with a diagonal line.\n    // The thirty-third tile is a square with a diagonal line.\n    // The thirty-fourth tile is a square with a diagonal", "\n\tvec2 w = max(abs(ddx), abs(ddy));\n\t// analytical integral (box filter)\n\tvec2 i = 2.0*(p*p + (w*w)/12.0);\n\t// fractional part\n\treturn i.x + i.y - 0.5*w.x*w.y;\n}\n\nfloat", "\n    vec2 h = n + f;\n\n    // find the closest point\n    float d = dot( f, f );\n    float e = dot( n, n );\n    float g = dot( h, h );\n\n    // find the closest point\n    if( d < e ) {\n        if( e < g ) {\n            mr = n;\n            mg = f;\n            return d;\n        }\n        else {\n            mr = h;\n            mg = f;\n            return e;\n        }\n    }\n    else {\n        if( d < g ) {\n            mr = f;\n            mg = h;\n            return d;\n        }\n        else {\n            mr = h;\n            mg = n;\n            return e;\n        }\n    }\n}\n\nfloat", "\n    vec2 p0 = vec2(0.0,0.0);\n    vec2 p1 = vec2(1.0,0.0);\n    vec2 p2 = vec2(1.0,1.0);\n    vec2 p3 = vec2(0.0,1.0);\n\n    vec2 p01 = mix(p0,p1,t);\n    vec2 p12 = mix(p1,p2,t);\n    vec2 p23 = mix(p2,p3,t);\n    vec2 p30 = mix(p3,p0,t);\n\n    vec2 p012 = mix(p01,p12,t);\n    vec2 p123 = mix(p12,p23,t);\n    vec2 p230 = mix(p23,p30,t);\n\n    vec2 p0123 = mix(p012,p123,t);\n    vec2 p1230 = mix(p123,p230,t);\n\n    return mix(p0123,p1230,t);\n}\n\nvec", "\n    // -Patricio 2015, 2016\n    //\n    // Also, it passes the second test in:\n    //   http://www.jcgt.org/published/0009/03/01/\n    //\n    // Thanks to I\u00f1igo Quiles for the tidbit that helped me figure out how to do this.\n    // Thanks to Fabrice Neyret for cleaning up the offsets and the derivative equations.\n    //\n    // If you're interested, you can check out my other hash functions at:\n    //   http://www.iquilezles.org/www/articles/hashing/hashing.htm\n\n    // const highp vec2 OFFSET = vec2(26.0, 161.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(161.0, 269.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(113.0, 311.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(269.0, 193.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(193.0, 269.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(113.0, 193.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const", "\n    // Visit http://www.nevads.com/ for more details.\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float A = acos((b*b + c*c - a*a) / (2.0*b*c));\n    float B = acos((a*a + c*c - b*b) / (2.0*a*c));\n    float C = acos((a*a + b*b - c*c) / (2.0*a*b));\n    \n    // Centroid.\n    vec2 cent = (p0*sin(A) + p1*sin(B) + p2*sin(C)) / sin(A + B + C);\n    \n    return cent;\n}\n\nvoid main() {\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    \n    vec2 cent = inCent(p0, p1, p2);\n    \n    gl_FragColor = vec4(cent, 0.0, 1.0);\n}\n", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n\n    // Angle A.\n    float A = acos((b*b + c*c - a*a) / (2.0*b*c));\n\n    // Angle B.\n    float B = acos((a*a + c*c - b*b) / (2.0*a*c));\n\n    // Angle C.\n    float C = acos((a*a + b*b - c*c) / (2.0*a*b));\n\n    // Radius.\n    float r = a*b*c / (4.0*sin(A)*sin(B)*sin(C));\n\n    // Area.\n    float S = a*b*sin(C)/2.0;\n\n    // Circumference.\n    float C1 = a + b + c;\n\n    // Circumference in radians.\n    float C2 = C1*r;\n\n    // Area in radians.\n    float S2 = S*r*r;\n\n    return S2/C2;\n}\n\nvoid main() {\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n\n    float r = inCentRad(p0, p1, p2);\n\n    gl_FragColor = vec4(vec3(r), 1.0);\n}\n", "\n   vec3 p1 = vec3(h1, 1.0);\n   vec3 p2 = vec3(h2, 1.0);\n   vec3 p3 = vec3(h3, 1.0);\n\n   // Computes normal of the triangle.\n   vec3 n = normalize(cross(p2 - p1, p3 - p1));\n\n   // Computes distance from the origin to the plane.\n   float d = dot(n, p1);\n\n   // Computes distance from the origin to the plane.\n   return d;\n}\n\nfloat", "\n    vec2 v0 = vec2(0.0, 0.0);\n    vec2 v1 = vec2(1.0, 0.0);\n    vec2 v2 = vec2(0.0, 1.0);\n    \n    // The number of iterations is the number of triangles we're going to generate.\n    // The number of triangles is 2^(n-2)\n    int n = int(log2(float(NUM_ITERATIONS)));\n    \n    // The number of vertices is 3^n\n    int numVertices = 3;\n    for(int i = 0; i < n; i++){\n        numVertices *= 3;\n    }\n    \n    // The number of triangles is 2^(n-2)\n    int numTriangles = numVertices / 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //set background color\n    vec3 col = vec3(0.0);\n\n    //draw a circle\n    float d = length(uv - vec2(0.5, 0.5));\n    if (d < 0.25) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n    //output to screen\n    fragColor = vec4(col, 1.0);\n}", "\n    //vec2 n = vec2(0.0);\n    //n.x = p.x + p.y * 157.0;\n    //n.y = p.y + p.x * 157.0;\n    //return fract(sin(n) * 159.543);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(127.1, 311.7)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is another good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(0.0, 127.1)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(127.1, 311.7)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(0.0, 127.1)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * ", "\n    /////////////////////////////////\n    //\n    // Compute the intersection of the given ray with the given sphere.\n    //\n    // If the ray intersects the sphere, return true and set t to the\n    // distance along the ray at which the intersection occurs.\n    //\n    // If the ray does not intersect the sphere, return false.\n    //\n    // If the ray intersects the sphere, set hitPos to the position of the\n    // intersection point and set hitNormal to the normal at the intersection\n    // point.\n    //\n    // Note: The sphere is defined by its center and radius.\n    //\n    // Note: The ray is defined by its origin and direction.\n    //\n    // Note: The intersection point is defined by the ray's origin plus the\n    // distance along the ray times the ray's direction.\n    //\n    // Note: The normal at the intersection point is defined by the vector\n    // from the intersection point to the sphere's center.\n    //\n    // Note: The ray's direction is normalized.\n    //\n    // Note: The ray's origin is not necessarily inside the sphere.\n    //\n    // Note: The ray's origin is not necessarily outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily on the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is", "\n    /////////////////////////////////\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    //\n    // The ray is defined by a point and a direction.\n    // The sphere is defined by a center and a radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //", "\n    float tmin = 1000000.0;\n    hasHit = false;\n    for( int i = 0; i < NUM_OBJECTS; i++ ) \n    {\n        float t = objects[i].Intersect( ray );\n        if( t > 0.0 ) \n        {\n            hasHit = true;\n            if( t < tmin ) \n            {\n                tmin = t;\n                hitPos = ray.origin + ray.direction * t;\n                hitNormal = objects[i].GetNormal( hitPos );\n                k_rg = objects[i].k_rg;\n            }\n        }\n    }\n    return k_rg;\n}\n\nvec", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p012 = p12 - p01;\n    vec2 p0121 = p12 - p01;\n    vec2 p0122 = p12 - p01;\n    vec2 p0123 = p12 - p01;\n    vec2 p0124 = p12 - p01;\n    vec2 p0125 = p12 - p01;\n    vec2 p0126 = p12 - p01;\n    vec2 p0127 = p12 - p01;\n    vec2 p0128 = p12 - p01;\n    vec2 p0129 = p12 - p01;\n    vec2 p01210 = p12 - p01;\n    vec2 p01211 = p12 - p01;\n    vec2 p01212 = p12 - p01;\n    vec2 p01213 = p12 - p01;\n    vec2 p01214 = p12 - p01;\n    vec2 p01215 = p12 - p01;\n    vec2 p01216 = p12 - p01;\n    vec2 p01217 = p12 - p01;\n    vec2 p01218 = p12 - p01;\n    vec2 p01219 = p12 - p01;\n    vec2 p01220 = p12 - p01;\n    vec2 p01221 = p12 - p01;\n    vec2 p01222 = p12 - p01;\n    vec2 p01223 = p12 - p01;\n    vec2 p01224 = p", "\n    vec3 p01 = p1 - p0;\n    vec3 p12 = p2 - p1;\n    vec3 p23 = p3 - p2;\n    vec3 p30 = p0 - p3;\n\n    // normals\n    vec3 n01 = normalize( p01 );\n    vec3 n12 = normalize( p12 );\n    vec3 n23 = normalize( p23 );\n    vec3 n30 = normalize( p30 );\n\n    // tangents\n    vec3 t01 = normalize( p01 - n01 * dot( p01, n01 ) );\n    vec3 t12 = normalize( p12 - n12 * dot( p12, n12 ) );\n    vec3 t23 = normalize( p23 - n23 * dot( p23, n23 ) );\n    vec3 t30 = normalize( p30 - n30 * dot( p30, n30 ) );\n\n    // binormals\n    vec3 b01 = normalize( cross( n01, t01 ) );\n    vec3 b12 = normalize( cross( n12, t12 ) );\n    vec3 b23 = normalize( cross( n23, t23 ) );\n    vec3 b30 = normalize( cross( n30, t30 ) );\n\n    // compute AABB\n    vec3 min = p0;\n    vec3 max = p0;\n\n    for( int i = 0; i < 3; i++ )\n    {\n        float d0 = dot( p0, b01 );\n        float d1 = dot( p1, b01 );\n        float d2 = dot( p2, b01 );\n        float d3 = dot( p3, b01 );\n\n        min[i] = min( min[i], min( min( d0, d1 ), min( d2, d3 ) ) );\n        max[i] = max( max[", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TWO_PI = 6.283185307179586476925286766559;\n    const float HALF_PI = 1.5707963267948966192313216916398;\n    const float INV_PI = 0.31830988618379067153776752674503;\n    const float INV_TWO_PI = 0.15915494309189533576888376337251;\n    const float INV_HALF_PI = 0.63661977236758134307553505349006;\n    const float SQRT_TWO = 1.4142135623730950488016887242097;\n    const float SQRT_THREE = 1.7320508075688772935274463415059;\n    const float SQRT_TWO_PI = 2.506628274631000502415765284811;\n    const float SQRT_HALF_PI = 1.2533141373155002512078826424055;\n    const float SQRT_INV_TWO_PI = 0.7978845608028653558798921198687;\n    const float SQRT_INV_TWO", "\n    return 0.5 - cos( k * PI ) / 2.0; // EaseInOut\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n\n    float p = sin( t * 0.5 ) * 0.5 + 0.5;\n    float p2 = sin( t * 0.25 ) * 0.5 + 0.5;\n    float p3 = sin( t * 0.125 ) * 0.5 + 0.5;\n\n    float k = uv.x;\n    float k2 = uv.y;\n    float k3 = uv.x + uv.y;\n\n    float e = easing( k );\n    float e2 = easing( k2 );\n    float e3 = easing( k3 );\n\n    col.r = e;\n    col.g = e2;\n    col.b = e3;\n\n    col.r *= p;\n    col.g *= p2;\n    col.b *= p3;\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (4", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tvec3 col = vec3(0.0);\n\t\n\tcol.r = uv.x;\n\tcol.g = uv.y;\n\tcol.b = 0.5 + 0.5*sin(iTime);\n\t\n\tfragColor = vec4(col,1.0);\n}", "\n    coord = (coord - res / 2.0) / res.y;\n\n    // Scale the coordinate to the size of the screen.\n    coord *= res.y;\n\n    return coord;\n}\n\nvoid main()\n{\n    // Get the resolution of the screen.\n    vec2 res = vec2(textureSize(u_texture, 0));\n\n    // Get the coordinate of the current pixel.\n    vec2 coord = space(res, gl_FragCoord.xy);\n\n    // Get the color of the current pixel.\n    vec4 color = texture(u_texture, gl_FragCoord.xy / res);\n\n    // Get the color of the pixel to the left.\n    vec4 left = texture(u_texture, (gl_FragCoord.xy + vec2(-1.0, 0.0)) / res);\n\n    // Get the color of the pixel to the right.\n    vec4 right = texture(u_texture, (gl_FragCoord.xy + vec2(1.0, 0.0)) / res);\n\n    // Get the color of the pixel above.\n    vec4 up = texture(u_texture, (gl_FragCoord.xy + vec2(0.0, 1.0)) / res);\n\n    // Get the color of the pixel below.\n    vec4 down = texture(u_texture, (gl_FragCoord.xy + vec2(0.0, -1.0)) / res);\n\n    // Get the color of the pixel above and to the left.\n    vec4 up_left = texture(u_texture, (gl_FragCoord.xy + vec2(-1.0, 1.0)) / res);\n\n    // Get the color of the pixel above and to the right.\n    vec4 up_right = texture(u_texture, (gl_FragCoord.xy + vec2(1.0, 1.0)) / res);\n\n    // Get the color of the pixel below and to the left.\n    vec4 down_", "\n    const vec3 k = vec3(0.001, 0.005, 0.01);\n\n    // derivatives\n    vec2 dx = vec2(dFdx(p.x), dFdx(p.y));\n    vec2 dy = vec2(dFdy(p.x), dFdy(p.y));\n\n    // gradient\n    vec2 g = vec2(dx.x + dy.x, dx.y + dy.y);\n\n    // normalize\n    float l = length(g);\n    if (l > 0.0)\n        g /= l;\n\n    // filter kernel\n    float f = exp(-k.x*l*l) - exp(-k.y*l*l);\n\n    // compute box filter average value and subtract it\n    float avg = exp(-k.z*l*l);\n    return f - avg;\n}\n\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec", "\n    // p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    // Slower, but more evenly disperses things.\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(\n        map(p+h.xyy) - map(p-h.xyy),\n        map(p+h.yxy) - map(p-h.yxy),\n        map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n// Raymarching\nfloat", "\n    return fract( sin( dot( q.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat", "\n    // width = 0 -> angle = 0\n    float angle = width * 2.0 * PI;\n    float r = radius * 0.5;\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r4 * r4;\n    float r10 = r8 * r2;\n    float r12 = r8 * r4;\n    float r14 = r12 * r2;\n    float r16 = r12 * r4;\n    float r18 = r16 * r2;\n    float r20 = r16 * r4;\n    float r22 = r20 * r2;\n    float r24 = r20 * r4;\n    float r26 = r24 * r2;\n    float r28 = r24 * r4;\n    float r30 = r28 * r2;\n    float r32 = r28 * r4;\n    float r34 = r32 * r2;\n    float r36 = r32 * r4;\n    float r38 = r36 * r2;\n    float r40 = r36 * r4;\n    float r42 = r40 * r2;\n    float r44 = r40 * r4;\n    float r46 = r44 * r2;\n    float r48 = r44 * r4;\n    float r50 = r48 * r2;\n    float r52 = r48 * r4;\n    float r54 = r52 * r2;\n    float r56 = r52 * r4;\n    float r58 = r56 * r2;\n    float r60 = r56 * r4;\n    float r62 = r60 * r2;\n    float r64 = r60 * r4;\n    float r66 = r64 * r2;\n    float r68 = r64 * r4;\n    float r70 = r68", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (4", "\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\t\n\t// get the distance to the center\n\tfloat d = length(uv);\n\t\n\t// get the angle\n\tfloat a = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d2 = length(uv);\n\t\n\t// get the angle\n\tfloat a2 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d3 = length(uv);\n\t\n\t// get the angle\n\tfloat a3 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d4 = length(uv);\n\t\n\t// get the angle\n\tfloat a4 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d5 = length(uv);\n\t\n\t// get the angle\n\tfloat a5 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d6 = length(uv);\n\t\n\t// get the angle\n\tfloat a6 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d7 = length(uv);\n\t\n\t// get the angle\n\tfloat a7 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d8 = length(uv);\n\t\n\t// get the angle\n\tfloat a8 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d9 = length(uv);\n\t\n\t// get the angle\n\tfloat a9 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d10 = length(uv);\n\t\n\t// get the angle\n\tfloat a10 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d11 = length(uv);\n\t\n\t// get the angle\n\t", "\n    vec3 s = vec3(10, 10, 10);\n\n    // Integer part, scaled and offset so that value is always positive.\n    vec3 a = floor(mod(p, s)) * (1.0 / s);\n\n    // Fractional part for interpolation\n    vec3 f = fract(p);\n\n    // Sine interpolation\n    float n = sin(dot(a, vec3(7, 157, 113)));\n\n    // Linear interpolation\n    return mix(mix(mix(hash31(n + dot(a, vec3(0, 0, 1))), hash31(n + dot(a, vec3(1, 0, 1))), f.x),\n                   mix(hash31(n + dot(a, vec3(0, 1, 1))), hash31(n + dot(a, vec3(1, 1, 1))), f.x), f.y),\n               mix(mix(hash31(n + dot(a, vec3(0, 0, 0))), hash31(n + dot(a, vec3(1, 0, 0))), f.x),\n                   mix(hash31(n + dot(a, vec3(0, 1, 0))), hash31(n + dot(a, vec3(1, 1, 0))), f.x), f.y), f.z);\n}\n\nfloat", "\n\tsp = p;\n\tsp.x = atan(sp.x, sp.z);\n\tsp.y = asin(sp.y);\n\tsp.x = sp.x * 0.5 * M_PI;\n\tsp.y = sp.y * 0.5 * M_PI;\n\n\t// Apply the inverse log-spherical map\n\ttp = sp;\n\ttp.x = cos(tp.x) * sin(tp.y);\n\ttp.y = sin(tp.x) * sin(tp.y);\n\ttp.z = cos(tp.y);\n\n\t// Apply the inverse log-spherical map\n\trp = tp;\n\trp.x = atan(rp.x, rp.z);\n\trp.y = asin(rp.y);\n\trp.x = rp.x * 0.5 * M_PI;\n\trp.y = rp.y * 0.5 * M_PI;\n\n\t// Apply the forward log-spherical map\n\tsp = rp;\n\tsp.x = cos(sp.x) * sin(sp.y);\n\tsp.y = sin(sp.x) * sin(sp.y);\n\tsp.z = cos(sp.y);\n\n\t// Apply the inverse log-spherical map\n\ttp = sp;\n\ttp.x = atan(tp.x, tp.z);\n\ttp.y = asin(tp.y);\n\ttp.x = tp.x * 0.5 * M_PI;\n\ttp.y = tp.y * 0.5 * M_PI;\n\n\t// Apply the forward log-spherical map\n\tsp = tp;\n\tsp.x = cos(sp.x) * sin(sp.y);\n\tsp.y = sin(sp.x) * sin(sp.y);\n\tsp.z = cos(sp.y);\n\n\t// Apply the inverse log-spherical map\n\trp = sp;\n\trp.x = atan(rp.x, rp.z);\n\trp.y = asin(rp.y);\n\trp.x = rp.x", "\n    float y = sin(u_Time * 0.5) * 0.5 + 0.5;\n    float r = cos(u_Time * 0.5) * 0.5 + 0.5;\n    vec3 s = vec3(0.0, y, 0.0);\n    float d = length(p - s) - r;\n    \n    //distance to plane\n    float d2 = p.y;\n    \n    //return the minimum distance\n    return vec2(min(d, d2), 0.0);\n}\n\n//raymarching function\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tvec2 p1 = p;\n\tvec2 p2 = p;\n\tvec2 p3 = p;\n\tvec2 p4 = p;\n\tvec2 p5 = p;\n\tvec2 p6 = p;\n\tvec2 p7 = p;\n\tvec2 p8 = p;\n\tvec2 p9 = p;\n\tvec2 p10 = p;\n\tvec2 p11 = p;\n\tvec2 p12 = p;\n\tvec2 p13 = p;\n\tvec2 p14 = p;\n\tvec2 p15 = p;\n\tvec2 p16 = p;\n\tvec2 p17 = p;\n\tvec2 p18 = p;\n\tvec2 p19 = p;\n\tvec2 p20 = p;\n\tvec2 p21 = p;\n\tvec2 p22 = p;\n\tvec2 p23 = p;\n\tvec2 p24 = p;\n\tvec2 p25 = p;\n\tvec2 p26 = p;\n\tvec2 p27 = p;\n\tvec2 p28 = p;\n\tvec2 p29 = p;\n\tvec2 p30 = p;\n\tvec2 p31 = p;\n\tvec2 p32 = p;\n\tvec2 p33 = p;\n\tvec2 p34 = p;\n\tvec2 p35 = p;\n\tvec2 p36 = p;\n\tvec2 p37 = p;\n\tvec2 p38 = p;\n\tvec2 p39 = p;\n\tvec2 p40 = p;\n\tvec2 p41 = p;\n\tvec2 p42 = p;\n\tvec2 p43 = p;\n\tvec2 p44 = p;\n\tvec2 p45 = p;\n\tvec2 p46 = p;\n\tvec2 p47 = p;\n\tvec2 p48 = p;\n\tvec2 p49 = p;\n\tvec2 p50 = p;\n\tvec2 p51 = p;\n\tvec2 p52 = p;\n", "\n    mat3 rot = getRotationMatrix(box.rotation);\n\n    // get the position of the box in the world\n    vec3 boxPos = box.position;\n\n    // get the position of the vertex in the box's local space\n    vec3 localPos = pos - boxPos;\n\n    // rotate the vertex into the box's local space\n    localPos = rot * localPos;\n\n    // get the position of the vertex in the world space\n    pos = localPos + boxPos;\n\n    // get the distance from the vertex to the box's center\n    float dist = length(pos - boxPos);\n\n    // get the distance from the vertex to the box's edge\n    float edge = length(pos - boxPos) - box.size;\n\n    // return the distance from the vertex to the box's edge\n    return vec2(edge, dist);\n}\n\n// get the distance from the vertex to the box's edge\nfloat", "\n    pos.y = sin(pos.x * 0.5 + iTime * 0.5) * 0.5 + 0.5;\n\n    // return the distance to the sphere\n    return vec2(length(pos) - 0.5, 1.0);\n}\n\n// the distance function for the scene\nvec", "\n    vec2 res = vec2(1000000.0, -1.0);\n    res = min(res, sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(2.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(4.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(6.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(8.0, 0.0, 0.0), vec3(1.0)));\n    return res;\n}\n\n// calculate the normal for a given point\nvec", "\n    vec3 rayDir = normalize(camDir + (fragCoord.x * u_camRight) + (fragCoord.y * u_camUp));\n    \n    // march the ray\n    vec3 marchPos = camPos;\n    float marchDist = 0.0;\n    float marchStep = 0.0;\n    float marchDistMax = 100.0;\n    float marchDistMin = 0.001;\n    float marchDistTotal = 0.0;\n    float marchDistPrev = 0.0;\n    float marchDistCurr = 0.0;\n    float marchDistNext = 0.0;\n    float marchDistDelta = 0.0;\n    float marchDistDeltaPrev = 0.0;\n    float marchDistDeltaCurr = 0.0;\n    float marchDistDeltaNext = 0.0;\n    float marchDistDeltaTotal = 0.0;\n    float marchDistDeltaTotalPrev = 0.0;\n    float marchDistDeltaTotalCurr = 0.0;\n    float marchDistDeltaTotalNext = 0.0;\n    float marchDistDeltaTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalTotal = 0.", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\nfloat", "\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\t// time varying pixel color\n\tvec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n\t\n\t// output to screen\n\tfragColor = vec4(col,1.0);\n}", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\nvec", " cell\n    vec3 i = floor(fx);\n    // grid cell corners\n    vec3 f = fract(fx);\n    // 3D grid cell corners\n    vec3 p = vec3(i.x + i.y*57.0 + 113.0*i.z,\n                  i.x + 113.0*i.y + 57.0*i.z,\n                  i.x + 57.0*i.y + 113.0*i.z);\n    // hash values at the corners\n    vec4 h = vec4(0.0, i.x + 113.0, i.x + 57.0, i.x) +\n             i.y + vec4(57.0, 57.0 + 113.0, 113.0, 113.0 + 1.0);\n    h = fract(sin(h) * 43758.5453);\n    // smooth interpolation weights\n    vec4 u = f * f * (3.0 - 2.0 * f);\n    // mix 4 coorners por grid cell\n    return mix(mix(mix(h.x, h.y, u.x), mix(h.z, h.w, u.x), u.y),\n               mix(mix(h.x, h.y, u.z), mix(h.z, h.w, u.z), u.y), u.w);\n}\n\nfloat", "\n    // and integer octaves\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function", "\n    p.x += sin(p.y*0.1)*0.05;\n    p.z += cos(p.y*0.1)*0.05;\n\n    // Capsule body\n    vec2 d = abs(vec2(length(p.xz)-2.0*r,p.y))-vec2(0.0,h);\n\n    // Capsule endcaps\n    float dc = length(max(vec2(d.x,d.y),0.0)) + min(max(d.x,d.y), 0.0);\n\n    // Capsule head\n    float dh = length(p.xz) - r;\n\n    return min(min(dc,dh),0.0) + length(max(vec2(dh,dc), 0.0));\n}\n\nfloat", "\n     p.xz += vec2(sin(iTime*0.5),cos(iTime*0.5))*0.5;\n     p.y += sin(iTime*0.5)*0.5;\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p", "\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  return normalize(vec3(\n    map(p + eps.xyy) - map(p - eps.xyy),\n    map(p + eps.yxy) - map(p - eps.yxy),\n    map(p + eps.yyx) - map(p - eps.yyx)\n  ));\n}\n\nfloat", "\n    return max(dot(n,l),0.0);\n}\n\nfloat", "\n    float a = dot(rd,rd);\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - ra*ra;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float t1 = (-b-d)/a;\n    float t2 = (-b+d)/a;\n    if( t1>t2 ) {\n        float tmp = t1;\n        t1 = t2;\n        t2 = tmp;\n    }\n    if( t1<0.0 ) {\n        t1 = t2;\n        if( t1<0.0 ) return -1.0;\n    }\n    return t1;\n}\n\nfloat", "\n    vec2 w = fwidth(p) * 2.0;\n    // analytical integral (box filter)\n    vec2 a = abs(mod(p,w)-0.5*w) - 0.5*w;\n    // conservative integral (box filter)\n    vec2 b = max(sign(a),0.0);\n    // fraction inside box\n    float f = clamp( dot(b,dpdx) / dot(b,w), 0.0, 1.0 );\n    // conservative integral (triangle filter)\n    b = max(sign(a+vec2(0.5*w.x,0.0)),0.0);\n    // fraction inside triangle\n    f *= clamp( dot(b,dpdy) / dot(b,w), 0.0, 1.0 );\n    return f;\n}\n\nfloat", "\n    Sphere[0].Center.X = 0.0;\n    Sphere[0].Center.Y = 0.0;\n    Sphere[0].Center.Z = 0.0;\n    Sphere[0].Radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].Center.X = -1.0;\n    Sphere[1].Center.Y = 0.0;\n    Sphere[1].Center.Z = 0.0;\n    Sphere[1].Radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].Center.X = 1.0;\n    Sphere[2].Center.Y = 0.0;\n    Sphere[2].Center.Z = 0.0;\n    Sphere[2].Radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].Center.X = 0.0;\n    Sphere[3].Center.Y = 1.0;\n    Sphere[3].Center.Z = 0.0;\n    Sphere[3].Radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].Center.X = 0.0;\n    Sphere[4].Center.Y = -1.0;\n    Sphere[4].Center.Z = 0.0;\n    Sphere[4].Radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].Center.X = 0.0;\n    Sphere[5].Center.Y = 0.0;\n    Sphere[5].Center.Z = -1.0;\n    Sphere[5].Radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].Center.X = 0.0;\n    Sphere[6].Center.Y = 0.", "\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    // If the ray intersects the sphere, then t should be set to the distance along the ray\n    // that the intersection occurs.\n    //\n    // If the ray intersects the sphere, then hitPos should be set to the position of the\n    // intersection point, and hitNormal should be set to the normal at the intersection point.\n    //\n    // If the ray does not intersect the sphere, then t should be set to -1.\n    //\n    // If the ray does not intersect the sphere, then hitPos and hitNormal should be set\n    // to any value.\n    //\n    // Hint: Remember that the equation of a sphere is given by (x-cx)^2 + (y-cy)^2 + (z-cz)^2 = r^2,\n    // where (x,y,z) are a point on the sphere, (cx,cy,cz) is the center of the sphere, and r is the\n    // radius of the sphere.\n    //\n    // Hint: Remember that the equation of a ray is given by P = O + t*D, where O is the origin of the ray,\n    // D is the direction of the ray, and t is a scalar.\n    //\n    // Hint: Remember that the dot product of two vectors is given by dot(u,v) = u.x*v.x + u.y*v.y + u.z*v.z.\n    //\n    // Hint: Remember that the cross product of two vectors is given by cross(u,v) = (u.y*v.z - u.z*v.y, u.z*v.x - u.x*v.z, u.x*v.y - u.y*v.x).\n    //\n    // Hint: Remember that the length of a vector is given by length(u) = sqrt(u.x^2 + u.y^2 + u.z^2).\n    //\n    // Hint: Remember that the normalize function returns a vector with the same direction as the input vector,\n    // but with a length of 1.\n    //\n   ", "\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    //\n    // The ray is defined by a point and a direction.\n    // The sphere is defined by a center and a radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n", "\n    float tmin = 1000000.0;\n    hasHit = false;\n    for (int i = 0; i < num_objects; i++) \n    {\n        float t = objects[i].Intersect(ray);\n        if (t > 0.0) \n        {\n            hasHit = true;\n            if (t < tmin) \n            {\n                tmin = t;\n                hitPos = ray.origin + ray.direction * t;\n                hitNormal = objects[i].GetNormal(hitPos);\n                k_rg = objects[i].k_rg;\n            }\n        }\n    }\n    return k_rg;\n}\n\nvec", "\n    float tp = (0.0 - ro.y) / rd.y;\n    if( tp > 0.0 ) mint = max( mint, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec", "\n    vec3 camera_pos = start + dir * planet_radius;\n\n    // calculate the distance from the camera to the planet\n    float dist_to_planet = distance(camera_pos, planet_position);\n\n    // if the distance to the planet is less than the radius of the planet, then the camera is inside the planet\n    if (dist_to_planet < planet_radius) {\n        return scene_color;\n    }\n\n    // calculate the distance from the camera to the atmosphere\n    float dist_to_atmo = dist_to_planet - planet_radius;\n\n    // if the distance to the atmosphere is less than the radius of the atmosphere, then the camera is inside the atmosphere\n    if (dist_to_atmo < atmo_radius) {\n        return scene_color;\n    }\n\n    // calculate the distance from the camera to the atmosphere\n    float dist_to_atmo_end = dist_to_atmo - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end = dist_to_atmo_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end = dist_to_atmo_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end = dist_to_atmo_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end_end = dist_to_atmo_end_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end_end_end = dist_to_atmo_end_end_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo", "\n    vec3 bent_normal = normalize(mix(surface_normal, light_dir, 0.1));\n\n    // calculate the skylight color\n    vec3 skylight_col = background_col * pow(max(dot(bent_normal, light_dir), 0.0), 1.0);\n\n    // calculate the skylight attenuation\n    float attenuation = max(dot(bent_normal, light_dir), 0.0);\n\n    // return the skylight color\n    return skylight_col * attenuation;\n}\n\n// calculate the skylight color\nvec", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the distance to the nearest object\n    float dist = 1000000.0;\n    \n    // the normal of the nearest object\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    \n    // the position of the nearest object\n    vec3 pos_obj = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the nearest object\n    vec3 color_obj = vec3(0.0, 0.0, 0.0);\n    \n    // the material of the nearest object\n    int material_obj = 0;\n    \n    // the id of the nearest object\n    int id_obj = 0;\n    \n    // the id of the nearest object\n    int id_obj_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last_", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // get the ray direction\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    \n    // get the ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    \n    // get the ray length\n    float rayLength = length(rayDir);\n    \n    // get the ray step\n    float rayStep = 0.01;\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - sr * sr;\n    // Exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b * b - c;\n    // A negative discriminant corresponds to ray missing sphere\n    if (discr < 0.0) return -1.0;\n    // Ray now found to intersect sphere, compute smallest t value of intersection\n    return -b - sqrt(discr);\n}\n\nfloat", "ialize the ray\n    vec3 rayPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    //initialize the color\n    vec4 color = vec4(0.0);\n\n    //initialize the distance\n    float distance = 0.0;\n\n    //initialize the material\n    Material material;\n\n    //initialize the normal\n    vec3 normal;\n\n    //initialize the hit\n    bool hit = false;\n\n    //initialize the hit distance\n    float hitDistance = 0.0;\n\n    //initialize the hit position\n    vec3 hitPos;\n\n    //initialize the hit normal\n    vec3 hitNormal;\n\n    //initialize the hit material\n    Material hitMaterial;\n\n    //initialize the hit object\n    Object hitObject;\n\n    //initialize the hit object index\n    int hitObjectIndex = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex2 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex3 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex4 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex5 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex6 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex7 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex8 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex9 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex10 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex11 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex12 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex13 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex14 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex15 = -1", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    vec3 ray_path[MAX_RAY_PATH_LENGTH];\n    ray_path[0] = ray_origin;\n    int ray_path_length = 1;\n\n    // Initialize the ray color -\n    // the color of the sample ray\n    vec3 ray_color = vec3(0.0);\n\n    // Initialize the ray distance -\n    // the distance of the sample ray\n    float ray_distance = 0.0;\n\n    // Initialize the ray bounce -\n    // the number of bounces the sample ray has made\n    int ray_bounce = 0;\n\n    // Initialize the ray mask -\n    // the mask of the sample ray\n    int ray_mask = 0;\n\n    // Initialize the ray material -\n    // the material of the sample ray\n    int ray_material = 0;\n\n    // Initialize the ray normal -\n    // the normal of the sample ray\n    vec3 ray_normal = vec3(0.0);\n\n    // Initialize the ray position -\n    // the position of the sample ray\n    vec3 ray_position = ray_origin;\n\n    // Initialize the ray direction -\n    // the direction of the sample ray\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs_inv = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs_inv_sqr = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample", "\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // Local cell index.\n    float i = id.x + id.y * 10.0;\n    \n    // Random offset.\n    vec2 offset = hash22(i);\n    \n    // Local cell coordinates.\n    vec2 pos0 = pos + offset - 0.5;\n    vec2 pos1 = pos + offset - vec2(1.0, 0.0) - 0.5;\n    vec2 pos2 = pos + offset - vec2(0.0, 1.0) - 0.5;\n    vec2 pos3 = pos + offset - vec2(1.0, 1.0) - 0.5;\n    \n    // Local cell values.\n    float v0 = value(pos0);\n    float v1 = value(pos1);\n    float v2 = value(pos2);\n    float v3 = value(pos3);\n    \n    // Smooth interpolation.\n    float sx = smoothstep(-0.2, 0.2, pos.x);\n    float sy = smoothstep(-0.2, 0.2, pos.y);\n    \n    // Interpolate between the local cells.\n    float vx0 = mix(v0, v1, sx);\n    float vx1 = mix(v2, v3, sx);\n    float vxy = mix(vx0, vx1, sy);\n    \n    return vec3(vxy, pos0, pos3 - pos0);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 j = jigsaw(uv * 10.0);\n    gl_FragColor = vec4(j, 1.0);\n}\n", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance to sphere\n    float dist = length(p - sphere_pos) - sphere_radius;\n\n    return dist;\n}\n\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // calculate the hash\n    vec4 hashx0, hashx1, hashy0, hashy1;\n    FAST32_hash_3D( Pi, hashx0, hashx1, hashy0, hashy1 );\n\n    // calculate the gradients\n    vec4 gradx0 = hashx0 - 0.49999;\n    vec4 gradx1 = hashx1 - 0.49999;\n    vec4 grady0 = hashy0 - 0.49999;\n    vec4 grady1 = hashy1 - 0.49999;\n\n    // normals\n    vec4 norm0 = inversesqrt( gradx0 * gradx0 + grady0 * grady0 + 1.0 );\n    vec4 norm1 = inversesqrt( gradx1 * gradx1 + grady1 * grady1 + 1.0 );\n\n    // mix normals\n    vec2 norm00 = vec2( gradx0.x, grady0.x ) * norm0.x;\n    vec2 norm10 = vec2( gradx1.x, grady1.x ) * norm1.x;\n    vec2 norm01 = vec2( gradx0.y, grady0.y ) * norm0.y;\n    vec2 norm11 = vec2( gradx1.y, grady1.y ) * norm1.y;\n    vec2 norm02 = vec2( gradx0.z, grady0.z ) * norm0.z;\n    vec2 norm12 = vec2( gradx1.z, grady1.z ) * norm1.z;\n    vec2 norm03 = vec2( gradx0.w, grady0.w ) * norm0.w;\n    vec2 norm13 = vec2( gradx1.w, grady1.w ) * norm1.w;\n\n    // compute the", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    // noise\n    return mix(\n        mix(\n            hash(i+0.0),\n            hash(i+1.0),\n            u\n        ),\n        mix(\n            hash(i+1.0),\n            hash(i+2.0),\n            u\n        ),\n        f\n    );\n}\n\nfloat", "\n    float d = p.y;\n    float t = -(p.y + 1.0) / p.z;\n    if (t > 0.0) d = min(d, t);\n    t = (p.y - 1.0) / p.z;\n    if (t > 0.0) d = min(d, t);\n    t = -p.y / p.x;\n    if (t > 0.0) d = min(d, t);\n    t = p.y / p.x;\n    if (t > 0.0) d = min(d, t);\n    return vec2(d, 0.0);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n\n    // base\n    float d2 = sdBox(p, vec3(0.9));\n\n    // base hole\n    float d3 = sdBox(p, vec3(0.8));\n\n    // base hole\n    float d4 = sdBox(p, vec3(0.7));\n\n    // base hole\n    float d5 = sdBox(p, vec3(0.6));\n\n    // base hole\n    float d6 = sdBox(p, vec3(0.5));\n\n    // base hole\n    float d7 = sdBox(p, vec3(0.4));\n\n    // base hole\n    float d8 = sdBox(p, vec3(0.3));\n\n    // base hole\n    float d9 = sdBox(p, vec3(0.2));\n\n    // base hole\n    float d10 = sdBox(p, vec3(0.1));\n\n    // base hole\n    float d11 = sdBox(p, vec3(0.05));\n\n    // base hole\n    float d12 = sdBox(p, vec3(0.025));\n\n    // base hole\n    float d13 = sdBox(p, vec3(0.0125));\n\n    // base hole\n    float d14 = sdBox(p, vec3(0.00625));\n\n    // base hole\n    float d15 = sdBox(p, vec3(0.003125));\n\n    // base hole\n    float d16 = sdBox(p, vec3(0.0015625));\n\n    // base hole\n    float d17 = sdBox(p, vec3(0.00078125));\n\n    // base hole\n    float d18 = sdBox(p, vec3(0.000390625));\n\n    // base hole\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n\tvec2 st = fragCoord;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = distance(st,vec2(iMouse.x,iMouse.y));\n\t\n\tfloat r = d/100.0;\n\t\n\tcolor = vec3(r);\n\t\n\tfragColor = vec4(color,1.0);\n}", "\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.", "\n    return (sin(ix*1600+iy*1600)+sin(ix*1600+iy*1600+136)+sin(ix*1600+iy*1600+272))/3;\n}\n\nfloat", "\n    p.xz = rotate2d( time * 0.5 ) * p.xz;\n\n    // map the sphere\n    p = map( p );\n\n    // get the color\n    return getColor( p );\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    vec3 rayDir = normalize( vec3( uv.x, uv.y, 1.0 ) );\n\n    // raymarch\n    float t = raymarch( rayDir );\n\n    // get the color\n    vec3 color = getColor( rayDir * t );\n\n    // output\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n   ", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy - e.xzy;\n\t \n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3.xyz;\n\t vec3 x2 = x - i2 + 2.0*G3.xyz;\n\t vec3 x3 = x - 1.0 + 3.0*G3.xyz;\n\t \n\t /* calculate skewed coords and unskewed coords for 3d noise */\n\t vec3 s1 = s + s*s13;\n\t vec3 s2 = s1 + i1;\n\t vec3 s3 = s2 + i2;\n\t \n\t vec3 n1 = hash33(s1);\n\t vec3 n2 = hash33(s2);\n\t vec3 n3 = hash33(s3);\n\t \n\t /* calculate noise */\n\t vec3 d1 = x - x1;\n\t vec3 d2 = x - x2;\n\t vec3 d3 = x - x3;\n\t \n\t vec3 n = d1*dot(d1, vec3(n1.y, n2.y, n3.y)) + d2*dot(d2, vec3(n1.z, n2.z, n3.z)) + d3*dot(d3, vec3(n1.x, n2.x, n3.x));\n\t \n\t /* scale and return value */\n\t return 70.0*dot(n, vec3(1.0));\n}\n\nfloat", "\n    float d = sdBox( p, vec3( 1.0, 1.0, 1.0 ) );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 2.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 3.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 4.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 5.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 6.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 7.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 8.0 ), vec3( 1.0, ", "\n    p.xz *= mat2( 0.95, 0.0, -0.0, 0.95 );\n    \n    // the distance to the tree\n    float d = length( p ) - 1.0;\n    \n    // the distance to the trunk\n    d = max( d, -p.y + 0.5 );\n    \n    // the distance to the leaves\n    d = min( d, length( p.xz - vec2( 0.0, 0.0 ) ) - 0.1 );\n    \n    return d;\n}\n\nvec", "\n    //float k = floor(rp.x*.5)*.25;\n    float k = floor(rp.x*.25)*.25;\n    //float k = floor(rp.x*.1)*.25;\n    //float k = floor(rp.x*.05)*.25;\n    //float k = floor(rp.x*.025)*.25;\n    //float k = floor(rp.x*.01)*.25;\n    //float k = floor(rp.x*.005)*.25;\n    //float k = floor(rp.x*.0025)*.25;\n    //float k = floor(rp.x*.001)*.25;\n    //float k = floor(rp.x*.0005)*.25;\n    //float k = floor(rp.x*.00025)*.25;\n    //float k = floor(rp.x*.0001)*.25;\n    //float k = floor(rp.x*.00005)*.25;\n    //float k = floor(rp.x*.000025)*.25;\n    //float k = floor(rp.x*.00001)*.25;\n    //float k = floor(rp.x*.000005)*.25;\n    //float k = floor(rp.x*.0000025)*.25;\n    //float k = floor(rp.x*.000001)*.25;\n    //float k = floor(rp.x*.0000005)*.25;\n    //float k = floor(rp.x*.00000025)*.25;\n    //float k = floor(rp.x*.0000001)*.25;\n    //float k = floor(rp.x*.00000005)*.25;\n    //float k = floor(rp.x*.000000025)*.25;\n    //float k = floor(rp.x*.00", "\n\treturn max(0.0, min(1.0, (end - d) / (end - start)));\n}\n\nvec", "\n    vec4 hexCenters = vec4(0.0, 0.0, 0.0, 0.0);\n    hexCenters.x = mod(floor(p.x / 2.0), 2.0);\n    hexCenters.y = mod(floor(p.y / 2.0), 2.0);\n    hexCenters.z = mod(floor(p.x / 2.0), 2.0);\n    hexCenters.w = mod(floor(p.y / 2.0), 2.0);\n    \n    // The hexagon ID is the unique hexagon center that is closest to the current point.\n    float hexID = hexCenters.x + hexCenters.y * 2.0 + hexCenters.z * 4.0 + hexCenters.w * 8.0;\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter = vec2(hexCenters.x, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter2 = vec2(hexCenters.z, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter3 = vec2(hexCenters.x, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter4 = vec2(hexCenters.z, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter5 = vec2(hexCenters.x, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter6 = vec2(hexCenters.z, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current", "\n    float rnd = random(floor(p));\n    \n    // Two by two cell random value.\n    float rnd2 = random(floor(p)+1.0);\n    \n    // Two by two cell random value.\n    float rnd3 = random(floor(p)+vec2(1.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd4 = random(floor(p)+vec2(1.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd5 = random(floor(p)+vec2(0.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd6 = random(floor(p)+vec2(1.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd7 = random(floor(p)+vec2(2.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd8 = random(floor(p)+vec2(2.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd9 = random(floor(p)+vec2(2.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd10 = random(floor(p)+vec2(0.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd11 = random(floor(p)+vec2(2.0,3.0));\n    \n    // Two by two cell random value.\n    float rnd12 = random(floor(p)+vec2(3.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd13 = random(floor(p)+vec2(3.0,3.0));\n    \n    // Two by two cell random value.\n    float rnd14 = random(floor(p)+vec2(3.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd15 = random", "\n    float scale = iMouse.x / iResolution.x;\n\n    // Set color according to scale.\n    // If scale is 0.0, color is red.\n    // If scale is 1.0, color is blue.\n    // If scale is 0.5, color is green.\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), scale);\n\n    // Set output color to color.\n    fragColor = vec4(color, 1.0);\n}", "\n    float theta = atan(pc.y, pc.x);\n    \n    //Solve for the distance of the polar coordinate\n    //(r = a+b*theta)\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    \n    //Solve for the distance of the polar coordinate\n    //(r = a+b*theta)\n    float r2 = a + b*theta;\n    \n    //Return the difference between the two distances\n    return r - r2;\n}\n\nvoid main(){\n    \n    //Get the polar coordinate of the current pixel\n    vec2 pc = vec2(gl_FragCoord.x, gl_FragCoord.y);\n    \n    //Get the polar coordinate of the center of the screen\n    vec2 center = vec2(width/2.0, height/2.0);\n    \n    //Get the distance of the polar coordinate from the center\n    float dist = distance(pc, center);\n    \n    //Get the distance of the polar coordinate from the center\n    //(r = a+b*theta)\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    \n    //Get the distance of the polar coordinate from the center\n    //(r = a+b*theta)\n    float r2 = a + b*atan(pc.y, pc.x);\n    \n    //Get the difference between the two distances\n    float diff = r - r2;\n    \n    //Get the difference between the two distances\n    float diff2 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff3 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff4 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff5 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff6 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference", "\n    return smoothstep(pct-0.02, pct, st.y) - smoothstep(pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a dot\n    color = vec3(st.x,st.y,0.0);\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line", "\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/po", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float ia = floor(a/TWO_PI);\n    a -= ia*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float b = atan(r, p.x);\n    float ib = floor(b/TWO_PI);\n    b -= ib*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float c = atan(r, p.y);\n    float ic = floor(c/TWO_PI);\n    c -= ic*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float d = atan(p.y, p.x);\n    float id = floor(d/TWO_PI);\n    d -= id*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float e = atan(r, p.x);\n    float ie = floor(e/TWO_", "\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Invert the mouse coordinates.\n    m = (m - 0.5) * 2.0;\n    \n    // Invert the mouse coordinates.\n    m.y *= -1.0;\n    \n    // Return the inverted mouse coordinates.\n    return m;\n}\n\n// 2D rotation matrix.\nmat", "\n\tvec3 lightPos0 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos1 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 =", "\n\tvec3 camPos = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 camUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 camSide = normalize(cross(camDir, camUp));\n\t\n\t// Camera\n\tvec3 rayDir = normalize(camSide * (fragCoord.x - 0.5 * iResolution.x) + camUp * (fragCoord.y - 0.5 * iResolution.y) + camDir * 1.0);\n\t\n\t// Raymarching\n\tfloat dist = 0.0;\n\tfloat maxDist = 100.0;\n\tfloat minDist = 0.001;\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = camPos + rayDir * dist;\n\t\tfloat d = map(pos);\n\t\tdist += d;\n\t\tif (d < minDist || dist > maxDist) break;\n\t}\n\t\n\t// Lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 10.0);\n\tvec3 lightDir = normalize(lightPos - pos);\n\tfloat diffuse = max(dot(lightDir, normal), 0.0);\n\t\n\t// Output\n\tfragColor = vec4(diffuse, diffuse, diffuse, 1.0);\n}\n\nfloat", "\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  // Time varying pixel color\n  vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}", "\n    vec3 cube = mod(floor(hash * 255.0), 2.0) * 2.0 - 1.0;\n    \n    // Random vertex of a tetrahedron inside it\n    float choice = mod(hash * 4.0, 1.0);\n    float s = (choice < 0.25)? 1.0 : 0.0;\n    float t = (choice < 0.5)? 1.0 : 0.0;\n    float u = (choice < 0.75)? 1.0 : 0.0;\n    vec3 tetra = vec3(s, t, u);\n    \n    // Blend the two and renormalize\n    vec3 blend = cube + tetra;\n    blend *= inversesqrt(dot(blend, blend));\n    \n    return blend;\n}\n\nfloat", "\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector", "\n  float d = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the YZ plane\n  float d2 = length(p.yz) - 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 1.0;\n  // return the minimum distance\n  return min(d, min(d2, d3));\n}\n\nvec", "\n    // \ub9cc\uc57d \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \uc815\ud655\ud55c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub530\ub77c\uc11c \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\ufffd", "\n\tmat2 rot = mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n\t\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Get the pixel color\n\tvec3 col = texture(iChannel0, uv).rgb;\n\t\n\t// Rotate the pixel coordinates\n\tuv = (uv - 0.5) * rot + 0.5;\n\t\n\t// Get the rotated pixel color\n\tvec3 col2 = texture(iChannel0, uv).rgb;\n\t\n\t// Mix the two colors\n\tcol = mix(col, col2, 0.5);\n\t\n\t// Output the color\n\tfragColor = vec4(col, 1.0);\n}", "-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos", "\n    vec3 targetDir = normalize( targetPos - ray.origin );\n    float targetDist = length( targetPos - ray.origin );\n    \n    float targetAngle = acos( dot( targetDir, ray.direction ) );\n    float targetAngle2 = targetAngle * targetAngle;\n    \n    float targetAngle3 = targetAngle2 * targetAngle;\n    float targetAngle4 = targetAngle3 * targetAngle;\n    float targetAngle5 = targetAngle4 * targetAngle;\n    \n    float targetAngle6 = targetAngle5 * targetAngle;\n    float targetAngle7 = targetAngle6 * targetAngle;\n    float targetAngle8 = targetAngle7 * targetAngle;\n    \n    float targetAngle9 = targetAngle8 * targetAngle;\n    float targetAngle10 = targetAngle9 * targetAngle;\n    float targetAngle11 = targetAngle10 * targetAngle;\n    \n    float targetAngle12 = targetAngle11 * targetAngle;\n    float targetAngle13 = targetAngle12 * targetAngle;\n    float targetAngle14 = targetAngle13 * targetAngle;\n    \n    float targetAngle15 = targetAngle14 * targetAngle;\n    float targetAngle16 = targetAngle15 * targetAngle;\n    float targetAngle17 = targetAngle16 * targetAngle;\n    \n    float targetAngle18 = targetAngle17 * targetAngle;\n    float targetAngle19 = targetAngle18 * targetAngle;\n    float targetAngle20 = targetAngle19 * targetAngle;\n    \n    float targetAngle21 = targetAngle20 * targetAngle;\n    float targetAngle22 = targetAngle21 * targetAngle;\n    float targetAngle23 = targetAngle22 * targetAngle;\n    \n    float targetAngle24 = targetAngle23 * targetAngle;\n    float targetAngle25 = targetAngle24 * targetAngle;\n    float", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n\n    // quintic interpolation\n    return mix(\n        mix(\n            mix(dot(hash(i + vec2(0.0, 0.0)), vec2(f, f), 1.0),\n                dot(hash(i + vec2(1.0, 0.0)), vec2(f - 1.0, f), 1.0), u),\n            mix(dot(hash(i + vec2(0.0, 1.0)), vec2(f, f - 1.0), 1.0),\n                dot(hash(i + vec2(1.0, 1.0)), vec2(f - 1.0, f - 1.0), 1.0), u),\n            u),\n        mix(\n            mix(dot(hash(i + vec2(0.0, 0.0)), vec2(f, f), 1.0),\n                dot(hash(i + vec2(1.0, 0.0)), vec2(f - 1.0, f), 1.0), u),\n            mix(dot(hash(i + vec2(0.0, 1.0)), vec2(f, f - 1.0), 1.0),\n                dot(hash(i + vec2(1.0, 1.0)), vec2(f - 1.0, f - 1.0), 1.0), u),\n            u),\n        u);\n}\n\nfloat", "s\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float inverDeno = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * inverDeno;\n    float v = (dot00 * dot12 - dot01 * dot02) * inverDeno;\n\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a triangle\n    if(in_triangle(vec2(0.2, 0.2), vec2(0.8, 0.2), vec2(0.5, 0.8), uv)){\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    float n = log(uv.x/start_radius)/log(1.5);\n    float n_int = floor(n);\n    float n_frac = n - n_int;\n    \n    //Find the closest hexagon\n    if(n_frac < 0.5){\n        n_int -= 1.0;\n    }\n    \n    //Find the center of the closest hexagon\n    float r = start_radius * pow(1.5, n_int);\n    float theta = atan(uv.y, uv.x);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    \n    return int(n_int);\n}\n\nvec", ".\n    //The points are then rotated and translated to the\n    //current hexagon.\n    \n    //The current hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next", ".\n    //\n    //The distance between the points is the circumradius of the hexagon.\n    //\n    //The angle between the points is 30 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon", "\n    float k = exp(-d);\n    float x = exp(dot(U, U) / 2.0);\n    return x * k / (2.0 * 3.1415926535897932384626433832795);\n}\n\nfloat", "'s implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash6(uint n)\n{\n    //", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // time\n    float t = iTime;\n\n    // color\n    vec3 col = vec3(0.0);\n\n    // loop\n    for (float i = 0.0; i < 10.0; i++) {\n        // position\n        vec2 pos = vec2(sin(t * 0.1 + i * 0.1), cos(t * 0.1 + i * 0.1));\n\n        // distance\n        float d = length(uv - pos);\n\n        // color\n        col += vec3(1.0 / d);\n    }\n\n    // output\n    fragColor = vec4(col, 1.0);\n}", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n  float epsilon = 0.0001;\n  // calculate the normal\n  return normalize(\n    vec3(\n      calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0)),\n      calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0)),\n      calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon))\n    )\n  );\n}\n\nvoid main() {\n  // calculate the normal\n  vec3 normal = calcNormal(v_position);\n  // calculate the light\n  vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n  // calculate the diffuse\n  float diffuse = max(dot(normal, light), 0.0);\n  // calculate the ambient\n  float ambient = 0.1;\n  // calculate the final color\n  vec3 color = vec3(diffuse + ambient);\n  // set the final color\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n  vec2 t = castRay(ro, rd);\n  vec3 col = vec3(0.0);\n  if (t.x > 0.0) {\n    vec3 pos = ro + t.x * rd;\n    vec3 nor = calcNormal(pos);\n    col = calcColor(pos, nor);\n  }\n  return col;\n}\n\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  vec3 ro = vec3(0.0, 0.0, 1.0);\n  vec3 rd = normalize(vec3(uv, -1.0));\n  vec3 col = render(ro, rd);\n  gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float epsilon = 0.0001;\n    // calculate the normal\n    return normalize(vec3(\n        calcHeight(pos + vec3(epsilon, 0, 0)) - calcHeight(pos - vec3(epsilon, 0, 0)),\n        calcHeight(pos + vec3(0, epsilon, 0)) - calcHeight(pos - vec3(0, epsilon, 0)),\n        calcHeight(pos + vec3(0, 0, epsilon)) - calcHeight(pos - vec3(0, 0, epsilon))\n    ));\n}\n\nvoid main() {\n    // calculate the normal\n    vec3 normal = calcNormal(position);\n    // calculate the light\n    vec3 light = normalize(vec3(1, 1, 1));\n    // calculate the color\n    vec3 color = vec3(0.5, 0.5, 0.5) * max(dot(normal, light), 0.0);\n    // set the color\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t.x > 0.0) {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        col = calcColor(pos, nor);\n        col = mix(col, vec3(0.8, 0.9, 1.0), 1.0-exp(-0.0001*t.x*t.x*t.x));\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 color = texture(texture_diffuse1, p.xz).rgb;\n    //normal map\n    vec3 normal = texture(texture_normal1, p.xz).rgb;\n    //normal = normal * 2.0 - 1.0;\n    normal = normalize(normal * 2.0 - 1.0);\n    return normal;\n}\n\nvoid main()\n{\n    //vec3 normal = normalize(fs_in.Normal);\n    vec3 normal = estimateNormal(fs_in.FragPos);\n    vec3 viewDir = normalize(viewPos - fs_in.FragPos);\n    vec3 reflectDir = reflect(-viewDir, normal);\n    vec3 specular = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 specularColor = vec3(0.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 ambientColor = vec3(0.0);\n    vec3 color = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 halfwayDir = vec3(0.0);\n    float specularStrength = 0.0;\n    float shininess = 0.0;\n    float diffuseStrength = 0.0;\n    float ambientStrength = 0.0;\n    float attenuation = 0.0;\n    float distance = 0.0;\n    float specularIntensity = 0.0;\n    float diffuseIntensity = 0.0;\n    float ambientIntensity = 0.0;\n    float specularFactor = 0.0;\n    float diffuseFactor = 0.0;\n    float ambientFactor = 0.0;\n    float specularFactor2 = 0.0;\n    float diffuseFactor2 = 0.0;\n    float ambientFactor2 = 0.0;\n    float spec", "\n    return fract( sin( dot( q.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat", "els\n\tvec2 texel = vec2( 16.0 / 1024.0, 16.0 / 1024.0 );\n\tvec2 uv = vec2( mod( float( i ), 16.0 ) * texel.x, floor( float( i ) / 16.0 ) * texel.y );\n\tvec2 uv2 = uv + texel;\n\tvec2 uv3 = uv + texel * 2.0;\n\tvec2 uv4 = uv + texel * 3.0;\n\tvec2 uv5 = uv + texel * 4.0;\n\tvec2 uv6 = uv + texel * 5.0;\n\tvec2 uv7 = uv + texel * 6.0;\n\tvec2 uv8 = uv + texel * 7.0;\n\tvec2 uv9 = uv + texel * 8.0;\n\tvec2 uv10 = uv + texel * 9.0;\n\tvec2 uv11 = uv + texel * 10.0;\n\tvec2 uv12 = uv + texel * 11.0;\n\tvec2 uv13 = uv + texel * 12.0;\n\tvec2 uv14 = uv + texel * 13.0;\n\tvec2 uv15 = uv + texel * 14.0;\n\tvec2 uv16 = uv + texel * 15.0;\n\n\tvec4 texel0 = texture2D( texture, uv );\n\tvec4 texel1 = texture2D( texture, uv2 );\n\tvec4 texel2 = texture2D( texture, uv3 );\n\tvec4 texel3 = texture2D( texture, uv4 );\n\tvec4 texel4 = texture2D( texture, uv5 );\n\tvec4 texel5 = texture2D( texture, uv6", "\n    p.x = abs(p.x);\n\n    // scale\n    p *= ab;\n\n    // ellipse\n    vec2 d = p - ab;\n    float a = dot(d,d);\n    float b = a/dot(ab,ab);\n    float c = sqrt(a*b);\n    float e = sqrt(b);\n    float f = c/e;\n    float g = atan(d.y,d.x);\n    float h = (135.0/180.0)*3.1415926535897932384626433832795;\n    float i = abs(g-h)/3.1415926535897932384626433832795;\n    float j = clamp(i,0.0,1.0);\n    float k = c*(1.0+cos(j*3.1415926535897932384626433832795-h));\n    float l = sqrt(a)*k;\n    float m = dot(d,d)*(1.0/dot(ab,ab));\n    float n = sqrt(m);\n    float o = n*(0.5+0.5*cos(g/2.0));\n    float q = l-o;\n    float r = sqrt(dot(p,p));\n    float s = q/r;\n    float t = atan(p.y,p.x);\n    float u = mod(t+3.1415926535897932384626433832795,6.283185307179586476925286766559)/3.1415926535897932384626433832795;\n    float v = clamp(", "\n    vec4 p4 = fract(vec4(p) *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    color = vec3(uv,0.5+0.5*sin(iTime));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "\n    float t = 0.0;\n    float tmin = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    // Calculate the Rotation Matrix\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy*cz + cx*sz, cx*cz - sx*sy*sz, -cx*sy*sz + sx*cz,\n        -cx*sy*cz + sx*sz, cx*sz + sx*sy*cz, cx*cy\n    );\n}\n\nvec", "\n    rayori = rayori - camera;\n    // Normalize the Ray\n    raydir = normalize(raydir);\n    // Set the initial distance to 0\n    float dist = 0.0;\n    // Set the initial color to 0\n    vec3 color = vec3(0.0);\n    // Set the initial normal to 0\n    vec3 normal = vec3(0.0);\n    // Set the initial hit to false\n    bool hit = false;\n    // Set the initial hit distance to 0\n    float hitdist = 0.0;\n    // Set the initial hit normal to 0\n    vec3 hitnormal = vec3(0.0);\n    // Set the initial hit color to 0\n    vec3 hitcolor = vec3(0.0);\n    // Set the initial hit material to 0\n    vec3 hitmaterial = vec3(0.0);\n    // Set the initial hit texture to 0\n    vec3 hittexture = vec3(0.0);\n    // Set the initial hit texture color to 0\n    vec3 hittexturecolor = vec3(0.0);\n    // Set the initial hit texture normal to 0\n    vec3 hittexturenormal = vec3(0.0);\n    // Set the initial hit texture material to 0\n    vec3 hittexturematerial = vec3(0.0);\n    // Set the initial hit texture texture to 0\n    vec3 hittexturetexture = vec3(0.0);\n    // Set the initial hit texture texture color to 0\n    vec3 hittexturetexturecolor = vec3(0.0);\n    // Set the initial hit texture texture normal to 0\n    vec3 hittexturetexturenormal = vec3(0.0);\n    // Set the initial hit texture texture material to 0\n    vec3 hittexturetexturematerial = vec3(0.0);\n    // Set the initial hit texture texture texture to 0\n    vec3 hittexturetexturetexture = vec3(0.0);\n    // Set the initial hit texture texture texture color to 0\n", "\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3", "\n    vec3 pos = rayori;\n    float dist = 0.0;\n    float totaldist = 0.0;\n    float t = 0.0;\n    float maxdist = 100.0;\n    float eps = 0.001;\n    float maxsteps = 100.0;\n    float steps = 0.0;\n    float hit = 0.0;\n    float id = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float f = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float c = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww = 0.0;\n    float xx = 0.0;\n    float yy = 0.0;\n    float zz = 0.0;\n    float aa = 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float seed = uv.x + uv.y * 1000.0;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + i", "\n    float borderFade = min(coord.x, 1.0 - coord.x);\n    borderFade = min(borderFade, min(coord.y, 1.0 - coord.y));\n\n    // Calculate ray position\n    float rayPos = travelRate * frequency * iTime;\n    rayPos = fract(rayPos);\n\n    // Calculate ray strength\n    float rayStrength = maxStrength * (1.0 - borderFade);\n    rayStrength *= smoothstep(rayPos - 0.01, rayPos, coord.x);\n    rayStrength *= smoothstep(rayPos, rayPos + 0.01, coord.x);\n\n    return rayStrength;\n}\n\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from", "\n    //return color / (color + vec3(1.0));\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 -", "\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\n    // compute point and normal\n    vec2 c = a + h*ba;\n    vec2 n = vec2(ba.y,-ba.x);\n\n    // compute distance\n    return length(pa-h*ba)*sign(pa.x*ba.y-pa.y*ba.x-w1*n.x*pa.x+w1*n.y*pa.y);\n}\n\nfloat", "\n    uv = (uv - 0.5) * mat2( 1.0, 0.0, -0.707, 0.707 );\n\n    //get the distance to the center\n    float d = length( uv );\n\n    //get the angle of the uv\n    float a = atan( uv.y, uv.x );\n\n    //get the distance to the edge\n    float e = abs( d - 0.5 );\n\n    //get the distance to the edge\n    float f = abs( d - 0.5 ) * 2.0;\n\n    //get the distance to the edge\n    float g = abs( d - 0.5 ) * 3.0;\n\n    //get the distance to the edge\n    float h = abs( d - 0.5 ) * 4.0;\n\n    //get the distance to the edge\n    float i = abs( d - 0.5 ) * 5.0;\n\n    //get the distance to the edge\n    float j = abs( d - 0.5 ) * 6.0;\n\n    //get the distance to the edge\n    float k = abs( d - 0.5 ) * 7.0;\n\n    //get the distance to the edge\n    float l = abs( d - 0.5 ) * 8.0;\n\n    //get the distance to the edge\n    float m = abs( d - 0.5 ) * 9.0;\n\n    //get the distance to the edge\n    float n = abs( d - 0.5 ) * 10.0;\n\n    //get the distance to the edge\n    float o = abs( d - 0.5 ) * 11.0;\n\n    //get the distance to the edge\n    float p = abs( d - 0.5 ) * 12.0;\n\n    //get the distance to the edge\n    float q = abs( d - 0.5 ) * 13.0;\n\n    //get the distance to the edge\n    float r = abs( d - 0.5 ) * 14.0;\n\n   ", "\n    vec3 colA = vec3(0.0,0.0,0.0);\n    vec3 colB = vec3(1.0,1.0,1.0);\n    return mix( colA, colB, falloff ) + rnd;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime;\n    float tt = t * 0.1;\n\n    vec3 col = vec3(0.0);\n\n    float falloff = 0.0;\n    vec3 rnd = vec3(0.0);\n\n    for( int i=0; i<10; i++ )\n    {\n        float f = float(i);\n        float tt2 = tt + f * 0.1;\n        float a = f * 0.1;\n        float s = sin( tt2 ) * 0.5 + 0.5;\n        float c = cos( tt2 ) * 0.5 + 0.5;\n        vec2 r = vec2( c, s );\n        vec2 q = p + r * a;\n        float d = length( q );\n        falloff += ( 1.0 - d ) * ( 1.0 - d );\n        rnd += pulse( d, vec3(0.0) );\n    }\n\n    col = pulse( falloff, rnd );\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "\n   vec3 q = vec3(vec2(p), p*p);\n   q = mod(q, 289.0);\n   return fract(q*vec3(41.0, 289.0, 151.0));\n}\n\nvec", "\n  //  return x - x*x*x/3 + x*x*x*x*x/5;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13 - x*x*x*x*x*x*x*x*x*x*x*x*x", "\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(", "\n    vec3 d = abs(p) - 1.0;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"]}