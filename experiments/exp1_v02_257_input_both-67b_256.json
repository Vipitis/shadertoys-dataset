{"input_both": ["\n\treturn max(0.0,cos( a ));\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    p = p - rotDir*dot(p,rotDir);\n\n    // Rotate the whole thing\n    p = Rotate(p,rotAngle);\n\n    // Scale\n    p *= scale;\n\n    // Translate\n    p += translate;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Get the distance to the voxel\n\tfloat d = length(p) - 0.5;\n\n\t// Return the distance\n\treturn d;\n}\n\n// Distance to the voxel\nfloat", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Distance to the scene\n\tfloat d = sdScene(p);\n\n\t// Color of the closest point\n\tP = vec3(0.0);\n\n\t// If the point is in the scene\n\tif (d < EPS) {\n\n\t\t// Get the color of the closest point\n\t\tP = getColor(p);\n\n\t\t// If the point is in the glow area\n\t\tif (d < GLOW_RADIUS) {\n\n\t\t\t// Add the glow\n\t\t\tP = P + glow(p);\n\t\t}\n\t}\n\n\t// Return the distance and the color\n\treturn vec2(d, P);\n}\n\n// Ray marching\nvec", " coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos2 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos3 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.", "\n\tvec4 colors[4];\n\tcolors[0] = vec4(0.0, 0.0, 0.0, 1.0);\n\tcolors[1] = vec4(0.0, 0.0, 1.0, 1.0);\n\tcolors[2] = vec4(0.0, 1.0, 0.0, 1.0);\n\tcolors[3] = vec4(1.0, 0.0, 0.0, 1.0);\n\n\tfloat x0 = floor(x);\n\tfloat x1 = x0 + 1.0;\n\tfloat w0 = x1 - x;\n\tfloat w1 = x - x0;\n\n\tvec4 c0 = colors[int(x0)];\n\tvec4 c1 = colors[int(x1)];\n\n\treturn c0 * w0 + c1 * w1;\n}\n\nvoid main()\n{\n\tvec4 color = gradient(v_color);\n\tgl_FragColor = color;\n", "\n\tvec4 color = texture(colorGradient, d);\n\n\t// add ambient light\n\tcolor += ambient;\n\n\t// add diffuse light\n\tcolor += diffuse * max(dot(normal, lightDir), 0.0);\n\n\t// add specular light\n\tcolor += specular * pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), shininess);\n\n\treturn color;\n}\n\nvoid main()\n{\n\t// get the distance to the point\n\tfloat d = distance(position, cameraPos);\n\n\t// shade the point\n\tvec4 color = shade(d);\n\n\t// set the fragment color\n\tfragColor = color;\n}\n", " up to the top\n    float fade = (rayDir.y + 1.0) * 0.5;\n\n    // softbox\n    float dist = RayBox(rayDir, vec3(0.0), vec3(100.0), 0.0);\n\n    // 4 lights in a horizontal circle\n    float dist2 = RayBox(rayDir, vec3(0.0, 0.0, 10.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist3 = RayBox(rayDir, vec3(0.0, 0.0, 20.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist4 = RayBox(rayDir, vec3(0.0, 0.0, 30.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist5 = RayBox(", "\n    float t = mod(time, 6.0);\n    if (t < 2.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a parabola\n    float x = coords.x;\n    float y = coords.y;\n    return (x - 2.0) * (x - 4.0) - y;\n}\n\n// the derivative of F(x,y)\nvec", "\n    float t = mod(time, 10.0);\n    if (t < 2.0 || t > 8.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of time\n    float tt = t - 2.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of x and y\n    float xxx = xx * xx;\n    float yyy = yy * yy;\n\n    // the curve is a function of x and y\n    float xxxx = xxx * xxx;\n    float yyyy = yyy * yyy;\n\n    // the curve is a function of x and y\n    float xxxxx = xxxx * xxx;\n    float yyyyy = yyyy * yyy;\n\n    // the curve is a function of", "\n    float t = mod(time, 5.0);\n    if (t < 1.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of t\n    float tt = t - 1.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of t, x and y\n    float ttt = tt * tt * tt;\n    float xxx = xx * xx * xx;\n    float yyy = yy * yy * yy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y^3\n    float f = ttt * xxx * yyy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y", " by changing the value of the variable\n    float time = iTime * 0.5;\n\n    //get the position of the pixel in the screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv4 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv5 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv6 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv7 = fragCoord.xy / iResolution.xy", "\n    vec3 q = p + vec3(0.0, 0.0, p.z * 0.00001);\n\n    // The time dialation is applied to the position and time frequencies.\n    float f = pow(2.0, 1.0 - 1.0 * u_time);\n    float g = pow(2.0, 1.0 - 1.0 * u_time);\n\n    // The noise is generated from the position and time frequencies.\n    float n = fbm(f * p);\n    float m = fbm(g * q);\n\n    // The noise is then returned.\n    return n + m;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269", "\n    vec2 i = floor(p + (p.x + p.y) *.125);\n    vec2 x0 = i - (i.x + i.y) *.25;\n    vec2 g = step(vec2(.5), fract(abs(x0) + vec2(.5,.75)));\n    vec2 o = g.yx * g.x + g.xy * (1. - g.x);\n    vec2 d = p - x0 - (o -.5);\n    float h = dot(d, d);\n    \n    // Simplex grid stuff.\n    //\n    vec2 i1;\n    if(o.y < o.x) i1 = vec2(1., 0.);\n    else i1 = vec2(0., 1.);\n    vec2 x1 = x0 + i1;\n    vec2 g1 = step(vec2(.5), fract(abs(x1) + vec2(.5,.75)));\n    vec2 o1 =", "\n    vec2 cell = floor(p);\n    // Get the distance to the cell.\n    vec2 cell_dist = p - cell;\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev = vec", "\n  vec3 color = vec3(0.0,0.0,0.0);\n\n  // get the position of the hit\n  vec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n\n  // get the normal of the hit\n  vec3 hitNormal = getNormal( hitPosition );\n\n  // get the material of the hit\n  Material material = getMaterial( hitPosition );\n\n  // get the light direction\n  vec3 lightDirection = normalize( vec3(1.0,1.0,1.0) );\n\n  // get the light color\n  vec3 lightColor = vec3(1.0,1.0,1.0);\n\n  // get the ambient color\n  vec3 ambientColor = vec3(0.1,0.1,0.1);\n\n  // get the diffuse color\n  vec3 diffuseColor = material.diffuseColor;\n\n  // get the specular color\n  vec3 specularColor = material.specularColor;\n\n  // get the specular exponent\n", "\n    vec2 res = vec2(1000.0, 0.0);\n\n    // sphere\n    res = opU(res, vec2(length(p - vec3(0.0, 0.0, 0.0)) - 1.0, 1.0));\n\n    // plane\n    res = opU(res, vec2(p.y + 1.0, 2.0));\n\n    // box\n    res = opU(res, vec2(length(max(abs(p.xz) - vec2(1.0, 1.0), 0.0)) - 0.1, 3.0));\n\n    return res;\n}\n\n// ~~~~~~~ get normal\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec", "\n\tfloat tmin = 0.001;\n\tfloat tmax = 100.0;\n\tfloat t = tmin;\n\t\n\t// variables used to store the hit object's ID\n\tfloat id = -1.0;\n\t\n\t// variables used to store the hit object's position\n\tvec3 qhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's normal\n\tvec3 nhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's color\n\tvec3 chit = vec3(0.0);\n\t\n\t// variables used to store the hit object's material\n\tfloat mhit = 0.0;\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit2 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit3 = vec2(0", "\n    vec4 res = vec4(0.0);\n\n    // distance to the closest object\n    float d = INFINITY;\n\n    // loop through all the objects\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the distance to the object\n        float d_obj = objects[i].sdf(p);\n\n        // if the distance is less than the current closest distance\n        if (d_obj < d)\n        {\n            // update the closest distance\n            d = d_obj;\n\n            // get the color of the object\n            vec3 col = objects[i].color;\n\n            // if the object is a sphere\n            if (objects[i].type == SPHERE)\n            {\n                // get the normal of the sphere\n                vec3 n = normalize(p - objects[i].pos);\n\n                // get the light direction\n                vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n                // get the ambient light\n                ve", "\n    float t = 0.0;\n    float mint = 0.0;\n    float maxt = 1000.0;\n    float precis = 0.001;\n    float maxd = 100.0;\n    float h = 1.0;\n    float tt = 0.0;\n    float id = 0.0;\n    float itter = 0.0;\n    float itterMax = 100.0;\n    float itterStep = 0.0;\n    float itterStepMax = 10.0;\n    float itterStepMin = 0.0;\n    float itterStepRatio = 0.0;\n    float itterStepRatioMax = 1.0;\n    float itterStepRatioMin = 0.0;\n    float itterStepRatioStep = 0.0;\n    float itterStepRatioStepMax = 1.0;\n    float itterStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioMax", "s\n    vec3 diffs[4];\n    diffs[0] = vec3(0.0, 0.0, 0.0);\n    diffs[1] = vec3(0.0, 0.0, 0.0);\n    diffs[2] = vec3(0.0, 0.0, 0.0);\n    diffs[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs2[4];\n    diffs2[0] = vec3(0.0, 0.0, 0.0);\n    diffs2[1] = vec3(0.0, 0.0, 0.0);\n    diffs2[2] = vec3(0.0, 0.0, 0.0);\n    diffs2[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diff", "\n    vec3 s = vec3(7, 157, 113);\n    \n    // The dot product of the input and the stride.\n    float h = dot(p, s);\n    \n    // The fractional part of the dot product.\n    vec3 f = fract(vec3(h, h+1, h+2) * (1.0 / 31.0));\n    \n    // The fractional part of the dot product, raised to the power of 3.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    // The dot product of the input and the stride, modulo 289.\n    h = mod(h, 289.0);\n    \n    // The index of the first vector.\n    vec3 i = floor(h * (1.0 / 41.0));\n    \n    // The index of the second vector.\n    vec3 j = floor((h - i * 41.0) * (1.0 / 41.", "\n\tvec3 col = vec3(0.);\n\tfloat t = 0.;\n\tfloat tmax = 1000.;\n\tfloat tmin = 0.001;\n\tfloat tstep = 0.01;\n\tfloat tstep2 = 0.001;\n\tfloat tstep3 = 0.0001;\n\tfloat tstep4 = 0.00001;\n\tfloat tstep5 = 0.000001;\n\tfloat tstep6 = 0.0000001;\n\tfloat tstep7 = 0.00000001;\n\tfloat tstep8 = 0.000000001;\n\tfloat tstep9 = 0.0000000001;\n\tfloat tstep10 = 0.00000000001;\n\tfloat tstep11 = 0.000000000001;\n\tfloat tstep12 = 0.0000000000001;\n", "\n    vec2 AB = B - A;\n    vec2 AB_normal = vec2(-AB.y, AB.x);\n    float AB_length = length(AB);\n    vec2 AB_normalized = AB / AB_length;\n    \n    // calculate distance from line segment\n    float dist = dot(AB_normal, coords - A);\n    dist = dist / AB_length;\n    \n    // calculate distance from line segment\n    float dist_from_line = abs(dist);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared = dist_from_line * dist_from_line;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped = clamp(dist_from_line_squared, 0.0, 1.0);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted = 1.0 - dist_from_line_squared_clamped;\n    \n    // calculate distance from line segment\n    float", "\n     float dot = dot(start, end);\n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot);\n     // Adjust start and reflect it about the relative vector\n     return (start*cos(theta)) + (RelativeVec*sin(theta));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    float camFov = 45.0;\n    float camNear = 0.1;\n    float camFar = 100.0;\n    float camAspect = iResolution.x / iResolution.y;\n    mat4 camView = lookAt(camPos, camTarget, camUp);\n    mat4 camProj = perspective(camFov, camAspect, camNear, camFar);\n    mat4 camViewProj = camProj * camView;\n\n    // set up our ray\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 rayStart = vec4(camPos, 1.0);\n", "\n    //\n    //e = a + e * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (", " and forth\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = t * t * t;\n\n    // make a softbox light\n    vec3 lightColor = vec3(1.0, 0.9, 0.8) * 10.0;\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n    float lightDist = 10.0;\n    float lightAtten = 1.0 / (1.0 + 0.01 * lightDist * lightDist);\n    vec3 light = lightColor * lightAtten * max(0.0, dot(lightDir, rayDir));\n\n    // make a softbox shadow\n    float shadow = 1.0;\n    if (t < 0.99)\n    {\n        float shadowDist = RayMarch(rayDir * lightDist, 0.0, 1.0);\n        shadow = max(0.0, 1.0 - shadowDist / lightDist);\n    }\n\n    return light * shadow;", "\n    // The ball-roller is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle", "^2\n\t// => (org.x^2 + 2*org.x*t*dir.x + t^2*dir.x^2) + (org.y^2 + 2*org.y*t*dir.y + t^2*dir.y^2) = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 -", "\n    vec3 q = abs(p) - s.xyz;\n    vec3 q2 = q - s.w;\n    vec3 q3 = q - s.w * 2.0;\n    vec3 q4 = q - s.w * 3.0;\n    // corner radius\n    vec3 r2 = r.xyz * r.xyz;\n    // bottom radius offset\n    vec3 r3 = r.xyz * r.w;\n    // corner distance\n    vec3 d = q * r2 + q2 * r3 + q3 * r.w + q4 * r.w;\n    // bottom distance\n    vec3 d2 = q * r.w + q2 * r.w + q3 * r.w + q4 * r.w;\n    // distance to the nearest corner\n    float dmin = min(min(d.x, d.y), d.z);\n    // distance to the nearest bottom\n    float dmin2 = min(min(d2.x, d2.y), d2.z);", "\n    float x = p.x * 1.0;\n    float y = p.y * 1.0;\n    float z = p.z * 1.0;\n    \n    // The first part of the hash function.\n    float x1 = x * 1.0;\n    float y1 = y * 1.0;\n    float z1 = z * 1.0;\n    \n    // The second part of the hash function.\n    float x2 = x * 1.0;\n    float y2 = y * 1.0;\n    float z2 = z * 1.0;\n    \n    // The third part of the hash function.\n    float x3 = x * 1.0;\n    float y3 = y * 1.0;\n    float z3 = z * 1.0;\n    \n    // The fourth part of the hash function.\n    float x4 = x * 1.0;\n    float y4 = y * 1.0;\n    float z4 = z * 1.0;\n    \n    // The", "\n    float d = dot(p,p);\n    \n    // The circle radius.\n    float r = 0.25;\n    \n    // The circle distance.\n    float c = d - r;\n    \n    // The circle distance squared.\n    float c2 = c*c;\n    \n    // The circle distance cubed.\n    float c3 = c2*c;\n    \n    // The circle distance to the power of 5.\n    float c5 = c3*c2;\n    \n    // The circle distance to the power of 7.\n    float c7 = c5*c2;\n    \n    // The circle distance to the power of 9.\n    float c9 = c7*c2;\n    \n    // The circle distance to the power of 11.\n    float c11 = c9*c2;\n    \n    // The circle distance to the power of 13.\n    float c13 = c11*c2;\n    \n    // The circle distance to the power of 15.\n    float c15 = c1", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // n - Normal vector\n    // nx - Change in \"n\" in in the X-direction.\n    // ny - Change in \"n\" in in the Y-direction.\n    // nz - Change in \"n\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bumpiness.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Slower, but more evenly disperses things.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n  vec3 l = normalize(light_pos - p);\n  float lambert = max(dot(n, l), 0.0);\n  vec3 diffuse = lambert * light_color;\n\n  // ambient\n  vec3 ambient = ambient_color;\n\n  // specular\n  vec3 v = normalize(camera_pos - p);\n  vec3 h = normalize(l + v);\n  float specular = pow(max(dot(n, h), 0.0), 16.0);\n  vec3 spec = specular * light_color;\n\n  return ambient + diffuse + spec;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    Ray ray = createRay(fragCoord);\n    //creates a color object\n    vec3 color = vec3(0.0);\n    //creates a hit object\n    Hit hit = Hit(1000000.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //checks if the ray hits the sphere\n    if (intersectRaySphere(ray, sphere, hit))\n    {\n        //if it does, it sets the color to the normal of the sphere\n        color = hit.normal;\n    }\n    //sets the color of the fragment\n    fragColor = vec4(color, 1.0);\n}\n", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float shininess = 64.0;\n\n    // raymarch\n    float t = raymarch(ro, rd);\n\n    // if we hit something\n    if (t < MAX_DIST)\n    {\n        // get the position of the hit\n        vec3 pos = ro + rd * t;\n\n        // get the normal of the hit\n        vec3 nor = calcNormal(pos);\n\n        // get the color of the hit\n        vec3 col = vec3(0.0);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 0.0));\n\n        // ambient\n        vec3 ambient = ka * vec3(1.0);\n\n        // diffuse\n        float diff = max(dot(nor, lightDir), 0.0);\n        vec3 diffuse = kd * diff * vec", "\n    return length(p) - rad;\n}\n\n//box\nfloat", "\n    float d = p.y;\n    d = max(d, -p.y - param.y);\n\n    // walls\n    d = max(d, abs(p.x) - param.x);\n    d = max(d, abs(p.z) - param.z);\n\n    return d;\n}\n\n// scene normal\nvec", "\n    float d = min(p.y, -p.y);\n    // walls\n    d = min(d, p.x);\n    d = min(d, -p.x);\n    d = min(d, p.z);\n    d = min(d, -p.z);\n    // sphere\n    d = min(d, length(p - vec3(0.0, 0.0, 0.0)) - param.x);\n    return d;\n}\n\n// scene distance without light gathering\nfloat", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float sh = 10.0;\n\n    // get the normal\n    vec3 n = normal(ro + rd * ti);\n\n    // get the light direction\n    vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n    // get the view direction\n    vec3 v = normalize(-ro);\n\n    // get the reflection direction\n    vec3 r = reflect(l, n);\n\n    // calculate the ambient, diffuse, and specular components\n    float amb = ka;\n    float dif = kd * max(dot(n, l), 0.0);\n    float spe = ks * pow(max(dot(r, v), 0.0), sh);\n\n    // calculate the final color\n    return vec3(amb + dif + spe);\n}\n\nvoid main()\n{\n    // get the ray origin and direction\n    vec3 ro", "\n    p = mat2(0.70710678118654757, -0.70710678118654757, 0.70710678118654757, 0.70710678118654757) * p;\n    p = abs(p);\n    return max(p.x, p.y) - diamond.z;\n}\n\n// 2D rotation matrix.\nmat", "\n    // so that the background is not transformed.\n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.", "\n\tfloat d = sdSphere( pos, 1.0 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 4.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 6.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 8.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 10.0 ), 1.0 ), 0.", "\n\tvec3 light1 = vec3( 1.0, 1.0, 1.0 );\n\tvec3 light2 = vec3( -1.0, 1.0, 1.0 );\n\tvec3 light3 = vec3( 1.0, -1.0, 1.0 );\n\tvec3 light4 = vec3( -1.0, -1.0, 1.0 );\n\tvec3 light5 = vec3( 1.0, 1.0, -1.0 );\n\tvec3 light6 = vec3( -1.0, 1.0, -1.0 );\n\tvec3 light7 = vec3( 1.0, -1.0, -1.0 );\n\tvec3 light8 = vec3( -1.0, -1.0, -1.0 );\n\n\tvec3 ambient = vec3( 0.1, 0.1, 0.1 );\n\tvec3 diffuse = vec3( 0.0, 0.0, ", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269", "\n    // 0.0    0.0000 |     0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float activity = a;\n    //Increase Activity Level For Better Performance\n    float activity2 = a;\n    //Increase Activity Level For Better Performance\n    float activity3 = a;\n    //Increase Activity Level For Better Performance\n    float activity4 = a;\n    //Increase Activity Level For Better Performance\n    float activity5 = a;\n    //Increase Activity Level For Better Performance\n    float activity6 = a;\n    //Increase Activity Level For Better Performance\n    float activity7 = a;\n    //Increase Activity Level For Better Performance\n    float activity8 = a;\n    //Increase Activity Level For Better Performance\n    float activity9 = a;\n    //Increase Activity Level For Better Performance\n    float activity10 = a;\n    //Increase Activity Level For Better Performance\n    float activity11 = a;\n    //Increase Activity Level For Better Performance\n    float activity12 = a;\n    //Increase Activity Level For Better Performance\n    float activity13 = a;\n    //Increase Activity Level For Better Performance\n    float activity14", ".\n    float d = length(p.xy) - r;\n    // How far up or down the point is, along the z-axis.\n    float z = abs(p.z) - h;\n    // Return the smallest distance to the cylinder.\n    return min(max(d, z), 0.0) + length(max(vec2(d, z), 0.0));\n}\n\n/**\n * Signed distance function for a box centered at the origin with the given dimensions.\n */\nfloat", "\n    p.yz *= rotate(iTime * 0.5);\n\n    // Add a sphere\n    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // Add a plane\n    float plane = p.y + 1.0;\n\n    // Add a box\n    float box = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // Add a torus\n    float torus = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a cylinder\n    float cylinder = length(p.xz - vec2(0.0, 2.0)) - 0.5;\n\n    // Add a cone\n    float cone = length(p - vec3(0.0, 0.0, 2.0)) - 1.0;\n\n    // Add a torus knot\n    float knot =", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = snoise(p);\n    n = n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*", "\n    //The only difference is that we are using a biomorph instead of a mandlebrot\n    //The biomorph is defined by the function z^2 + c\n    //Where c is the coordinate of the pixel\n    //z is the current value of the biomorph\n    //The biomorph is iterated until the magnitude of z is greater than 2\n    //or the maximum number of iterations is reached\n    //The color of the pixel is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined", "\n    // The \"w\" parameter is the \"width\" of the pattern.\n    p = mod(p, w);\n\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2", "\n    float r = length(p.xz);\n    float h = p.y;\n    \n    // The bump function.\n    return 1.0 - smoothstep(0.0, 0.01, abs(h) - 0.005 * r);\n}\n\n// The bump mapping function.\nfloat", "\n    //\n    // view_inv: inverse of the view matrix\n    // proj_inv: inverse of the projection matrix\n    // viewp_inv: inverse of the view-projection matrix\n    // scr_pt: screen coordinates of a point\n    //\n    // Returns:\n    //   vec4(0,0,0,0) if scr_pt is outside the viewport\n    //   vec4(0,0,0,1) if scr_pt is inside the viewport\n    //   vec4(x,y,z,1) if scr_pt is inside the viewport\n    //\n    // Note:\n    //   The returned vector is in world coordinates.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized", "\n    rounded = min(rounded, thick.y);\n\n    // Get the distance from the line.\n    float dist = LineDist(uv, pA, pB, thick, rounded);\n\n    // Get the distance from the dash.\n    float dashDist = LineDist(uv, pA, pB, thick, thick.y);\n\n    // If the dash is on, then we want to subtract the dash from the line.\n    // If the dash is off, then we want to add the dash to the line.\n    // This is a simple way to do a subtract or add operation.\n    return dist - dashOn * dashDist;\n}\n\n// This is the same as the above, but it returns a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn", "\n  vec3 lightPos = vec3(0.0, 10.0, 0.0);\n  vec3 lightDir = normalize(lightPos - p);\n  float diffuse = max(dot(n, lightDir), 0.0);\n  vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n  vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n  vec3 diffuseLight = diffuse * diffuseColor;\n  vec3 ambientLight = ambientColor;\n  vec3 light = diffuseLight + ambientLight;\n\n  // ambient occlusion\n  float ao = texture(aoMap, p.xz * 0.01).r;\n  light *= ao;\n\n  return light;\n}\n\n// Ray marching\n// p : ray origin\n// d : ray direction\n// t : distance to intersection\n// n : normal at intersection\n// m : material at intersection\nbool RayMarch(vec3 p, vec3 d", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec", "          ___\n    float y = (x - a) / (b - a);                 //  /     \\      /     \\      /     \\      /     \\\n    y = y - floor(y);                           // /   ___  \\  /   ___  \\  /   ___  \\  /   ___  \\\n    y = y * 2;                                  // | /     \\ | | /     \\ | | /     \\ | | /     \\ |\n    y = y - 1;                                  // |/   ___  \\| |/   ___  \\| |/   ___  \\| |/   ___  \\\n    y = y * y;                                  // | | /     \\ | | | /     \\ | | | /     \\ | | | /     \\ |\n    y = y * y;                                  // | |/   ___  \\| | |/   ___  \\| | |/   ___  \\| | |/   ___  \\\n    y = y * y;                                  // | | | /     \\ | | | | /     \\ | | | | /", "\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float a = rdrd*baba - bard*bard;\n    float b = rdrd*baoa - bard*rdoa;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    float t = (-b - sqrt(h))/a;\n    if( t<0.0 ) return vec4(-1.0);\n    vec3  n = oaoa + t*bard*ba - oa;\n    float d", "\n\n\tvec2 p = P-U;\n\tfloat d = length(p);\n\t\n\tO = vec4(C, smoothstep(r,r-1.,d));\n}\n\nvoid main(void)\n{\n\tvec2 U = gl_FragCoord.xy;\n\tvec2 P = iMouse.xy;\n\t\n\tvec4 O = vec4(0.);\n\t\n\tsphere(O, U, P, 100., vec3(1.));\n\t\n\tgl_FragColor = O;\n}", "\n    p.xz *= rot(iTime * 0.5);\n    p.yz *= rot(iTime * 0.5);\n    p.xy *= rot(iTime * 0.5);\n\n    // add a sphere\n    float d = length(p) - 1.0;\n\n    // add a box\n    d = max(d, -box(p, vec3(0.5)));\n\n    // add a torus\n    d = max(d, -torus(p, vec2(0.5, 0.1)));\n\n    // add a cylinder\n    d = max(d, -cylinder(p, vec2(0.5, 0.1)));\n\n    // add a plane\n    d = max(d, p.y + 0.5);\n\n    return d;\n}\n\n// raymarching\nvec", "\n    float scale = float(N)/float(N-1);\n    float scale2 = scale*scale;\n    float scale3 = scale2*scale;\n    float scale4 = scale3*scale;\n    float scale5 = scale4*scale;\n    float scale6 = scale5*scale;\n    float scale7 = scale6*scale;\n    float scale8 = scale7*scale;\n    float scale9 = scale8*scale;\n    float scale10 = scale9*scale;\n    float scale11 = scale10*scale;\n    float scale12 = scale11*scale;\n    float scale13 = scale12*scale;\n    float scale14 = scale13*scale;\n    float scale15 = scale14*scale;\n    float scale16 = scale15*scale;\n    float scale17 = scale16*scale;\n    float scale18 = scale17*scale;\n    float scale19 = scale18*scale;\n    float scale20 = scale19*scale;\n    float scale21 = scale20*scale", "\n    p.x *= 1.0 + sin(p.y * 10.0) * 0.05;\n    p.y *= 1.0 + sin(p.x * 10.0) * 0.05;\n    \n    // The scale tiles are made of two sets of fans.\n    float fan1 = fan(p, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,", "\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    //", "\n    float flameDistance = length(currentRayPosition - flamePosition) - flameRadius;\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float wallDistance = sdBox(currentRayPosition, vec3(0.0), vec3(1.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float sphereDistance = sdSphere(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float planeDistance = sdPlane(currentRayPosition, vec3(0.0, 1.0, 0.0), vec3(0.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float boxDistance = sdBox(currentRayPosition, vec3(-0.5), vec3(0.5));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float cylinderDistance = sdCylinder(currentRayPosition,", "\n    float sm2 = sm * sm;\n    \n    // Smoothing factor.\n    float sm3 = sm2 * sm;\n    \n    // Fractional part.\n    float fract = x - floor(x);\n    \n    // Smoothing factor.\n    float fract2 = fract * fract;\n    \n    // Smoothing factor.\n    float fract3 = fract2 * fract;\n    \n    // Smoothing factor.\n    float fract4 = fract2 * fract2;\n    \n    // Smoothing factor.\n    float fract5 = fract4 * fract;\n    \n    // Smoothing factor.\n    float fract6 = fract4 * fract2;\n    \n    // Smoothing factor.\n    float fract7 = fract6 * fract2;\n    \n    // Smoothing factor.\n    float fract8 = fract4 * fract4;\n    \n    // Smoothing factor.\n    float fract9 = fract8 * fract;\n    \n    // Smoothing factor.\n    float fract10 = fract8 * fract2;\n    \n    // Smoothing factor.", "\n    //\n    // p = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n\n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n\n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n   ", "\n    float n = snoise(p);\n    \n    // The quantized value.\n    float q = floor(n*10.0)/10.0;\n    \n    // The tapered value.\n    float t = smoothstep(-0.1, 0.1, n);\n    \n    // The final value.\n    return q*t;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel coordinates.\n    vec2 p = gl_FragCoord.xy;\n    \n    // The function value.\n    float f = func(p);\n    \n    // The final color.\n    vec3 c = vec3(f);\n    \n    // The output color.\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n  vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n  \n  // Then we define the radius of the balloon\n  float balloonRadius = 0.5;\n  \n  // Then we define the height of the balloon\n  float balloonHeight = 1.0;\n  \n  // Then we define the balloon color\n  vec3 balloonColor = vec3(1.0, 0.0, 0.0);\n  \n  // Then we define the balloon specular color\n  vec3 balloonSpecularColor = vec3(1.0, 1.0, 1.0);\n  \n  // Then we define the balloon specular power\n  float balloonSpecularPower = 10.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\t// return the intersection t value\n\tif( tN > tF ) return vec4(-1.0);\n\treturn vec4(tN, tF, tN, tF);\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n    \n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n    \n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube", "\n //c=vec3(0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//over", "\n    //Use a counter instead.\n    int i;\n    for(i=0; i<MAX_ITERATIONS; i++){\n        //Calculate the next iteration\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        //Check if the point is outside the circle with radius 2:\n        //(x*x+y*y) > 4\n        if(dot(z,z) > 4.0) break;\n    }\n    return float(i)/float(MAX_ITERATIONS);\n}\n\nvoid main() {\n    //Calculate the complex number for this pixel:\n    vec2 c = vec2(\n        (gl_FragCoord.x/float(width) - 0.5) * 4.0,\n        (gl_FragCoord.y/float(height) - 0.5) * 4.0\n    );\n    //Start the iteration at the origin\n    vec2 z = vec2(", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    //we need to create the translation matrix\n    mat4 translation = mat4(1.0);\n    translation[3] = vec4(-cam, 1.0);\n\n    //we need to create the rotation matrix\n    mat4 rotation = mat4(1.0);\n    rotation[0] = vec4(x, 0.0);\n    rotation[1] = vec4(y, 0.0);\n    rotation[2] = vec4(z, 0.0);\n\n    //we need to create the view matrix\n    return rotation * translation;\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    p = p * 2.0;\n    \n    // Get the integer part of the grid position.\n    vec2 i = floor(p);\n    \n    // Get the fractional part of the grid position.\n    vec2 f = fract(p);\n    \n    // Get the direction of the grid.\n    vec2 dir = vec2(1.0, 0.0);\n    \n    // Rotate the grid.\n    mat2 rot = mat2(dir.x, -dir.y, dir.y, dir.x);\n    \n    // Rotate the fractional part of the grid position.\n    f = rot * f;\n    \n    // Get the distance to the grid.\n    float d = dot(f, f);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n   ", "\n    float t = (x - a) / (b - a);\n    t = clamp(t, 0.0, 1.0);\n    return t;\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float dist = func(xy.x);\n    // if distance is less than 0.001, draw the curve\n    if (dist < 0.001)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold, float scale)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist <", "\n vec2 n=vec2(0.0,1.0);\n vec2 ne=vec2(1.0,1.0);\n vec2 e=vec2(1.0,0.0);\n vec2 se=vec2(1.0,-1.0);\n vec2 s=vec2(0.0,-1.0);\n vec2 sw=vec2(-1.0,-1.0);\n vec2 w=vec2(-1.0,0.0);\n vec2 nw=vec2(-1.0,1.0);\n // get the value of the current pixel\n float c=texture2D(iChannel0,p).x;\n // get the value of the neighbors\n float nv=texture2D(iChannel0,p+n).x;\n float nev=texture2D(iChannel0,p+ne).x;\n float ev=texture2D(iChannel0,p+e).x;\n float sev=texture2D(iChannel0,p+se).x;\n float sv=texture", "\n //f+=.05*sin(p.y*5.);\n //f+=.05*cos(p.x*5.);\n //f+=.05*sin(p.x*5.+p.y*5.);\n //f+=.05*cos(p.x*5.+p.y*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z", ", but it works\n    c.r = c.r*1.05-0.05;\n    c.g = c.g*0.95+0.05;\n    c.b = c.b*1.05-0.05;\n    return c;\n}\n\n//this is a very simple \"color space\" conversion,\n//it's not a true conversion, but it's close enough\n//for our purposes.\nvec", "\n  vec3 d=abs(p)-s;\n  return vec4(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),1.0);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=", "\n    float dist = distScene(pos, depth, steps);\n    int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    Material mat = materials[matrIndex];\n    return Material(matrIndex, mat.color, mat.reflectivity, mat.refractiveIndex, mat.transparency);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float time)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n   ", "\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Tone mapping\nvec", "\n    p.z -= 1.0;\n    \n    // The number of iterations.\n    float n = 1.0;\n    \n    // The radius of the first circle.\n    float r = 1.0;\n    \n    // The radius of the next circle.\n    float r2 = 1.0;\n    \n    // The distance to the next circle.\n    float d = 1.0;\n    \n    // The distance to the next circle.\n    float d2 = 1.0;\n    \n    // The distance to the next circle.\n    float d3 = 1.0;\n    \n    // The distance to the next circle.\n    float d4 = 1.0;\n    \n    // The distance to the next circle.\n    float d5 = 1.0;\n    \n    // The distance to the next circle.\n    float d6 = 1.0;\n    \n    // The distance to the next circle.\n    float d7 = 1.0;\n    \n    // The distance to the next circle.\n    float d8 = 1.0;\n    \n    // The distance to", "\n    float d = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    if (d < 0.0) {\n        return mat(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,", "\n    mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    // initialize the fractal sum\n    float f = 0.0;\n\n    // octaves of noise\n    float amp = 0.5;\n    float freq = 4.0;\n    for ( int i=0; i<5; i++ ) {\n        // rotate the point\n        p = m * p * 2.02;\n\n        // add the noise\n        f += amp * noise( p );\n\n        // scale up the wavelenghts\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n\n    return f;\n}\n\nvoid main() {\n    // get the position of the fragment\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n\n    // get the noise value\n    float n = fbm( p * 10.0 );\n\n    // set the color\n    gl_FragColor = vec4( n, n,", "\n    \n    // The first point is the wrapped cell point.\n    vec2 cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The second point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The third point is the wrapped cell point.\n    cell = floor(p) +", "\n return u.x*m.y-u.y*m.x;\n}\n\n//return __signed distance of [u] to line trough [a] and [b], a and b must be normalized.\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),dot(m,u)<0.);//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//", "\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n", "\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n\tfloat alpha = acos(dot(A, B));\n\tfloat beta = acos(dot(B, C));\n\tfloat gamma = acos(dot(C, A));\n\n\t//calculate area of spherical triangle\n\tfloat area = alpha + beta + gamma - PI;\n\n\t//calculate probability of sampling each triangle\n\tfloat pA = alpha / area;\n\tfloat pB = beta / area;\n\tfloat pC = gamma / area;\n\n\t//sample spherical triangle\n\tfloat r1 = Xi1;\n\tfloat r2 = Xi2;\n\tfloat p = r1 * area;\n\tif (p < pA) {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pA / area;\n\t} else if (p < pA + p", "\n  v2 x;\n  x.x = U.x;\n  x.y = U.y;\n  return x;\n}\n\nv2 main(){\n  v1 a;\n  a.x = 1;\n  a.y = 2;\n  v2 b;\n  b = c(a);\n  return b;\n}\n", "\n    \n    // The tube is a square with a beveled edge.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge", "\n    float w = 0.05;\n\n    // The tube is made of two cylinders.\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0*w) - w;\n    float d = length(q.xz) - w;\n    float d2 = length(p.xz) - 0.95;\n\n    // The bands are made of two cylinders.\n    vec3 q2 = p;\n    q2.xz = mod(q2.xz, 2.0*w) - w;\n    float d3 = length(q2.xz) - 0.02;\n    float d4 = length(p.xz) - 0.97;\n\n    // The bands are made of two cylinders.\n    vec3 q3 = p;\n    q3.xz = mod(q3.xz, 2.0*w) - w;\n    float d5 = length(q3.xz) - 0.04;\n    float d6", "\n    vec3 id = floor(p);\n    \n    // Distance to the grid cell.\n    float d = length(max(abs(p)-gID,0.0));\n    \n    // Blink effect.\n    float blink = sin(iTime*10.0);\n    blink = blink*blink*blink;\n    \n    // Return the distance.\n    return d*blink;\n}\n\n// Distance function for the scene.\nfloat", "\n    float t = 0., d;\n    \n    // Raymarching loop.\n    for(int i = 0; i < 128; i++){\n        \n        // Get the distance to the scene at the current ray position.\n        d = map(o + r * t);\n        \n        // If the distance is less than the minimum distance, return the current ray distance.\n        if(d < EPS){\n            //glow = float(i) / 128.;\n            return t;\n        }\n        \n        // Increment the ray distance.\n        t += d;\n    }\n    \n    // If the ray didn't hit anything, return a large value.\n    return 1000.;\n}\n\n// Calculate the normal at a given point in the scene.\nvec", "\n    const int N = 10;\n    float h = 0.001;\n    float d = 0.0;\n    float s = 0.0;\n    for(int i = 0; i < N; i++){\n        d = sdf(ro + h * lp);\n        s += k * d;\n        h += d;\n    }\n    return clamp(1.0 - s / t, 0.0, 1.0);\n}\n\n// The main function.\nvec", "\n    float e =.0005 * (1.0 / t);\n\n    // Calculate the normal.\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec3 eps = vec3(e,0.0,0.0);\n        eps.xy *= HASH12(p.xy);\n        vec3 v = vec3(\n            map(p+eps.xyy, edge, crv, t),\n            map(p+eps.yxy, edge, crv, t),\n            map(p+eps.yyx, edge, crv, t)\n        );\n        n += v - map(p, edge, crv, t);\n    }\n\n    return normalize(n);\n}\n\n// Calculate the normal, and also the edge and curvature values.\nvec", "\n    vec3 w = vec3(dot(p3, m[0]), dot(p3, m[1]), dot(p3, m[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row,", "\n    vec2 uv = vec2(df_truchet(p, dir), atan(p.y, p.x) / 3.1415926535897932384626433832795);\n    \n    // The Truchet distance field is a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The", "\n    q.x += sin(u_time * 0.5) * 0.05;\n    q.y += cos(u_time * 0.5) * 0.05;\n    \n    // Polar conversion.\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    \n    // The animation.\n    a += u_time * 0.5;\n    \n    // The color.\n    float c = cos(a * 10.0);\n    \n    // The color.\n    float f = smoothstep(0.0, 0.01, abs(r - 0.5 + c * 0.5));\n    \n    // The color.\n    return f;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel.\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    \n    // The color.\n    float f = getPolarCoord(q, 1.0);\n    \n    // The", "\n    vec3 w = vec3(dot(p3, n[0]), dot(p3, n[1]), dot(p3, n[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w.x, w.y, w.z, 1.0 - w.x - w.y - w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", ".\n  if (abs(r.w) < 1e-6 || abs(p.w) < 1e-6) {\n    return 0.0;\n  }\n  // The line is defined by the equation\n  //   r.x + t * (p.x - r.x) / r.w = q.x\n  //   r.y + t * (p.y - r.y) / r.w = q.y\n  //   r.z + t * (p.z - r.z) / r.w = q.z\n  //\n  // We can solve for t by substituting the above\n  // into the equation for the distance squared\n  //   (q.x - r.x)^2 + (q.y - r.y)^2 + (q.z - r.z)^2\n  //   = (p.x - r.x)^2 / r.w^2 + (p.y - r.y)^2 / r.w^2 + (p.z - r.z)^2 / r.w^2\n", "\n    float t = floor(p.x) + floor(p.y);\n    float s = step(1.0, mod(t, 2.0));\n    \n    // The shadow.\n    float sh = s;\n    \n    // The line width.\n    float lW2 = lW * 0.5;\n    \n    // The line width.\n    float lW4 = lW2 * 0.5;\n    \n    // The line width.\n    float lW8 = lW4 * 0.5;\n    \n    // The line width.\n    float lW16 = lW8 * 0.5;\n    \n    // The line width.\n    float lW32 = lW16 * 0.5;\n    \n    // The line width.\n    float lW64 = lW32 * 0.5;\n    \n    // The line width.\n    float lW128 = lW64 * 0.5;\n    \n    // The line width.\n    float lW256 = lW1", "\n\tvec2 w = max(abs(ddx), abs(ddy));\n\t// analytical integral (box filter)\n\tvec2 i = 2.0*(p*p + (w*w - 0.25))/w;\n\t// x(t) = (i0 + 0.5*i1)*t + 0.5*(i0 - i1)\n\treturn (i.x + i.y)*0.5 + 0.5*(i.y - i.x);\n}\n\n// grid ratio\nfloat", "\n    mr = floor(n) + vec2(0.5);\n    // take half-cell position\n    mg = floor(f) + vec2(0.5);\n    // take cell corners\n    vec2 m[4];\n    m[0] = mr;\n    m[1] = mr + vec2(1.0, 0.0);\n    m[2] = mr + vec2(0.0, 1.0);\n    m[3] = mr + vec2(1.0, 1.0);\n    // find closest corner\n    float d = dot(m[0] - n, m[0] - n);\n    float d2 = dot(m[1] - n, m[1] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[1];\n    }\n    d2 = dot(m[2] - n, m[2] - n);\n    if (d2 < d) {\n        d = d2;\n        m", "\n    vec2 pos = vec2(0.0);\n    if(t < 0.0){\n        pos = vec2(0.0);\n    }else if(t < 0.25){\n        pos = vec2(0.0, 0.5);\n    }else if(t < 0.5){\n        pos = vec2(0.5, 0.5);\n    }else if(t < 0.75){\n        pos = vec2(0.5, 0.0);\n    }else if(t < 1.0){\n        pos = vec2(0.0, 0.0);\n    }\n    return pos;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    //\n    // 1 out, 2 in...\n    //\n    // vec3 p3 = fract(vec3(p.xyx) *.1031);\n    // p3 += dot(p3, p3.yzx + 33.33);\n    // return fract((p3.xx+p3.yz)*p3.zy);\n\n    // 2 out, 2 in...\n    //\n    // const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n    //                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n    //                    -0.577350269189626,  // -1.0 + 2.0 * C.x\n    //                     0.024390243902439); // 1.0 /", "\n    //\n    // float n = sin(p.x) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // n += sin(p.y) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // return n;\n\n    // This is a pretty standard 2D hash, but it's a bit slower than the one above,\n    // so if you're in a hurry, and framerate is not a huge issue for you, go with\n    // this one.\n    float n = p.x * 17.0 + p.y * 23.0;\n    return fract(sin(n) * 43758.5453123);\n}\n\n// vec3 to float hash.\nfloat", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n    \n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n    \n    // Incenter.\n    return (a * p0 + b * p1 + c * p2) / (a + b + c);\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can be drawn around a triangle.\nvec", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float A = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Radius of the incircle.\n    return A / s;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat", "\n   // The projection is a plane in 3D space.\n   // The plane is defined by three points.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is", "\n    vec2 v0, v1, v2, v3, v4, v5, v6, v7;\n    \n    // The first step is to find the cell that the point is in.\n    // We do this by finding the cell that contains the point, and then iterating through the cell's neighbors\n    // until we find a quadrilateral.\n    //\n    // The cell that contains the point is the cell that contains the point's x and y coordinates.\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //set background color\n    vec3 col = vec3(0.0);\n\n    //set up camera\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    //set up ray\n    vec3 rayOrigin = camPos;\n    vec3 rayDir = normalize(camRight * uv.x + camUp * uv.y + camDir);\n\n    //set up sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 1.0);\n    float sphere", "\n    //p = fract(p * vec2(233.34, 851.73));\n    //p += dot(p, p + 23.45);\n    \n    // I like this one best.\n    p = p*p*157.139 + p*137.549;\n    return fract((p + vec2(233.34, 851.73))*p);\n    \n    // Another nice one from IQ\n    //p = p*p*p*p*521.0 + p*p*p*196.0 + p*p*39.346 + p*78.253;\n    //return fract(p);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    //////////////////////////////////////////////////////////////////", "\n    // Find whether the hit point is in shadow or not.\n    // If there is no intersection, return the background color.\n    // If there is intersection, return the color.\n    /////////////////////////////////////////////////////////////////////////////\n    // \u627e\u5230\u5149\u7ebf\u662f\u5426\u4e0e\u67d0\u4e9b\u7269\u4f53\u76f8\u4ea4\u3002\n    // \u627e\u5230\u6700\u8fd1\u7684\u4ea4\u70b9\u3002\n    // \u627e\u5230\u4ea4\u70b9\u662f\u5426\u5728\u9634\u5f71\u4e2d\u3002\n    // \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\u3002\n    // \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u989c\u8272\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    hasHit = false;\n    float tmin = 1e10;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        if (objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp)) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p20 = p0 - p2;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // angles\n    float a01 = atan(p01.y, p01.x);\n    float a12 = atan(p12.y, p12.x);\n    float a20 = atan(p20.y, p20.x);\n\n    // min/max angles\n    float amin = min(a01, min(a12, a20));\n    float amax = max(a01, max(a12, a20));\n\n    // min/max distances\n    float dmin = min(d01, min(d12, d20));\n    float dmax = max(d01, max(", "\n    vec3 pmin = min( min( p0, p1 ), min( p2, p3 ) );\n    vec3 pmax = max( max( p0, p1 ), max( p2, p3 ) );\n\n    // control points\n    vec3 c0 = ( p0 + p1 ) * 0.5;\n    vec3 c1 = ( p1 + p2 ) * 0.5;\n    vec3 c2 = ( p2 + p3 ) * 0.5;\n    vec3 c3 = ( c0 + c1 ) * 0.5;\n    vec3 c4 = ( c1 + c2 ) * 0.5;\n    vec3 c5 = ( c3 + c4 ) * 0.5;\n\n    // control points\n    vec3 c6 = ( c0 + c3 ) * 0.5;\n    vec3 c7 = ( c3 + c5 ) * 0.5;\n    vec3 c8 = ( c5 + c6 ) * 0.5;\n", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TWO_PI = 6.283185307179586476925286766559;\n    const float HALF_PI = 1.5707963267948966192313216916398;\n    const float INV_PI = 0.31830988618379067153776752674503;\n    const float INV_TWO_PI = 0.15915494309189533576888378337251;\n    const float INV_HALF_PI = 0.636619772367581343075535", "\n    return 0.5 * ( 1.0 - cos( k * PI ) ); // EaseInOut\n}\n\n/**\n * Linear Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    // i1.x = step( x0.y, x0.x ); // x0.x > x0.y", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    coord -= res/2.0;\n\n    // Scale the coordinate so that the julia set is in the [-2;-2] - [2;2] space.\n    coord *= 4.0/res.x;\n\n    return coord;\n}\n\n// Calculate the distance from the origin to the point (x;y).\nfloat", "\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Higher quality, more disperse, but slower.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D simplex noise.\n//\n// Should match the noise function in the noise module.\nfloat", "\n    const float eps = 0.0005;\n    const vec2 h = vec2(eps,0);\n    return normalize( p - vec3(\n        map(p-h.xyy).x,\n        map(p-h.yxy).x,\n        map(p-h.yyx).x ) );\n}\n\n// Tetrahedral distance function.\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float angle = width * 2. * PI;\n    float r = radius * cos(angle);\n    float h = radius * sin(angle);\n    float d = sqrt(r*r + h*h);\n    float a = atan(h, r);\n    float b = atan(h, d-r);\n    float c = atan(h, d);\n    float d1 = a - b;\n    float d2 = c - b;\n    float d3 = c - a;\n    float d4 = b - a;\n    float d5 = c - a;\n    float d6 = c - b;\n    float d7 = b - a;\n    float d8 = c - b;\n    float d9 = a - b;\n    float d10 = c - a;\n    float d11 = b - a;\n    float d12 = c - b;\n    float d13 = a - b;\n    float d14 = c - a;\n    float d15 = b - a;\n    float d16 = c - b", "\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do", "\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t\n\t// camera\n\tvec3 camPos = vec3(0.0, 0.0, 2.0);\n\tvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n\t\n\t// ray\n\tvec3 rayDir = normalize(camDir + uv.x*camRight + uv.y*camUp);\n\t\n\t// sphere\n\tvec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n\tfloat sphereRadius = 1.0;\n\t\n\t// ray-sphere intersection\n\tvec3 oc = camPos - sphereCenter;\n\tfloat a = dot(", "\n    vec3 s = vec3(7, 157, 113);\n\n    // Integer part, floor(p), then mod 289.\n    vec3 i = floor(mod(p, 289.0));\n\n    // Fractional part, after the decimal point.\n    vec3 f = fract(p);\n\n    // This is the first part of the hash.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // This is the second part of the hash.\n    return mix(mix(mix( dot( s, i + vec3(0.0, 0.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 0.0, 0.0) ), u.x),\n                   mix( dot( s, i + vec3(0.0, 1.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 1.0, 0.0) ),", "\n\tsp = log_spherical(p);\n\n\t// Apply the tiling\n\ttp = tiling(sp);\n\n\t// Apply the rotation\n\trp = rotation(tp);\n\n\t// Compute the scaling factor\n\tmul = scaling(rp);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d, out float d1, out float d2)\n{\n\t// Compute the log-spherical distance\n\td", "\n    float y = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float r = cos(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d = length(p-vec3(0.0,y,0.0))-r;\n    \n    //distance to plane = distance to plane minus height\n    float h = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d2 = p.y-h;\n    \n    //return the minimum of the two distances\n    return vec2(min(d,d2),0.0);\n}\n\n//the normal function returns the normal at a point\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\t// T to R\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), aaSize);\n\t// R to B\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), aaSize);\n\t// B to L\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0), aaSize);\n\n\t// L to R\n\tret += drawSquare(p, vec2(0.0, 0.0),", "\n    mat3 rot = getRotationMatrix(boxRotation);\n\n    // rotate the position\n    pos = rot * pos;\n\n    // get the distance to the box\n    float dist = length(max(abs(pos) - boxSize, 0.0));\n\n    // return the distance and the material ID\n    return vec2(dist, boxMaterial);\n}\n\n// returns the distance to our sphere and the its associated material ID packed into a vec2\nvec", "\n    float y = sin(pos.x * 0.5 + time * 0.5) * 0.5 + 0.5;\n\n    // return the distance to the sphere and the material ID\n    return vec2(length(pos - vec3(0.0, y, 0.0)) - 0.5, 0.0);\n}\n\n// returns the distance to the ground plane\nfloat", "\n    vec2 s1 = sdSphere(pos, vec3(0.0, 0.0, 0.0), 1.0);\n    vec2 s2 = sdBox(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec2 s3 = sdCylinder(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s4 = sdCone(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s5 = sdPlane(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec2 s6 = sdTriangle(pos, vec3(0.0, 0.0, 0", "\n    vec3 rayDir = normalize(camDir + (fragCoord.x * u_camRight) + (fragCoord.y * u_camUp));\n    \n    // march the ray through the scene\n    vec4 color = march(camPos, rayDir);\n    \n    // apply lighting\n    color.rgb *= (0.5 + dot(lightDir, rayDir) * 0.5);\n    \n    return color;\n}\n\nvoid main() {\n    \n    // calculate the camera position and direction\n    vec3 camPos = u_camPos;\n    vec3 camDir = normalize(u_camDir);\n    \n    // calculate the direction of the light\n    vec3 lightDir = normalize(u_lightDir);\n    \n    // raymarch the scene\n    vec4 color = marchScene(v_fragCoord, camPos, camDir, lightDir);\n    \n    // output the color\n    gl_FragColor = color;\n}\n", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n//https://www.shadertoy.com/view/XsXXD1\nfloat", "\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\t// ray direction\n\tvec3 rayDir = normalize(vec3(uv, 1.0));\n\n\t// ray origin\n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\n\t// ray marching\n\tfloat t = 0.0;\n\tfloat maxDist = 100.0;\n\tfloat minDist = 0.001;\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\tvec3 color = vec3(0.0);\n\tfloat specular = 0.0;\n\tfloat shadow = 1.0;\n\tfloat shadowDist;\n\tvec3 shadowRayOrigin;\n\tvec3 shadowRayDir;\n\tvec3 shadowPos;\n\tvec3 shadowNormal;\n\tfloat shadowT;\n\tfloat shadowMaxDist;\n\tfloat shadowMinDist;\n\tfloat shadowDist;\n\tvec3 shadowColor = vec3(0.0);\n", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", " cell\n    ivec3 g = ix >> uvec3(1,1,1);\n    // grid cell offset\n    vec3 gf = fract(fx);\n    // grid cell corners\n    vec3 g000 = vec3(g.x, g.y, g.z);\n    vec3 g100 = vec3(g.x+1, g.y, g.z);\n    vec3 g010 = vec3(g.x, g.y+1, g.z);\n    vec3 g110 = vec3(g.x+1, g.y+1, g.z);\n    vec3 g001 = vec3(g.x, g.y, g.z+1);\n    vec3 g101 = vec3(g.x+1, g.y, g.z+1);\n    vec3 g011 = vec3(g.x, g.y+1, g.z+1);\n    vec3 g111 = ve", "\n    // and integer octaves\n    int period = 100;\n    int lacunarity = 2;\n    int octaves = 5;\n    float h = 0.0;\n    float g = -0.7;\n    float f = 0.5;\n    float a = 0.5;\n    float t = 1.0;\n    for(int i = 0; i < octaves; i++){\n        h += a * noise(fxyz);\n        fxyz = f * fxyz;\n        a *= g;\n        t *= lacunarity;\n    }\n    return h;\n}\n\nvoid main() {\n    // get the position of the current pixel\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    // get the position of the current pixel in the world\n    vec3 pos = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos2 = vec3(uv * ", "\n    p.y -= h * 0.5;\n\n    // Capsule\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h*0.5);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),", "\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n\n  // Compute the normal by taking the gradient of the distance function\n  vec3 n = vec3(\n    distance_function(p + eps.xyy) - distance_function(p - eps.xyy),\n    distance_function(p + eps.yxy) - distance_function(p - eps.yxy),\n    distance_function(p + eps.yyx) - distance_function(p - eps.yyx)\n  );\n\n  return normalize(n);\n}\n\n// Compute the color of a point on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float a = dot(rd,rd);\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - ra*ra;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float t1 = (-b-d)/a;\n    float t2 = (-b+d)/a;\n    if( t1>t2 ) { float tmp=t1; t1=t2; t2=tmp; }\n    if( t1<0.0 ) t1 = t2;\n    if( t1<0.0 ) return -1.0;\n    return t1;\n}\n\n// -----------------------------\n// sphere\n// -----------------------------\nfloat", "\n    vec2 w = abs(dpdx) + abs(dpdy);\n    // analytic 2D gradient\n    vec2 g = vec2(dpdy.x*p.x - dpdx.x*p.y, dpdy.y*p.x - dpdx.y*p.y);\n    // range in [-w,w]\n    g = clamp(g,-w,w);\n    // range in [0,1]\n    g = (g + w) / (2.0*w);\n    // range in [-1,1]\n    g = g * 2.0 - 1.0;\n    // range in [0,1]\n    g = (g + 1.0) / 2.0;\n    // range in [0,1] again\n    g = smoothstep(0.0,1.0,g);\n    // return 1D gradient\n    return g.x*g.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.ht", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -2.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 2.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sp", "\n    // Compute the intersection between the ray and the sphere.\n    // If there is an intersection, return true and output the value of t,\n    // the position of the intersection and the normal vector at the intersection.\n    // Otherwise, return false.\n    //\n    // Hint: You can use the quadratic equation to solve the intersection.\n    //\n    // Hint: You can use the following functions:\n    //       dot(vec3 a, vec3 b)\n    //       length(vec3 v)\n    //       normalize(vec3 v)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint: You can use the following operators:\n    //       + - * /\n    //\n    // Hint: You can use the following functions:\n    //       pow(float x, float y)\n    //       sqrt(float", "\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float", "\n    hasHit = false;\n    float tmin = INFINITY;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        bool hit = objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp);\n        if (hit) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;\n            k_rg = k_rg_temp;\n        }\n    }\n\n    // If there was no intersection, return background color\n    if (!hasHit) {\n        return backgroundColor;\n    }\n\n    // Compute color using Phong Lighting Model\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < numLights; i++) {\n        // Compute the color from", "\n    float tp = (0.5-ro.y)/rd.y; if( tp>0.0 ) mint = max( mint, tp );\n    float tm = (1.5-ro.y)/rd.y; if( tm>0.0 ) tmax = min( tmax, tm );\n    if( mint>tmax ) return 1.0;\n\n    // raymarch loop\n    float res = 1.0;\n    for( int i=ZERO; i<NUM_STEPS; i++ )\n    {\n        float h = map( ro + rd*mint );\n        res = min( res, 8.0*h/mint );\n        mint += clamp( h, 0.02, 0.1 );\n        if( mint>tmax ) break;\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid main()\n{\n    vec3 pos = position;\n    vec3 normal = normalize(normalMatrix * normal);\n    vec3 tangent = normalize(normalMatrix * tangent);\n    vec3 bitangent = normalize(normalMatrix * bitangent);\n    \n    vec3 view", "\n    vec3 camera_pos = start + dir * planet_radius;\n\n    // calculate the rayleigh and mie scattering\n    vec3 rayleigh_scattering = beta_ray * exp(-beta_absorption * height_ray);\n    vec3 mie_scattering = beta_mie * exp(-beta_absorption * height_mie);\n\n    // calculate the primary ray\n    vec3 primary_ray = primary_ray_trace(\n        camera_pos, \n        dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_absorption, \n        height_absorption, \n        absorption_falloff, \n        steps_i\n    );\n\n    // calculate the light ray\n    vec3 light_ray = light_ray_trace(\n        camera_pos, \n        light_dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_abs", "\n    vec3 bent_normal = normalize(mix(surface_normal, light_dir, 0.5));\n\n    // sample the atmosphere\n    vec3 sample_col = sample_atmosphere(sample_pos, bent_normal);\n\n    // mix the sample with the background color\n    return mix(sample_col, background_col, 0.5);\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the ray origin and direction, the current time, and the background color.\n\nIt returns the color of the planet at the given ray.\n*/\nvec", "\n    vec4 color = vec4(0.0);\n    \n    // the distance to the surface\n    float dist = 0.0;\n    \n    // the raymarching step\n    float step = 0.0;\n    \n    // the raymarching distance\n    float march = 0.0;\n    \n    // the raymarching distance\n    float march_dist = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_", " and position\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(fragCoord.x - 0.5 * iResolution.x, fragCoord.y - 0.5 * iResolution.y, 1.0));\n    \n    // get the light direction\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    // draw the atmosphere\n    fragColor = drawAtmosphere(camPos, camDir, lightDir);\n}\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b * b - c;\n    if (discr < 0.0) return -1.0;\n    else return b - sqrt(discr);\n}\n\n//-----------------------------------------------------------------------\nfloat", "ialize the ray\n    vec3 rayPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    //initialize the color\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    //initialize the distance\n    float distance = 0.0;\n\n    //initialize the material\n    Material material;\n\n    //initialize the hit\n    bool hit = false;\n\n    //initialize the normal\n    vec3 normal;\n\n    //initialize the hit position\n    vec3 hitPos;\n\n    //initialize the hit normal\n    vec3 hitNormal;\n\n    //initialize the hit material\n    Material hitMaterial;\n\n    //initialize the hit distance\n    float hitDistance;\n\n    //initialize the hit object\n    int hitObject;\n\n    //initialize the hit object index\n    int hitObjectIndex;\n\n    //initialize the hit object index\n    int hitObjectIndex2;\n\n    //initialize the hit object index\n    int hitObjectIndex3", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", " ray\n    RayQueue ray_queue = RayQueue(ray_origin, ray_target);\n\n    // Initialize the sample color\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the number of reflections and refractions\n    int num_reflections = 0;\n    int num_refractions = 0;\n\n    // Initialize the number of bounces\n    int num_bounces = 0;\n\n    // Initialize the number of samples\n    int num_samples = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std = 0;\n", "\n    vec2 id = floor(p);\n    vec2 pos = p - id;\n    \n    // Local cell color ID.\n    float cid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 color = vec3(0.0);\n    \n    // Local cell color ID.\n    float nid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 ncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    //", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance to sphere\n    return length(p - sphere_pos) - sphere_radius;\n}\n\n// Get normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // calculate the hash\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0 );\n    FAST32_hash_3D( Pi + vec3(1.0, 0.0, 0.0), hashx1, hashy1, hashz1 );\n\n    // calculate the gradients\n    vec4 gradx0 = hashx0 - 0.49999;\n    vec4 grady0 = hashy0 - 0.49999;\n    vec4 gradz0 = hashz0 - 0.49999;\n    vec4 gradx1 = hashx1 - 0.49999;\n    vec4 grady1 = hashy1 - 0.49999;\n    vec4 gradz1 =", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    // hash lookup\n    float a = hash(i);\n    float b = hash(i + 1.0);\n\n    // interpolate\n    return lerp(a, b, u);\n}\n\n// 2D noise\nfloat", "\n    float d = p.y + 1.0;\n    float id = 1.0;\n\n    // sphere\n    vec3 q = p - vec3(0.0, 1.0, 0.0);\n    float r = 0.5;\n    float d2 = length(q) - r;\n    if (d2 < d)\n    {\n        d = d2;\n        id = 2.0;\n    }\n\n    return vec2(d, id);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n\n    // add a sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n    d = opU(d, sd);\n\n    // add a box\n    sd = sdBox(p, vec3(0.5));\n    d = opU(d, sd);\n\n    return vec2(d, 0.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n\tvec2 st = fragCoord/iResolution.xy;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = distance(st,vec2(0.5));\n\t\n\tfloat r = d*10.0;\n\t\n\tfloat f = sin(r);\n\t\n\tcolor = vec3(f);\n\t\n\tfragColor = vec4(color,1.0);\n}", "\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Pointed top hexagons.\n    p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.", "\n    return (sin(ix*1600)*1376+sin(iy*1600)*1376+sin(ix*1600+iy*1600)*1376)/3000;\n}\n\nfloat", "\n    p = rotate(p, vec3(0.0, 0.0, 1.0), 0.5*iTime);\n\n    // solve the quadratic polynomial\n    float a = dot(p, p);\n    float b = dot(p, p*p);\n    float c = dot(p, p*p*p);\n    float d = dot(p, p*p*p*p);\n\n    // get the solutions\n    float s1 = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*a);\n    float s2 = (-b - sqrt(b*b - 4.0*a*c)) / (2.0*a);\n\n    // get the colors\n    vec3 c1 = getColor(s1);\n    vec3 c2 = getColor(s2);\n\n    // mix the colors\n    return mix(c1, c2, 0.5);\n}\n\n//------------------------------------------------------------------\n// main\n//------------------------------------------------------------------\nvoid main()\n{\n    // get the ray direction", "\n    p *= 10.0;\n\n    // add a few elements\n    float e1 = sdBox(p, vec3(1.0, 1.0, 1.0));\n    float e2 = sdBox(p + vec3(2.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e3 = sdBox(p + vec3(4.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e4 = sdBox(p + vec3(6.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e5 = sdBox(p + vec3(8.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // combine elements\n    float d = min(e1,", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* calculate dot products */\n\t vec4 p1 = permute(permute(permute(s.z) + s.y) + s.x);\n\t vec4 p2 = permute(permute(permute(s", "\n    float t = mod(iTime, 25.0);\n    float t1 = t;\n    float t2 = t + 12.5;\n    float t3 = t + 25.0;\n    float t4 = t + 37.5;\n    float t5 = t + 50.0;\n    float t6 = t + 62.5;\n    float t7 = t + 75.0;\n    float t8 = t + 87.5;\n    float t9 = t + 100.0;\n    float t10 = t + 112.5;\n    float t11 = t + 125.0;\n    float t12 = t + 137.5;\n    float t13 = t + 150.0;\n    float t14 = t + 162.5;\n    float t15 = t + 175.0;\n    float t16 = t + 187.5;\n    float t17 = t + 200.0;\n    float t18 =", " in the scene\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n", "\n    float k = floor(rp.x*.5)*.5;\n    float d = sdBox(rp-vec3(k,0,0),vec3(.25,.5,.25));\n    return d;\n}\n\n// The normal of the surface at point p\nvec", "\n\treturn max(0.0, min(1.0, (end - d) / (end - start)));\n}\n\nvoid main() {\n\tvec3 color = texture(tex, texCoord).rgb;\n\tfloat fog = linearFog(gl_FragCoord.z, 0.0, 100.0);\n\tcolor = mix(color, fogColor, fog);\n\toutColor = vec4(color, 1.0);\n}\n", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons centered at \n    // (0,0), and the second row centered at (0,1), etc.\n    hex.xy = floor(p);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure", "\n    float r = rand(floor(p));\n    \n    // The distance to the center of the cell.\n    float d = length(p);\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d2 = length(p + vec2(r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d3 = length(p + vec2(r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d4 = length(p + vec2(-r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d5 = length(p + vec2(-r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d6 = length(p + vec2(r, 0.0));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d7 =", "\n    float scale = iMouse.x / iResolution.x;\n\n    // Set color according to scale.\n    // If scale is 0.0, color is red.\n    // If scale is 1.0, color is blue.\n    // If scale is 0.5, color is green.\n    // If scale is 0.25, color is yellow.\n    // If scale is 0.75, color is purple.\n    // If scale is 0.125, color is orange.\n    // If scale is 0.875, color is cyan.\n    // If scale is 0.375, color is magenta.\n    // If scale is 0.625, color is brown.\n    // If scale is 0.1875, color is pink.\n    // If scale is 0.8125, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.", "\n    float theta = atan(pc.y, pc.x);\n    float r = length(pc);\n    float theta_spiral = atan(b*theta, a+b*theta);\n    \n    //If the polar coordinate is on the spiral, return theta.\n    //If not, return -1.0\n    if(abs(theta_spiral - theta) < 0.0001){\n        return theta;\n    }else{\n        return -1.0;\n    }\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//Given a polar coordinate (r, theta), return the cartesian coordinate (x, y)\nvec", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Plot a line\n  color = vec3(plot(st,0.5));\n\n  gl_FragColor = vec4(color,1.0);\n}\n", "\n    //\n    // The following is a diagram of the initial circular domain.\n    //\n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // ", "\n    float a = atan(p.y, p.x);\n    float ia = floor(a / (2.0 * PI) +.5);\n    a -= ia * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float r = length(p);\n    float ir = floor(r / circ.z +.5);\n    r -= ir * circ.z;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float b = atan(p.y,", "\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Invert mouse coordinates.\n    m = (m - 0.5) * 2.0;\n    \n    // Invert mouse coordinates.\n    m.y *= -1.0;\n    \n    // Return inverted mouse coordinates.\n    return m;\n}\n\n// Mouse pointer inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, ", "\n\tvec3 camPos = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 camUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 camSide = normalize(cross(camDir, camUp));\n\t\n\t// Camera\n\tvec3 rayDir = normalize(camSide * (fragCoord.x - iResolution.x * 0.5) + camUp * (fragCoord.y - iResolution.y * 0.5) + camDir * 1.0);\n\t\n\t// Raymarch\n\tvec3 rayPos = camPos;\n\tfloat dist = 0.0;\n\tfloat totalDist = 0.0;\n\tfloat t = 0.0;\n\tfloat tMax = 100.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tdist = map(rayPos);\n\t\ttotal", "\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI);\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n", "\n    vec3 cube = mod(floor(hash * 6.0), 2.0) * 2.0 - 1.0;\n    \n    // Random vertex of a rhombic dodecahedron\n    float cb = (cube.x + cube.y + cube.z) / 3.0;\n    float cr = (cube.x + cube.y) / 2.0;\n    float cs = (cube.x + cube.z) / 2.0;\n    float ct = (cube.y + cube.z) / 2.0;\n    vec3 rhomb = vec3(cr + cb, ct + cb, cs + cb);\n    \n    // Expand outwards\n    float scale = 1.0 / (sqrt(3.0) * (abs(rhomb.x) + abs(rhomb.y) + abs(rhomb.z)));\n    return rhomb * scale;\n}\n\n// 2D simplex noise\nfloat", "\n    // This is a bit of a hack, but it's the only way to get a triangular\n    // alignment.\n    X.yz = X.yz * mat2(0.866025404, -0.5, 0.5, 0.866025404);\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.", "\n  float d = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the YZ plane\n  float d2 = length(p.yz) - 0.5;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ", "\n    // \ub9cc\uc57d \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \uc815\ud655\ud55c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub530\ub77c\uc11c \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \ufffd", "\n\tmat2 rot = mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n\t\n\t// Get the pixel coordinates\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\t\n\t// Rotate the pixel coordinates\n\tuv = rot * uv;\n\t\n\t// Get the distance from the center\n\tfloat dist = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist2 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle2 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist3 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle3 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist4 = length(uv);\n\t\n\t// Get the", "\n    vec4 s = vec4(p, 0.0);\n    s.y -= 0.5;\n    s.y = pModPolar(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, ", "\n    vec3 targetDir = normalize( targetPos - ray.origin );\n    float targetDist = length( targetPos - ray.origin );\n    float targetAngle = dot( targetDir, ray.direction );\n    float targetAngle2 = targetAngle * targetAngle;\n    float targetAngle3 = targetAngle2 * targetAngle;\n    float targetAngle4 = targetAngle2 * targetAngle2;\n    float targetAngle5 = targetAngle3 * targetAngle2;\n    float targetAngle6 = targetAngle3 * targetAngle3;\n    float targetAngle7 = targetAngle4 * targetAngle3;\n    float targetAngle8 = targetAngle4 * targetAngle4;\n    float targetAngle9 = targetAngle5 * targetAngle4;\n    float targetAngle10 = targetAngle5 * targetAngle5;\n    float targetAngle11 = targetAngle6 * targetAngle5;\n    float targetAngle12 = targetAngle6 * targetAngle6;\n    float targetAngle13 =", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    // noise\n    return mix(\n        hash(i),\n        hash(i + 1.0),\n        u\n    );\n}\n\n// 2D noise\nfloat", "\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n    \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en", "\n    float n = log(start_radius/uv.x)/log(1.5);\n    return int(n);\n}\n\n//Find the hexagon a point is in\nvec", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = 1.0;\n    float U1 = U.x;\n    while (U1 > L) {\n        k += 1.0;\n        p *= (d / k);\n        U1 *= U.y;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "'s work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // time\n    float t = iTime;\n\n    // color\n    vec3 col = vec3(0.0);\n\n    // loop\n    for (float i = 0.0; i < 10.0; i++) {\n        // position\n        vec2 pos = vec2(sin(t * 0.1 + i * 0.1), cos(t * 0.1 + i * 0.1)) * 0.5;\n\n        // distance\n        float d = length(uv - pos);\n\n        // color\n        col += vec3(1.0 / d);\n    }\n\n    // output\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n  float epsilon = 0.0001;\n  // Compute normal using central differences method\n  vec3 normal = vec3(\n    calcD(pos, epsilon, 0),\n    calcD(pos, 0, epsilon),\n    calcD(pos, epsilon, epsilon)\n  );\n  return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n  float t = castRay(ro, rd);\n  if (t < 0.0) {\n    return vec3(0.0, 0.0, 0.0);\n  }\n  vec3 pos = ro + rd * t;\n  vec3 normal = calcNormal(pos);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  if (t < tmin) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (t < tmax) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else {\n    color = vec3(0.0, 0.0, 0.0);\n  }\n  return color;\n}\n\nvoid main() {\n  // camera\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 rd = normalize(vec3(vUv.", "\n    float epsilon = 0.0001;\n    // Compute normal using central differences method\n    vec3 normal = vec3(\n        calcD(pos, epsilon, 0),\n        calcD(pos, 0, epsilon),\n        calcD(pos, epsilon, epsilon)\n    );\n    return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    float t = castRay(ro, rd);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // get position and normal at hit point\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // get material color at hit point\n    vec3 col = getMaterialColor(pos);\n\n    // calculate lighting\n    float occ = calcAO(pos, nor);\n    vec3 lig = calcLighting(pos, nor, col, occ);\n\n    // calculate fog\n    float fogAmount = calcFog(t);\n    vec3 fogCol = vec3(0.5, 0.6, 0.7);\n    vec3 colFog = mix(col, fogCol, fogAmount);\n\n    // calculate reflections\n    vec3 ref = reflect(rd, nor);\n    vec3 refCol = render(pos + nor * 0.001, ref);\n\n", "\n    vec3 s = vec3(0.0);\n    for (int i=ZERO; i<8; i++) {\n        float j = float(i);\n        vec2 e = vec2(cos(j), sin(j))*0.02;\n        s += vec3(0.5 + 0.5*dot(e, e));\n    }\n    s = s*s*(3.0 - 2.0*s);\n\n    //normal\n    vec2 e = vec2(1.0, 0.0)*0.001;\n    vec3 n = sdf(p + e.xyy) - sdf(p - e.xyy);\n    n.x = sdf(p + e.yxy) - sdf(p - e.yxy);\n    n.y = sdf(p + e.yyx) - sdf(p - e.yyx);\n    return normalize(n);\n}\n\n/**\n * Raymarching using the gradient of the SDF.\n */\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat", "els\n\tvec2 texel = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16", "\n    p = abs(p);\n\n    // normalize\n    float a = ab.x;\n    float b = ab.y;\n    float r = a / b;\n    p *= r;\n\n    // project\n    float l = length(p);\n    float m = l*l/(a*a+b*b);\n    vec2 n = m*p;\n\n    // distance\n    float d = l*sqrt(m*m+1.0-m);\n\n    // gradient\n    vec3 g;\n    g.x = d;\n    g.yz = n;\n\n    return g;\n}\n\n// signed distance to ellipse\nfloat", "\n    vec3 q = vec3(dot(vec2(1.0, 1.0), vec2(p, p + iGlobalTime)),\n                  dot(vec2(7.0, 13.0), vec2(p, p + 1.0)),\n                  dot(vec2(17.0, 19.0), vec2(p, p + 2.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Plot a line\n    float y = plot(uv, vec2(0.4, 0.6));\n    col = vec3(y);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float dist = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    // Calculate the Rotation Matrix\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy, cx*cz + sx*sy*sz, cx*sz - cy*sx*sz,\n        -sy, cy*sx + sy*sz*cx, cy*cx - sx*sy*sz\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    rayori = rayori - camera;\n    // Raymarching\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // Get the distance to the nearest object\n        d = map(rayori + raydir * t);\n        // If we are close enough to the object, break\n        if(d < MIN_DIST){\n            break;\n        }\n        // Move the ray forward\n        t += d;\n        // If we are too far away, break\n        if(t > MAX_DIST){\n            break;\n        }\n    }\n    // Get the normal of the object\n    vec3 normal = getNormal(rayori + raydir * t);\n    // Get the color of the object\n    vec3 color = getColor(rayori + raydir * t);\n    // Get the light direction\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    // Get the ambient light\n    float ambient = 0", "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Distance of the Ray\n    float rayDist = rayMarch(rayPos, rayDir);\n    // Calculate the Position of the Ray\n    vec3 rayPos2 = rayPos + rayDist * rayDir;\n    // Calculate the Normal of the Ray\n    vec3 rayNorm = calcNormal(rayPos2);\n    // Calculate the Light of the Ray\n    vec3 rayLight = calcLight(rayPos2, rayNorm);\n    // Calculate the Color of the Ray\n    vec3 rayColor = rayLight * calcColor(rayPos2);\n    // Return the Color of the Ray\n    return rayColor;\n}\n\n// 4D Screen Output Image\nvec", "\n    rayori = cameraPos;\n    // Set the Raymarching Distance\n    float dist = 0.0;\n    // Set the Raymarching Maximum Distance\n    float maxDist = 100.0;\n    // Set the Raymarching Step Size\n    float stepSize = 0.01;\n    // Set the Raymarching Color\n    vec3 color = vec3(0.0);\n    // Set the Raymarching Normal\n    vec3 normal = vec3(0.0);\n    // Set the Raymarching Material\n    vec3 material = vec3(0.0);\n    // Set the Raymarching Light\n    vec3 light = vec3(0.0);\n    // Set the Raymarching Light Color\n    vec3 lightColor = vec3(1.0);\n    // Set the Raymarching Light Position\n    vec3 lightPos = vec3(0.0, 10.0, 0.0);\n    // Set the Raymarching Light Attenuation\n    float", "\n    float seed = dot(fragCoord, iResolution.xy);\n    seed = seed + iGlobalTime;\n    seed = seed * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float fade = clamp(1.0 - abs(coord.x - 0.5) * 2.0, 0.0, 1.0);\n\n    // Calculate the ray's position\n    float rayPos = coord.x + travelRate * frequency;\n\n    // Calculate the ray's strength\n    float rayStrength = clamp(1.0 - abs(rayPos - 0.5) * 2.0, 0.0, 1.0);\n\n    // Return the ray's strength multiplied by the fade\n    return rayStrength * fade * maxStrength;\n}\n\n// Calculate the color of the fragment\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// ", " right now\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    vec2 p3 = p - vec2(d.x, -d.y);\n    vec2 p4 = p + vec2(d.x, -d.y);\n    vec2 p5 = p - vec2(-d.x, d.y);\n    vec2 p6 = p + vec2(-d.x, d.y);\n    vec2 p7 = p - vec2(-d.x, -d.y);\n    vec2 p8 = p + vec2(-d.x, -d.y);\n    float d1 = distance(p, p1);\n    float d2 = distance(p, p2);\n    float d3 = distance(p, p3);\n    float d4 = distance(p, p4);\n    float d5 = distance(p, p5);\n    float d6 = distance(p, p6);\n    float d7 = distance(p, p7);\n    float", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 dir = normalize(b-a);\n    vec2 n = vec2(-dir.y,dir.x);\n    float k = w1+w2;\n\n    // start with a box\n    float d = sdBox(p,a,b,vec2(w1,w1));\n\n    // subtract the arrowhead\n    float d2 = sdSegment(p,a,b);\n    d2 = max(d2,-dot(p-a,n));\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    // subtract the arrowhead\n    d2 = sdSegment(p,b-n*k,b);\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    return d;\n}\n\n//------------------------------------------------------------------\n// sdSegment\n//\n// Returns the distance from p to the line segment ab.\n//\n// The line segment is defined by two points a and b.\n//", "\n    uv = (uv - 0.5) * mat2(0.8,0.6,-0.6,0.8);\n    \n    //get the distance to the center\n    float d = length(uv);\n    \n    //get the angle of the uv\n    float a = atan(uv.y,uv.x);\n    \n    //get the distance to the edge\n    float e = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float f = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float g = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float h = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float i = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float j = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float k = abs(d - 0.5);", "\n    vec3 colA = vec3(0.0,0.0,0.0);\n    vec3 colB = vec3(1.0,1.0,1.0);\n    return mix( colA, colB, rnd ) * falloff;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n   vec3 q = vec3(dot(vec2(1.0, 1.0), p),\n                 dot(vec2(57.0, 113.0), p),\n                 dot(vec2(157.0, 213.0), p));\n   return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n  //  return x - x*x*x/3 + x*x*x*x*x/5;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x", ", I don't remember where.\n  //  It's a post-processing effect that makes the image look more like a\n  //  film.\n  col = pow(col, vec3(0.4545));\n  col = col * (col * 0.5 + 0.5);\n  col = col * (1.0 - pow(clamp(1.0 - max(dot(q, q), 0.0), 0.0, 1.0), 1.5));\n  col = col * (0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.75));\n  return clamp(col, 0.0, 1.0);\n}\n\n//  This is the main function that is called by the shadertoy API.\n//  It is called once per frame, and it is responsible for rendering the scene.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n ", "\n    vec3 d = abs(p) - vec3(1.0);\n    // Return the maximum component of d\n    return max(d.x, max(d.y, d.z));\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a circle\n    float radius = iMouse.x / iResolution.x;\n    float radius_last = iMouse.x / iResolution.x;\n    float radius_diff = radius - radius_last;\n    float brightness = radius_diff;\n    col = vec3(brightness, brightness, brightness);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"]}