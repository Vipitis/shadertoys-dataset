{"generations": [" return 0.5f * ( 1.0f + s.z ); }\nfloat", "\n    return length(cross(p-a,b-a)) / length(b-a);\n}\n// distance to a line segment\nfloat", "\n\treturn ( dot( v, r ) < 0.0 )? -v : v;\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n    return v - 2.0 * dot(v, r) * r;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec", "\n\treturn sign(r.x) * min( abs(v.x), abs(r.x) ) + sign(r.y) * min( abs(v.y), abs(r.y) );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 proj = a + ba*h;\n    return length(p-proj)-mix(w1,w2,h);\n}\n\n// https://www.shadertoy.com/view/Xt23Dy\nfloat", "\n\tfloat cosTheta = dot(rayDir, sunDir);\n\treturn sunCol * (1.0 - cosTheta);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec", "\n    float t2 = t * t;\n    float t3 = t2 * t;\n    return 0.5f * (\n        2.0f * p1 * t3 +\n        (3.0f * p2 - 3.0f * p0) * t2 +\n        (p0 - 2.0f * p1 + p2) * t +\n        p3\n    );\n}\n\n// This is a spline used for the camera path\nvec", "\n\tfloat sum = 0.0;\n\tfloat freq = 0.01;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfloat x = p.x * freq;\n\t\tfloat y = p.y * freq;\n\t\tfloat z = p.z * freq;\n\t\tfloat nx = nudge * (y - z);\n\t\tfloat ny = nudge * (z - x);\n\t\tfloat nz = nudge * (x - y);\n\t\tsum += amp * (sin(x + nx) + sin(y + ny) + sin(z + nz));\n\t\tfreq *= 1.9;\n\t\tamp *= 0.5;\n\t}\n\treturn sum * normalizer;\n}\n\n// This is a simple noise function that uses a hash function.\n// It's not as fast as the spiral noise, but it's a good fallback if you need to support older hardware.\nfloat", "\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tp0 = p0 + vec4(0.0, 0.0, 0.0, 1.0);\n\tp1 = p1 + vec4(0.0, 0.0, 0.0, 1.0);\n\tp2 = p2 + vec4(0.0, 0.0, 0.0, 1.0);\n\tp3 = p3 + vec4(0.0, 0.0, 0.0, 1.0);\n\n\tvec4 p = p0 * (1.0 - t) * (1.0 - t) * (1.0 - t) +\n\t\tp1 * 3.0 * t * (1.0 - t) * (1.0 - t) +\n\t\tp2 * 3.0 * t * t * (1.0 - t) +\n\t\tp3 * t * t * t;\n\n\treturn p;\n}\n\n// This is the main function that gets called by the shader.\n// It takes a time t and a camera index c, and returns the\n// position of the camera at time t.\nvec", "\n\treturn u - floor(u);\n}\n\nfloat", "\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat z = p.z;\n\tfloat r = sqrt(x*x + y*y + z*z);\n\tfloat theta = atan(y, x);\n\tfloat phi = atan(z, sqrt(x*x + y*y));\n\tfloat r2 = r * r;\n\tfloat r4 = r2 * r2;\n\tfloat r8 = r4 * r4;\n\tfloat r16 = r8 * r8;\n\tfloat r32 = r16 * r16;\n\tfloat r64 = r32 * r32;\n\tfloat r128 = r64 * r64;\n\tfloat r256 = r128 * r128;\n\tfloat r512 = r256 * r256;\n\tfloat r1024 = r512 * r512;\n\tfloat r2048 = r1024 * r1024;\n\tfloat r4096 = r2048 * r2048;\n\tfloat r8192 = r4096 * r4096;\n\tfloat r16384 = r8192 * r8192;\n\tfloat r32768 = r16384 * r16384;\n\tfloat r65536 = r32768 * r32768;\n\tfloat r131072 = r65536 * r65536;\n\tfloat r262144 = r131072 * r131072;\n\tfloat r524288 = r262144 * r262144;\n\tfloat r1048576 = r524288 * r524288;\n\tfloat r2097152 = r1048576 * r1048576;\n\tfloat r4194304 = r2097152 * r2097152;\n\tfloat r8388608 = r4194304 * r4194304;\n\tfloat r16777216 = r8388608 * r8388608;\n\tfloat r33554432 = r16777216 * r16777216;\n\tfloat r67108864 = r33554432 * r33554432;\n\tfloat r134217728 = r67108864 * r67108864;\n\tfloat r268435456 = r134217728 * r134217728;\n\tfloat r5368", "\n\t// This is the distance to the object\n\tfloat d = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d2 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d3 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d4 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d5 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d6 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d7 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d8 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d9 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d10 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d11 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d12 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d13 = length(p - vec3(0.0, 0.0, 0.0));\n\n\t// This is the distance to the next level of recursion\n\tfloat d14 = length(p", "\n    // Compute the distance to the closest intersection.\n    float t = 0.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float t0 = GetLightDistance(rayDir, sunDir, i);\n        if (t0 < t || i == 0)\n            t = t0;\n    }\n\n    // Compute the color of the intersection.\n    vec3 color = GetEnvColor(rayDir, t);\n\n    // Compute the color of the sky.\n    color = color * (1.0 - exp(-t * 0.5));\n\n    // Compute the color of the lights.\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 lightDir = GetLightDir(i);\n        float lightDist = GetLightDistance(rayDir, lightDir, i);\n        color += GetLightColor(i) * exp(-lightDist * 0.5);\n    }\n\n    return color;\n}\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec", "\n\treturn a + k * (b - a);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat", "\n\tvec3 d = pos - spherePos;\n\tfloat b = dot(d, dirVecPLZNormalizeMeFirst);\n\tfloat det = b*b - dot(d, d) + rad*rad;\n\tif (det < 0.0f)\n\t\treturn -1.0f;\n\telse\n\t\treturn -b - sqrtf(det);\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat", "\n    vec3 p_ = p;\n    p_.z = 0.0;\n    return p_ - p;\n}\n\n// Calculate the distance field that defines the object.\nvec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve second derivative (acceleration)\nvec", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// curve third derivative (jerk)\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\treturn dot( pa, ba ) / dot( ba, ba );\n}\n\n// signed squared distance between point and segment\nfloat", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tvec3 abxao = cross( ab, ao );\n\tvec3 abxad = cross( ab, ad );\n\tfloat t = dot( abxao, ad ) / dot( abxad, abxad );\n\treturn vec2( dot( abxao, abxad ), dot( ao, ao ) + t * dot( ad, ad ) - dot( ab, ab ) );\n}\n\n// signed squared distance between ray and segment\nvec", "\n\tvec2 d = abs(p) - b - vec2(r.xy);\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.z;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat", "\n\tfloat cosTheta = dot(rayDir, sunDir);\n\treturn sunCol * (1.0 - cosTheta);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec", "\n    // Calculate the direction of the eye ray\n    vec3 dir = normalize( ta - ro );\n\n    // Calculate the up vector\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n\n    // Calculate the right vector\n    vec3 right = normalize( cross( up, dir ) );\n\n    // Calculate the new up vector\n    up = normalize( cross( dir, right ) );\n\n    // Calculate the new right vector\n    right = normalize( cross( up, dir ) );\n\n    // Calculate the transformation matrix\n    mat3 m = mat3(\n        right,\n        up,\n        dir\n    );\n\n    // Calculate the roll\n    m = mat3(\n        vec3( cos( roll ), sin( roll ), 0.0 ),\n        vec3( -sin( roll ), cos( roll ), 0.0 ),\n        vec3( 0.0, 0.0, 1.0 )\n    ) * m;\n\n    // Return the transformation matrix\n    return m;\n}\n\n// This function calculates the transformation matrix for the camera\nmat", "\n\tvec2 p = currentRayPosition.xy;\n\tfloat r = 0.5;\n\tfloat h = 0.5;\n\tfloat d = length(p);\n\tfloat s = smoothstep(r, r+h, d);\n\treturn vec2(s, s);\n}\n\n//'TAG: BOX'\nvec", "\n\tfloat distance1 = distance( thing1, thing2 );\n\tfloat distance2 = distance( thing2, thing1 );\n\tif( distance1 < distance2 ){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec", "\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of the ray\n\tvec3 currentRayPosition = rayPosition;\n\t// Get the current position of", "\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what direction the surface is facing.\n\t// This is the same thing as the normal of the surface.\n\t// We are going to use the normal of the surface\n\t// to figure out what", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// the doBackground function is the one that actually\n// draws the background. it's a function because it can\n// be called from anywhere.\nvoid doBackground(){\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of triangles,\n\t// so we need to set the vertex count.\n\tglBegin(GL_TRIANGLES);\n\n\t// we're going to draw a bunch of", "\n\treturn vec3(0.0,0.0,0.0) + normalOfSurface * 0.5;\n}\n\n// This is the main function that will be called\n// by the shader. It will pass in the position\n// of the hit, and the normal of the surface.\n// It will also pass in the ray that was used to\n// find the hit.\nvec", "\n\t// We need to get the color of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the color of that object\n\tint objectIndex = rayHitInfo.x;\n\tvec3 objectColor = objects[ objectIndex ].color;\n\t// We also need to get the position of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the position of that object\n\tvec3 objectPosition = objects[ objectIndex ].position;\n\t// We also need to get the normal of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the normal of that object\n\tvec3 objectNormal = objects[ objectIndex ].normal;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the material of that object\n\tint objectMaterial = objects[ objectIndex ].material;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the material of that object\n\tfloat objectReflectivity = objects[ objectIndex ].reflectivity;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the material of that object\n\tfloat objectRefractivity = objects[ objectIndex ].refractivity;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the material of that object\n\tfloat objectTransparency = objects[ objectIndex ].transparency;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object that was hit\n\t// and then getting the material of that object\n\tfloat objectShininess = objects[ objectIndex ].shininess;\n\t// We also need to get the material of the object that was hit\n\t// We do this by getting the index of the object", "\n\treturn smoothstep(b - 0.5, b + 0.5, x);\n}\n\n// returns a value between 0.0 and 1.0\n// if x is less than 0.0 then 0.0 is returned\n// if x is greater than 1.0 then 1.0 is returned\n// if x is between 0.0 and 1.0 then x is returned\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\n// creates a 2D noise function\nfloat", "\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat", "\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> sphere center\n// input r --> sphere radius\nfloat", "\n\tfloat d = abs(d1) - abs(d2);\n\treturn d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d", "\n\tfloat d = d1 - d2;\n\tfloat d1_d2 = d1 / d2;\n\tfloat d2_d1 = d2 / d1;\n\tfloat d1_d2_d2_d1 = d1_d2 * d2_d1;\n\tfloat d1_d2_d2_d1_d1_d2 = d1_d2_d2_d1 * d1_d2_d2_d1;\n\tfloat d1_d2_d2_d1_d1_d2_d1_d2 = d1_d2_d2_d1_d1_d2 * d1_d2_d2_d1_d1_d2;\n\tfloat d1_d2_d2_d1_d1_d2_d1_d2_d1_d2 = d1_d2_d2_d1_d1_d2_d1_d2_d1_d2 * d1_d2_d2_d1_d1_d2;\n\tfloat d1_d2_d2_d1_d1_d2_d1_d2_d1_d2_d1_d2 = d1_d2_d2_d1_d1_d2_d1_d2_d1_d2_d1_d2 * d1_d2_d2_d1_d1_d2;\n\tfloat d1_d2_d2_d1_d1_d2_d1_d2_d1_d2_d1_d2_d1_d2 = d1_d2_d2_d1_d1_d2_d1_d2_d1_d2_d1_d2_d1_d2 * d1_d2_d2_d1_d1_d2;\n\tfloat d1_d2_d2_d1_d1_d2_d1_d2_d1_d2_d1_d2_d1_d2_d1_d2 = d1_d2_", "\n\tvec3 p1 = p;\n\tvec3 p2 = p;\n\tvec3 p3 = p;\n\tvec3 p4 = p;\n\tvec3 p5 = p;\n\tvec3 p6 = p;\n\tvec3 p7 = p;\n\tvec3 p8 = p;\n\tvec3 p9 = p;\n\tvec3 p10 = p;\n\tvec3 p11 = p;\n\tvec3 p12 = p;\n\tvec3 p13 = p;\n\tvec3 p14 = p;\n\tvec3 p15 = p;\n\tvec3 p16 = p;\n\tvec3 p17 = p;\n\tvec3 p18 = p;\n\tvec3 p19 = p;\n\tvec3 p20 = p;\n\tvec3 p21 = p;\n\tvec3 p22 = p;\n\tvec3 p23 = p;\n\tvec3 p24 = p;\n\tvec3 p25 = p;\n\tvec3 p26 = p;\n\tvec3 p27 = p;\n\tvec3 p28 = p;\n\tvec3 p29 = p;\n\tvec3 p30 = p;\n\tvec3 p31 = p;\n\tvec3 p32 = p;\n\tvec3 p33 = p;\n\tvec3 p34 = p;\n\tvec3 p35 = p;\n\tvec3 p36 = p;\n\tvec3 p37 = p;\n\tvec3 p38 = p;\n\tvec3 p39 = p;\n\tvec3 p40 = p;\n\tvec3 p41 = p;\n\tvec3 p42 = p;\n\tvec3 p43 = p;\n\tvec3 p44 = p;\n\tvec3 p45 = p;\n\tvec3 p46 = p;\n\tvec3 p47 = p;\n\tvec3 p48 = p;\n\tvec3 p49 = p;\n\tvec3 p50 = p;\n\tvec3 p51 = p;\n\tvec3 p52 = p;\n\tvec3 p53 = p;\n\tvec3 p54 = p;\n\tvec3 p55 = p;\n\tvec3 p56 = p;\n\tvec3 p57 = p", "\n\tif (o1.x > o2.x)\n\t{\n\t\treturn o2;\n\t}\n\telse\n\t{\n\t\treturn o1;\n\t}\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n\t// find the closest object\n\t// find the closest point on the object\n\t// move the object to that point\n\t// return the point\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~\n\t// ~~~~~~~", "\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro;\n\tvec3 rd_ = rd;\n\tvec3 ro_ = ro", "\n    // ~~~~~~~ find closest intersection point\n    // input ro --> pixel's ray original position\n    // input rd --> pixel's ray direction\n    // output --> closest intersection point\n    float t = INF;\n    int id = -1;\n    for (int i = 0; i < n_surfaces; i++)\n    {\n        float t_i = intersect(surfaces[i], ro, rd);\n        if (t_i > 0 && t_i < t)\n        {\n            t = t_i;\n            id = i;\n        }\n    }\n\n    // ~~~~~~~ apply color\n    // input id --> closest surface id\n    // input ro --> pixel's ray original position\n    // input rd --> pixel's ray direction\n    // output --> pixel color\n    vec3 color = vec3(0.0);\n    if (id!= -1)\n    {\n        color = surfaces[id].color;\n    }\n    return color;\n}\n\n// ~~~~~~~ render image\n// input nx --> image width\n// input ny --> image height\n// output --> image\nvoid render_image(int nx, int ny)\n{\n    // ~~~~~~~ initialize image\n    // input nx --> image width\n    // input ny --> image height\n    // output --> image\n    vec3 *image = (vec3 *)malloc(sizeof(vec3) * nx * ny);\n    for (int i = 0; i < nx * ny; i++)\n    {\n        image[i] = vec3(0.0);\n    }\n\n    // ~~~~~~~ render image\n    // input nx --> image width\n    // input ny --> image height\n    // output --> image\n    for (int j = ny - 1; j >= 0; j--)\n    {\n        for (int i = 0; i < nx; i++)\n        {\n            // ~~~~~~~ compute pixel's ray\n            // input i --> pixel's x coordinate\n            // input j --> pixel's y coordinate\n            // output --> pixel's ray\n            vec3 ro = vec3(0.0, 0.0, 2.0);\n            vec3 rd = normalize(vec3(i - nx / 2.0, j - ny", "\n\tvec3 zAxis = normalize( targetPos - camPos );\n\tvec3 xAxis = normalize( cross( vec3( 0.0, 1.0, 0.0 ), zAxis ) );\n\tvec3 yAxis = normalize( cross( zAxis, xAxis ) );\n\n\tmat3 camMat = mat3(\n\t\tvec3( xAxis.x, yAxis.x, zAxis.x ),\n\t\tvec3( xAxis.y, yAxis.y, zAxis.y ),\n\t\tvec3( xAxis.z, yAxis.z, zAxis.z )\n\t);\n\n\treturn camMat;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// input up --> up vector\n// output --> camera matrix used to transform\nmat", "\n    if (id < 0.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (id < 1.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id < 2.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id < 3.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id < 4.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id < 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id < 6.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id < 7.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> sphere center\n// input r --> sphere radius\nfloat", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> size x\n//        ps.y --> size z\n//        ps.z --> radius\nfloat", "\n    float h = clamp( 0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n\tvec4 o3;\n\tfloat d1 = o1.w;\n\tfloat d2 = o2.w;\n\tfloat d3 = d1 * bf + d2 * (1.0 - bf);\n\to3.xyz = o1.xyz * bf + o2.xyz * (1.0 - bf);\n\to3.w = d3;\n\treturn o3;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec", "\n\treturn d1-d2;\n}\n\n// ~~~~~~~ do shape intersect, cuts d1 out of d2\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat", "\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    lightPos.x = cos(time) * radius;\n    lightPos.z = sin(time) * radius;\n    return lightPos;\n}\n\n// ~~~~~~~~ generates world position of point light\n// output --> wolrd pos of point light\nvec", "\n    // find the closest object\n    float closest = 1.0;\n    vec3 closest_point = vec3(0.0);\n    vec3 closest_normal = vec3(0.0);\n    vec4 closest_color = vec4(0.0);\n    for (int i = 0; i < objects.length(); i++)\n    {\n        // get the object\n        Object obj = objects[i];\n        // get the distance\n        float dist = distance(p, obj.position);\n        // if it's closer than the current closest\n        if (dist < closest)\n        {\n            // set it as the closest\n            closest = dist;\n            // set the closest point\n            closest_point = p - obj.position;\n            // set the closest normal\n            closest_normal = normalize(closest_point);\n            // set the closest color\n            closest_color = obj.color;\n        }\n    }\n    // return the closest distance and the closest color\n    return vec4(closest, closest_color);\n}\n\n// ~~~~~~~ main\n// main function\n// inputs:\n//   ray_origin: the origin of the ray\n//   ray_direction: the direction of the ray\n// outputs:\n//   color: the color of the ray\nvec", "\n\tvec4 hit = vec4(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 99999.0;\n\tint id = -1;\n\tfloat itter = 0.0;\n\tfloat itterStep = 0.0;\n\tfloat itterMax = 0.0;\n\tfloat itterMin = 0.0;\n\tfloat itterRatioMin = 0.0;\n\tfloat itterRatioMax = 0.0;\n\tfloat itterRatioStep = 0.0;\n\tfloat itterRatioStepMax = 0.0;\n\tfloat itterRatioStepMin = 0.0;\n\tfloat itterRatioStepStep = 0.0;\n\tfloat itterRatioStepStepMax = 0.0;\n\tfloat itterRatioStepStepMin = 0.0;\n\tfloat itterRatioStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepMin = 0.0;\n\tfloat itterRatioStepStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepStepMin = 0.0;\n\tfloat itterRatioStepStepStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepStepStepMin = 0.0;\n\tfloat itterRatioStepStepStepStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepMin = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStepMin = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStepStep = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStepStepMax = 0.0;\n\tfloat itterRatioStepStepStepStepStepStepStepStepMin = 0.0;\n\tfloat itterRatio", "\n    float t = 0.0;\n    float tMax = 100.0;\n    float tDelta = 0.05;\n    float bias = 0.0001;\n    float shadow = 1.0;\n    vec3 dir = normalize(lp - sp);\n    while (t < tMax)\n    {\n        float dist = rayMarch(sp + dir * t);\n        if (dist < 0.0001)\n        {\n            break;\n        }\n        t += dist;\n        tDelta += 0.01;\n    }\n    shadow = clamp(tDelta / t, 0.0, 1.0);\n    return shadow;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat", "\n    float d = 0.0;\n    float step = 0.01;\n    float maxDist = 0.1;\n    float maxDist2 = maxDist * maxDist;\n    vec3 dir = nor * step;\n    vec3 pos = sp + dir;\n    for (int i = 0; i < 10; i++)\n    {\n        if (get_material(pos) == 0)\n        {\n            d += step;\n            pos += dir;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return d / maxDist;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat", "\n\tvec3 n = vec3(0.0);\n\tfloat d = 0.0;\n\tfor (int i = 0; i < nearbyPoints.size(); i++)\n\t{\n\t\tvec3 p1 = nearbyPoints[i];\n\t\tvec3 n1 = nearbyNormals[i];\n\t\tfloat d1 = distance(p, p1);\n\t\tif (d1 < 0.1)\n\t\t{\n\t\t\tn += n1;\n\t\t\td += 1.0;\n\t\t}\n\t}\n\tif (d > 0.0)\n\t{\n\t\tn /= d;\n\t}\n\treturn n;\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec", "\n    vec3 ret = pow(c, vec3(1.0 / 2.2));\n    return ret;\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec", "\n    float fog = clamp(1.0 - exp(-fs.x * d), 0.0, 1.0);\n    float fogColor = pow(fog, fs.y);\n    return mix(fc1, fc2, fogColor);\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec", "\n\tfloat attn = 1.0f;\n\tif (d > 0.0f)\n\t{\n\t\tattn = 1.0f / (cF + lF * d + qF * d * d);\n\t}\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat", "\n    vec3 rayDir = vec3(0.0);\n    rayDir.x = fCoord.x;\n    rayDir.y = fCoord.y;\n    rayDir.z = 1.0;\n    rayDir = cMatrix * rayDir;\n    rayDir = normalize(rayDir);\n    return rayDir;\n}\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec", "\n    // ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n    //          only effective for shape edges, doesn't fix surface col patterns\n    // input fCoord --> pixel coordinate\n    // input cPos --> camera position\n    // input cMat --> camera matrix\n    // output vec3 --> pixel antialaised color\n    vec3 col = vec3(0.0);\n    vec3 col_sum = vec3(0.0);\n    float col_weight = 0.0;\n    for(int i=0;i<AA_ITER;i++)\n    {\n        // ~~~~~~~ render pixel\n        // input fCoord --> pixel coordinate\n        // input cPos --> camera position\n        // input cMat --> camera matrix\n        // output vec3 --> pixel color\n        vec3 pCol = render(fCoord,cPos,cMat);\n        // ~~~~~~~ accumulate pixel color\n        // input pCol --> pixel color\n        // input col_weight --> pixel color weight\n        // output vec3 --> pixel color\n        col_sum += pCol*col_weight;\n        col_weight += 1.0;\n        // ~~~~~~~ move to next pixel\n        // input fCoord --> pixel coordinate\n        // input cPos --> camera position\n        // input cMat --> camera matrix\n        // output vec3 --> pixel color\n        fCoord += vec2(AA_STEP,AA_STEP);\n    }\n    // ~~~~~~~ return pixel color\n    // input col_sum --> pixel color\n    // input col_weight --> pixel color weight\n    // output vec3 --> pixel color\n    return col_sum/col_weight;\n}\n\n// ~~~~~~~ render pixel\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel color\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n`;\n\nexport default shader;\n", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n// sphere distance field\nfloat", "\n\treturn length(p) - r;\n}\n\n// simple sphere distance field\nfloat", "\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p;\n    vec3 p_ = p", "\n\treturn vec2(pow(c.x, 5), pow(c.y, 5));\n}\n\n//Function that returns a complex number to power of 10\nvec", "\n\tvec2 coord2 = coord * morphConstant;\n\tvec2 coord3 = coord2 * morphConstant;\n\tvec2 coord4 = coord3 * morphConstant;\n\tvec2 coord5 = coord4 * morphConstant;\n\tvec2 coord6 = coord5 * morphConstant;\n\tvec2 coord7 = coord6 * morphConstant;\n\tvec2 coord8 = coord7 * morphConstant;\n\tvec2 coord9 = coord8 * morphConstant;\n\tvec2 coord10 = coord9 * morphConstant;\n\tvec2 coord11 = coord10 * morphConstant;\n\tvec2 coord12 = coord11 * morphConstant;\n\tvec2 coord13 = coord12 * morphConstant;\n\tvec2 coord14 = coord13 * morphConstant;\n\tvec2 coord15 = coord14 * morphConstant;\n\tvec2 coord16 = coord15 * morphConstant;\n\tvec2 coord17 = coord16 * morphConstant;\n\tvec2 coord18 = coord17 * morphConstant;\n\tvec2 coord19 = coord18 * morphConstant;\n\tvec2 coord20 = coord19 * morphConstant;\n\tvec2 coord21 = coord20 * morphConstant;\n\tvec2 coord22 = coord21 * morphConstant;\n\tvec2 coord23 = coord22 * morphConstant;\n\tvec2 coord24 = coord23 * morphConstant;\n\tvec2 coord25 = coord24 * morphConstant;\n\tvec2 coord26 = coord25 * morphConstant;\n\tvec2 coord27 = coord26 * morphConstant;\n\tvec2 coord28 = coord27 * morphConstant;\n\tvec2 coord29 = coord28 * morphConstant;\n\tvec2 coord30 = coord29 * morphConstant;\n\tvec2 coord31 = coord30 * morphConstant;\n\tvec2 coord32 = coord31 * morphConstant;\n\tvec2 coord33 = coord32 * morphConstant;\n\tvec2 coord34 = coord33 * morphConstant;\n\tvec2 coord35 = coord34 * morphConstant;\n\tvec2 coord36 = coord35 * morphConstant;\n\tvec2 coord37 = coord36 * morphConstant;\n\tvec2 coord38 = coord37 * morphConstant;\n\tvec2 coord39 = coord38 * morphConstant;\n\tvec2 coord40 = coord39 * morphConstant;\n\tvec2 coord41", "\n\tvec2 uv2 = uv * constant;\n\tvec2 uv3 = uv * constant;\n\tvec2 uv4 = uv * constant;\n\tvec2 uv5 = uv * constant;\n\tvec2 uv6 = uv * constant;\n\tvec2 uv7 = uv * constant;\n\tvec2 uv8 = uv * constant;\n\tvec2 uv9 = uv * constant;\n\tvec2 uv10 = uv * constant;\n\tvec2 uv11 = uv * constant;\n\tvec2 uv12 = uv * constant;\n\tvec2 uv13 = uv * constant;\n\tvec2 uv14 = uv * constant;\n\tvec2 uv15 = uv * constant;\n\tvec2 uv16 = uv * constant;\n\tvec2 uv17 = uv * constant;\n\tvec2 uv18 = uv * constant;\n\tvec2 uv19 = uv * constant;\n\tvec2 uv20 = uv * constant;\n\tvec2 uv21 = uv * constant;\n\tvec2 uv22 = uv * constant;\n\tvec2 uv23 = uv * constant;\n\tvec2 uv24 = uv * constant;\n\tvec2 uv25 = uv * constant;\n\tvec2 uv26 = uv * constant;\n\tvec2 uv27 = uv * constant;\n\tvec2 uv28 = uv * constant;\n\tvec2 uv29 = uv * constant;\n\tvec2 uv30 = uv * constant;\n\tvec2 uv31 = uv * constant;\n\tvec2 uv32 = uv * constant;\n\tvec2 uv33 = uv * constant;\n\tvec2 uv34 = uv * constant;\n\tvec2 uv35 = uv * constant;\n\tvec2 uv36 = uv * constant;\n\tvec2 uv37 = uv * constant;\n\tvec2 uv38 = uv * constant;\n\tvec2 uv39 = uv * constant;\n\tvec2 uv40 = uv * constant;\n\tvec2 uv41 = uv * constant;\n\tvec2 uv42 = uv * constant;\n\tvec2 uv43 = uv * constant;\n\tvec2 uv44 = uv * constant;\n\tvec2 uv45 = uv * constant;\n\tvec2 uv46 = uv * constant;\n\tvec2 uv47 = uv * constant;\n\tvec2 uv48", "\n    return x - floor(x);\n}\n\n// A sawtooth wave\nfloat", "\n\t// Get the distance from the line.\n\tvec2 p = uv - pA;\n\tfloat d = dot(p, pB - pA);\n\tfloat d2 = dot(p, p);\n\tfloat d3 = dot(pB - pA, pB - pA);\n\tfloat d4 = d2 / d3;\n\tfloat d5 = d4 * d4;\n\tfloat d6 = d4 * d4 * d4;\n\tfloat d7 = d4 * d4 * d4 * d4;\n\tfloat d8 = d4 * d4 * d4 * d4 * d4;\n\tfloat d9 = d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d10 = d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d11 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d12 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d13 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d14 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d15 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d16 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d17 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4;\n\tfloat d18 = d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 * d4 *", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tif (len < 0.0001) {\n\t\treturn 0.0;\n\t}\n\td /= len;\n\tvec2 p = pA + d * 0.5;\n\tfloat r = len * 0.5;\n\tfloat r2 = r * r;\n\tfloat r4 = r2 * r2;\n\tfloat r8 = r4 * r4;\n\tfloat r16 = r8 * r8;\n\tfloat r32 = r16 * r16;\n\tfloat r64 = r32 * r32;\n\tfloat r128 = r64 * r64;\n\tfloat r256 = r128 * r128;\n\tfloat r512 = r256 * r256;\n\tfloat r1024 = r512 * r512;\n\tfloat r2048 = r1024 * r1024;\n\tfloat r4096 = r2048 * r2048;\n\tfloat r8192 = r4096 * r4096;\n\tfloat r16384 = r8192 * r8192;\n\tfloat r32768 = r16384 * r16384;\n\tfloat r65536 = r32768 * r32768;\n\tfloat r131072 = r65536 * r65536;\n\tfloat r262144 = r131072 * r131072;\n\tfloat r524288 = r262144 * r262144;\n\tfloat r1048576 = r524288 * r524288;\n\tfloat r2097152 = r1048576 * r1048576;\n\tfloat r4194304 = r2097152 * r2097152;\n\tfloat r8388608 = r4194304 * r4194304;\n\tfloat r16777216 = r8388608 * r8388608;\n\tfloat r33554432 = r16777216 * r16777216;\n\tfloat r67108864 = r33554432 * r33554432;\n\tfloat r134217728 = r67108864 * r67108864;\n\tfloat r268435456 = r134217728 * r134217728;\n\tfloat r536870912 = r", "\n\tvec2 pC = pA + (pB - pA) * 0.5;\n\tvec2 pD = pB - (pB - pA) * 0.5;\n\tvec2 pE = pC + (pD - pC) * 0.5;\n\tvec2 pF = pD - (pD - pC) * 0.5;\n\tvec2 pG = pE + (pF - pE) * 0.5;\n\tvec2 pH = pF - (pF - pE) * 0.5;\n\tvec2 pI = pG + (pH - pG) * 0.5;\n\tvec2 pJ = pH - (pH - pG) * 0.5;\n\tvec2 pK = pI + (pJ - pI) * 0.5;\n\tvec2 pL = pJ - (pJ - pI) * 0.5;\n\tvec2 pM = pK + (pL - pK) * 0.5;\n\tvec2 pN = pL - (pL - pK) * 0.5;\n\tvec2 pO = pM + (pN - pM) * 0.5;\n\tvec2 pP = pN - (pN - pM) * 0.5;\n\tvec2 pQ = pO + (pP - pO) * 0.5;\n\tvec2 pR = pP - (pP - pO) * 0.5;\n\tvec2 pS = pQ + (pR - pQ) * 0.5;\n\tvec2 pT = pR - (pR - pQ) * 0.5;\n\tvec2 pU = pS + (pT - pS) * 0.5;\n\tvec2 pV = pT - (pT - pS) * 0.5;\n\tvec2 pW = pU + (pV - pU) * 0.5;\n\tvec2 pX = pV - (pV - pU) * 0.5;\n\tvec2 pY = pW + (pX - pW) * 0.5;\n\tvec2 pZ = pX -", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir /= len;\n    float halfThick = thick.x / 2.0;\n    float halfThick2 = thick.y / 2.0;\n    float halfThick2_2 = halfThick2 * 2.0;\n    float halfThick2_4 = halfThick2_2 * 2.0;\n    float halfThick2_8 = halfThick2_4 * 2.0;\n    float halfThick2_16 = halfThick2_8 * 2.0;\n    float halfThick2_32 = halfThick2_16 * 2.0;\n    float halfThick2_64 = halfThick2_32 * 2.0;\n    float halfThick2_128 = halfThick2_64 * 2.0;\n    float halfThick2_256 = halfThick2_128 * 2.0;\n    float halfThick2_512 = halfThick2_256 * 2.0;\n    float halfThick2_1024 = halfThick2_512 * 2.0;\n    float halfThick2_2048 = halfThick2_1024 * 2.0;\n    float halfThick2_4096 = halfThick2_2048 * 2.0;\n    float halfThick2_8192 = halfThick2_4096 * 2.0;\n    float halfThick2_16384 = halfThick2_8192 * 2.0;\n    float halfThick2_32768 = halfThick2_16384 * 2.0;\n    float halfThick2_65536 = halfThick2_32768 * 2.0;\n    float halfThick2_131072 = halfThick2_65536 * 2.0;\n    float halfThick2_262144 = halfThick2_131072 * 2.0;\n    float halfThick2_524288 = halfThick2_262144 * 2.0;\n    float halfThick2_1048576 = halfThick2_524288 * 2.0;\n    float halfThick2_2097152 = half", "\n\tvec2 dir = pB - pA;\n\tfloat len = length(dir);\n\tdir /= len;\n\tfloat halfThick = thick.x / 2.0;\n\tfloat halfThick2 = thick.y / 2.0;\n\tfloat halfThick3 = thick.z / 2.0;\n\tfloat halfThick4 = thick.w / 2.0;\n\tfloat halfThick5 = thick.z / 2.0;\n\tfloat halfThick6 = thick.w / 2.0;\n\tfloat halfThick7 = thick.x / 2.0;\n\tfloat halfThick8 = thick.y / 2.0;\n\tfloat halfThick9 = thick.z / 2.0;\n\tfloat halfThick10 = thick.w / 2.0;\n\tfloat halfThick11 = thick.x / 2.0;\n\tfloat halfThick12 = thick.y / 2.0;\n\tfloat halfThick13 = thick.z / 2.0;\n\tfloat halfThick14 = thick.w / 2.0;\n\tfloat halfThick15 = thick.x / 2.0;\n\tfloat halfThick16 = thick.y / 2.0;\n\tfloat halfThick17 = thick.z / 2.0;\n\tfloat halfThick18 = thick.w / 2.0;\n\tfloat halfThick19 = thick.x / 2.0;\n\tfloat halfThick20 = thick.y / 2.0;\n\tfloat halfThick21 = thick.z / 2.0;\n\tfloat halfThick22 = thick.w / 2.0;\n\tfloat halfThick23 = thick.x / 2.0;\n\tfloat halfThick24 = thick.y / 2.0;\n\tfloat halfThick25 = thick.z / 2.0;\n\tfloat halfThick26 = thick.w / 2.0;\n\tfloat halfThick27 = thick.x / 2.0;\n\tfloat halfThick28 = thick.y / 2.0;\n\tfloat halfThick29 = thick.z / 2.0;\n\tfloat halfThick30 = thick.w / 2.0;\n\tfloat halfTh", "\n\tfloat a = pA.x;\n\tfloat b = pB.x;\n\tfloat c = pA.y;\n\tfloat d = pB.y;\n\tfloat e = uv.x;\n\tfloat f = uv.y;\n\tfloat g = thick.x;\n\tfloat h = thick.y;\n\tfloat i = rounded;\n\tfloat j = outlineThick;\n\treturn (a * f + b * e + c * h + d * g) / (a * i + b * j + c * i + d * j);\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat", "\n\t//vec2 uv = (p - vec2(0.5)) * 2.0;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.y += 0.5;\n\t//uv.y *= aspect;\n\t//uv.y -= 0.5;\n\t//uv.y *= aspect;\n\t//uv.y += 0.5;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect;\n\t//uv.x += 0.5;\n\t//uv.x *= aspect;\n\t//uv.x -= 0.5;\n\t//uv.x *= aspect", "\n    float t = dot( ro - cen, nor ) / dot( rd, nor );\n    vec3 pt = ro + t * rd;\n    return ( dot( pt, pt ) - 2. * dot( pt, nor ) * rad + rad * rad ) / dot( rd, rd );\n}\n\n// ray-sphere intersection\nfloat", "\n\tvec3 t1 = (cen - ro) / rd;\n\tvec3 t2 = (cen + rad - ro) / rd;\n\treturn min(t1, t2);\n}\n\n// ray-box intersection (full)\nvec", "\n    vec3 d = pb - pa;\n    float l = length(d);\n    vec3 n = normalize(d);\n    vec3 v = abs(cross(n, vec3(1,0,0)));\n    float x = max(max(pa.x, pb.x), ra) - min(min(pa.x, pb.x), ra);\n    float y = max(max(pa.y, pb.y), ra) - min(min(pa.y, pb.y), ra);\n    float z = max(max(pa.z, pb.z), ra) - min(min(pa.z, pb.z), ra);\n    float mx = max(max(x,y),z);\n    float my = max(abs(dot(n,v)), ra);\n    return bound3( pa - vec3(mx,my,mx), pb + vec3(mx,my,mx) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3(r,r,r), p + vec3(r,r,r) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 p1, in vec3 p2, in vec3 p3 )\n{\n    return bound3( min(min(p1,p2),p3), max(max(p1,p2),p3) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 p1, in vec3 p2, in vec3 p3, in vec3 n1, in vec3 n2, in vec3 n3 )\n{\n    return bound3( min(min(p1,p2),p3), max(max(p1,p2),p3) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a triangle\n//---------------------------------------------------------------------------------------\nbound3 TriangleAABB( in vec3 p1, in vec3 p2, in vec3 p3, in vec3 n", "\n    vec3 e = pb - pa;\n    float a = dot(rd,rd);\n    float b = 2.0 * dot(ro-pa,rd);\n    float c = dot(ro-pa,ro-pa) - ra*ra;\n    float d = b*b - 4.0*a*c;\n    if (d < 0.0) return vec4(0.0,0.0,0.0,0.0);\n    float t = (-b - sqrt(d)) / (2.0*a);\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(p-pa);\n    return vec4(p,n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n\tvec3 t1 = (cen - ro) / rd;\n\tvec3 t2 = (cen - ro + vec3(rad.x, 0, 0)) / rd;\n\tvec3 t3 = (cen - ro + vec3(0, rad.y, 0)) / rd;\n\tvec3 t4 = (cen - ro + vec3(0, 0, rad.z)) / rd;\n\treturn vec2(min(min(min(t1.x, t2.x), t3.x), t4.x), max(max(max(t1.x, t2.x), t3.x), t4.x));\n}\n\n// ray-sphere intersection\nvec", "\n\tvec3 e = pa - pb;\n\tfloat a = dot(rd,rd);\n\tfloat b = dot(rd,e);\n\tfloat c = dot(e,e) - r*r;\n\tfloat d = b*b - a*c;\n\tif (d < 0.0) return -1.0;\n\treturn (-b - sqrt(d)) / a;\n}\n\n// intersect ray with sphere\nfloat", "\n\tvec3 dir = pos - a;\n\tfloat t = r / length( dir );\n\treturn normalize( dir - t * b );\n}\n\n// compute intersection\nvec", "\n\tvec3 t1 = ( ro - rad ) / rd;\n\tvec3 t2 = ( ro + rad ) / rd;\n\treturn min( t1, t2 );\n}\n\n// ray-box intersection in world space\nvec", "\n\tfloat tmin = 0.0;\n\tfloat tmax = max( max( ro.x, ro.y ), ro.z ) + 1.0;\n\tfloat thit = tmin;\n\tfor( int i=0; i<MAX_STEPS; i++ )\n\t{\n\t\tfloat t = intersect_sphere( ro, rd, thit );\n\t\tif( t<0.0 )\n\t\t\tbreak;\n\t\tif( t<thit )\n\t\t\tthit = t;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn vec4( ro + rd*thit, thit );\n}\n\n// raymarch\nvec", "\n\tfloat phi = i * 2.0 * PI / n;\n\tfloat cosPhi = cos(phi);\n\tfloat sinPhi = sin(phi);\n\tfloat cosI = cos(i);\n\tfloat sinI = sin(i);\n\tfloat r = sqrt(1.0 - cosI * cosI);\n\treturn vec3(r * cosPhi, r * sinPhi, sinI);\n}\n\nvec", "\n\tvec3 res = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1.0e10;\n\tfloat tlast = tmax;\n\tfloat tcur = 0.0;\n\tfloat tstep = 0.01;\n\tfloat tmaxstep = 0.1;\n\tfloat tmaxstep2 = tmaxstep * tmaxstep;\n\tfloat tmaxstep3 = tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep4 = tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep5 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep6 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep7 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep8 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep9 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep10 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep11 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep12 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep;\n\tfloat tmaxstep13 = tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep * tmaxstep *", "\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\n\t// Four corners in 2D of a tile\n\tfloat a = random( i );\n\tfloat b = random( i + vec2( 1.0 ) );\n\tfloat c = random( i + vec2( 0.0, 1.0 ) );\n\tfloat d = random( i + vec2( 1.0, 1.0 ) );\n\n\t// Smooth Interpolation\n\tvec2 g = fade( f );\n\n\t// Mix 4 coorners percentages\n\tvec2 e = mix( vec2( a, b ), vec2( c, d ), g );\n\n\t// Mix final noise value\n\treturn mix( vec3( e.x, e.y, p.x ), vec3( e.y, e.x, p.y ), f.y );\n}\n\n// Noise based on <NAME>'s \"improved perlin noise\"\nfloat", "\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat", "\n\treturn vec3(uv.x, uv.y, 0.0);\n}\n\n// Pattern 2\nvec", "\n\treturn vec3(uv.x, uv.y, 0.0);\n}\n\n// Pattern 3\nvec", "\n    return gridTexture( p, ddx, ddy );\n}\n\n// grid ratio\nfloat", "\n\treturn normalize( vec3( dFdx( p.x ), dFdy( p.y ), 0.0 ) );\n}\n\n// compute the normal\nvec", "\n\tv33 c;\n\tc.x=a.y*b.z-a.z*b.y;\n\tc.y=a.z*b.x-a.x*b.z;\n\tc.z=a.x*b.y-a.y*b.x;\n\ta=c;\n}\n\n//this is the same as rayTransp, but it's a bit more efficient\nvoid rayTransp2(inout v33 a,inout v33 b){\n\tv33 c;\n\tc.x=a.y*b.z-a.z*b.y;\n\tc.y=a.z*b.x-a.x*b.z;\n\tc.z=a.x*b.y-a.y*b.x;\n\ta=c;\n}\n\n//this is the same as rayTransp, but it's a bit more efficient\nvoid rayTransp3(inout v33 a,inout v33 b){\n\tv33 c;\n\tc.x=a.y*b.z-a.z*b.y;\n\tc.y=a.z*b.x-a.x*b.z;\n\tc.z=a.x*b.y-a.y*b.x;\n\ta=c;\n}\n\n//this is the same as rayTransp, but it's a bit more efficient\nvoid rayTransp4(inout v33 a,inout v33 b){\n\tv33 c;\n\tc.x=a.y*b.z-a.z*b.y;\n\tc.y=a.z*b.x-a.x*b.z;\n\tc.z=a.x*b.y-a.y*b.x;\n\ta=c;\n}\n\n//this is the same as rayTransp, but it's a bit more efficient\nvoid rayTransp5(inout v33 a,inout v33 b){\n\tv33 c;\n\tc.x=a.y*b.z-a.z*b.y;\n\tc.y=a.z*b.", "\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\nv33 mul(v33 a,float b){\n\treturn v33(a.x*b,a.y*b,a.z*b);\n}\nv33 div(v33 a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\nv33 add(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\nv33 sub(v33 a,v33 b){\n\treturn v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 div(v33 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 add(v33 a,float b){\n\treturn v33(a.x+b,a.y+b,a.z+b);\n}\nv33 sub(v33 a,float b){\n\treturn v33(a.x-b,a.y-b,a.z-b);\n}\nv33 mul(v33 a,float b){\n\treturn v33(a.x*b,a.y*b,a.z*b);\n}\nv33 div(v33 a,float b){\n\treturn v33(a.x/b,a.y/b,a.z/b);\n}\nv33 add(v33 a,v33 b){\n\treturn v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\nv33 sub(v33 a,v33 b){\n\treturn v33(a.x-b.x,", "\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]-b[i][j];\n\treturn c;\n}\n\n//component wise ray multiplication\nv33 mulc(v33 a,v33 b){\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]*b[i][j];\n\treturn c;\n}\n\n//component wise ray division\nv33 divc(v33 a,v33 b){\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]/b[i][j];\n\treturn c;\n}\n\n//component wise ray addition\nv33 addc(v33 a,v33 b){\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]+b[i][j];\n\treturn c;\n}\n\n//component wise ray substraction\nv33 subc(v33 a,v33 b){\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]-b[i][j];\n\treturn c;\n}\n\n//component wise ray multiplication\nv33 mulc(v33 a,v33 b){\n\tv33 c;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<3;j++)\n\t\t\tc[i][j]=a[i][j]*b[i][j];\n\treturn c;\n}\n\n//component wise ray division\nv33 divc(v33 a,v33 b){\n\tv33 c;", "\n\treturn vec2(a[0][1]-a[0][0],a[1][1]-a[1][0]);\n}\n\n//v33-differentials for AB\nvec", "\n\treturn vec2(dot(a[0],b),dot(a[1],b));\n\t//return vec2(dot(a[0],b),dot(a[1],b));\n}\n\n//dual dotproduct on v33s\nvec", "\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,vec3 b){\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c){\n\treturn v33(a.x*b.x*c.x,a.y*b.x*c.x,a.z*b.x*c.x,a.x*b.y*c.x,a.y*b.y*c.x,a.z*b.y*c.x,a.x*b.z*c.x,a.y*b.z*c.x,a.z*b.z*c.x);\n}\n\n//dual mult\nv33 mul(v33 a,v33 b,v33 c,v33 d){\n\treturn v33(a.x*b.x*c.x*d.x,a.y*b.x*c.x*d.x,a.z*b.x*c.x*d.x,a.x*b.y*c.x*d.x,a.", "\n\treturn (int(floor(p.x/w.x))+int(floor(p.y/w.y))+int(floor(p.z/w.z))%2)*0.5;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat", "\n\tvec3 a=vec3(0.5,0.5,0.5);\n\tvec3 b=vec3(0.5,0.5,0.5);\n\tvec3 c=vec3(0.5,0.5,0.5);\n\tvec3 d=vec3(0.5,0.5,0.5);\n\tvec3 e=vec3(0.5,0.5,0.5);\n\tvec3 f=vec3(0.5,0.5,0.5);\n\tvec3 g=vec3(0.5,0.5,0.5);\n\tvec3 h=vec3(0.5,0.5,0.5);\n\tvec3 i=vec3(0.5,0.5,0.5);\n\tvec3 j=vec3(0.5,0.5,0.5);\n\tvec3 k=vec3(0.5,0.5,0.5);\n\tvec3 l=vec3(0.5,0.5,0.5);\n\tvec3 m=vec3(0.5,0.5,0.5);\n\tvec3 n=vec3(0.5,0.5,0.5);\n\tvec3 o=vec3(0.5,0.5,0.5);\n\tvec3 p=vec3(0.5,0.5,0.5);\n\tvec3 q=vec3(0.5,0.5,0.5);\n\tvec3 r=vec3(0.5,0.5,0.5);\n\tvec3 s=vec3(0.5,0.5,0.5);\n\tvec3 t=vec3(0.5,0.5,0.5);\n\tvec3 u=vec3(0.5,0.5,0.5);\n\tvec3 v=vec3(0.5,0.5,0.5);\n\tvec3 w=vec3(0.5,0.5,0.5);\n\tvec3 x=vec3(0.5,0.5,0.5);\n\tvec3 y=vec3", "\n\tv33 n=normalize(s.xyz);\n\tfloat d=dot(n,r.xyz);\n\tfloat t=d-s.w;\n\treturn t;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat", "\n\tvec3 oc = u - s.xyz;\n\tfloat r2 = s.w*s.w;\n\tfloat d2 = dot(oc,oc);\n\treturn d2/r2;\n}\n\n//plane occlusion\nfloat", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p012m = mix(p012, p01, 0.5);\n    vec2 p012p = mix(p012, p12, 0.5);\n    return vec4(p0, p012m, p012p);\n}\n\n// Exact BBox to a cubic bezier\nvec", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    return vec4(p0, p012, p2);\n}\n\n// Approximated BBox to a cubic bezier\nvec", "\n    vec3 min = min( min( p0, p1 ), min( p2, p3 ) );\n    vec3 max = max( max( p0, p1 ), max( p2, p3 ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7 )\n{\n    vec3 min = min( min( min( min( p0, p1 ), p2 ), min( p3, p4 ) ), min( p5, p6 ) );\n    vec3 max = max( max( max( max( p0, p1 ), p2 ), max( p3, p4 ) ), max( p5, p6 ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7, in vec3 p8, in vec3 p9, in vec3 p10, in vec3 p11 )\n{\n    vec3 min = min( min( min( min( min( min( min( min( p0, p1 ), p2 ), p3 ), p4 ), p5 ), p6 ), min( p7, p8 ) ), min( p9, p10 ) );\n    vec3 max = max( max( max( max( max( max( max( max( p0, p1 ), p2 ), p3 ), p4 ), p5 ), p6 ), max( p7, p8 ) ), max( p9, p10 ) );\n    return bound3( min,", "\n    vec2 min = min(p0, min(p1, min(p2, p3)));\n    vec2 max = max(p0, max(p1, max(p2, p3)));\n    return vec4(min, max);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n    return mix(p0123, pos, 0.5);\n}\n\n// Bezier curve with 4 control points.\n//\n// p0, p1, p2, p3 are the control points.\n// pos is the position on the curve.\n//\n// This is a very slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 s1 = cross( rd, e2 );\n\tfloat invDet = 1.0 / dot( s1, e1 );\n\tvec3 d = ro - v0;\n\tfloat u = dot( d, s1 ) * invDet;\n\tif ( u < 0.0 || u > 1.0 )\n\t\treturn vec3( -1.0 );\n\tvec3 s2 = cross( d, e1 );\n\tfloat v = dot( rd, s2 ) * invDet;\n\tif ( v < 0.0 || u + v > 1.0 )\n\t\treturn vec3( -1.0 );\n\tfloat t = dot( e2, s2 ) * invDet;\n\tif ( t > 0.0 )\n\t\treturn vec3( t, u, v );\n\treturn vec3( -1.0 );\n}\n\n// Returns the normal of the triangle at the given barycentric coordinates\nvec", "\n    vec3 edge0 = v1 - v0;\n    vec3 edge1 = v2 - v0;\n    vec3 t = normalize( cross( edge0, edge1 ) );\n    float alpha = dot( t, nor );\n    if ( alpha < 0.0 )\n        return 0.0;\n    float beta = dot( t, pos - v0 );\n    if ( beta < 0.0 || beta > alpha )\n        return 0.0;\n    float gamma = dot( nor, pos );\n    if ( gamma < 0.0 || gamma > alpha + beta )\n        return 0.0;\n    return 1.0;\n}\n\n// Triangle occlusion (if partially visible)\nfloat", "\n    vec2 P = pos - A;\n    vec2 Q = C - A;\n    vec2 R = B - A;\n    float m = dot(Q, Q);\n    float n = dot(P, Q);\n    float o = dot(P, R);\n    float p = dot(R, R);\n    float s = m*p - n*n;\n    float t = m*o - n*o;\n    float u = dot(P, P) - o*o;\n    float v = t/s;\n    float w = u/s;\n    if ( v < 0.0 ) v = 0.0;\n    if ( v > 1.0 ) v = 1.0;\n    if ( w < 0.0 ) w = 0.0;\n    if ( w > 1.0 ) w = 1.0;\n    return length( vec2( v, w ) - vec2( v, w ) );\n}\n\n// signed distance to a cubic bezier\nfloat", "\n\tp = abs(p);\n\treturn min( p.y, min( min(p.x, min(p.x + r1, p.x + r2)), p.x + sqrt(r1*r1 - p.y*p.y) ) ) - he/2.0;\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h ) - ( ra + h * ( rb - ra ) );\n}\n\n// rounded rectangle\nfloat", "\n\tvec3 eps = vec3( 0.001 );\n\tvec3 nor = vec3(\n\t\tcalcSDF( pos + eps.xyy ) - calcSDF( pos - eps.xyy ),\n\t\tcalcSDF( pos + eps.yxy ) - calcSDF( pos - eps.yxy ),\n\t\tcalcSDF( pos + eps.yyx ) - calcSDF( pos - eps.yyx )\n\t);\n\treturn normalize( nor );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        h = max( 0.0, h );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( t>tmax || res<0.001 )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    const float a = 0.9;\n    const float b = 0.5;\n    return fract( a * sin( dot( q, vec2( a, b ) ) ) * 43758.5453 );\n}\n\n// noise\nfloat", "\n    vec2 p = ( vec2( p ) + dot( x.xy(), vec2( 12.9898, 78.233 ) ) ) * 2.0;\n    return fract( sin( p ) * 43758.5453 );\n}\n\n// basic value noise\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    for( int i = 0; i < p; i++ )\n    {\n        v += a * noise( x );\n        x *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fractal noise\nfloat", "\n    return length( p.xy*r.xy + p.z*r.z ) - r.x;\n}\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat", "\n\treturn length( vec3( p.x, p.z, p.z ) ) - r.x;\n}\n\n// symmetric ellipsoid - APPROXIMATE distance\nfloat", "\n\treturn length( p - r ) - r.z;\n}\n\n// generic ellipsoid - good approximated distance\nfloat", "\n\treturn length( p.xy / r.xy + vec2( length( p.xz ) / r.z, length( p.yz ) / r.z ) );\n}\n\n// generic ellipsoid - improved approximated distance\nfloat", "\n    vec2 b = floor( p );\n    vec2 f = fract( p );\n    f = f*f*(3.0-2.0*f);\n    return mix( mix( f.x, 1.0-f.x, b.y ), mix( f.y, 1.0-f.y, b.x ), b.y );\n}\n\nfloat", "\n\treturn a + ( 1.0f - a ) * pow( 1.0f - x, 5.0f );\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n    return (x - p) * 2.0f;\n}\n\n// square wave\nfloat", "\n    vec3 c = vec3( 0.0 );\n    float hh = h * h;\n    float hhh = hh * h;\n    float hhhh = hhh * h;\n    float hhhhh = hhhh * h;\n    float h6 = h * 6.0;\n    float h6_1 = h6 - 1.0;\n    float h6_2 = h6 - 2.0;\n    float h6_3 = h6 - 3.0;\n    float h6_4 = h6 - 4.0;\n    float h6_5 = h6 - 5.0;\n    float h6_6 = h6 - 6.0;\n    float h6_7 = h6 - 7.0;\n    float h6_8 = h6 - 8.0;\n    float h6_9 = h6 - 9.0;\n    float h6_10 = h6 - 10.0;\n    float h6_11 = h6 - 11.0;\n    float h6_12 = h6 - 12.0;\n    float h6_13 = h6 - 13.0;\n    float h6_14 = h6 - 14.0;\n    float h6_15 = h6 - 15.0;\n    float h6_16 = h6 - 16.0;\n    float h6_17 = h6 - 17.0;\n    float h6_18 = h6 - 18.0;\n    float h6_19 = h6 - 19.0;\n    float h6_20 = h6 - 20.0;\n    float h6_21 = h6 - 21.0;\n    float h6_22 = h6 - 22.0;\n    float h6_23 = h6 - 23.0;\n    float h6_24 = h6 - 24.0;\n    float h6_25 = h6 - 25.0;\n    float h6_26 = h6 - 26.0;\n    float h6_27 = h6 - 27.0;\n    float h6_28 = h6 - 28.0;\n    float h6_29 = h6 - 29.0;\n    float h6_30", "\n    vec3 e = pb - pa;\n    float tca = max( 0, dot( ro - pa, e ) / dot( rd, e ) );\n    vec3 p2 = ro + rd * tca;\n    float t2 = clamp( length( p2 - pa ) - r, 0.0, length( pb - p2 ) );\n    float t = min( t2, tca );\n    return t;\n}\n\nfloat", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 proj = a + h * ba;\n    return length(p - proj) - mix(ra, rb, h);\n}\n\nfloat", "\n\tfloat t = -1.0;\n\tif( dot( a, rd ) < 0.0 ) t = -dot( a - ro, rd ) / dot( rd, rd );\n\tif( t > r ) return 0.0;\n\tif( t < 0.0 ) t = r;\n\tfloat d = dot( b - a, b - a );\n\tfloat s = dot( b - a, rd );\n\tfloat t2 = ( s * s - d * ( dot( a, a ) - r * r ) ) / d;\n\tif( t2 > t ) return 0.0;\n\tif( t2 < 0.0 ) t2 = 0.0;\n\tfloat oc = 1.0 - pow( 1.0 - k, t * sqrt( d ) );\n\treturn oc * ( t - t2 ) / t;\n}\n\n// fakesoft shadow occlusion\nfloat", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float s = smoothstep(rad1, rad2, r);\n    return vec2(cos(a) * s, sin(a) * s) * th;\n}\n\nvec", "\n\treturn length(p-c) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat", "\n\tvec3 p = pos;\n\tp.x = abs(p.x);\n\tp.y = abs(p.y);\n\tp.z = abs(p.z);\n\treturn p - vec3(1.0);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec", "\n\tvec2 q = abs(p) - ra;\n\tfloat k = max( q.x, q.y );\n\treturn k*k / (scb.x*scb.x*q.x*q.x + scb.y*scb.y*q.y*q.y);\n}\n\n// The main function\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < 16; i++ )\n    {\n        float h = map( ro + rd*t );\n        h = max( 0.0, h );\n        res = min( res, 8.0*h*h );\n        t += h;\n        if( t > tmax || res < 0.0001 )\n            break;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n\tfloat e = 0.001;\n\tvec3 nor = vec3(\n\t\tcalcSDF( pos + vec3( e, 0.0, 0.0 ), time ) - calcSDF( pos - vec3( e, 0.0, 0.0 ), time ),\n\t\tcalcSDF( pos + vec3( 0.0, e, 0.0 ), time ) - calcSDF( pos - vec3( 0.0, e, 0.0 ), time ),\n\t\tcalcSDF( pos + vec3( 0.0, 0.0, e ), time ) - calcSDF( pos - vec3( 0.0, 0.0, e ), time )\n\t);\n\treturn normalize( nor );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        h = max( 0.0, h );\n        res = min( res, 8.0*h*exp( -6.0*h*h ) );\n        t += h;\n        if( t>tmax || res<0.0001 )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows2/rmshadows2.htm\nfloat", "\n    vec2 f = floor( p );\n    vec2 e = smoothstep( f - vec2( 0.5 ), f + vec2( 0.5 ), p );\n    vec2 g = smoothstep( f + vec2( 0.5 ) - vec2( 1.0 ), f + vec2( 0.5 ) + vec2( 1.0 ), p );\n    return mix( e.x * e.y, g.x * g.y, fract( p ) );\n}\n\nfloat", "\n\treturn k*floor(x/k);\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n    // Get the distance to the light\n    float distance = length(light_dir);\n    // Get the direction of the light\n    vec3 light_dir_norm = normalize(light_dir);\n    // Get the direction of the surface normal\n    vec3 surface_normal_norm = normalize(surface_normal);\n    // Get the angle between the light direction and the surface normal\n    float angle = dot(light_dir_norm, surface_normal_norm);\n    // Get the angle between the light direction and the sample position\n    float angle2 = dot(light_dir_norm, normalize(sample_pos - light_dir));\n    // Get the angle between the sample position and the surface normal\n    float angle3 = dot(normalize(sample_pos - light_dir), surface_normal_norm);\n    // Get the angle between the sample position and the light direction\n    float angle4 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle5 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle6 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle7 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle8 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle9 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle10 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle11 = dot(normalize(sample_pos - light_dir), light_dir_norm);\n    // Get the angle between the sample position and the light direction\n    float angle12", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float distance = 0.0;\n    \n    //the following code is the same as the one in the previous shader\n    //it's just a bit more complicated, since we have to take into account the atmosphere\n    \n    //we first check if the ray intersects the planet\n    if (ray_intersect_sphere(pos, dir, planet_pos, planet_radius)) {\n        //if it does, we compute the distance to the surface\n        distance = ray_sphere_distance(pos, dir, planet_pos, planet_radius);\n        \n        //we then check if the ray intersects the atmosphere\n        if (ray_intersect_sphere(pos, dir, atmosphere_pos, atmosphere_radius)) {\n            //if it does, we compute the distance to the atmosphere\n            float atmosphere_distance = ray_sphere_distance(pos, dir, atmosphere_pos, atmosphere_radius);\n            \n            //we then check if the distance to the atmosphere is smaller than the distance to the surface\n            if (atmosphere_distance < distance) {\n                //if it is, we compute the color of the atmosphere\n                color = atmosphere_color(pos, dir, atmosphere_pos, atmosphere_radius, atmosphere_density, atmosphere_color_density, atmosphere_color_density_exponent, atmosphere_color_density_exponent_scale, atmosphere_color_density_exponent_offset, atmosphere_color_density_exponent_scale_offset, atmosphere_color_density_exponent_offset_offset, atmosphere_color_density_exponent_scale_offset_offset, atmosphere_color_density_exponent_offset_offset_offset, atmosphere_color_density_exponent_scale_offset_offset_offset, atmosphere_color_density_exponent_offset_offset_offset_offset, atmosphere_color_density_exponent_scale_offset_offset_offset_offset, atmosphere_color_density_exponent_offset_offset_offset_offset_offset, atmosphere_color_density_exponent_scale_offset_offset_offset_offset_offset, atmosphere_color_density_exponent_offset_offset_offset_offset_offset_offset, atmosphere_color_density_exponent_scale_", "\n    return normalize(vec3(coord * resolution - resolution * 0.5, 1.0));\n}\n\n/*\nthis function calculates the scattering function\n\nit takes the camera vector, the position of the current pixel, the position of the light source, the light color, the material color, the material roughness, the material metalness, the material normal, the material displacement, the material occlusion, the material emissive, the material environment, the material environment strength, the material environment scale, the material environment rotation, the material environment offset, the material environment normal, the material environment normal strength, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material environment normal rotation, the material environment normal scale, the material environment normal offset, the material", "\n\tfloat r = length(p);\n\tfloat h = sqrt(ra*ra - r*r);\n\tfloat d = dot(p, c);\n\tfloat s = d - h;\n\treturn s;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat", "\n    if (material == 0) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        return vec3(1.0, 0.0, 0.0);\n    } else if (material == 2) {\n        return vec3(0.0, 1.0, 0.0);\n    } else if (material == 3) {\n        return vec3(0.0, 0.0, 1.0);\n    } else if (material == 4) {\n        return vec3(1.0, 1.0, 1.0);\n    } else if (material == 5) {\n        return vec3(1.0, 0.0, 1.0);\n    } else if (material == 6) {\n        return vec3(0.0, 1.0, 1.0);\n    } else if (material == 7) {\n        return vec3(1.0, 1.0, 0.0);\n    } else if (material == 8) {\n        return vec3(0.5, 0.5, 0.5);\n    } else if (material == 9) {\n        return vec3(0.5, 0.0, 0.5);\n    } else if (material == 10) {\n        return vec3(0.0, 0.5, 0.5);\n    } else if (material == 11) {\n        return vec3(0.5, 0.5, 0.0);\n    } else if (material == 12) {\n        return vec3(0.5, 0.0, 0.0);\n    } else if (material == 13) {\n        return vec3(0.0, 0.5, 0.0);\n    } else if (material == 14) {\n        return vec3(0.0, 0.0, 0.5);\n    } else if (material == 15) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 16) {\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 17) {\n        return vec3(0.0,", "\n    return materials[material].reflectivity;\n}\n\n// Get the color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec", "\n    return materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat", "\n    return materials[material].opacity;\n}\n\n// Get color of a material.\n// 0.0 is black.\n// 1.0 is white.\nvec", "\n    vec3 edge1 = tri_b - tri_a;\n    vec3 edge2 = tri_c - tri_a;\n    vec3 dir = line_b - line_a;\n    vec3 pvec = cross(dir, edge2);\n    float det = dot(edge1, pvec);\n    if (det > -EPSILON && det < EPSILON) {\n        return vec3(0, 0, 0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 tvec = line_a - tri_a;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(0, 0, 0);\n    }\n    vec3 qvec = cross(tvec, edge1);\n    float v = dot(dir, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(0, 0, 0);\n    }\n    float t = dot(edge2, qvec) * inv_det;\n    if (t < 0.0 || t > 1.0) {\n        return vec3(0, 0, 0);\n    }\n    return vec3(1, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec", "\n    vec3 normal = cross(tri_b - tri_a, tri_c - tri_a);\n    return normalize(normal);\n}\n\n// Given a triangle, compute the surface normal of that triangle.\nvec", "\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 z = normalize(camera_position - camera_target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return mat3(x, y, z);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\nmat", "\n    cast_ray_result result = {0};\n    float t_min = INFINITY;\n    for (int i = 0; i < scene.num_triangles; i++) {\n        vec3 triangle_normal;\n        vec3 triangle_vertices[3];\n        vec3 triangle_centroid;\n        vec3 triangle_edge1;\n        vec3 triangle_edge2;\n        vec3 triangle_edge3;\n        vec3 triangle_edge1_perp;\n        vec3 triangle_edge2_perp;\n        vec3 triangle_edge3_perp;\n        vec3 triangle_edge1_perp_normal;\n        vec3 triangle_edge2_perp_normal;\n        vec3 triangle_edge3_perp_normal;\n        vec3 triangle_edge1_perp_normal_cross;\n        vec3 triangle_edge2_perp_normal_cross;\n        vec3 triangle_edge3_perp_normal_cross;\n        vec3 triangle_edge1_perp_normal_cross_cross;\n        vec3 triangle_edge2_perp_normal_cross_cross;\n        vec3 triangle_edge3_perp_normal_cross_cross;\n        vec3 triangle_edge1_perp_normal_cross_cross_cross;\n        vec3 triangle_edge2_perp_normal_cross_cross_cross;\n        vec3 triangle_edge3_perp_normal_cross_cross_cross;\n        vec3 triangle_edge1_perp_normal_cross_cross_cross_cross;\n        vec3 triangle_edge2_perp_normal_cross_cross_cross_cross;\n        vec3 triangle_edge3_perp_normal_cross_cross_cross_cross;\n        vec3 triangle_edge1_perp_normal_cross_cross_cross_cross_cross;\n        vec3 triangle_edge2_perp_normal_cross_cross_cross_cross_cross;\n        vec3 triangle_edge3_perp_normal_cross_cross_cross_cross_cross;\n        vec3 triangle_edge1_perp_normal_cross_cross_cross_cross_cross_cross;\n        vec3 triangle_edge2_perp_normal_cross_cross_cross_cross_cross_cross;\n        vec3 triangle_", "\n    // TODO: Implement this function.\n    // Hint: You can use the same ray-casting code as in the\n    // previous assignment.\n    // Hint: You can use the same shadow_ray_origin and shadow_ray_target\n    // variables as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light variable as in\n    // the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction variable\n    // as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_length variable\n    // as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared_reciprocal\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared_reciprocal_times_shadow_ray_length\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared_reciprocal_times_shadow_ray_length_times_shadow_ray_length\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared_reciprocal_times_shadow_ray_length_times_shadow_ray_length_times_shadow_ray_length\n    // variable as in the previous assignment.\n    // Hint: You can use the same shadow_ray_origin_to_light_direction_normalized_squared_reciprocal_times_shadow_ray_length_times_shadow_ray_length_times_shadow_ray_length_times_shadow_ray_length\n    // variable as in the previous assignment.", "\n    return bnoise( x, 0.0 );\n}\n\n// Basic noise\nfloat", "\n    return fract( sin( p ) * 43758.5453 );\n}\n\n// Classic Perlin noise, 3D version\nfloat", "\n\tn = (n+0.5) * 1220703125;\n\tn = (n ^ (n >> 2)) * 1640531513;\n\tn = (n ^ (n >> 4)) * 6043988245;\n\tn = (n ^ (n >> 17)) * 2654435769;\n\treturn (float)n / (float)0x80000000;\n}\n\n// integer hash copied from Hugo Elias\nint", "\n    return fract( sin( p ) * 43758.5453123 );\n}\n\n// noise\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    float x0 = x;\n    for( int i = 0; i < 4; i++ )\n    {\n        v += a * noise( x0 );\n        x0 *= 2.0;\n        a *= G;\n    }\n    return v;\n}\n\n// fbm2\nfloat", "\n    float a = 1.0 - p.z;\n    float b = -2.0 * p.z;\n    float c = p.z * p.z - 1.0;\n    float d = b * b - 4.0 * a * c;\n    float t = sqrt( d );\n    float t0 = (-b - t) / (2.0 * a);\n    float t1 = (-b + t) / (2.0 * a);\n    vec3 color = vec3( 0.0 );\n    if ( t0 >= 0.0 && t0 <= 1.0 )\n    {\n        color += vec3( 1.0, 0.0, 0.0 ) * ( 1.0 - t0 );\n    }\n    if ( t1 >= 0.0 && t1 <= 1.0 )\n    {\n        color += vec3( 0.0, 1.0, 0.0 ) * ( 1.0 - t1 );\n    }\n    return color;\n}\n\nvoid main()\n{\n    vec3 p = vec3( 0.0 );\n    p.x = cos( u ) * sin( v );\n    p.y = sin( u ) * sin( v );\n    p.z = cos( v );\n    gl_FragColor = vec4( getColor( p ), 1.0 );\n}\n`;\n\nexport {\n    vertexShader,\n    fragmentShader\n};\n\n", "\n\tfloat a = 1.0 + pb.x;\n\tfloat b = 1.0 + pb.y;\n\tfloat c = 1.0 + pb.z;\n\tfloat d = 1.0 - pb.x - pb.y - pb.z;\n\tfloat n = a*a*a*a - b*b*b*b - c*c*c*c + d*d*d*d;\n\tfloat m = a*a*a - 3.0*a*b*b + b*b*b*b + 3.0*a*c*c - 3.0*a*d*d - c*c*c + 3.0*c*d*d + d*d*d*d;\n\tfloat k = a*a - 3.0*a*b + 3.0*b*b*b - 3.0*b*c*c + c*c*c*c - 3.0*c*d*d + d*d*d*d*d;\n\tfloat j = a - 3.0*b + 3.0*c*c - d*d*d;\n\tfloat i = 1.0 - a + 3.0*b - 3.0*c*c + d*d;\n\tfloat h = 1.0 - a*a + b*b*b - c*c*c*c + d*d*d*d*d;\n\tfloat g = 1.0 - a*a*a + b*b*b*b - c*c*c*c*c*c + d*d*d*d*d*d*d;\n\tfloat f = 1.0 - a*a*a*a + b*b*b*b*b*b*b - c*c*c*c*c*c*c*c*c*c*c + d*d*d*d*d*d*d*d*d*d*d*d;\n\tfloat e = 1.0 - a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a", "\n    vec3 tmin, tmax, tdelta;\n    tmin = ( cen - rad - ro ) / rd;\n    tmax = ( cen + rad - ro ) / rd;\n    tdelta = min( tmin, tmax );\n    return max( tmin, min( tmax, tdelta ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec3 t = (ro - cen) / rd;\n    vec3 offset_ro = ro + rd * t * 0.0001;\n    vec3 offset_cen = cen + rd * t * 0.0001;\n    vec3 offset_rd = rd;\n    float tmin = 0.0;\n    float tmax = 1.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        vec3 ro_t = (offset_ro - offset_cen) / offset_rd;\n        float t_ = ro_t.x;\n        if( t_ > tmin && t_ < tmax )\n        {\n            tmin = max( tmin, t_ );\n            tmax = min( tmax, t_ );\n        }\n        t_ = ro_t.y;\n        if( t_ > tmin && t_ < tmax )\n        {\n            tmin = max( tmin, t_ );\n            tmax = min( tmax, t_ );\n        }\n        t_ = ro_t.z;\n        if( t_ > tmin && t_ < tmax )\n        {\n            tmin = max( tmin, t_ );\n            tmax = min( tmax, t_ );\n        }\n    }\n    return tmin;\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    float t = mint;\n    float s = 0.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = texture(shadowMap, ro + rd * t).r;\n        s += h * h;\n        t += h;\n        if (t > tmax)\n            break;\n    }\n    return s * w / t;\n}\n\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat", " return seed = (seed * 214013L + 2531011L) / 65536L; }\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n", "\n\treturn a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Noise Function\n//https://www.shadertoy.com/view/lsfGz2\nfloat", "\n\tvec3 q = abs(p) - vec3(la,lb,h);\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat", "\n\tvec2 d = b - a;\n\tfloat t = clamp( (p.x - a.x) / d.x, 0.0, 1.0 );\n\tvec2 proj = a + d * t;\n\tvec2 projOff = proj - p;\n\tfloat dd = dot( projOff, projOff );\n\tfloat dist = sqrt( dd );\n\tfloat per = (1.0-t) * d.y + t * (d.x < 0.0? -d.y : d.y);\n\tfloat perp = abs(d.x) * max(0.0,p.y-a.y) + abs(d.y) * max(0.0,p.x-a.x);\n\tfloat totalPer = per + perp;\n\tfloat bandDist = abs(dist - r) - band;\n\tfloat bandDist2 = abs(dist - r) - band;\n\tfloat bandDist3 = abs(dist - r) - band;\n\tfloat bandDist4 = abs(dist - r) - band;\n\tfloat bandDist5 = abs(dist - r) - band;\n\tfloat bandDist6 = abs(dist - r) - band;\n\tfloat bandDist7 = abs(dist - r) - band;\n\tfloat bandDist8 = abs(dist - r) - band;\n\tfloat bandDist9 = abs(dist - r) - band;\n\tfloat bandDist10 = abs(dist - r) - band;\n\tfloat bandDist11 = abs(dist - r) - band;\n\tfloat bandDist12 = abs(dist - r) - band;\n\tfloat bandDist13 = abs(dist - r) - band;\n\tfloat bandDist14 = abs(dist - r) - band;\n\tfloat bandDist15 = abs(dist - r) - band;\n\tfloat bandDist16 = abs(dist - r) - band;\n\tfloat bandDist17 = abs(dist - r) - band;\n\tfloat bandDist18 = abs(dist - r) - band;\n\tfloat bandDist19 = abs(dist - r) - band;\n\tfloat bandDist20 = abs(dist - r) - band;\n\tfloat bandDist21 =", "\n    vec2 d = abs(p) - b;\n    vec2 g = max(d,0.0);\n    float q = min(dot(d,d),dot(g,g));\n    float n = length(p);\n    return vec4( q, q-r*r, q-s*s, n );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n\tvec2 d = abs(p) - b;\n\treturn vec3( max( d.x, d.y ), sign( d.x ) * sign( d.y ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 d = abs(p) - r;\n\tvec2 g = abs(d) / r - band;\n\treturn vec4( min(max(g.x,g.y),0.0) * 10.0, dot(p,p), length(p), length(d) );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 e = verts[0] - p;\n    float min = dot(e,e);\n    float min2 = min;\n    for(int i=1; i<5; i++)\n    {\n        e = verts[i] - p;\n        float e2 = dot(e,e);\n        if(e2<min) min=e2;\n    }\n    return sqrt(min) - r;\n}\n\n// https://www.shadertoy.com/view/XdXGW8\nfloat", "\n\tvec2 d = vec2(0.0);\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d43 = 0.0;\n\tfloat d44 = 0.0;\n\tfloat d45 = 0.0;\n\tfloat d46 = 0.0;\n\tfloat d47 = 0.0;\n\tfloat d48 = 0.0;\n\tfloat d49 = 0.0;\n\tfloat d50 = 0.0;\n\tfloat d51 = 0.0", "\n\tvec2 d = b - a;\n\tfloat t = clamp( (p.x - a.x) / d.x, 0.0, 1.0 );\n\tvec2 q = a + d * t;\n\tvec2 dq = q - p;\n\treturn vec3( t, dq.x, dq.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 q = p - vec2(r, 0.0);\n\tvec2 r2 = p - vec2(0.0, r);\n\tvec2 r3 = p - vec2(r, r);\n\tvec2 r4 = p - vec2(0.0, -r);\n\tvec2 r5 = p - vec2(-r, 0.0);\n\tvec2 r6 = p - vec2(0.0, -r);\n\tvec2 r7 = p - vec2(-r, -r);\n\tvec2 r8 = p - vec2(-r, r);\n\tvec2 r9 = p - vec2(r, -r);\n\tvec2 r10 = p - vec2(-r, r);\n\tvec2 r11 = p - vec2(r, r);\n\tvec2 r12 = p - vec2(-r, -r);\n\tvec2 r13 = p - vec2(r, -r);\n\tvec2 r14 = p - vec2(-r, r);\n\tvec2 r15 = p - vec2(-r, -r);\n\tvec2 r16 = p - vec2(r, r);\n\tvec2 r17 = p - vec2(-r, -r);\n\tvec2 r18 = p - vec2(r, -r);\n\tvec2 r19 = p - vec2(-r, r);\n\tvec2 r20 = p - vec2(r, -r);\n\tvec2 r21 = p - vec2(-r, r);\n\tvec2 r22 = p - vec2(r, r);\n\tvec2 r23 = p - vec2(-r, -r);\n\tvec2 r24 = p - vec2(r, -r);\n\tvec2 r25 = p - vec2(-r, r);\n\tvec2 r26 = p - vec2(-r, -r);\n\tvec2 r27 = p - vec2(r, r);\n\tvec2 r28 = p - vec2(-r, r);\n\tvec2 r29 = p - vec2(r, -r);\n\tvec2 r30 = p - vec2(-r, -r);\n\tvec2 r31 = p", "\n\tvec3 p1 = X[0].xyz;\n\tvec3 p2 = X[1].xyz;\n\tvec3 p3 = X[2].xyz;\n\tvec3 p4 = X[3].xyz;\n\tvec3 p5 = X[4].xyz;\n\tvec3 p6 = X[5].xyz;\n\tvec3 p7 = X[6].xyz;\n\tvec3 p8 = X[7].xyz;\n\tvec3 p9 = X[8].xyz;\n\tvec3 p10 = X[9].xyz;\n\tvec3 p11 = X[10].xyz;\n\tvec3 p12 = X[11].xyz;\n\tvec3 p13 = X[12].xyz;\n\tvec3 p14 = X[13].xyz;\n\tvec3 p15 = X[14].xyz;\n\tvec3 p16 = X[15].xyz;\n\tvec3 p17 = X[16].xyz;\n\tvec3 p18 = X[17].xyz;\n\tvec3 p19 = X[18].xyz;\n\tvec3 p20 = X[19].xyz;\n\tvec3 p21 = X[20].xyz;\n\tvec3 p22 = X[21].xyz;\n\tvec3 p23 = X[22].xyz;\n\tvec3 p24 = X[23].xyz;\n\tvec3 p25 = X[24].xyz;\n\tvec3 p26 = X[25].xyz;\n\tvec3 p27 = X[26].xyz;\n\tvec3 p28 = X[27].xyz;\n\tvec3 p29 = X[28].xyz;\n\tvec3 p30 = X[29].xyz;\n\tvec3 p31 = X[30].xyz;\n\tvec3 p32 = X[31].xyz;\n\tvec3 p33 = X[32].xyz;\n\tvec3 p34 = X[33].xyz;\n\tvec3 p35 = X[34].xyz;\n\tvec3 p36 = X[35].xyz;\n\tvec3 p37 = X[36].xyz;\n\tvec3 p38 = X[37].xyz;\n\tvec3 p39 = X[38].xyz;\n\tvec3 p", "\n\tif (b.x == 0.0) {\n\t\tb.x = 0.000000001;\n\t}\n\tif (b.y == 0.0) {\n\t\tb.y = 0.000000001;\n\t}\n\tif (b.z == 0.0) {\n\t\tb.z = 0.000000001;\n\t}\n\treturn a / b;\n}\n\nvec", "\n\treturn vec3(p.x, cos(a)*p.y - sin(a)*p.z, sin(a)*p.y + cos(a)*p.z);\n}\n\nvec", "\n\treturn 1.0f - (x / R);\n}\n\n// Returns the distance between two points\nfloat", "\n\treturn (e / R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// d: distance\nfloat", "\n\tfloat k = 0.0f;\n\tif (a < b)\n\t{\n\t\tk = (a - b) / (R * R);\n\t}\n\telse\n\t{\n\t\tk = (b - a) / (R * R);\n\t}\n\treturn k * e;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat", "\n    return exp(-dot(p-c,p-c)/R/R) * e;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n\tvec3 ab = b - a;\n\tfloat d = dot(ab, ab);\n\tfloat r = R + e;\n\tfloat s = dot(ab, c - a);\n\tfloat t = dot(ab, c - b);\n\tfloat s2 = s * s;\n\tfloat t2 = t * t;\n\tfloat s_t = s + t;\n\tfloat s_t2 = s_t * s_t;\n\tfloat s_t3 = s_t2 * s_t;\n\tfloat s_t4 = s_t3 * s_t;\n\tfloat s_t5 = s_t4 * s_t;\n\tfloat s_t6 = s_t5 * s_t;\n\tfloat s_t7 = s_t6 * s_t;\n\tfloat s_t8 = s_t7 * s_t;\n\tfloat s_t9 = s_t8 * s_t;\n\tfloat s_t10 = s_t9 * s_t;\n\tfloat s_t11 = s_t10 * s_t;\n\tfloat s_t12 = s_t11 * s_t;\n\tfloat s_t13 = s_t12 * s_t;\n\tfloat s_t14 = s_t13 * s_t;\n\tfloat s_t15 = s_t14 * s_t;\n\tfloat s_t16 = s_t15 * s_t;\n\tfloat s_t17 = s_t16 * s_t;\n\tfloat s_t18 = s_t17 * s_t;\n\tfloat s_t19 = s_t18 * s_t;\n\tfloat s_t20 = s_t19 * s_t;\n\tfloat s_t21 = s_t20 * s_t;\n\tfloat s_t22 = s_t21 * s_t;\n\tfloat s_t23 = s_t22 * s_t;\n\tfloat s_t24 = s_t23 * s_t;\n\tfloat s_t25 = s_t24 * s_t;\n\tfloat s_t26 = s_t25 * s_t;\n", "\n    float d = length(p);\n    return d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*d*", "\n\treturn (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y) + (b.z - a.z) * (b.z - a.z);\n}\n\n// K root\nfloat", "\n    vec3 normal = normalize(cross(dFdx(p), dFdy(p)));\n    return normal;\n}\n\n// Evaluate the normal of the surface at a point\nvec", "\n    float t = 0.0;\n    float d = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float r2_inv = 0.0;\n    float t_max = 0.0;\n    float t_min = 0.0;\n    float t_hit = 0.0;\n    float t_hit_max = 0.0;\n    float t_hit_min = 0.0;\n    float t_hit_step = 0.0;\n    float t_hit_step_max = 0.0;\n    float t_hit_step_min = 0.0;\n    float t_hit_step_inv = 0.0;\n    float t_hit_step_inv_max = 0.0;\n    float t_hit_step_inv_min = 0.0;\n    float t_hit_step_inv_max_inv = 0.0;\n    float t_hit_step_inv_min_inv = 0.0;\n    float t_hit_step_inv_max_inv_max = 0.0;\n    float t_hit_step_inv_min_inv_min = 0.0;\n    float t_hit_step_inv_max_inv_min = 0.0;\n    float t_hit_step_inv_min_inv_max = 0.0;\n    float t_hit_step_inv_max_inv_max_inv = 0.0;\n    float t_hit_step_inv_min_inv_min_inv = 0.0;\n    float t_hit_step_inv_max_inv_min_inv = 0.0;\n    float t_hit_step_inv_min_inv_max_inv = 0.0;\n    float t_hit_step_inv_max_inv_max_inv_max = 0.0;\n    float t_hit_step_inv_min_inv_min_inv_min = 0.0;\n    float t_hit_step_inv_max_inv_min_inv_max = 0.0;\n    float t_hit_step_inv_min_inv_max_inv_min = 0.", "\n\tfloat t = 0.0;\n\tfloat dt = 0.0;\n\tfloat tmax = 1.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;\n\tfloat t43 = 0.0;\n\tfloat t44 = 0.0;\n\tfloat t45 = 0.0;\n\tfloat t", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat", "\n    vec3 ro2 = ro - rad;\n    vec3 rd2 = rd - rad;\n    vec3 r = ro2 - rd2;\n    vec3 k = 2.0 * dot( r, rd2 );\n    vec3 q = k + k + ro2;\n    vec3 t = -k - k + ro2;\n    vec3 o = max( q, t );\n    return sign( o ) * sqrt( max( 0.0, o * o - q * t ) ) + min( abs( q ), abs( t ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    return coord / (1.0 + coord.x + coord.y);\n}\n\n// normalized fragment coordinate\nvec", "\n\tvec2 r = q - p;\n\tfloat a = length(r);\n\tfloat b = length(vec2(r.y, -r.x));\n\tfloat c = length(vec2(-r.y, r.x));\n\tfloat s = (a + b + c) / 2.0;\n\tfloat A = sqrt(s * (s - a) * (s - b) * (s - c));\n\tfloat d = 2 * A / a;\n\treturn vec3(d, 0.0, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 q = p - vec2(0.5, 0.5);\n\tfloat r2 = r * r;\n\tfloat d2 = d * d;\n\tfloat r2d2 = r2 * d2;\n\tfloat r2d2q2 = r2d2 * dot(q, q);\n\tfloat r2d2q2_2 = r2d2q2 * r2d2q2;\n\tfloat r2d2q2_3 = r2d2q2_2 * r2d2q2;\n\tfloat r2d2q2_4 = r2d2q2_3 * r2d2q2;\n\tfloat r2d2q2_5 = r2d2q2_4 * r2d2q2;\n\tfloat r2d2q2_6 = r2d2q2_5 * r2d2q2;\n\tfloat r2d2q2_7 = r2d2q2_6 * r2d2q2;\n\tfloat r2d2q2_8 = r2d2q2_7 * r2d2q2;\n\tfloat r2d2q2_9 = r2d2q2_8 * r2d2q2;\n\tfloat r2d2q2_10 = r2d2q2_9 * r2d2q2;\n\tfloat r2d2q2_11 = r2d2q2_10 * r2d2q2;\n\tfloat r2d2q2_12 = r2d2q2_11 * r2d2q2;\n\tfloat r2d2q2_13 = r2d2q2_12 * r2d2q2;\n\tfloat r2d2q2_14 = r2d2q2_13 * r2d2q2;\n\tfloat r2d2q2_15 = r2d2q2_14 * r2d2q2;\n\tfloat r2d2q2_16 = r2d2q2_15 * r2d2q2;\n\tfloat r2d2q2_17 = r2d2q2_16", "\n\treturn vec3( p.x, p.y, sqrt( 1.0 - dot( p, p ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec", "\n\tvec3 e0 = v[1] - v[0];\n\tvec3 e1 = v[2] - v[0];\n\tvec3 e2 = v[0] - p;\n\n\tfloat a = -dot(e0, e2);\n\tfloat b = dot(e0, e1);\n\tfloat c = -dot(e1, e2);\n\tfloat d = dot(e0, e0);\n\tfloat e = dot(e1, e1);\n\tfloat f = dot(e2, e2);\n\n\tfloat det = a*e + b*f + c*d;\n\tfloat s = (a*e2[0] + b*e2[1] + c*d) / det;\n\tfloat t = (a*e1[0] + b*e1[1] + c*e0[0]) / det;\n\n\treturn vec3(s, t, 1.0 - s - t);\n}\n\n// Compute the barycentric coordinates of a point in a triangle\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 q = p*sca;\n\tvec2 r = p*scb;\n\tfloat d = length(q);\n\tfloat e = length(r);\n\tfloat f = d*d + e*e - ra*ra - rb*rb;\n\tfloat g = sqrt( max( 0.0, f ) );\n\tvec2 h = (q*rb + r*ra)/d;\n\tvec2 i = (q*rb - r*ra)/d;\n\tvec3 j = vec3( h, g, i );\n\treturn normalize( j );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec", "\n\treturn dot( a, b );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n\tvec2 q = p / ab;\n\tfloat r = 1.0 / (1.0 + dot(q, q));\n\treturn vec3( r, r*q.x, r*q.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 q = p;\n    q.x = mod(q.x, 2.0*ra) - ra;\n    q.y = mod(q.y, 2.0*rb) - rb;\n    float r = length(q);\n    float d = r - ra;\n    float d2 = d*d;\n    float d4 = d2*d2;\n    float d6 = d4*d2;\n    float d8 = d6*d2;\n    float d10 = d8*d2;\n    float d12 = d10*d2;\n    float d14 = d12*d2;\n    float d16 = d14*d2;\n    float d18 = d16*d2;\n    float d20 = d18*d2;\n    float d22 = d20*d2;\n    float d24 = d22*d2;\n    float d26 = d24*d2;\n    float d28 = d26*d2;\n    float d30 = d28*d2;\n    float d32 = d30*d2;\n    float d34 = d32*d2;\n    float d36 = d34*d2;\n    float d38 = d36*d2;\n    float d40 = d38*d2;\n    float d42 = d40*d2;\n    float d44 = d42*d2;\n    float d46 = d44*d2;\n    float d48 = d46*d2;\n    float d50 = d48*d2;\n    float d52 = d50*d2;\n    float d54 = d52*d2;\n    float d56 = d54*d2;\n    float d58 = d56*d2;\n    float d60 = d58*d2;\n    float d62 = d60*d2;\n    float d64 = d62*d2;\n    float d66 = d64*d2;\n    float d68 = d66*d2;\n    float d70 = d68*d2;\n    float d72 = d70*d2;\n    float d74 = d72*d2;\n    ", "\n\tvec3 d = b - a;\n\tfloat l = length( d );\n\td /= l;\n\tvec3 n = normalize( cross( d, vec3( 0.0, 1.0, 0.0 ) ) );\n\tvec3 t = normalize( cross( n, d ) );\n\tvec3 p0 = p - a;\n\tfloat t0 = dot( p0, t );\n\tfloat n0 = dot( p0, n );\n\tfloat r0 = l - r;\n\tvec3 p1 = p - b;\n\tfloat t1 = dot( p1, t );\n\tfloat n1 = dot( p1, n );\n\tfloat r1 = l - r;\n\tvec3 p2 = p - a;\n\tfloat t2 = dot( p2, t );\n\tfloat n2 = dot( p2, n );\n\tfloat r2 = r;\n\tvec3 p3 = p - b;\n\tfloat t3 = dot( p3, t );\n\tfloat n3 = dot( p3, n );\n\tfloat r3 = r;\n\tvec3 p4 = p - a;\n\tfloat t4 = dot( p4, t );\n\tfloat n4 = dot( p4, n );\n\tfloat r4 = r;\n\tvec3 p5 = p - b;\n\tfloat t5 = dot( p5, t );\n\tfloat n5 = dot( p5, n );\n\tfloat r5 = r;\n\tvec3 p6 = p - a;\n\tfloat t6 = dot( p6, t );\n\tfloat n6 = dot( p6, n );\n\tfloat r6 = r;\n\tvec3 p7 = p - b;\n\tfloat t7 = dot( p7, t );\n\tfloat n7 = dot( p7, n );\n\tfloat r7 = r;\n\tvec3 p8 = p - a;\n\tfloat t8 = dot( p8, t );\n\tfloat n8 = dot( p8, n );\n\tfloat r8 = r;\n\tvec3 p9 = p - b;\n\tfloat t9 = dot( p9, t );\n\tfloat n9 = dot( p", "\n\tvec2 d = abs(p) - vec2(wi, he);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - sk;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset)\nfloat", "\n\tvec2 p0 = vec2( -wi, -he );\n\tvec2 p1 = vec2(  wi, -he );\n\tvec2 p2 = vec2(  wi,  he );\n\tvec2 p3 = vec2( -wi,  he );\n\n\tvec2 p0p1 = p1 - p0;\n\tvec2 p0p2 = p2 - p0;\n\tvec2 p0p3 = p3 - p0;\n\n\tvec2 p0p = p - p0;\n\tvec2 p1p = p - p1;\n\tvec2 p2p = p - p2;\n\tvec2 p3p = p - p3;\n\n\tfloat a = dot( p0p1, p0p1 );\n\tfloat b = dot( p0p2, p0p2 );\n\tfloat c = dot( p0p3, p0p3 );\n\n\tfloat d = dot( p0p1, p0p2 );\n\tfloat e = dot( p0p2, p0p3 );\n\tfloat f = dot( p0p3, p0p1 );\n\n\tfloat g = dot( p0p1, p0p );\n\tfloat h = dot( p0p2, p0p );\n\tfloat i = dot( p0p3, p0p );\n\n\tfloat j = dot( p0p1, p0p2 );\n\tfloat k = dot( p0p2, p0p3 );\n\tfloat l = dot( p0p3, p0p1 );\n\n\tfloat m = a * e - b * d;\n\tfloat n = a * k - c * d;\n\tfloat o = a * f - c * j;\n\tfloat p = b * k - c * j;\n\tfloat q = b * f - c * l;\n\tfloat r = c * d - a * k;\n\tfloat s = c * j - b * f;\n\tfloat t = c * l - a * q;\n\n\tfloat u = g * p - h * o;\n\tfloat v = h * r - i * n;\n\tfloat w = i * o - g * q;\n\n\tfloat x = ( u", "\n\treturn (p*c);\n\t}\n\nfloat", "\n    return (a < b)? a : b - k;\n}\n\n// IQ's polynominal max\nfloat", "\n\tp = p - size * floor(p * (1.0 / size));\n\treturn p * size;\n}\n\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n\tvec3 oc = ro - s.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - s.w * s.w;\n\tfloat h = b * b - c;\n\tif (h == 0.0) return vec2(0.0, -b / rd.z);\n\tif (h > 0.0) return vec2(-b - sqrt(h), -b / rd.z);\n\treturn vec2(-b, -b / rd.z);\n}\n\n// IQ's ray plane intersection\nvec", "\n    vec3 t1 = (boxSize - ro) / rd;\n    vec3 t2 = (boxSize * -1.0 - ro) / rd;\n    outNormal = sign(rd) * step(t1, t2) * sign(t1) * sign(t2);\n    return min(t1, t2);\n}\n\n// IQ's ray box intersection\nvec", "\n\te1 = p + d.xy;\n\te2 = p + d.yx;\n\te3 = p - d.xy;\n\te4 = p - d.yx;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n\te1 = p + d.xy;\n\te2 = p + d.yx;\n\te3 = p - d.xy;\n\te4 = p - d.yx;\n\te5 = p + d.x;\n\te6 = p - d.x;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\te1 = p + d.xy;\n\te2 = p + d.yx;\n\te3 = p - d.xy;\n\te4 = p - d.yx;\n\te5 = p + d.x;\n\te6 = p - d.x;\n\te7 = p + d.y;\n\te8 = p - d.y;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8, inout vec2 e9, inout vec2 e10)", "\n\tvec2 ba = p - a;\n\tvec2 bax = b - a;\n\treturn length(ba - dot(ba, bax) / dot(bax, bax) * bax);\n}\n\nfloat", "\n    // The arrow head is a cone.\n    float h = length( b - a );\n    float r = h * w1;\n    float d = length( p - a );\n    float t = clamp( ( d - r ) / w2, 0.0, 1.0 );\n    return h * t;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 I = vec2(ro.x, ro.z);\n    vec2 D = vec2(rd.x, rd.z);\n    float t = dot(I, D);\n    float DD = dot(D, D);\n    float II = dot(I, I);\n    float discriminant = pow(t*t + II*DD - tor.x*tor.x*DD - tor.y*tor.y*II,.5);\n    float result = (t + discriminant) / DD;\n    return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    vec2 p = pos.xz - tor.xy;\n    float d = length(p);\n    return normalize(vec3(p, tor.y + tor.x * pos.y / d));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat", "\n    float y = fabs(x);\n    if (y > 4.0f) {\n        return (x > 0.0f)? 1.0f : -1.0f;\n    }\n    float y2 = y * y;\n    return x * (1.0f + y2 * (0.9675f + y2 * (0.3094f + y2 * 0.0848f)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec3 col2 = col;\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b * 0.6, col2.r * 0.6 + col2.g * 0.3 + col2.b * 0.11);\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b * 0.6, col2.r * 0.6 + col2.g * 0.3 + col2.b * 0.11);\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b * 0.6, col2.r * 0.6 + col2.g * 0.3 + col2.b * 0.11);\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b * 0.6, col2.r * 0.6 + col2.g * 0.3 + col2.b * 0.11);\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b * 0.6, col2.r * 0.6 + col2.g * 0.3 + col2.b * 0.11);\n    col2 = vec3(col2.r * 0.3 + col2.g * 0.59 + col2.b * 0.11, col2.r * 0.3 + col2.g * 0.3 + col2.b *", "\n\tp = p - size * floor(p * (1.0 / size));\n\treturn p * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// License: Unknown, author: <NAME>, found: https://www.shadertoy.com/view/XsX3z4\nfloat", "\n    return length(p-c)-r;\n}\n\n// signed distance to a cylinder\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa,ba)/dot(ba,ba);\n}\n\n// distance to a triangle\nfloat", "\n\treturn (a.x - b.x) * (a.y + b.y);\n}\n\n// signed distance to a 3D triangle\nfloat", "\n\tp = abs(p);\n\treturn min( p.x, min(p.y, min(sqrt(dot(p,p))-s, max(p.x-s, p.y-s))));\n}\n\n// s = side length\n// r = corner radius\nfloat", "\n    return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// https://www.shadertoy.com/view/XsXGW8\nfloat", "\n    vec3 a = abs(x) - 1.0;\n    return vec3(a, a * a, a * a * a);\n}\n\n// cubic hermite spline\nvec", "\n    float d = length(p);\n    float a = atan(p.y, p.x) * k;\n    return smoothstep(0.0, 1.0, -pow(d/w, 2.0) + pow(sin(a), 2.0));\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat", "\n    // The optical depth is in units of cm.\n    // The transmittance is in units of cm^-1.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n    // The transmittance is calculated by integrating the optical depth\n    // over the wavelength range.\n", "\n\t// Calculate the optical depth along the ray.\n\tfloat opticalDepth = 0.0;\n\tfor (int i = 0; i < NUM_SCATTERING_LAYERS; i++)\n\t{\n\t\tfloat distance = rayLength * (i + 1) / NUM_SCATTERING_LAYERS;\n\t\tfloat stepSize = distance / NUM_SCATTERING_STEPS;\n\t\tfloat step = 0.0;\n\t\tfor (int j = 0; j < NUM_SCATTERING_STEPS; j++)\n\t\t{\n\t\t\tfloat stepDistance = stepSize * (j + 1);\n\t\t\tfloat stepLength = min(stepDistance, rayLength - step);\n\t\t\tfloat stepRayLength = min(stepLength, distance);\n\t\t\tvec3 stepRayStart = rayStart + rayDir * step;\n\t\t\tvec3 stepRayDir = normalize(lightDir - stepRayStart);\n\t\t\tvec3 stepTransmittance = exp(-stepRayLength * GetScatteringCoefficient(i));\n\t\t\topticalDepth += stepTransmittance.r + stepTransmittance.g + stepTransmittance.b;\n\t\t\tstep += stepRayLength;\n\t\t}\n\t}\n\n\t// Calculate the transmittance.\n\ttransmittance = exp(-opticalDepth * rayLength);\n\n\t// Calculate the scattering.\n\tvec3 scattering = vec3(0.0);\n\tfor (int i = 0; i < NUM_SCATTERING_LAYERS; i++)\n\t{\n\t\tfloat distance = rayLength * (i + 1) / NUM_SCATTERING_LAYERS;\n\t\tfloat stepSize = distance / NUM_SCATTERING_STEPS;\n\t\tfloat step = 0.0;\n\t\tfor (int j = 0; j < NUM_SCATTERING_STEPS; j++)\n\t\t{\n\t\t\tfloat stepDistance = stepSize * (j + 1);\n\t\t\tfloat stepLength = min(stepDistance, rayLength - step);\n\t\t\tfloat stepRayLength = min(stepLength, distance);\n\t\t\tvec3 stepRayStart = rayStart + rayDir * step;\n\t\t\tvec3 stepRayDir = normalize(lightDir - stepRayStart);\n\t\t\tvec3 stepTransmittance = exp(-stepRayLength * GetScatteringCoefficient(i));", "\n    float h = clamp( ra - d, 0.0, ra );\n    return sqrt( sqr( h ) + sqr( rb ) ) - h;\n}\n\n//\n//\n//\nfloat", "\n\tfloat d = length( p - vec3( 0, h, 0 ) ) - r;\n\treturn d < t? d : length( p ) - r;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        h = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.1 );\n        if( t>tmax || res<0.001 )\n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat", "\n    return length( p - vec3( 0.0, h, 0.0 ) ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat", "\n    vec3 eps = vec3( 0.001 );\n    vec3 nor = vec3(\n        calcSDF( pos + eps.xyy ) - calcSDF( pos - eps.xyy ),\n        calcSDF( pos + eps.yxy ) - calcSDF( pos - eps.yxy ),\n        calcSDF( pos + eps.yyx ) - calcSDF( pos - eps.yyx )\n    );\n    return normalize( nor );\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = abs(p);\n    return length(p) - r;\n}\n\n// r=radius, h=height\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix( mix( mix( dot(vec3(f.x, f.y, f.z),\n                             vec3(0.0,113.0,271.0)),\n                         dot(vec3(f.x-1.0, f.y, f.z),\n                             vec3(283.0,313.0,371.0)), 0.6),\n                    mix( dot(vec3(f.x, f.y-1.0, f.z),\n                             vec3(331.0,197.0,37.0)),\n                         dot(vec3(f.x, f.y-1.0, f.z-1.0),\n                             vec3(289.0,149.0,197.0)), 0.6), 0.3),\n                mix( mix( dot(vec3(f.x-1.0, f.y-1.0, f.z),\n                             vec3(329.0,179.0,137.0)),\n                         dot(vec3(f.x-1.0, f.y, f.z-1.0),\n                             vec3(307.0,271.0,265.0)), 0.6),\n                    dot(vec3(f.x-1.0, f.y-1.0, f.z-1.0),\n                        vec3(305.0,193.0,263.0)), 0.3), 0.3);\n}\n\n// 3d noise function\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    for( int i = 0; i < 4; i++ )\n    {\n        v += a * noise( p );\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat", "\n    vec3 p = p3;\n    p = fract(p * vec3(0.1, 0.2, 0.3));\n    p += dot(p, p.yzx + vec3(38.0, 10.0, 7.0));\n    return fract(p.x * p.x * p.y * p.z * p.w);\n}\n\n//value noise hash\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    // The following is a simple example of a raytracer.\n    // It is not a physically accurate raytracer, but it is a good example of how to use the raytracing shader.\n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The following is a simple example of a raytracer.\n    // It is not a physically accurate raytracer, but it is a good example of how to use the raytracing shader.\n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The following is a simple example of a raytracer.\n    // It is not a physically accurate raytracer, but it is a good example of how to use the raytracing shader.\n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The following is a simple example of a raytracer.\n    // It is not a physically accurate raytracer, but it is a good example of how to use the raytracing shader.\n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The following is a simple example of a raytracer.\n    // It is not a physically accurate raytracer, but it is a good example of how to use the raytracing shader.\n    // The raytracer is based on the following paper:\n    // https://www.cs.utah.edu/~reinhard/cdrom/papers/mt.pdf\n    \n    // The following is a simple example of a raytracer", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    p = p - size * floor(p / size);\n    return p;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat", "\n\treturn fract(sin(co) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\treturn t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat", "\n\treturn pow(c, vec3(2.2));\n}\n\nvec", "\n    return smoothstep(k, k+1, a) * a + smoothstep(k, k+1, b) * b;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat", "\n    float h = clamp(dot(ro-sph.xyz, rd), 0.0, 1.0);\n    float t = -sph.w * log(1.0-h);\n    return t-dbuffer;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n    vec4 c = vec4(0.0);\n    float a = 0.0;\n    for (int i = 0; i < 4; i++) {\n        c += vec4(sin(p.x * p.y * p.z), cos(p.x * p.y * p.z), sin(p.x * p.y * p.z), cos(p.x * p.y * p.z)) * a;\n        a += 0.2;\n        p *= 2.0;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 p = vec4(uv * 2.0 - 1.0, 0.0, 1.0);\n    vec4 c = formula(p);\n    fragColor = vec4(c.xyz, 1.0);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n`;\n\nexport const shader = {\n    vertex: vertexShader,\n    fragment: fragmentShader,\n};\n\n", "\n    vec3 q = p / r;\n    float q2 = dot(q,q);\n    float q3 = q2 * q2;\n    float q4 = q3 * q2;\n    float q5 = q4 * q2;\n    float q6 = q5 * q2;\n    float q7 = q6 * q2;\n    float q8 = q7 * q2;\n    float q9 = q8 * q2;\n    float q10 = q9 * q2;\n    float q11 = q10 * q2;\n    float q12 = q11 * q2;\n    float q13 = q12 * q2;\n    float q14 = q13 * q2;\n    float q15 = q14 * q2;\n    float q16 = q15 * q2;\n    float q17 = q16 * q2;\n    float q18 = q17 * q2;\n    float q19 = q18 * q2;\n    float q20 = q19 * q2;\n    float q21 = q20 * q2;\n    float q22 = q21 * q2;\n    float q23 = q22 * q2;\n    float q24 = q23 * q2;\n    float q25 = q24 * q2;\n    float q26 = q25 * q2;\n    float q27 = q26 * q2;\n    float q28 = q27 * q2;\n    float q29 = q28 * q2;\n    float q30 = q29 * q2;\n    float q31 = q30 * q2;\n    float q32 = q31 * q2;\n    float q33 = q32 * q2;\n    float q34 = q33 * q2;\n    float q35 = q34 * q2;\n    float q36 = q35 * q2;\n    float q37 = q36 * q2;\n    float q38 = q37 * q2;\n    float q39 = q38 * q2;\n    float q40 = q39 * q2;\n    float q41 = q40 * q2;\n    float q42 = q41 * q2;\n    float q43 = q42 * q", "\n    return vec4(\n        back.rgb * (1.0 - front.a) + front.rgb * front.a,\n        front.a + back.a * (1.0 - front.a)\n    );\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec2 q = abs(p) - r;\n    float r2 = dot(q,q);\n    return r - sqrt(r2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat", "\n\treturn pow(v, vec3(2.2));\n}\n\n// License: Unknown, author: <NAME> (https://github.com/mattdesl), found: https://www.shadertoy.com/view/XsXGW8\nvec", "\n\tp = vec2(dot(p, vec2(127.41, 311.77)), dot(p, vec2(269.51, 183.77)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\tfloat x = Temp / 10000.0;\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tfloat x4 = x3 * x;\n\tfloat x5 = x4 * x;\n\tfloat x6 = x5 * x;\n\tfloat x7 = x6 * x;\n\tfloat x8 = x7 * x;\n\tfloat x9 = x8 * x;\n\tfloat x10 = x9 * x;\n\tfloat x11 = x10 * x;\n\tfloat x12 = x11 * x;\n\tfloat x13 = x12 * x;\n\tfloat x14 = x13 * x;\n\tfloat x15 = x14 * x;\n\tfloat x16 = x15 * x;\n\tfloat x17 = x16 * x;\n\tfloat x18 = x17 * x;\n\tfloat x19 = x18 * x;\n\tfloat x20 = x19 * x;\n\tfloat x21 = x20 * x;\n\tfloat x22 = x21 * x;\n\tfloat x23 = x22 * x;\n\tfloat x24 = x23 * x;\n\tfloat x25 = x24 * x;\n\tfloat x26 = x25 * x;\n\tfloat x27 = x26 * x;\n\tfloat x28 = x27 * x;\n\tfloat x29 = x28 * x;\n\tfloat x30 = x29 * x;\n\tfloat x31 = x30 * x;\n\tfloat x32 = x31 * x;\n\tfloat x33 = x32 * x;\n\tfloat x34 = x33 * x;\n\tfloat x35 = x34 * x;\n\tfloat x36 = x35 * x;\n\tfloat x37 = x36 * x;\n\tfloat x38 = x37 * x;\n\tfloat x39 = x38 * x;\n\tfloat x40 = x39 * x;\n\tfloat x41 = x40 * x;\n\tfloat x42 = x41 * x;\n\tfloat x43 = x42 * x;\n\tfloat x44 = x43 * x;\n\tfloat x45 = x44 * x;\n\tfloat x46 = x45 * x;\n\tfloat x47 = x", "\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat", "\n    vec3 op = ro - sph.xyz;\n    float b = dot(op, rd);\n    float det = b * b - dot(op, op) + sph.w;\n    if (det < 0.0) return vec2(1.0, 0.0);\n    return vec2(b - sqrt(det), b + sqrt(det));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat", "\n    p = abs(p);\n    float x = p.x, y = p.y;\n    float a = sqrt(x*x + y*y);\n    float b = sqrt(x*x + y*y + n*n);\n    float c = sqrt(x*x + y*y + 2.0*n*n);\n    float d = sqrt(x*x + y*y + 3.0*n*n);\n    float e = sqrt(x*x + y*y + 4.0*n*n);\n    float f = sqrt(x*x + y*y + 5.0*n*n);\n    float g = sqrt(x*x + y*y + 6.0*n*n);\n    float h = sqrt(x*x + y*y + 7.0*n*n);\n    float i = sqrt(x*x + y*y + 8.0*n*n);\n    float j = sqrt(x*x + y*y + 9.0*n*n);\n    float k = sqrt(x*x + y*y + 10.0*n*n);\n    float l = sqrt(x*x + y*y + 11.0*n*n);\n    float m = sqrt(x*x + y*y + 12.0*n*n);\n    float n1 = sqrt(x*x + y*y + 13.0*n*n);\n    float n2 = sqrt(x*x + y*y + 14.0*n*n);\n    float n3 = sqrt(x*x + y*y + 15.0*n*n);\n    float n4 = sqrt(x*x + y*y + 16.0*n*n);\n    float n5 = sqrt(x*x + y*y + 17.0*n*n);\n    float n6 = sqrt(x*x + y*y + 18.0*n*n);\n    float n7 = sqrt(x*x + y*y + 19.0*n*n);\n    float n8 = sqrt(x*x + y*y + 20.0*n*n);\n    float n9 = sqrt(x*", "\n    return x + t * (x - floor(x));\n}\n\n// generalization of Devil's Staircase\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return length( pa - ba * h );\n}\n\nfloat", "\n    vec3 c = p;\n    float d = 0.0;\n    for (int i = 0; i < iterations; i++) {\n        c = abs(c) - vec3(0.5);\n        d += 1.0;\n        if (c.x < 0.0 || c.y < 0.0 || c.z < 0.0) {\n            break;\n        }\n    }\n    return d / float(iterations);\n}\n\n// main fractal func\nfloat", "\n    float a = 0.15f;\n    float b = 0.50f;\n    float c = 0.90f;\n    float d = 0.60f;\n    float e = 0.90f;\n    float f = 0.60f;\n    float g = 0.90f;\n    float h = 0.60f;\n    float i = 0.90f;\n    float j = 0.60f;\n    float k = 0.90f;\n    float l = 0.60f;\n    float m = 0.90f;\n    float n = 0.60f;\n    float o = 0.90f;\n    float p = 0.60f;\n    float q = 0.90f;\n    float r = 0.60f;\n    float s = 0.90f;\n    float t = 0.60f;\n    float u = 0.90f;\n    float v = 0.60f;\n    float w = 0.90f;\n    float x1 = 0.60f;\n    float y1 = 0.90f;\n    float z1 = 0.60f;\n    float a1 = 0.90f;\n    float b1 = 0.60f;\n    float c1 = 0.90f;\n    float d1 = 0.60f;\n    float e1 = 0.90f;\n    float f1 = 0.60f;\n    float g1 = 0.90f;\n    float h1 = 0.60f;\n    float i1 = 0.90f;\n    float j1 = 0.60f;\n    float k1 = 0.90f;\n    float l1 = 0.60f;\n    float m1 = 0.90f;\n    float n1 = 0.60f;\n    float o1 = 0.90f;\n    float p1 = 0.60f;\n    float q1 = 0.90f;\n    float r1 = 0.60f;\n    float s1 = 0.90f;\n    float t1 = 0.60f;\n    float u1 = 0.90f;\n    float v1 = 0.60f;\n    float w1 = 0", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\treturn vec2(catanh(z.x), catanh(z.y));\n}\n\n// Inverse hyperbolic tangent \nvec", "\n\treturn vec2(exp(z.x), exp(z.y));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\treturn vec2(exp(z.x), exp(z.y));\n}\n\nvec", "\n  return alpha * (1.0 + contrast) / (1.0 + contrast + contrast * alpha);\n}\n\n// Returns a color with the same hue as the input color, but a different saturation\n// and value.\nvec", "\n\treturn length(p - vec3(0.0, 0.0, 0.0));\n}\n\n//Distance from the Edge of Rhombic Triacontahedron\nfloat", "\n\tvec3 p = vec3(uvw.x, uvw.y, uvw.z);\n\tp = abs(p) - 0.5;\n\tp = p * p * (6.0 * p.z - 15.0 * p.y + 10.0) + vec3(0.0, 1.0, 0.0);\n\treturn tilingVal3D(p);\n}\n\n//Rhombic Triacontahedron Tiling\ntilingVal3D rohmTriTile(vec3 uvw) {\n\tvec3 p = vec3(uvw.x, uvw.y, uvw.z);\n\tp = abs(p) - 0.5;\n\tp = p * p * (10.0 * p.z - 20.0 * p.y + 12.0) + vec3(0.0, 1.0, 0.0);\n\treturn tilingVal3D(p);\n}\n\n//Rhombic Hexahedron Tiling\ntilingVal3D rohmHexTile(vec3 uvw) {\n\tvec3 p = vec3(uvw.x, uvw.y, uvw.z);\n\tp = abs(p) - 0.5;\n\tp = p * p * (8.0 * p.z - 16.0 * p.y + 9.0) + vec3(0.0, 1.0, 0.0);\n\treturn tilingVal3D(p);\n}\n\n//Rhombic Pentacontahedron Tiling\ntilingVal3D rohmPentaTile(vec3 uvw) {\n\tvec3 p = vec3(uvw.x, uvw.y, uvw.z);\n\tp = abs(p) - 0.5;\n\tp = p * p * (14.0 * p.z - 30.0 * p.y + 22.0) + vec3(0.0, 1.0, 0.0);\n\treturn tilingVal3D(p);\n}\n\n//Rhombic Hexahedron Tiling\ntilingVal3D rohmOctTile(vec3 uvw) {\n\tvec3 p = vec3(uvw.x, uv", "\n\t// Rhombic Dodecahedron tiling\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www.youtube.com/watch?v=_7Yn-3uPjr4\n\t// https://www", "\n  float gridSize = 1.0 / gridRes;\n  float gridOffset = gridSize / 2.0;\n  float gridStep = gridSize;\n  float gridX = uvw.x * gridRes;\n  float gridY = uvw.y * gridRes;\n  float gridZ = uvw.z * gridRes;\n  float gridXf = floor(gridX);\n  float gridYf = floor(gridY);\n  float gridZf = floor(gridZ);\n  float gridXr = fract(gridX);\n  float gridYr = fract(gridY);\n  float gridZr = fract(gridZ);\n  float gridXc = gridXr - 0.5;\n  float gridYc = gridYr - 0.5;\n  float gridZc = gridZr - 0.5;\n  float gridXc2 = gridXc * gridXc;\n  float gridYc2 = gridYc * gridYc;\n  float gridZc2 = gridZc * gridZc;\n  float gridXc4 = gridXc2 * gridXc2;\n  float gridYc4 = gridYc2 * gridYc2;\n  float gridZc4 = gridZc2 * gridZc2;\n  float gridXc8 = gridXc4 * gridXc4;\n  float gridYc8 = gridYc4 * gridYc4;\n  float gridZc8 = gridZc4 * gridZc4;\n  float gridXc16 = gridXc8 * gridXc8;\n  float gridYc16 = gridYc8 * gridYc8;\n  float gridZc16 = gridZc8 * gridZc8;\n  float gridXc32 = gridXc16 * gridXc16;\n  float gridYc32 = gridYc16 * gridYc16;\n  float gridZc32 = gridZc16 * gridZc16;\n  float gridXc64 = gridXc32 * gridXc32;\n  float gridYc64 = gridYc32 * gridYc32;\n  float gridZc64 = gridZc32 * gridZc32;", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\td += dist(p, icoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center Squared\nfloat", "\n\treturn vec3(t, t, t);\n}\n\n// makes Cool colormap with polynimal 6\nvec", "\n    float s = sin(a.x);\n    float c = cos(a.x);\n    mat3 m = mat3(vec3(c, s, 0),\n                  vec3(-s, c, 0),\n                  vec3(0, 0, 1));\n    return m * v;\n}\n\n// returns a random float between 0 and 1\nfloat", "\n\treturn fract(sin(dot(co.f2, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n\treturn sqrt(p.x*p.x + p.y*p.y);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat", "\n    vec2 p = uv * 2.0 - 1.0;\n    vec2 q = abs(p) - 0.5;\n    float r = min(min(min(length(p), length(q)), length(p + q)), length(p + q + 1.0));\n    float s = r - floor(r);\n    vec2 t = p + s;\n    return vec2(t.x > 0.0? t.x - 1.0 : t.x, t.y);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec", "\n    vec3 c = vec3(1.0);\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    float a = 1.0;\n    float h = 0.0;\n    float s = 0.0;\n    float v = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float f = 0.0;\n    float i = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float e = 0.0;\n    float d = 0.0;\n    float l = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 =", "\n\treturn (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n  float cellSize = 1.0 / gridRes;\n  float cellX = floor(uv.x / cellSize);\n  float cellY = floor(uv.y / cellSize);\n  float cellXf = fract(uv.x / cellSize);\n  float cellYf = fract(uv.y / cellSize);\n  float cellX2 = floor(cellXf / 2.0);\n  float cellY2 = floor(cellYf / 2.0);\n  float cellX3 = floor(cellXf / 3.0);\n  float cellY3 = floor(cellYf / 3.0);\n  float cellX4 = floor(cellXf / 4.0);\n  float cellY4 = floor(cellYf / 4.0);\n  float cellX5 = floor(cellXf / 5.0);\n  float cellY5 = floor(cellYf / 5.0);\n  float cellX6 = floor(cellXf / 6.0);\n  float cellY6 = floor(cellYf / 6.0);\n  float cellX7 = floor(cellXf / 7.0);\n  float cellY7 = floor(cellYf / 7.0);\n  float cellX8 = floor(cellXf / 8.0);\n  float cellY8 = floor(cellYf / 8.0);\n  float cellX9 = floor(cellXf / 9.0);\n  float cellY9 = floor(cellYf / 9.0);\n  float cellX10 = floor(cellXf / 10.0);\n  float cellY10 = floor(cellYf / 10.0);\n  float cellX11 = floor(cellXf / 11.0);\n  float cellY11 = floor(cellYf / 11.0);\n  float cellX12 = floor(cellXf / 12.0);\n  float cellY12 = floor(cellYf / 12.0);\n  float cellX13 = floor(cellXf / 13.0);\n  float cellY13 = floor(cellYf / 13.0);\n  float cellX14 = floor(cellXf / 14.0);\n  float cellY14 = floor(cellYf", "\n  float flow = 0.0;\n  float flow2 = 0.0;\n  float flow3 = 0.0;\n  float flow4 = 0.0;\n  float flow5 = 0.0;\n  float flow6 = 0.0;\n  float flow7 = 0.0;\n  float flow8 = 0.0;\n  float flow9 = 0.0;\n  float flow10 = 0.0;\n  float flow11 = 0.0;\n  float flow12 = 0.0;\n  float flow13 = 0.0;\n  float flow14 = 0.0;\n  float flow15 = 0.0;\n  float flow16 = 0.0;\n  float flow17 = 0.0;\n  float flow18 = 0.0;\n  float flow19 = 0.0;\n  float flow20 = 0.0;\n  float flow21 = 0.0;\n  float flow22 = 0.0;\n  float flow23 = 0.0;\n  float flow24 = 0.0;\n  float flow25 = 0.0;\n  float flow26 = 0.0;\n  float flow27 = 0.0;\n  float flow28 = 0.0;\n  float flow29 = 0.0;\n  float flow30 = 0.0;\n  float flow31 = 0.0;\n  float flow32 = 0.0;\n  float flow33 = 0.0;\n  float flow34 = 0.0;\n  float flow35 = 0.0;\n  float flow36 = 0.0;\n  float flow37 = 0.0;\n  float flow38 = 0.0;\n  float flow39 = 0.0;\n  float flow40 = 0.0;\n  float flow41 = 0.0;\n  float flow42 = 0.0;\n  float flow43 = 0.0;\n  float flow44 = 0.0;\n  float flow45 = 0.0;\n  float flow46 = 0.0;\n  float flow47 = 0.0;\n  float flow48 = 0.0;\n  float flow49 = 0.0;\n  float flow50 = 0.0;\n  float flow51 = 0.0;\n  float", "\n  float angle = time * 0.1;\n  float x = radius * cos(angle);\n  float y = radius * sin(angle);\n  return vec2(x, y);\n}\n\n// makes a simple flowmap of a cyclone\nvec", "\n\treturn vec2(floor(pos.x / ARROW_TILE_SIZE), floor(pos.y / ARROW_TILE_SIZE));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n\tvec2 v = p2 - p1;\n\tfloat t = clamp(dot(p - p1, v) / dot(v, v), 0.0, 1.0);\n\treturn length(p - (p1 + t * v));\n}\n\n// Computes the signed distance from a line segment\nfloat", "\n  float d = length(v) - arrowLength;\n  return d;\n}\n\n// Returns a signed distance from the arrow\nfloat", "\n\treturn x * 0.5 + 0.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n\tfloat dist = length(point);\n\tfloat angle = atan(point.y, point.x);\n\tfloat angleOffset = angle + offset;\n\tfloat angleSpread = spread * dist;\n\treturn vec2(cos(angleOffset + angleSpread), sin(angleOffset + angleSpread));\n}\n\n// makes a simple flowmap in the shape of a spiral centered on point\nvec", "\n    return length(max(abs(p)-b,0.0)) + min(max(p.x,p.y),0.0);\n}\n\nfloat", "\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.0;\n\tfloat d36 = 0.0;\n\tfloat d37 = 0.0;\n\tfloat d38 = 0.0;\n\tfloat d39 = 0.0;\n\tfloat d40 = 0.0;\n\tfloat d41 = 0.0;\n\tfloat d42 = 0.0;\n\tfloat d43 = 0.0;\n\tfloat d44 = 0.0;\n\tfloat d45 = 0.0;\n\tfloat d46 = 0.0;\n\tfloat d47 = 0", "\n    float d = length(p);\n    float a = atan(p.y, p.x) + time;\n    float r = ra + sp * sin(a);\n    return r - d;\n}\n\n// the point of this shader\nfloat", "\n\treturn length(uvw);\n}\n\n//edge distance of a Sphere\nfloat", "\n    vec3 p = uvw.xyz * 2.0 - 1.0;\n    vec3 q = abs(p);\n    float h = max(q.x, max(q.y, q.z));\n    vec3 sc = sign(p);\n    if (h > 1.0)\n        p = (p / h) * 0.5 + 0.5 * sc;\n    return vec4(p, 1.0);\n}\n\n// Cube Tiling\nvec", "\n  return vec4(uvw.xy, uvw.z * gridRes + offset.z, 1.0);\n}\n\n// scaled with offset cube tiling\nvec", "\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (t < 0.25) {\n        c.r = 1.0;\n        c.g = 4.0 * t;\n    } else if (t < 0.5) {\n        c.r = 1.0 - 4.0 * (t - 0.25);\n        c.b = 1.0;\n    } else if (t < 0.75) {\n        c.b = 1.0 - 4.0 * (t - 0.5);\n        c.g = 1.0;\n    } else {\n        c.g = 4.0 * (t - 0.75);\n        c.b = 1.0;\n    }\n    return c;\n}\n\n// makes RdYlBu_r colormap with polynimal 7 https://www.shadertoy.com/view/Nd3fR2\nvec", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 8; i++) {\n\t\td += distance(p, cubocVertices[i]);\n\t}\n\treturn d;\n}\n\n//Distance from the Edge of Octahedron\nfloat", "\n    return vec3(0.5, 0.5, 0.5) + 0.5 * sin(6.0 * t) * vec3(1.0, 1.0, 1.0);\n}\n\n// makes summer colormap with polynimal 6\nvec", "\n    return vec3(uv.x, uv.y, 0.0);\n}\n\n// simple cube Tiling\nvec", "\n  vec2 p = uv - 0.5;\n  float d = length(p);\n  float a = atan(p.y, p.x);\n  float r = d * cos(a);\n  float s = d * sin(a);\n  return vec3(r, s, 0.0);\n}\n\n//rhombic shape form Manhattan distance\nvec", "\n  float gridSize = 1.0 / gridRes;\n  float gridX = floor(uv.x / gridSize);\n  float gridY = floor(uv.y / gridSize);\n  float gridX2 = floor(uv.x / gridSize);\n  float gridY2 = floor(uv.y / gridSize);\n  float gridX3 = floor(uv.x / gridSize);\n  float gridY3 = floor(uv.y / gridSize);\n  float gridX4 = floor(uv.x / gridSize);\n  float gridY4 = floor(uv.y / gridSize);\n  float gridX5 = floor(uv.x / gridSize);\n  float gridY5 = floor(uv.y / gridSize);\n  float gridX6 = floor(uv.x / gridSize);\n  float gridY6 = floor(uv.y / gridSize);\n  float gridX7 = floor(uv.x / gridSize);\n  float gridY7 = floor(uv.y / gridSize);\n  float gridX8 = floor(uv.x / gridSize);\n  float gridY8 = floor(uv.y / gridSize);\n  float gridX9 = floor(uv.x / gridSize);\n  float gridY9 = floor(uv.y / gridSize);\n  float gridX10 = floor(uv.x / gridSize);\n  float gridY10 = floor(uv.y / gridSize);\n  float gridX11 = floor(uv.x / gridSize);\n  float gridY11 = floor(uv.y / gridSize);\n  float gridX12 = floor(uv.x / gridSize);\n  float gridY12 = floor(uv.y / gridSize);\n  float gridX13 = floor(uv.x / gridSize);\n  float gridY13 = floor(uv.y / gridSize);\n  float gridX14 = floor(uv.x / gridSize);\n  float gridY14 = floor(uv.y / gridSize);\n  float gridX15 = floor(uv.x / gridSize);\n  float gridY15 = floor(uv.y / gridSize);\n  float gridX16 = floor(uv.x / gridSize);\n  float gridY", "\n  float gridSize = 1.0 / gridRes;\n  float gridX = floor(uv.x / gridSize);\n  float gridY = floor(uv.y / gridSize);\n  float gridX2 = floor(uv.x / gridSize);\n  float gridY2 = floor(uv.y / gridSize);\n  float gridX3 = floor(uv.x / gridSize);\n  float gridY3 = floor(uv.y / gridSize);\n  float gridX4 = floor(uv.x / gridSize);\n  float gridY4 = floor(uv.y / gridSize);\n  float gridX5 = floor(uv.x / gridSize);\n  float gridY5 = floor(uv.y / gridSize);\n  float gridX6 = floor(uv.x / gridSize);\n  float gridY6 = floor(uv.y / gridSize);\n  float gridX7 = floor(uv.x / gridSize);\n  float gridY7 = floor(uv.y / gridSize);\n  float gridX8 = floor(uv.x / gridSize);\n  float gridY8 = floor(uv.y / gridSize);\n  float gridX9 = floor(uv.x / gridSize);\n  float gridY9 = floor(uv.y / gridSize);\n  float gridX10 = floor(uv.x / gridSize);\n  float gridY10 = floor(uv.y / gridSize);\n  float gridX11 = floor(uv.x / gridSize);\n  float gridY11 = floor(uv.y / gridSize);\n  float gridX12 = floor(uv.x / gridSize);\n  float gridY12 = floor(uv.y / gridSize);\n  float gridX13 = floor(uv.x / gridSize);\n  float gridY13 = floor(uv.y / gridSize);\n  float gridX14 = floor(uv.x / gridSize);\n  float gridY14 = floor(uv.y / gridSize);\n  float gridX15 = floor(uv.x / gridSize);\n  float gridY15 = floor(uv.y / gridSize);\n  float gridX16 = floor(uv.x / gridSize);\n  float gridY", "\n  float cellSize = 1.0 / gridRes;\n  float cellX = floor(uv.x / cellSize);\n  float cellY = floor(uv.y / cellSize);\n  float x = fract(uv.x / cellSize);\n  float y = fract(uv.y / cellSize);\n  float xy = min(x, y);\n  float yx = max(x, y);\n  float xyOffset = cellSize * 0.5;\n  float yxOffset = cellSize * 0.5;\n  float xyLen = len * xy;\n  float yxLen = len * yx;\n  float xyOffsetLen = xyOffset * xyLen;\n  float yxOffsetLen = yxOffset * yxLen;\n  float xyOffsetLen2 = xyOffsetLen * 2.0;\n  float yxOffsetLen2 = yxOffsetLen * 2.0;\n  float xyOffsetLen3 = xyOffsetLen * 3.0;\n  float yxOffsetLen3 = yxOffsetLen * 3.0;\n  float xyOffsetLen4 = xyOffsetLen * 4.0;\n  float yxOffsetLen4 = yxOffsetLen * 4.0;\n  float xyOffsetLen5 = xyOffsetLen * 5.0;\n  float yxOffsetLen5 = yxOffsetLen * 5.0;\n  float xyOffsetLen6 = xyOffsetLen * 6.0;\n  float yxOffsetLen6 = yxOffsetLen * 6.0;\n  float xyOffsetLen7 = xyOffsetLen * 7.0;\n  float yxOffsetLen7 = yxOffsetLen * 7.0;\n  float xyOffsetLen8 = xyOffsetLen * 8.0;\n  float yxOffsetLen8 = yxOffsetLen * 8.0;\n  float xyOffsetLen9 = xyOffsetLen * 9.0;\n  float yxOffsetLen9 = yxOffsetLen * 9.0;\n  float xyOffsetLen10 = xyOffsetLen * 10.0;\n  float yxOffsetLen10 = yxOffsetLen * 10.0;\n  float xyOffsetLen11 =", "\n  float r = 0.0;\n  float d = 0.0;\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d2 = 0.0;\n  float a2 = 0.0;\n  float b2 = 0.0;\n  float c2 = 0.0;\n  float d3 = 0.0;\n  float a3 = 0.0;\n  float b3 = 0.0;\n  float c3 = 0.0;\n  float d4 = 0.0;\n  float a4 = 0.0;\n  float b4 = 0.0;\n  float c4 = 0.0;\n  float d5 = 0.0;\n  float a5 = 0.0;\n  float b5 = 0.0;\n  float c5 = 0.0;\n  float d6 = 0.0;\n  float a6 = 0.0;\n  float b6 = 0.0;\n  float c6 = 0.0;\n  float d7 = 0.0;\n  float a7 = 0.0;\n  float b7 = 0.0;\n  float c7 = 0.0;\n  float d8 = 0.0;\n  float a8 = 0.0;\n  float b8 = 0.0;\n  float c8 = 0.0;\n  float d9 = 0.0;\n  float a9 = 0.0;\n  float b9 = 0.0;\n  float c9 = 0.0;\n  float d10 = 0.0;\n  float a10 = 0.0;\n  float b10 = 0.0;\n  float c10 = 0.0;\n  float d11 = 0.0;\n  float a11 = 0.0;\n  float b11 = 0.0;\n  float c11 = 0.0;\n  float d12 = 0.0;\n  float a12 = 0.0;\n  float b12 = 0.0;\n  float c12 = 0.0;\n  float d13 = 0.0;\n  float a13 = 0.0;\n  float b13 = 0", "\n    vec2 q = floor( p );\n    vec2 f = fract( p );\n    f = f*f*(3.0-2.0*f);\n    vec2 e = f*f*(6.0-6.0*f);\n    vec2 r = mix( vec2( e.x, e.y ), vec2( e.y, e.x ), float( step(.5, mod( q.x, 2.0 ) ) ) );\n    return mix( r, 1.0 - r, float( step(.5, mod( q.y, 2.0 ) ) ) );\n}\n\nfloat", "\n    p = abs(p);\n    float d = length(max(abs(p) - r, 0.0));\n    return min(d, length(p) - r);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n\tp = fract(p);\n\tp = p * vec2(0.5, 0.5) + vec2(0.5, 0.5);\n\tp = floor(p) * vec2(2.0, 2.0);\n\treturn fract(p);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec", "\n    return 1.0 - clamp( abs( sin( x ) * 0.5 + x ), 0.0, 1.0 );\n}\n\n// noise, https://www.shadertoy.com/view/XsjXRW\nfloat", "\n\treturn pow(t, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec", "\n    return smoothstep(0.0, 1.0, cos(p.x * PI) * cos(p.y * PI));\n}\n\n// Classic truchet pattern\nfloat", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < n; i++) {\n\t\td += abs(p[0] - p[1] - i);\n\t}\n\treturn d;\n}\n\nfloat", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n    vec2 e3 = p - p0;\n    vec2 e4 = p - p1;\n    vec2 e5 = p - p2;\n    float a = -dot(e0, e3);\n    float b = dot(e0, e4);\n    float c = -dot(e0, e5);\n    float d = dot(e1, e3);\n    float e = -dot(e1, e4);\n    float f = dot(e1, e5);\n    float g = -dot(e2, e3);\n    float h = dot(e2, e4);\n    float i = -dot(e2, e5);\n    float j = dot(e3, e3);\n    float k = dot(e3, e4);\n    float l = dot(e3, e5);\n    float m = dot(e4, e4);\n    float n = dot(e4, e5);\n    float o = dot(e5, e5);\n    float s = a*j + b*k + c*l;\n    float t = d*j + e*k + f*l;\n    float u = g*j + h*k + i*l;\n    float v = a*m + b*n + c*o;\n    float w = d*m + e*n + f*o;\n    float x = g*m + h*n + i*o;\n    float y = a*j + b*k + c*l;\n    float z = d*j + e*k + f*l;\n    float A = y - z;\n    float B = z - s;\n    float C = s - v;\n    float D = v - x;\n    float E = x - u;\n    float F = u - t;\n    float G = t - w;\n    float H = w - j;\n    float I = j - l;\n    float J = l - B;\n    float K = B - C;\n    ", "\n    float r = sph.x;\n    float g = sph.y;\n    float b = sph.z;\n    float a = sph.w;\n    float h = 0.5 * (r + g + b);\n    float l = sqrt(max(0.0, r*r + g*g + b*b - a*a));\n    float d = length(ro) - r;\n    float s = clamp(0.5 + 0.5 * (d / dbuffer), 0.0, 1.0);\n    return h * (1.0 - s) + l * s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat", "\n    float d = length(p) - w;\n    return d < 0.0? d : max(d - r, 0.0);\n}\n\nfloat", "\n    float d = length( p );\n    float alpha = k * d;\n    float beta = sqrt( 1.0 - pow( alpha, 2.0 ) );\n    return sqrt( pow( alpha, 2.0 ) + pow( beta, 2.0 ) );\n}\n\n// k in (0,1) range\nfloat", "\n    return length( p - vec2( 1.0 / p.x, p.y ) );\n}\n\n// distance to y=x^2\nfloat", "\n    float h = clamp(0.5f + 0.5f*(b - a)/k, 0.0f, 1.0f);\n    return lerp(b, a, h) - k*h*(1.0f - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat", "\n    return a < 0.0? -a : a * k;\n}\n\nfloat", "\n    float a = length(p);\n    float k = 8.0;\n    return sqrt(abs(a - cos(k * a) * sin(k * a))) / sqrt(k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Hash with Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec2 p = pos - A;\n    vec2 q = pos - B;\n    vec2 r = pos - C;\n    vec2 u = B - A;\n    vec2 v = C - A;\n    vec2 w = u * dot(u, p) + v * dot(v, p);\n    vec2 x = u * dot(u, q) + v * dot(v, q);\n    vec2 y = u * dot(u, r) + v * dot(v, r);\n    vec2 z = cross(w, x);\n    float d = length(z);\n    return vec3(d, z.x, z.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec", "\n    vec2 p = vec2( pos.x, pos.y );\n    vec2 d = vec2( pos.x, pos.y );\n    float h = he * 0.5;\n    float w = wi * 0.5;\n    float a = h * h / w / w;\n    float b = -2.0 * h * h / w / w / w;\n    float c = h * h / w / w / w / w;\n    float x = p.x;\n    float y = p.y;\n    float z = a * x * x + b * x * y + c * y * y;\n    vec3 n = vec3( 2.0 * a * x + b * y, b * x + 2.0 * c * y, 2.0 * c * y );\n    n = normalize( n );\n    return vec3( z, n.x, n.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return vec3( pos.y, k * pos.x * pos.x - 1.0, 0.0 );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    float r = length(p);\n    float h = clamp(r - d, 0.0, 1.0);\n    float s = smoothstep(0.0, 1.0, h);\n    float a = smoothstep(0.0, 1.0, r / ra);\n    float b = smoothstep(0.0, 1.0, r / rb);\n    float c = smoothstep(0.0, 1.0, r / d);\n    float f = min(min(a, b), c);\n    vec3 n = normalize(vec3(p, f));\n    return vec3(f, n.x, n.y);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    v = v * 0x5851f42d4c957f2d;\n    v = (v ^ (v >> 17)) * 0xbc8d1a43b9ed94f9;\n    return v ^ (v >> 32);\n}\n\nivec2 Pcg2(ivec2 v, ivec2 m)\n{\n    v = v * 0x5851f42d4c957f2d;\n    v = (v ^ (v >> 17)) * 0xbc8d1a43b9ed94f9;\n    return v ^ (v >> 32) & m;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 m, ivec2 s)\n{\n    v = v * 0x5851f42d4c957f2d;\n    v = (v ^ (v >> 17)) * 0xbc8d1a43b9ed94f9;\n    return v ^ (v >> 32) & m & s;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 m, ivec2 s, ivec2 t)\n{\n    v = v * 0x5851f42d4c957f2d;\n    v = (v ^ (v >> 17)) * 0xbc8d1a43b9ed94f9;\n    return v ^ (v >> 32) & m & s & t;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 m, ivec2 s, ivec2 t, ivec2 u)\n{\n    v = v * 0x5851f42d4c957f2d;\n    v = (v ^ (v >> 17)) * 0xbc8d1a43b9ed94f9;\n    return v ^ (v >> 32) & m & s & t & u;\n}\n\nivec2 Pcg2(ivec2 v, ivec2 m, ivec2 s, ivec2 t, ivec2 u, ivec2 w)\n{\n    v = v * 0x5851f42d4c957f2", "\n    v = ivec3(v.x ^ v.x >> 16, v.y ^ v.y >> 16, v.z ^ v.z >> 16);\n    v = ivec3(v.x ^ v.x << 16, v.y ^ v.y << 16, v.z ^ v.z << 16);\n    v = ivec3(v.x ^ v.x >> 8, v.y ^ v.y >> 8, v.z ^ v.z >> 8);\n    v = ivec3(v.x ^ v.x << 8, v.y ^ v.y << 8, v.z ^ v.z << 8);\n    v = ivec3(v.x ^ v.x >> 7, v.y ^ v.y >> 7, v.z ^ v.z >> 7);\n    v = ivec3(v.x ^ v.x << 1, v.y ^ v.y << 1, v.z ^ v.z << 1);\n    return v;\n}\n\nivec3 Pcg3(ivec3 v, int seed)\n{\n    v = ivec3(v.x ^ v.x >> 16, v.y ^ v.y >> 16, v.z ^ v.z >> 16);\n    v = ivec3(v.x ^ v.x << 16, v.y ^ v.y << 16, v.z ^ v.z << 16);\n    v = ivec3(v.x ^ v.x >> 8, v.y ^ v.y >> 8, v.z ^ v.z >> 8);\n    v = ivec3(v.x ^ v.x << 8, v.y ^ v.y << 8, v.z ^ v.z << 8);\n    v = ivec3(v.x ^ v.x >> 7, v.y ^ v.y >> 7, v.z ^ v.z >> 7);\n    v = ivec3(v.x ^ v.x << 1, v.y ^ v.y << 1, v.z ^ v.z << 1);\n    return v;\n}\n\nivec3 Pcg3(ivec", "\n\tvec2 P = pos - A;\n\tvec2 Q = B - A;\n\tvec2 R = C - A;\n\tfloat a = dot(Q, Q);\n\tfloat b = dot(P, Q);\n\tfloat c = dot(P, P) - dot(R, R);\n\tfloat d = b * b - a * c;\n\tif (d < 0.0) {\n\t\treturn min(length(P - Q), length(P - 2.0 * Q - R));\n\t} else {\n\t\tfloat t = max(0.0, min(1.0, -b / a + sqrt(d) / a));\n\t\tvec2 Q1 = (1.0 - t) * A + t * B;\n\t\tvec2 Q2 = (1.0 - t) * B + t * C;\n\t\treturn length(pos - Q1) * (1.0 - t) + length(pos - Q2) * t;\n\t}\n}\n\n// signed distance to a cubic bezier\nfloat", "\n    return sign(cross(a - p, b - p));\n}\n\n// Source: https://www.shadertoy.com/view/ldXGW8\nfloat", "\n    vec3  h = s.xy;\n    vec3  w = s.z;\n    vec3  o = ro - h;\n    vec3  a = abs(rd);\n    vec3  b = abs(o);\n    vec3  r = min(a,b);\n    vec3  t = max(a,b);\n    float t1 = (r.z >= t.x)? t.x : t.z;\n    float t2 = (r.x >= t.y)? t.y : t.x;\n    float t3 = (r.y >= t.z)? t.z : t.y;\n    float t4 = min(t1,t2);\n    float t5 = min(t3,t4);\n    float t6 = max(t1,t2);\n    float t7 = max(t3,t6);\n    float t8 = min(t5,t7);\n    float t9 = max(t5,t7);\n    vec3  p = ro + t8 * rd;\n    vec3  n = vec3(0.0);\n    if (t8*t8 < t9*t9)\n    {\n        n.x = (o.x < 0.0)? -1.0 : 1.0;\n        n.y = (o.y < 0.0)? -1.0 : 1.0;\n        n.z = (o.z < 0.0)? -1.0 : 1.0;\n    }\n    else\n    {\n        n.x = (o.x < 0.0)? 1.0 : -1.0;\n        n.y = (o.y < 0.0)? 1.0 : -1.0;\n        n.z = (o.z < 0.0)? 1.0 : -1.0;\n    }\n    return vec4(t8,n);\n}\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = sphere center and radius\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\n", "\n\tint n = (a>>12) + (int)(b*x);\n\tret_n = n;\n\treturn (float)(a-n*4096) + b*x;\n}\n\n// https://www.shadertoy.com/view/XtBXz4\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat", "\n\treturn a * ( 1.0 - k ) + b * k;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n\treturn dot(p,p) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat", "\n    return a + b;\n}\n\nfloat", "\n\tvec2 p1 = ab * s1;\n\tvec2 p2 = ab * s2;\n\treturn mix( p1, p2, smoothstep( 0.0, 1.0, p.x ) );\n}\n\n//for highlighting individual solutions\nvec", "\n    vec3 ab = b - a;\n    vec3 pa = p - a;\n    float d = dot(pa, ab);\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n    float d31 = d30 * d;\n    float d32 = d31 * d;\n    float d33 = d32 * d;\n    float d34 = d33 * d;\n    float d35 = d34 * d;\n    float d36 = d35 * d;\n    float d37 = d36 * d;\n    float d38 = d37 * d;\n    float d39 = d38 * d;\n    float d40 = d39 * d;\n    float d41 = d40 * d;\n    float d42 = d41 * d;\n    float d43 = d42 * d;\n    float d44 = d43 * d;\n    float d45 = d44 *", "\n    return length( p - closestPointOnLine( p, a, b ) ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat", "\n    return length(p-cen)-rad;\n}\n\nfloat", "\n\tvec3 eps = vec3( 0.001 );\n\tvec3 nor = vec3(\n\t\tcalcSDF( pos + eps.xyy, showSurface, samplePoint ) - calcSDF( pos - eps.xyy, showSurface, samplePoint ),\n\t\tcalcSDF( pos + eps.yxy, showSurface, samplePoint ) - calcSDF( pos - eps.yxy, showSurface, samplePoint ),\n\t\tcalcSDF( pos + eps.yyx, showSurface, samplePoint ) - calcSDF( pos - eps.yyx, showSurface, samplePoint )\n\t);\n\treturn normalize( nor );\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1.0;\n    float tstep = 0.01;\n    float tmax2 = 1.0;\n    float tstep2 = 0.1;\n    float tmin2 = 0.0;\n    float tmax3 = 1.0;\n    float tstep3 = 0.01;\n    float tmin3 = 0.0;\n    float tmax4 = 1.0;\n    float tstep4 = 0.01;\n    float tmin4 = 0.0;\n    float tmax5 = 1.0;\n    float tstep5 = 0.01;\n    float tmin5 = 0.0;\n    float tmax6 = 1.0;\n    float tstep6 = 0.01;\n    float tmin6 = 0.0;\n    float tmax7 = 1.0;\n    float tstep7 = 0.01;\n    float tmin7 = 0.0;\n    float tmax8 = 1.0;\n    float tstep8 = 0.01;\n    float tmin8 = 0.0;\n    float tmax9 = 1.0;\n    float tstep9 = 0.01;\n    float tmin9 = 0.0;\n    float tmax10 = 1.0;\n    float tstep10 = 0.01;\n    float tmin10 = 0.0;\n    float tmax11 = 1.0;\n    float tstep11 = 0.01;\n    float tmin11 = 0.0;\n    float tmax12 = 1.0;\n    float tstep12 = 0.01;\n    float tmin12 = 0.0;\n    float tmax13 = 1.0;\n    float tstep13 = 0.01;\n    float tmin13 = 0.0;\n    float tmax14 = 1.0;\n    float tstep14 = 0.01;\n    float tmin14 = 0.0;\n    float tmax15 = 1.0;\n    float tstep15 = 0.01;\n    float tmin15 = 0.0;\n    float tmax16 = 1.0;", "\n\tvec2 ocl_ = vec2( 0.0 );\n\tvec3 res = vec3( 0.0 );\n\tfloat h = he / 2.0;\n\tfloat h2 = h * h;\n\tfloat h3 = h2 * h;\n\tfloat h4 = h3 * h;\n\tfloat h5 = h4 * h;\n\tfloat h6 = h5 * h;\n\tfloat h7 = h6 * h;\n\tfloat h8 = h7 * h;\n\tfloat h9 = h8 * h;\n\tfloat h10 = h9 * h;\n\tfloat h11 = h10 * h;\n\tfloat h12 = h11 * h;\n\tfloat h13 = h12 * h;\n\tfloat h14 = h13 * h;\n\tfloat h15 = h14 * h;\n\tfloat h16 = h15 * h;\n\tfloat h17 = h16 * h;\n\tfloat h18 = h17 * h;\n\tfloat h19 = h18 * h;\n\tfloat h20 = h19 * h;\n\tfloat h21 = h20 * h;\n\tfloat h22 = h21 * h;\n\tfloat h23 = h22 * h;\n\tfloat h24 = h23 * h;\n\tfloat h25 = h24 * h;\n\tfloat h26 = h25 * h;\n\tfloat h27 = h26 * h;\n\tfloat h28 = h27 * h;\n\tfloat h29 = h28 * h;\n\tfloat h30 = h29 * h;\n\tfloat h31 = h30 * h;\n\tfloat h32 = h31 * h;\n\tfloat h33 = h32 * h;\n\tfloat h34 = h33 * h;\n\tfloat h35 = h34 * h;\n\tfloat h36 = h35 * h;\n\tfloat h37 = h36 * h;\n\tfloat h38 = h37 * h;\n\tfloat h39 = h38 * h;\n\tfloat h40 = h39 * h;\n\tfloat h41 = h40 * h;\n\tfloat h42 = h41 * h;\n\tfloat h43 = h42 * h;\n\tfloat h44 = h43 * h;\n", "\n    vec3 q = p;\n    q.z = 0.0;\n    float r = length( q );\n    float t = ( r - ra ) / rb;\n    float st = sin( t );\n    float ct = cos( t );\n    q.x = p.x * ct - p.y * st;\n    q.y = p.x * st + p.y * ct;\n    q.z = p.z;\n    return vec4( q, 1.0 );\n}\n\nvec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*t );\n}\n\nfloat", " return v.x*v.x+v.y*v.y; }\nfloat", "\n    vec2 d = abs(p) - (maxCorner - minCorner);\n    return dot(d, max(d, 0.0));\n}\n\n// Returns the squared distance between a point and a line segment\nfloat", "\n    // Get the height of the water\n    float h = waterHeight(uv);\n\n    // Get the normal of the water\n    vec3 n = waterNormal(uv);\n\n    // Get the color of the water\n    vec3 c = waterColor(uv);\n\n    // Get the reflection of the water\n    vec3 r = waterReflection(uv, cdir);\n\n    // Get the refraction of the water\n    vec3 ref = waterRefraction(uv, cdir);\n\n    // Get the fog of the water\n    float fog = waterFog(uv);\n\n    // Get the color of the water\n    vec3 color = mix(c, r, 0.5);\n\n    // Get the final color of the water\n    vec3 final = mix(color, ref, 0.5);\n\n    // Get the final color of the water\n    vec3 finalColor = mix(final, c, fog);\n\n    // Return the final color of the water\n    return finalColor;\n}\n\n// Procedural texture generation for the sky\nvec", "\n    vec2 dir = uv * 2.0 - 1.0;\n    float dist = 1.0;\n    return vec3(dir * dist);\n}\n\n// Camera perspective based on [0..1] viewport\nvec", "\n\tvec3 uv, uuv;\n\tvec3 qvec = vec3(q.xyz);\n\tuv = cross(qvec, v);\n\tuuv = cross(qvec, uv);\n\tuv *= 2.0f * q.w;\n\tuuv *= 2.0f;\n\treturn v + uv + uuv;\n}\n\n// Quaternion-quaternion multiplication\nvec", "\n    return length(p-c)-r;\n}\n\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat", "\n    return mix( m, vec2( d, a ), smoothstep( 0.0, 1.0, d ) );\n}\n\nvec", "\n    vec2 t = (ro + rd * rad) - ro;\n    float d = dot(t, t);\n    float h = dot(rd, t);\n    float k = dot(rd, rd);\n    float a = k - h * h;\n    float b = d * k - h * h;\n    float c = d * d - rad * rad * k;\n    float disc = b * b - a * c;\n    if (disc < 0.0)\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n    }\n    else\n    {\n        float e = sqrt(disc);\n        p1 = vec4((-b - e) / a, 0.0, 0.0, 1.0);\n        p2 = vec4((-b + e) / a, 0.0, 0.0, 1.0);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec4 p1, out vec4 p2, out float t )\n{\n    vec2 t = (ro + rd * rad) - ro;\n    float d = dot(t, t);\n    float h = dot(rd, t);\n    float k = dot(rd, rd);\n    float a = k - h * h;\n    float b = d * k - h * h;\n    float c = d * d - rad * rad * k;\n    float disc = b * b - a * c;\n    if (disc < 0.0)\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n        t = 0.0;\n    }\n    else\n    {\n        float e = sqrt(disc);\n        p1 = vec4((-b - e) / a, 0.0, 0.0, 1.0);\n        p2 = vec4((-b + e) / a, 0.0, 0.0, 1.0);\n        t = min(p1.x, p2.x);\n    }\n", "\n\tvec2 d = p - c;\n\tfloat f = length(d) - r;\n\tvec2 g = normalize(d);\n\treturn vec3(f, g.x, g.y);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 d = abs(p) - b;\n\treturn vec3(max(d.x,d.y), sign(p.x)*d.x + sign(p.y)*d.y);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n\tvec2 q = p - vec2(0.5, 0.5);\n\tfloat r = length(q);\n\tfloat s = r - 0.5;\n\tfloat t = sqrt(1.0 - s*s);\n\tfloat u = s*t;\n\tfloat v = s + t;\n\tfloat w = s - t;\n\tfloat x = u*u*u;\n\tfloat y = v*v*v;\n\tfloat z = w*w*w;\n\treturn vec3(x, y, z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n  return a1 * x + b1;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat", "\n  return pow(fabs(sin(x)), n) * a + b;\n}\n\n// Fast push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);\n            }\n            float paperNoise(vec2 uv, float time){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time) * 43758.5453);\n            }\n            float paperNoise(vec2 uv, float time, float freq){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time * freq) * 43758.5453);\n            }\n            float paperNoise(vec2 uv, float time, float freq, float amp){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time * freq) * 43758.5453) * amp;\n            }\n            float paperNoise(vec2 uv, float time, float freq, float amp, float offset){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time * freq) * 43758.5453) * amp + offset;\n            }\n            float paperNoise(vec2 uv, float time, float freq, float amp, float offset, float scale){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time * freq) * 43758.5453) * amp + offset * scale;\n            }\n            float paperNoise(vec2 uv, float time, float freq, float amp, float offset, float scale, float offset2){\n                return fract(sin(dot(uv, vec2(12.9898,78.233)) * 43758.5453 + time * freq) * 43758.5453) * amp + offset * scale + offset2;\n            }\n            float paperNoise(vec2 uv, float time, float freq, float amp, float offset, float scale, float offset2, float scale2){\n                return fract(sin(dot(uv, vec2(12.9", "\n    vec3 result;\n    result.x = (x * x) + (y * y);\n    result.y = (x * x) + (y * y);\n    result.z = (x * x) + (y * y);\n    return result;\n}\n\n// Cost: (6/14 MUL  6/13 ADD)\nvec", "\n    return length(p-c)-r;\n}\n\nfloat", "\n    return length(max(abs(p-c)-b,0.0)) + min(max(p.x,p.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h2 = h * h;\n    float l2 = dot(ba,ba);\n    float t = clamp( dot(pa,ba)/l2, 0.0, 1.0 );\n    vec2 proj = a + ba*t;\n    vec2 off = normalize(p-proj) * h;\n    vec2 res = proj + off;\n    float d2 = dot(res-p,res-p);\n    return res;\n}\n\nfloat", "\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44 = 0.0;\n    float d45 = 0.0;\n    float d46 = 0.0;\n    float d47 = 0.0;\n    float d48 = 0.0;\n    float d49 = 0.0;\n    float d50 = 0.0;\n    float", "\n\tp = abs(p);\n\treturn max(p.x,p.y);\n}\n\n// correct outside, correct inside\nfloat", "\n\treturn smoothstep( -0.5, 0.5, p.y );\n}\n\n// correct inside, incorrect outside\nfloat", "\n\t// Simple gray-scale pattern.\n\tfloat v = dot(uv, vec2(1.));\n\treturn vec3(v, v, v);\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec", "\n\tvec2 pa = a - p;\n\tvec2 ba = b - a;\n\tfloat t = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn a + ba * t;\n}\n\n// Closest point on circle\nvec", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*t ) - th;\n}\n\n// distance to circle\nfloat", "\n\tvec2 d = abs(p) - b;\n\treturn p - clamp( d, 0.0, r ) * sign(d);\n}\n\n// closest point on rounded box\nvec", "\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// distance to rounded cylinder\nfloat", "\n    return max( abs(p.x)-b.x, abs(p.y)-b.y );\n}\n\n// distance to box\nfloat", "\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// This is the main function that does all the work.\n// It takes a position in the texture and returns the color at that position.\nvec", "\n\treturn fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// From iq\nfloat", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0.0, 1.0));\n    float d = noise(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    float u = smoothstep(0.0, 1.0, f.x);\n    float v = smoothstep(0.0, 1.0, f.y);\n    // Mix 4 coorners percentages\n    return mix(a, b, u) + (c - a) * v * (1.0 - u) + (d - b) * u * v;\n}\n\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 4; i++)\n    {\n        v += a * noise(x);\n        x *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// The main function\nvoid main()\n{\n    // Get the position of the fragment\n    vec2 pos = gl_FragCoord.xy;\n    // Get the position of the fragment in the range [0, 1]\n    vec2 uv = pos / iResolution.xy;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 p = 2.0 * uv - 1.0;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 q = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 r = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 s = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 t = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 u = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 v = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 w = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 x = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 y = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 z = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 a = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 b = p;\n    // Get the position of the fragment in the range [-1, 1]\n    vec2 c = p;\n    // Get the position of the fragment in the range [-1, 1", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// A simple checkerboard pattern\nfloat", "\n    return 1.0 / (4.0 * atan(1.0));\n}\n\nfloat", "\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec4 h = clamp(i, 0.0, 1.0);\n    vec4 b = vec4(h.x, h.y, h.z, h.y);\n    vec4 a = vec4(h.x - 1.0, h.y - 1.0, h.z - 1.0, h.y - 1.0);\n    vec4 c = vec4(a.x + b.x, a.y + b.y, a.z + b.z, a.y + b.y);\n    vec4 d = vec4(a.z + b.x, a.y + b.y, a.x + b.x, a.y + b.y);\n    vec3 e = mix(vec3(a), vec3(c), f.x);\n    vec3 f1 = mix(vec3(b), vec3(d), f.x);\n    return mix(e, f1, f.y);\n}\n\n// From <NAME> (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat", "\n    float h = dot(x,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\n// this is the main function that does the magic\n// it takes a position in the fractal space and\n// returns a value between 0 and 1\nfloat", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\treturn length( pa - dot( pa, ba ) * ba ) / length( ba );\n}\n\nfloat", "\n    vec2 d = abs(p) - b - r;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat", "\n    // The projection center is the center of the disk.\n    proj_center = vec2(center.xy);\n\n    // The major axis is the normal to the disk.\n    major = vec2(normal.xy);\n\n    // The minor axis is the tangent to the disk at the center.\n    // The minor axis is the vector from the center to the projection center.\n    minor = normalize(proj_center - center.xy);\n\n    // The radius of the projection is the radius of the disk.\n    proj_info.x = radius;\n}\n\n// Project a circle onto a plane.\n// The plane is defined by a normal and a distance from the origin.\n// The circle is defined by a center and a radius.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.\n// The projection is a circle.\n// The projection is defined by a center and a radius.", "\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4t2SRW\nfloat", "\n    float d = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m2 = m * 2.0;\n    float m3 = m * 3.0;\n    float m4 = m * 4.0;\n    float m5 = m * 5.0;\n    float m6 = m * 6.0;\n    float m7 = m * 7.0;\n    float m8 = m * 8.0;\n    float m9 = m * 9.0;\n    float m10 = m * 10.0;\n    float m11 = m * 11.0;\n    float m12 = m * 12.0;\n    float m13 = m * 13.0;\n    float m14 = m * 14.0;\n    float m15 = m * 15.0;\n    float m16 = m * 16.0;\n    float m17 = m * 17.0;\n    float m18 = m * 18.0;\n    float m19 = m * 19.0;\n    float m20 = m * 20.0;\n    float m21 = m * 21.0;\n    float m22 = m * 22.0;\n    float m23 = m * 23.0;\n    float m24 = m * 24.0;\n    float m25 = m * 25.0;\n    float m26 = m * 26.0;\n    float m27 = m * 27.0;\n    float m28 = m * 28.0;\n    float m29 = m * 29.0;\n    float m30 = m * 30.0;\n    float m31 = m * 31.0;\n    float m32 = m * 32.0;\n    float m33 = m * 33.0;\n    ", "\n    vec3 d = abs(p) - 0.5;\n    return normalize(sign(d) * d.xxy + sign(d.yzx) * vec3(0.0, d.zxy, d.yzx));\n}\n\n// https://iquilezles.org/articles/normalsSDF octahedron normals\nvec", "\n    float t = t0;\n    for (int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (p.y < 0.0)\n            return 0.0;\n        if (p.y > 1.0)\n            return 0.0;\n        if (p.x * p.x + p.z * p.z < 1.0)\n            return 0.0;\n        t += EPSILON;\n    }\n    return 1.0;\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface\n//       (normal could be calculated here but that would most likely be redundant)\nfloat", "\n    float cosTheta = clamp( dot( nor, vec3( 0.0, 0.0, 1.0 ) ), 0.0, 1.0 );\n    float distance = 0.0;\n    float power = 1.0;\n    float occlusion = 0.0;\n    float stepSize = 0.01;\n    float rayStep = 0.0;\n    float rayStepAccum = 0.0;\n    float rayStepAccumSq = 0.0;\n    float rayStepAccumSq2 = 0.0;\n    float rayStepAccumSq3 = 0.0;\n    float rayStepAccumSq4 = 0.0;\n    float rayStepAccumSq5 = 0.0;\n    float rayStepAccumSq6 = 0.0;\n    float rayStepAccumSq7 = 0.0;\n    float rayStepAccumSq8 = 0.0;\n    float rayStepAccumSq9 = 0.0;\n    float rayStepAccumSq10 = 0.0;\n    float rayStepAccumSq11 = 0.0;\n    float rayStepAccumSq12 = 0.0;\n    float rayStepAccumSq13 = 0.0;\n    float rayStepAccumSq14 = 0.0;\n    float rayStepAccumSq15 = 0.0;\n    float rayStepAccumSq16 = 0.0;\n    float rayStepAccumSq17 = 0.0;\n    float rayStepAccumSq18 = 0.0;\n    float rayStepAccumSq19 = 0.0;\n    float rayStepAccumSq20 = 0.0;\n    float rayStepAccumSq21 = 0.0;\n    float rayStepAccumSq22 = 0.0;\n    float rayStepAccumSq23 = 0.0;\n    float rayStepAccumSq24 = 0.0;\n    float rayStepAccumSq25 = 0.0;\n    float rayStepAccumSq26 = 0.0;\n    float rayStepAccumSq27 = 0.0;\n    float rayStepAccumSq28 = 0.", "\n    mat3 result;\n    float cos = cosf(angle);\n    float sin = sinf(angle);\n    float t = 1.0f - cos;\n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float yz = axis.y * axis.z;\n    result[0][0] = t * axis.x * axis.x + cos;\n    result[0][1] = t * xy - sin * axis.z;\n    result[0][2] = t * xz + sin * axis.y;\n    result[1][0] = t * xy + sin * axis.z;\n    result[1][1] = t * axis.y * axis.y + cos;\n    result[1][2] = t * yz - sin * axis.x;\n    result[2][0] = t * xz - sin * axis.y;\n    result[2][1] = t * yz + sin * axis.x;\n    result[2][2] = t * axis.z * axis.z + cos;\n    return result;\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat", "\n    vec2 depth = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 direction = normalize(vec3(uv, 1.0));\n    return origin + direction * depth.x;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec", "\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat", "\n\treturn p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x + p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y*p.y + p.z*p.z*p.z*p.z*p.z*p.z*p.z*p.z*p.z*p.z*p.z;\n}\n\n// Hash for 4d vectors\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    return mix(mix(mix(dot(gl_TextureMatrix[0][2].x,\n                           gl_TextureMatrix[0][3]),\n                       dot(gl_TextureMatrix[0][2].y,\n                           gl_TextureMatrix[0][3]),\n                       f.x),\n                   mix(dot(gl_TextureMatrix[0][2].z,\n                           gl_TextureMatrix[0][3]),\n                       dot(gl_TextureMatrix[0][2].w,\n                           gl_TextureMatrix[0][3]),\n                       f.x),\n                   f.y),\n               mix(mix(dot(gl_TextureMatrix[0][2].x,\n                           gl_TextureMatrix[0][3]),\n                       dot(gl_TextureMatrix[0][2].y,\n                           gl_TextureMatrix[0][3]),\n                       f.z),\n                   mix(dot(gl_TextureMatrix[0][2].z,\n                           gl_TextureMatrix[0][3]),\n                       dot(gl_TextureMatrix[0][2].w,\n                           gl_TextureMatrix[0][3]),\n                       f.z),\n                   f.y),\n               f.z);\n}\n\n// 4D value noise\nfloat", "\n    vec3 q = floor(p);\n    vec3 r = p - q;\n    vec3 s = r * r * (3. - 2. * r);\n    return mix(mix(mix(dot(q, q + 1. - r), dot(q + 1. - r, q), r),\n                   dot(q + 1. - r, q + 1. - r), r),\n               dot(q, q), r);\n}\n\n// 3D simplex noise, cool trick\nfloat", "\n\tfloat scale = 0.1;\n\tfloat lacunarity = 2.0;\n\tfloat octaves = 8.0;\n\tfloat offset = 0.0;\n\tfloat gain = 0.55;\n\tfloat fbm = cloudsFBM(p, scale, lacunarity, octaves, offset, gain);\n\treturn fbm;\n}\n\n// FBM with some precisely adjusted behavior\nfloat", "\n\tvec3 pos2 = pos;\n\tpos2.z = pos.z * 0.5;\n\tfloat x = pos.x;\n\tfloat y = pos.y;\n\tfloat z = pos.z;\n\tfloat x2 = pos2.x;\n\tfloat y2 = pos2.y;\n\tfloat z2 = pos2.z;\n\tfloat x3 = x2 * 0.5;\n\tfloat y3 = y2 * 0.5;\n\tfloat z3 = z2 * 0.5;\n\tfloat x4 = x3 * 0.5;\n\tfloat y4 = y3 * 0.5;\n\tfloat z4 = z3 * 0.5;\n\tfloat x5 = x4 * 0.5;\n\tfloat y5 = y4 * 0.5;\n\tfloat z5 = z4 * 0.5;\n\tfloat x6 = x5 * 0.5;\n\tfloat y6 = y5 * 0.5;\n\tfloat z6 = z5 * 0.5;\n\tfloat x7 = x6 * 0.5;\n\tfloat y7 = y6 * 0.5;\n\tfloat z7 = z6 * 0.5;\n\tfloat x8 = x7 * 0.5;\n\tfloat y8 = y7 * 0.5;\n\tfloat z8 = z7 * 0.5;\n\tfloat x9 = x8 * 0.5;\n\tfloat y9 = y8 * 0.5;\n\tfloat z9 = z8 * 0.5;\n\tfloat x10 = x9 * 0.5;\n\tfloat y10 = y9 * 0.5;\n\tfloat z10 = z9 * 0.5;\n\tfloat x11 = x10 * 0.5;\n\tfloat y11 = y10 * 0.5;\n\tfloat z11 = z10 * 0.5;\n\tfloat x12 = x11 * 0.5;\n\tfloat y12 = y11 * 0.5;\n\tfloat z12 = z11 * 0.5;\n\tfloat x13 = x12 * 0.5;\n\tfloat y13 = y12 * 0.5;\n\tfloat z13 = z12 * 0.5", "\n\tfloat coverage = 0.0;\n\tfloat smoothstep = 0.0;\n\tfloat dir = 0.0;\n\tfloat height = 0.0;\n\tfloat height2 = 0.0;\n\tfloat height3 = 0.0;\n\tfloat height4 = 0.0;\n\tfloat height5 = 0.0;\n\tfloat height6 = 0.0;\n\tfloat height7 = 0.0;\n\tfloat height8 = 0.0;\n\tfloat height9 = 0.0;\n\tfloat height10 = 0.0;\n\tfloat height11 = 0.0;\n\tfloat height12 = 0.0;\n\tfloat height13 = 0.0;\n\tfloat height14 = 0.0;\n\tfloat height15 = 0.0;\n\tfloat height16 = 0.0;\n\tfloat height17 = 0.0;\n\tfloat height18 = 0.0;\n\tfloat height19 = 0.0;\n\tfloat height20 = 0.0;\n\tfloat height21 = 0.0;\n\tfloat height22 = 0.0;\n\tfloat height23 = 0.0;\n\tfloat height24 = 0.0;\n\tfloat height25 = 0.0;\n\tfloat height26 = 0.0;\n\tfloat height27 = 0.0;\n\tfloat height28 = 0.0;\n\tfloat height29 = 0.0;\n\tfloat height30 = 0.0;\n\tfloat height31 = 0.0;\n\tfloat height32 = 0.0;\n\tfloat height33 = 0.0;\n\tfloat height34 = 0.0;\n\tfloat height35 = 0.0;\n\tfloat height36 = 0.0;\n\tfloat height37 = 0.0;\n\tfloat height38 = 0.0;\n\tfloat height39 = 0.0;\n\tfloat height40 = 0.0;\n\tfloat height41 = 0.0;\n\tfloat height42 = 0.0;\n\tfloat height43 = 0.0;\n\tfloat height44 = 0.0;\n\tfloat height45 = 0.0;\n\tfloat height46 = 0.0;\n\tfloat height47 = 0.0;\n\tfloat height48 = 0.0;\n\tfloat height49", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float fog = 0.0;\n    float fogDist = 0.0;\n    float fogAmount = 0.0;\n    float fogAmount2 = 0.0;\n    float fogAmount3 = 0.0;\n    float fogAmount4 = 0.0;\n    float fogAmount5 = 0.0;\n    float fogAmount6 = 0.0;\n    float fogAmount7 = 0.0;\n    float fogAmount8 = 0.0;\n    float fogAmount9 = 0.0;\n    float fogAmount10 = 0.0;\n    float fogAmount11 = 0.0;\n    float fogAmount12 = 0.0;\n    float fogAmount13 = 0.0;\n    float fogAmount14 = 0.0;\n    float fogAmount15 = 0.0;\n    float fogAmount16 = 0.0;\n    float fogAmount17 = 0.0;\n    float fogAmount18 = 0.0;\n    float fogAmount19 = 0.0;\n    float fogAmount20 = 0.0;\n    float fogAmount21 = 0.0;\n    float fogAmount22 = 0.0;\n    float fogAmount23 = 0.0;\n    float fogAmount24 = 0.0;\n    float fogAmount25 = 0.0;\n    float fogAmount26 = 0.0;\n    float fogAmount27 = 0.0;\n    float fogAmount28 = 0.0;\n    float fogAmount29 = 0.0;\n    float fogAmount30 = 0.0;\n    float fogAmount31 = 0.0;\n    float fogAmount32 = 0.0;\n    float fogAmount33 = 0.0;\n    float fogAmount34 = 0.0;\n    float fogAmount35 = 0.0;\n    float fogAmount36 = 0.0;\n    float fogAmount37 = 0.0;\n    float fogAmount38 = 0.0;\n    float fogAmount39 = 0.0;\n    float fogAmount40 = 0.0;\n    float fogAmount41 = 0.0;\n    float fogAmount42 = 0.0;\n    float fogAmount43 = 0.0;", "\n    color = color / (0.0003 * color + 0.11);\n    color = color / (0.329 * color + 0.9);\n    return pow(color, vec3(1.0 / 2.2));\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec"]}