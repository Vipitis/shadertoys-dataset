{"generations": [" return 0.282095f; }\nfloat SH_1_0( in vec3 s ) { return 0.488603f * s.y; }\nfloat SH_1_1( in vec3 s ) { return 0.488603f * s.z; }\nfloat SH_1_2( in vec3 s ) { return 0.488603f * s.x; }\nfloat SH_2_0( in vec3 s ) { return 0.488603f * s.z * s.y; }\nfloat SH_2_1( in vec3 s ) { return 0.488603f * s.x * s.z; }\nfloat SH_2_2( in vec3 s ) { return 0.488603f * s.x * s.y; }\nfloat SH_3_0( in vec3 s ) { return 0.315392f * s.z * s.z; }\nfloat SH_3_1( in vec3 s ) { return 0.315392f * s.x * s.z; }\nfloat SH_3_2( in vec3 s ) { return 0.315392f * s.x * s.y; }\nfloat SH_3_3( in vec3 s ) { return 0.315392f * s.y * s.y; }\nfloat SH_4_0( in vec3 s ) { return 0.546274f * s.z * s.z * s.y; }\nfloat SH_4_1( in vec3 s ) { return 0.546274f * s.x * s.z * s.z; }\nfloat SH_4_2( in vec3 s ) { return 0.546274f * s.x * s.y * s.z; }\nfloat SH_4_3( in vec3 s ) { return 0.546274f * s.x * s.y * s.y; }\nfloat SH_4", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment (can't get simpler than this)\nfloat segment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a triangle (can't get simpler than this)\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    float s = 0.5/dot(c-b,cross(a-b,c-b));\n    float u = s*dot(p-b,cross(a-b,c-b));\n    float v = s*dot(p-a,cross(c-a,b-a));\n    return distance(p,a + u*cross(b-a,c-a)) * step(1.0,u+v);\n}\n\n// distance to a convex polygon (can't get simpler than this)\nfloat polygon( in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 p )\n{\n    float s = 0.5/dot(c-b,cross(a-b,c-b));\n    float u = s*dot(p-b,cross(a-b,c-b));\n    float v = s*dot(p-a,cross(c-a,b-a));\n    float w = 1.0 - u - v;\n    return distance(p,a + u*cross(b-a,c-a) + v*cross(c-a,d-a) + w*cross(d-a,a-a)) * step(1.0,u+v);\n}\n\n// distance to a convex polygon (can't get simpler than this)\nfloat polygon( in vec2 a, in vec2 b, in vec2 c", "\n\treturn mix( v, -v, step( 0.0, dot( v, r ) ) );\n}\n\n// Returns the distance from a point to a line\nfloat pointToLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn length( cross( p - a, b - a ) ) / length( b - a );\n}\n\n// Returns the distance from a point to a line segment\nfloat pointToLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn min( distance( p, a ), distance( p, b ) );\n}\n\n// Returns the distance from a point to a triangle\nfloat pointToTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tfloat d1 = distance( p, a );\n\tfloat d2 = distance( p, b );\n\tfloat d3 = distance( p, c );\n\treturn min( min( d1, d2 ), d3 );\n}\n\n// Returns the distance from a point to a rectangle\nfloat pointToRectangle( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 d = abs( p - a ) - b;\n\treturn length( max( d, 0.0 ) );\n}\n\n// Returns the distance from a point to a circle\nfloat pointToCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// Returns the distance from a point to a sphere\nfloat pointToSphere( in vec3 p, in vec3 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// Returns the distance from a point to a plane\nfloat pointToPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot( p, n ) - d;\n}\n\n// Returns the distance from a point to a triangle\nfloat pointToTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n\tfloat d1 = distance( p, a );\n\tfloat d2 = distance( p, b", "\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r ) * r;\n}\n\n// Reflect v if in the half plane defined by r (this works in 3D too)\nvec2 reflIfHalf( in vec2 v, in vec2 r )\n{\nreturn v - 2.0 * dot( v, r )", "\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\nreturn min( v, r );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\nreturn min( v, r );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\nreturn min( v, r );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in float r )\n{\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in float r )\n{\nreturn min( v, r );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in float r )\n{\nreturn max( v, -r );\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in float r )\n{\nreturn min( v, r );\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - ((w1+w2)*0.5);\n}\n\n// https://www.shadertoy.com/view/4sf3zW\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float r )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - ((w1+w2)*0.5) - r;\n}\n\n// https://www.shadertoy.com/view/4sf3zW\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float r, float h )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - ((w1+w2)*0.5) - r - h;\n}\n\n// https://www.shadertoy.com/view/4sf3zW\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float r, float h, float s )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - ((w1+w2)*0.5) - r - h - s;\n}\n\n// https://www.shadertoy.com/view/4sf3zW\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float r, float h, float s, float t )\n", "\n\tfloat nDotL = max(0.0, dot(rayDir, sunDir));\n\treturn sunCol * nDotL;\n}\n\n// This function is the same as the GetSunColorReflection function, but it is used for the skybox.\nvec3 GetSunColorSkybox(vec3 rayDir, vec3 sunDir)\n{\n\tfloat nDotL = max(0.0, dot(rayDir, sunDir));\n\treturn sunCol * nDotL;\n}\n\n// This function is used to get the color of the skybox.\nvec3 GetSkyboxColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 skyboxColor = vec3(0.0, 0.0, 0.0);\n\tskyboxColor = GetSunColorSkybox(rayDir, sunDir);\n\treturn skyboxColor;\n}\n\n// This function is used to get the color of the reflection.\nvec3 GetReflectionColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 reflectionColor = vec3(0.0, 0.0, 0.0);\n\treflectionColor = GetSunColorReflection(rayDir, sunDir);\n\treturn reflectionColor;\n}\n\n// This function is used to get the color of the refraction.\nvec3 GetRefractionColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 refractionColor = vec3(0.0, 0.0, 0.0);\n\trefractionColor = GetSunColorReflection(rayDir, sunDir);\n\treturn refractionColor;\n}\n\n// This function is used to get the color of the diffuse.\nvec3 GetDiffuseColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n\tdiffuseColor = GetSunColorReflection(rayDir, sunDir);\n\treturn diffuseColor;\n}\n\n// This function is used to get the color of the specular.\nvec3 GetSpecularColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 specularColor = vec3(0.0, 0.0, 0.0);\n\t", "\n\tvec4 a = p2;\n\tvec4 b = p0;\n\tvec4 c = p1 - p0;\n\tvec4 d = p3 - p2;\n\tvec4 ab = b + c * t;\n\tvec4 cd = d * t;\n\treturn (a + ab + cd) * 0.5;\n}\n\n// This is a spline used for the camera path\nvec4 Hermite(vec4 p0, vec4 p1, vec4 t0, vec4 t1, float t)\n{\n\tvec4 a = p0;\n\tvec4 b = p1;\n\tvec4 c = t0;\n\tvec4 d = t1;\n\tvec4 ab = b - a;\n\tvec4 cd = d - c;\n\tvec4 abc = ab * 3.0 - c - cd;\n\tvec4 bcd = cd * 3.0 - d - ab;\n\tvec4 abcd = abc * t + bcd * t * t + c * t * t * t + a * t * t * t * t;\n\treturn abcd;\n}\n\n// This is a spline used for the camera path\nvec4 Bezier(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tvec4 a = p0;\n\tvec4 b = p1;\n\tvec4 c = p2;\n\tvec4 d = p3;\n\tvec4 ab = b - a;\n\tvec4 bc = c - b;\n\tvec4 cd = d - c;\n\tvec4 abc = ab * 3.0 - bc - cd;\n\tvec4 bcd = bc * 3.0 - cd - ab;\n\tvec4 abcd = abc * t + bcd * t * t + bc * t * t * t + a * t * t * t * t;\n\treturn abcd;\n}\n\n// This is a spline used for the camera path\nvec4 BSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n\tvec4 a = p0;\n\tvec4 b = p1;\n\t", "\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tsum += amp * sin(freq * (p.x + p.y + p.z));\n\t\tfreq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn sum * normalizer;\n}\n\n// This is a 3D version of the 2D simplex noise.\n// It's a bit slower than the 2D version, but it's a lot more interesting.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a lot more interesting than the 3D version of the 2D simplex noise.\n// It's also a", "\n\tvec4 p0 = camPath[0];\n\tvec4 p1 = camPath[1];\n\tvec4 p2 = camPath[2];\n\tvec4 p3 = camPath[3];\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p2 - p0;\n\tvec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n\tvec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n\tvec4 pos = 0.5 * (a + (b * t) + (c * t * t) + (d * t * t * t));\n\n\treturn pos;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamDir(float t)\n{\n\tvec4 p0 = camPath[0];\n\tvec4 p1 = camPath[1];\n\tvec4 p2 = camPath[2];\n\tvec4 p3 = camPath[3];\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p2 - p0;\n\tvec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n\tvec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n\n\tvec4 dir = (a + (2.0 * b * t) + (2.0 * c * t * t) + (d * t * t * t));\n\n\treturn dir;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamUp(float t)\n{\n\tvec4 p0 = camPath[0];\n\tvec4 p1 = camPath[1];\n\tvec4 p2 = camPath[2];\n\tvec4 p3 = camPath[3];\n\n\tvec4 a = 2.0 * p1;\n\tvec4 b = p", "\n\treturn fract(sin(u) * 43758.5453123);\n}\n\nfloat Hash2d(float u, float v)\n{\n\treturn fract(sin(u + v) * 43758.5453123);\n}\n\nfloat Hash3d(float u, float v, float w)\n{\n\treturn fract(sin(u + v + w) * 43758.5453123);\n}\n\nfloat Hash4d(float u, float v, float w, float t)\n{\n\treturn fract(sin(u + v + w + t) * 43758.5453123);\n}\n\nfloat Noise1d(float u)\n{\n\tfloat u1 = floor(u);\n\tfloat u2 = u1 + 1.0;\n\tfloat w1 = u - u1;\n\tfloat w2 = 1.0 - w1;\n\tfloat h1 = Hash1d(u1);\n\tfloat h2 = Hash1d(u2);\n\treturn w1 * h1 + w2 * h2;\n}\n\nfloat Noise2d(float u, float v)\n{\n\tfloat u1 = floor(u);\n\tfloat v1 = floor(v);\n\tfloat u2 = u1 + 1.0;\n\tfloat v2 = v1 + 1.0;\n\tfloat w1 = u - u1;\n\tfloat w2 = 1.0 - w1;\n\tfloat h1 = Hash2d(u1, v1);\n\tfloat h2 = Hash2d(u2, v1);\n\tfloat h3 = Hash2d(u1, v2);\n\tfloat h4 = Hash2d(u2, v2);\n\tfloat h12 = mix(h1, h2, w1);\n\tfloat h34 = mix(h3, h4, w1);\n\treturn mix(h12, h34, w2);\n}\n\nfloat Noise3d(float u, float v, float w)\n{\n\tfloat", "\n\tfloat f = 0.0;\n\tfloat a = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tf += 0.5 * sin(p.x * scale + a) + 0.5 * cos(p.y * scale + a) + 0.5 * sin(p.z * scale + a);\n\t\ta += 0.1;\n\t\tscale *= 2.0;\n\t}\n\treturn f * normalizer;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat Noise3D(vec3 p)\n{\n\treturn RustNoise3D(p) * 0.5 + 0.5;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat Noise3D(vec3 p, float scale)\n{\n\treturn RustNoise3D(p) * 0.5 + 0.5;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat Noise3D(vec3 p, float scale, float offset)\n{\n\treturn RustNoise3D(p) * 0.5 + 0.5;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat Noise3D(vec3 p, float scale, float offset, float power)\n{\n\treturn RustNoise3D(p) * 0.5 + 0.5;\n}\n\n// This is a 3D noise function that uses a 2D noise function to generate the 3rd dimension.\n// It's a bit of a hack, but it works well.\nfloat Noise3D(", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td += pow(abs(p.x), 0.5) + pow(abs(p.y), 0.5) + pow(abs(p.z), 0.5);\n\t\tp = vec3(pow(abs(p.x), 0.5), pow(abs(p.y), 0.5), pow(abs(p.z), 0.5));\n\t}\n\treturn d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject2(vec3 p)\n{\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td += pow(abs(p.x), 0.5) + pow(abs(p.y), 0.5) + pow(abs(p.z), 0.5);\n\t\tp = vec3(pow(abs(p.x), 0.5), pow(abs(p.y), 0.5), pow(abs(p.z), 0.5));\n\t}\n\treturn d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject3(vec3 p)\n{\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\td += pow(abs(p.x), 0.5) + pow(abs(p.y), 0.5) + pow(abs(p.z), 0.5);\n\t\tp = vec3(pow(abs(p.x), 0.5), pow(abs(p.y), 0.5), pow(abs(p.z), 0.5));\n\t}\n\treturn d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject4(vec3 p)\n{\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 10;", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = normalize(rayDir);\n\tvec3 lightDir = normalize(sunDir);\n\tvec3 lightDir2 = normalize(sunDir + vec3(0.0, 0.0, -1.0));\n\tvec3 lightDir3 = normalize(sunDir + vec3(0.0, 0.0, 1.0));\n\tvec3 lightDir4 = normalize(sunDir + vec3(0.0, -1.0, 0.0));\n\tvec3 lightDir5 = normalize(sunDir + vec3(0.0, 1.0, 0.0));\n\tvec3 lightDir6 = normalize(sunDir + vec3(-1.0, 0.0, 0.0));\n\tvec3 lightDir7 = normalize(sunDir + vec3(1.0, 0.0, 0.0));\n\tvec3 lightDir8 = normalize(sunDir + vec3(0.0, 0.0, -2.0));\n\tvec3 lightDir9 = normalize(sunDir + vec3(0.0, 0.0, 2.0));\n\tvec3 lightDir10 = normalize(sunDir + vec3(0.0, -2.0, 0.0));\n\tvec3 lightDir11 = normalize(sunDir + vec3(0.0, 2.0, 0.0));\n\tvec3 lightDir12 = normalize(sunDir + vec3(-2.0, 0.0, 0.0));\n\tvec3 lightDir13 = normalize(sunDir + vec3(2.0, 0.0, 0.0));\n\tvec3 lightDir14 = normalize(sunDir + vec3(0.0, 0.0, -3.0));\n\tvec3 lightDir15 = normalize(sunDir + vec3(0.0, 0.0, 3.0));\n\tvec3 lightDir16 = normalize(sunDir + vec3(0.0, -3.0, 0.0));\n\tvec3 lightDir17 = normalize(sunDir + vec3(0.", "\n\tfloat h = clamp( 0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * k * (b - a);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5f - 0.5f * (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * k * (b - a);\n}\n\n// polynomial smooth step (k = 0.1);\nfloat sstep( float a, float b, float k )\n{\n\tfloat h = clamp( (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * k * (b - a);\n}\n\n// polynomial smooth step (k = 0.1);\nfloat ssmoothstep( float a, float b, float k )\n{\n\tfloat h = clamp( (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * h * h * (b - a);\n}\n\n// polynomial smooth step (k = 0.1);\nfloat ssmootherstep( float a, float b, float k )\n{\n\tfloat h = clamp( (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * h * h * (b - a);\n}\n\n// polynomial smooth step (k = 0.1);\nfloat ssmootherstep( float a, float b, float k )\n{\n\tfloat h = clamp( (b - a) / k, 0.0f, 1.0f );\n\treturn a + h * h * h * (b - a);\n}\n\n// polynomial smooth step (k = 0.1);\nfloat ssmootherstep( float a, float b, float k )\n{\n\tfloat h = clamp( (b - a) / k, 0.0f, 1.0f );\n\treturn a + h *", "\n\tfloat a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n\tfloat b = 2.0f * dot(dirVecPLZNormalizeMeFirst, (pos - spherePos));\n\tfloat c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n\tfloat discriminant = b * b - 4.0f * a * c;\n\tif (discriminant < 0.0f)\n\t{\n\t\treturn -1.0f;\n\t}\n\telse\n\t{\n\t\treturn (-b - sqrt(discriminant)) / (2.0f * a);\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, vec3& normal)\n{\n\tfloat a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n\tfloat b = 2.0f * dot(dirVecPLZNormalizeMeFirst, (pos - spherePos));\n\tfloat c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n\tfloat discriminant = b * b - 4.0f * a * c;\n\tif (discriminant < 0.0f)\n\t{\n\t\treturn -1.0f;\n\t}\n\telse\n\t{\n\t\tfloat t = (-b - sqrt(discriminant)) / (2.0f * a);\n\t\tnormal = normalize(pos + t * dirVecPLZNormalizeMeFirst - spherePos);\n\t\treturn t;\n\t}\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, vec3& normal, vec3& tangent)\n{\n\tfloat a = dot(dirVecPLZNormalizeMeFirst, dirVecPLZNormalizeMeFirst);\n\tfloat b = 2.0f * dot(dirVecPLZNormalizeMeFirst, (pos - spherePos));\n\tfloat c = dot(pos - spherePos, pos - spherePos) - rad * rad;\n\tfloat discriminant = b *", "\nvec3 d = p - objectPosition;\nreturn vec2(length(d), sign(d.z));\n}\n\n// Calculate the distance field that defines the plane.\nvec2 DistanceToPlane(vec3 p)\n{\nvec3 d = p - planePosition;\nreturn vec2(length(d), sign(d.y));\n}\n\n// Calculate the distance field that defines the sphere.\nvec2 DistanceToSphere(vec3 p)\n{\nvec3 d = p - spherePosition;\nreturn vec2(length(d) - sphereRadius, sign(d.z));\n}\n\n// Calculate the distance field that defines the box.\nvec2 DistanceToBox(vec3 p)\n{\nvec3 d = abs(p - boxPosition) - boxSize;\nreturn vec2(max(max(d.x, d.y), d.z), sign(d.z));\n}\n\n// Calculate the distance field that defines the cylinder.\nvec2 DistanceToCylinder(vec3 p)\n{\nvec3 d = abs(p - cylinderPosition) - cylinderSize;\nreturn vec2(max(max(d.x, d.y), d.z), sign(d.z));\n}\n\n// Calculate the distance field that defines the torus.\nvec2 DistanceToTorus(vec3 p)\n{\nvec3 d = abs(p - torusPosition) - torusSize;\nreturn vec2(max(max(d.x, d.y), d.z), sign(d.z));\n}\n\n// Calculate the distance field that defines the cone.\nvec2 DistanceToCone(vec3 p)\n{\nvec3 d = abs(p - conePosition) - coneSize;\nreturn vec2(max(max(d.x, d.y), d.z), sign(d.z));\n}\n\n// Calculate the distance field that defines the ellipsoid.\nvec2 DistanceToEllipsoid(vec3 p)\n{\nvec3 d = abs(p - ellipsoidPosition) - ellipsoidSize;\nreturn vec2(max(max(d.x, d.y), d.z), sign(d.z));\n}\n\n// Calculate the distance field", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD3(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n\treturn vec3(0.0, 0.0, 0", "\n\treturn 3.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (acceleration)\nvec3 mapD2(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (jerk)\nvec3 mapD3(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (snap)\nvec3 mapD4(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (crackle)\nvec3 mapD5(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (pop)\nvec3 mapD6(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (bounce)\nvec3 mapD7(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (elastic)\nvec3 mapD8(float t)\n{\n\treturn 6.0f * t * (1.0f - t) * vec3(1.0f, 0.0f, 0.0f);\n}\n\n// curve derivative (back)\nvec3 mapD9(float t)\n{\n\treturn 6.0f * t * (1", "\n\treturn 6.0f * (1.0f - t) * (1.0f - t) * p0 + 12.0f * (1.0f - t) * t * p1 + 6.0f * t * t * p2;\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n\treturn 6.0f * (1.0f - t) * (1.0f - t) * (1.0f - t) * p0 + 12.0f * (1.0f - t) * (1.0f - t) * t * p1 + 12.0f * (1.0f - t) * t * t * p2 + 6.0f * t * t * t * p3;\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n\treturn 20.0f * (1.0f - t) * (1.0f - t) * (1.0f - t) * (1.0f - t) * p0 + 120.0f * (1.0f - t) * (1.0f - t) * (1.0f - t) * t * p1 + 120.0f * (1.0f - t) * (1.0f - t) * t * t * p2 + 20.0f * t * t * t * t * p3;\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n\treturn 70.0f * (1.0f - t) * (1.0f - t) * (1.0f - t) * (1.0f - t) * (1.0f - t) * p0 + 315.0f * (1.0f - t) * (1.0f - t) * (1.0f - t) * (1.0f - t) * t * p1 + 315.0f * (1.0f - t) * (1.0", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// unsigned squared distance between point and triangle\nfloat usqdPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n\treturn min( min( usqdPointSegment( p, a, b ), usqdPointSegment( p, b, c ) ), usqdPointSegment( p, c, a ) );\n}\n\n// unsigned squared distance between point and plane\nfloat usqdPointPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot( p, n ) - d;\n}\n\n// unsigned squared distance between point and sphere\nfloat usqdPointSphere( in vec3 p, in vec3 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// unsigned squared distance between point and box\nfloat usqdPointBox( in vec3 p, in vec3 b, in vec3 c )\n{\n\tvec3 d = abs( p - c ) - b;\n\treturn max( d.x, max( d.y, d.z ) ) * max( d.x, max( d.y, d.z ) );\n}\n\n// unsigned squared distance between point and frustum\nfloat usqdPointFrustum( in vec3 p, in vec3 n, in float d, in vec4 params )\n{\n\tfloat s = dot( p, n ) - d;\n\tfloat q = params.x * params.x + params.y * params.y + params.z * params.z;\n\treturn s * s / q;\n}\n\n// unsigned squared distance between point and plane\nfloat usqdPointPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot( p, n ) - d;\n}\n\n// unsigned squared distance between point and plane\nfloat usqdPointPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot( p, n ) - d;\n}", "\n\tvec3 ab = b - a;\n\tvec3 ao = o - a;\n\tvec3 ad = d;\n\tfloat t = dot( ao, ab ) / dot( ad, ab );\n\tvec3 p = a + t * ab;\n\tvec3 v = p - o;\n\treturn vec2( length( v ), t );\n}\n\n// unsigned squared distance between ray and triangle\nfloat usqdRayTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n\tvec2 usqd = usqdLineSegment( a, b, o, d );\n\tfloat usqd1 = usqd.x;\n\tvec2 usqd2 = usqdLineSegment( b, c, o, d );\n\tfloat usqd3 = usqd2.x;\n\tvec2 usqd4 = usqdLineSegment( c, a, o, d );\n\tfloat usqd5 = usqd4.x;\n\treturn min( usqd1, min( usqd3, usqd5 ) );\n}\n\n// unsigned squared distance between ray and plane\nfloat usqdRayPlane( vec3 p, vec3 n, vec3 o, vec3 d )\n{\n\tfloat t = dot( p - o, n ) / dot( d, n );\n\tvec3 p1 = o + t * d;\n\tvec3 v = p1 - p;\n\treturn length( v );\n}\n\n// unsigned squared distance between ray and sphere\nfloat usqdRaySphere( vec3 c, float r, vec3 o, vec3 d )\n{\n\tvec3 oc = o - c;\n\tfloat a = dot( d, d );\n\tfloat b = 2.0 * dot( d, oc );\n\tfloat c = dot( oc, oc ) - r * r;\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif ( discriminant < 0.0 )\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\tfloat t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n\t\tvec3 p = o + t * d;\n\t\tvec3", "\n\tvec2 d = abs(p) - b;\n\tvec2 a = vec2(0.0);\n\ta.x = max(d.x,d.y);\n\ta.y = length(max(d,0.0));\n\treturn min(max(a.x,a.y),max(r.x,r.y)) - min(min(r.z,r.w),0.0);\n}\n\n// 2D Round Box\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n\tvec2 d = abs(p) - b;\n\tvec2 a = vec2(0.0);\n\ta.x = max(d.x,d.y);\n\ta.y = length(max(d,0.0));\n\treturn min(max(a.x,a.y),r) - min(min(r,r),0.0);\n}\n\n// 2D Round Box\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n\tvec3 d = abs(p) - b;\n\tvec3 a = vec3(0.0);\n\ta.x = max(d.x,d.y);\n\ta.y = max(a.x,d.z);\n\ta.z = length(max(d,0.0));\n\treturn min(max(a.x,a.y),max(a.z,max(r.x,r.y))) - min(min(r.z,r.w),0.0);\n}\n\n// 2D Round Box\n// b.x", "\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn sunCol * sunDot;\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is the same as the GetSunColorReflection function, but it is used for the skybox.\nvec3 GetSunColorSkybox(vec3 rayDir, vec3 sunDir)\n{\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn sunCol * sunDot;\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is used to get the color of the skybox.\nvec3 GetSkyboxColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn vec3(0.0);\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is used to get the color of the ground.\nvec3 GetGroundColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn vec3(0.0);\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is used to get the color of the water.\nvec3 GetWaterColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat sunDot = dot(rayDir, sunDir);\n\tif (sunDot > 0.0)\n\t{\n\t\treturn vec3(0.0);\n\t}\n\telse\n\t{\n\t\treturn vec3(0.0);\n\t}\n}\n\n// This function is used to get the color of the grass.\nvec3 GetGrassColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat sunDot = dot(rayDir, sunDir", "\n\t// This is the vector that points from the center of the eye to the center of the window\n\tvec3 eyeToWindow = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro;\n\n\t// This is the vector that points from the center of the eye to the center of the screen\n\tvec3 eyeToScreen = vec3( 0.0, 0.0, -1.0 );\n\n\t// This is the vector that points from the center of the window to the center of the screen\n\tvec3 windowToScreen = ta - ro", "\n\tvec3 center = vec3( 0.0, 0.0, 0.0 );\n\tfloat radius = 0.5;\n\tfloat height = 0.5;\n\tfloat thickness = 0.1;\n\tfloat falloff = 0.1;\n\tfloat heightFalloff = 0.1;\n\tfloat heightFalloff2 = 0.1;\n\tfloat heightFalloff3 = 0.1;\n\tfloat heightFalloff4 = 0.1;\n\tfloat heightFalloff5 = 0.1;\n\tfloat heightFalloff6 = 0.1;\n\tfloat heightFalloff7 = 0.1;\n\tfloat heightFalloff8 = 0.1;\n\tfloat heightFalloff9 = 0.1;\n\tfloat heightFalloff10 = 0.1;\n\tfloat heightFalloff11 = 0.1;\n\tfloat heightFalloff12 = 0.1;\n\tfloat heightFalloff13 = 0.1;\n\tfloat heightFalloff14 = 0.1;\n\tfloat heightFalloff15 = 0.1;\n\tfloat heightFalloff16 = 0.1;\n\tfloat heightFalloff17 = 0.1;\n\tfloat heightFalloff18 = 0.1;\n\tfloat heightFalloff19 = 0.1;\n\tfloat heightFalloff20 = 0.1;\n\tfloat heightFalloff21 = 0.1;\n\tfloat heightFalloff22 = 0.1;\n\tfloat heightFalloff23 = 0.1;\n\tfloat heightFalloff24 = 0.1;\n\tfloat heightFalloff25 = 0.1;\n\tfloat heightFalloff26 = 0.1;\n\tfloat heightFalloff27 = 0.1;\n\tfloat heightFalloff28 = 0.1;\n\tfloat heightFalloff29 = 0.1;\n\tfloat heightFalloff30 = 0.1;\n\tfloat heightFalloff", "\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH AM I CLOSER TO?'\n\t// 'TAG : WHICH", "\n\tvec2 closestThing = vec2( 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec3 normal = vec3(\n\t\tsdf( positionOfHit + vec3( 0.001, 0, 0 ) ) - sdf( positionOfHit - vec3( 0.001, 0, 0 ) ),\n\t\tsdf( positionOfHit + vec3( 0, 0.001, 0 ) ) - sdf( positionOfHit - vec3( 0, 0.001, 0 ) ),\n\t\tsdf( positionOfHit + vec3( 0, 0, 0.001 ) ) - sdf( positionOfHit - vec3( 0, 0, 0.001 ) )\n\t);\n\treturn normalize( normal );\n}\n\n// This is the main function that is called by the shader\n// to calculate the color of a pixel.\nvec4 getColor( in vec3 positionOfHit ){\n\t// Here we are getting the normal of the surface\n\t// at the point of the hit.\n\tvec3 normal = getNormalOfSurface( positionOfHit );\n\n\t// Here we are getting the color of the surface\n\t// at the point of the hit.\n\tvec3 color = getColorOfSurface( positionOfHit );\n\n\t// Here we are getting the lighting of the surface\n\t// at the point of the hit.\n\tvec3 lighting = getLighting( positionOfHit, normal, color );\n\n\t// Here we are returning the color of the pixel.\n\treturn vec4( lighting, 1.0 );\n}\n\n// This is the main function that is called by the shader\n// to calculate the color of a pixel.\nvec4 getColor( in vec3 positionOfHit, in vec3 normalOfHit ){\n\t// Here we are getting the color of the surface\n\t// at the point of the hit.\n\tvec3 color = getColorOfSurface( positionOfHit );\n\n\t// Here we are getting the lighting of the surface\n\t// at the point of the hit.\n\tvec3 lighting = getLighting( positionOfHit, normalOfHit, color );\n\n\t// Here we are returning the color of the pixel.\n\treturn vec4( lighting, 1.0 );\n}\n\n// This is the main function that is", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n// this is the function that does the actual\n// lighting. it takes in the normal of the\n// surface, the direction of the light, and\n// the color of the light.\nvec3 doLighting(vec3 normal, vec3 lightDir, vec3 lightColor){\n\t// we need to normalize the normal\n\t// and the light direction.\n\tnormal = normalize(normal);\n\tlightDir = normalize(lightDir);\n\n\t// we need to find the dot product\n\t// of the normal and the light direction.\n\t// this is the cosine of the angle between\n\t// the normal and the light direction.\n\tfloat cosTheta = dot(normal, lightDir);\n\n\t// we need to make sure that the cosine\n\t// is not negative. if it is, we need to\n\t// make it 0.\n\tif(cosTheta < 0.0){\n\t\tcosTheta = 0.0;\n\t}\n\n\t// we need to find the color of the\n\t// lighting. we do this by multiplying\n\t// the color of the light by the cosine\n\t// of the angle between the normal and\n\t// the light direction.\n\tvec3 color = lightColor * cosTheta;\n\n\t// we need to return the color of the\n\t// lighting.\n\treturn color;\n}\n\n// this is the function that does the\n// shading. it takes in the normal of the\n// surface, the direction of the light,\n// the color of the light, and the color\n// of the surface.\nvec3 doShading(vec3 normal, vec3 lightDir, vec3 lightColor, vec3 surfaceColor){\n\t// we need to normalize the normal\n\t// and the light direction.\n\tnormal = normalize(normal);\n\tlightDir = normalize(lightDir);\n\n\t// we need to find the dot product\n\t// of the normal and the light direction.\n\t// this is the cosine of the angle between\n\t// the normal and the light direction.\n\tfloat cosTheta = dot(normal, lightDir);\n\n\t// we need to make sure that the cosine\n\t// is not negative. if it is, we need", "\n\tvec3 color = vec3(0.0,0.0,0.0);\n\tcolor = normalOfSurface;\n\treturn color;\n}\n\n// This is the main function that does the ray tracing.\n// It takes in a ray, and returns the color of the ray.\nvec3 doRayTracing(Ray ray){\n\t// This is the color of the ray.\n\tvec3 color = vec3(0.0,0.0,0.0);\n\n\t// This is the distance to the closest object.\n\tfloat closestDistance = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\t// This is the color of the world\n\t// we will return at the end of this function\n\tvec3 worldColor = vec3(0.0);\n\n\t// This is the color of the object\n\t// we will return at the end of this function\n\tvec3 objectColor = vec3(0.0);\n\n\t// This is the color of the light\n\t// we will return at the end of this function\n\tvec3 lightColor = vec3(0.0);\n\n\t// This is the color of the reflection\n\t// we will return at the end of this function\n\tvec3 reflectionColor = vec3(0.0);\n\n\t// This is the color of the refraction\n\t// we will return at the end of this function\n\tvec3 refractionColor = vec3(0.0);\n\n\t// This is the color of the shadow\n\t// we will return at the end of this function\n\tvec3 shadowColor = vec3(0.0);\n\n\t// This is the color of the sky\n\t// we will return at the end of this function\n\tvec3 skyColor = vec3(0.0);\n\n\t// This is the color of the ground\n\t// we will return at the end of this function\n\tvec3 groundColor = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor2 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor3 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor4 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor5 = vec3(0.0);\n\n\t// This is the color of the water\n\t// we will return at the end of this function\n\tvec3 waterColor6 = vec3(0.0);\n\n", "\n  return pow(x, log(b) / log(0.5));\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat smoothstep(float x) {\n  return bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat smoothstep2(float x) {\n  return bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat smoothstep3(float x) {\n  return bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat smoothstep4(float x) {\n  return bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\nfloat smoothstep5(float x) {\n  return bias(x, 0.5);\n}\n\n// returns a value between 0 and 1\n// if x is near 0.0 then 0.0 is returned\n// if x is near 1.0 then 1.0 is returned\n// if x is near 0.5 then 0.5 is returned\n", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(dot(i,i+vec2(1.0)),dot(i+vec2(1.0),i+vec2(1.0)),u.x),mix(dot(i,i+vec2(1.0)),dot(i+vec2(1.0),i+vec2(1.0)),u.y),f.y);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(mix(dot(i,i+vec3(1.0)),dot(i+vec3(1.0),i+vec3(1.0)),u.x),mix(dot(i,i+vec3(1.0)),dot(i+vec3(1.0),i+vec3(1.0)),u.y),u.z),mix(mix(dot(i,i+vec3(1.0)),dot(i+vec3(1.0),i+vec3(1.0)),u.x),mix(dot(i,i+vec3(1.0)),dot(i+vec3(1.0),i+vec3(1.0)),u.y),u.z),f.z);\n}\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){\n    vec4 i = floor(p);\n    vec4 f = fract(p);\n    vec4 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(mix(mix(dot(i,i+vec4(1.0)),dot(i+vec4(1.0),i+vec4(1.0)),u.x),mix(dot(", "\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec3 p){\n    return fract(sin(dot(p,vec3(12.9898,78.233,51.719)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec4 p){\n    return fract(sin(dot(p,vec4(12.9898,78.233,51.719,17.271)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(float p){\n    return fract(sin(p*12.9898)*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(int p){\n    return fract(sin(p*12.9898)*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(uint p){\n    return fract(sin(p*12.9898)*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(ivec2 p){\n    return fract(sin(dot(p,ivec2(12.9898,78.233)))*43758.5453);\n}\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(ivec3 p){\n    return fract(sin(dot(p,ivec3(12.9898,78.233,", "\n\treturn length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input r --> is box radius\n// pretty simple, just compare point to radius of box\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input r --> is cylinder radius\n// input h --> is cylinder height\n// pretty simple, just compare point to radius of cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n\tvec3 q = vec3(length(p.xz) - r, abs(p.y) - h * 0.5, 0.0);\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for cone\n// input r --> is cone radius\n// input h --> is cone height\n// pretty simple, just compare point to radius of cone\nfloat sdCone(vec3 p, float r, float h)\n{\n\tvec3 q = vec3(length(p.xz) - r, abs(p.y) - h, 0.0);\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input r --> is torus radius\n// input R --> is torus radius\n// pretty simple, just compare point to radius of torus\nfloat sdTorus(vec3 p, float r, float R)\n{\n\tvec2 q = vec2(length(p.xz) - r, abs(p.y) - R);\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}", "\n\tp.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t.x;\n\treturn length(p.xz) - t.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n// \tt.x = sphere radius\n//  \n// think of the sphere as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere circumference/core/radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat sdSphere(vec3 p, float t)\n{\n\tp.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t;\n\treturn length(p.xz) - t;\n}\n\n// ~~~~~~~ signed distance function for box\n// input t --> box specs where:\n// \tt.x = box width\n//\tt.y = box height\n//\tt.z = box depth\n//  \n// think of the box as a cube with 6 planes\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the box circumference/core/radius which is flat on the y axis\n// then simply subtract the box radius from that \nfloat sdBox(vec3 p, vec3 t)\n{\n\tvec3 q = abs(p) - t;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n// \tt.x = cylinder radius\n//\tt.y = cylinder height\n//  \n// think of the cylinder as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder circumference/core/radius which is flat on the y axis\n// then simply subtract the cylinder radius from that \nfloat sdCylinder(", "\n\tfloat d = d1 - d2;\n\treturn d1 - d*d*d*(d*(-2.0f*d - 6.0f) + 3.0f);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n\tfloat d = d1 - d2;\n\treturn d1 - d*d*d*(d*(-2.0f*d - 6.0f*k) + 3.0f*k);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smax/smax.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2)\n{\n\tfloat d = d1 - d2;\n\treturn d1 - d*d*d*(d*(2.0f*d - 6.0f) + 3.0f);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smax/smax.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{\n\tfloat d = d1 - d2;\n\treturn d1 - d*d*d*(d*(2.0f*d - 6.0f*k) + 3.0f*k);\n}\n\n// ~~~~~~~ smooth step function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/", "\n\treturn d1 * d2;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3)\n{\n\treturn d1 * d2 * d3;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4)\n{\n\treturn d1 * d2 * d3 * d4;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5)\n{\n\treturn d1 * d2 * d3 * d4 * d5;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5, float d6)\n{\n\treturn d1 * d2 * d3 * d4 * d5 * d6;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float d3, float d4, float d5, float d6, float d7)\n{\n\treturn d1 * d2 * d3 * d4 * d5 * d6 * d7;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n//", "\n\tvec3 q = p;\n\tq.x += t * cos( yaw );\n\tq.y += t * sin( yaw );\n\treturn q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n\tvec3 q = p;\n\tq.x += t * cos( yaw ) * cos( pitch );\n\tq.y += t * sin( yaw ) * cos( pitch );\n\tq.z += t * sin( pitch );\n\treturn q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch, float roll )\n{\n\tvec3 q = p;\n\tq.x += t * cos( yaw ) * cos( pitch ) * cos( roll );\n\tq.y += t * sin( yaw ) * cos( pitch ) * cos( roll );\n\tq.z += t * sin( pitch ) * cos( roll );\n\treturn q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch, float roll, float scale )\n{\n\tvec3 q = p;\n\tq.x += t * cos( yaw ) * cos( pitch ) * cos( roll ) * scale;\n\tq.y += t * sin( yaw ) * cos( pitch ) * cos( roll ) * scale;\n\tq.z += t * sin( pitch ) * cos", "\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n\tif(o1.x > o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opD(vec2 o1, vec2 o2)\n{\n\tif(o1.x > o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Xor / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opX(vec2 o1, vec2 o2)\n{\n\tif(o1.x < o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opE(vec2 o1, vec2 o2)\n{\n\tif(o1.x > o2.x)\n\t\treturn o1;\n\telse\n\t\treturn o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opN(vec2 o1, vec2 o2)\n{\n\tif(o1.x > o", "\n\t// ~~~~~~~ map out the world\n\t// input p --> is ray position\n\t// basically find the object/point closest to the ray by\n\t// checking all the objects with respect to p\n\t// move objects/shapes by messing with p\n\tvec2 uv = vec2(0.0);\n\tfloat min_dist = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tnear = 0.0;\n\tfloat tfar = 1000000.0;\n\tvec3 p = vec3(0.0);\n\tvec3 n = vec3(0.0);\n\tint id = 0;\n\tint hit = 0;\n\tint i = 0;\n\tint j = 0;\n\tint k = 0;\n\tint l = 0;\n\tint m = 0;\n\tint n = 0;\n\tint o = 0;\n\tint p = 0;\n\tint q = 0;\n\tint r = 0;\n\tint s = 0;\n\tint t = 0;\n\tint u = 0;\n\tint v = 0;\n\tint w = 0;\n\tint x = 0;\n\tint y = 0;\n\tint z = 0;\n\tint a = 0;\n\tint b = 0;\n\tint c = 0;\n\tint d = 0;\n\tint e = 0;\n\tint f = 0;\n\tint g = 0;\n\tint h = 0;\n\tint ii = 0;\n\tint jj = 0;\n\tint kk = 0;\n\tint ll = 0;\n\tint mm = 0;\n\tint nn = 0;\n\tint oo = 0;\n\tint pp = 0;\n\tint qq = 0;\n\tint rr = 0;\n\tint ss = 0;\n\tint tt = 0;\n\tint uu = 0;\n\tint vv = 0;\n\tint ww = 0;\n\tint xx = 0;\n\tint yy = 0;\n\tint zz = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint cc = 0;\n\tint dd = 0;\n\tint ee =", "\n\t// find closest surface\n\tfloat t = 1e9;\n\tint id = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfloat tt = s[i].intersect(ro, rd);\n\t\tif (tt > 0 && tt < t)\n\t\t{\n\t\t\tt = tt;\n\t\t\tid = i;\n\t\t}\n\t}\n\n\t// if no surface is hit, return background color\n\tif (id == -1)\n\t\treturn vec3(0.0, 0.0, 0.0);\n\n\t// if surface is hit, return its color\n\treturn s[id].color;\n}\n\n// ~~~~~~~ main\nint main()\n{\n\t// ~~~~~~~ read input\n\tifstream fin(\"input.txt\");\n\tfin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint type;\n\t\tfin >> type;\n\t\tif (type == 0)\n\t\t{\n\t\t\tfloat x, y, z, r, g, b;\n\t\t\tfin >> x >> y >> z >> r >> g >> b;\n\t\t\ts.push_back(Sphere(vec3(x, y, z), r, vec3(r, g, b)));\n\t\t}\n\t\telse if (type == 1)\n\t\t{\n\t\t\tfloat x1, y1, z1, x2, y2, z2, x3, y3, z3, r, g, b;\n\t\t\tfin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2 >> x3 >> y3 >> z3 >> r >> g >> b;\n\t\t\ts.push_back(Triangle(vec3(x1, y1, z1), vec3(x2, y2, z2), vec3(x3, y3, z3), vec3(r, g, b)));\n\t\t}\n\t}\n\tfin.close();\n\n\t// ~~~~~~~ render\n\tint w = 1000, h = 1000;\n\tofstream fout(\"output.ppm\");\n\tfout << \"P3\\n\" << w << \" \" << h << \"\\n255\\n", "\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera matrix\n\t// ~~~~~~~ create camera", "\n\tif (id == 0) return vec3(1.0, 0.0, 0.0);\n\tif (id == 1) return vec3(0.0, 1.0, 0.0);\n\tif (id == 2) return vec3(0.0, 0.0, 1.0);\n\tif (id == 3) return vec3(1.0, 1.0, 0.0);\n\tif (id == 4) return vec3(1.0, 0.0, 1.0);\n\tif (id == 5) return vec3(0.0, 1.0, 1.0);\n\tif (id == 6) return vec3(1.0, 1.0, 1.0);\n\tif (id == 7) return vec3(0.0, 0.0, 0.0);\n\tif (id == 8) return vec3(0.5, 0.5, 0.5);\n\tif (id == 9) return vec3(0.5, 0.0, 0.0);\n\tif (id == 10) return vec3(0.0, 0.5, 0.0);\n\tif (id == 11) return vec3(0.0, 0.0, 0.5);\n\tif (id == 12) return vec3(0.5, 0.5, 0.0);\n\tif (id == 13) return vec3(0.5, 0.0, 0.5);\n\tif (id == 14) return vec3(0.0, 0.5, 0.5);\n\tif (id == 15) return vec3(0.5, 0.5, 0.5);\n\tif (id == 16) return vec3(0.0, 0.0, 0.0);\n\tif (id == 17) return vec3(0.5, 0.5, 0.5);\n\tif (id == 18) return vec3(0.5,", "\n    p.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t.x;\n    float d = length(p.xz) - t.x;\n    return min(d, abs(p.y) - t.y);\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input t --> sphere specs where:\n//  t.x = sphere radius\n//  \n// think of the sphere as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the sphere radius which is flat on the y axis\n// then simply subtract the sphere radius from that \nfloat sdSphere(vec3 p, float t)\n{\n    p.xz = p.xz - normalize(p.xz) * dot(p.xz, normalize(p.xz)) * t;\n    return length(p.xz) - t;\n}\n\n// ~~~~~~~ signed distance function for box\n// input t --> box specs where:\n//  t.x = box width\n//  t.y = box height\n//  t.z = box depth\n//  \n// think of the box as a cube with 6 planes\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the box width/core/radius which is flat on the y axis\n// then simply subtract the box height from that \nfloat sdBox(vec3 p, vec3 t)\n{\n    vec3 q = abs(p) - t;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input t --> cylinder specs where:\n//  t.x = cylinder radius\n//  t.y = cylinder height\n//  \n// think of the cylinder as a circle wrapped around a 3d circle\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the cylinder radius which is flat on the y axis\n// then simply subtract the cylinder height from that \nfloat sdCylinder(vec", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\nfloat sdSphere(vec3 p)\n{\n    return length(p) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\nfloat sdBox(vec3 p)\n{\n    vec3 q = abs(p) - ps;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> tube radius\nfloat sdTorus(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, p.y);\n    return length(q) - ps.y;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\nfloat sdCylinder(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, abs(p.y) - ps.y * 0.5);\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// ~~~~~~~ signed distance function for cone\n//  input ps --> specs of cone\n//        ps.x --> radius\n//        ps.y --> height\nfloat sdCone(vec3 p)\n{\n    vec2 q = vec2(length(p.xz) - ps.x, abs(p.y) - ps.y);\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\n// ~~~~~~~ signed distance function for ellipsoid\n//  input ps --> specs of ellipsoid", "\n\tfloat h = clamp( 0.5f + 0.5f * (d2 - d1) / k, 0.0f, 1.0f);\n\treturn mix( d2, d1, h) - k * h * (1.0f - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float k2)\n{\n\tfloat h = clamp( 0.5f + 0.5f * (d2 - d1) / k, 0.0f, 1.0f);\n\treturn mix( d2, d1, h) - k * h * (1.0f - h) - k2 * h * h * (1.0f - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float k2, float k3)\n{\n\tfloat h = clamp( 0.5f + 0.5f * (d2 - d1) / k, 0.0f, 1.0f);\n\treturn mix( d2, d1, h) - k * h * (1.0f - h) - k2 * h * h * (1.0f - h) - k3 * h * h * h * (1.0f - h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.", "\n\tvec4 o = vec4(0.0);\n\to.xyz = mix(o1.xyz, o2.xyz, bf);\n\to.w = mix(o1.w, o2.w, bf);\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, vec4 bf)\n{\n\tvec4 o = vec4(0.0);\n\to.xyz = mix(o1.xyz, o2.xyz, bf.xyz);\n\to.w = mix(o1.w, o2.w, bf.w);\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf, float bf2)\n{\n\tvec4 o = vec4(0.0);\n\to.xyz = mix(o1.xyz, o2.xyz, bf);\n\to.w = mix(o1.w, o2.w, bf2);\n\treturn o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, vec4 bf, float bf2)\n", "\n  return d1-d2;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2)\n{\n  return d1-d2;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2,float d3)\n{\n  return d1-d2-d3;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2,float d3,float d4)\n{\n  return d1-d2-d3-d4;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2,float d3,float d4,float d5)\n{\n  return d1-d2-d3-d4-d5;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2,float d3,float d4,float d5,float d6)\n", "\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec3 generateSpotLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of directional light\n// output --> wolrd pos of directional light\nvec3 generateDirLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec3 generateSpotLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec3 generateSpotLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec3 generateSpotLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.x = 0.0;\n\tlightPos.y = 0.0;\n\tlightPos.z = 0.0;\n\treturn lightPos;\n}\n\n// ~~~~~~~~ generates world position of spot light\n// output --> wolrd pos of spot light\nvec3 generateSpotLightPos()\n{\n\tvec3 lightPos;\n\tlightPos.", "\n\t// ~~~~~~~ find the closest object\n\t// ~~~~~~~ and return the color of that object\n\t// ~~~~~~~ and the distance to that object\n\t// ~~~~~~~ and the blended color of that object\n\t// ~~~~~~~ and the normal of that object\n\t// ~~~~~~~ and the texture of that object\n\t// ~~~~~~~ and the material of that object\n\t// ~~~~~~~ and the lighting of that object\n\t// ~~~~~~~ and the reflection of that object\n\t// ~~~~~~~ and the refraction of that object\n\t// ~~~~~~~ and the fresnel of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that object\n\t// ~~~~~~~ and the fresnel power of that object\n\t// ~~~~~~~ and the fresnel bias of that object\n\t// ~~~~~~~ and the fresnel scale of that object\n\t// ~~~~~~~ and the fresnel exponent of that object\n\t// ~~~~~~~ and the fresnel clamp of that", "\n\t// ~~~~~~~ cast/march ray through the word and see what it hits\n\t// input ro --> ray origin point/position\n\t// input rd --> ray direction\n\t// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n\t// output is vec3 where\n\t// .x = distance travelled by ray\n\t// .y = hit object's ID\n\t// .z = itteration ratio\n\tvec4 hit = vec4(0.0,0.0,0.0,0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000000.0;\n\tfloat tnear = 0.0;\n\tfloat tfar = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 =", "\n    float shadow = 1.0;\n    float bias = 0.0001;\n    float step = 0.001;\n    float maxDist = 100.0;\n    float dist = 0.0;\n    vec3 dir = normalize(lp - sp);\n    for (float i = 0.0; i < maxDist; i += step)\n    {\n        dist += step;\n        vec3 p = sp + dir * dist;\n        if (any(greaterThan(p, vec3(0.0))))\n        {\n            if (any(greaterThan(p, vec3(1.0))))\n            {\n                break;\n            }\n            if (texture(tex, p).a < 0.5)\n            {\n                break;\n            }\n        }\n        shadow = 0.5 + 0.5 * cos(dist);\n    }\n    return shadow;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    float shadow = 1.0;\n    float bias = 0.0001;\n    float step = 0.001;\n    float maxDist = 100.0;\n    float dist = 0.0;\n    vec3 dir = normalize(lp - sp);\n    for (float i = 0.0; i < maxDist; i += step)\n    {\n        dist += step;\n        vec3 p = sp + dir * dist;\n        if (any(greaterThan(p, vec3(0.0))))\n        {\n            if (any(greaterThan(p, vec3(1.0))))\n            {\n                break;\n            }\n            if (texture(tex, p).a < 0.5)\n            {\n                break;\n            }\n        }\n        shadow = 0.5 + 0.5 * cos(dist);\n    }\n    return shadow;\n}\n\n// ~~~~~~~ softShadow,", "\n\tfloat t = 0.0;\n\tfloat step = 0.01;\n\tfloat maxDist = 100.0;\n\tfloat dist = 0.0;\n\tvec3 dir = nor;\n\tvec3 pos = sp;\n\twhile (dist < maxDist)\n\t{\n\t\tdist += step;\n\t\tpos += dir * step;\n\t\tt += step;\n\t\tif (dist > maxDist)\n\t\t\tbreak;\n\t\tif (getDistance(pos) < 0.001)\n\t\t\tbreak;\n\t}\n\treturn t;\n}\n\n// ~~~~~~~ getDistance\n// returns distance from surface\nfloat getDistance(vec3 pos)\n{\n\treturn distanceField(pos);\n}\n\n// ~~~~~~~ distanceField\n// returns distance from surface\nfloat distanceField(vec3 pos)\n{\n\tfloat d = 0.0;\n\td += noise(pos * 0.01);\n\td += noise(pos * 0.05) * 0.5;\n\td += noise(pos * 0.1) * 0.25;\n\td += noise(pos * 0.2) * 0.125;\n\td += noise(pos * 0.4) * 0.0625;\n\td += noise(pos * 0.8) * 0.03125;\n\td += noise(pos * 1.6) * 0.015625;\n\td += noise(pos * 3.2) * 0.0078125;\n\td += noise(pos * 6.4) * 0.00390625;\n\td += noise(pos * 12.8) * 0.001953125;\n\td += noise(pos * 25.6) * 0.0009765625;\n\td += noise(pos * 51.2) * 0.00048828125;\n\td += noise(pos * 102.4) * 0.00024", "\n\tvec3 n = oN;\n\tvec3 n1 = oN;\n\tvec3 n2 = oN;\n\tvec3 n3 = oN;\n\tvec3 n4 = oN;\n\tvec3 n5 = oN;\n\tvec3 n6 = oN;\n\tvec3 n7 = oN;\n\tvec3 n8 = oN;\n\tvec3 n9 = oN;\n\tvec3 n10 = oN;\n\tvec3 n11 = oN;\n\tvec3 n12 = oN;\n\tvec3 n13 = oN;\n\tvec3 n14 = oN;\n\tvec3 n15 = oN;\n\tvec3 n16 = oN;\n\tvec3 n17 = oN;\n\tvec3 n18 = oN;\n\tvec3 n19 = oN;\n\tvec3 n20 = oN;\n\tvec3 n21 = oN;\n\tvec3 n22 = oN;\n\tvec3 n23 = oN;\n\tvec3 n24 = oN;\n\tvec3 n25 = oN;\n\tvec3 n26 = oN;\n\tvec3 n27 = oN;\n\tvec3 n28 = oN;\n\tvec3 n29 = oN;\n\tvec3 n30 = oN;\n\tvec3 n31 = oN;\n\tvec3 n32 = oN;\n\tvec3 n33 = oN;\n\tvec3 n34 = oN;\n\tvec3 n35 = oN;\n\tvec3 n36 = oN;\n\tvec3 n37 = oN;\n\tvec3 n38 = oN;\n\tvec3 n39 = oN;\n\tvec3 n40 = oN;\n\tvec3 n41 = oN;\n\tvec3 n42 = oN;\n\tvec3 n43 = oN;\n\tvec3 n44 = oN;\n\tvec3 n45 = oN;\n\tvec3 n46 = oN;\n\tvec3 n4", "\n\treturn vec3(\n\t\tpow(c.r, 1.0 / 2.2),\n\t\tpow(c.g, 1.0 / 2.2),\n\t\tpow(c.b, 1.0 / 2.2)\n\t);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec4 c)\n{\n\treturn vec3(\n\t\tpow(c.r, 1.0 / 2.2),\n\t\tpow(c.g, 1.0 / 2.2),\n\t\tpow(c.b, 1.0 / 2.2)\n\t);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec4 c)\n{\n\treturn vec4(\n\t\tpow(c.r, 1.0 / 2.2),\n\t\tpow(c.g, 1.0 / 2.2),\n\t\tpow(c.b, 1.0 / 2.2),\n\t\tc.a\n\t);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c, float gamma)\n{\n\treturn vec3(\n\t\tpow(c.r, 1.0 / gamma),\n\t\tpow(c.g, 1.0 / gamma),\n\t\tpow(c.b, 1.0 / gamma)\n\t);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor", "\n\tfloat f = 1.0 - exp(-fs.x*d);\n\treturn mix(fc1,fc2,f);\n}\n\n// ~~~~~~~ do lighting\n// from iq's pageon lighting:\n// http://www.iquilezles.org/www/articles/lighting/lighting.htm\n// input c --> original color\n// input n --> normal\n// input l --> light direction\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// output --> color with lighting applied\nvec3 applyLighting(vec3 c,vec3 n,vec3 l,vec3 cRD,vec3 lRD,vec3 fc1,vec3 fc2,vec2 fs)\n{\n\tfloat nl = dot(n,l);\n\tvec3 c1 = mix(fc1,fc2,nl);\n\tvec3 c2 = mix(fc1,fc2,nl*nl);\n\tvec3 c3 = mix(fc1,fc2,nl*nl*nl);\n\tvec3 c4 = mix(fc1,fc2,nl*nl*nl*nl);\n\tvec3 c5 = mix(fc1,fc2,nl*nl*nl*nl*nl);\n\tvec3 c6 = mix(fc1,fc2,nl*nl*nl*nl*nl*nl);\n\tvec3 c7 = mix(fc1,fc2,nl*nl*nl*nl*nl*nl*nl);\n\tvec3 c8 = mix(fc1,fc2,nl*nl*nl*nl*nl*nl*nl*nl);\n\tvec3 c9 = mix(fc1,fc2,nl*nl*nl*nl*nl*nl*nl*nl*nl);\n\tvec3 c10 = mix(fc1,fc2,nl*nl*nl*nl*nl*nl*nl*nl*nl*nl);\n\tvec3 c11 = mix(fc1,fc", "\n\treturn 1.0f / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist)\n{\n\tfloat attn = 1.0f / (cF + lF * d + qF * d * d);\n\tif (attn > 1.0f)\n\t\tattn = 1.0f;\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float maxDist, float minDist)\n{\n\tfloat attn = 1.0f / (cF + lF * d + qF * d * d);\n\tif (attn > 1.0f)\n\t\tattn = 1.0f;\n\tif (attn < minDist)\n\t\tattn = minDist;\n\treturn attn;\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float", "\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayDir = normalize(vec3(cMatrix * vec4(ndc, 1.0, 1.0)));\n\treturn rayDir;\n}\n\n// ~~~~~~~ calculate ray origin\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayOrigin = vec3(cMatrix * vec4(ndc, 1.0, 1.0));\n\treturn rayOrigin;\n}\n\n// ~~~~~~~ calculate ray origin\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat4 cMatrix)\n{\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayOrigin = vec3(cMatrix * vec4(ndc, 0.0, 1.0));\n\treturn rayOrigin;\n}\n\n// ~~~~~~~ calculate ray origin\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat4 cMatrix, vec3 camPos)\n{\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayOrigin = vec3(cMatrix * vec4(ndc, 0.0, 1.0)) + camPos;\n\treturn rayOrigin;\n}\n\n// ~~~~~~~ calculate ray origin\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat4 cMatrix, vec3 camPos, vec3 camDir)\n{\n\tvec2 ndc = fCoord * 2.0 - 1.0;\n\tvec3 rayOrigin = vec3(cMatrix * vec4(ndc, 0.0, 1.0)) + camPos + camDir;\n\treturn", "\n    vec3 color = vec3(0.0);\n    vec3 fPos = vec3(fCoord,0.0);\n    vec3 fDir = normalize(fPos-cPos);\n    vec3 fNorm = normalize(vec3(cMat*vec3(fDir.xy,0.0)));\n    vec3 fCol = vec3(0.0);\n    float fDist = 0.0;\n    float fMarch = 0.0;\n    float fItter = 0.0;\n    float fMaxItter = 100.0;\n    float fMaxMarch = 100.0;\n    float fMaxDist = 100.0;\n    float fMinDist = 0.001;\n    float fStep = 0.001;\n    float fStepItter = 0.001;\n    float fStepMarch = 0.001;\n    float fStepDist = 0.001;\n    float fStepAA = 0.001;\n    float fAA = 0.0;\n    float fAAItter = 0.0;\n    float fAAMarch = 0.0;\n    float fAADist = 0.0;\n    float fAAStep = 0.0;\n    float fAAStepItter = 0.0;\n    float fAAStepMarch = 0.0;\n    float fAAStepDist = 0.0;\n    float fAAStepAA = 0.0;\n    float fAAStepAAItter = 0.0;\n    float fAAStepAAMarch = 0.0;\n    float fAAStepAADist = 0.0;\n    float fAAStepAAStep = 0.0;\n    float fAAStepAAStepItter = 0.0;\n    float fAAStepAAStepMarch = 0.0;\n    float fAAStepAAStepDist = 0.0;\n    float fAAStepAAStepAA = 0.0;\n    float fAAStepAAStepAAItter = 0.0;\n    float fAAStepAAStepAAMarch = 0.0;\n    float fAAStepAAStepAADist = 0.0;\n    float fAAStepAAStepAAStep = 0.0;\n    float fAAStepAAStep", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 z = vec2( 0.0 );\n\tvec2 c = vec2( uv.x * 2.0, uv.y * 2.0 );\n\tfloat i = 0.0;\n\n\tfor( i = 0.0; i < 100.0; i++ )\n\t{\n\t\tz = vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n\t\tif( length( z ) > 10.0 )\n\t\t\tbreak;\n\t}\n\n\tfloat t = i / 100.0;\n\tt = 1.0 - t;\n\tt = t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n\tfragColor = vec4( vec3( t ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 z = vec2( 0.0 );\n\tvec2 c = vec2( uv.x * 2.0, uv.y * 2.0 );\n\tfloat i = 0.0;\n\n\tfor( i = 0.0; i < 100.0; i++ )\n\t{\n\t\tz = vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + c;\n\t\tif( length( z ) > 10.0 )\n\t\t\tbreak;\n\t}\n\n\tfloat t = i / 100.0;\n\tt = 1.0 - t;\n\tt = t * t * t * ( t * ( t *", "\n\tvec3 d = abs(p) - radius;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, float R, float r)\n{\n\tvec2 q = vec2(length(p.xz) - R, p.y);\n\treturn length(q) - r;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, float h, float r)\n{\n\tvec2 q = vec2(length(p.xz) - r, abs(p.y) - h * 0.5);\n\treturn min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// cone distance field\nfloat sdCone(vec3 p, float h, float r)\n{\n\tfloat a = r / h;\n\tfloat b = sqrt(max(0.0, 1.0 - a * a));\n\tvec2 q = vec2(length(p.xz) - r, abs(p.y) - h * 0.5);\n\treturn min(max(q.x, q.y * b), 0.0) + length(max(q, 0.0));\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n)\n{\n\treturn dot(p, n);\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n, float d)\n{\n\treturn dot(p, n) - d;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n, vec3 d)\n{\n\treturn dot(p, n) - dot(d, n);\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 n, vec3 d, float scale)\n{\n\treturn dot(p, n) - dot(", "\n\treturn length(p) - r;\n}\n\n// simple sphere distance field\nfloat sphere(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// simple torus distance field\nfloat torus(vec2 p, float r, float R)\n{\n\treturn length(p) - r - R;\n}\n\n// simple ellipse distance field\nfloat ellipse(vec2 p, float a, float b)\n{\n\treturn length(p) - sqrt(a*a*b*b) / length(p);\n}\n\n// simple heart distance field\nfloat heart(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y));\n}\n\n// simple heart distance field\nfloat heart2(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\nfloat heart3(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\nfloat heart4(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\nfloat heart5(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\nfloat heart6(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\nfloat heart7(vec2 p)\n{\n\treturn length(p) - sqrt(abs(p.x*p.x - p.y*p.y)) - 0.5;\n}\n\n// simple heart distance field\n", "\n\t// The distance to the nearest surface\n\tfloat d = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tvec2 temp = c;\n\tc.x = c.x * c.x * c.x * c.x * c.x;\n\tc.y = c.y * c.y * c.y * c.y * c.y;\n\tc.x = c.x - c.y;\n\tc.y = 2.0 * temp.x * c.y + temp.y * temp.y * temp.y * temp.y * temp.y;\n\treturn c;\n}\n\n//Function that returns a complex number to power of 6\nvec2 complexPower6(vec2 c)\n{\n\tvec2 temp = c;\n\tc.x = c.x * c.x * c.x * c.x * c.x * c.x;\n\tc.y = c.y * c.y * c.y * c.y * c.y * c.y;\n\tc.x = c.x - c.y;\n\tc.y = 2.0 * temp.x * c.y + temp.y * temp.y * temp.y * temp.y * temp.y * temp.y;\n\treturn c;\n}\n\n//Function that returns a complex number to power of 7\nvec2 complexPower7(vec2 c)\n{\n\tvec2 temp = c;\n\tc.x = c.x * c.x * c.x * c.x * c.x * c.x * c.x;\n\tc.y = c.y * c.y * c.y * c.y * c.y * c.y * c.y;\n\tc.x = c.x - c.y;\n\tc.y = 2.0 * temp.x * c.y + temp.y * temp.y * temp.y * temp.y * temp.y * temp.y * temp.y;\n\treturn c;\n}\n\n//Function that returns a complex number to power of 8\nvec2 complexPower8(vec2 c)\n{\n\tvec2 temp = c;\n\tc.x = c.x * c.x * c.x * c.x * c.x * c", "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 tempCoord = coord;\n\tfor(int i = 0; i < 10; i++)\n\t{\n\t\ttempCoord = biomorph(tempCoord, morphConstant);\n\t}\n\tcolor = vec4(tempCoord, 0.0, 0.0);\n\treturn color;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant, int iterations)\n{\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 tempCoord = coord;\n\tfor(int i = 0; i < iterations; i++)\n\t{\n\t\ttempCoord = biomorph(tempCoord, morphConstant);\n\t}\n\tcolor = vec4(tempCoord, 0.0, 0.0);\n\treturn color;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant, int iterations, float scale)\n{\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 tempCoord = coord;\n\tfor(int i = 0; i < iterations; i++)\n\t{\n\t\ttempCoord = biomorph(tempCoord, morphConstant);\n\t}\n\tcolor = vec4(tempCoord, 0.0, 0.0);\n\treturn color;\n}\n\n//Returns the color of a biomorph at position coord\nvec4 colorBiomorph(vec2 coord, vec2 morphConstant, int iterations, float scale, float offset)\n{\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 tempCoord = coord;\n\tfor(int i = 0; i < iterations; i++)\n\t{\n\t\ttempCoord = biomorph(tempCoord, morphConstant);\n\t}\n\tcolor = vec4(tempCoord, 0.0, ", "\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcolor += texture(iTexture, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph2(vec2 uv, vec2 constant)\n{\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcolor += texture(iTexture, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph3(vec2 uv, vec2 constant)\n{\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcolor += texture(iTexture, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn color / 16.0;\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph4(vec2 uv, vec2 constant)\n{\n\tvec4 color = vec4(0.0);\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tfor(int j = 0; j < 4; j++)\n\t\t{\n\t\t\tcolor += texture(iTexture, uv + vec2(i, j) * constant);\n\t\t}\n\t}\n\treturn color / ", "\n\treturn x - floor(x);\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period) {\n\treturn x - floor(x / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset) {\n\treturn x - floor((x + offset) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center, float bias) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center, float bias, float slope) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center, float bias, float slope, float offset2) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center, float bias, float slope, float offset2, float phase2) {\n\treturn x - floor((x + offset + phase) / period) * period;\n}\n\n// Basically a triangle wave\nfloat repeat(float x, float period, float offset, float phase, float amplitude, float center, float bias, float slope, float", "\n\t// This is the distance from the line to the point\n\tfloat dist = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist2 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist3 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist4 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist5 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist6 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist7 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist8 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist9 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist10 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist11 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist12 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist13 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist14 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist15 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist16 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist17 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist18 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist19 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist20 = 0.0;\n\t// This is the distance from the point to the line\n\tfloat dist21 = 0", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\tvec2 n = normalize(d);\n\tvec2 t = vec2(n.y, -n.x);\n\tvec2 p = pA + t * thick.x * 0.5;\n\tfloat tlen = length(pB - pA);\n\tfloat tlen2 = tlen - thick.x;\n\tfloat tlen3 = tlen + thick.x;\n\tfloat tlen4 = tlen2 + thick.x;\n\tfloat tlen5 = tlen3 + thick.x;\n\tfloat tlen6 = tlen4 + thick.x;\n\tfloat tlen7 = tlen5 + thick.x;\n\tfloat tlen8 = tlen6 + thick.x;\n\tfloat tlen9 = tlen7 + thick.x;\n\tfloat tlen10 = tlen8 + thick.x;\n\tfloat tlen11 = tlen9 + thick.x;\n\tfloat tlen12 = tlen10 + thick.x;\n\tfloat tlen13 = tlen11 + thick.x;\n\tfloat tlen14 = tlen12 + thick.x;\n\tfloat tlen15 = tlen13 + thick.x;\n\tfloat tlen16 = tlen14 + thick.x;\n\tfloat tlen17 = tlen15 + thick.x;\n\tfloat tlen18 = tlen16 + thick.x;\n\tfloat tlen19 = tlen17 + thick.x;\n\tfloat tlen20 = tlen18 + thick.x;\n\tfloat tlen21 = tlen19 + thick.x;\n\tfloat tlen22 = tlen20 + thick.x;\n\tfloat tlen23 = tlen21 + thick.x;\n\tfloat tlen24 = tlen22 + thick.x;\n\tfloat tlen25 = tlen23 + thick.x;\n\tfloat tlen26 = tlen24 + thick.", "\n\tfloat dist = distance(pA, pB);\n\tfloat outline = outlineThick * dist;\n\tfloat outlineDist = outline / 2.0;\n\tfloat outlineDistRounded = outlineDist * rounded;\n\tfloat outlineDistRounded2 = outlineDistRounded * rounded;\n\tfloat outlineDistRounded3 = outlineDistRounded2 * rounded;\n\tfloat outlineDistRounded4 = outlineDistRounded3 * rounded;\n\tfloat outlineDistRounded5 = outlineDistRounded4 * rounded;\n\tfloat outlineDistRounded6 = outlineDistRounded5 * rounded;\n\tfloat outlineDistRounded7 = outlineDistRounded6 * rounded;\n\tfloat outlineDistRounded8 = outlineDistRounded7 * rounded;\n\tfloat outlineDistRounded9 = outlineDistRounded8 * rounded;\n\tfloat outlineDistRounded10 = outlineDistRounded9 * rounded;\n\tfloat outlineDistRounded11 = outlineDistRounded10 * rounded;\n\tfloat outlineDistRounded12 = outlineDistRounded11 * rounded;\n\tfloat outlineDistRounded13 = outlineDistRounded12 * rounded;\n\tfloat outlineDistRounded14 = outlineDistRounded13 * rounded;\n\tfloat outlineDistRounded15 = outlineDistRounded14 * rounded;\n\tfloat outlineDistRounded16 = outlineDistRounded15 * rounded;\n\tfloat outlineDistRounded17 = outlineDistRounded16 * rounded;\n\tfloat outlineDistRounded18 = outlineDistRounded17 * rounded;\n\tfloat outlineDistRounded19 = outlineDistRounded18 * rounded;\n\tfloat outlineDistRounded20 = outlineDistRounded19 * rounded;\n\tfloat outlineDistRounded21 = outlineDistRounded20 * rounded;\n\tfloat outlineDistRounded22 = outlineDistRounded21 * rounded;\n\tfloat outlineDistRounded23 = outlineDistRounded22 * rounded;\n\tfloat outlineDistRounded24 = outlineDistRounded23 * rounded;\n\tfloat outlineDistRounded25 = outlineDistRounded24 * rounded;\n\tfloat outlineDistRounded26 = outlineDistRounded25 * rounded;\n\tfloat outlineDistRounded27 = outlineDistRounded26 * rounded;\n\tfloat outlineDistRounded28 = outlineDistRounded27 * rounded;\n\tfloat outlineDistRounded29 = outlineDistRounded28 * rounded;\n\tfloat outlineDist", "\n\tvec2 d = pB - pA;\n\tfloat len = length(d);\n\td /= len;\n\tvec2 n = vec2(-d.y, d.x);\n\tvec2 p = pA + d * 0.5;\n\tvec2 t = p + n * thick.x * 0.5;\n\tvec2 b = p - n * thick.x * 0.5;\n\tfloat tlen = length(t - b);\n\tfloat tlen2 = tlen * tlen;\n\tfloat tlen4 = tlen2 * tlen2;\n\tfloat tlen6 = tlen4 * tlen2;\n\tfloat tlen8 = tlen4 * tlen4;\n\tfloat tlen10 = tlen8 * tlen2;\n\tfloat tlen12 = tlen8 * tlen4;\n\tfloat tlen14 = tlen12 * tlen2;\n\tfloat tlen16 = tlen12 * tlen4;\n\tfloat tlen18 = tlen16 * tlen2;\n\tfloat tlen20 = tlen16 * tlen4;\n\tfloat tlen22 = tlen20 * tlen2;\n\tfloat tlen24 = tlen20 * tlen4;\n\tfloat tlen26 = tlen24 * tlen2;\n\tfloat tlen28 = tlen24 * tlen4;\n\tfloat tlen30 = tlen28 * tlen2;\n\tfloat tlen32 = tlen28 * tlen4;\n\tfloat tlen34 = tlen32 * tlen2;\n\tfloat tlen36 = tlen32 * tlen4;\n\tfloat tlen38 = tlen36 * tlen2;\n\tfloat tlen40 = tlen36 * tlen4;\n\tfloat tlen42 = tlen40 * tlen2;\n\tfloat tlen44 = tlen40 * tlen4;\n\tfloat tlen46 = tlen44 * tlen2;\n\tfloat tlen48 = tlen44 * tlen4;\n\tfloat t", "\n\tfloat dist = length(pB - pA);\n\tfloat dash = thick.x;\n\tfloat gap = thick.y;\n\tfloat dashCount = floor(dist / dash);\n\tfloat gapCount = dashCount;\n\tfloat dashOffset = mod(uv.x * dist, dash);\n\tfloat gapOffset = mod(uv.x * dist, gap);\n\tfloat dashPhase = step(dashOffset, dash) - step(dashOffset - dash, dash);\n\tfloat gapPhase = step(gapOffset, gap) - step(gapOffset - gap, gap);\n\tfloat dashPhaseRounded = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded;\n\tfloat gapPhaseRounded = step(gapOffset, gap) - step(gapOffset - gap, gap) * rounded;\n\tfloat dashPhaseRounded2 = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded * rounded;\n\tfloat gapPhaseRounded2 = step(gapOffset, gap) - step(gapOffset - gap, gap) * rounded * rounded;\n\tfloat dashPhaseRounded3 = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded * rounded * rounded;\n\tfloat gapPhaseRounded3 = step(gapOffset, gap) - step(gapOffset - gap, gap) * rounded * rounded * rounded;\n\tfloat dashPhaseRounded4 = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded * rounded * rounded * rounded;\n\tfloat gapPhaseRounded4 = step(gapOffset, gap) - step(gapOffset - gap, gap) * rounded * rounded * rounded * rounded;\n\tfloat dashPhaseRounded5 = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded * rounded * rounded * rounded * rounded;\n\tfloat gapPhaseRounded5 = step(gapOffset, gap) - step(gapOffset - gap, gap) * rounded * rounded * rounded * rounded * rounded;\n\tfloat dashPhaseRounded6 = step(dashOffset, dash) - step(dashOffset - dash, dash) * rounded * rounded * rounded * rounded * rounded * rounded;\n\tfloat gapPhaseRounded6 = step(gapOffset, gap) - step(gapOffset - gap, gap", "\n\tfloat dist = distance(pA, pB);\n\tfloat outline = outlineThick * dist;\n\tfloat outlineUV = outline / thick.x;\n\tfloat outlineUV2 = outlineUV * 2.0;\n\tfloat outlineUV3 = outlineUV * 3.0;\n\tfloat outlineUV4 = outlineUV * 4.0;\n\tfloat outlineUV5 = outlineUV * 5.0;\n\tfloat outlineUV6 = outlineUV * 6.0;\n\tfloat outlineUV7 = outlineUV * 7.0;\n\tfloat outlineUV8 = outlineUV * 8.0;\n\tfloat outlineUV9 = outlineUV * 9.0;\n\tfloat outlineUV10 = outlineUV * 10.0;\n\tfloat outlineUV11 = outlineUV * 11.0;\n\tfloat outlineUV12 = outlineUV * 12.0;\n\tfloat outlineUV13 = outlineUV * 13.0;\n\tfloat outlineUV14 = outlineUV * 14.0;\n\tfloat outlineUV15 = outlineUV * 15.0;\n\tfloat outlineUV16 = outlineUV * 16.0;\n\tfloat outlineUV17 = outlineUV * 17.0;\n\tfloat outlineUV18 = outlineUV * 18.0;\n\tfloat outlineUV19 = outlineUV * 19.0;\n\tfloat outlineUV20 = outlineUV * 20.0;\n\tfloat outlineUV21 = outlineUV * 21.0;\n\tfloat outlineUV22 = outlineUV * 22.0;\n\tfloat outlineUV23 = outlineUV * 23.0;\n\tfloat outlineUV24 = outlineUV * 24.0;\n\tfloat outlineUV25 = outlineUV * 25.0;\n\tfloat outlineUV26 = outlineUV * 26.0;\n\tfloat outlineUV27 = outlineUV * 27.0;\n\tfloat outlineUV28 = outlineUV * 28.0;\n\tfloat outlineUV29 = outlineUV * 29.0;\n\tfloat outlineUV30 = outlineUV * 30.", "\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}\n\n// This is the main fragment shader.\nvoid main() {\n\t// Get the UV coordinates of the fragment.\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\t// Get the color of the fragment.\n\tvec3 col = vec3(0.0);\n\n\t// Draw the point.\n\tDrawPoint(uv, uv, col);\n\n\t// Output the color.\n\tgl_FragColor = vec4(col, 1.0);\n}\n```\n\n## 3.2.2. \u7ed8\u5236\u4e00\u4e2a\u70b9\n\n\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 `DrawPoint` \u51fd\u6570\u6765\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n```glsl\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}\n```\n\n\u8fd9\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u662f\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u5b83\u63a5\u6536\u4e09\u4e2a\u53c2\u6570\uff1a\n\n- `uv`\uff1a\u7247\u6bb5\u7684 UV \u5750\u6807\u3002\n- `p`\uff1a\u7247\u6bb5\u7684\u4f4d\u7f6e\u3002\n- `col`\uff1a\u7247\u6bb5\u7684\u989c\u8272\u3002\n\n\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u5b83\u5c06 `col` \u8bbe\u7f6e\u4e3a\u7ea2\u8272\uff0c\u7136\u540e\u5c06 `gl_Position` \u8bbe\u7f6e\u4e3a `p`\u3002\n\n## 3.2.3. \u7ed8\u5236\u4e00\u4e2a\u70b9\u7684\u7247\u6bb5\u7740\u8272\u5668\n\n\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 `DrawPoint` \u51fd\u6570\u6765\u7ed8\u5236\u4e00\u4e2a\u70b9\u3002\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n```glsl\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n\tcol = vec3(1.0, 0.0, 0.0);\n\tgl_Position = vec4(p, 0.0, 1.0);\n}", "\n    vec3 oc = ro - cen;\n    float b = dot(rd, nor);\n    float c = dot(oc, nor);\n    float d = b*b - c;\n    if (d < 0.0) return -1.0;\n    float t = -b - sqrt(d);\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd,             // ray: origin, direction\n               in vec3 cen, float rad )            // sphere: center, radius\n{\n    vec3 oc = ro - cen;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - rad*rad;\n    float d = b*b - 4.0*a*c;\n    if (d < 0.0) return -1.0;\n    float t = (-b - sqrt(d)) / (2.0*a);\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd,           // ray: origin, direction\n                  in vec3 v0, in vec3 v1, in vec3 v2 ) // triangle: vertices\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross(rd, e2);\n    float a = dot(e1, h);\n    if (a > -0.00001 && a < 0.00001) return -1.0;\n    float f = 1.0 / a;\n    vec3 s = ro - v0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return -1.0;\n    vec3 q = cross(s, e1);\n    float v = f * dot(rd, q);\n    if (v < 0.0 || u + v > 1.0) return -1.0;\n    float t = f * dot(e2, q);\n   ", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (cen - ro) * invdir;\n\tvec3 tmax = (cen + rad - ro) * invdir;\n\tif (tmin.x > tmax.x) swap(tmin.x, tmax.x);\n\tif (tmin.y > tmax.y) swap(tmin.y, tmax.y);\n\tif (tmin.z > tmax.z) swap(tmin.z, tmax.z);\n\tfloat t0 = max(tmin.x, max(tmin.y, tmin.z));\n\tfloat t1 = min(tmax.x, min(tmax.y, tmax.z));\n\tif (t0 <= t1) return vec2(t0,t1); else return vec2(0.0);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\tvec3 l = ro - cen;\n\tfloat tca = dot(l, rd);\n\tfloat d2 = dot(l, l) - tca * tca;\n\tif (d2 > rad * rad) return vec2(0.0);\n\tfloat thc = sqrt(rad * rad - d2);\n\treturn vec2(tca - thc, tca + thc);\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = cross(rd, e2);\n\tfloat a = dot(e1, h);\n\tif (a > -0.00001 && a < 0.00001) return vec2(0.0);\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot(s, h);\n\tif (u <", "\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tvec3 c = pa + d * 0.5;\n\tvec3 n = normalize(d);\n\tvec3 e = vec3(0,0,0);\n\te.x = abs(n.x) * ra;\n\te.y = abs(n.y) * ra;\n\te.z = abs(n.z) * ra;\n\treturn bound3(c - e, c + e);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conebbox/conebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tvec3 c = pa + d * 0.5;\n\tvec3 n = normalize(d);\n\tvec3 e = vec3(0,0,0);\n\te.x = abs(n.x) * ra;\n\te.y = abs(n.y) * ra;\n\te.z = abs(n.z) * ra;\n\te.y = max(e.y, rb);\n\treturn bound3(c - e, c + e);\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n\treturn bound3(p - vec3(r,r,r), p + vec3(r,r,r));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a capsule (http://iquilezles.org/www/articles/capsulebbox/capsulebbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n\tvec3 d = pb - pa;\n\tfloat h = length(d);\n\tvec3 c = pa + d * 0.5;\n\tvec3 n = normalize(d);\n\tvec3 e = vec3(0,0,0);\n\te", "\n    vec3 v = pa - ro;\n    float b = dot(v, rd);\n    float c = dot(v, v) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 n = normalize(pa + t*rd - ro);\n    return vec4(t, n.x, n.y, n.z);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, \n              in vec3 sp, in float sr ) // sphere center, radius\n{\n    vec3 v = ro - sp;\n    float b = dot(v, rd);\n    float c = dot(v, v) - sr*sr;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 n = normalize(ro + t*rd - sp);\n    return vec4(t, n.x, n.y, n.z);\n}\n\n// ray-triangle intersection (returns t and normal)\nvec4 iTriangle( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in vec3 pc ) // point a, point b, point c\n{\n    vec3 e1 = pb - pa;\n    vec3 e2 = pc - pa;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det == 0.0) return vec4(0.0, 0.0, 0.0, 0.0);\n    float inv_det = 1.0 / det;\n    vec3 s = ro -", "\n\tvec3 tmin = (cen - ro) / rd;\n\tvec3 tmax = (cen + rad - ro) / rd;\n\n\tif (tmin.x > tmax.x) swap(tmin.x, tmax.x);\n\tif (tmin.y > tmax.y) swap(tmin.y, tmax.y);\n\tif (tmin.z > tmax.z) swap(tmin.z, tmax.z);\n\n\tfloat t0 = max(max(tmin.x, tmin.y), tmin.z);\n\tfloat t1 = min(min(tmax.x, tmax.y), tmax.z);\n\n\treturn vec2(t0, t1);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\tvec3 l = ro - cen;\n\tfloat tca = dot(l, rd);\n\tfloat d2 = dot(l, l) - tca * tca;\n\tfloat radius2 = rad * rad;\n\n\tif (d2 > radius2) return vec2(0.0);\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\treturn vec2(t0, t1);\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = cross(rd, e2);\n\tfloat a = dot(e1, h);\n\n\tif (a > -0.00001 && a < 0.00001) return vec2(0.0);\n\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot(s, h);\n\n\tif (u < 0.0 || u >", "\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat c = length( p - ( d * h ) );\n\tfloat l = length( d );\n\tfloat r2 = r * r;\n\tfloat D = h * h - c * c + r2;\n\tif ( D < 0.0 ) return -1.0;\n\tD = sqrt( D );\n\tfloat s0 = -h - D;\n\tfloat s1 = -h + D;\n\tif ( s1 < 0.0 ) return s0;\n\tif ( s0 < 0.0 ) return s1;\n\treturn min( s0, s1 ) / l;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec3 sp, in float sr )\n{\n\tvec3 l = ro - sp;\n\tfloat tca = dot( l, rd );\n\tif ( tca < 0.0 ) return -1.0;\n\tfloat d2 = dot( l, l ) - tca * tca;\n\tif ( d2 > sr * sr ) return -1.0;\n\treturn tca - sqrt( sr * sr - d2 );\n}\n\n// intersect triangle : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = cross( rd, e2 );\n\tfloat a = dot( e1, h );\n\tif ( a > -1.0e-6 && a < 1.0e-6 ) return -1.0;\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot( s, h );\n\tif ( u < ", "\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n = normalize( cross( ab, ac ) );\n\tif ( dot( n, ab ) < 0.0 ) n = -n;\n\treturn n;\n}\n\n// compute tangent\nvec3 capTangent( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n = normalize( cross( ab, ac ) );\n\tif ( dot( n, ab ) < 0.0 ) n = -n;\n\tvec3 t = normalize( cross( n, ab ) );\n\treturn t;\n}\n\n// compute binormal\nvec3 capBinormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n = normalize( cross( ab, ac ) );\n\tif ( dot( n, ab ) < 0.0 ) n = -n;\n\tvec3 t = normalize( cross( n, ab ) );\n\tvec3 b = normalize( cross( t, n ) );\n\treturn b;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in vec3 c, in float r )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n = normalize( cross( ab, ac ) );\n\tif ( dot( n, ab ) < 0.0 ) n = -n;\n\treturn n;\n}\n\n// compute tangent\nvec3 capTangent( in vec3 pos, in vec3 a, in vec3 b, in vec3 c, in float r )\n{\n\tvec3 ab = b - a;\n\tvec3 ac = pos - a;\n\tvec3 bc = pos - b;\n\tvec3 n", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = ( -rad - ro ) * invdir;\n\tvec3 tmax = (  rad - ro ) * invdir;\n\tif ( tmin.x > tmax.x ) swap( tmin.x, tmax.x );\n\tif ( tmin.y > tmax.y ) swap( tmin.y, tmax.y );\n\tif ( tmin.z > tmax.z ) swap( tmin.z, tmax.z );\n\tfloat t0 = max( tmin.x, max( tmin.y, tmin.z ) );\n\tfloat t1 = min( tmax.x, min( tmax.y, tmax.z ) );\n\treturn vec2( t0, t1 );\n}\n\n// ray-box intersection in world space\nvec2 iBoxW( in vec3 ro, in vec3 rd, in vec3 rad, in mat4 m ) \n{\n\tvec3 roW = ( m * vec4( ro, 1.0 ) ).xyz;\n\tvec3 rdW = ( m * vec4( rd, 0.0 ) ).xyz;\n\tvec3 radW = ( m * vec4( rad, 0.0 ) ).xyz;\n\treturn iBox( roW, rdW, radW );\n}\n\n// ray-sphere intersection in box space\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\tvec3 d = ro - rad;\n\tfloat b = dot( d, rd );\n\tfloat c = dot( d, d ) - 1.0;\n\tfloat h = b * b - c;\n\tif ( h < 0.0 ) return vec2( -1.0, -1.0 );\n\tfloat t = -b - sqrt( h );\n\tif ( t < 0.0 ) return vec2( -1.0, -1.0 );\n\treturn vec2( t, -1.0 );\n}\n\n// ray-sphere intersection in world space\nvec2 iSphereW( in vec3 ro, in vec3 rd, in vec3 rad, in mat", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tvec3 p = vec3(0.0);\n\tvec3 n = vec3(0.0);\n\tvec3 c = vec3(0.0);\n\tvec3 l = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tvec3 h = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\tvec3 w = vec3(0.0);\n\tvec3 u = vec3(0.0);\n\tvec3 q = vec3(0.0);\n\tvec3 s = vec3(0.0);\n\tvec3 r = vec3(0.0);\n\tvec3 f = vec3(0.0);\n\tvec3 g = vec3(0.0);\n\tvec3 b = vec3(0.0);\n\tvec3 i = vec3(0.0);\n\tvec3 j = vec3(0.0);\n\tvec3 k = vec3(0.0);\n\tvec3 m = vec3(0.0);\n\tvec3 o = vec3(0.0);\n\tvec3 x = vec3(0.0);\n\tvec3 y = vec3(0.0);\n\tvec3 z = vec3(0.0);\n\tvec3 a = vec3(0.0);\n\tvec3 h1 = vec3(0.0);\n\tvec3 h2 = vec3(0.0);\n\tvec3 h3 = vec3(0.0);\n\tvec3 h4 = vec3(0.0);\n\tvec3 h5 = vec3(0.0);\n\tvec3 h6 = vec3(0.0);\n\tvec3 h7 = vec3(0.0);\n\tvec3 h8 = vec3(0.0);\n\tvec3 h9 = vec3(0.0);\n\tvec3 h10 = vec3(0.0);\n\tvec3 h11 = vec3(0.0", "\n\tfloat phi = 2.0 * M_PI * i / n;\n\tfloat theta = M_PI * (3.0 - sqrt(5.0)) * i / n;\n\tfloat x = sin(theta) * cos(phi);\n\tfloat y = cos(theta);\n\tfloat z = sin(theta) * sin(phi);\n\treturn vec3(x, y, z);\n}\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n, float r) \n{\n\tfloat phi = 2.0 * M_PI * i / n;\n\tfloat theta = M_PI * (3.0 - sqrt(5.0)) * i / n;\n\tfloat x = r * sin(theta) * cos(phi);\n\tfloat y = r * cos(theta);\n\tfloat z = r * sin(theta) * sin(phi);\n\treturn vec3(x, y, z);\n}\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n, float r, float phi) \n{\n\tfloat theta = M_PI * (3.0 - sqrt(5.0)) * i / n;\n\tfloat x = r * sin(theta) * cos(phi);\n\tfloat y = r * cos(theta);\n\tfloat z = r * sin(theta) * sin(phi);\n\treturn vec3(x, y, z);\n}\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n, float r, float phi, float theta) \n{\n\tfloat x = r * sin(theta) * cos(phi);\n\tfloat y = r * cos(theta);\n\tfloat z =", "\n\tvec3 p = ro;\n\tvec3 d = rd;\n\tvec3 n = vec3(0.0);\n\tvec3 c = vec3(0.0);\n\tvec3 f = vec3(0.0);\n\tvec3 t = vec3(0.0);\n\tvec3 s = vec3(0.0);\n\tvec3 v = vec3(0.0);\n\tvec3 u = vec3(0.0);\n\tvec3 w = vec3(0.0);\n\tvec3 q = vec3(0.0);\n\tvec3 r = vec3(0.0);\n\tvec3 e = vec3(0.0);\n\tvec3 m = vec3(0.0);\n\tvec3 g = vec3(0.0);\n\tvec3 b = vec3(0.0);\n\tvec3 a = vec3(0.0);\n\tvec3 h = vec3(0.0);\n\tvec3 k = vec3(0.0);\n\tvec3 l = vec3(0.0);\n\tvec3 o = vec3(0.0);\n\tvec3 i = vec3(0.0);\n\tvec3 j = vec3(0.0);\n\tvec3 p1 = vec3(0.0);\n\tvec3 p2 = vec3(0.0);\n\tvec3 p3 = vec3(0.0);\n\tvec3 p4 = vec3(0.0);\n\tvec3 p5 = vec3(0.0);\n\tvec3 p6 = vec3(0.0);\n\tvec3 p7 = vec3(0.0);\n\tvec3 p8 = vec3(0.0);\n\tvec3 p9 = vec3(0.0);\n\tvec3 p10 = vec3(0.0);\n\tvec3 p11 = vec3(0.0);\n\tvec3 p12 = vec3(0.0);\n\tvec3 p13 = vec3(0.0);\n\tvec3 p14 = vec3(0.0);\n\tvec3 p15 = vec3(0.0);\n\tvec3 p16", "\n\tvec3  grad = vec3( 0.0 );\n\tvec2  r = mod( p, 2.0 );\n\tp = ( p - r ) / 2.0;\n\tvec2  i = floor( p );\n\tvec2  f = fract( p );\n\tvec2  u = f * f * ( 3.0 - 2.0 * f );\n\tvec2  a = i;\n\tvec2  b = i + 1.0;\n\tvec2  c = a + 1.0;\n\tvec2  d = b + 1.0;\n\tvec2  e = a + 2.0;\n\tvec2  f = b + 2.0;\n\tvec2  g = c + 2.0;\n\tvec2  h = d + 2.0;\n\tvec2  i = e + 2.0;\n\tvec2  j = f + 2.0;\n\tvec2  k = g + 2.0;\n\tvec2  l = h + 2.0;\n\tvec2  m = i + 2.0;\n\tvec2  n = j + 2.0;\n\tvec2  o = k + 2.0;\n\tvec2  p = l + 2.0;\n\tvec2  q = m + 2.0;\n\tvec2  r = n + 2.0;\n\tvec2  s = o + 2.0;\n\tvec2  t = p + 2.0;\n\tvec2  u = q + 2.0;\n\tvec2  v = r + 2.0;\n\tvec2  w = s + 2.0;\n\tvec2  x = t + 2.0;\n\tvec2  y = u + 2.0;\n\tvec2  z = v + 2.0;\n\tvec2  A = w + 2.0;\n\tvec2  B = x + 2.0;\n\tvec2  C = y + 2.0;\n\tvec2  D = z + 2.0;\n\tvec2", "\n\tvec2 d = abs(p) - size;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat boxDist(vec3 p, vec3 size, float radius)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat smoothMerge(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMerge(float a, float b)\n{\n\treturn smoothMerge(a, b, 0.001);\n}\n\nfloat smoothMerge(float a, float b, float k, float m)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h) + m;\n}\n\nfloat smoothMerge(float a, float b, float k, float m, float n)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h) + m * n;\n}\n\nfloat smoothMerge(float a, float b, float k, float m, float n, float o)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h) + m * n * o;\n}\n\nfloat smoothMerge(float a, float b, float k, float m", "\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n\treturn vec3(0.5 + 0.5 * cos(2.0 * PI * (uv.x + uv.y)), 0.5 + 0.5 * sin(2.0 * PI * (uv.x + uv.y)), 0.0);\n}\n\n// Pattern 7", "\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat aa = 1.0;\n\tfloat ab = 1.0;\n\tfloat ac = 1.0;\n\tfloat ad = 1.0;\n\tfloat ae = 1.0;\n\tfloat af = 1.0;\n\tfloat ag = 1.0;\n\tfloat ah = 1.0;\n\tfloat ai = 1.0;\n\tfloat aj = 1.0;\n\tfloat ak = 1.0;\n\tfloat al = 1.0;\n\tfloat am = 1.0;\n\tfloat an = 1.0;\n\tfloat ao = 1.0;\n\tfloat ap = 1.0;\n\tfloat aq = 1.0;\n\tfloat ar = 1.0;\n\tfloat as = 1.0;\n\tfloat at = 1.0;\n\tfloat au = 1.0;\n\tfloat av = 1.0;\n\tfloat aw = 1.0;\n\tfloat ax = 1.0;\n\tfloat ay = 1.0;\n", "\n\tvec2 g = 2.0 * ddx * ddy;\n\tvec2 h = 2.0 * ddx * ddy;\n\tvec2 i = 2.0 * ddx * ddy;\n\tvec2 j = 2.0 * ddx * ddy;\n\tvec2 k = 2.0 * ddx * ddy;\n\tvec2 l = 2.0 * ddx * ddy;\n\tvec2 m = 2.0 * ddx * ddy;\n\tvec2 n = 2.0 * ddx * ddy;\n\tvec2 o = 2.0 * ddx * ddy;\n\tvec2 p = 2.0 * ddx * ddy;\n\tvec2 q = 2.0 * ddx * ddy;\n\tvec2 r = 2.0 * ddx * ddy;\n\tvec2 s = 2.0 * ddx * ddy;\n\tvec2 t = 2.0 * ddx * ddy;\n\tvec2 u = 2.0 * ddx * ddy;\n\tvec2 v = 2.0 * ddx * ddy;\n\tvec2 w = 2.0 * ddx * ddy;\n\tvec2 x = 2.0 * ddx * ddy;\n\tvec2 y = 2.0 * ddx * ddy;\n\tvec2 z = 2.0 * ddx * ddy;\n\tvec2 A = 2.0 * ddx * ddy;\n\tvec2 B = 2.0 * ddx * ddy;\n\tvec2 C = 2.0 * ddx * ddy;\n\tvec2 D = 2.0 * ddx * ddy;\n\tvec2 E = 2.0 * ddx * ddy;\n\tvec2 F = 2.0 * ddx * ddy;\n\tvec2 G = 2.0 * ddx * ddy;\n\tvec2 H = 2.0 * ddx * ddy;\n\tvec2 I = 2.0 * ddx * ddy;\n\tvec2 J = 2.0 * ddx * ddy;\n\t", "\n\tvec3 u = dFdx( p );\n\tvec3 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec2 p )\n{\n\tvec2 u = dFdx( p );\n\tvec2 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec2 dmap( in vec2 p )\n{\n\tvec2 u = dFdx( p );\n\tvec2 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n )\n{\n\tvec3 u = dFdx( p );\n\tvec3 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec2 dmap( in vec2 p, in vec2 n )\n{\n\tvec2 u = dFdx( p );\n\tvec2 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 m )\n{\n\tvec3 u = dFdx( p );\n\tvec3 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec2 dmap( in vec2 p, in vec2 n, in vec2 m )\n{\n\tvec2 u = dFdx( p );\n\tvec2 v = dFdy( p );\n\treturn normalize( cross( u, v ) );\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 n, in vec3 m, in vec3 o )\n{\n\tvec3 u = dFdx( p );", "\n\tv33 c;\n\tc.x = a.x;\n\tc.y = a.y;\n\tc.z = a.z;\n\ta.x = c.x;\n\ta.y = c.y;\n\ta.z = c.z;\n\tb.x = c.x;\n\tb.y = c.y;\n\tb.z = c.z;\n}\n\n//this is the function that actually does the ray-tracing\n//it takes a ray, a starting point, and a direction\n//it returns the distance to the closest object\n//it also returns the color of the closest object\n//it also returns the normal of the closest object\n//it also returns the material of the closest object\n//it also returns the texture of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture coordinates of the closest object\n//it also returns the texture", "return v33(a.x-b.x,a.y-b.y,a.z-b.z);}\nv33 add(v33 a,vec3 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 mul(v33 a,vec3 b){return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 div(v33 a,vec3 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 sub(v33 a,v33 b){return v33(a.x-b.x,a.y-b.y,a.z-b.z);}\nv33 add(v33 a,v33 b){return v33(a.x+b.x,a.y+b.y,a.z+b.z);}\nv33 mul(v33 a,v33 b){return v33(a.x*b.x,a.y*b.y,a.z*b.z);}\nv33 div(v33 a,v33 b){return v33(a.x/b.x,a.y/b.y,a.z/b.z);}\nv33 sub(v33 a,float b){return v33(a.x-b,a.y-b,a.z-b);}\nv33 add(v33 a,float b){return v33(a.x+b,a.y+b,a.z+b);}\nv33 mul(v33 a,float b){return v33(a.x*b,a.y*b,a.z*b);}\nv33 div(v33 a,float b){return v33(a.x/b,a.y/b,a.z/b);}\nv33 sub(float a,v33 b){return v33(a-b.", "\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\tc.z=a.z-b.z;\n\treturn c;\n}\n//substract b from all ray components\n//component wise ray substraction", "\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for BB\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for CC\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for DD\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for EE\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for FF\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for GG\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for HH\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for II\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for JJ\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x-b.x,a.y-b.y);\n}\n\n//v33-differentials for KK\nvec2 dt(v33 a,v33 b){\n\treturn vec2(a.x", "\n\treturn vec2(dot(a.x,b),dot(a.y,b));\n}\n\n//dual dotprodiuct on v33s\nvec3 dt(v33 a,vec4 b){\n\treturn vec3(dot(a.x,b),dot(a.y,b),dot(a.z,b));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,vec4 b){\n\treturn vec4(dot(a.x,b),dot(a.y,b),dot(a.z,b),0.0);\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec3 dt(v33 a,v33 b){\n\treturn vec3(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,v33 b){\n\treturn vec4(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z),0.0);\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33s b){\n\treturn vec2(dot(a.x,b.x),dot(a.y,b.y));\n}\n\n//dual dotprodiuct on v33s\nvec3 dt(v33 a,v33s b){\n\treturn vec3(dot(a.x,b.x),dot(a.y,b.y),dot(a.z,b.z));\n}\n\n//dual dotprodiuct on v33s\nvec4 dt(v33 a,v33s b){\n\treturn vec4(dot(a.x,b.x),dot(a.y", "\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(vec2 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\nv33 mul(v33 a,v33 b){\n\treturn v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//dual div\nv33 div(v33 a,vec2 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 div(vec2 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\nv33 div(v33 a,v33 b){\n\treturn v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//dual dot\nfloat dot(v33 a,vec2 b){\n\treturn a.x*b.x+a.y*b.y+a.z*b.z;\n}\nfloat dot(vec2 a,v33 b){\n\treturn a.x*b.x+a.y*b.y+a.z*b.z;\n}\nfloat dot(v33 a,v33 b){\n\treturn a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\n//dual cross\nv33 cross(v33 a,vec2 b){\n\treturn v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\nv33 cross(vec2 a,v33 b){\n\treturn v33(a", "\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n,float s){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n,float s,float t){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n,float s,float t,float u){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n,float s,float t,float u,float v){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0.0;\n}\n\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w,vec3 n,float s,float t,float u,float v,float ww){\n\tfloat d=abs(dot(w,p));\n\treturn (d<0.5)?1.0:0", "\n\tfloat d=length(p);\n\tfloat f=0.0;\n\tfloat a=0.0;\n\tfloat b=0.0;\n\tfloat c=0.0;\n\tfloat d1=0.0;\n\tfloat d2=0.0;\n\tfloat d3=0.0;\n\tfloat d4=0.0;\n\tfloat d5=0.0;\n\tfloat d6=0.0;\n\tfloat d7=0.0;\n\tfloat d8=0.0;\n\tfloat d9=0.0;\n\tfloat d10=0.0;\n\tfloat d11=0.0;\n\tfloat d12=0.0;\n\tfloat d13=0.0;\n\tfloat d14=0.0;\n\tfloat d15=0.0;\n\tfloat d16=0.0;\n\tfloat d17=0.0;\n\tfloat d18=0.0;\n\tfloat d19=0.0;\n\tfloat d20=0.0;\n\tfloat d21=0.0;\n\tfloat d22=0.0;\n\tfloat d23=0.0;\n\tfloat d24=0.0;\n\tfloat d25=0.0;\n\tfloat d26=0.0;\n\tfloat d27=0.0;\n\tfloat d28=0.0;\n\tfloat d29=0.0;\n\tfloat d30=0.0;\n\tfloat d31=0.0;\n\tfloat d32=0.0;\n\tfloat d33=0.0;\n\tfloat d34=0.0;\n\tfloat d35=0.0;\n\tfloat d36=0.0;\n\tfloat d37=0.0;\n\tfloat d38=0.0;\n\tfloat d39=0.0;\n\tfloat d40=0.0;\n\tfloat d41=0.0;\n\tfloat d42=0.0;\n\tfloat d43=0.0;\n\tfloat", "\n\tfloat t=0;\n\tfloat d=0;\n\tfloat t1=0;\n\tfloat t2=0;\n\tfloat t3=0;\n\tfloat t4=0;\n\tfloat t5=0;\n\tfloat t6=0;\n\tfloat t7=0;\n\tfloat t8=0;\n\tfloat t9=0;\n\tfloat t10=0;\n\tfloat t11=0;\n\tfloat t12=0;\n\tfloat t13=0;\n\tfloat t14=0;\n\tfloat t15=0;\n\tfloat t16=0;\n\tfloat t17=0;\n\tfloat t18=0;\n\tfloat t19=0;\n\tfloat t20=0;\n\tfloat t21=0;\n\tfloat t22=0;\n\tfloat t23=0;\n\tfloat t24=0;\n\tfloat t25=0;\n\tfloat t26=0;\n\tfloat t27=0;\n\tfloat t28=0;\n\tfloat t29=0;\n\tfloat t30=0;\n\tfloat t31=0;\n\tfloat t32=0;\n\tfloat t33=0;\n\tfloat t34=0;\n\tfloat t35=0;\n\tfloat t36=0;\n\tfloat t37=0;\n\tfloat t38=0;\n\tfloat t39=0;\n\tfloat t40=0;\n\tfloat t41=0;\n\tfloat t42=0;\n\tfloat t43=0;\n\tfloat t44=0;\n\tfloat t45=0;\n\tfloat t46=0;\n\tfloat t47=0;\n\tfloat t48=0;\n\tfloat t49=0;\n\tfloat t50=0;\n\tfloat t51=0;\n\tfloat t52=0;\n\tfloat t53=0;\n\tfloat t54=0;\n\tfloat t55=0;\n\tfloat t56=0;\n\tfloat", "\n\tfloat r = s.w;\n\tfloat d = dot(u,n);\n\tfloat c = length(u-n*d);\n\treturn 1.0-clamp(1.0-r*r/(r*r+c*c-d*d),0.0,1.0);\n}\n\n//plane occlusion\nfloat occPlane(vec3 u,vec3 n,vec4 s){\n\tfloat d = dot(u,n);\n\treturn clamp(1.0-d/length(u),0.0,1.0);\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 s){\n\tvec3 b = vec3(s.x,s.y,s.z);\n\tvec3 d = abs(u)-b;\n\treturn clamp(1.0-max(d.x,max(d.y,d.z))/length(u),0.0,1.0);\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n\tfloat r = s.w;\n\tfloat d = dot(u,n);\n\tfloat c = length(u-n*d);\n\treturn 1.0-clamp(1.0-r*r/(r*r+c*c-d*d),0.0,1.0);\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 s){\n\tfloat r = s.w;\n\tfloat d = dot(u,n);\n\tfloat c = length(u-n*d);\n\treturn 1.0-clamp(1.0-r*r/(r*r+c*c-d*d),0.0,1.0);\n}\n\n//torus occlusion\nfloat occTorus(vec3 u,vec3 n,vec4 s){\n\tfloat r = s.w;\n\tfloat d = dot(u,n);\n\tfloat c = length(u-n*d);\n\treturn 1.0-clamp(1.0-r*r/(r*r+c*c-d*d),0.", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p012, p012);\n}\n\n// Quadratic bezier to a cubic bezier\nvec4 bezierCubic(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p012, p012);\n}\n\n// Cubic bezier to a quadratic bezier\nvec4 bezierQuad(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\treturn vec4(p01, p12);\n}\n\n// Cubic bezier to a quadratic bezier\nvec4 bezierQuad(in vec4 p0, in vec4 p1, in vec4 p2 )\n{\n\tvec2 p01 = (p0.xy + p1.xy) * 0.5;\n\tvec2 p12 = (p1.xy + p2.xy) * 0.5;\n\treturn vec4(p01, p12);\n}\n\n// Cubic bezier to a quadratic bezier\nvec4 bezierQuad(in vec4 p0, in vec4 p1, in vec4 p2, in vec4 p3 )\n{\n\tvec2 p01 = (p0.xy + p1.xy) * 0.5;\n\tvec2 p12 = (p1.xy + p2.xy) * 0.5;\n\tvec2", "\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\treturn vec4(p012, p012);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\tvec2 p01212 = (p012 + p12) * 0.5;\n\treturn vec4(p01212, p01212);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 p01 = (p0 + p1) * 0.5;\n\tvec2 p12 = (p1 + p2) * 0.5;\n\tvec2 p23 = (p2 + p3) * 0.5;\n\tvec2 p012 = (p01 + p12) * 0.5;\n\tvec2 p123 = (p12 + p23) * 0.5;\n\tvec2 p01212 = (p012 + p123) * 0.5;\n\treturn vec4(p01212, p01212);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n\tvec2 p01 = (p0 + p1", "\n\tvec3 v0 = p0 - p1;\n\tvec3 v1 = p2 - p1;\n\tvec3 v2 = p3 - p1;\n\tvec3 v3 = cross( v1, v2 );\n\tvec3 v4 = cross( v2, v0 );\n\tvec3 v5 = cross( v0, v1 );\n\tvec3 v6 = cross( v3, v4 );\n\tvec3 v7 = cross( v4, v5 );\n\tvec3 v8 = cross( v5, v6 );\n\tvec3 v9 = cross( v6, v7 );\n\tvec3 v10 = cross( v7, v8 );\n\tvec3 v11 = cross( v8, v9 );\n\tvec3 v12 = cross( v9, v10 );\n\tvec3 v13 = cross( v10, v11 );\n\tvec3 v14 = cross( v11, v12 );\n\tvec3 v15 = cross( v12, v13 );\n\tvec3 v16 = cross( v13, v14 );\n\tvec3 v17 = cross( v14, v15 );\n\tvec3 v18 = cross( v15, v16 );\n\tvec3 v19 = cross( v16, v17 );\n\tvec3 v20 = cross( v17, v18 );\n\tvec3 v21 = cross( v18, v19 );\n\tvec3 v22 = cross( v19, v20 );\n\tvec3 v23 = cross( v20, v21 );\n\tvec3 v24 = cross( v21, v22 );\n\tvec3 v25 = cross( v22, v23 );\n\tvec3 v26 = cross( v23, v24 );\n\tvec3 v27 = cross( v24, v25 );\n\tvec3 v28 = cross( v25, v26 );\n\tvec3 v29 = cross( v26, v27 );\n\tvec3 v30 = cross( v27", "\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\treturn vec4(p0123, 0.0, 1.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n\tvec2 p01 = mix(p0, p1, 0.5);\n\tvec2 p12 = mix(p1, p2, 0.5);\n\tvec2 p23 = mix(p2, p3, 0.5);\n\tvec2 p34 = mix(p3, p4, 0.5);\n\tvec2 p012 = mix(p01, p12, 0.5);\n\tvec2 p123 = mix(p12, p23, 0.5);\n\tvec2 p234 = mix(p23, p34, 0.5);\n\tvec2 p0123 = mix(p012, p123, 0.5);\n\tvec2 p1234 = mix(p123, p234, 0.5);\n\tvec2 p01234 = mix(p0123, p1234, 0.5);\n\treturn vec4(p01234, 0.0, 1.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec2 p0, in", "\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\tvec2 d = p3;\n\tvec2 t = pos;\n\tvec2 ab = mix(a, b, t);\n\tvec2 bc = mix(b, c, t);\n\tvec2 cd = mix(c, d, t);\n\tvec2 abbc = mix(ab, bc, t);\n\tvec2 bccd = mix(bc, cd, t);\n\tvec2 abbcccd = mix(abbc, bccd, t);\n\treturn abbcccd;\n}\n\n// 2D Catmull-Rom spline\nvec2 catmullRom(vec2 p0, vec2 p1, vec2 p2, vec2 p3, in vec2 pos)\n{\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\tvec2 d = p3;\n\tvec2 t = pos;\n\tvec2 ab = mix(a, b, t);\n\tvec2 bc = mix(b, c, t);\n\tvec2 cd = mix(c, d, t);\n\tvec2 abbc = mix(ab, bc, t);\n\tvec2 bccd = mix(bc, cd, t);\n\tvec2 abbcccd = mix(abbc, bccd, t);\n\treturn abbcccd;\n}\n\n// 2D Hermite spline\nvec2 hermite(vec2 p0, vec2 p1, vec2 p2, vec2 p3, in vec2 pos)\n{\n\tvec2 a = p0;\n\tvec2 b = p1;\n\tvec2 c = p2;\n\tvec2 d = p3;\n\tvec2 t = pos;\n\tvec2 ab = mix(a, b, t);\n\tvec2 bc = mix(b, c, t);\n\tvec2 cd = mix(c, d, t);\n\tvec2 abbc = mix(ab, bc, t);\n\tvec2 bccd = mix(bc, cd, t);\n\tvec2 abbcccd = mix(abbc, bccd, t);\n", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross( rd, e2 );\n\tfloat a = dot( e1, p );\n\tif ( a > -EPSILON && a < EPSILON )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot( s, p );\n\tif ( u < 0.0 || u > 1.0 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tvec3 q = cross( s, e1 );\n\tfloat v = f * dot( rd, q );\n\tif ( v < 0.0 || u + v > 1.0 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat t = f * dot( e2, q );\n\tif ( t > EPSILON )\n\t\treturn vec3( t, u, v );\n\telse\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n}\n\n// Sphere intersection. Returns { t, u, v }\nvec3 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 sp, in float sr )\n{\n\tvec3 l = ro - sp;\n\tfloat tca = dot( l, rd );\n\tif ( tca < 0.0 )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat d2 = dot( l, l ) - tca * tca;\n\tif ( d2 > sr * sr )\n\t\treturn vec3( -1.0, -1.0, -1.0 );\n\tfloat thc = sqrt( sr * sr - d2 );\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif ( t0 > t1 )\n\t\tswap( t0, t1 );\n\tif ( t0 < 0.0 )\n\t{\n\t", "\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 s = cross( e2, e1 );\n\tvec3 p = cross( pos - v0, e1 );\n\tfloat d = dot( s, e2 );\n\tfloat t = dot( s, p ) / d;\n\tif( t < 0.0 || t > 1.0 ) return 0.0;\n\tp = cross( pos - v0, e2 );\n\tfloat u = dot( s, p ) / d;\n\tif( u < 0.0 || u > 1.0 ) return 0.0;\n\tfloat q = 1.0 - u - t;\n\tif( q < 0.0 || q > 1.0 ) return 0.0;\n\treturn 1.0;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 e3 = v3 - v0;\n\tvec3 s = cross( e2, e1 );\n\tvec3 p = cross( pos - v0, e1 );\n\tfloat d = dot( s, e2 );\n\tfloat t = dot( s, p ) / d;\n\tif( t < 0.0 || t > 1.0 ) return 0.0;\n\tp = cross( pos - v0, e2 );\n\tfloat u = dot( s, p ) / d;\n\tif( u < 0.0 || u > 1.0 ) return 0.0;\n\tfloat q = 1.0 - u - t;\n\tif( q < 0.0 || q > 1.0 ) return 0.0;\n\ts = cross( e3, e1 );\n\tp = cross( pos - v0, e1 );\n\td = dot( s, e3 );\n\tt = dot( s", "\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tfloat ab2 = dot( ab, ab );\n\tfloat ac2 = dot( ac, ac );\n\tfloat bc2 = dot( bc, bc );\n\tfloat abc = dot( ab, ac );\n\tfloat bca = dot( bc, ac );\n\tfloat bac = dot( bc, ab );\n\tfloat a2 = dot( p - a, p - a );\n\tfloat b2 = dot( p - b, p - b );\n\tfloat c2 = dot( p - c, p - c );\n\tfloat a3 = a2 * a2;\n\tfloat b3 = b2 * b2;\n\tfloat c3 = c2 * c2;\n\tfloat a2b = a2 * b2;\n\tfloat a2c = a2 * c2;\n\tfloat b2c = b2 * c2;\n\tfloat a2bc = a2b * c2;\n\tfloat a2b2 = a2b * b2;\n\tfloat a2c2 = a2c * c2;\n\tfloat b2c2 = b2c * c2;\n\tfloat a2bc2 = a2bc * c2;\n\tfloat a2b2c = a2b2 * c2;\n\tfloat a2b2c2 = a2b2c * c2;\n\tfloat a2b2c3 = a2b2c2 * c2;\n\tfloat a2b2c2b = a2b2c2 * b2;\n\tfloat a2b2c2c = a2b2c2 * c2;\n\tfloat a2b2c2bc = a2b2c2 * bc2;\n\tfloat a2b2c2b2 = a2b2c2 * b2;\n\tfloat a2b2c2b2c = a2b2c2 * c2;\n\tfloat a2b2c2b2c2 = a2b2", "\n\tfloat h = p.y;\n\tfloat d = abs( p.x );\n\tfloat r = mix( r1, r2, h / he );\n\treturn max( d - r, h - he ) + length( p );\n}\n\n// torus, specialized for Y alignment\nfloat sdTorus( in vec2 p, in float r1, float r2 )\n{\n\tfloat d = length( p ) - r1;\n\treturn d * d + r2 * r2 - r2 * r2 * cos( d / r2 );\n}\n\n// torus knot, specialized for Y alignment\nfloat sdTorusKnot( in vec2 p, in float r1, float r2, float k )\n{\n\tfloat d = length( p ) - r1;\n\tfloat a = atan( p.x, p.y );\n\tfloat c = cos( k * a );\n\tfloat s = sin( k * a );\n\treturn d * d + r2 * r2 - r2 * r2 * c;\n}\n\n// torus knot, specialized for Y alignment\nfloat sdTorusKnot2( in vec2 p, in float r1, float r2, float k )\n{\n\tfloat d = length( p ) - r1;\n\tfloat a = atan( p.x, p.y );\n\tfloat c = cos( k * a );\n\tfloat s = sin( k * a );\n\treturn d * d + r2 * r2 - r2 * r2 * c;\n}\n\n// torus knot, specialized for Y alignment\nfloat sdTorusKnot3( in vec2 p, in float r1, float r2, float k )\n{\n\tfloat d = length( p ) - r1;\n\tfloat a = atan( p.x, p.y );\n\tfloat c = cos( k * a );\n\tfloat s = sin( k * a );\n\treturn d * d + r2 * r2 - r2 * r2 * c;\n}\n\n// torus knot, specialized for Y alignment\nfloat sdTorusKnot4( in vec2 p, in float r1, float r2, float k )\n{\n\tfloat d", "\n\tvec2 w = p - a;\n\tvec2 h = b - a;\n\tfloat hw = dot( w, h );\n\tfloat hh = dot( h, h );\n\tfloat aw = dot( w, w );\n\tfloat ah = dot( a, h );\n\tfloat ab = dot( a, b );\n\tfloat bh = dot( b, h );\n\tfloat d = hw * hw * hh - hh * aw;\n\tfloat e = hw * hw * bh - bh * aw;\n\tfloat f = hw * hw * ab - ab * aw;\n\tfloat g = hh * bh - bh * bh;\n\tfloat h = hh * ab - ab * bh;\n\tfloat i = hh * ah - ah * hh;\n\tfloat j = ab * ah - ah * ab;\n\tfloat k = aw * bh - bh * aw;\n\tfloat l = aw * ab - ab * aw;\n\tfloat m = aw * ah - ah * aw;\n\tfloat n = aw * ab - ab * aw;\n\tfloat t = d * e - g * f;\n\tfloat u = d * h - i * f;\n\tfloat v = d * j - k * f;\n\tfloat w = e * h - l * f;\n\tfloat x = e * j - m * f;\n\tfloat y = g * j - n * f;\n\tfloat z = i * j - m * h;\n\tfloat A = d * y - h * w + j * u;\n\tfloat B = e * y - l * w + m * u;\n\tfloat C = g * y - n * w + p.y * u;\n\tfloat D = i * y - m * w + n * v;\n\tfloat E = j * y - p.y * w + m * x;\n\tfloat F = k * y - p.y * v + l * x;\n\tfloat G = l * z - m * x + n * v;\n\tfloat H = m * z - n * x + p.y * v;\n\tfloat I = n * z - p.y * v + m * x;\n\tfloat J = p.x * z - m * x + n * v;\n\tfloat K", "\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( 0.001, 0.0, 0.0 ) ) - sdf( pos - vec3( 0.001, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.001, 0.0 ) ) - sdf( pos - vec3( 0.0, 0.001, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.0, 0.001 ) ) - sdf( pos - vec3( 0.0, 0.0, 0.001 ) )\n\t);\n\treturn normalize( n );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in vec3 nrm )\n{\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( 0.001, 0.0, 0.0 ) ) - sdf( pos - vec3( 0.001, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.001, 0.0 ) ) - sdf( pos - vec3( 0.0, 0.001, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.0, 0.001 ) ) - sdf( pos - vec3( 0.0, 0.0, 0.001 ) )\n\t);\n\treturn normalize( nrm + n );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in vec3 nrm, in vec3 nrm2 )\n{\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( 0.001, 0.0, 0.0 ) ) - sdf( pos - vec3( 0.001, ", "\n\tfloat t = tmin;\n\tfloat dt = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat f = 0.0;\n\tfloat bias = 0.0;\n\tfloat shadow = 1.0;\n\tfloat bias_shadow = 1.0;\n\tfloat bias_shadow_soft = 1.0;\n\tfloat bias_shadow_soft_max = 1.0;\n\tfloat bias_shadow_soft_min = 1.0;\n\tfloat bias_shadow_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min = 1.0;\n\tfloat bias_shadow_soft_min_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max_soft = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max_soft_max = 1.0;\n\tfloat bias_shadow_soft_min_soft_max_soft_max_soft_max = 1.0;\n\tfloat bias_shadow_soft_max_soft_min_soft_max", "\n    return fract(sin(dot(q,vec2(127.1,311.7)))*43758.5453123);\n}\n\n// 2D simplex noise\nfloat snoise( in vec2 v )\n{\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 =   v - i + dot(i, C.xx);\n\n// Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n// Permutations\n    i = mod(i, 289.0 );\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n// Gradients", "\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\n\tvec2 r = i + vec2( p, p + 1 );\n\n\tvec3 h = vec3( dot( i, vec2( 127.1, 311.7 ) ), dot( r, vec2( 269.5, 183.3 ) ), dot( r, vec2( 419.2, 371.9 ) ) );\n\n\treturn mix( mix( dot( u, vec2( h.x, h.y ) ), dot( u, vec2( h.y, h.z ) ), f.x ), mix( dot( u, vec2( h.z, h.x ) ), dot( u, vec2( h.y, h.x ) ), f.x ), f.y );\n}\n\n// 2D simplex noise\nfloat snoise( vec2 v )\n{\n\tconst vec2 C = vec2( 0.138196601125011, 0.138196601125011 );\n\tvec2 i = floor( v + dot( v, C ) );\n\tvec2 x0 = v - i + dot( i, C );\n\tvec2 i1;\n\ti1 = ( x0.x > x0.y )? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\ti = mod289( i );\n\tvec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) ) + i.x + vec3( 0.0, i1.x, 1.0 ) );\n\tvec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x1", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2( 100.0 );\n\tfor( int i = 0; i < p; ++i )\n\t{\n\t\tf += a * noise( x );\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\n// turbulence\nfloat turbulence( in vec2 x, in int p )\n{\n\tfloat t = 0.0;\n\tfloat a = 1.0;\n\tvec2 shift = vec2( 100.0 );\n\tfor( int i = 0; i < p; ++i )\n\t{\n\t\tt += a * abs( noise( x ) );\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn t;\n}\n\n// cellular noise\nfloat cellular( in vec2 x )\n{\n\tconst float jitter = 4.0;\n\tvec2 p = floor( x );\n\tvec2 f = fract( x );\n\tfloat c = 1.0;\n\tfloat im = 1.0;\n\tfor( int i = 0; i < 4; ++i )\n\t{\n\t\tvec2 cell = p;\n\t\tif( im > 0.0 ) cell += vec2( random( p ), random( p ) ) * jitter;\n\t\tvec2 x = f * cell;\n\t\tvec2 b = step( vec2( 0.4 ), abs( f - ( cell + 0.5 ) ) );\n\t\tc += ( im - c ) * b.x * b.y;\n\t\tim *= 1.0 - b.x * b.y;\n\t\tp = floor( cell );\n\t\tf = fract( cell );\n\t}\n\treturn c;\n}\n\n// simplex noise\nfloat snoise( in vec2 x )\n{\n\tconst vec2  C = vec2( 0.138196601125011, 0.13819660", "\n\tvec3 q = abs(p)-r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat sdTorus( in vec3 p, in vec2 r ) \n{\n\tvec2 q = vec2(length(p.xz)-r.x,p.y);\n\treturn length(q)-r.y;\n}\n\n// generic box - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n\tvec3 q = abs(p)-b;\n\treturn length(max(q,0.0));\n}\n\n// generic sphere - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat sdSphere( in vec3 p, in float r ) \n{\n\treturn length(p)-r;\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat sdCylinder( in vec3 p, in float h, in float r ) \n{\n\tvec2 q = vec2(length(p.xz)-r,p.y-h*0.5);\n\treturn length(max(q,0.0)) - h*0.5;\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/4dS3zW\nfloat sdCone( in vec3 p, in float h, in float r ) \n{\n\tfloat y = p.y;\n\tfloat xz = length(p.xz);\n\tfloat q = y-h*0.5;\n\tfloat d = q/h;\n\treturn length(vec2(xz,max(q,0.0))) - r*sqrt(1.0-d*d);\n}\n\n// generic capsule - approximated distance: https://www.shadertoy.com/view/4dS3z", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZX( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXY( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYY( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXZZ( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidYXX( in vec3 p, in vec2 r ) \n{\n\tvec3 q = abs(p) - r;\n\treturn length(max(q.x,max(q.y,q.z))) + min(max(q.x,max(q.y,q.z", "\n\tvec3 q = abs(p)-r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c ) \n{\n\treturn length(p-c) - length(max(abs(p-c)-r,0.0));\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float s ) \n{\n\treturn length(p-c) - length(max(abs(p-c)-r,0.0)) * s;\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float s, in float m ) \n{\n\treturn length(p-c) - length(max(abs(p-c)-r,0.0)) * s * m;\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t ) \n{\n\treturn length(p-c) - length(max(abs(p-c)-r,0.0)) * s * m * t;\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t, in float b ) \n{\n\treturn length(p-c) - length(max(abs(p-c)-r,0.0)) * s * m * t * b;\n}\n\n// ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t, in float b, in float a ) ", "\n\tvec3 q = abs(p) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c ) \n{\n\treturn length(p - c) - length(max(abs(p) - r,0.0));\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float s ) \n{\n\treturn length(p - c) - length(max(abs(p) - r,0.0)) * s;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float s, in float m ) \n{\n\treturn length(p - c) - length(max(abs(p) - r,0.0)) * s * m;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t ) \n{\n\treturn length(p - c) - length(max(abs(p) - r,0.0)) * s * m * t;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t, in float b ) \n{\n\treturn length(p - c) - length(max(abs(p) - r,0.0)) * s * m * t * b;\n}\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r, in vec3 c, in float s, in float m, in float t, in float b, in float a ) \n{\n\treturn length(p - c) - length(max(abs(p) - r", "\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\tf = f * f * ( 3.0 - 2.0 * f );\n\tfloat c = ( f.x * f.y - f.x * f.y * f.y );\n\treturn mix( mix( i.x + i.y, i.x + i.y + 1.0, c ), mix( i.x + i.y + 1.0, i.x + i.y + 2.0, c ), f.y );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * ( b.x - a.x ) / k, 0.0, 1.0 );\n\treturn mix( b.x, a.x, h ) - k * h * ( 1.0 - h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( vec3 a, vec3 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * ( b.x - a.x ) / k, 0.0, 1.0 );\n\treturn mix( b.x, a.x, h ) - k * h * ( 1.0 - h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( vec4 a, vec4 b, float k )\n{\n\tfloat h = clamp( 0.5 + ", "\n\treturn x * x * (3.0f - 2.0f * x);\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat ggx( float a, float x )\n{\n\tfloat a2 = a * a;\n\tfloat x2 = x * x;\n\treturn a2 / (M_PI * x2 * (a2 - 1.0f) + 1.0f);\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat ggx( float a, float x, float alpha )\n{\n\tfloat a2 = a * a;\n\tfloat x2 = x * x;\n\treturn a2 / (M_PI * x2 * (a2 - 1.0f) + 1.0f) * alpha;\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat ggx( float a, float x, float alpha, float beta )\n{\n\tfloat a2 = a * a;\n\tfloat x2 = x * x;\n\treturn a2 / (M_PI * x2 * (a2 - 1.0f) + 1.0f) * alpha * beta;\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat ggx( float a, float x, float alpha, float beta, float gamma )\n{\n\tfloat a2 = a * a;\n\tfloat x2 = x * x;\n\treturn a2 / (M_PI * x2 * (a2 - 1.0f) + 1.0f) * alpha * beta * gamma;\n}\n\n// Schlick GGX distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.", "\n\treturn ( x + p ) * 0.5f;\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n\treturn ( x < p )? 0.0f : 1.0f;\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n\treturn ( x < p )? x : 1.0f - x;\n}\n\n// biased pulse\nfloat my_pulse( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased random\nfloat my_rnd( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased noise\nfloat my_noise( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased sine\nfloat my_sin( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased cosine\nfloat my_cos( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased sine\nfloat my_sine( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased cosine\nfloat my_cosine( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased sine\nfloat my_sawtooth( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased square\nfloat my_square( float x, float p )\n{\n\treturn ( x < p )? 1.0f : 0.0f;\n}\n\n// biased triangle\nfloat my_triangle( float x,", "\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h, float s )\n{\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h, float s, float l )\n{\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h, float s, float l, float a )\n{\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h, float s, float l, float a, float b )\n{\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h, float s, float l, float a, float b, float c )\n{\n    float c = cos( h * 2.0 * PI );\n    float s = sin( h * 2.0 * PI );\n    return vec3( c, s, 0.0 );\n}\n", "\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat c = length( p - ( d * clamp( h, 0.0, 1.0 ) ) );\n\treturn clamp( c - r, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat c = length( p - ( d * clamp( h, 0.0, 1.0 ) ) );\n\treturn clamp( c - r, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCone( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n\tvec3 p = pa - ro;\n\tvec3 d = pb - pa;\n\tfloat h = dot( p, d );\n\tfloat c = length( p - ( d * clamp( h, 0.0, 1.0 ) ) );\n\treturn clamp( c - r, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 pa, in float r )\n{\n\tvec3 p = pa - ro;\n\tfloat c = length( p );\n\treturn clamp( c - r, 0.0, 1.0 );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iPlane( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pn )\n{\n\tfloat h = dot( pa - ro,", "\n\tfloat d = length(p - a);\n\tfloat t = clamp(dot(normalize(p - a), normalize(b - a)), 0.0, 1.0);\n\tfloat h = length(p - (a + t * (b - a)));\n\tfloat r = ra * (1.0 - t) + rb * t;\n\treturn max(d - r, h - r);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n\treturn length(p - c) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec3 q = pa - ba * h;\n\tfloat d = length(q) - ra;\n\treturn d < 0.0? d : length(q - normalize(q) * rb) - rb;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus2(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec3 q = pa", "\n\tvec3 p = a + rd * k;\n\tvec3 q = b + rd * k;\n\tvec3 d = q - p;\n\tfloat t = length( d );\n\td = normalize( d );\n\tfloat h = clamp( dot( d, normalize( p - ro ) ), 0.0, 1.0 );\n\tfloat c = clamp( dot( d, normalize( q - ro ) ), 0.0, 1.0 );\n\tfloat s = clamp( dot( d, normalize( p - q ) ), 0.0, 1.0 );\n\tfloat d1 = clamp( dot( d, normalize( p - ro ) ), 0.0, 1.0 );\n\tfloat d2 = clamp( dot( d, normalize( q - ro ) ), 0.0, 1.0 );\n\tfloat d3 = clamp( dot( d, normalize( p - q ) ), 0.0, 1.0 );\n\tfloat d4 = clamp( dot( d, normalize( q - p ) ), 0.0, 1.0 );\n\tfloat d5 = clamp( dot( d, normalize( ro - p ) ), 0.0, 1.0 );\n\tfloat d6 = clamp( dot( d, normalize( ro - q ) ), 0.0, 1.0 );\n\tfloat d7 = clamp( dot( d, normalize( p - ro ) ), 0.0, 1.0 );\n\tfloat d8 = clamp( dot( d, normalize( q - ro ) ), 0.0, 1.0 );\n\tfloat d9 = clamp( dot( d, normalize( p - q ) ), 0.0, 1.0 );\n\tfloat d10 = clamp( dot( d, normalize( q - p ) ), 0.0, 1.0 );\n\tfloat d11 = clamp( dot( d, normalize( ro - p ) ), 0.0, 1.0 );\n\tfloat d12 = clamp( dot( d, normalize( ro - q ) ), 0.0, 1.0 );\n\tfloat d13 = clamp( dot( d, normalize( p - ro ) ), 0.0, ", "\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float t = a / (2.0 * PI);\n    float s = sin(t * 2.0 * PI);\n    float c = cos(t * 2.0 * PI);\n    float r1 = rad1 + s * th;\n    float r2 = rad2 + s * th;\n    float r3 = r1 + (r2 - r1) * smoothstep(0.0, 1.0, r);\n    float r4 = r3 + (r2 - r3) * smoothstep(0.0, 1.0, r);\n    float r5 = r4 + (r2 - r4) * smoothstep(0.0, 1.0, r);\n    float r6 = r5 + (r2 - r5) * smoothstep(0.0, 1.0, r);\n    float r7 = r6 + (r2 - r6) * smoothstep(0.0, 1.0, r);\n    float r8 = r7 + (r2 - r7) * smoothstep(0.0, 1.0, r);\n    float r9 = r8 + (r2 - r8) * smoothstep(0.0, 1.0, r);\n    float r10 = r9 + (r2 - r9) * smoothstep(0.0, 1.0, r);\n    float r11 = r10 + (r2 - r10) * smoothstep(0.0, 1.0, r);\n    float r12 = r11 + (r2 - r11) * smoothstep(0.0, 1.0, r);\n    float r13 = r12 + (r2 - r12) * smoothstep(0.0, 1.0, r);\n    float r14 = r13 + (r2 - r13) * smoothstep(0.0, 1.0, r);\n    float r15 = r14 + (r2 - r14) * smoothstep(0.0, 1.0, r);\n    float r16 = r15 + (r2 - r15", "\n\tvec2 q = p - c;\n\tfloat d = length( q );\n\tif( d > r ) return 1.0;\n\tfloat t = atan( q.y, q.x );\n\tfloat a = t - c.x;\n\tfloat b = c.y - r;\n\tfloat h = sqrt( r*r - d*d );\n\tfloat s = h * a / b;\n\treturn abs( s ) / b;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle2( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle3( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle4( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle5( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle6( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle7( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// c is the center of the circle. r is the radius\nfloat sdCircle8( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r", "\n\tvec3 n = vec3( 4.0 * pos.x * pos.x, 4.0 * pos.y * pos.y, 4.0 * pos.z * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2 - ra^2\nvec3 nSphere2( in vec3 pos )\n{\n\tvec3 n = vec3( 2.0 * pos.x, 2.0 * pos.y, 2.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2 - 1\nvec3 nSphere1( in vec3 pos )\n{\n\tvec3 n = vec3( 2.0 * pos.x, 2.0 * pos.y, 2.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2\nvec3 nSphere0( in vec3 pos )\n{\n\tvec3 n = vec3( 2.0 * pos.x, 2.0 * pos.y, 2.0 * pos.z );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2\nvec3 nPlane( in vec3 pos )\n{\n\tvec3 n = vec3( 2.0 * pos.x, 2.0 * pos.y, 0.0 );\n\treturn n;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2 - 1\nvec3 nPlane1( in vec3 pos )\n{\n\tvec3 n = vec3( 2.0 * pos.x, 2.0 * pos.y, 2.0 * pos.z );\n\treturn", "\n\tvec2 q = p - 0.5;\n\tfloat d = length( q );\n\tfloat t = atan( q.y, q.x );\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * s;\n\tfloat b = rb * c;\n\tfloat x = a * sca.x + b * scb.x;\n\tfloat y = a * sca.y + b * scb.y;\n\treturn length( vec2( x, y ) ) - d;\n}\n\n// sdArcRound\n//\n// The signed distance function for an arc with rounded corners.\n//\n// p is the point to test\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\n// ra is the radius of the arc\n// rb is the radius of the rounded corners\n// r is the radius of the rounded corners\nfloat sdArcRound( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r )\n{\n\tvec2 q = p - 0.5;\n\tfloat d = length( q );\n\tfloat t = atan( q.y, q.x );\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * s;\n\tfloat b = rb * c;\n\tfloat x = a * sca.x + b * scb.x;\n\tfloat y = a * sca.y + b * scb.y;\n\tfloat d1 = length( vec2( x, y ) ) - d;\n\tfloat d2 = length( vec2( x, y ) ) - d - r;\n\treturn min( d1, d2 );\n}\n\n// sdArcRound\n//\n// The signed distance function for an arc with rounded corners.\n//\n// p is the point to test\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\n// ra is the radius of the arc\n// rb is the radius of the rounded corners\n// r is the radius of the rounded corners\nfloat sdArcRound( in vec3 p, in vec3 sca, in vec3", "\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat d = 0.0;\n\tfloat f = 0.0;\n\tfloat p = 0.0;\n\tfloat bias = 0.0001;\n\tfloat shadow = 1.0;\n\tfloat shadow_bias = 0.0001;\n\tfloat shadow_scale = 0.95;\n\tfloat shadow_decay = 0.98;\n\tfloat shadow_max = 0.9;\n\tfloat shadow_min = 0.1;\n\tfloat shadow_soft = 0.0;\n\tfloat shadow_hard = 0.0;\n\tfloat shadow_hard_bias = 0.0001;\n\tfloat shadow_hard_scale = 0.95;\n\tfloat shadow_hard_decay = 0.98;\n\tfloat shadow_hard_max = 0.9;\n\tfloat shadow_hard_min = 0.1;\n\tfloat shadow_hard_soft = 0.0;\n\tfloat shadow_hard_hard = 0.0;\n\tfloat shadow_hard_hard_bias = 0.0001;\n\tfloat shadow_hard_hard_scale = 0.95;\n\tfloat shadow_hard_hard_decay = 0.98;\n\tfloat shadow_hard_hard_max = 0.9;\n\tfloat shadow_hard_hard_min = 0.1;\n\tfloat shadow_hard_hard_soft = 0.0;\n\tfloat shadow_hard_hard_hard = 0.0;\n\tfloat shadow_hard_hard_hard_bias = 0.0001;\n\tfloat shadow_hard_hard_hard_scale = 0.95;\n\tfloat shadow_hard_hard_hard_decay = 0.98;\n\tfloat shadow_hard_hard_hard_max = 0.9;\n\tfloat shadow_hard_hard_hard_min = 0.1;\n\tfloat shadow_hard_hard_hard_soft = 0.0;\n\tfloat shadow_hard_hard_hard_hard = 0.0;\n\t", "\n\tvec3 n = vec3( 0.0 );\n\tn.x = sdSphere( pos + vec3( 0.001, 0.0, 0.0 ), time ) - sdSphere( pos - vec3( 0.001, 0.0, 0.0 ), time );\n\tn.y = sdSphere( pos + vec3( 0.0, 0.001, 0.0 ), time ) - sdSphere( pos - vec3( 0.0, 0.001, 0.0 ), time );\n\tn.z = sdSphere( pos + vec3( 0.0, 0.0, 0.001 ), time ) - sdSphere( pos - vec3( 0.0, 0.0, 0.001 ), time );\n\treturn normalize( n );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in float time )\n{\n\treturn length( p ) - 1.0;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn length( max( d, vec3( 0.0 ) ) ) + min( max( d.x, max( d.y, d.z ) ), 0.0 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( in vec3 p, in float R, in float r )\n{\n\tvec2 q = vec2( length( p.xz ) - R, p.y );\n\treturn length( q ) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h =", "\n\tfloat t = mint;\n\tfloat dt = 0.001;\n\tfloat t0 = t;\n\tfloat t1 = t + dt;\n\tfloat t2 = t + dt * 2.0;\n\tfloat t3 = t + dt * 3.0;\n\tfloat t4 = t + dt * 4.0;\n\tfloat t5 = t + dt * 5.0;\n\tfloat t6 = t + dt * 6.0;\n\tfloat t7 = t + dt * 7.0;\n\tfloat t8 = t + dt * 8.0;\n\tfloat t9 = t + dt * 9.0;\n\tfloat t10 = t + dt * 10.0;\n\tfloat t11 = t + dt * 11.0;\n\tfloat t12 = t + dt * 12.0;\n\tfloat t13 = t + dt * 13.0;\n\tfloat t14 = t + dt * 14.0;\n\tfloat t15 = t + dt * 15.0;\n\tfloat t16 = t + dt * 16.0;\n\tfloat t17 = t + dt * 17.0;\n\tfloat t18 = t + dt * 18.0;\n\tfloat t19 = t + dt * 19.0;\n\tfloat t20 = t + dt * 20.0;\n\tfloat t21 = t + dt * 21.0;\n\tfloat t22 = t + dt * 22.0;\n\tfloat t23 = t + dt * 23.0;\n\tfloat t24 = t + dt * 24.0;\n\tfloat t25 = t + dt * 25.0;\n\tfloat t26 = t + dt * 26.0;\n\tfloat t27 = t + dt * 27.0;\n\tfloat t28 = t + dt * 28.0;\n\tfloat t29 = t + dt * 29.0;\n\tfloat t30 = t + dt * 30.", "\n\tvec2 dp = dpdx + dpdy;\n\tvec2 dpdz = dpdy - dpdx;\n\tfloat d = dot( dp, dpdz );\n\tfloat e = dot( dp, dp );\n\tfloat f = dot( dpdz, dpdz );\n\tfloat g = dot( dp, dp ) * f - d * d;\n\tfloat h = e * f - d * d;\n\tfloat i = e * f - d * d;\n\tfloat j = e * f - d * d;\n\tfloat k = e * f - d * d;\n\tfloat l = e * f - d * d;\n\tfloat m = e * f - d * d;\n\tfloat n = e * f - d * d;\n\tfloat o = e * f - d * d;\n\tfloat p = e * f - d * d;\n\tfloat q = e * f - d * d;\n\tfloat r = e * f - d * d;\n\tfloat s = e * f - d * d;\n\tfloat t = e * f - d * d;\n\tfloat u = e * f - d * d;\n\tfloat v = e * f - d * d;\n\tfloat w = e * f - d * d;\n\tfloat x = e * f - d * d;\n\tfloat y = e * f - d * d;\n\tfloat z = e * f - d * d;\n\tfloat A = e * f - d * d;\n\tfloat B = e * f - d * d;\n\tfloat C = e * f - d * d;\n\tfloat D = e * f - d * d;\n\tfloat E = e * f - d * d;\n\tfloat F = e * f - d * d;\n\tfloat G = e * f - d * d;\n\tfloat H = e * f - d * d;\n\tfloat I = e * f - d * d;\n\tfloat J = e * f - d * d;\n\tfloat K = e * f - d * d;\n\tfloat L = e * f - d * d;\n\tfloat M = e * f - d * d;\n\tfloat N = e * f - d * d;", "\n\treturn k*x;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float offset )\n{\n\treturn k*x+offset;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float offset, in float scale )\n{\n\treturn k*x+offset;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float offset, in float scale, in float bias )\n{\n\treturn k*x+offset;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k, in float offset, in float scale, in float bias, in float power )\n{\n\treturn k*x+offset;\n}\n\n//\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase", "\n\tvec3 sample_dir = normalize(light_dir - sample_pos);\n\tvec3 sample_col = texture(sky_texture, sample_dir).rgb;\n\treturn mix(background_col, sample_col, 0.5);\n}\n\n/*\nThis is the main function that actually renders the planet.\n\nIt takes in the position of the camera, the position of the light, the radius of the planet,\nthe radius of the atmosphere, the color of the planet, the color of the atmosphere, the\ncolor of the sky, the color of the background, and the number of samples to take.\n\nThe number of samples is the number of rays that are cast from the camera to the atmosphere\nand the surface of the planet.\n\nThe more samples, the more accurate the rendering will be, but the more expensive it will be.\n*/\nvec3 render(vec3 camera_pos, vec3 light_pos, float planet_radius, float atmosphere_radius, vec3 planet_col, vec3 atmosphere_col, vec3 sky_col, vec3 background_col, int samples) {\n\tvec3 result = background_col;\n\tvec3 light_dir = normalize(light_pos - camera_pos);\n\tvec3 camera_dir = normalize(camera_pos);\n\tvec3 camera_normal = normalize(camera_pos);\n\tvec3 sample_pos = camera_pos;\n\tvec3 sample_normal = camera_normal;\n\tvec3 sample_col = planet_col;\n\tfloat sample_radius = planet_radius;\n\tfloat sample_atmosphere_radius = atmosphere_radius;\n\tfloat sample_atmosphere_height = 0.0;\n\tfloat sample_atmosphere_density = 0.0;\n\tfloat sample_atmosphere_opacity = 0.0;\n\tfloat sample_atmosphere_transmittance = 0.0;\n\tfloat sample_atmosphere_transmittance_height = 0.0;\n\tfloat sample_atmosphere_transmittance_density = 0.0;\n\tfloat sample_atmosphere_transmittance_opacity = 0.0;\n\tfloat sample_atmosphere_transmittance_transmittance = 0.0;\n\tfloat sample_", "\n\tvec3 color = vec3(0.0);\n\tfloat distance = 1000000.0;\n\tvec3 normal = vec3(0.0);\n\tvec3 hit_pos = vec3(0.0);\n\tvec3 hit_normal = vec3(0.0);\n\tvec3 hit_color = vec3(0.0);\n\tvec3 hit_dir = vec3(0.0);\n\tvec3 hit_pos_light = vec3(0.0);\n\tvec3 hit_normal_light = vec3(0.0);\n\tvec3 hit_color_light = vec3(0.0);\n\tvec3 hit_dir_light = vec3(0.0);\n\tvec3 hit_pos_light_2 = vec3(0.0);\n\tvec3 hit_normal_light_2 = vec3(0.0);\n\tvec3 hit_color_light_2 = vec3(0.0);\n\tvec3 hit_dir_light_2 = vec3(0.0);\n\tvec3 hit_pos_light_3 = vec3(0.0);\n\tvec3 hit_normal_light_3 = vec3(0.0);\n\tvec3 hit_color_light_3 = vec3(0.0);\n\tvec3 hit_dir_light_3 = vec3(0.0);\n\tvec3 hit_pos_light_4 = vec3(0.0);\n\tvec3 hit_normal_light_4 = vec3(0.0);\n\tvec3 hit_color_light_4 = vec3(0.0);\n\tvec3 hit_dir_light_4 = vec3(0.0);\n\tvec3 hit_pos_light_5 = vec3(0.0);\n\tvec3 hit_normal_light_5 = vec3(0.0);\n\tvec3 hit_color_light_5 = vec3(0.0);\n\tvec3 hit_dir_light_5 = vec3(0.0);\n\tvec3 hit_pos_light_6 = vec3(0.0);\n\tvec3 hit_normal_light_6 = vec3(0.0);", "\n\tvec2 ndc = coord * 2.0 - 1.0;\n\tvec3 camera_vector = vec3(ndc.x, ndc.y, -1.0);\n\tcamera_vector = normalize(camera_vector);\n\treturn camera_vector;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the ray direction of the current pixel\nthis function calculates it\n*/\nvec3 get_ray_direction(vec3 resolution, vec2 coord) {\n\tvec2 ndc = coord * 2.0 - 1.0;\n\tvec3 ray_direction = vec3(ndc.x, ndc.y, 1.0);\n\tray_direction = normalize(ray_direction);\n\treturn ray_direction;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the ray origin of the current pixel\nthis function calculates it\n*/\nvec3 get_ray_origin(vec3 resolution, vec2 coord) {\n\tvec2 ndc = coord * 2.0 - 1.0;\n\tvec3 ray_origin = vec3(ndc.x, ndc.y, 0.0);\n\treturn ray_origin;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the ray origin of the current pixel\nthis function calculates it\n*/\nvec3 get_ray_origin_2(vec3 resolution, vec2 coord) {\n\tvec2 ndc = coord * 2.0 - 1.0;\n\tvec3 ray_origin = vec3(ndc.x, ndc.y, 0.0);\n\treturn ray_origin;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the ray origin of the current pixel\nthis function calculates it\n*/\nvec3 get_ray_origin_3(vec3 resolution, vec2 coord) {\n\tvec2 ndc = coord * 2.0 - 1.0;\n\tvec3 ray_origin = vec3(ndc", "\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle2(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone2(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle3(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone3(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle4(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone4(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle5(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone5(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle6(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone6(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle7(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p, ra);\n\tfloat b = sdCone7(p, c, ra);\n\treturn a - b;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle8(vec3 p, vec2 c, float ra)\n{\n\tfloat a = sdSphere(p", "\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (material == 1) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 2) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 3) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 4) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 5) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 6) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 7) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 8) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 9) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 10) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 11) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 12) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 13) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 14) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 15) {\n        color = vec3(0.5, 0.5, 0.5);\n    } else if (material == 16) {\n        color = vec3(0.5", "\n\tswitch (material) {\n\t\tcase 0:\n\t\t\treturn 0.0;\n\t\tcase 1:\n\t\t\treturn 0.0;\n\t\tcase 2:\n\t\t\treturn 0.0;\n\t\tcase 3:\n\t\t\treturn 0.0;\n\t\tcase 4:\n\t\t\treturn 0.0;\n\t\tcase 5:\n\t\t\treturn 0.0;\n\t\tcase 6:\n\t\t\treturn 0.0;\n\t\tcase 7:\n\t\t\treturn 0.0;\n\t\tcase 8:\n\t\t\treturn 0.0;\n\t\tcase 9:\n\t\t\treturn 0.0;\n\t\tcase 10:\n\t\t\treturn 0.0;\n\t\tcase 11:\n\t\t\treturn 0.0;\n\t\tcase 12:\n\t\t\treturn 0.0;\n\t\tcase 13:\n\t\t\treturn 0.0;\n\t\tcase 14:\n\t\t\treturn 0.0;\n\t\tcase 15:\n\t\t\treturn 0.0;\n\t\tcase 16:\n\t\t\treturn 0.0;\n\t\tcase 17:\n\t\t\treturn 0.0;\n\t\tcase 18:\n\t\t\treturn 0.0;\n\t\tcase 19:\n\t\t\treturn 0.0;\n\t\tcase 20:\n\t\t\treturn 0.0;\n\t\tcase 21:\n\t\t\treturn 0.0;\n\t\tcase 22:\n\t\t\treturn 0.0;\n\t\tcase 23:\n\t\t\treturn 0.0;\n\t\tcase 24:\n\t\t\treturn 0.0;\n\t\tcase 25:\n\t\t\treturn 0.0;\n\t\tcase 26:\n\t\t\treturn 0.0;\n\t\tcase 27:\n\t\t\treturn 0.0;\n\t\tcase 28:\n\t\t\treturn 0.0;\n\t\tcase 29:\n\t\t\treturn 0.0;\n\t\tcase 30:\n\t\t\treturn 0.0;\n\t\tcase 31:\n\t\t\treturn 0.0;\n\t\tcase 32:\n\t\t\treturn 0.0;\n\t\tcase 33:\n\t\t\treturn 0.0;\n\t\tcase 3", "\n\treturn materials[material].refraction;\n}\n\n// Get index of refraction of a material.\nfloat get_material_reflection(int material) {\n\treturn materials[material].reflection;\n}\n\n// Get index of refraction of a material.\nfloat get_material_emission(int material) {\n\treturn materials[material].emission;\n}\n\n// Get index of refraction of a material.\nfloat get_material_shininess(int material) {\n\treturn materials[material].shininess;\n}\n\n// Get index of refraction of a material.\nfloat get_material_transparency(int material) {\n\treturn materials[material].transparency;\n}\n\n// Get index of refraction of a material.\nfloat get_material_ior(int material) {\n\treturn materials[material].ior;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index(int material) {\n\treturn materials[material].refraction_index;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_air(int material) {\n\treturn materials[material].refraction_index_of_air;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_water(int material) {\n\treturn materials[material].refraction_index_of_water;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_glass(int material) {\n\treturn materials[material].refraction_index_of_glass;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_diamond(int material) {\n\treturn materials[material].refraction_index_of_diamond;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_ice(int material) {\n\treturn materials[material].refraction_index_of_ice;\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction_index_of_water_ice(", "\n\treturn materials[material].opacity;\n}\n\n// Get the ambient color of a material.\n// The ambient color is the color that the material reflects\n// when there is no light.\n// The color is specified as a float array of size 3.\n// The first element is the red component, the second is the green\n// component, and the third is the blue component.\n// The values are in the range [0, 1].\nvoid get_material_ambient_color(int material, float *color) {\n\tcolor[0] = materials[material].ambient_color[0];\n\tcolor[1] = materials[material].ambient_color[1];\n\tcolor[2] = materials[material].ambient_color[2];\n}\n\n// Get the diffuse color of a material.\n// The diffuse color is the color that the material reflects\n// when there is light.\n// The color is specified as a float array of size 3.\n// The first element is the red component, the second is the green\n// component, and the third is the blue component.\n// The values are in the range [0, 1].\nvoid get_material_diffuse_color(int material, float *color) {\n\tcolor[0] = materials[material].diffuse_color[0];\n\tcolor[1] = materials[material].diffuse_color[1];\n\tcolor[2] = materials[material].diffuse_color[2];\n}\n\n// Get the specular color of a material.\n// The specular color is the color that the material reflects\n// when there is shininess.\n// The color is specified as a float array of size 3.\n// The first element is the red component, the second is the green\n// component, and the third is the blue component.\n// The values are in the range [0, 1].\nvoid get_material_specular_color(int material, float *color) {\n\tcolor[0] = materials[material].specular_color[0];\n\tcolor[1] = materials[material].specular_color[1];\n\tcolor[2] = materials[material].specular_color[2];\n}\n\n// Get the shininess of a material.\n// The shininess is the specular exponent of the", "\n    vec3 edge_a = tri_b - tri_a;\n    vec3 edge_b = tri_c - tri_a;\n    vec3 pvec = cross(line_b - line_a, edge_b);\n    float det = dot(edge_a, pvec);\n    if (det == 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float inv_det = 1.0 / det;\n    vec3 tvec = line_a - tri_a;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 qvec = cross(tvec, edge_a);\n    float v = dot(line_b - line_a, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float t = dot(edge_b, qvec) * inv_det;\n    return vec3(1.0, u, v);\n}\n\n// Determine whether a line intersects a plane.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_plane(vec3 line_a, vec3 line_b, vec3 plane_p, vec3 plane_n) {\n    float denom = dot(plane_n, line_b - line_a);\n    if (abs(denom) < 0.00001) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float t = dot(plane_p - line_a, plane_n) / denom;\n    if (t < 0.0 || t > 1.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return vec3(1.0, t, 0.0);\n}\n\n// Determine whether a line intersect", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return normalize(cross(ab, ac));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 ad = tri_d - tri_a;\n    return normalize(cross(ab, ac) + cross(ac, ad) + cross(ad, ab));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c, vec3 tri_d, vec3 tri_e) {\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    vec3 ad = tri_d - tri_a;\n    vec3 ae = tri_e - tri_a;\n    return normalize(cross(ab, ac) + cross(ac, ad) + cross(ad, ab) + cross(ae, ab));\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_", "\n    vec3 zaxis = normalize(camera_position - camera_target);\n    vec3 xaxis = normalize(cross(vec3(0.0, 1.0, 0.0), zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n\n    mat3 rotation_matrix = mat3(\n        xaxis.x, yaxis.x, zaxis.x,\n        xaxis.y, yaxis.y, zaxis.y,\n        xaxis.z, yaxis.z, zaxis.z\n    );\n\n    return rotation_matrix;\n}\n\n// Generate a perspective projection matrix based on a field of view,\n// aspect ratio, and near and far clipping planes.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect_ratio, float near_plane, float far_plane) {\n    float f = 1.0 / tan(fov * 0.5);\n    float range = far_plane - near_plane;\n\n    mat4 perspective_matrix = mat4(\n        f / aspect_ratio, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, -(far_plane + near_plane) / range, -1.0,\n        0.0, 0.0, -2.0 * near_plane * far_plane / range, 0.0\n    );\n\n    return perspective_matrix;\n}\n\n// Generate a orthographic projection matrix based on a left, right,\n// bottom, top, near, and far clipping planes.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\nmat4 orthographic_matrix(float left, float right, float bottom, float top, float near_plane, float far_plane) {\n    float range = far_plane - near_plane;\n\n    mat4 orthographic_matrix = mat4(\n        2.0 / (right - left), 0.0, 0.0, ", "\n    cast_ray_result result;\n    result.distance = std::numeric_limits<float>::max();\n    for (auto &triangle : triangles) {\n        cast_ray_result local_result = triangle.cast_ray(ray_origin, ray_target);\n        if (local_result.distance < result.distance) {\n            result = local_result;\n        }\n    }\n    return result;\n}\n\n// Render the scene.\nvoid render() {\n    // Clear the color buffer.\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Set the viewport to the size of the window.\n    glViewport(0, 0, window_width, window_height);\n\n    // Set the camera.\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(60.0, (float) window_width / (float) window_height, 0.1, 1000.0);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(camera_position.x, camera_position.y, camera_position.z,\n              camera_position.x + camera_direction.x, camera_position.y + camera_direction.y,\n              camera_position.z + camera_direction.z, 0.0, 1.0, 0.0);\n\n    // Draw the triangles.\n    for (auto &triangle : triangles) {\n        triangle.draw();\n    }\n\n    // Swap the buffers.\n    glutSwapBuffers();\n}\n\n// Handle keyboard input.\nvoid keyboard(unsigned char key, int x, int y) {\n    switch (key) {\n        case 'w':\n            camera_position += camera_direction * 0.1;\n            break;\n        case's':\n            camera_position -= camera_direction * 0.1;\n            break;\n        case 'a':\n            camera_position -= cross(camera_direction, camera_up) * 0.1;\n            break;\n        case 'd':\n            camera_position += cross(camera_direction, camera_up) * 0.1;\n            break;\n        case 'q':\n            camera_position -= camera_up * 0.1;\n            break;\n        case 'e':\n            camera_position += camera_up * 0.1;\n            break;\n        case '", "\n    float t = 0.0;\n    float t_min = 0.0;\n    float t_max = 1000000.0;\n    float t_hit = 1000000.0;\n    vec3 hit_point;\n    vec3 hit_normal;\n    vec3 hit_color;\n    vec3 hit_tex_coord;\n    vec3 hit_tex_color;\n    int hit_material_index = -1;\n    int hit_object_index = -1;\n    int hit_light_index = -1;\n    int hit_light_type = -1;\n    int hit_light_num_samples = -1;\n    int hit_light_num_samples_remaining = -1;\n    int hit_light_num_samples_total = -1;\n    int hit_light_num_samples_done = -1;\n    int hit_light_num_samples_done_total = -1;\n    int hit_light_num_samples_done_remaining = -1;\n    int hit_light_num_samples_done_this_frame = -1;\n    int hit_light_num_samples_done_this_frame_total = -1;\n    int hit_light_num_samples_done_this_frame_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max = -1;\n    int hit_light_num_samples_done_this_frame_max_total = -1;\n    int hit_light_num_samples_done_this_frame_max_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_total = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_remaining = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_max = -1;\n    int hit_light_num_samples_done_this_frame_max_this_frame_max_total = -1;\n    int hit_light_num_samples_done_this_frame_max_this_", "\n\treturn fract( sin( x ) * 43758.5453123 );\n}\n\n// 2D noise\nfloat noise( in vec2 x )\n{\n\tvec2 i = floor( x );\n\tvec2 f = fract( x );\n\n\tfloat a = bnoise( i.x + i.y * 57.0 );\n\tfloat b = bnoise( i.x + 1.0 + i.y * 57.0 );\n\tfloat c = bnoise( i.x + i.y * 57.0 + 1.0 );\n\tfloat d = bnoise( i.x + 1.0 + i.y * 57.0 + 1.0 );\n\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;\n}\n\n// 3D noise\nfloat noise( in vec3 x )\n{\n\tvec3 i = floor( x );\n\tvec3 f = fract( x );\n\n\tfloat a = bnoise( i.x + i.y * 57.0 + i.z * 289.0 );\n\tfloat b = bnoise( i.x + i.y * 57.0 + 1.0 + i.z * 289.0 );\n\tfloat c = bnoise( i.x + 1.0 + i.y * 57.0 + i.z * 289.0 );\n\tfloat d = bnoise( i.x + 1.0 + i.y * 57.0 + 1.0 + i.z * 289.0 );\n\n\tvec3 u = f * f * ( 3.0 - 2.0 * f );\n\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;", "\n\tfloat f = fract( p );\n\tf = f * f * ( 3.0 - 2.0 * f );\n\treturn f;\n}\n\n// Simplex gradient noise\nfloat snoise( in vec2 v )\n{\n\tconst vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\t\t0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\t\t0.577350269189626,  // 2.0/3.0\n\t\t0.024390243902439 ); // 1.0/40.0\n\t// First corner\n\tvec2 i  = floor( v + dot( v, C.yy ) );\n\tvec2 x0 = v - i + dot( i, C.xx );\n\n\t// Other corners\n\tvec2 i1;\n\t//i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n\t//i1.y = 1.0 - i1.x;\n\ti1 = ( x0.x > x0.y )? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\n\t// x1 = x0 - i1 + 1.0 * C.xx ;\n\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\n\tvec4 x12 = x0.xyxy + C.xxzz;\n\tx12.xy -= i1;\n\n\t// Permutations\n\ti = mod289( i );\n\tvec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n\t\t+ i.x + vec3(", "\n    n = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return (float) n / 1073741824.0;\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    n = (n + 0.000000001) * 404743.0;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return (float) n / 1073741824.0;\n}\n\n// double hash copied from Hugo Elias\nfloat hash( double n ) \n{\n    n = (n + 0.000000001) * 404743.0;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return (float) n / 1073741824.0;\n}\n\n// string hash copied from Hugo Elias\nfloat hash( string s ) \n{\n    int n = 0;\n    for (int i = 0; i < s.length(); i++) {\n        n = (n << 13) ^ (n * 7 + s[i]);\n    }\n    n = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return (float) n / 1073741824.0;\n}\n\n// vector hash copied from Hugo Elias\nfloat hash( vector<int> v ) \n{\n    int n = 0;\n    for (int i = 0; i < v.size(); i++) {\n        n = (n << 13) ^ (n *", "\n\tfloat f = fract( p * 0.1136 );\n\tf = f * f + f * 0.3660;\n\treturn f * f * f * f * f;\n}\n\n// gradient noise\nfloat gnoise( in vec2 p )\n{\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\n\tfloat a = gnoise( i );\n\tfloat b = gnoise( i + vec2( 1.0, 0.0 ) );\n\tfloat c = gnoise( i + vec2( 0.0, 1.0 ) );\n\tfloat d = gnoise( i + vec2( 1.0, 1.0 ) );\n\n\tvec2 u = f * f * ( 3.0 - 2.0 * f );\n\n\treturn mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;\n}\n\n// gradient noise\nfloat gnoise( in vec3 p )\n{\n\tvec3 i = floor( p );\n\tvec3 f = fract( p );\n\n\tfloat a = gnoise( i );\n\tfloat b = gnoise( i + vec3( 1.0, 0.0, 0.0 ) );\n\tfloat c = gnoise( i + vec3( 0.0, 1.0, 0.0 ) );\n\tfloat d = gnoise( i + vec3( 1.0, 1.0, 0.0 ) );\n\tfloat e = gnoise( i + vec3( 0.0, 0.0, 1.0 ) );\n\tfloat f2 = gnoise( i + vec3( 1.0, 0.0, 1.0 ) );\n\tfloat g = gnoise( i + vec3( 0.0, 1.0, 1.0 ) );\n\tfloat h = gnoise( i + vec3( 1.0, 1.0, 1.0 ) );\n\n\tvec4 u = f * f * ( vec4( ", "\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat b = 0.0;\n\tfloat n = 6.0;\n\tfor( float i = 0.0; i < n; i++ )\n\t{\n\t\tv += a * noise( x * f, G );\n\t\tf *= 2.0;\n\t\ta *= b;\n\t}\n\treturn v;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat b = 0.0;\n\tfloat n = 6.0;\n\tfor( float i = 0.0; i < n; i++ )\n\t{\n\t\tv += a * noise( x * f, G );\n\t\tf *= 2.0;\n\t\ta *= b;\n\t}\n\treturn v;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G )\n{\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat b = 0.0;\n\tfloat n = 6.0;\n\tfor( float i = 0.0; i < n; i++ )\n\t{\n\t\tv += a * noise( x * f, G );\n\t\tf *= 2.0;\n\t\ta *= b;\n\t}\n\treturn v;\n}\n\n// fbm\nfloat fbm( in vec4 x, in float G )\n{\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n\tfloat a = 0.5;\n\tfloat b = 0.0;\n\tfloat n = 6.0;\n\tfor( float i = 0.0; i < n; i++ )\n\t{\n\t\tv += a * noise( x * f, G );\n\t\tf *= 2.0;\n\t\ta *= b;\n\t}\n\treturn v;\n}\n\n// fbm", "\n\t// Compute the quadratic polynomial coefficients\n\tvec3 a = vec3( 1.0, 4.0 * p.y, 2.0 * p.y * p.y + 2.0 * p.x * p.x );\n\tvec3 b = vec3( 0.0, 4.0 * p.z, 2.0 * p.z * p.z + 2.0 * p.x * p.x );\n\tvec3 c = vec3( 0.0, 4.0 * p.w, 2.0 * p.w * p.w + 2.0 * p.x * p.x );\n\n\t// Solve the quadratic equation\n\tvec3 d = b * b - 4.0 * a * c;\n\tvec3 s = sqrt( d );\n\tvec3 q = ( b < 0.0 )? ( -0.5 * ( b - s ) ) : ( -0.5 * ( b + s ) );\n\tvec3 x0 = q / a;\n\tvec3 x1 = c / q;\n\n\t// Return the color of the closest solution\n\treturn ( abs( x0.x ) < abs( x1.x ) )? ( x0 ) : ( x1 );\n}\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec3 getColor( in vec3 p )\n{\n\t// Compute the quadratic polynomial coefficients\n\tvec3 a = vec3( 1.0, 4.0 * p.y, 2.0 * p.y * p.y + 2.0 * p.x * p.x );\n\tvec3 b = vec3( 0.0, 4.0 * p.z, 2.0 * p.z * p.z + 2.0 * p.x * p.x );\n\tvec3 c = vec3( 0.0, 4.0 * p.w, 2.0 * p.w * p.w + 2.0 * p.x * p.x );\n\n\t// Solve the quadratic equation\n\tvec3 d = b * b -", "\n\tvec3 p = pb;\n\tp.x = p.x * 2.0 - 1.0;\n\tp.y = p.y * 2.0 - 1.0;\n\tp.z = p.z * 2.0 - 1.0;\n\tvec3 c = vec3(0.0);\n\tc.x = p.x * p.x * p.x;\n\tc.y = p.y * p.y * p.y;\n\tc.z = p.z * p.z * p.z;\n\tvec3 d = vec3(0.0);\n\td.x = p.x * p.x;\n\td.y = p.y * p.y;\n\td.z = p.z * p.z;\n\tvec3 e = vec3(0.0);\n\te.x = p.x * p.y * p.z;\n\te.y = p.x * p.y;\n\te.z = p.x * p.z;\n\tvec3 f = vec3(0.0);\n\tf.x = p.x;\n\tf.y = p.y;\n\tf.z = p.z;\n\tvec3 g = vec3(0.0);\n\tg.x = 1.0;\n\tg.y = 1.0;\n\tg.z = 1.0;\n\tvec3 h = vec3(0.0);\n\th.x = -1.0;\n\th.y = -1.0;\n\th.z = -1.0;\n\tvec3 a = vec3(0.0);\n\ta.x = 1.0;\n\ta.y = 1.0;\n\ta.z = 1.0;\n\tvec3 b = vec3(0.0);\n\tb.x = 1.0;\n\tb.y = 1.0;\n\tb.z = 1.0;\n\tvec3 c = vec3(0.0);\n\tc.x = 1.0;\n\tc.y = 1.0;\n", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (cen - ro) * invdir;\n\tvec3 tmax = (cen + rad - ro) * invdir;\n\tif (all(lessThan(tmin, tmax))) {\n\t\tfloat t1 = max(max(tmin.x, tmin.y), tmin.z);\n\t\tfloat t2 = min(min(tmax.x, tmax.y), tmax.z);\n\t\treturn vec4(t1, t2);\n\t} else {\n\t\treturn vec4(0.0);\n\t}\n}\n\n// http://iquilezles.org/www/articles/rayboxintersect/rayboxintersect.htm\nvec4 rayBoxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (cen - ro) * invdir;\n\tvec3 tmax = (cen + rad - ro) * invdir;\n\tif (all(lessThan(tmin, tmax))) {\n\t\tfloat t1 = max(max(tmin.x, tmin.y), tmin.z);\n\t\tfloat t2 = min(min(tmax.x, tmax.y), tmax.z);\n\t\treturn vec4(t1, t2);\n\t} else {\n\t\treturn vec4(0.0);\n\t}\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat boxDistance( in vec3 p, in vec3 cen, in vec3 rad ) \n{\n\tvec3 d = abs(p - cen) - rad;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat boxDistance( in vec3 p, in vec3 cen, in vec3 rad, in vec3 n ) \n{\n\t", "\n\tvec3 p = abs(rd) - cen;\n\tvec3 b = clamp( p, 0.0, rad );\n\treturn min( max( b.x, max( b.y, b.z ) ), 0.0 ) + length( max( p - rad, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 p = abs(rd) - cen;\n\tvec3 b = clamp( p, 0.0, rad );\n\treturn min( max( b.x, max( b.y, b.z ) ), 0.0 ) + length( max( p - rad, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n\treturn length( ro - cen ) - rad;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torus( in vec3 ro, in vec3 rd, in vec3 cen, in vec2 rad ) \n{\n\tvec2 q = vec2( length( ro - cen ) - rad.x, length( project( ro - cen, rd ) - rad.y ) );\n\treturn min( max( q.x, q.y ), 0.0 ) + length( max( q - rad, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat ellipsoid( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 p = abs( project( ro - cen, rd ) ) - rad;\n\treturn min( max( p.x, max( p.y, p.z ) ), 0.0 ) + length( max( p, 0.0 ) );\n", "\n    float t = mint;\n    float d = 0.0;\n    float s = 0.0;\n    float f = 0.0;\n    float p = 0.0;\n    float m = 0.0;\n    float e = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40", " seed = (seed * 1664525 + 1013904223) % 2147483647; return seed / 2147483647.0; }\nfloat randn(void) { return sqrt(-2.0 * log(rand())) * cos(2.0 * M_PI * rand()); }\nfloat randn(float mean, float stddev) { return mean + stddev * randn(); }\n\n// 3D vector\nstruct vec3 { float x, y, z; };\nvec3 operator+(vec3 a, vec3 b) { return (vec3){a.x + b.x, a.y + b.y, a.z + b.z}; }\nvec3 operator-(vec3 a, vec3 b) { return (vec3){a.x - b.x, a.y - b.y, a.z - b.z}; }\nvec3 operator*(vec3 a, float b) { return (vec3){a.x * b, a.y * b, a.z * b}; }\nvec3 operator/(vec3 a, float b) { return (vec3){a.x / b, a.y / b, a.z / b}; }\nvec3 operator*(float a, vec3 b) { return (vec3){a * b.x, a * b.y, a * b.z}; }\nvec3 operator/(vec3 a, vec3 b) { return (vec3){a.x / b.x, a.y / b.y, a.z / b.z}; }\nvec3 operator*(vec3 a, vec3 b) { return (vec3){a.x * b.x, a.y * b.y, a.z * b.z}; }\nvec3 operator/(vec3 a, vec3 b) { return (vec3){a.x / b.x, a.y / b.y, a.z / b.z}; }\nvec3 operator-(vec3 a) { return (vec3){-a.x, -a.y, -a.z}; }\nfloat dot(vec3 a, vec3 b) { return a.x", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec3 g )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f + g );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec3 g, in vec3 h )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f + g + h );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 e, in vec3 f, in vec3 g, in vec3 h", "\n\tfloat d = length(p);\n\tfloat a = length(vec2(p.x,p.y));\n\tfloat b = length(vec2(p.x,p.z));\n\tfloat c = length(vec2(p.y,p.z));\n\tfloat s = (a+b+c)/2.0;\n\tfloat A = sqrt(s*(s-a)*(s-b)*(s-c));\n\tfloat R = A/s;\n\tfloat r = sqrt(pow(a,2)+pow(b,2)-2*a*b*cos(ra));\n\tfloat h2 = h/2.0;\n\tfloat d2 = d-h2;\n\tfloat d3 = d+h2;\n\tfloat d4 = d-h2*cos(ra);\n\tfloat d5 = d+h2*cos(ra);\n\tfloat d6 = d-h2*cos(ra)*cos(ra);\n\tfloat d7 = d+h2*cos(ra)*cos(ra);\n\tfloat d8 = d-h2*cos(ra)*cos(ra)*cos(ra);\n\tfloat d9 = d+h2*cos(ra)*cos(ra)*cos(ra);\n\tfloat d10 = d-h2*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d11 = d+h2*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d12 = d-h2*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d13 = d+h2*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d14 = d-h2*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d15 = d+h2*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra);\n\tfloat d16 = d-h2*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(ra)*cos(", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 ap = a + ba * h - p;\n\tfloat d = length( ap );\n\tfloat x = d - r;\n\tfloat y = length( ap + band * normalize( ba ) );\n\tfloat z = length( ba );\n\tfloat w = length( p - a );\n\treturn vec4( x, y, z, w );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pbSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n\tvec2 pb = p - b;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pb, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 bp = b + ba * h - p;\n\tfloat d = length( bp );\n\tfloat x = d - r;\n\tfloat y = length( bp + band * normalize( ba ) );\n\tfloat z = length( ba );\n\tfloat w = length( p - b );\n\treturn vec4( x, y, z, w );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pcSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec2 ap = a + ba * h - p;\n\tfloat d = length( ap );\n\tfloat x = d - r;\n\tfloat y = length( ap + band * normalize( ba ) );\n\tfloat z = length( ba );\n\tfloat w = length( p - a );\n\treturn vec4(", "\n    vec2 d = abs(p) - b;\n    vec2 q = clamp(d, 0.0, r);\n    float c = length(d - q);\n    float h = clamp(s - c, 0.0, r);\n    return vec4(q, h, c, 0.0);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pbBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 d = abs(p) - b;\n    vec2 q = clamp(d, 0.0, r);\n    float c = length(d - q);\n    float h = clamp(s - c, 0.0, r);\n    return vec4(q, h, c, 0.0);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pcBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 d = abs(p) - b;\n    vec2 q = clamp(d, 0.0, r);\n    float c = length(d - q);\n    float h = clamp(s - c, 0.0, r);\n    return vec4(q, h, c, 0.0);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pdBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 d = abs(p) - b;\n    vec2 q = clamp(d, 0.0, r);\n    float c = length(d - q);\n    float h = clamp(s - c, 0.0, r);\n    return vec4(q, h, c, 0.0);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 pdBox( in vec", "\nvec3 q = vec3( p, 0.0 );\nq.xy -= b.xy;\nq.x = abs( q.x ) - b.x;\nq.y = abs( q.y ) - b.y;\nvec3 r = vec3( step( q.xy, vec2(0.0) ), 0.0 );\nr.z = 1.0 - r.x - r.y;\nr.xy *= r.z;\nreturn r;\n}\n\n// 2D signed distance function for a circle\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\nvec2 q = p;\nq -= 0.5;\nq *= 2.0;\nfloat d = length( q ) - r;\nvec3 r = vec3( d, 0.0, 0.0 );\nr.y = -q.x / length( q );\nr.z = -q.y / length( q );\nr.yz *= r.x;\nreturn r;\n}\n\n// 2D signed distance function for a polygon\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPolygon( in vec2 p, in vec2[] v )\n{\nvec3 r = vec3( 1e10 );\nfor( int i = 0; i < v.length; i++ )\n{\nvec2 a = v[i];\nvec2 b = v[(i+1) % v.length];\nvec2 d = b - a;\nvec2 e = p - a;\nfloat c = dot( e, d );\nif( c <= 0.0 )\n{\nfloat d = length( e );\nif( d < r", "\n\tvec2 d = abs(p) - r;\n\tfloat x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\tfloat y = length(max(d,0.0));\n\tfloat z = y + band;\n\tfloat w = length(p);\n\treturn vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale ) \n{\n\tvec2 d = abs(p) - r;\n\tfloat x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\tfloat y = length(max(d,0.0));\n\tfloat z = y + band;\n\tfloat w = length(p) * scale;\n\treturn vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale, float offset ) \n{\n\tvec2 d = abs(p) - r;\n\tfloat x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\tfloat y = length(max(d,0.0));\n\tfloat z = y + band;\n\tfloat w = length(p) * scale + offset;\n\treturn vec4(x,y,z,w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band, float scale, float offset, float bias ) \n{\n\tvec2 d = abs(p) - r;\n\tfloat x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\tfloat", "\n\tfloat h = 0.0;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tfloat d = sdLine( p, verts[i], verts[(i+1)%5] );\n\t\th = max( h, d );\n\t}\n\treturn h;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h ) \n{\n\tfloat d = 0.0;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tfloat d1 = sdLine( p, verts[i], verts[(i+1)%5] );\n\t\td = max( d, d1 );\n\t}\n\treturn d - h;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h, in float s ) \n{\n\tfloat d = 0.0;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tfloat d1 = sdLine( p, verts[i], verts[(i+1)%5] );\n\t\td = max( d, d1 );\n\t}\n\treturn d - h - s;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h, in float s, in float t ) \n{\n\tfloat d = 0.0;\n\tfor( int i = 0; i < 5; i++ ) \n\t{\n\t\tfloat d1 = sdLine( p, verts[i], verts[(i+1)%5] );\n\t\td = max( d, d1 );\n\t}\n\treturn d - h - s - t;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float h, in float s, in", "\n\tvec4 res = vec4(0.0);\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat w = 0.0;\n\tfloat d = 0.0;\n\tfloat l = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d1 = 0.0;\n\tfloat d2 = 0.0;\n\tfloat d3 = 0.0;\n\tfloat d4 = 0.0;\n\tfloat d5 = 0.0;\n\tfloat d6 = 0.0;\n\tfloat d7 = 0.0;\n\tfloat d8 = 0.0;\n\tfloat d9 = 0.0;\n\tfloat d10 = 0.0;\n\tfloat d11 = 0.0;\n\tfloat d12 = 0.0;\n\tfloat d13 = 0.0;\n\tfloat d14 = 0.0;\n\tfloat d15 = 0.0;\n\tfloat d16 = 0.0;\n\tfloat d17 = 0.0;\n\tfloat d18 = 0.0;\n\tfloat d19 = 0.0;\n\tfloat d20 = 0.0;\n\tfloat d21 = 0.0;\n\tfloat d22 = 0.0;\n\tfloat d23 = 0.0;\n\tfloat d24 = 0.0;\n\tfloat d25 = 0.0;\n\tfloat d26 = 0.0;\n\tfloat d27 = 0.0;\n\tfloat d28 = 0.0;\n\tfloat d29 = 0.0;\n\tfloat d30 = 0.0;\n\tfloat d31 = 0.0;\n\tfloat d32 = 0.0;\n\tfloat d33 = 0.0;\n\tfloat d34 = 0.0;\n\tfloat d35 = 0.", "\nvec2 d = b - a;\nvec2 f = p - a;\nfloat t = clamp( dot( f, d ) / dot( d, d ), 0.0, 1.0 );\nvec2 h = a + t * d;\nvec2 r = p - h;\nfloat d2 = dot( r, r );\nfloat k = 1.0 / sqrt( d2 );\nreturn vec3( d2, k * dot( r, d ), k * dot( r, cross( d, d ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\nvec2 f = p - c;\nfloat d2 = dot( f, f );\nfloat k = 1.0 / sqrt( d2 );\nreturn vec3( d2 - r * r, k * dot( f, vec2( -f.y, f.x ) ), k * dot( f, cross( f, vec2( -f.y, f.x ) ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\nvec2 f = p - c;\nvec2 d = f / r;\nfloat d2 = dot( d, d );\nfloat k = 1.0 / sqrt( d2 );\nreturn vec3( d2 - 1.0, k * dot( d, vec2( -d.y, d.x ) ), k * dot( d, cross( d, vec2( -d.y, d.x ) ) ) );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/", "\n\tvec3 q = vec3( p, 0.0 );\n\tfloat d = length( q );\n\tfloat t = atan( q.y, q.x );\n\tfloat s = sign( q.x );\n\tfloat a = s * ( 1.0 - r ) * t;\n\tfloat b = s * ( 1.0 - r ) * ( 1.0 - t );\n\tfloat c = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat d = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat e = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat f = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat g = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat h = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat i = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat j = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat k = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat l = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat m = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat n = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat o = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat p = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat q = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat r = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat s = s * ( 1.0 - r ) * ( 1.0 + t );\n\tfloat t = s * ( 1.", "\n\t// Find the two tangents to the conic X from point p.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t// normal to the plane.\n\t// The conic is a quadratic in the plane containing p and the\n\t//", "\n\tif (b.x == 0) b.x += 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 a)\n{\n\treturn RotateX(RotateY(RotateZ(p, a.z), a.y), a.x);\n}\n\n// Camera\nvec3 CameraPos = vec3(0, 0, 0);\nvec3 CameraDir = vec3(0, 0, -1);\nvec3 CameraUp = vec3(0, 1, 0);\n\n// Light\nvec3 LightPos = vec3(0, 0, 0);\nvec3 LightColor = vec3(1, 1, 1);\n\n// Material\nvec3 MaterialColor = vec3(1, 1, 1);\nfloat MaterialShininess = 100;\n\n// Texture\nvec3 TextureColor = vec3(1, 1, 1);\n\n// Model\nvec3 ModelPos = vec3(0, 0, 0);\nvec3 ModelScale = vec3(1, 1, 1);\nvec3 ModelRot = vec3(0, 0, 0);\n\n// Viewport\nint ViewportWidth = 100;\nint ViewportHeight = 100;\n\n// Projection\nfloat ProjectionFov = 45;\nfloat ProjectionNear = 0.1;\nfloat ProjectionFar = 100;\n\n// Screen\nint ScreenWidth = 1", "\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\treturn 1.0f - (x - R) * (x - R) / (2.0f * R * R);\n\telse\n\t\treturn 0.0f;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float falloff)\n{\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\treturn 1.0f - (x - R) * (x - R) / (2.0f * R * R);\n\telse\n\t\treturn 0.0f;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float falloff, float falloff2)\n{\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\treturn 1.0f - (x - R) * (x - R) / (2.0f * R * R);\n\telse\n\t\treturn 0.0f;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float falloff, float falloff2, float falloff3)\n{\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\treturn 1.0f - (x - R) * (x - R) / (2.0f * R * R);\n\telse\n\t\treturn 0.0f;\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R, float falloff, float falloff2, float falloff3, float falloff4)\n{\n\tif (x < R)\n\t\treturn 1.0f;\n\telse if (x < 2.0f * R)\n\t\t", "\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffL(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffM(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffN(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffO(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffP(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffQ(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffR(float e, float R)\n{\n\treturn 1.0f / (1.0f + e * e / (R * R));\n}\n\n// Computes the global lipschitz bound of the falloff function\n", "\n\tfloat k = 0.0f;\n\tfloat d = b - a;\n\tfloat r = R * R;\n\tfloat e2 = e * e;\n\tif (d!= 0.0f)\n\t{\n\t\tk = (d * d) / (4.0f * r * e2);\n\t}\n\treturn k;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffL(float a, float b, float R, float e)\n{\n\tfloat l = 0.0f;\n\tfloat d = b - a;\n\tfloat r = R * R;\n\tfloat e2 = e * e;\n\tif (d!= 0.0f)\n\t{\n\t\tl = (d * d) / (2.0f * r * e2);\n\t}\n\treturn l;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffM(float a, float b, float R, float e)\n{\n\tfloat m = 0.0f;\n\tfloat d = b - a;\n\tfloat r = R * R;\n\tfloat e2 = e * e;\n\tif (d!= 0.0f)\n\t{\n\t\tm = (d * d) / (r * e2);\n\t}\n\treturn m;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffN(float a, float b, float R, float e)\n{\n\tfloat n = 0.0f;\n\tfloat d = b - a;\n\tfloat r = R * R;\n\tfloat e2 = e * e;\n\tif (d!= 0.0f)\n\t{\n\t\tn = (d * d) / (r * e2);\n\t}", "\n    float d = distance(p, c);\n    return e * (1.0 - d / R);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e, float k)\n{\n    float d = distance(p, c);\n    return e * (1.0 - d / R) * pow(d / R, k);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e, float k, float a)\n{\n    float d = distance(p, c);\n    return e * (1.0 - d / R) * pow(d / R, k) * pow(d / R, a);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e, float k, float a, float b)\n{\n    float d = distance(p, c);\n    return e * (1.0 - d / R) * pow(d / R, k) * pow(d / R, a) * pow(d / R, b);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e, float k, float a, float b, float m)\n{\n    float d = distance(p, c);\n    return e * (1.0 - d / R) * pow(d / R, k) * pow(d / R, a) * pow(d / R, b) * pow(d / R, m);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e, float k, float a, float b, float m, float n)\n{\n    float d = distance(p, c);\n    return", "\n    float d = length(a - b);\n    float l = length(c - a);\n    float r = length(c - b);\n    float t = length(c - (a + b) / 2.0f);\n    float s = length(c - (a + b) / 2.0f + (a - b) / 2.0f);\n    float u = length(c - (a + b) / 2.0f - (a - b) / 2.0f);\n    float v = length(c - (a + b) / 2.0f + (a - b) / 2.0f);\n    float w = length(c - (a + b) / 2.0f - (a - b) / 2.0f);\n    float x = length(c - (a + b) / 2.0f + (a - b) / 2.0f);\n    float y = length(c - (a + b) / 2.0f - (a - b) / 2.0f);\n    float z = length(c - (a + b) / 2.0f);\n    float A = (l + r) / 2.0f;\n    float B = (t + s) / 2.0f;\n    float C = (u + v) / 2.0f;\n    float D = (w + x) / 2.0f;\n    float E = (y + z) / 2.0f;\n    float F = (A + B) / 2.0f;\n    float G = (C + D) / 2.0f;\n    float H = (E + F) / 2.0f;\n    float I = (G + H) / 2.0f;\n    float J = (A + C) / 2.0f;\n    float K = (B + D) / 2.0f;\n    float L = (E + G) / 2.0f;\n    float M = (F + H) / 2.0f;\n    float N = (J + K) / 2.0f;\n    float O = (L + M) / 2.0f;\n    float P = (N + O) /", "\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x = 1.0;\n\tfloat y = 1.0;\n\tfloat z = 1.0;\n\tfloat A = 1.0;\n\tfloat B = 1.0;\n\tfloat C = 1.0;\n\tfloat D = 1.0;\n\tfloat E = 1.0;\n\tfloat F = 1.0;\n\tfloat G = 1.0;\n\tfloat H = 1.0;\n\tfloat I = 1.0;\n\tfloat J = 1.0;\n\tfloat K = 1.0;\n\tfloat L = 1.0;\n\tfloat M = 1.0;\n\tfloat N = 1.0;\n\tfloat O = 1.0;\n\tfloat P = 1.0;\n\tfloat Q = 1.0;\n\tfloat R = 1.0;\n\tfloat S = 1.0;\n\tfloat T = 1.0;\n\tfloat U = 1.0;\n\tfloat V = 1.0;\n\tfloat W = 1.0;\n\tfloat X = 1.0;\n\tfloat Y = 1.0;\n\t", "\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// L root\nfloat LSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// M root\nfloat MSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// N root\nfloat NSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// O root\nfloat OSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// P root\nfloat PSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// Q root\nfloat QSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// R root\nfloat RSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.y * a.y);\n}\n\n// S root\nfloat SSegment(vec3 a, vec3 b)\n{\n\treturn (a.x * b.y - a.y * b.x) / (a.x * a.x + a.", "\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n)\n{\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in vec3 f)\n{\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in vec3 f, in vec3 u)\n{\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in vec3 f, in vec3 u, in vec3 v)\n{\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn.z = fwidth(p.z);\n\treturn normalize(n);\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p, in vec3 n, in vec3 f, in vec3 u, in vec3 v, in vec3 w)\n{\n\tvec3 n = vec3(0.0);\n\tn.x = fwidth(p.x);\n\tn.y = fwidth(p.y);\n\tn", "\n\t// Sphere tracing\n\tfloat t = 0.0;\n\tvec3 p = o;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t// Check if we hit the sphere\n\t\tif (length(p - sphere.position) < sphere.radius)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\n\t\t// Move along the ray\n\t\tt += length(u);\n\t\tp += u;\n\t}\n\n\t// We didn't hit the sphere\n\th = false;\n\ts = 0;\n\treturn t;\n}\n\n// Trace ray using ray tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat RayTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n\t// Ray tracing\n\tfloat t = 0.0;\n\tvec3 p = o;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t// Check if we hit the plane\n\t\tif (p.y < 0.0)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\n\t\t// Move along the ray\n\t\tt += length(u);\n\t\tp += u;\n\t}\n\n\t// We didn't hit the plane\n\th = false;\n\ts = 0;\n\treturn t;\n}\n\n// Trace ray using path tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat PathTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n\t// Path tracing\n\tfloat t = 0.0;\n\tvec3 p = o;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t// Check if we hit the plane\n\t\tif (p.y < 0.0)\n\t\t{\n\t\t\th = true;\n\t\t\ts = i;\n\t\t\treturn t;\n\t\t}\n\n\t\t// Move along the ray\n\t\tt += length(u);\n\t\tp += u;\n", "\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\twhile (s < 1000)\n\t{\n\t\tt += 0.001;\n\t\tvec3 p = o + t * u;\n\t\tfloat d = distance(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\twhile (s < 1000)\n\t{\n\t\tt += 0.001;\n\t\tp = o + t * u;\n\t\tfloat d = distance(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\ts++;\n\t}\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n)\n{\n\tfloat t = 0.0;\n\th = false;\n\ts = 0;\n\twhile (s < 1000)\n\t{\n\t\tt += 0.001;\n\t\tp = o + t * u;\n\t\tfloat d = distance(p);\n\t\tif (d < 0.001)\n\t\t{\n\t\t\th = true;\n\t\t\tbreak;\n\t\t}\n\t\ts++;\n\t}\n\tn = normalize(vec3(0.0, 0.0, 0.0));\n\treturn t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h", "\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 Sphere(vec3 rd, vec3 p, vec3 n, float r)\n{\n\tvec3 L = vec3(0.0, 0.0, 0.0);\n\tvec3 V = normalize(rd);\n\tvec3 N = normalize(n);\n\tfloat t = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h * ba;\n\tvec3 d = p - q;\n\treturn length(d) - r;\n}\n\n// cylinder with arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h2 = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h2 * ba;\n\tvec3 d = p - q;\n\treturn length(d) - r;\n}\n\n// cylinder with arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float h2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h2 = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h2 * ba;\n\tvec3 d = p - q;\n\treturn length(d) - r;\n}\n\n// cylinder with arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float h2, float h3)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h2 = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h2 * ba;\n\tvec3 d = p - q;\n\treturn length(d) - r;\n}\n\n// cylinder with arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float h2, float h3, float h4)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h2 = dot(pa, ba) / dot(ba, ba);\n\tvec3 q = a + h2 * ba;\n\tvec3 d =", "\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\treturn max( t1, 0.0 ) + min( t2, 0.0 );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\treturn min( max( t1, 0.0 ), min( t2, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad, in float t ) \n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * invdir;\n\tvec3 t1 = min( tmin, tmax );\n\tvec3 t2 = max( tmin, tmax );\n\treturn min( max( t1, 0.0 ), min( t2, 0.0 ) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat iBox( in vec3 ro, in vec3 rd, in vec3 rad, in float t, in float mint, in float maxt ) \n{\n\tvec3 invdir = 1.0 / rd;\n\tvec3 tmin = (ro - rad) * invdir;\n\tvec3 tmax = (ro + rad) * inv", "\n\treturn coord * 0.5 + 0.5;\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord) {\n\treturn texture(tex, coord.xy);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, float lod) {\n\treturn texture(tex, coord.xy, lod);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset) {\n\treturn texture(tex, coord.xy, offset.xy);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, float lod) {\n\treturn texture(tex, coord.xy, offset.xy, lod);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale) {\n\treturn texture(tex, coord.xy, offset.xy, scale.xy);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale, float lod) {\n\treturn texture(tex, coord.xy, offset.xy, scale.xy, lod);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale, vec2 lod) {\n\treturn texture(tex, coord.xy, offset.xy, scale.xy, lod.xy);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale, vec2 lod, float bias) {\n\treturn texture(tex, coord.xy, offset.xy, scale.xy, lod.xy, bias);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale, vec2 lod, float bias, float level) {\n\treturn texture(tex, coord.xy, offset.xy, scale.xy, lod.xy, bias, level);\n}\n\n// texture lookup\nvec4 texture(sampler2D tex, vec2 coord, vec2 offset, vec2 scale, vec2 lod, float bias, float", "\nvec2 d = q - p;\nvec2 r = d * vec2( 0.5, 0.5 );\nvec2 s = d * vec2( 0.5, -0.5 );\nvec2 t = d * vec2( 0.0, 1.0 );\nvec2 u = d * vec2( 1.0, 0.0 );\nvec2 v = d * vec2( 0.0, 0.0 );\nvec2 w = d * vec2( 0.5, 0.0 );\nvec2 x = d * vec2( 0.0, 0.5 );\nvec2 y = d * vec2( 0.0, 0.0 );\nvec2 z = d * vec2( 0.0, 0.0 );\nvec2 a = d * vec2( 0.0, 0.0 );\nvec2 b = d * vec2( 0.0, 0.0 );\nvec2 c = d * vec2( 0.0, 0.0 );\nvec2 e = d * vec2( 0.0, 0.0 );\nvec2 f = d * vec2( 0.0, 0.0 );\nvec2 g = d * vec2( 0.0, 0.0 );\nvec2 h = d * vec2( 0.0, 0.0 );\nvec2 i = d * vec2( 0.0, 0.0 );\nvec2 j = d * vec2( 0.0, 0.0 );\nvec2 k = d * vec2( 0.0, 0.0 );\nvec2 l = d * vec2( 0.0, 0.0 );\nvec2 m = d * vec2( 0.0, 0.0 );\nvec2 n = d * vec2( 0.0, 0.0 );\nvec2 o = d * vec2( 0.0, 0.0 );\nvec2 p = d * vec2( 0.0, 0.0 );\nvec2 q = d * vec2( 0.0, 0.0 );\nvec2", "\n\tfloat a = 1.0 - p.x * p.x - p.y * p.y;\n\tfloat b = 2.0 * p.x * p.y;\n\tfloat c = 2.0 * p.x * p.y;\n\tfloat d = p.x * p.x + p.y * p.y - r * r;\n\tfloat e = 2.0 * p.x;\n\tfloat f = 2.0 * p.y;\n\tfloat g = 1.0;\n\tfloat h = 2.0 * p.x * p.y;\n\tfloat i = 2.0 * p.x * p.y;\n\tfloat j = 1.0;\n\tfloat k = 2.0 * p.x;\n\tfloat l = 2.0 * p.y;\n\tfloat m = 1.0;\n\tfloat n = 2.0 * p.x * p.y;\n\tfloat o = 2.0 * p.x * p.y;\n\tfloat p = 1.0;\n\tfloat q = 2.0 * p.x;\n\tfloat r = 2.0 * p.y;\n\tfloat s = 1.0;\n\tfloat t = 2.0 * p.x * p.y;\n\tfloat u = 2.0 * p.x * p.y;\n\tfloat v = 1.0;\n\tfloat w = 2.0 * p.x;\n\tfloat x = 2.0 * p.y;\n\tfloat y = 1.0;\n\tfloat z = 2.0 * p.x * p.y;\n\tfloat A = 1.0;\n\tfloat B = 2.0 * p.x;\n\tfloat C = 2.0 * p.y;\n\tfloat D = 1.0;\n\tfloat E = 2.0 * p.x * p.y;\n\tfloat F = 2.0 * p.x * p.y;\n\tfloat G = 1.0;\n\tfloat H = 2.0 * p.x;\n\tfloat I = 2.0", "\n\tvec3 v = vec3( p, 0.0 );\n\tv.x = v.x * c.x + v.y * c.y;\n\tv.y = v.x * c.y - v.y * c.x;\n\tv.z = r;\n\treturn v;\n}\n\n// 2D spherical gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgSph( in vec2 p, in vec2 c, in float r )\n{\n\tvec3 v = vec3( p, 0.0 );\n\tv.x = v.x * c.x + v.y * c.y;\n\tv.y = v.x * c.y - v.y * c.x;\n\tv.z = r;\n\treturn v;\n}\n\n// 2D spherical gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgSph( in vec2 p, in vec2 c, in float r, in float s )\n{\n\tvec3 v = vec3( p, 0.0 );\n\tv.x = v.x * c.x + v.y * c.y;\n\tv.y = v.x * c.y - v.y * c.x;\n\tv.z = r;\n\tv.z *= s;\n\treturn v;\n}\n\n// 2D spherical gradient\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207", "\nvec3 x = vec3( p, 1 );\nvec3 y = vec3( v[0], 1 );\nvec3 z = vec3( v[1], 1 );\nvec3 w = vec3( v[2], 1 );\nvec3 a = cross( x, y );\nvec3 b = cross( z, w );\nvec3 c = cross( w, x );\nvec3 d = cross( y, z );\nvec3 e = cross( x, z );\nvec3 f = cross( w, y );\nvec3 g = cross( z, x );\nvec3 h = cross( y, w );\nvec3 i = cross( x, w );\nvec3 j = cross( z, y );\nvec3 k = cross( w, x );\nvec3 l = cross( y, z );\nvec3 m = cross( x, z );\nvec3 n = cross( w, y );\nvec3 o = cross( z, x );\nvec3 p = cross( y, w );\nvec3 q = cross( x, w );\nvec3 r = cross( z, y );\nvec3 s = cross( w, x );\nvec3 t = cross( y, z );\nvec3 u = cross( x, z );\nvec3 v = cross( w, y );\nvec3 w = cross( z, x );\nvec3 x = cross( y, w );\nvec3 y = cross( x, z );\nvec3 z = cross( w, y );\nvec3 A = cross( z, x );\nvec3 B = cross( y, w );\nvec3 C = cross( x, z );\nvec3 D = cross( w, y );\nvec3 E = cross( z, x );\nvec3 F = cross( y, w );\nvec3 G = cross( x, z );\nvec3 H = cross( w, y );\nvec3 I = cross( z, x );\nvec3 J = cross( y, w );\nvec3 K = cross( x, z );\nvec3 L = cross( w, y );\nvec3 M = cross( z, x );\nvec3 N = cross( y, w );\nvec3 O = cross( x, z );\nvec3", "\n\tvec2 q = p * sca;\n\tvec2 r = q * scb;\n\tfloat t = atan( r.y, r.x );\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * c;\n\tfloat b = rb * s;\n\tfloat x = a + b;\n\tfloat y = b - a;\n\treturn vec3( x, y, t );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r )\n{\n\tvec2 q = p * sca;\n\tvec2 r = q * scb;\n\tfloat t = atan( r.y, r.x );\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * c;\n\tfloat b = rb * s;\n\tfloat x = a + b;\n\tfloat y = b - a;\n\treturn vec3( x, y, t ) * r;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r, in float t )\n{\n\tvec2 q = p * sca;\n\tvec2 r = q * scb;\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = ra * c;\n", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 2D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 3D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec4 a, in vec4 b ) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 2D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec2 b, in vec2 c ) {\n\treturn cro( a, b ) * cro( b, c );\n}\n\n// 3D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.xyz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b, in vec3 c ) {\n\treturn cro( a, b ) * cro( b, c );\n}\n\n// 4D cross product\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z", "\nvec2 q = p - ab;\nvec2 r = ab + ab - p;\nvec2 s = ab - ab + p;\nvec2 t = ab - p;\nvec2 u = ab + p;\nvec2 v = ab - q;\nvec2 w = ab + q;\nvec2 x = ab - r;\nvec2 y = ab + r;\nvec2 z = ab - s;\nvec2 A = ab + s;\nvec2 B = ab - t;\nvec2 C = ab + t;\nvec2 D = ab - u;\nvec2 E = ab + u;\nvec2 F = ab - v;\nvec2 G = ab + v;\nvec2 H = ab - w;\nvec2 I = ab + w;\nvec2 J = ab - x;\nvec2 K = ab + x;\nvec2 L = ab - y;\nvec2 M = ab + y;\nvec2 N = ab - z;\nvec2 O = ab + z;\nvec2 P = ab - A;\nvec2 Q = ab + A;\nvec2 R = ab - B;\nvec2 S = ab + B;\nvec2 T = ab - C;\nvec2 U = ab + C;\nvec2 V = ab - D;\nvec2 W = ab + D;\nvec2 X = ab - E;\nvec2 Y = ab + E;\nvec2 Z = ab - F;\nvec2 a = ab + F;\nvec2 b = ab - G;\nvec2 c = ab + G;\nvec2 d = ab - H;\nvec2 e = ab + H;\nvec2 f = ab - I;\nvec2 g = ab + I;\nvec2 h = ab - J;\nvec2 i = ab + J;\nvec2 j = ab - K;\nvec2 k = ab + K;\nvec2 l = ab - L;\nvec2 m = ab + L;\nvec2 n = ab - M;\nvec2 o = ab + M;\nvec2 p = ab - N;\nvec2 q = ab + N;\nvec2 r = ab - O;\nvec2 s = ab + O;\nvec2 t = ab - P;\nvec2 u", "\n\tvec2 q = vec2( length(p.xz) - ra, p.y );\n\tfloat d = length(q) - rb;\n\tfloat g = dot(q,q) - ra*ra;\n\tfloat h = dot(p,p) - rb*rb;\n\tfloat f = d*d - g*h;\n\tfloat x = -d*g;\n\tfloat y = -f*h;\n\tfloat z = f*g;\n\tfloat w = -d*h;\n\treturn vec4( x, y, z, w ) / ( f*f + g*g + h*h );\n}\n\n// Torus\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n\tvec2 q = vec2( length(p.xz) - ra, p.y );\n\tfloat d = length(q) - rb;\n\tfloat g = dot(q,q) - ra*ra;\n\tfloat h = dot(p,p) - rb*rb;\n\tfloat f = d*d - g*h;\n\tfloat x = -d*g;\n\tfloat y = -f*h;\n\tfloat z = f*g;\n\tfloat w = -d*h;\n\treturn vec4( x, y, z, w ) / ( f*f + g*g + h*h );\n}\n\n// Cone\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float r, float h )\n{\n\tfloat d = length(p.xz) -", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\tvec3 q = a + h * ba;\n\tvec3 d = p - q;\n\tfloat c = clamp( dot( d, d ) - r * r, 0.0, 1.0 );\n\tfloat s = sqrt( c );\n\tvec3 n = normalize( cross( ba, d ) );\n\tvec3 v = n * s;\n\treturn vec4( v, h );\n}\n\n//\n// SDF for a sphere\n//\nfloat sdgSphere( vec3 p, float r )\n{\n\treturn length( p ) - r;\n}\n\n//\n// SDF for a box\n//\nfloat sdgBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn length( max( d, 0.0 ) ) + min( max( d.x, max( d.y, d.z ) ), 0.0 );\n}\n\n//\n// SDF for a cylinder\n//\nfloat sdgCylinder( vec3 p, float r, float h )\n{\n\tvec2 q = vec2( length( p.xz ) - r, abs( p.y ) - h * 0.5 );\n\treturn min( max( q.x, q.y ), 0.0 ) + length( max( q, 0.0 ) );\n}\n\n//\n// SDF for a torus\n//\nfloat sdgTorus( vec3 p, float r0, float r1 )\n{\n\tvec2 q = vec2( length( p.xz ) - r0, abs( p.y ) - r1 );\n\treturn min( max( q.x, q.y ), 0.0 ) + length( max( q, 0.0 ) );\n}\n\n//\n// SDF for a cone\n//\nfloat sdgCone( vec3 p, float r, float h )\n{\n\tvec2 q = vec2( length( p.xz )", "\n\tfloat h = abs(p.x*sin(sk) + p.y*cos(sk));\n\tfloat d = length(p - vec2(wi*0.5, he*0.5)) - wi*0.5;\n\treturn min(h, d);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk, vec2 of )\n{\n\treturn sdParallelogram_1(p-of, wi, he, sk);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset, rotation)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk, vec2 of, float ro )\n{\n\treturn sdParallelogram_2(rotate(p-of, ro), wi, he, sk);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset, rotation, scale)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk, vec2 of, float ro, vec2 sc )\n{\n\treturn sdParallelogram_3(p*sc-of, wi, he, sk, ro);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset, rotation, scale, color)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk, vec2 of, float ro, vec2 sc, vec3 col )\n{\n\treturn sdParallelogram_4(p, wi, he, sk, of, ro, sc)*col.r;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew, offset, rotation, scale, color, opacity)\nfloat sdParallelogram_6( in vec2 p, float wi, float he, float sk, vec2 of, float ro, vec2 sc, vec3 col, float op )\n{\n\treturn sdParallelogram_5(p, wi, he, sk, of, ro,", "\n\tvec2 q = p - vec2( wi, he );\n\tvec2 r = p + vec2( wi, he );\n\tvec2 s = p + vec2( wi, -he );\n\tvec2 t = p - vec2( wi, -he );\n\tvec2 u = p + vec2( -wi, he );\n\tvec2 v = p - vec2( -wi, he );\n\tvec2 w = p + vec2( -wi, -he );\n\tvec2 x = p - vec2( -wi, -he );\n\tvec2 y = p + vec2( sk, 0.0 );\n\tvec2 z = p - vec2( sk, 0.0 );\n\tvec2 a = p + vec2( 0.0, sk );\n\tvec2 b = p - vec2( 0.0, sk );\n\tvec2 c = p + vec2( sk, sk );\n\tvec2 d = p - vec2( sk, sk );\n\tvec2 e = p + vec2( sk, -sk );\n\tvec2 f = p - vec2( sk, -sk );\n\tvec2 g = p + vec2( -sk, sk );\n\tvec2 h = p - vec2( -sk, sk );\n\tvec2 i = p + vec2( -sk, -sk );\n\tvec2 j = p - vec2( -sk, -sk );\n\tvec2 k = p + vec2( sk, sk );\n\tvec2 l = p - vec2( sk, sk );\n\tvec2 m = p + vec2( sk, -sk );\n\tvec2 n = p - vec2( sk, -sk );\n\tvec2 o = p + vec2( -sk, sk );\n\tvec2 p = p - vec2( -sk, sk );\n\tvec2 q = p + vec2( -sk, -sk );\n\tvec2 r = p - vec2( -sk, -sk );\n\tvec2 s = p + vec2( sk, sk );\n\tvec2 t = p - vec2( sk, sk );\n\tvec2 u = p + vec2( sk, -sk );\n\tvec2 v = p - vec2", "\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor( int l = 0; l < p; l++ )\n\t\t\t\t\tfor( int m = 0; m < p; m++ )\n\t\t\t\t\t\tr += c;\n\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\tfloat r = 0;\n\tfor( int i = 0; i < p; i++ )\n\t\tfor( int j = 0; j < p; j++ )\n\t\t\tfor( int k = 0; k < p; k++ )\n\t\t\t\tfor", "\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\treturn (ak < bk)? ak : bk;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\treturn (ak > bk)? ak : bk;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\treturn (ak < bk)? ak : bk;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k, float min, float max) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\treturn (ak < bk)? ak : bk;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k, float min, float max, float c) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\tfloat ck = c * k;\n\treturn (ak < bk)? (ak < ck)? ak : ck : (bk < ck)? bk : ck;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k, float min, float max, float c, float d) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\tfloat ck = c * k;\n\tfloat dk = d * k;\n\treturn (ak < bk)? (ak < ck)? (ak < dk)? ak : dk : ck : (bk < ck)? (bk < dk)? bk : dk : ck;\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k, float min, float max, float c, float d, float e) {\n\tfloat ak = a * k;\n\tfloat bk = b * k;\n\tfloat ck = c * k;\n\tfloat dk = d * k;\n\tfloat ek = e * k;\n\t", "\n\treturn mod(p, size) - 0.5 * size;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec2 p, vec2 b, vec2 s) {\n\tvec2 q = mod2(p, s);\n\tvec2 d = abs(q) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b, vec3 s) {\n\tvec3 q = mod2(p, s);\n\tvec3 d = abs(q) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec4 p, vec4 b) {\n\tvec4 d = abs(p) - b;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, max(d.z, d.w))), 0.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec4 p, vec4 b, vec4 s) {\n\tvec4 q = mod2(p, s);\n\tvec4 d = abs(q", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to", "\n\tvec3 c = vec3(s.x, s.y, s.z);\n\tfloat r = s.w;\n\tvec3 oc = ro - c;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(oc, rd);\n\tfloat c = dot(oc, oc) - r * r;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) {\n\t\treturn vec2(0.0, 0.0);\n\t}\n\tfloat s0 = (-b - sqrt(d)) / (2.0 * a);\n\tfloat s1 = (-b + sqrt(d)) / (2.0 * a);\n\treturn vec2(s0, s1);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 p = cross(rd, e2);\n\tfloat a = dot(e1, p);\n\tif (a > -0.00001 && a < 0.00001) {\n\t\treturn vec2(0.0, 0.0);\n\t}\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot(s, p);\n\tif (u < 0.0 || u > 1.0) {\n\t\treturn vec2(0.0, 0.0);\n\t}\n\tvec3 q = cross(s, e1);\n\tfloat v = f * dot(rd, q);\n\tif (v < 0.0 || u + v > 1.0) {\n\t\treturn vec2(0.0, 0.0);\n\t}\n\tfloat t = f * dot(e2, q);\n\tif (t > 0.00001) {\n\t\treturn vec2(t, 0.0);\n\t}\n\telse {\n\t\treturn", "\n\tvec3 tmin = (boxSize - ro) / rd;\n\tvec3 tmax = (boxSize - ro) / rd;\n\tvec3 tmin_tmax = min(tmin, tmax);\n\tvec3 tmax_tmin = max(tmin, tmax);\n\tvec3 t0 = max(tmin_tmax, 0.0);\n\tvec3 t1 = min(tmax_tmin, 1.0);\n\tfloat t = max(max(t0.x, t0.y), t0.z);\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0;\n\t}\n\tif (t < 0.0) {\n\t\tt = -1.0;\n\t}\n\tif (t > 1.0) {\n\t\tt = -1.0", "\n\te1 = vec2(d.x, 0.0);\n\te2 = vec2(0.0, d.y);\n\te3 = vec2(-d.x, 0.0);\n\te4 = vec2(0.0, -d.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n\te1 = vec3(d.x, 0.0, 0.0);\n\te2 = vec3(0.0, d.y, 0.0);\n\te3 = vec3(0.0, 0.0, d.z);\n\te4 = vec3(-d.x, 0.0, 0.0);\n\te5 = vec3(0.0, -d.y, 0.0);\n\te6 = vec3(0.0, 0.0, -d.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge8(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6, inout vec2 e7, inout vec2 e8) {\n\te1 = vec2(d.x, 0.0);\n\te2 = vec2(0.0, d.y);\n\te3 = vec2(-d.x, 0.0);\n\te4 = vec2(0.0, -d.y);\n\te5 = vec2(d.x, d.y);\n\te6 = vec2(-d.x, d.y);\n\te7 = vec2(-d.x, -d.y);\n\te8 = vec2(d.x, -d.", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat boxcycle(float x, float a, float b) {\n    float y = mod(x, b) - a;\n    return clamp(y, 0.0, b);\n}\n\nfloat boxcycle(float x, float a, float b, float c, float d) {\n    float y = mod(x, b) - a;\n    return clamp(y, 0.0, b) + c * step(b, y) * (d - c);\n}\n\nfloat boxcycle(float x, float a, float b, float c, float d, float e, float f) {\n    float y = mod(x, b) - a;\n    return clamp(y, 0.0, b) + c * step(b, y) * (d - c) + e * step(b + c, y) * (f - e);\n}\n\nfloat boxcycle(float x, float a, float b, float c, float d, float e, float f, float g, float h) {\n    float y = mod(x, b) - a;\n    return clamp(y, 0.0, b) + c * step(b, y) * (d - c) + e * step(b + c, y) * (f - e) + g * step(b + c + e, y) * (h - g);\n}\n\nfloat boxcycle(float x, float a, float b, float c, float d, float e, float f, float g, float h, float i, float j) {\n    float y = mod(x, b) - a;\n    return clamp(y, 0.0, b) + c * step(b, y) * (d - c) + e * step(b + c, y) * (f - e) + g * step(b + c + e, y) * (h - g) + i * step(b + c + e + g, y) * (j - i);\n}\n\nfloat boxcycle(", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\tvec2 proj = a + h*ba;\n\tfloat d = length(pa - proj);\n\tif ( h < 0.0 ) d = length(pa);\n\tif ( h > 1.0 ) d = length(pa - ba);\n\treturn min( d-w1, w2 );\n}\n\n// The distance from a point to a line segment.\nfloat sdLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - h*ba );\n}\n\n// The distance from a point to a circle.\nfloat sdCircle( in vec2 p, in vec2 c, float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// The distance from a point to a rectangle.\nfloat sdRectangle( in vec2 p, in vec2 b, in vec2 c )\n{\n\tvec2 d = abs(p+b) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// The distance from a point to a rounded rectangle.\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in vec2 c, float r )\n{\n\tvec2 d = abs(p+b) - c;\n\treturn min(max(d.x,d.y) - r,0.0) + length(max(d - r,0.0));\n}\n\n// The distance from a point to a rounded rectangle.\nfloat sdRoundedRectangle( in vec2 p, in vec2 b, in vec2 c, float r1, float r2 )\n{\n\tvec2 d = abs(p+b) - c;\n\treturn min(max(d.x,d.y) - r1,0.0) + length(max(d - r2,0", "\n\tvec2 p = vec2(dot(ro, rd), dot(ro, ro));\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, ro);\n\tfloat c = dot(ro, ro) - tor.x * tor.x;\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0) return -1.0;\n\tfloat e = sqrt(d);\n\tfloat u1 = (-b - e) / (2.0 * a);\n\tfloat u2 = (-b + e) / (2.0 * a);\n\tif (u1 > u2) swap(u1, u2);\n\tif (u2 < 0.0) return -1.0;\n\tif (u1 > 1.0) return -1.0;\n\treturn u1;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n\tvec3 l = ro - sc;\n\tfloat tca = dot(l, rd);\n\tif (tca < 0.0) return -1.0;\n\tfloat d2 = dot(l, l) - tca * tca;\n\tif (d2 > sr * sr) return -1.0;\n\tfloat thc = sqrt(sr * sr - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\tif (t0 > t1) swap(t0, t1);\n\tif (t0 < 0.0) {\n\t\tt0 = t1;\n\t\tif (t0 < 0.0) return -1.0;\n\t}\n\treturn t0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec3 pl", "\n    vec2 p = vec2(length(pos.xz) - tor.x, pos.y);\n    return normalize(vec3(p, dot(p, p) - tor.y * tor.y));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusPoint(vec3 pos, vec2 tor) {\n    vec2 p = vec2(length(pos.xz) - tor.x, pos.y);\n    return vec3(p, sqrt(max(0.0, tor.y * tor.y - dot(p, p))));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusIntersect(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float b = dot(p, rd);\n    float c = dot(p, p) - tor.y * tor.y;\n    float d = b * b - c;\n    if (d < 0.0) return vec3(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) return vec3(0.0);\n    return ro + rd * t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusIntersectNormal(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 p = vec2(length(ro.xz) - tor.x, ro.y);\n    float b = dot(p, rd);\n    float c = dot(p, p) - tor.y * tor.y;\n    float d = b * b - c;\n    if (d < 0.0) return vec3(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) return vec3(0.0);\n    return normalize(", "\n    float x2 = x * x;\n    float x4 = x2 * x2;\n    float x6 = x4 * x2;\n    float x8 = x4 * x4;\n    float x10 = x6 * x4;\n    float x12 = x6 * x6;\n    float x14 = x8 * x6;\n    float x16 = x8 * x8;\n    float x18 = x10 * x8;\n    float x20 = x10 * x10;\n    float x22 = x12 * x10;\n    float x24 = x12 * x12;\n    float x26 = x14 * x12;\n    float x28 = x14 * x14;\n    float x30 = x16 * x14;\n    float x32 = x16 * x16;\n    float x34 = x18 * x16;\n    float x36 = x18 * x18;\n    float x38 = x20 * x18;\n    float x40 = x20 * x20;\n    float x42 = x22 * x20;\n    float x44 = x22 * x22;\n    float x46 = x24 * x22;\n    float x48 = x24 * x24;\n    float x50 = x26 * x24;\n    float x52 = x26 * x26;\n    float x54 = x28 * x26;\n    float x56 = x28 * x28;\n    float x58 = x30 * x28;\n    float x60 = x30 * x30;\n    float x62 = x32 * x30;\n    float x64 = x32 * x32;\n    float x66 = x34 * x32;\n    float x68 = x34 * x34;\n    float x70 = x36 * x34;\n    float x72 = x36 * x36;\n    float x74 = x38 * x36;\n    float x76 = x38 * x38;\n    float x", "\n    vec3 c = col;\n    c = vec3(dot(c, vec3(0.2126, 0.7152, 0.0722)));\n    c = vec3(1.0) - exp(-0.0015 * c);\n    c = vec3(1.0) - exp(-0.00004 * c);\n    return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q, float time) {\n    vec3 c = col;\n    c = vec3(dot(c, vec3(0.2126, 0.7152, 0.0722)));\n    c = vec3(1.0) - exp(-0.0015 * c);\n    c = vec3(1.0) - exp(-0.00004 * c);\n    return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q, float time, float time2) {\n    vec3 c = col;\n    c = vec3(dot(c, vec3(0.2126, 0.7152, 0.0722)));\n    c = vec3(1.0) - exp(-0.0015 * c);\n    c = vec3(1.0) - exp(-0.00004 * c);\n    return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q, float time, float time2, float time3) {\n    vec3 c = col;\n    c = vec3(dot(c, vec3(0.2126, 0.7152, 0.0722)));\n    c = vec3(1.0) - exp(-0.0015", "\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(vec2 p, vec2 size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, float size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(vec2 p, float size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec3 p, vec3 size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(vec3 p, vec3 size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec3 p, float size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(vec3 p, float size) {\n    return mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC", "\n\tuv = uv * 2.0 - 1.0;\n\tvec4 p = vec4(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5, 183.3)), dot(uv, vec2(419.2, 371.9)), dot(uv, vec2(987.2, 374.2)));\n\treturn fract(sin(dot(p, vec4(12.9898, 78.233, 151.7182, 24.214))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat fbm(vec2 uv) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(uv);\n\tf += 0.2500 * noise(uv * 2.0);\n\tf += 0.1250 * noise(uv * 4.0);\n\tf += 0.0625 * noise(uv * 8.0);\n\treturn f;\n}\n\nfloat fbm(vec2 uv, float octaves) {\n\tfloat f = 0.0;\n\tfloat amp = 1.0;\n\tfloat maxAmp = 0.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tf += amp * noise(uv);\n\t\tmaxAmp += amp;\n\t\tamp *= 0.5;\n\t\tuv *= 2.0;\n\t}\n\treturn f / maxAmp;\n}\n\nfloat fbm(vec2 uv, float octaves, float lacunarity, float gain) {\n\tfloat f = 0.0;\n\tfloat amp = 1.0;\n\tfloat maxAmp = 0.0;\n\tfor (int i = 0; i < octaves", "\n\treturn length( p - c ) - r;\n}\n\n// signed distance to a rectangle\nfloat sdRect( in vec2 p, in vec2 b, in vec2 c )\n{\n\tvec2 d = abs(p-c) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a rounded rectangle\nfloat sdRoundedRect( in vec2 p, in vec2 b, in vec2 c, in float r )\n{\n\tvec2 d = abs(p-c) - b;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// signed distance to a circle\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\n// signed distance to a triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 ap = p - a;\n\tfloat d1 = dot(ac, cross(ab, ap));\n\tfloat d2 = dot(ab, cross(ac, ap));\n\tif (d1 <= 0.0 && d2 <= 0.0) return length(ap);\n\tvec2 bp = p - b;\n\td1 = dot(ab, cross(ac, bp));\n\td2 = dot(ac, cross(ab, bp));\n\tif (d1 <= 0.0 && d2 <= 0.0) return length(bp);\n\tvec2 cp = p - c;\n\td1 = dot(ab, cross(ac, cp));\n\td2 = dot(ac, cross(ab, cp));\n\tif (d1 <= 0.0 && d2 <= 0.0) return length(cp);\n\tfloat d = dot(ab, cross(ac, ap));\n\treturn abs(d) / length(ab);\n}\n\n// signed distance to a polygon\nfloat sd", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// distance to a circle\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length( p ) - r;\n}\n\n// distance to a box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d-vec2(r),0.0)) + min(max(d.x-r,d.y-r),0.0);\n}\n\n// distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float aspect )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d-vec2(r),0.0)) + min(max(d.x-r,d.y-r*aspect),0.0);\n}\n\n// distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float aspect, in float angle )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d-vec2(r),0.0)) + min(max(d.x-r,d.y-r*aspect),0.0);\n}\n\n// distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r, in float aspect, in float angle, in float roundness )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d-vec2(r),0.0)) + min(max(d.x", "\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec3 a, in vec3 b ) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec4 a, in vec4 b ) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c ) {\n\treturn cro(a, b) + cro(b, c) + cro(c, a);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec3 a, in vec3 b, in vec3 c ) {\n\treturn cro(a, b) + cro(b, c) + cro(c, a);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec4 a, in vec4 b, in vec4 c ) {\n\treturn cro(a, b) + cro(b, c) + cro(c, a);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b, in vec2 c, in vec2 p ) {\n\treturn cro(a, b, c) + cro(p, a, b) + cro(p, b, c) + cro(p, c, a);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec3 a, in vec3 b, in vec3 c, in vec3 p ) {\n\treturn cro(a, b, c) + cro(p, a, b) + cro(p, b, c) + cro(p, c, a);\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec4 a, in vec4 b, in vec4 c, in vec4 p ) {\n\treturn cro(a, b, c) + cro(p, a, b) + cro(p, b, c) + cro(p, c, a);\n}\n", "\n\tvec2 q = abs(p) - vec2(s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + length(max(vec2(length(q)-r),0.0));\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in float r ) \n{\n\tvec3 q = abs(p) - vec3(s, s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(q.z,0.0) + length(max(vec3(length(q)-r),0.0));\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec4 p, in float s, in float r ) \n{\n\tvec4 q = abs(p) - vec4(s, s, s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(q.z,0.0) + min(q.w,0.0) + length(max(vec4(length(q)-r),0.0));\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in vec2 r ) \n{\n\tvec2 q = abs(p) - vec2(s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + length(max(vec2(length(q)-r),0.0));\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec3 p, in float s, in vec3 r ) \n{\n\tvec3 q = abs(p) - vec3(s, s, s);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0) + min(q.z,0.", "\n\treturn x * (x * (3.0 - 2.0 * x));\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 inv_s_curve(vec3 x)\n{\n\treturn pow((x * (x * x + 0.25)), 1.0 / 3.0);\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_derivative(vec3 x)\n{\n\treturn (3.0 * x * x - 2.0 * x);\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 inv_s_curve_derivative(vec3 x)\n{\n\treturn (1.0 / 3.0) * pow((x * (x * x + 0.25)), -2.0 / 3.0) * (3.0 * x * x - 2.0 * x);\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Using this since it was easy to differentiate, same technique would work for any curve \nvec3 s_curve_integral(vec3 x)\n{\n\treturn (1.0 / 2.0) * pow((x * (x * x + 0.25)), 1.0 / 3.0);\n}\n\n// Adapted from: https://knarkowicz.wordpress.com/2016/01/06/aces-", "\n\tvec3 y;\n\ty.x = 3.0 * x.x * (1.0 - x.x) * (1.0 - 2.0 * x.x);\n\ty.y = 3.0 * x.y * (1.0 - x.y) * (1.0 - 2.0 * x.y);\n\ty.z = 3.0 * x.z * (1.0 - x.z) * (1.0 - 2.0 * x.z);\n\treturn y;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(float x)\n{\n\tvec3 y;\n\ty.x = 3.0 * x * (1.0 - x) * (1.0 - 2.0 * x);\n\ty.y = 3.0 * x * (1.0 - x) * (1.0 - 2.0 * x);\n\ty.z = 3.0 * x * (1.0 - x) * (1.0 - 2.0 * x);\n\treturn y;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(float x, float y, float z)\n{\n\tvec3 y;\n\ty.x = 3.0 * x * (1.0 - x) * (1.0 - 2.0 * x);\n\ty.y = 3.0 * y * (1.0 - y) * (1.0 - 2.0 * y);\n\ty.z = 3.0 * z * (1.0 - z) * (1.0 - 2.0 * z);\n\treturn y;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z)\n{\n\tvec3 y;\n\ty.x = 3.0 * x.x * (1.0 - x.x) * (1.0 - 2.0 * x.x);\n\ty.y = 3.0 * y.y * (1.0 - y.y) * (1.0 - 2", "\n\tfloat a = 2.0 * PI * k;\n\tfloat r = length( p ) - w * a;\n\treturn r;\n}\n\n// sdSpiral2\n//\n// Spiral with a twist\n//\n// p is the position\n// w is the width / distance from center to tip\n// k is the number of rotations\n// t is the twist\nfloat sdSpiral2( in vec2 p, float w, in float k, in float t )\n{\n\tfloat a = 2.0 * PI * k;\n\tfloat r = length( p ) - w * a;\n\tfloat s = sin( a );\n\tfloat c = cos( a );\n\tfloat x = p.x * c - p.y * s;\n\tfloat y = p.x * s + p.y * c;\n\tfloat z = r * r + t * x * y;\n\treturn z;\n}\n\n// sdSpiral3\n//\n// Spiral with a twist\n//\n// p is the position\n// w is the width / distance from center to tip\n// k is the number of rotations\n// t is the twist\nfloat sdSpiral3( in vec2 p, float w, in float k, in float t )\n{\n\tfloat a = 2.0 * PI * k;\n\tfloat r = length( p ) - w * a;\n\tfloat s = sin( a );\n\tfloat c = cos( a );\n\tfloat x = p.x * c - p.y * s;\n\tfloat y = p.x * s + p.y * c;\n\tfloat z = r * r + t * x * y;\n\treturn z;\n}\n\n// sdSpiral4\n//\n// Spiral with a twist\n//\n// p is the position\n// w is the width / distance from center to tip\n// k is the number of rotations\n// t is the twist\nfloat sdSpiral4( in vec2 p, float w, in float k, in float t )\n{\n\tfloat a = 2.0 * PI * k;\n\tfloat r = length( p ) - w * a;\n\tfloat s = sin( a );\n\t", "\nreturn exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance)\n{\nreturn transmittance * exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption)\n{\nreturn transmittance * exp(-opticalDepth * absorption);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption, vec3 scattering)\n{\nreturn transmittance * exp(-opticalDepth * (absorption + scattering));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption, vec3 scattering, vec3 extinction)\n{\nreturn transmittance * exp(-opticalDepth * (absorption + scattering) * extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption, vec3 scattering, vec3 extinction, vec3 albedo)\n{\nreturn transmittance * exp(-opticalDepth * (absorption + scattering) * extinction) * albedo;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption, vec3 scattering, vec3 extinction, vec3 albedo, vec3 scatteringAlbedo)\n{\nreturn transmittance * exp(-opticalDepth * (absorption + scattering) * extinction) * albedo * scatteringAlbedo;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 absorption, vec3 scattering, vec3 extinction, vec3 albedo, vec3 scatteringAlbedo, vec3 anisotropy)\n{\nreturn transmit", "\n\t// Integrate the scattering along the ray.\n\tvec3 scatteredColor = vec3(0.0);\n\tfloat opticalDepth = 0.0;\n\tfloat stepSize = 0.01;\n\tfloat stepCount = rayLength / stepSize;\n\tfor (int i = 0; i < stepCount; i++)\n\t{\n\t\tfloat t = (float(i) + 0.5) * stepSize;\n\t\tvec3 pos = rayStart + rayDir * t;\n\t\tvec3 normal = GetNormal(pos);\n\t\tvec3 color = GetColor(pos);\n\t\tvec3 attenuation = GetAttenuation(pos);\n\t\tvec3 transmittanceStep = exp(-attenuation * t);\n\t\ttransmittance = transmittance * transmittanceStep;\n\t\tvec3 scattering = GetScattering(pos, normal, lightDir, lightColor);\n\t\tscatteredColor += transmittanceStep * scattering * color;\n\t\topticalDepth += t;\n\t}\n\tscatteredColor /= opticalDepth;\n\treturn scatteredColor;\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance, out vec3 attenuation)\n{\n\t// Integrate the scattering along the ray.\n\tvec3 scatteredColor = vec3(0.0);\n\tfloat opticalDepth = 0.0;\n\tfloat stepSize = 0.01;\n\tfloat stepCount = rayLength / stepSize;\n\tfor (int i = 0; i < stepCount; i++)\n\t{\n\t\tfloat t = (float(i) + 0.5) * stepSize;\n\t\tvec3 pos = rayStart + rayDir * t;\n\t\tvec3 normal = GetNormal(pos);\n\t\tvec3 color = GetColor(pos);\n\t\tattenuation = GetAttenuation(pos);\n\t\tvec3 transmittanceStep = exp(-attenuation * t);\n\t\ttransmittance = transmittance * transmitt", "\n\tfloat h = length( p2 - vec3( 0.0 ) );\n\tfloat d2 = max( h - ra - rb, 0.0 );\n\treturn d2 + length( p2 - vec3( d, 0.0, 0.0 ) );\n}\n\n//\n//\n//\n\nfloat sdDeathStar2( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat h = length( p2 - vec3( 0.0 ) );\n\tfloat d2 = max( h - ra - rb, 0.0 );\n\treturn d2 + length( p2 - vec3( d, 0.0, 0.0 ) );\n}\n\n//\n//\n//\n\nfloat sdDeathStar3( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat h = length( p2 - vec3( 0.0 ) );\n\tfloat d2 = max( h - ra - rb, 0.0 );\n\treturn d2 + length( p2 - vec3( d, 0.0, 0.0 ) );\n}\n\n//\n//\n//\n\nfloat sdDeathStar4( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat h = length( p2 - vec3( 0.0 ) );\n\tfloat d2 = max( h - ra - rb, 0.0 );\n\treturn d2 + length( p2 - vec3( d, 0.0, 0.0 ) );\n}\n\n//\n//\n//\n\nfloat sdDeathStar5( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat h = length( p2 - vec3( 0.0 ) );\n\tfloat d2 = max( h - ra - rb, 0.0 );\n\treturn d2 + length( p2 - vec3( d, 0.0, 0.0 ) );\n}\n\n//\n//\n//\n\nfloat sdDeathStar6( in vec3 p2, in float ra, float rb, in float d )\n{\n\tfloat h = length(", "\n\tfloat d = length( p - vec3( 0, h, 0 ) );\n\treturn max( d - r - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r;\n\treturn max( d - h - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r;\n\treturn max( d - h - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r;\n\treturn max( d - h - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r;\n\treturn max( d - h - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r;\n\treturn max( d - h - t, 0.0 );\n}\n\n// Cylindrical shell\n// p = point\n// r = radius\n// h = height\n// t = thickness\nfloat sdCylShell( vec3 p, float r, float h, float t )\n{\n\tfloat d = length( p.xz ) - r", "\n\tfloat t = tmin;\n\tfloat dt = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat p = 0.0;\n\tfloat f = 0.0;\n\tfloat bias = 0.0001;\n\tfloat k2 = k * k;\n\tfloat k3 = k2 * k;\n\tfloat k4 = k3 * k;\n\tfloat k5 = k4 * k;\n\tfloat k6 = k5 * k;\n\tfloat k7 = k6 * k;\n\tfloat k8 = k7 * k;\n\tfloat k9 = k8 * k;\n\tfloat k10 = k9 * k;\n\tfloat k11 = k10 * k;\n\tfloat k12 = k11 * k;\n\tfloat k13 = k12 * k;\n\tfloat k14 = k13 * k;\n\tfloat k15 = k14 * k;\n\tfloat k16 = k15 * k;\n\tfloat k17 = k16 * k;\n\tfloat k18 = k17 * k;\n\tfloat k19 = k18 * k;\n\tfloat k20 = k19 * k;\n\tfloat k21 = k20 * k;\n\tfloat k22 = k21 * k;\n\tfloat k23 = k22 * k;\n\tfloat k24 = k23 * k;\n\tfloat k25 = k24 * k;\n\tfloat k26 = k25 * k;\n\tfloat k27 = k26 * k;\n\tfloat k28 = k27 * k;\n\tfloat k29 = k28 * k;\n\tfloat k30 = k29 * k;\n\tfloat k31 = k30 * k;\n\tfloat k32 = k31 * k;\n\tfloat k33 = k32 * k;\n\tfloat k34 = k33 * k;\n\tfloat k35 = k34 * k;\n\tfloat k36 = k35 * k;\n\tfloat k", "\n\tfloat d = p.y - h;\n\tif ( d < 0.0 ) return length( p ) - r;\n\telse return length( p - vec3( 0.0, h, 0.0 ) ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h )\n{\n\tfloat d = p.y - h.y;\n\tif ( d < 0.0 ) return length( p ) - r;\n\telse return length( p - h ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n )\n{\n\tfloat d = dot( p - h, n );\n\tif ( d < 0.0 ) return length( p ) - r;\n\telse return length( p - h ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in float d )\n{\n\tfloat d2 = dot( p - h, n );\n\tif ( d2 < d ) return length( p ) - r;\n\telse return length( p - h ) - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in float d, in float r2 )\n{\n\tfloat d2 = dot( p - h, n );\n\tif ( d2 < d ) return length( p ) - r;\n\telse return length( p - h ) - r2;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in vec3 h, in vec3 n, in float d, in float r2, in float r3 )\n{\n\tfloat d2 = dot( p - h, n );\n\tif ( d2 < d ) return length( p ) -", "\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( 0.001, 0.0, 0.0 ) ) - sdf( pos - vec3( 0.001, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.001, 0.0 ) ) - sdf( pos - vec3( 0.0, 0.001, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.0, 0.001 ) ) - sdf( pos - vec3( 0.0, 0.0, 0.001 ) )\n\t);\n\treturn normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( eps, 0.0, 0.0 ) ) - sdf( pos - vec3( eps, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, eps, 0.0 ) ) - sdf( pos - vec3( 0.0, eps, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, 0.0, eps ) ) - sdf( pos - vec3( 0.0, 0.0, eps ) )\n\t);\n\treturn normalize( n );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps, in float eps2 )\n{\n\tvec3 n = vec3(\n\t\tsdf( pos + vec3( eps, 0.0, 0.0 ) ) - sdf( pos - vec3( eps, 0.0, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.0, eps, 0.0 ) ) - sdf( pos - vec3( 0.0, eps, 0.0 ) ),\n\t\tsdf( pos + vec3( 0.", "\n\tvec2 q = abs(p) - vec2(r,h);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\n\tfloat a = p.x;\n\tfloat b = p.y;\n\tfloat k = h/r;\n\tfloat d = length(p) - a*k;\n\treturn length(max(vec2(d,a),0.0)) + min(max(vec2(d,b),0.0),0.0);\n}\n\n// r=radius, h=height\nfloat sdCutCylinder( in vec2 p, in float r, in float h )\n{\n\tfloat a = p.x;\n\tfloat b = p.y;\n\tfloat k = h/r;\n\tfloat d = length(p) - a*k;\n\treturn length(max(vec2(d,a),0.0)) + min(max(vec2(d,b),0.0),0.0);\n}\n\n// r=radius, h=height\nfloat sdCutSphere( in vec2 p, in float r, in float h )\n{\n\tfloat a = p.x;\n\tfloat b = p.y;\n\tfloat k = h/r;\n\tfloat d = length(p) - a*k;\n\treturn length(max(vec2(d,a),0.0)) + min(max(vec2(d,b),0.0),0.0);\n}\n\n// r=radius, h=height\nfloat sdCutTorus( in vec2 p, in float r, in float h )\n{\n\tfloat a = p.x;\n\tfloat b = p.y;\n\tfloat k = h/r;\n\tfloat d = length(p) - a*k;\n\treturn length(max(vec2(d,a),0.0)) + min(max(vec2(d,b),0.0),0.0);\n}\n\n// r=radius, h=height\n", "\n\tvec3 p = floor( x );\n\tvec3 f = fract( x );\n\n\tf = f * f * ( 3.0 - 2.0 * f );\n\n\tvec2 uv = ( p.xy + vec2( 37.0, 17.0 ) * p.z ) + f.xy;\n\n\tvec2 rg = texture2D( iChannel0, uv / 103.0 ).rg;\n\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// 3d simplex noise function\nfloat snoise( in vec3 x )\n{\n\tconst vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n\tconst vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n\t// First corner\n\tvec3 i  = floor( x + dot( x, C.yyy ) );\n\tvec3 x0 = x - i + dot( i, C.xxx );\n\n\t// Other corners\n\tvec3 g = step( x0.yzx, x0.xyz );\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations", "\n\tfloat f = 0.0;\n\tfloat a = 0.5;\n\tfloat b = 2.0;\n\tfloat c = 0.5;\n\tfloat d = 2.0;\n\tfloat e = 0.5;\n\tfloat f = 2.0;\n\tfloat g = 0.5;\n\tfloat h = 2.0;\n\tfloat i = 0.5;\n\tfloat j = 2.0;\n\tfloat k = 0.5;\n\tfloat l = 2.0;\n\tfloat m = 0.5;\n\tfloat n = 2.0;\n\tfloat o = 0.5;\n\tfloat p = 2.0;\n\tfloat q = 0.5;\n\tfloat r = 2.0;\n\tfloat s = 0.5;\n\tfloat t = 2.0;\n\tfloat u = 0.5;\n\tfloat v = 2.0;\n\tfloat w = 0.5;\n\tfloat x = 2.0;\n\tfloat y = 0.5;\n\tfloat z = 2.0;\n\tfloat A = 0.5;\n\tfloat B = 2.0;\n\tfloat C = 0.5;\n\tfloat D = 2.0;\n\tfloat E = 0.5;\n\tfloat F = 2.0;\n\tfloat G = 0.5;\n\tfloat H = 2.0;\n\tfloat I = 0.5;\n\tfloat J = 2.0;\n\tfloat K = 0.5;\n\tfloat L = 2.0;\n\tfloat M = 0.5;\n\tfloat N = 2.0;\n\tfloat O = 0.5;\n\tfloat P = 2.0;\n\tfloat Q = 0.5;\n\tfloat R = 2.0;\n\tfloat S = 0.5;\n\tfloat T = 2.0;\n\tfloat U = 0.5;\n\tfloat V = 2.0;\n\tfloat W = 0.5;\n\tfloat X = 2.0;\n\t", "\n\tvec3 p = fract(p3.xyz * 0.1031);\n\tp += dot(p, p.yzx + 19.19);\n\treturn fract((p.x + p.y) * p.z);\n}\n\n//simplex noise\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy) );\n\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min( g.xyz, l.zxy );\n\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute(\n\t\t\t i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t+ i.y + vec4(0.", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat t = iTime;\n\tfloat a = 0.0;\n\tfloat d = 0.0;\n\tfloat s = 0.0;\n\tfloat c = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat b = 0.0;\n\tfloat e = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat r = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\tfloat W = 0.0;\n\tfloat X = 0.0;\n\tfloat Y = 0.0;\n\tfloat Z", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(hue, 1.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default class HueShader extends Shader {\n    constructor() {\n        super(vertexShader, fragmentShader);\n    }\n}\n/src/shaders/hue-shader.js\nimport Shader from './shader';\n\nconst vertexShader = `\nattribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision mediump float;\n\nuniform float hue;\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(hue, 1.0, 1.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport default class HueShader extends Shader {\n    constructor() {\n        super(vertexShader, fragmentShader);\n    }\n}\n/src/shaders/shader.js\nimport {\n    ShaderMaterial,\n    BufferGeometry,\n    BufferAttribute,\n    Vector3,\n    Color,\n    Float32Buffer", "\n\treturn fract(p * size);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod2(inout float p, float size) {\n\tfloat q = mod(p, size);\n\treturn mix(q, q - size, step(size, q));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod3(inout float p, float size) {\n\tfloat q = mod(p, size);\n\treturn mix(q, q - size, step(size, q)) * mix(q, q + size, step(size, size - q));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod4(inout float p, float size) {\n\tfloat q = mod(p, size);\n\treturn mix(q, q - size, step(size, q)) * mix(q, q + size, step(size, size - q)) * mix(q, q - size * 2.0, step(size * 2.0, q)) * mix(q, q + size * 2.0, step(size * 2.0, size - q));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod5(inout float p, float size) {\n\tfloat q = mod(p, size);\n\treturn mix(q, q - size, step(size, q)) * mix(q, q + size, step(size, size - q)) * mix(q, q - size * 2.0, step(size * 2.0, q)) * mix(q, q + size * 2.0, step(size * 2.0, size - q)) * mix(q, q - size * 3.0, step(size * 3.0, q)) * mix(q, q", "\n\treturn (co * 127.1) - (int)(co * 127.1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2) {\n\treturn (co * 127.1) - (int)(co * 127.1) + (co2 * 127.1) - (int)(co2 * 127.1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3) {\n\treturn (co * 127.1) - (int)(co * 127.1) + (co2 * 127.1) - (int)(co2 * 127.1) + (co3 * 127.1) - (int)(co3 * 127.1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4) {\n\treturn (co * 127.1) - (int)(co * 127.1) + (co2 * 127.1) - (int)(co2 * 127.1) + (co3 * 127.1) - (int)(co3 * 127.1) + (co4 * 127.1) - (int)(co4 * 127.1);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co, float co2, float co3, float co4, float co5) {\n\treturn (co * 127.1) - (int)(co * 127.1) + (co2 * 127.1) - (int)(co2 * 127.1) + (co3 * 127.1) - (int)(co3 * 127.1) + (co4 * 127.1) - (int)(co4 * 127.1) + (co5", "\n    return t < 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linear(float t) {\n    return t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat gamma(float t) {\n    return pow(t, 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat inverseGamma(float t) {\n    return pow(t, 1.0 / 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linear(vec3 t) {\n    return vec3(linear(t.r), linear(t.g), linear(t.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat gamma(vec3 t) {\n    return vec3(gamma(t.r), gamma(t.g), gamma(t.b));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat inverseGamma(vec3 t) {\n    return vec3(inverseGamma(t.r), inverseGamma(t.g), inverseGamma(t.b));\n}\n\n// License: Unknown", "\n    return pow(c, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 linear(in vec3 c) {\n    return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 gamma(in vec3 c) {\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec4 c) {\n    return pow(c.rgb, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec4 linear(in vec4 c) {\n    return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec4 gamma(in vec4 c) {\n    return pow(c, vec4(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in float c) {\n    return pow(c, 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat linear(in float c) {\n    return c;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat gamma(in float c) {\n    return pow(c, 1.0 / 2.2);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy", "\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b) {\n    return pmin(a, b, 0.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p) {\n    float r = pmin(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n    return pmin(r, a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o) {\n    float r = pmin(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n    return pmin(r, a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n) {\n    float r = pmin(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n    return pmin(r, a);\n}", "\n    float r = sph.w;\n    float r2 = r*r;\n    float d = length(ro-sph.xyz);\n    float d2 = d*d;\n    float b = dot(rd,ro-sph.xyz);\n    float c = d2-r2;\n    float disc = b*b-c;\n    if (disc < 0) return dbuffer;\n    float t = -b-sqrt(disc);\n    if (t < dbuffer) return dbuffer;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float dbuffer2) {\n    float r = sph.w;\n    float r2 = r*r;\n    float d = length(ro-sph.xyz);\n    float d2 = d*d;\n    float b = dot(rd,ro-sph.xyz);\n    float c = d2-r2;\n    float disc = b*b-c;\n    if (disc < 0) return dbuffer2;\n    float t = -b-sqrt(disc);\n    if (t < dbuffer) return dbuffer2;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer, float dbuffer2, float dbuffer3) {\n    float r = sph.w;\n    float r2 = r*r;\n    float d = length(ro-sph.xyz);\n    float d2 = d*d;\n    float b = dot(rd,ro-sph.xyz);\n    float c = d2-r2;\n    float disc = b*b-c;\n    if (disc < 0) return dbuffer3;\n    float t = -b-sqrt(disc);\n    if (t < dbuffer) return dbuffer3;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro,", "\n    vec4 p0 = vec4(p.x, p.y, 0.0, 0.0);\n    vec4 p1 = vec4(p.x, p.y, 1.0, 1.0);\n    vec4 p2 = vec4(p.x, p.y, 2.0, 2.0);\n    vec4 p3 = vec4(p.x, p.y, 3.0, 3.0);\n    vec4 p4 = vec4(p.x, p.y, 4.0, 4.0);\n    vec4 p5 = vec4(p.x, p.y, 5.0, 5.0);\n    vec4 p6 = vec4(p.x, p.y, 6.0, 6.0);\n    vec4 p7 = vec4(p.x, p.y, 7.0, 7.0);\n    vec4 p8 = vec4(p.x, p.y, 8.0, 8.0);\n    vec4 p9 = vec4(p.x, p.y, 9.0, 9.0);\n    vec4 p10 = vec4(p.x, p.y, 10.0, 10.0);\n    vec4 p11 = vec4(p.x, p.y, 11.0, 11.0);\n    vec4 p12 = vec4(p.x, p.y, 12.0, 12.0);\n    vec4 p13 = vec4(p.x, p.y, 13.0, 13.0);\n    vec4 p14 = vec4(p.x, p.y, 14.0, 14.0);\n    vec4 p15 = vec4(p.x, p.y, 15.0, 15.0);\n    vec4 p16 = vec4(p.x, p.y, 16.0, 16.0);\n    vec4 p17 = vec4(p.x, p.y, 17.0, 17.0);\n    vec", "\n\tvec3 q = p / r;\n\tvec3 q2 = q * q;\n\tfloat q2_x = q2.x;\n\tfloat q2_y = q2.y;\n\tfloat q2_z = q2.z;\n\tfloat q2_xy = q2.x * q2.y;\n\tfloat q2_yz = q2.y * q2.z;\n\tfloat q2_zx = q2.z * q2.x;\n\tfloat q2_xyz = q2.x * q2.y * q2.z;\n\tfloat q2_x2 = q2_x * q2_x;\n\tfloat q2_y2 = q2_y * q2_y;\n\tfloat q2_z2 = q2_z * q2_z;\n\tfloat q2_xy2 = q2_xy * q2_xy;\n\tfloat q2_yz2 = q2_yz * q2_yz;\n\tfloat q2_zx2 = q2_zx * q2_zx;\n\tfloat q2_xyz2 = q2_xyz * q2_xyz;\n\tfloat q2_x3 = q2_x2 * q2_x;\n\tfloat q2_y3 = q2_y2 * q2_y;\n\tfloat q2_z3 = q2_z2 * q2_z;\n\tfloat q2_xy3 = q2_xy2 * q2_xy;\n\tfloat q2_yz3 = q2_yz2 * q2_yz;\n\tfloat q2_zx3 = q2_zx2 * q2_zx;\n\tfloat q2_xyz3 = q2_xyz2 * q2_xyz;\n\tfloat q2_x4 = q2_x2 * q2_x2;\n\tfloat q2_y4 = q2_y2 * q2_y2;\n\tfloat q2_z4 = q2_z2 * q2_z2;\n\tfloat q2_xy4 = q2_xy2 * q2_xy2;\n\tfloat q2_yz4 = q2_yz2 * q2_", "\n    return front * front.a + back * (1.0 - front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return front * alpha + back * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n    return front * alpha + back * (1.0 - alpha);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 backAlpha) {\n    return front * alpha + back * (1.0 - alpha) * backAlpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 backAlpha, vec4 frontAlpha) {\n    return front * alpha + back * (1.0 - alpha) * backAlpha * frontAlpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 backAlpha, vec4 frontAlpha, vec4 backFrontAlpha) {\n    return front * alpha + back * (1.0 - alpha) * backAlpha * frontAlpha * backFrontAlpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 backAlpha, vec4 frontAlpha, vec4 backFrontAlpha, vec4 frontBackAlpha) {\n    return front * alpha + back * (1.0 - alpha) * backAlpha * frontAlpha * backFrontAlpha * frontBackAlpha;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 backAlpha, vec4 frontAlpha, vec4 backFrontAlpha, vec4 frontBackAlpha, vec4 backFrontBackAlpha) {\n    return front * alpha + back * (1.0 - alpha) * backAlpha * frontAlpha * backFrontAlpha *", "\n    return front.a * front.rgb + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return front + (1.0 - front.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha) {\n    return front * alpha + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha) {\n    return front * alpha + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha) {\n    return front * alpha.rgb + (1.0 - alpha.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, float alpha2) {\n    return front * alpha + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, float alpha2) {\n    return front * alpha + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec4 alpha, float alpha2) {\n    return front * alpha.rgb + (1.0 - alpha.a) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, float alpha, vec3 alpha2) {\n    return front * alpha + (1.0 - alpha) * back;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front, vec3 alpha, vec3 alpha2) {\n    return front * alpha +", "\n    vec2 q = abs(p) - vec2(r, r*0.86602540378443864676372317075294);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h ) {\n    vec2 q = abs(p) - vec2(r, r*0.86602540378443864676372317075294);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r + h;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s ) {\n    vec2 q = abs(p) - vec2(r, r*0.86602540378443864676372317075294);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r + h + s;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r, float h, float s, float t ) {\n    vec2 q = abs(p) - vec2(r, r*0.86602540378443864676372317075294);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r + h + s", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_filmic(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_filmic_inverse(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (c * v + d) + e) / (v * (a * v + b)), 0.0f, 1.0f);\n}\n\n// License: Unknown, author:  (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_filmic_inverse_approx(vec3 v) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v * (c * v + d)", "\n    p = fract(sin(p) * 43758.5453123);\n    return fract(p * p * (34.0 + p * vec2(0.0, 103.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash3(vec3 p) {\n    p = fract(sin(p) * 43758.5453123);\n    return fract(p * p * (34.0 + p * vec3(0.0, 103.0, 107.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash4(vec4 p) {\n    p = fract(sin(p) * 43758.5453123);\n    return fract(p * p * (34.0 + p * vec4(0.0, 103.0, 107.0, 113.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n    return hash2(p);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 p) {\n    return hash3(p);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 p) {\n    return hash4(p);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float p) {\n    return hash(vec4(p));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(int p) {\n    return hash(float(p));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(uint p) {\n    return hash(float(p));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(ivec2 p) {\n    return hash(vec2(p));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(ivec", "\n    vec3 color;\n    float x = Temp / 5000.0;\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float x4 = x3 * x;\n    float x5 = x4 * x;\n    float x6 = x5 * x;\n    float x7 = x6 * x;\n    float x8 = x7 * x;\n    float x9 = x8 * x;\n    float x10 = x9 * x;\n    float x11 = x10 * x;\n    float x12 = x11 * x;\n    float x13 = x12 * x;\n    float x14 = x13 * x;\n    float x15 = x14 * x;\n    float x16 = x15 * x;\n    float x17 = x16 * x;\n    float x18 = x17 * x;\n    float x19 = x18 * x;\n    float x20 = x19 * x;\n    float x21 = x20 * x;\n    float x22 = x21 * x;\n    float x23 = x22 * x;\n    float x24 = x23 * x;\n    float x25 = x24 * x;\n    float x26 = x25 * x;\n    float x27 = x26 * x;\n    float x28 = x27 * x;\n    float x29 = x28 * x;\n    float x30 = x29 * x;\n    float x31 = x30 * x;\n    float x32 = x31 * x;\n    float x33 = x32 * x;\n    float x34 = x33 * x;\n    float x35 = x34 * x;\n    float x36 = x35 * x;\n    float x37 = x36 * x;\n    float x38 = x37 * x;\n    float x39 = x38 * x;\n    float x40 = x39 * x;\n    float x41 = x40 * x;\n    float x42 = x41 * x;\n    float x43 = x42 * x;\n    float x44 = x", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 u = f * f * f * (vec2(12.9898, 78.233) * i + vec2(12.9898, 12.9898));\n    return fract(sin(dot(u, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p.xy); p = p * 2.02;\n    f += 0.2500 * noise(p.xy); p = p * 2.03;\n    f += 0.1250 * noise(p.xy); p = p * 2.01;\n    f += 0.0625 * noise(p.xy);\n    return f / 0.9375;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat fbm(vec4 p) {\n    float f = 0.0;\n    f +=", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec2(1.0);\n    discr = sqrt(discr);\n    float t = -b - discr;\n    if (t < 0.0) t = -b + discr;\n    return vec2(t, t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sc, vec3 sp, float sr) {\n    vec3 oc = ro - sp;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec2(1.0);\n    discr = sqrt(discr);\n    float t = -b - discr;\n    if (t < 0.0) t = -b + discr;\n    return vec2(t, t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sc, vec3 sp, float sr) {\n    vec3 oc = ro - sp;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec2(1.0);\n    discr = sqrt(discr);\n    float t = -b - discr;\n    if (t < 0.0) t = -b + discr;\n    return vec2(t, t);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec3 sc, vec3 sp,", "\nfloat a = 1.0;\nfloat b = 1.0;\nfloat c = 1.0;\nfloat d = 1.0;\nfloat e = 1.0;\nfloat f = 1.0;\nfloat g = 1.0;\nfloat h = 1.0;\nfloat i = 1.0;\nfloat j = 1.0;\nfloat k = 1.0;\nfloat l = 1.0;\nfloat m = 1.0;\nfloat n = 1.0;\nfloat o = 1.0;\nfloat p = 1.0;\nfloat q = 1.0;\nfloat r = 1.0;\nfloat s = 1.0;\nfloat t = 1.0;\nfloat u = 1.0;\nfloat v = 1.0;\nfloat w = 1.0;\nfloat x = 1.0;\nfloat y = 1.0;\nfloat z = 1.0;\nfloat A = 1.0;\nfloat B = 1.0;\nfloat C = 1.0;\nfloat D = 1.0;\nfloat E = 1.0;\nfloat F = 1.0;\nfloat G = 1.0;\nfloat H = 1.0;\nfloat I = 1.0;\nfloat J = 1.0;\nfloat K = 1.0;\nfloat L = 1.0;\nfloat M = 1.0;\nfloat N = 1.0;\nfloat O = 1.0;\nfloat P = 1.0;\nfloat Q = 1.0;\nfloat R = 1.0;\nfloat S = 1.0;\nfloat T = 1.0;\nfloat U = 1.0;\nfloat V = 1.0;\nfloat W = 1.0;\nfloat X = 1.0;\nfloat Y = 1.0;\nfloat Z = 1.0;\nfloat AA = 1.0;\nfloat AB = 1.0;\nfloat AC = 1.0;\nfloat AD = 1.0;\nfloat AE = 1.0", "\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat w = 0.0;\n\tfloat v = 0.0;\n\tfloat u = 0.0;\n\tfloat s = 0.0;\n\tfloat r = 0.0;\n\tfloat q = 0.0;\n\tfloat p = 0.0;\n\tfloat o = 0.0;\n\tfloat n = 0.0;\n\tfloat m = 0.0;\n\tfloat l = 0.0;\n\tfloat k = 0.0;\n\tfloat j = 0.0;\n\tfloat i = 0.0;\n\tfloat h = 0.0;\n\tfloat g = 0.0;\n\tfloat f = 0.0;\n\tfloat e = 0.0;\n\tfloat d = 0.0;\n\tfloat c = 0.0;\n\tfloat b = 0.0;\n\tfloat a = 0.0;\n\tfloat _ = 0.0;\n\tfloat __ = 0.0;\n\tfloat ___ = 0.0;\n\tfloat ____ = 0.0;\n\tfloat _____ = 0.0;\n\tfloat ______ = 0.0;\n\tfloat _______ = 0.0;\n\tfloat ________ = 0.0;\n\tfloat _________ = 0.0;\n\tfloat __________ = 0.0;\n\tfloat ___________ = 0.0;\n\tfloat ____________ = 0.0;\n\tfloat _____________ = 0.0;\n\tfloat ______________ = 0.0;\n\tfloat _______________ = 0.0;\n\tfloat ________________ = 0.0;\n\tfloat __________________ = 0.0;\n\tfloat ___________________ = 0.0;\n\tfloat ____________________ = 0.0;\n\tfloat _____________________ = 0.0;\n\tfloat ______________________ = 0.0;\n\tfloat _______________________ = 0.0;\n\tfloat ________________________ = 0.0;\n\tfloat _________________________ = 0", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float h )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - h;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float h, in float d )\n{\n\tvec2 d1 = abs(p) - b;\n\treturn length(max(d1,0.0)) + min(max(d1.x,d1.y),0.0) - r - h - d;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float h, in float d, in float w )\n{\n\tvec2 d1 = abs(p) - b;\n\treturn length(max(d1,0.0)) + min(max(d1.x,d1.y),0.0) - r - h - d - w;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r, in float h, in float d, in float w", "\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt = fractal(p, idx);\n\t\tp = p + t;\n\t}\n\treturn t;\n}\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt", "\n    float r;\n    float abs_y = abs(y) + 1e-10;      // kludge to prevent 0/0 condition\n    r = atan(x / abs_y);\n    if (y < 0)\n        r = PI - r;\n    else if (x < 0)\n        r = PI - r;\n    return r;\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(dot(i, i + vec2(1.0, 0.0)), dot(i + vec2(1.0, 0.0), i + vec2(1.0, 1.0)), u.x), mix(dot(i + vec2(0.0, 1.0), i + vec2(1.0, 1.0)), dot(i, i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/4dS3Wc\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(i, i + vec3(1.0, 0.0, 0.0)), dot(i + vec3(1.0, 0.0, 0.0), i + vec3(1.0, 1.0, 0.0)), u.x), mix(dot(i + vec3(0.0, 1.0, 0.0), i + vec3(1.0, 1.0, 0.0)), dot(i, i + vec3(1.0, 1.0, 0.0)), u.x), u.y), mix(mix(dot(i + vec3(0.0, 0.0, 1.0), i + vec3", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return cmul(z, vec2(w.x, -w.y) / (w.x * w.x + w.y * w.y)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(length(z)), atan2(z.y, z.x)); }\nvec2 cpow(vec2 z, vec2 w) { return cexp(w * clog(z)); }\nvec2 csqrt(vec2 z) { return cexp(0.5 * clog(z)); }\nvec2 csin(vec2 z) { return cmul(z, vec2(cos(z.y), sin(z.y))); }\nvec2 ccos(vec2 z) { return cmul(z, vec2(cos(z.y), -sin(z.y))); }\nvec2 ctan(vec2 z) { return cdiv(csin(z), ccos(z)); }\nvec2 csinh(vec2 z) { return cmul(z, vec2(cosh(z.y), sinh(z.y))); }\nvec2 ccosh(vec2 z) { return cmul(z, vec2(cosh(z.y), sinh(z.y))); }\nvec2 ctanh(vec2 z) { return cdiv(csinh(z), ccosh(z)); }\nvec2 casin(vec2 z) { return clog(vec2(sqrt(1.0 - z.x * z.x), z.y) + vec2(0.0, 1.0)); }\nvec2 cacos(vec2 z) { return clog(vec2(sqrt(1.0 - z.x * z.x), -z.y) + vec2(0.0, 1.0)); }\nvec2", "\n\treturn log(z + 1.0) - log(1.0 - z);\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n\treturn log(z + sqrt(z * z - 1.0));\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n\treturn log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic tangent \nvec2 catan(vec2 z) {\n\treturn log((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n\treturn log((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n\treturn log((z + sqrt(z * z - 1.0)) / 2.0);\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n\treturn log((z + sqrt(z * z + 1.0)) / 2.0);\n}\n\n// Inverse hyperbolic tangent \nvec2 catan(vec2 z) {\n\treturn log((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n\treturn log((1.0 + z) / (1.0 - z)) / 2.0;\n}\n\n// Inverse hyperbolic cosine \nvec2 cacosh(vec2 z) {\n\treturn log((z + sqrt(z * z - 1.0)) / 2.0);\n}\n\n// Inverse hyperbolic sine \nvec2 casinh(vec2 z) {\n\treturn log((z + sqrt(z * z + 1.0)) / 2.0);\n}\n\n// Inverse hyperbolic tangent \nvec2 catan(", "\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an csinh\nvec2 csinh(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an ccosh\nvec2 ccosh(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an catanh\nvec2 catanh(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an csin\nvec2 csin(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an ccos\nvec2 ccos(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z.y;\n}\n\n// My own attempt at an catan\nvec2 catan(vec2 z) {\n\tvec2 c = vec2(cos(z.x), sin(z.x));\n\tvec2 s = vec2(sin(z.x), cos(z.x));\n\treturn c + s * z", " return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x); }\nvec2 cdiv(vec2 z, vec2 w) { return cmul(z, vec2(w.x, -w.y) / (w.x * w.x + w.y * w.y)); }\nvec2 cexp(vec2 z) { return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\nvec2 clog(vec2 z) { return vec2(log(length(z)), atan2(z.y, z.x)); }\nvec2 cpow(vec2 z, vec2 w) { return cexp(w * clog(z)); }\nvec2 csqrt(vec2 z) { return cexp(0.5 * clog(z)); }\nvec2 csin(vec2 z) { return cmul(z, vec2(cos(z.y), sin(z.y))); }\nvec2 ccos(vec2 z) { return cmul(z, vec2(cos(z.y), -sin(z.y))); }\nvec2 ctan(vec2 z) { return cdiv(csin(z), ccos(z)); }\nvec2 csinh(vec2 z) { return cmul(z, vec2(cosh(z.y), sinh(z.y))); }\nvec2 ccosh(vec2 z) { return cmul(z, vec2(cosh(z.y), sinh(z.y))); }\nvec2 ctanh(vec2 z) { return cdiv(csinh(z), ccosh(z)); }\nvec2 casin(vec2 z) { return clog(vec2(sqrt(1.0 - z.x * z.x), z.y) + vec2(0.0, 1.0)); }\nvec2 cacos(vec2 z) { return clog(vec2(sqrt(1.0 - z.x * z.x), -z.y) + vec2(0.0, 1.0)); }\nvec2", "\n\treturn vec2(exp(z.x), exp(z.y));\n}\n\nvec2 clog(vec2 z) {\n\treturn vec2(log(z.x), log(z.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n\treturn vec2(pow(z.x, w.x), pow(z.y, w.y));\n}\n\nvec2 csqrt(vec2 z) {\n\treturn vec2(sqrt(z.x), sqrt(z.y));\n}\n\nvec2 csin(vec2 z) {\n\treturn vec2(sin(z.x), sin(z.y));\n}\n\nvec2 ccos(vec2 z) {\n\treturn vec2(cos(z.x), cos(z.y));\n}\n\nvec2 ctan(vec2 z) {\n\treturn vec2(tan(z.x), tan(z.y));\n}\n\nvec2 catan(vec2 z) {\n\treturn vec2(atan(z.x), atan(z.y));\n}\n\nvec2 csinh(vec2 z) {\n\treturn vec2(sinh(z.x), sinh(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n\treturn vec2(cosh(z.x), cosh(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n\treturn vec2(tanh(z.x), tanh(z.y));\n}\n\nvec2 catanh(vec2 z) {\n\treturn vec2(atanh(z.x), atanh(z.y));\n}\n\nvec2 cabs(vec2 z) {\n\treturn vec2(abs(z.x), abs(z.y));\n}\n\nvec2 carg(vec2 z) {\n\treturn vec2(arg(z.x), arg(z.y));\n}\n\nvec2 cproj(vec2 z) {\n\treturn vec2(proj(z.x), proj(z.y));\n}\n\nvec2 cdist(vec2 z, vec2 w) {\n\treturn vec2(", "\n\treturn vec4(\n\t\tsmoothstep(0.0, 1.0, alpha.r * contrast),\n\t\tsmoothstep(0.0, 1.0, alpha.g * contrast),\n\t\tsmoothstep(0.0, 1.0, alpha.b * contrast),\n\t\talpha.a\n\t);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec4 contrast) {\n\treturn vec4(\n\t\tsmoothstep(0.0, 1.0, alpha.r * contrast.r),\n\t\tsmoothstep(0.0, 1.0, alpha.g * contrast.g),\n\t\tsmoothstep(0.0, 1.0, alpha.b * contrast.b),\n\t\talpha.a\n\t);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrastR, float contrastG, float contrastB) {\n\treturn vec4(\n\t\tsmoothstep(0.0, 1.0, alpha.r * contrastR),\n\t\tsmoothstep(0.0, 1.0, alpha.g * contrastG),\n\t\tsmoothstep(0.0, 1.0, alpha.b * contrastB),\n\t\talpha.a\n\t);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, vec3 contrast) {\n\treturn vec4(\n\t\tsmoothstep(0.0, 1.0, alpha.r * contrast.r),\n\t\tsmoothstep(0.0, 1.0, alpha.g * contrast.g),\n\t\tsmoothstep(0.0, 1.0, alpha.b * contrast", "\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icoDist(vec3 p) {\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Octahedron\nfloat octDist(vec3 p) {\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.", "\n\tvec3 v = uvw;\n\tvec3 v1 = v;\n\tvec3 v2 = v;\n\tvec3 v3 = v;\n\tvec3 v4 = v;\n\tvec3 v5 = v;\n\tvec3 v6 = v;\n\tvec3 v7 = v;\n\tvec3 v8 = v;\n\tvec3 v9 = v;\n\tvec3 v10 = v;\n\tvec3 v11 = v;\n\tvec3 v12 = v;\n\tvec3 v13 = v;\n\tvec3 v14 = v;\n\tvec3 v15 = v;\n\tvec3 v16 = v;\n\tvec3 v17 = v;\n\tvec3 v18 = v;\n\tvec3 v19 = v;\n\tvec3 v20 = v;\n\tvec3 v21 = v;\n\tvec3 v22 = v;\n\tvec3 v23 = v;\n\tvec3 v24 = v;\n\tvec3 v25 = v;\n\tvec3 v26 = v;\n\tvec3 v27 = v;\n\tvec3 v28 = v;\n\tvec3 v29 = v;\n\tvec3 v30 = v;\n\tvec3 v31 = v;\n\tvec3 v32 = v;\n\tvec3 v33 = v;\n\tvec3 v34 = v;\n\tvec3 v35 = v;\n\tvec3 v36 = v;\n\tvec3 v37 = v;\n\tvec3 v38 = v;\n\tvec3 v39 = v;\n\tvec3 v40 = v;\n\tvec3 v41 = v;\n\tvec3 v42 = v;\n\tvec3 v43 = v;\n\tvec3 v44 = v;\n\tvec3 v45 = v;\n\tvec3 v46 = v;\n\tvec3 v47 = v;\n\tvec3 v48 = v;\n\tvec3 v49 = v;\n\tvec3 v50 = v;\n\tvec3 v51 = v;\n\t", "\n\tfloat u = uvw.x;\n\tfloat v = uvw.y;\n\tfloat w = uvw.z;\n\tfloat x = u + offset.x;\n\tfloat y = v + offset.y;\n\tfloat z = w + offset.z;\n\tfloat a = 1.0f / 3.0f;\n\tfloat b = 1.0f / 2.0f;\n\tfloat c = 1.0f;\n\tfloat d = 1.0f / 3.0f;\n\tfloat e = 1.0f / 2.0f;\n\tfloat f = 1.0f;\n\tfloat g = 1.0f / 3.0f;\n\tfloat h = 1.0f / 2.0f;\n\tfloat i = 1.0f;\n\tfloat j = 1.0f / 3.0f;\n\tfloat k = 1.0f / 2.0f;\n\tfloat l = 1.0f;\n\tfloat m = 1.0f / 3.0f;\n\tfloat n = 1.0f / 2.0f;\n\tfloat o = 1.0f;\n\tfloat p = 1.0f / 3.0f;\n\tfloat q = 1.0f / 2.0f;\n\tfloat r = 1.0f;\n\tfloat s = 1.0f / 3.0f;\n\tfloat t = 1.0f / 2.0f;\n\tfloat u1 = 1.0f;\n\tfloat v1 = 1.0f / 3.0f;\n\tfloat w1 = 1.0f / 2.0f;\n\tfloat x1 = 1.0f;\n\tfloat y1 = 1.0f / 3.0f;\n\tfloat z1 = 1.0f / 2.0f;\n\tfloat a1 = 1.0f;\n\tfloat b1 = 1.0f / 3.0f;\n\tfloat c1 = 1.0f / 2.0f;\n", "\n\tfloat gridSize = 1.0 / gridRes;\n\tfloat gridOffset = 0.5 / gridRes;\n\tfloat gridOffset2 = 0.25 / gridRes;\n\tfloat gridOffset3 = 0.75 / gridRes;\n\tfloat gridOffset4 = 0.25 / gridRes;\n\tfloat gridOffset5 = 0.75 / gridRes;\n\tfloat gridOffset6 = 0.5 / gridRes;\n\tfloat gridOffset7 = 0.25 / gridRes;\n\tfloat gridOffset8 = 0.75 / gridRes;\n\tfloat gridOffset9 = 0.5 / gridRes;\n\tfloat gridOffset10 = 0.25 / gridRes;\n\tfloat gridOffset11 = 0.75 / gridRes;\n\tfloat gridOffset12 = 0.5 / gridRes;\n\tfloat gridOffset13 = 0.25 / gridRes;\n\tfloat gridOffset14 = 0.75 / gridRes;\n\tfloat gridOffset15 = 0.5 / gridRes;\n\tfloat gridOffset16 = 0.25 / gridRes;\n\tfloat gridOffset17 = 0.75 / gridRes;\n\tfloat gridOffset18 = 0.5 / gridRes;\n\tfloat gridOffset19 = 0.25 / gridRes;\n\tfloat gridOffset20 = 0.75 / gridRes;\n\tfloat gridOffset21 = 0.5 / gridRes;\n\tfloat gridOffset22 = 0.25 / gridRes;\n\tfloat gridOffset23 = 0.75 / gridRes;\n\tfloat gridOffset24 = 0.5 / gridRes;\n\tfloat gridOffset25 = 0.25 / gridRes;\n\tfloat gridOffset26 = 0.75 / gridRes;\n\tfloat gridOffset27 = 0.5 / gridRes;\n\tfloat gridOffset28 = 0.25 / gridRes;\n\tfloat gridOffset29 = 0.75 / gridRes;\n\tfloat gridOffset30 = 0.5 / gridRes;\n\tfloat gridOffset31 =", "\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 n) {\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 n, vec3 p2) {\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 n, vec3 p2, vec3 n2) {\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 n, vec3 p2, vec3 n2, vec3 p3) {\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, vec3 n, vec3 p2, vec3 n2, vec3 p3, vec3 n3) {\n\tfloat d = 0.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\td += length(p - IcoVerts[i]);\n\t}\n\treturn d;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p", "\n\treturn vec3(\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t),\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * t,\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * t * t,\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * t * t * t,\n\t\t(1.0 - t) * (1.0 - t) * t * t * t * t,\n\t\t(1.0 - t) * t * t * t * t * t,\n\t\tt * t * t * t * t * t\n\t);\n}\n\n// makes Hot colormap with polynimal 6\nvec3 Hot(float t) {\n\treturn vec3(\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t),\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * t,\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * (1.0 - t) * t * t,\n\t\t(1.0 - t) * (1.0 - t) * (1.0 - t) * t * t * t,\n\t\t(1.0 - t) * (1.0 - t) * t * t * t * t,\n\t\t(1.0 - t) * t * t * t * t * t,\n\t\tt * t * t * t * t * t\n\t);\n}\n\n// makes Bone colormap with polynimal 6\nvec3 Bone(float t) {", "\n\treturn v * cos(a.x) + cross(a, v) * sin(a.x) + cross(cross(a, v), a) * (1.0 - cos(a.x));\n}\n\n// returns the color of a pixel\nvec3 getColor(vec2 uv)\n{\n\tvec3 color = vec3(0.0);\n\tvec3 normal = vec3(0.0);\n\tvec3 position = vec3(0.0);\n\tvec3 lightDir = vec3(0.0);\n\tvec3 lightColor = vec3(0.0);\n\tvec3 viewDir = vec3(0.0);\n\tvec3 reflectDir = vec3(0.0);\n\tvec3 reflectColor = vec3(0.0);\n\tvec3 refractDir = vec3(0.0);\n\tvec3 refractColor = vec3(0.0);\n\tvec3 refractColor2 = vec3(0.0);\n\tvec3 refractColor3 = vec3(0.0);\n\tvec3 refractColor4 = vec3(0.0);\n\tvec3 refractColor5 = vec3(0.0);\n\tvec3 refractColor6 = vec3(0.0);\n\tvec3 refractColor7 = vec3(0.0);\n\tvec3 refractColor8 = vec3(0.0);\n\tvec3 refractColor9 = vec3(0.0);\n\tvec3 refractColor10 = vec3(0.0);\n\tvec3 refractColor11 = vec3(0.0);\n\tvec3 refractColor12 = vec3(0.0);\n\tvec3 refractColor13 = vec3(0.0);\n\tvec3 refractColor14 = vec3(0.0);\n\tvec3 refractColor15 = vec3(0.0);\n\tvec3 refractColor16 = vec3(0.0);\n\tvec3 refractColor17 = vec3(0.0);\n\tvec3 refractColor18 = vec3(0.0);\n\tvec3 refractColor19 = vec3(0.0);\n\tvec3", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec3 co) {\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,12.9898))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec4 co) {\n    return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,12.9898,12.9898))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n    return fract(sin(co) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(int co) {\n    return fract(sin(float(co)) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(uint co) {\n    return fract(sin(float(co)) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(ivec2 co) {\n    return fract(sin(dot(float(co.xy),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(ivec3 co) {\n    return fract(sin(dot(float(co.xyz),vec3(12.9898,78.233,12.9898))) * 43758.5453", "\n\treturn abs(p.x) + abs(p.y) + abs(p.x + p.y);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q) {\n\treturn hexDist(p - q);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r) {\n\treturn hexDist(p - q) + hexDist(p - r);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r, vec2 s) {\n\treturn hexDist(p - q) + hexDist(p - r) + hexDist(p - s);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r, vec2 s, vec2 t) {\n\treturn hexDist(p - q) + hexDist(p - r) + hexDist(p - s) + hexDist(p - t);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r, vec2 s, vec2 t, vec2 u) {\n\treturn hexDist(p - q) + hexDist(p - r) + hexDist(p - s) + hexDist(p - t) + hexDist(p - u);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r, vec2 s, vec2 t, vec2 u, vec2 v) {\n\treturn hexDist(p - q) + hexDist(p - r) + hexDist(p - s) + hexDist(p - t) + hexDist(p - u) + hexDist(p - v);\n}\n\n// Hexagonal Distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 q, vec2 r, vec2 s, vec2 t, vec2 u, vec2 v, vec2 w) {\n\treturn hexDist(p - q) +", "\n\tvec2 p = uv * 2.0 - 1.0;\n\tvec2 q = vec2(p.x, -p.y);\n\tvec2 r = vec2(-p.x, -p.y);\n\tvec2 s = vec2(-p.x, p.y);\n\tvec2 t = vec2(p.x, p.y);\n\tvec2 u = vec2(q.x, p.y);\n\tvec2 v = vec2(r.x, p.y);\n\tvec2 w = vec2(s.x, p.y);\n\tvec2 x = vec2(t.x, p.y);\n\tvec2 y = vec2(q.x, r.y);\n\tvec2 z = vec2(r.x, r.y);\n\tvec2 a = vec2(s.x, r.y);\n\tvec2 b = vec2(t.x, r.y);\n\tvec2 c = vec2(q.x, s.y);\n\tvec2 d = vec2(r.x, s.y);\n\tvec2 e = vec2(s.x, s.y);\n\tvec2 f = vec2(t.x, s.y);\n\tvec2 g = vec2(q.x, t.y);\n\tvec2 h = vec2(r.x, t.y);\n\tvec2 i = vec2(s.x, t.y);\n\tvec2 j = vec2(t.x, t.y);\n\tvec2 k = vec2(q.x, u.y);\n\tvec2 l = vec2(r.x, u.y);\n\tvec2 m = vec2(s.x, u.y);\n\tvec2 n = vec2(t.x, u.y);\n\tvec2 o = vec2(q.x, v.y);\n\tvec2 p = vec2(r.x, v.y);\n\tvec2 q_ = vec2(s.x, v.y);\n\tvec2 r_ = vec2(t.x, v.y);\n\tvec2 s_ = vec2(q.x,", "\n\tfloat p = pow(t, 6.0);\n\treturn vec3(p, 1.0 - p, 1.0 - p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 magma(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, 1.0 - p, p);\n}\n\n// makes inferno colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 inferno(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, p, p);\n}\n\n// makes plasma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 plasma(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, 1.0 - p, p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 magma(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, 1.0 - p, p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 magma(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, 1.0 - p, p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 magma(float t) {\n\tfloat p = pow(t, 6.0);\n\treturn vec3(1.0 - p, 1.0 - p, p);\n}\n\n// makes magma colormap with polynimal 6 https://www.shadertoy.com/view/Nd", "\n\treturn (x + 1) / 2;\n}\n\n//returns a random float between -1 and 1\nfloat randomFloat() {\n\treturn (rand() % 2000 - 1000) / 1000.0;\n}\n\n//returns a random float between 0 and 1\nfloat randomFloat0to1() {\n\treturn rand() / (float)RAND_MAX;\n}\n\n//returns a random float between min and max\nfloat randomFloat(float min, float max) {\n\treturn min + (max - min) * randomFloat0to1();\n}\n\n//returns a random int between min and max\nint randomInt(int min, int max) {\n\treturn min + rand() % (max - min + 1);\n}\n\n//returns a random int between 0 and max\nint randomInt(int max) {\n\treturn rand() % (max + 1);\n}\n\n//returns a random int between 0 and 1\nint randomInt0to1() {\n\treturn rand() % 2;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1() {\n\treturn rand() % 3 - 1;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_signed() {\n\treturn rand() % 3 - 1;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_unsigned() {\n\treturn rand() % 3;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_signed_signed() {\n\treturn rand() % 3 - 1;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_signed_unsigned() {\n\treturn rand() % 3;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_unsigned_signed() {\n\treturn rand() % 3 - 1;\n}\n\n//returns a random int between -1 and 1\nint randomInt_1to1_unsigned_unsigned() {\n", "\n    float res = 1.0 / gridRes;\n    float cellSize = 1.0 / gridRes;\n    float cellSize2 = cellSize * 0.5;\n    float cellSize3 = cellSize * 0.33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float t = time * 0.01;\n    float s = sin(t);\n    float c = cos(t);\n    float a = 0.0;\n    float b = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float a", "\n\tvec2 dir = normalize(point);\n\tfloat dist = length(point);\n\tfloat angle = atan(dir.y, dir.x);\n\tfloat speed = 1.0 + 0.5 * sin(time * 0.5);\n\tfloat radius2 = radius * speed;\n\tfloat radius3 = radius2 * speed;\n\tfloat radius4 = radius3 * speed;\n\tfloat radius5 = radius4 * speed;\n\tfloat radius6 = radius5 * speed;\n\tfloat radius7 = radius6 * speed;\n\tfloat radius8 = radius7 * speed;\n\tfloat radius9 = radius8 * speed;\n\tfloat radius10 = radius9 * speed;\n\tfloat radius11 = radius10 * speed;\n\tfloat radius12 = radius11 * speed;\n\tfloat radius13 = radius12 * speed;\n\tfloat radius14 = radius13 * speed;\n\tfloat radius15 = radius14 * speed;\n\tfloat radius16 = radius15 * speed;\n\tfloat radius17 = radius16 * speed;\n\tfloat radius18 = radius17 * speed;\n\tfloat radius19 = radius18 * speed;\n\tfloat radius20 = radius19 * speed;\n\tfloat radius21 = radius20 * speed;\n\tfloat radius22 = radius21 * speed;\n\tfloat radius23 = radius22 * speed;\n\tfloat radius24 = radius23 * speed;\n\tfloat radius25 = radius24 * speed;\n\tfloat radius26 = radius25 * speed;\n\tfloat radius27 = radius26 * speed;\n\tfloat radius28 = radius27 * speed;\n\tfloat radius29 = radius28 * speed;\n\tfloat radius30 = radius29 * speed;\n\tfloat radius31 = radius30 * speed;\n\tfloat radius32 = radius31 * speed;\n\tfloat radius33 = radius32 * speed;\n\tfloat radius34 = radius33 * speed;\n\tfloat radius35 = radius34 * speed;\n\tfloat radius36 = radius35 * speed;\n\tfloat radius37 = radius36 * speed;\n\tfloat radius", "\n\treturn vec2(floor(pos.x / tileSize), floor(pos.y / tileSize));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n\treturn vec2(floor(pos.x / tileSize.x), floor(pos.y / tileSize.y));\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileCount) {\n\treturn vec2(floor(pos.x / tileSize.x) * tileSize.x, floor(pos.y / tileSize.y) * tileSize.y);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileCount, vec2 tileOffset) {\n\treturn vec2(floor(pos.x / tileSize.x) * tileSize.x + tileOffset.x, floor(pos.y / tileSize.y) * tileSize.y + tileOffset.y);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileCount, vec2 tileOffset, vec2 tileScale) {\n\treturn vec2(floor(pos.x / tileSize.x) * tileSize.x * tileScale.x + tileOffset.x, floor(pos.y / tileSize.y) * tileSize.y * tileScale.y + tileOffset.y);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tileCount, vec2 tileOffset, vec2 tileScale, vec2 tileCountScale) {\n\treturn vec2(floor(pos.x / tileSize.x) * tileSize.x * tileScale.x * tileCountScale.x + tileOffset.x, floor(pos.y / tileSize.y) * tileSize.y * tileScale.y * tileCountScale.y + tileOffset.y);\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord", "\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat c1 = dot(w, v);\n\tfloat c2 = dot(v, v);\n\tfloat b = c1 / c2;\n\tif (b < 0.0) {\n\t\treturn length(p - p1);\n\t}\n\tif (b > 1.0) {\n\t\treturn length(p - p2);\n\t}\n\treturn length(p - (p1 + b * v));\n}\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n\tfloat a = 0.5 * length(cross(p2 - p1, p3 - p1));\n\tfloat s = 1.0 / (2.0 * a);\n\tvec2 v = s * cross(p2 - p1, p3 - p1);\n\tvec2 w = s * cross(p - p1, p3 - p1);\n\tfloat c1 = dot(w, v);\n\tfloat c2 = dot(v, v);\n\tfloat b = c1 / c2;\n\tif (b < 0.0) {\n\t\treturn length(p - p1);\n\t}\n\tif (b > 1.0) {\n\t\treturn length(p - p2);\n\t}\n\tvec2 w2 = s * cross(p - p1, p2 - p1);\n\tfloat c3 = dot(w2, v);\n\tif (c3 < 0.0) {\n\t\treturn length(p - p1);\n\t}\n\tif (c3 > 1.0) {\n\t\treturn length(p - p2);\n\t}\n\tfloat c4 = -dot(w, w2);\n\tif (c4 < 0.0) {\n\t\treturn length(p - p1);\n\t}\n\tif (c4 > a) {\n\t\treturn length(p - p2);\n\t}\n\treturn c3 * c3 * s;\n}\n\n// Computes the signed distance from a polygon\nfloat polygon(vec2 p, vec", "\n    float d = 0.0;\n    float l = length(v);\n    if (l > 0.0) {\n        float s = 1.0 / l;\n        v *= s;\n        float a = 0.0;\n        float b = 0.0;\n        float c = 0.0;\n        float d = 0.0;\n        float e = 0.0;\n        float f = 0.0;\n        float g = 0.0;\n        float h = 0.0;\n        float i = 0.0;\n        float j = 0.0;\n        float k = 0.0;\n        float l = 0.0;\n        float m = 0.0;\n        float n = 0.0;\n        float o = 0.0;\n        float p = 0.0;\n        float q = 0.0;\n        float r = 0.0;\n        float s = 0.0;\n        float t = 0.0;\n        float u = 0.0;\n        float v = 0.0;\n        float w = 0.0;\n        float x = 0.0;\n        float y = 0.0;\n        float z = 0.0;\n        float A = 0.0;\n        float B = 0.0;\n        float C = 0.0;\n        float D = 0.0;\n        float E = 0.0;\n        float F = 0.0;\n        float G = 0.0;\n        float H = 0.0;\n        float I = 0.0;\n        float J = 0.0;\n        float K = 0.0;\n        float L = 0.0;\n        float M = 0.0;\n        float N = 0.0;\n        float O = 0.0;\n        float P = 0.0;\n        float Q = 0.0;\n        float R = 0.0;\n        float S = 0.0;\n        float T = 0.0;\n        float U = 0.0;\n        float V = 0.0;\n        float W = 0.0;\n        float X = 0.0;\n        float Y = 0.0;\n        float Z = 0.0;", "\n\treturn (x + 1.0) / 2.0;\n}\n\n//returns a random float between 0 and 1\nfloat rand0to1() {\n\treturn (float)rand() / (float)RAND_MAX;\n}\n\n//returns a random float between -1 and 1\nfloat randm1to1() {\n\treturn (float)rand() / (float)RAND_MAX * 2.0 - 1.0;\n}\n\n//returns a random float between min and max\nfloat rand(float min, float max) {\n\treturn min + (float)rand() / (float)RAND_MAX * (max - min);\n}\n\n//returns a random float between -1 and 1\nvec2 randm1to1(vec2 x) {\n\treturn vec2(randm1to1(), randm1to1());\n}\n\n//returns a random float between 0 and 1\nvec2 rand0to1(vec2 x) {\n\treturn vec2(rand0to1(), rand0to1());\n}\n\n//returns a random float between min and max\nvec2 rand(vec2 min, vec2 max, vec2 x) {\n\treturn vec2(rand(min.x, max.x), rand(min.y, max.y));\n}\n\n//returns a random float between -1 and 1\nvec3 randm1to1(vec3 x) {\n\treturn vec3(randm1to1(), randm1to1(), randm1to1());\n}\n\n//returns a random float between 0 and 1\nvec3 rand0to1(vec3 x) {\n\treturn vec3(rand0to1(), rand0to1(), rand0to1());\n}\n\n//returns a random float between min and max\nvec3 rand(vec3 min, vec3 max, vec3 x) {\n\treturn vec3(rand(min.x, max.x), rand(min.y, max.y), rand(min.z, max.z));\n}\n\n//returns a random float between -1 and 1\nvec4 randm1to1(vec4 x) {\n\treturn vec4(randm1to1(), rand", "\n\tvec2 flow = vec2(0.0);\n\tfloat dist = distance(point, vec2(0.5));\n\tif (dist < 0.5)\n\t{\n\t\tfloat angle = atan(point.y, point.x);\n\t\tfloat angle2 = angle + offset;\n\t\tfloat angle3 = angle2 + spread;\n\t\tfloat angle4 = angle2 - spread;\n\t\tfloat angle5 = angle4 + spread;\n\t\tfloat angle6 = angle4 - spread;\n\t\tfloat angle7 = angle6 + spread;\n\t\tfloat angle8 = angle6 - spread;\n\t\tfloat angle9 = angle8 + spread;\n\t\tfloat angle10 = angle8 - spread;\n\t\tfloat angle11 = angle10 + spread;\n\t\tfloat angle12 = angle10 - spread;\n\t\tfloat angle13 = angle12 + spread;\n\t\tfloat angle14 = angle12 - spread;\n\t\tfloat angle15 = angle14 + spread;\n\t\tfloat angle16 = angle14 - spread;\n\t\tfloat angle17 = angle16 + spread;\n\t\tfloat angle18 = angle16 - spread;\n\t\tfloat angle19 = angle18 + spread;\n\t\tfloat angle20 = angle18 - spread;\n\t\tfloat angle21 = angle20 + spread;\n\t\tfloat angle22 = angle20 - spread;\n\t\tfloat angle23 = angle22 + spread;\n\t\tfloat angle24 = angle22 - spread;\n\t\tfloat angle25 = angle24 + spread;\n\t\tfloat angle26 = angle24 - spread;\n\t\tfloat angle27 = angle26 + spread;\n\t\tfloat angle28 = angle26 - spread;\n\t\tfloat angle29 = angle28 + spread;\n\t\tfloat angle30 = angle28 - spread;\n\t\tfloat angle31 = angle30 + spread;\n\t\tfloat angle32 = angle30 - spread;\n\t\tfloat angle33 = angle32 + spread;\n\t\tfloat angle34 = angle32 - spread;\n\t\tfloat angle35 = angle34 + spread;\n\t\tfloat angle36 = angle34 - spread;\n\t\tfloat angle37 = angle36 + spread;\n\t\tfloat angle", "\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBox( in vec4 p, in vec4 b ) \n{\n    vec4 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float h ) \n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - h;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in float h ) \n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - h;\n}\n\nfloat sdBox( in vec4 p, in vec4 b, in float h ) \n{\n    vec4 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,max(d.z,d.w))),0.0) - h;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 h ) \n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(h.x,h.y);\n}\n\nfloat sdBox( in vec3 p, in vec3 b, in vec3 h ) \n{", "\n\t// the base SDF\n\tfloat sd = sdCircle( p, vec2( 0.0, 0.0 ), 1.0 );\n\n\t// the SDF we want to repeat\n\tfloat sdRepeat = sdCircle( p, vec2( 0.0, 0.0 ), 0.5 );\n\n\t// the distance between the two\n\tfloat dist = distance( sd, sdRepeat );\n\n\t// the distance between the two, scaled by the time\n\tfloat distScaled = dist * time;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed\n\tfloat distScaledSp = distScaled * sp;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id\n\tfloat distScaledSpId = distScaledSp * id.x;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id, and then scaled by the id\n\tfloat distScaledSpIdId = distScaledSpId * id.y;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id, and then scaled by the id, and then scaled by the id\n\tfloat distScaledSpIdIdId = distScaledSpIdId * id.x;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then scaled by the id\n\tfloat distScaledSpIdIdIdId = distScaledSpIdIdId * id.y;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then scaled by the id\n\tfloat distScaledSpIdIdIdIdId = distScaledSpIdIdIdId * id.x;\n\n\t// the distance between the two, scaled by the time, and then scaled by the speed, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then scaled by the id, and then", "\n\tfloat d = distance( p, vec2( 0.0 ) );\n\tfloat a = atan( p.y, p.x );\n\tfloat r = d / ra;\n\tfloat s = mod( a, sp ) / sp;\n\treturn r + s * time;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec3 p, float ra, float sp, float time )\n{\n\tfloat d = distance( p, vec3( 0.0 ) );\n\tfloat a = atan( p.y, p.x );\n\tfloat r = d / ra;\n\tfloat s = mod( a, sp ) / sp;\n\treturn r + s * time;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec4 p, float ra, float sp, float time )\n{\n\tfloat d = distance( p, vec4( 0.0 ) );\n\tfloat a = atan( p.y, p.x );\n\tfloat r = d / ra;\n\tfloat s = mod( a, sp ) / sp;\n\treturn r + s * time;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float r )\n{\n\tfloat d = distance( p, vec2( 0.0 ) );\n\tfloat a = atan( p.y, p.x );\n\tfloat r2 = d / ra;\n\tfloat s = mod( a, sp ) / sp;\n\treturn r + r2 + s * time;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec3 p, float ra, float sp, float time, float r )\n{\n\tfloat d = distance( p, vec3( 0.0 ) );\n\tfloat a = atan( p.y, p.x );\n\tfloat r2 = d / ra;\n\tfloat s = mod( a, sp ) / sp;\n\treturn r + r2 + s * time;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec4 p, float ra, float sp, float time, float r )\n{\n\tfloat d =", "\n\treturn max(max(abs(uvw.x), abs(uvw.y)), abs(uvw.z));\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n\treturn length(uvw) - 1.0;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n\treturn length(vec2(uvw.x, uvw.z)) - 1.0;\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n\treturn uvw.y - 1.0;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n\treturn max(abs(uvw.y), abs(uvw.z)) - 1.0;\n}\n\n//edge distance of a Hyperboloid\nfloat hyperboloidDist(vec3 uvw) {\n\treturn length(vec2(uvw.x, uvw.z)) - 1.0;\n}\n\n//edge distance of a Paraboloid\nfloat paraboloidDist(vec3 uvw) {\n\treturn uvw.y * uvw.y - 1.0;\n}\n\n//edge distance of a Ellipsoid\nfloat ellipsoidDist(vec3 uvw) {\n\treturn length(vec2(uvw.x, uvw.z)) - 1.0;\n}\n\n//edge distance of a Hyperbolic Paraboloid\nfloat hyperbolicParaboloidDist(vec3 uvw) {\n\treturn uvw.y * uvw.y - 1.0;\n}\n\n//edge distance of a Hyperbolic Ellipsoid\nfloat hyperbolicEllipsoidDist(vec3 uvw) {\n\treturn length(vec2(uvw.x, uvw.z)) - 1.0;\n}\n\n//edge distance of a Hyperbolic Cone\nfloat hyperbolicConeDist(vec3 uvw) {\n\treturn uvw.y - 1.0;\n}\n\n//edge distance of a Hyperbolic Cylinder\nfloat hyperbolicCylinderDist(vec3 uvw) {\n\treturn max(abs", "\n\tvec3 c = floor(uvw);\n\tvec3 f = fract(uvw);\n\tvec3 a = abs(f);\n\tvec3 b = step(a, vec3(0.5));\n\tvec3 d = step(a, vec3(0.25));\n\tvec3 e = step(a, vec3(0.75));\n\tvec3 g = step(a, vec3(0.125));\n\tvec3 h = step(a, vec3(0.375));\n\tvec3 i = step(a, vec3(0.625));\n\tvec3 j = step(a, vec3(0.875));\n\tvec3 k = step(a, vec3(0.0625));\n\tvec3 l = step(a, vec3(0.2125));\n\tvec3 m = step(a, vec3(0.3625));\n\tvec3 n = step(a, vec3(0.5125));\n\tvec3 o = step(a, vec3(0.6625));\n\tvec3 p = step(a, vec3(0.8125));\n\tvec3 q = step(a, vec3(0.9375));\n\tvec3 r = step(a, vec3(0.03125));\n\tvec3 s = step(a, vec3(0.1875));\n\tvec3 t = step(a, vec3(0.3375));\n\tvec3 u = step(a, vec3(0.4875));\n\tvec3 v = step(a, vec3(0.6375));\n\tvec3 w = step(a, vec3(0.7875));\n\tvec3 x = step(a, vec3(0.96875));\n\tvec3 y = step(a, vec3(0.015625));\n\tvec3 z = step(a, vec3(0.16875));\n\tvec3 aa = step(a, vec3(0.3125));\n\tvec3 ab = step", "\n    vec3 cell = floor(uvw * gridRes) + offset;\n    vec3 f = fract(uvw * gridRes);\n    vec3 c = step(f, vec3(0.5));\n    vec3 o = step(vec3(0.5) - f, vec3(0.5));\n    return vec4(mix(mix(c.x, o.x, f.x), mix(c.y, o.y, f.y), mix(c.z, o.z, f.z)), 1.0);\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, float gridRes) {\n    return floor(uvw * gridRes);\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, float gridRes) {\n    return floor(uvw * gridRes) + offset;\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, vec3 gridRes) {\n    return floor(uvw * gridRes) + offset;\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, vec3 gridRes, float gridResScale) {\n    return floor(uvw * gridRes * gridResScale) + offset;\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, vec3 gridRes, vec3 gridResScale) {\n    return floor(uvw * gridRes * gridResScale) + offset;\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, vec3 gridRes, vec3 gridResScale, float gridResScale2) {\n    return floor(uvw * gridRes * gridResScale * gridResScale2) + offset;\n}\n\n// returns a 3D cell index for a given 3D position\nvec3 cell(vec3 uvw, vec3 offset, vec3 gridRes, vec3 gridResScale, vec3 gridResScale2) {\n   ", "\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\tfloat t4 = t3*t;\n\tfloat t5 = t4*t;\n\tfloat t6 = t5*t;\n\treturn vec3(\n\t\t(t6 - 6*t5 + 15*t4 - 20*t3 + 15*t2 - 6*t + 1),\n\t\t(6*t5 - 15*t4 + 20*t3 - 15*t2 + 6*t),\n\t\t(t6 - 6*t5 + 15*t4 - 20*t3 + 15*t2 - 6*t + 1)\n\t);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a) {\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\tfloat t4 = t3*t;\n\tfloat t5 = t4*t;\n\tfloat t6 = t5*t;\n\treturn vec3(\n\t\t(t6 - 6*t5 + 15*t4 - 20*t3 + 15*t2 - 6*t + 1),\n\t\t(6*t5 - 15*t4 + 20*t3 - 15*t2 + 6*t),\n\t\t(t6 - 6*t5 + 15*t4 - 20*t3 + 15*t2 - 6*t + 1)\n\t) * a;\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t, float a, float b) {\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\tfloat t4 = t3*t;\n\tfloat t5 = t4*t", "\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosaDist(vec3 p) {\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x + p.y) - 1.0);\n\td = max(d, abs(p.x + p.z) - 1.0);\n\td = max(d, abs(p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\td = max(d, abs(p.x + p.y + p.z) - 1.0);\n\treturn d;\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n\tfloat d = 0.0;\n\td = max(d, abs(p.x) - 1.0);\n\td = max(d, abs(p.y) - 1.0);\n\td = max(d, abs(p.z) - 1.0);\n\td = max(d, abs(p.x", "\n\treturn vec3(1.0, 1.0, 1.0) * (1.0 - t) + vec3(0.0, 0.0, 1.0) * t;\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n\treturn vec3(1.0, 1.0, 0.0) * (1.0 - t) + vec3(0.0, 1.0, 0.0) * t;\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n\treturn vec3(0.0, 1.0, 0.0) * (1.0 - t) + vec3(0.0, 1.0, 1.0) * t;\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n\treturn vec3(0.0, 0.0, 1.0) * (1.0 - t) + vec3(1.0, 0.0, 1.0) * t;\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n\treturn vec3(1.0, 0.0, 0.0) * (1.0 - t) + vec3(1.0, 1.0, 0.0) * t;\n}\n\n// makes cool colormap with polynimal 6\nvec3 cool(float t) {\n\treturn vec3(0.0, 1.0, 1.0) * (1.0 - t) + vec3(0.0, 0.0, 1.0) * t;\n}\n\n// makes warm colormap with polynimal 6\nvec3 warm(float t) {\n\treturn vec3(1.0, 0.0, 0.0) * (1.0 - t) + vec3(1.0, 1.0, 0.0) * t;\n}\n\n// makes gray colormap with polynimal 6\nvec3 gray(float", "\n\tvec2 st = uv * 2.0 - 1.0;\n\tvec2 p = abs(st);\n\tvec2 f = fract(st);\n\tvec2 i = step(p, vec2(0.5));\n\tvec2 r = step(vec2(0.25), p);\n\tvec2 c = step(vec2(0.75), p);\n\tvec2 o = 1.0 - i - r - c;\n\tvec2 v = i * vec2(0.0, 0.0) + r * vec2(0.5, 0.0) + c * vec2(0.0, 0.5) + o * vec2(0.5, 0.5);\n\treturn vec3(v, 0.0);\n}\n\n// simple hexagonal Tiling\nvec3 hexTile(vec2 uv) {\n\tvec2 st = uv * 2.0 - 1.0;\n\tvec2 p = abs(st);\n\tvec2 f = fract(st);\n\tvec2 i = step(p, vec2(0.5));\n\tvec2 r = step(vec2(0.2886751345948129), p);\n\tvec2 c = step(vec2(0.7113248654051871), p);\n\tvec2 o = 1.0 - i - r - c;\n\tvec2 v = i * vec2(0.0, 0.0) + r * vec2(0.5, 0.0) + c * vec2(0.0, 0.5) + o * vec2(0.5, 0.5);\n\treturn vec3(v, 0.0);\n}\n\n// simple triangular Tiling\nvec3 triTile(vec2 uv) {\n\tvec2 st = uv * 2.0 - 1.0;\n\tvec2 p = abs(st);\n\tvec2 f = fract(st);\n\tvec2 i = step(p, vec2(0.5));\n\tvec2 r = step(vec2(", "\n    vec2 p = uv * 2.0 - 1.0;\n    vec2 q = abs(p);\n    vec2 r = max(q, vec2(0.0));\n    vec2 s = min(q, vec2(0.0));\n    vec2 t = max(r, s);\n    vec2 u = min(r, s);\n    vec2 v = max(u, vec2(0.0));\n    vec2 w = min(u, vec2(0.0));\n    vec2 x = max(w, vec2(0.0));\n    vec2 y = min(w, vec2(0.0));\n    vec2 z = max(y, vec2(0.0));\n    vec2 a = min(y, vec2(0.0));\n    vec2 b = max(a, vec2(0.0));\n    vec2 c = min(a, vec2(0.0));\n    vec2 d = max(c, vec2(0.0));\n    vec2 e = min(c, vec2(0.0));\n    vec2 f = max(e, vec2(0.0));\n    vec2 g = min(e, vec2(0.0));\n    vec2 h = max(g, vec2(0.0));\n    vec2 i = min(g, vec2(0.0));\n    vec2 j = max(i, vec2(0.0));\n    vec2 k = min(i, vec2(0.0));\n    vec2 l = max(k, vec2(0.0));\n    vec2 m = min(k, vec2(0.0));\n    vec2 n = max(m, vec2(0.0));\n    vec2 o = min(m, vec2(0.0));\n    vec2 p = max(o, vec2(0.0));\n    vec2 q = min(o, vec2(0.0));\n    vec2 r = max(q, vec2(0.0));\n    vec2 s = min(q, vec2(0.0));\n    vec2 t = max(s, vec2(0.0));\n    vec2 u = min(s, vec2(0.0));\n    vec2 v = max(u, vec2(0.0));", "\n    float gridSize = 1.0 / gridRes;\n    vec2 gridPos = floor(uv * gridRes) / gridRes;\n    vec2 gridPos2 = fract(uv * gridRes) / gridRes;\n    vec2 gridPos3 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos4 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos5 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos6 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos7 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos8 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos9 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos10 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos11 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos12 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos13 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos14 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos15 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos16 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos17 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos18 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos19 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos20 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos21 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos22 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos23 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos24 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos25 = fract(uv * gridRes) * gridRes;\n    vec2 gridPos26 = fract", "\n\tfloat gridSize = 1.0 / gridRes;\n\tfloat gridX = floor(uv.x / gridSize);\n\tfloat gridY = floor(uv.y / gridSize);\n\tfloat gridXFrac = fract(uv.x / gridSize);\n\tfloat gridYFrac = fract(uv.y / gridSize);\n\tfloat gridXFrac2 = fract(gridXFrac * 2.0);\n\tfloat gridYFrac2 = fract(gridYFrac * 2.0);\n\tfloat gridXFrac2Sub = 1.0 - gridXFrac2;\n\tfloat gridYFrac2Sub = 1.0 - gridYFrac2;\n\tfloat gridXFrac2Sub2 = 1.0 - gridXFrac2Sub;\n\tfloat gridYFrac2Sub2 = 1.0 - gridYFrac2Sub;\n\tfloat gridXFrac2Sub2Sub = 1.0 - gridXFrac2Sub2;\n\tfloat gridYFrac2Sub2Sub = 1.0 - gridYFrac2Sub2;\n\tfloat gridXFrac2Sub2Sub2 = 1.0 - gridXFrac2Sub2Sub;\n\tfloat gridYFrac2Sub2Sub2 = 1.0 - gridYFrac2Sub2Sub;\n\tfloat gridXFrac2Sub2Sub2Sub = 1.0 - gridXFrac2Sub2Sub2;\n\tfloat gridYFrac2Sub2Sub2Sub = 1.0 - gridYFrac2Sub2Sub2;\n\tfloat gridXFrac2Sub2Sub2Sub2 = 1.0 - gridXFrac2Sub2Sub2Sub;\n\tfloat gridYFrac2Sub2Sub2Sub2 = 1.0 - gridYFrac2Sub2Sub2Sub;\n\tfloat gridXFrac2Sub2Sub2Sub2Sub = 1.0 - gridXFrac2Sub2Sub2Sub2;\n\tfloat gridYFrac2Sub2Sub2Sub2Sub = 1.0 - gridYFrac2Sub2Sub2Sub2;\n\tfloat gridXFrac2Sub2Sub2Sub2Sub2 = 1.0 - gridXFrac2Sub2Sub2Sub2Sub;\n\tfloat gridYFrac2Sub2Sub2", "\n    float cellSize = 1.0 / gridRes;\n    float cellSize2 = cellSize * 0.5;\n    float cellSize4 = cellSize2 * 0.5;\n    float cellSize8 = cellSize4 * 0.5;\n    float cellSize16 = cellSize8 * 0.5;\n    float cellSize32 = cellSize16 * 0.5;\n    float cellSize64 = cellSize32 * 0.5;\n    float cellSize128 = cellSize64 * 0.5;\n    float cellSize256 = cellSize128 * 0.5;\n    float cellSize512 = cellSize256 * 0.5;\n    float cellSize1024 = cellSize512 * 0.5;\n    float cellSize2048 = cellSize1024 * 0.5;\n    float cellSize4096 = cellSize2048 * 0.5;\n    float cellSize8192 = cellSize4096 * 0.5;\n    float cellSize16384 = cellSize8192 * 0.5;\n    float cellSize32768 = cellSize16384 * 0.5;\n    float cellSize65536 = cellSize32768 * 0.5;\n    float cellSize131072 = cellSize65536 * 0.5;\n    float cellSize262144 = cellSize131072 * 0.5;\n    float cellSize524288 = cellSize262144 * 0.5;\n    float cellSize1048576 = cellSize524288 * 0.5;\n    float cellSize2097152 = cellSize1048576 * 0.5;\n    float cellSize4194304 = cellSize2097152 * 0.5;\n    float cellSize8388608 = cellSize4194304 * 0.5;\n    float cellSize16777216 = cellSize83", "\n    float t = time * 0.01;\n    float r = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z = 0.0;\n    float AA = ", "\n\tvec2 g = ddx * ddy;\n\tvec2 h = ddx * ddy;\n\tvec2 i = ddx * ddy;\n\tvec2 j = ddx * ddy;\n\tvec2 k = ddx * ddy;\n\tvec2 l = ddx * ddy;\n\tvec2 m = ddx * ddy;\n\tvec2 n = ddx * ddy;\n\tvec2 o = ddx * ddy;\n\tvec2 p = ddx * ddy;\n\tvec2 q = ddx * ddy;\n\tvec2 r = ddx * ddy;\n\tvec2 s = ddx * ddy;\n\tvec2 t = ddx * ddy;\n\tvec2 u = ddx * ddy;\n\tvec2 v = ddx * ddy;\n\tvec2 w = ddx * ddy;\n\tvec2 x = ddx * ddy;\n\tvec2 y = ddx * ddy;\n\tvec2 z = ddx * ddy;\n\tvec2 A = ddx * ddy;\n\tvec2 B = ddx * ddy;\n\tvec2 C = ddx * ddy;\n\tvec2 D = ddx * ddy;\n\tvec2 E = ddx * ddy;\n\tvec2 F = ddx * ddy;\n\tvec2 G = ddx * ddy;\n\tvec2 H = ddx * ddy;\n\tvec2 I = ddx * ddy;\n\tvec2 J = ddx * ddy;\n\tvec2 K = ddx * ddy;\n\tvec2 L = ddx * ddy;\n\tvec2 M = ddx * ddy;\n\tvec2 N = ddx * ddy;\n\tvec2 O = ddx * ddy;\n\tvec2 P = ddx * ddy;\n\tvec2 Q = ddx * ddy;\n\tvec2 R = ddx * ddy;\n\tvec2 S = ddx * ddy;\n\tvec2 T = ddx * ddy;\n\tvec2 U = ddx * ddy;\n\tvec2 V = ddx * ddy;\n\tvec2 W = ddx", "\n    p = abs(p);\n    float d = length(p - vec2(r, 0.0));\n    float a = atan(p.y, p.x);\n    float b = a + 0.25 * PI;\n    float c = a - 0.25 * PI;\n    float s = r * sin(0.25 * PI);\n    float t = r * cos(0.25 * PI);\n    float q = r * 0.5;\n    float u = r * 0.70710678118654752440084436210485;\n    float v = r * 0.86602540378443864676372317075294;\n    float w = r * 0.57735026918962576450914878050196;\n    float x = r * 0.81649658092772603273242802490196;\n    float y = r * 0.38268343236508977172845998403040;\n    float z = r * 0.92387953251128675612818318939679;\n    float e = r * 0.70710678118654752440084436210485;\n    float f = r * 0.40824829046386301636621401245098;\n    float g = r * 0.23570226039551587373095089805178;\n    float h = r * 0.14142135623730950", "\n    p = floor(p);\n    vec2 q = p + vec2(0.5, 0.5);\n    vec2 r = mod(p, 2.0);\n    vec2 s = step(r, vec2(1.0, 1.0));\n    vec2 t = step(r, vec2(0.0, 0.0));\n    vec2 u = step(r, vec2(1.0, 0.0));\n    vec2 v = step(r, vec2(0.0, 1.0));\n    vec2 w = step(r, vec2(1.0, 1.0));\n    vec2 x = step(r, vec2(0.0, 0.0));\n    vec2 y = step(r, vec2(1.0, 0.0));\n    vec2 z = step(r, vec2(0.0, 1.0));\n    vec2 A = step(r, vec2(1.0, 1.0));\n    vec2 B = step(r, vec2(0.0, 0.0));\n    vec2 C = step(r, vec2(1.0, 0.0));\n    vec2 D = step(r, vec2(0.0, 1.0));\n    vec2 E = step(r, vec2(1.0, 1.0));\n    vec2 F = step(r, vec2(0.0, 0.0));\n    vec2 G = step(r, vec2(1.0, 0.0));\n    vec2 H = step(r, vec2(0.0, 1.0));\n    vec2 I = step(r, vec2(1.0, 1.0));\n    vec2 J = step(r, vec2(0.0, 0.0));\n    vec2 K = step(r, vec2(1.0, 0.0));\n    vec2 L = step(r, vec2(0.0, 1.0));\n    vec2 M = step(r, vec2(1.0, 1.0));\n    vec2 N = step(r, vec2(0.0, 0.0));\n    vec2 O = step(r, vec", "\n\tfloat x2 = x * x;\n\treturn x2 * x2 * (3.0 - 2.0 * x2);\n}\n\n// 3D noise, https://www.shadertoy.com/view/3sd3Rs\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor( x );\n\tvec3 f = fract( x );\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n\tvec3 mod289 = fract( vec3( n *.14285714285714285 ) * 289.0 );\n\tvec2 mod289_2 = fract( mod289.xy * 289.0 );\n\tvec2 mod289_3 = fract( mod289.xz * 289.0 );\n\tvec2 mod289_4 = fract( mod289.yw * 289.0 );\n\n\tvec4 i = vec4( dot( mod289.xy, vec2( 113.0, 127.0 ) ), dot( mod289.xz, vec2( 113.0, 127.0 ) ), dot( mod289.yw, vec2( 113.0, 127.0 ) ), dot( mod289.yz, vec2( 113.0, 127.0 ) ) );\n\n\tvec4 j = p - ( mod289.xyzw * 289.0 );\n\n\tvec4 x0 = vec4( j.x, j.y, j.z, j.w );\n\tvec4 x1 = x0 + 1.0;\n\n\tvec4 k0 = mod289_2 * ( mod289_3 * mod289_4 );\n\tvec4 k1 = mod289_2 * ( mod289_3 * ( mod289_4 - 1.", "\n    return pow(t, vec3(1.0 / 2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 linear(vec3 t) {\n    return t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 gamma(vec3 t) {\n    return pow(t, vec3(2.2));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 inverse(vec3 t) {\n    return 1.0 - t;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 saturate(vec3 t) {\n    return clamp(t, 0.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 clamp(vec3 t, float min, float max) {\n    return mix(min, max, saturate(t));\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 mix(vec3 t, float a, float b) {\n    return mix(a, b, t);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 mix(vec3 t, float a, float b, float c) {\n    return mix(a, b, c, t);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 mix(vec3 t, float a, float b, float c, float d) {\n    return mix(a", "\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df8(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df9(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df10(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df11(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df12(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df13(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df14(vec2 p) {\n    return 1.0f - length(p);\n}\n\n// Classic truchet pattern\nfloat df15(vec2 p) {\n    return 1.0f - length(p", "\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;\n        f += a * exp(-a * length(p - vec2(0.5, 0.5)));\n    }\n    return f;\n}\n\n// Multiscale truchet\nfloat df2(vec2 p) {\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;\n        f += a * exp(-a * length(p - vec2(0.5, 0.5)));\n    }\n    return f;\n}\n\n// Multiscale truchet\nfloat df3(vec2 p) {\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;\n        f += a * exp(-a * length(p - vec2(0.5, 0.5)));\n    }\n    return f;\n}\n\n// Multiscale truchet\nfloat df4(vec2 p) {\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;\n        f += a * exp(-a * length(p - vec2(0.5, 0.5)));\n    }\n    return f;\n}\n\n// Multiscale truchet\nfloat df5(vec2 p) {\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;\n        f += a * exp(-a * length(p - vec2(0.5, 0.5)));\n    }\n    return f;\n}\n\n// Multiscale truchet\nfloat df6(vec2 p) {\n    float f = 0.0;\n    for (int i = 0; i < 5; i++) {\n        float a = 1.0 + 0.1 * i;", "\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p0;\n\tvec2 e2 = p - p0;\n\n\tfloat a = dot( e0, e0 );\n\tfloat b = dot( e0, e1 );\n\tfloat c = dot( e1, e1 );\n\tfloat d = dot( e0, e2 );\n\tfloat e = dot( e1, e2 );\n\tfloat f = dot( e2, e2 );\n\n\tfloat det = a * c - b * b;\n\tfloat s = b * e - c * d;\n\tfloat t = b * d - a * e;\n\tfloat s0 = 0.0;\n\tfloat s1 = 1.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 1.0;\n\n\tif ( det!= 0.0 ) {\n\t\ts0 = s / det;\n\t\ts1 = t / det;\n\t\tt0 = e / det;\n\t\tt1 = f / det;\n\t}\n\n\tif ( s < 0.0 ) {\n\t\tfloat tmp0 = s0;\n\t\ts0 = t0;\n\t\tt0 = tmp0;\n\t\tfloat tmp1 = s1;\n\t\ts1 = t1;\n\t\tt1 = tmp1;\n\t}\n\n\tif ( t < 0.0 ) {\n\t\tif ( s + t < 0.0 ) {\n\t\t\tfloat tmp0 = s0;\n\t\t\ts0 = t0;\n\t\t\tt0 = tmp0;\n\t\t\tfloat tmp1 = s1;\n\t\t\ts1 = t1;\n\t\t\tt1 = tmp1;\n\t\t}\n\t\tt0 = 0.0;\n\t}\n\n\tif ( s > 1.0 ) {\n\t\tfloat tmp0 = s0;\n\t\ts0 = t0;\n\t\tt0 = tmp0;\n\t\tfloat tmp1 = s1;\n\t\ts1 = t1;\n\t\tt1 = tmp1;\n\t}\n\n\tif ( t > 1.0 ) {\n\t\tt1 = 1.0;\n\t}\n\n\tfloat s2 = 1.0 - s0 - t", "\n    float r = sph.w;\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r8 = r4*r4;\n    float r16 = r8*r8;\n    float r32 = r16*r16;\n    float r64 = r32*r32;\n    float r128 = r64*r64;\n    float r256 = r128*r128;\n    float r512 = r256*r256;\n    float r1024 = r512*r512;\n    float r2048 = r1024*r1024;\n    float r4096 = r2048*r2048;\n    float r8192 = r4096*r4096;\n    float r16384 = r8192*r8192;\n    float r32768 = r16384*r16384;\n    float r65536 = r32768*r32768;\n    float r131072 = r65536*r65536;\n    float r262144 = r131072*r131072;\n    float r524288 = r262144*r262144;\n    float r1048576 = r524288*r524288;\n    float r2097152 = r1048576*r1048576;\n    float r4194304 = r2097152*r2097152;\n    float r8388608 = r4194304*r4194304;\n    float r16777216 = r8388608*r8388608;\n    float r33554432 = r16777", "\n    float d = length(p) - w;\n    return clamp(d, 0.0, r) - d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedY(vec2 p, float h, float r) {\n    float d = abs(p.y) - h;\n    return clamp(d, 0.0, r) - d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float h, float r) {\n    return roundedX(p, w, r) + roundedY(p, h, r);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float h, float r, float a) {\n    return roundedX(p, w, r) + roundedY(p, h, r) + a;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float h, float r, float a, float b) {\n    return roundedX(p, w, r) + roundedY(p, h, r) + a + b;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat rounded(vec2 p, float w, float h, float r, float a, float b, float c) {\n    return roundedX(p, w, r) + roundedY(p, h, r) + a + b + c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/", "\n\treturn abs( p.x * p.y ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n\treturn abs( p.x * p.y * p.z ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\n\treturn abs( p.x * p.y * p.z * p.w ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, vec2 q, float k )\n{\n\treturn abs( p.x * q.y ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, vec3 q, float k )\n{\n\treturn abs( p.x * q.y * q.z ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, vec4 q, float k )\n{\n\treturn abs( p.x * q.y * q.z * q.w ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec2 p, vec2 q, vec2 r, float k )\n{\n\treturn abs( p.x * q.y * r.z ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, vec3 q, vec3 r, float k )\n{\n\treturn abs( p.x * q.y * r.z * r.w ) * ( k + 1.0 );\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, vec4 q, vec4 r, float k )\n{\n\treturn abs( p.x * q.y * r.z", "\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, 1.0/p.y)), sdCircle(vec2(1.0/p.x, p.y)), step(p.x, p.y) );\n}\n\n// distance to y=x\nfloat sdOX( in vec2 p )\n{\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, p.y)), sdCircle(vec2(1.0/p.x, 1.0/p.y)), step(p.x, p.y) );\n}\n\n// distance to y=x^2\nfloat sdOX2( in vec2 p )\n{\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, p.y*p.y)), sdCircle(vec2(1.0/p.x, 1.0/(p.y*p.y))), step(p.x, p.y) );\n}\n\n// distance to y=x^3\nfloat sdOX3( in vec2 p )\n{\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, p.y*p.y*p.y)), sdCircle(vec2(1.0/p.x, 1.0/(p.y*p.y*p.y))), step(p.x, p.y) );\n}\n\n// distance to y=x^4\nfloat sdOX4( in vec2 p )\n{\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, p.y*p.y*p.y*p.y)), sdCircle(vec2(1.0/p.x, 1.0/(p.y*p.y*p.y*p.y))), step(p.x, p.y) );\n}\n\n// distance to y=x^5\nfloat sdOX5( in vec2 p )\n{\n\tp = abs(p);\n\treturn mix( sdCircle(vec2(p.x, p.y*p.y*p.y*p.", "\n\tfloat h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n\treturn mix(b, a, h) - k * h * (1.0f - h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b) {\n\treturn pmin(a, b, 0.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p) {\n\tfloat r = pmin(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n\treturn pmin(r, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, 0.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p, float q) {\n\tfloat r = pmin(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n\treturn pmin(r, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q);\n}\n\n// License: MIT, author: Inigo Quilez,", "\n    return abs(a) - k * sign(a);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp(float x, float a, float b) {\n    return clamp(x, a, b);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp01(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp11(float x) {\n    return clamp(x, -1.0, 1.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp22(float x) {\n    return clamp(x, -2.0, 2.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp33(float x) {\n    return clamp(x, -3.0, 3.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp44(float x) {\n    return clamp(x, -4.0, 4.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp55(float x) {\n    return clamp(x, -5.0, 5.0);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pclamp66(float x) {\n    return clamp(x, -6.0, 6.0);\n}\n\n// License: CC0, author: M", "\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart2(vec2 p) {\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart3(vec2 p) {\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart4(vec2 p) {\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart5(vec2 p) {\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart6(vec2 p) {\n    p = abs(p);\n    p = p * (3.0 - 2.0 * p);\n    return p.x + p.y - 1.0;\n}\n\n// License: MIT", "\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p) {\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p) {\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p) {\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p) {\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash17(vec2 p) {\n\tp = fract(p *.1031);\n\tp += dot(p, p + 33.33);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without", "\n\tvec2 p = pos;\n\tvec2 f = sdBezier( p, A, B, C );\n\tvec2 df = sdBezierDerivative( p, A, B, C );\n\treturn vec3( f.x, df.x, df.y );\n}\n\n//\n// Bezier curve\n//\n\n// Bezier curve\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n\tvec2 p = pos;\n\tvec2 f = sdBezier( p, A, B, C, D );\n\tvec2 df = sdBezierDerivative( p, A, B, C, D );\n\treturn vec3( f.x, df.x, df.y );\n}\n\n//\n// Bezier curve\n//\n\n// Bezier curve\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in vec2 E )\n{\n\tvec2 p = pos;\n\tvec2 f = sdBezier( p, A, B, C, D, E );\n\tvec2 df = sdBezierDerivative( p, A, B, C, D, E );\n\treturn vec3( f.x, df.x, df.y );\n}\n\n//\n// Bezier curve\n//\n\n// Bezier curve\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(", "\n\tvec2 p = pos * vec2( wi, he );\n\tfloat x = p.x;\n\tfloat y = p.y;\n\tfloat f = x*x + y*y;\n\tfloat df = 2.0 * x;\n\tfloat ddf = 2.0;\n\tfloat dddf = 0.0;\n\tfloat ddddf = 0.0;\n\tfloat dddddf = 0.0;\n\tfloat ddddddf = 0.0;\n\tfloat dddddddf = 0.0;\n\tfloat ddddddddf = 0.0;\n\tfloat dddddddddf = 0.0;\n\tfloat ddddddddddf = 0.0;\n\tfloat dddddddddddf = 0.0;\n\tfloat ddddddddddddf = 0.0;\n\tfloat dddddddddddddf = 0.0;\n\tfloat ddddddddddddddf = 0.0;\n\tfloat dddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddddf = 0.0;\n\tfloat dddddddddddddddddddddddddddddddf = 0.0;\n\tfloat ddddddddddddddddddddddddddddddd", "\n\tvec2 p = pos - vec2(0.5, 0.5);\n\tfloat d = dot(p, p) - k;\n\treturn vec3(d, 2.0 * p.x, 2.0 * p.y);\n}\n\n//\n// Paraboloid\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParaboloid( in vec2 pos, in float k )\n{\n\tvec2 p = pos - vec2(0.5, 0.5);\n\tfloat d = dot(p, p) - k;\n\treturn vec3(d, 2.0 * p.x, 2.0 * p.y);\n}\n\n//\n// Hyperboloid\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdHyperboloid( in vec2 pos, in float k )\n{\n\tvec2 p = pos - vec2(0.5, 0.5);\n\tfloat d = dot(p, p) - k;\n\treturn vec3(d, 2.0 * p.x, 2.0 * p.y);\n}\n\n//\n// Torus\n//\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdTorus( in vec2 pos, in float r1, in float r2 )\n{\n\tvec2 p = pos - vec2(0.5, 0.5);\n\tfloat d = length(vec2(length(p) - r1, 0.0)) - r", "\n\tvec2 q = vec2(length(p)-d, atan(p.y,p.x));\n\tfloat r = length(q);\n\tfloat a = atan(q.y,q.x);\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat x = ra*r*c;\n\tfloat y = ra*r*s;\n\tfloat z = rb*r;\n\treturn vec3(x,y,z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdMars(vec2 p, float d, float ra, float rb )\n{\n\tvec2 q = vec2(length(p)-d, atan(p.y,p.x));\n\tfloat r = length(q);\n\tfloat a = atan(q.y,q.x);\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat x = ra*r*c;\n\tfloat y = ra*r*s;\n\tfloat z = rb*r;\n\treturn vec3(x,y,z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdJupiter(vec2 p, float d, float ra, float rb )\n{\n\tvec2 q = vec2(length(p)-d, atan(p.y,p.x));\n\tfloat r = length(q);\n\tfloat a = atan(q.y,q.x);\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat x = ra*r*c;\n\tfloat y = ra*r*s;\n\tfloat z = rb*r;\n\treturn vec3(x,y,z);\n}\n\n//.x =", "\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg3(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg4(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\treturn v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg5(ivec2 v)\n{\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v << 5)) ^ (v >> 11);\n\tv = (v ^ (v << 13)) ^ (v >> 17);\n\tv = (v ^ (v", "\n\treturn ivec3(\n\t\t(v.x * 1103515245 + 12345) & 0x7fffffff,\n\t\t(v.y * 1103515245 + 12345) & 0x7fffffff,\n\t\t(v.z * 1103515245 + 12345) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed)\n{\n\treturn ivec3(\n\t\t(v.x * 1103515245 + seed.x) & 0x7fffffff,\n\t\t(v.y * 1103515245 + seed.y) & 0x7fffffff,\n\t\t(v.z * 1103515245 + seed.z) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed, ivec3 offset)\n{\n\treturn ivec3(\n\t\t(v.x * 1103515245 + seed.x + offset.x) & 0x7fffffff,\n\t\t(v.y * 1103515245 + seed.y + offset.y) & 0x7fffffff,\n\t\t(v.z * 1103515245 + seed.z + offset.z) & 0x7fffffff);\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 seed, ivec3 offset, ivec3 mul)\n{\n\treturn ivec", "\n\tvec2 p = pos;\n\tvec2 a = A;\n\tvec2 b = B;\n\tvec2 c = C;\n\tvec2 ab = b - a;\n\tvec2 ac = c - a;\n\tvec2 bc = c - b;\n\tfloat ab2 = dot(ab, ab);\n\tfloat ac2 = dot(ac, ac);\n\tfloat bc2 = dot(bc, bc);\n\tfloat abc = dot(ab, ac);\n\tfloat bca = dot(bc, ac);\n\tfloat bac = dot(bc, ab);\n\tfloat a2 = dot(p - a, p - a);\n\tfloat b2 = dot(p - b, p - b);\n\tfloat c2 = dot(p - c, p - c);\n\tfloat a3 = a2 * a2;\n\tfloat b3 = b2 * b2;\n\tfloat c3 = c2 * c2;\n\tfloat a2b = a2 * b2;\n\tfloat a2c = a2 * c2;\n\tfloat b2c = b2 * c2;\n\tfloat a2bc = a2b * c2;\n\tfloat a2b2 = a2b * b2;\n\tfloat a2c2 = a2c * c2;\n\tfloat b2c2 = b2c * c2;\n\tfloat a2bc2 = a2bc * c2;\n\tfloat a2b2c = a2b2 * c2;\n\tfloat a2b2c2 = a2b2c * c2;\n\tfloat a2b2c3 = a2b2c * b2;\n\tfloat a2b2c23 = a2b2c2 * b2;\n\tfloat a2b2c232 = a2b2c23 * b2;\n\tfloat a2b2c233 = a2b2c23 * c2;\n\tfloat a2b2c2322 = a2b2c232 * b2;\n\tfloat a2b2c2323 = a2b2c232 * c2;\n\tfloat a2b2c23", "\n    return (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, d) + winding_sign(p, d, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, d) + winding_sign(p, d, e) + winding_sign(p, e, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, d) + winding_sign(p, d, e) + winding_sign(p, e, f) + winding_sign(p, f, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, d) + winding_sign(p, d", "\n    vec3 n = normalize( cross( rd, s.yzx ) );\n    vec3 p = ro + rd * ( dot( n, s.yzx ) / dot( n, rd ) );\n    vec3 d = p - s.yzx;\n    float t = length( d );\n    return vec4( t, n );\n}\n\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iCylinder( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3 n = normalize( cross( rd, s.yzx ) );\n    vec3 p = ro + rd * ( dot( n, s.yzx ) / dot( n, rd ) );\n    vec3 d = p - s.yzx;\n    float t = length( d );\n    return vec4( t, n );\n}\n\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iCone( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3 n = normalize( cross( rd, s.yzx ) );\n    vec3 p = ro + rd * ( dot( n, s.yzx ) / dot( n, rd ) );\n    vec3 d = p - s.yzx;\n    float t = length( d );\n    return vec4( t, n );\n}\n\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3 d = ro - s.yzx;\n    float t = length( d );\n    return vec4( t, normalize( d ) );\n}\n\n// returns:\n// .x    = distance to intersection\n// .yzw  = normal at intersection point\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    vec3 n = s.yzx;\n    float t = dot( n, s.yzx ) / dot( n, rd );\n    return vec4( t, n );\n}\n\n// returns:\n// .x", "\n\tfloat ret = frac_mad_i24_m12_f32(a, b, x);\n\tret_n = floor(ret);\n\treturn ret;\n}\n\n// https://www.shadertoy.com/view/4sfGzN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (int a, float b, float x) {\n\tfloat ret = frac_mad_i24_m12_f32(a, b, x);\n\treturn ret;\n}\n\n// https://www.shadertoy.com/view/4sfGzN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (int a, float b, float x, out int ret_n) {\n\tfloat ret = frac_mad_i24_m12_f32(a, b, x);\n\tret_n = floor(ret);\n\treturn ret;\n}\n\n// https://www.shadertoy.com/view/4sfGzN\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (int a, float b, float x, out int ret_n, out float ret) {\n\tfloat ret = frac_mad_i24_m12_f32(a, b, x);\n\tret_n = floor(ret);\n\treturn ret;\n}\n\n// https://www.shadertoy.com/view/4sfGzN\n// requires abs(a) < (1<<24), recognizes only ", "\n\tfloat h = clamp( dot(a,b), 0.0, 1.0 );\n\tfloat d = acos( h ) - k;\n\tvec3 m = -b + 2.0 * a * h;\n\treturn normalize( m + a * cos(d) ) * acos( h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n\tfloat h = clamp( dot(a,b), 0.0, 1.0 );\n\tfloat d = acos( h ) + k;\n\tvec3 m = -b + 2.0 * a * h;\n\treturn normalize( m + a * cos(d) ) * acos( h );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k, in float l )\n{\n\tfloat h = clamp( dot(a,b), 0.0, 1.0 );\n\tfloat d = acos( h ) - k;\n\tvec3 m = -b + 2.0 * a * h;\n\treturn normalize( m + a * cos(d) ) * acos( h ) + l * a;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec3 sdgSMax( in vec3 a, in vec3 b, in float k, in float l )", "\n\treturn dot(p-ab,p-ab) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat inside_Ellipse( vec2 p, in vec2 ab){\n\treturn dot(p-ab,p-ab) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in vec2 ab){\n\treturn dot(p-ab,p-ab) - dot(ab,ab);\n}\n\n//using the \"locus of points\" geometric defn of ellipse\nfloat inside_Ellipse( vec2 p, in vec2 ab, in vec2 cd){\n\treturn dot(p-ab,p-ab) - dot(ab,ab) + dot(p-cd,p-cd) - dot(cd,cd);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in vec2 ab, in vec2 cd){\n\treturn dot(p-ab,p-ab) - dot(ab,ab) + dot(p-cd,p-cd) - dot(cd,cd);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef){\n\treturn dot(p-ab,p-ab) - dot(ab,ab) + dot(p-cd,p-cd) - dot(cd,cd) + dot(p-ef,p-ef) - dot(ef,ef);\n}\n\n//using the \"locus of points\" geometric defn of circle\nfloat inside_Circle( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef, in vec2 gh){\n\treturn dot(p-ab,p-ab) - dot(ab,ab) + dot(p-cd,p-cd) - dot(cd,cd) + dot(p-ef,p-ef) - dot(ef,ef) + dot(p-gh,p-gh) - dot(gh,gh);\n}\n\n//", "\n\treturn a+b;\n}\n\nfloat sub_ploss(in float a, in float b){\n\treturn a-b;\n}\n\nfloat mul_ploss(in float a, in float b){\n\treturn a*b;\n}\n\nfloat div_ploss(in float a, in float b){\n\treturn a/b;\n}\n\nfloat add_ploss_test(in float a, in float b){\n\treturn add_ploss(a,b);\n}\n\nfloat sub_ploss_test(in float a, in float b){\n\treturn sub_ploss(a,b);\n}\n\nfloat mul_ploss_test(in float a, in float b){\n\treturn mul_ploss(a,b);\n}\n\nfloat div_ploss_test(in float a, in float b){\n\treturn div_ploss(a,b);\n}\n\n//precision loss testing\nfloat add_ploss_test_2(in float a, in float b){\n\treturn add_ploss(a,b);\n}\n\nfloat sub_ploss_test_2(in float a, in float b){\n\treturn sub_ploss(a,b);\n}\n\nfloat mul_ploss_test_2(in float a, in float b){\n\treturn mul_ploss(a,b);\n}\n\nfloat div_ploss_test_2(in float a, in float b){\n\treturn div_ploss(a,b);\n}\n\n//precision loss testing\nfloat add_ploss_test_3(in float a, in float b){\n\treturn add_ploss(a,b);\n}\n\nfloat sub_ploss_test_3(in float a, in float b){\n\treturn sub_ploss(a,b);\n}\n\nfloat mul_ploss_test_3(in float a, in float b){\n\treturn mul_ploss(a,b);\n}\n\nfloat div_ploss_test_3(in float a, in float b){\n\treturn div_ploss(a,b);\n}\n\n//precision loss testing\nfloat add_ploss_test_4(in", "\n\treturn pHyperbola( p, ab, s1, s2 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3 )\n{\n\treturn pHyperbola( p, ab, s1, s2, s3 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4 )\n{\n\treturn pHyperbola( p, ab, s1, s2, s3, s4 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4, in float s5 )\n{\n\treturn pHyperbola( p, ab, s1, s2, s3, s4, s5 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4, in float s5, in float s6 )\n{\n\treturn pHyperbola( p, ab, s1, s2, s3, s4, s5, s6 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4, in float s5, in float s6, in float s7 )\n{\n\treturn pHyperbola( p, ab, s1, s2, s3, s4, s5, s6, s7 );\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2, in float s3, in float s4, in float s5, in float s6, in float s7, in float s8 )\n{\n\treturn pHyperbola(", "\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba);\n\tfloat e = length(pa - h * ba);\n\tfloat f = length(ba);\n\tfloat r = ra;\n\tif (h < 0.0) r = rb;\n\telse if (h > f) r = ra;\n\tfloat d = length(p - (a + h * ba / f));\n\treturn vec4(d - r, h, a + h * ba / f);\n}\n\n//.x   distance to the cylinder\n//.yzw closest point\nvec4 sdcCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = dot(pa, ba);\n\tfloat e = length(pa - h * ba);\n\tfloat f = length(ba);\n\tfloat d = length(p - (a + h * ba / f));\n\treturn vec4(d - r, h, a + h * ba / f);\n}\n\n//.x   distance to the sphere\n//.yzw closest point\nvec4 sdcSphere(vec3 p, vec3 c, float r)\n{\n\tvec3 pc = p - c;\n\tfloat d = length(pc);\n\treturn vec4(d - r, pc);\n}\n\n//.x   distance to the box\n//.yzw closest point\nvec4 sdcBox(vec3 p, vec3 b, vec3 c)\n{\n\tvec3 q = abs(p - c) - b;\n\tvec3 d = sign(q);\n\tfloat m = max(max(q.x, q.y), q.z);\n\treturn vec4(m, p - c + m * d);\n}\n\n//.x   distance to the plane\n//.yzw closest point\nvec4 sdcPlane(vec3 p, vec3 n, vec3 c)\n{\n\tfloat d = dot(p - c, n);\n\treturn vec4(d, p - d * n);\n}\n\n//.x   distance to the", "\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCapsule2d( vec2 p, vec2 a, vec2 b, float r )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCylinder2d( vec2 p, vec2 a, vec2 b, float r )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCone2d( vec2 p, vec2 a", "\n\tvec3 d = p - cen;\n\treturn length(d) - rad;\n}\n\nfloat sdTorus( vec3 p, vec3 cen, float rad, float rad2 )\n{\n\tvec3 q = p - cen;\n\tvec2 d = vec2(length(q.xz) - rad, q.y);\n\treturn length(d) - rad2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCone( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float d )\n{\n\treturn dot(p,n) - d;\n}\n\nfloat sdPlane( vec3 p, vec3 n )\n{\n\treturn dot(p,n);\n}\n\nfloat sdPlane( vec3 p, vec3 n, vec3 d )\n{\n\treturn dot(p,n) - dot(d,n);\n}\n\nfloat sd", "\n\tvec3 n = vec3( 0.0 );\n\tvec3 eps = vec3( 0.0001 );\n\tvec3 eps2 = vec3( 0.00001 );\n\tvec3 eps3 = vec3( 0.000001 );\n\tvec3 eps4 = vec3( 0.0000001 );\n\tvec3 eps5 = vec3( 0.00000001 );\n\tvec3 eps6 = vec3( 0.000000001 );\n\tvec3 eps7 = vec3( 0.0000000001 );\n\tvec3 eps8 = vec3( 0.00000000001 );\n\tvec3 eps9 = vec3( 0.000000000001 );\n\tvec3 eps10 = vec3( 0.0000000000001 );\n\tvec3 eps11 = vec3( 0.00000000000001 );\n\tvec3 eps12 = vec3( 0.000000000000001 );\n\tvec3 eps13 = vec3( 0.0000000000000001 );\n\tvec3 eps14 = vec3( 0.00000000000000001 );\n\tvec3 eps15 = vec3( 0.000000000000000001 );\n\tvec3 eps16 = vec3( 0.0000000000000000001 );\n\tvec3 eps17 = vec3( 0.00000000000000000001 );\n\tvec3 eps18 = vec3( 0.000000000000000000001 );\n\tvec3 eps19 = vec3( 0", "\n\tfloat shadow = 1.0;\n\tfloat bias = 0.0001;\n\tfloat step = 0.001;\n\tfloat maxDist = 100.0;\n\tfloat dist = 0.0;\n\tfloat t = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.", "\n\tvec2 q = p - vec2( ra, 0.0 );\n\tvec2 r = p - vec2( rb, 0.0 );\n\tvec2 s = p - vec2( 0.0, he );\n\tvec2 t = p - vec2( 0.0, -he );\n\tvec2 u = p - vec2( ra, he );\n\tvec2 v = p - vec2( rb, he );\n\tvec2 w = p - vec2( ra, -he );\n\tvec2 x = p - vec2( rb, -he );\n\tvec2 y = p - vec2( 0.0, 0.0 );\n\tvec2 z = p - vec2( ra, 0.0 );\n\tvec2 a = p - vec2( rb, 0.0 );\n\tvec2 b = p - vec2( 0.0, he );\n\tvec2 c = p - vec2( 0.0, -he );\n\tvec2 d = p - vec2( ra, he );\n\tvec2 e = p - vec2( rb, he );\n\tvec2 f = p - vec2( ra, -he );\n\tvec2 g = p - vec2( rb, -he );\n\tvec2 h = p - vec2( 0.0, 0.0 );\n\tvec2 i = p - vec2( ra, 0.0 );\n\tvec2 j = p - vec2( rb, 0.0 );\n\tvec2 k = p - vec2( 0.0, he );\n\tvec2 l = p - vec2( 0.0, -he );\n\tvec2 m = p - vec2( ra, he );\n\tvec2 n = p - vec2( rb, he );\n\tvec2 o = p - vec2( ra, -he );\n\tvec2 p = p - vec2( rb, -he );\n\tvec2 q = p - vec2( 0.0, 0.0 );\n\tvec2 r = p - vec2( ra, 0.0 );\n\tvec2 s = p - vec2( rb, 0.0 );\n\tvec2 t = p -", "\n\tvec3 q = p - vec3( 0.0, 0.0, 0.0 );\n\tfloat d = length( q );\n\tfloat r = sqrt( max( 0.0, 1.0 - d * d / ( ra * ra ) ) );\n\tfloat h = rb * r / ra;\n\treturn vec4( normalize( q.xy ), h );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n\tvec3 q = p - vec3( 0.0, 0.0, 0.0 );\n\tfloat d = length( q );\n\tfloat r = sqrt( max( 0.0, 1.0 - d * d / ( ra * ra ) ) );\n\tfloat h = rb * r / ra;\n\treturn vec4( normalize( q.xy ), h );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n\tvec3 q = p - vec3( 0.0, 0.0, 0.0 );\n\tfloat d = length( q );\n\tfloat r = sqrt( max( 0.0, 1.0 - d * d / ( ra * ra ) ) );\n\tfloat h = rb * r / ra;\n\treturn vec4( normalize( q.xy ), h );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgSphere( vec3 p, float ra, float rb )\n{\n\tvec3 q = p - vec3( 0.0, 0.0, 0.0 );\n\tfloat d = length( q );\n\tfloat r = sqrt( max( 0.0, 1.0 - d * d / ( ra * ra ) ) );\n\tfloat h = rb * r / ra;\n\treturn vec4( normalize( q.xy ), h );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = dot(pa,ba);\n    float l = dot(ba,ba);\n    float t = clamp( h / l, 0.0, 1.0 );\n    return length( pa - ba*t );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length( p - c ) - r;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udPolygon( in vec2 p, in vec2[] v )\n{\n    float w = 0.0;\n    for( int i = 0; i < v.length; i++ )\n    {\n        float s = udSegment( p, v[i], v[(i+1)%v.length] );\n        w = max( w, s );\n    }\n    return w;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udPoly( in vec2 p, in vec2[] v )\n{\n    float w = 0.0;\n    for( int i = 0; i < v.length; i++ )\n    {\n        float s = udSegment( p, v[i], v[(i+1)%v.length] );\n        w = max( w, s );\n    }\n    return w;\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat udPoly( in vec2 p, in vec2[] v, in float r )\n{\n    float w = 0.0;\n    for( int i = 0; i < v.length; i++ )\n    {\n        float s = udSegment( p, v[i], v[(i+1)%v.length] );\n        w = max( w, s );\n    }\n    return w -", " return v.x*v.x + v.y*v.y; }\nfloat dot3(in vec3 v) { return v.x*v.x + v.y*v.y + v.z*v.z; }\nfloat dot4(in vec4 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w; }\nfloat dot5(in vec5 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v; }\nfloat dot6(in vec6 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v + v.u*v.u; }\nfloat dot7(in vec7 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v + v.u*v.u + v.t*v.t; }\nfloat dot8(in vec8 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v + v.u*v.u + v.t*v.t + v.s*v.s; }\nfloat dot9(in vec9 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v + v.u*v.u + v.t*v.t + v.s*v.s + v.r*v.r; }\nfloat dot10(in vec10 v) { return v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.v*v.v + v.u*v.u + v.t*v", "\n    vec2 d = max( vec2(0.0), vec2(minCorner - p) );\n    vec2 e = min( vec2(0.0), vec2(maxCorner - p) );\n    return dot(d, d) + dot(e, e);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 d = max( vec3(0.0), vec3(minCorner - p) );\n    vec3 e = min( vec3(0.0), vec3(maxCorner - p) );\n    return dot(d, d) + dot(e, e);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 d = max( vec4(0.0), vec4(minCorner - p) );\n    vec4 e = min( vec4(0.0), vec4(maxCorner - p) );\n    return dot(d, d) + dot(e, e);\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float radius ) \n{\n    vec2 d = max( vec2(0.0), vec2(minCorner - p) );\n    vec2 e = min( vec2(0.0), vec2(maxCorner - p) );\n    return dot(d, d) + dot(e, e) + radius * radius;\n}\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in float radius ) \n{\n    vec3 d = max( vec3(0.0), vec3(minCorner - p) );\n    vec3 e = min( vec3(0.", "\n\tvec3 color = vec3(0.0);\n\tvec3 normal = vec3(0.0);\n\tvec3 position = vec3(0.0);\n\tvec3 light = vec3(0.0);\n\tvec3 view = vec3(0.0);\n\tvec3 lightDir = vec3(0.0);\n\tvec3 lightColor = vec3(0.0);\n\tvec3 lightPos = vec3(0.0);\n\tvec3 lightAttenuation = vec3(0.0);\n\tvec3 lightDir2 = vec3(0.0);\n\tvec3 lightColor2 = vec3(0.0);\n\tvec3 lightPos2 = vec3(0.0);\n\tvec3 lightAttenuation2 = vec3(0.0);\n\tvec3 lightDir3 = vec3(0.0);\n\tvec3 lightColor3 = vec3(0.0);\n\tvec3 lightPos3 = vec3(0.0);\n\tvec3 lightAttenuation3 = vec3(0.0);\n\tvec3 lightDir4 = vec3(0.0);\n\tvec3 lightColor4 = vec3(0.0);\n\tvec3 lightPos4 = vec3(0.0);\n\tvec3 lightAttenuation4 = vec3(0.0);\n\tvec3 lightDir5 = vec3(0.0);\n\tvec3 lightColor5 = vec3(0.0);\n\tvec3 lightPos5 = vec3(0.0);\n\tvec3 lightAttenuation5 = vec3(0.0);\n\tvec3 lightDir6 = vec3(0.0);\n\tvec3 lightColor6 = vec3(0.0);\n\tvec3 lightPos6 = vec3(0.0);\n\tvec3 lightAttenuation6 = vec3(0.0);\n\tvec3 lightDir7 = vec3(0.0);\n\tvec3 lightColor7 = vec3(0.0);\n\tvec3 lightPos7 = vec3(0.0);\n\tvec3 lightAttenuation7 = vec3(0.0);\n\tvec3 lightDir8 = vec3(0.0);\n\tvec3 lightColor8 = vec", "\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\treturn normalize(vec3(xy, -1.0));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z)\n{\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\treturn normalize(vec3(xy, z));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float time)\n{\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\treturn normalize(vec3(xy, z + time));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float time, float aspect)\n{\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\treturn normalize(vec3(xy, z + time));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float time, float aspect, float fov)\n{\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\txy *= tan(radians(fov) * 0.5);\n\treturn normalize(vec3(xy, z + time));\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float time, float aspect, float fov, float near, float far)\n{\n\tvec2 xy = 2.0 * uv - 1.0;\n\txy.x *= aspect;\n\txy *= tan(radians(fov) * 0.5);\n\treturn normalize(vec3(xy, z + time)) * (far + near) / (far - near);\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, float time, float aspect, float f", "\n\tvec3 t = cross(q.xyz, v);\n\tt += q.w * v;\n\tt += cross(q.xyz, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec3 v)\n{\n\tvec3 t = cross(q, v);\n\tt += q.w * v;\n\tt += cross(q, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec4 v)\n{\n\tvec3 t = cross(q.xyz, v.xyz);\n\tt += q.w * v.xyz;\n\tt += cross(q.xyz, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\n\tvec3 t = cross(q, v.xyz);\n\tt += q.w * v.xyz;\n\tt += cross(q, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n\tvec3 t = cross(q.xyz, v);\n\tt += q.w * v;\n\tt += cross(q.xyz, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\n\tvec3 t = cross(q, v.xyz);\n\tt += q.w * v.xyz;\n\tt += cross(q, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n\tvec3 t = cross(q.xyz, v);\n\tt += q.w * v;\n\tt += cross(q.xyz, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec3 q, vec4 v)\n{\n\tvec3 t = cross(q, v.xyz);\n\tt += q.w * v.xyz;\n\tt += cross(q, t);\n\treturn t;\n}\n\n// Quaternion-vector multiplication", "\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( in vec3 p, in vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( in vec3 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCylinder( in vec3 p, in float h, in float r )\n{\n\tvec3 q = abs(p.xz) - vec2(r,h);\n\treturn length(max(q,0.0)) + min(max(q.y,0.0),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( in vec3 p, in float R, in float r )\n{\n\tvec2 q = vec2(length(p.xz)-R,p.y);\n\treturn length(q) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( in vec3 p, in float h, in float r )\n{\n\tvec3 q = abs(p.xy) - vec2(r,h);\n\treturn length(max(q,0.0)) + min(max(q.z,0.0),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in float h", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n\treturn length( p - c ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(d.x,d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in float s )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(d.x,d.y) - s;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in float s, in float t )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0) - max(d.x,d.y) - s - t;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in float s, in float t", "\n\tfloat k = 1.0 / ( 1.0 + a );\n\tfloat h = 1.0 - k;\n\tfloat s = 1.0 - h;\n\tfloat t = 1.0 - s;\n\tfloat x = m.x;\n\tfloat y = m.y;\n\tfloat r = sqrt( x * x + y * y );\n\tfloat r2 = r * r;\n\tfloat r3 = r2 * r;\n\tfloat r4 = r2 * r2;\n\tfloat r5 = r4 * r;\n\tfloat r6 = r4 * r2;\n\tfloat r7 = r6 * r;\n\tfloat r8 = r4 * r4;\n\tfloat r9 = r8 * r;\n\tfloat r10 = r8 * r2;\n\tfloat r11 = r10 * r;\n\tfloat r12 = r8 * r4;\n\tfloat r13 = r12 * r;\n\tfloat r14 = r12 * r2;\n\tfloat r15 = r14 * r;\n\tfloat r16 = r12 * r4;\n\tfloat r17 = r16 * r;\n\tfloat r18 = r16 * r2;\n\tfloat r19 = r18 * r;\n\tfloat r20 = r16 * r4;\n\tfloat r21 = r20 * r;\n\tfloat r22 = r20 * r2;\n\tfloat r23 = r22 * r;\n\tfloat r24 = r20 * r4;\n\tfloat r25 = r24 * r;\n\tfloat r26 = r24 * r2;\n\tfloat r27 = r26 * r;\n\tfloat r28 = r24 * r4;\n\tfloat r29 = r28 * r;\n\tfloat r30 = r28 * r2;\n\tfloat r31 = r30 * r;\n\tfloat r32 = r28 * r4;\n\tfloat r33 = r32 * r;\n\tfloat r34 = r32 * r2", "\n\tfloat a = dot(rd,rd);\n\tfloat b = 2.0 * dot(rd,ro);\n\tfloat c = dot(ro,ro) - rad*rad;\n\tfloat d = b*b - 4.0*a*c;\n\tif( d < 0.0 ) return;\n\tfloat s = sqrt(d);\n\tfloat t = -b - s;\n\tif( t > 0.0 )\n\t{\n\t\tp1 = vec4( ro + rd*t, 0.0, 0.0 );\n\t\tt = -b + s;\n\t\tif( t > 0.0 )\n\t\t{\n\t\t\tp2 = vec4( ro + rd*t, 0.0, 0.0 );\n\t\t}\n\t}\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectPlane( in vec3 ro, in vec3 rd, in vec3 no, in vec3 po, out vec4 p1, out vec4 p2 )\n{\n\tfloat t = dot(po-ro,no) / dot(rd,no);\n\tp1 = vec4( ro + rd*t, 0.0, 0.0 );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, out vec4 p1, out vec4 p2 )\n{\n\tvec3 e1 = v1 - v0;\n\tvec3 e2 = v2 - v0;\n\tvec3 h = cross(rd,e2);\n\tfloat a = dot(e1,h);\n\tif( a > -0.00001 && a < 0.00001 ) return;\n\tfloat f = 1.0 / a;\n\tvec3 s = ro - v0;\n\tfloat u = f * dot(s,h);\n\tif( u < 0.0 || u > 1.0 ) return;\n\tvec3 q = cross(s,e1);\n\tfloat v = f * dot(rd", "\n    vec2 q = p - c;\n    float d = length(q);\n    float s = clamp(1.0 - d / r, 0.0, 1.0);\n    return vec3(s, q / d, 1.0 - s);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r ) \n{\n    vec2 q = p - c;\n    vec2 d = abs(q) - r;\n    float s = clamp(1.0 - min(max(d.x, d.y), 0.0) / max(r.x, r.y), 0.0, 1.0);\n    return vec3(s, (q / r) * (1.0 - s), 1.0 - s);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgRectangle( in vec2 p, in vec2 c, in vec2 r ) \n{\n    vec2 q = abs(p - c) - r;\n    float s = clamp(1.0 - min(max(q.x, q.y), 0.0) / max(r.x, r.y), 0.0, 1.0);\n    return vec3(s, (q / r) * (1.0 - s), 1.0 - s);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgPolygon( in vec2 p, in vec2 c, in vec2 r, in float a ) \n{\n    vec2 q = p - c;\n    float d = length(q);\n    float s = clamp(1", "\nvec2 d = abs(p) - b;\nvec2 m = min(d,vec2(0.0));\nvec2 h = max(d,vec2(0.0));\nvec2 a = m + h;\nvec2 r = h - a;\nfloat s = max(max(r.x,r.y),0.0);\nfloat q = 1.0 - s;\nfloat t = max(s,q);\nvec2 u = mix(m,h,step(vec2(s),r));\nvec2 v = mix(a,b,step(vec2(t),d));\nvec2 w = mix(u,v,step(vec2(q),d));\nreturn vec3(w.x,w.y,q);\n}\n\n// SDFs from iquilezles.org/articles/distfunctions3d\n//.x = f(p),.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSphere( in vec3 p, in float r )\n{\nvec3 q = p - vec3(0.0,0.0,r);\nfloat d = length(q);\nfloat s = 1.0 - smoothstep(r,r+0.01,d);\nvec3 n = normalize(q);\nvec3 g = vec3(0.0,0.0,1.0);\nvec3 b = vec3(0.0,1.0,0.0);\nvec3 c = vec3(1.0,0.0,0.0);\nvec3 t = mix(g,b,step(vec3(s),abs(n)));\nvec3 u = mix(b,c,step(vec3(s),abs(n)));\nvec3 v = mix(c,t,step(vec3(s),abs(n)));\nvec3 w = mix(t,u,step(vec3(s),abs(n)));\nvec3 x = mix(u,v,step(vec3(s),abs(n)));\nvec3 y = mix(v,w,step(vec3(s),abs(n)));\nvec3 z = mix(w,", "\nvec2 q = p;\nq.x += 0.5;\nq.y += 0.5;\nvec2 r = q;\nr.x *= 0.5;\nr.y *= 0.5;\nvec2 s = r;\ns.x *= 0.5;\ns.y *= 0.5;\nvec2 t = s;\nt.x *= 0.5;\nt.y *= 0.5;\nvec2 u = t;\nu.x *= 0.5;\nu.y *= 0.5;\nvec2 v = u;\nv.x *= 0.5;\nv.y *= 0.5;\nvec2 w = v;\nw.x *= 0.5;\nw.y *= 0.5;\nvec2 x = w;\nx.x *= 0.5;\nx.y *= 0.5;\nvec2 y = x;\ny.x *= 0.5;\ny.y *= 0.5;\nvec2 z = y;\nz.x *= 0.5;\nz.y *= 0.5;\nvec2 a = z;\na.x *= 0.5;\na.y *= 0.5;\nvec2 b = a;\nb.x *= 0.5;\nb.y *= 0.5;\nvec2 c = b;\nc.x *= 0.5;\nc.y *= 0.5;\nvec2 d = c;\nd.x *= 0.5;\nd.y *= 0.5;\nvec2 e = d;\ne.x *= 0.5;\ne.y *= 0.5;\nvec2 f = e;\nf.x *= 0.5;\nf.y *= 0.5;\nvec2 g = f;\ng.x *= 0.5;\ng.y *= 0.5;\nvec2 h = g;\nh.x *= 0.5;\nh.y *= 0.5;\nvec2 i = h;\ni.x *= 0.5;\ni.y *= 0.5", "\n  return a1 * sin(b1 * x) + a2 * sin(b2 * x);\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat h(float a1, float b1, float a2, float b2, float x) {\n  return a1 * cos(b1 * x) + a2 * cos(b2 * x);\n}\n\n// Instant push -> wobble (green)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat i(float a1, float b1, float a2, float b2, float x) {\n  return a1 * sin(b1 * x) + a2 * sin(b2 * x);\n}\n\n// Instant push -> wobble (yellow)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat j(float a1, float b1, float a2, float b2, float x) {\n  return a1 * cos(b1 * x) + a2 * cos(b2 * x);\n}\n\n// Instant push -> wobble (purple)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat k(float a1, float b1, float a2, float b2, float x) {\n  return a1 * sin(b1 * x) + a2 * sin(b2 * x);\n}\n\n// Instant push -> wobble (cyan)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat l(float a1, float b1, float a2, float b2, float x) {\n  return a1 * cos(b1 * x) + a2 * cos(b2 * x);\n}\n\n// Instant push -> wobble (white)\n// https://www.desmos.com/calculator/gbkax818fx\nfloat m(float a1, float b1, float a2, float b2, float x) {\n  return a1 * sin(b1 * x) + a2 * sin(b2", "\n  float y = pow(abs(x), n);\n  return a * pow(y + b, 1.0 / n);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y) {\n  float z = pow(abs(x), n);\n  float w = pow(abs(y), n);\n  return a * pow(z + b, 1.0 / n) * pow(w + b, 1.0 / n);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z) {\n  float w = pow(abs(x), n);\n  float v = pow(abs(y), n);\n  float u = pow(abs(z), n);\n  return a * pow(w + b, 1.0 / n) * pow(v + b, 1.0 / n) * pow(u + b, 1.0 / n);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x, float y, float z, float w) {\n  float v = pow(abs(x), n);\n  float u = pow(abs(y), n);\n  float t = pow", "\n                uv = vec2(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5, 183.3)));\n                return fract(sin(dot(uv, vec2(43758.5453, 3027.9487))) * 43758.5453);\n            }\n\n            float noise(vec2 uv){\n                return paperNoise(uv);\n            }\n\n            float noise(vec3 uv){\n                return paperNoise(uv.xy);\n            }\n\n            float noise(vec4 uv){\n                return paperNoise(uv.xy);\n            }\n\n            float noise(vec2 uv, float time){\n                return paperNoise(uv + time);\n            }\n\n            float noise(vec3 uv, float time){\n                return paperNoise(uv.xy + time);\n            }\n\n            float noise(vec4 uv, float time){\n                return paperNoise(uv.xy + time);\n            }\n\n            float noise(vec2 uv, vec2 time){\n                return paperNoise(uv + time);\n            }\n\n            float noise(vec3 uv, vec2 time){\n                return paperNoise(uv.xy + time);\n            }\n\n            float noise(vec4 uv, vec2 time){\n                return paperNoise(uv.xy + time);\n            }\n\n            float noise(vec2 uv, vec3 time){\n                return paperNoise(uv + time.xy);\n            }\n\n            float noise(vec3 uv, vec3 time){\n                return paperNoise(uv.xy + time.xy);\n            }\n\n            float noise(vec4 uv, vec3 time){\n                return paperNoise(uv.xy + time.xy);\n            }\n\n            float noise(vec2 uv, vec4 time){\n                return paperNoise(uv + time.xy);\n            }\n\n            float noise(vec3 uv, vec4 time){\n                return paperNoise(uv.xy + time.xy);\n            }\n\n            float noise(vec4 uv, vec4 time){\n                return paperNoise(uv.xy + time.xy);\n            }\n\n            float noise(vec2 uv, vec2 time, vec2 scale){\n                return paperNoise(uv * scale + time);\n            }\n\n            float noise(vec3 uv, vec2 time, vec3 scale){\n                return paperNoise(uv.xy * scale.xy + time", "\n\tvec3 color = vec3( 0.0 );\n\tfor( int i = 0; i < 6; i++ )\n\t{\n\t\tint i1 = ( i + 1 ) % 6;\n\t\tint i2 = ( i + 2 ) % 6;\n\t\tint i3 = ( i + 3 ) % 6;\n\t\tint i4 = ( i + 4 ) % 6;\n\t\tint i5 = ( i + 5 ) % 6;\n\t\tint i6 = ( i + 6 ) % 6;\n\t\tint i7 = ( i + 7 ) % 6;\n\t\tint i8 = ( i + 8 ) % 6;\n\t\tint i9 = ( i + 9 ) % 6;\n\t\tint i10 = ( i + 10 ) % 6;\n\t\tint i11 = ( i + 11 ) % 6;\n\t\tint i12 = ( i + 12 ) % 6;\n\t\tint i13 = ( i + 13 ) % 6;\n\t\tint i14 = ( i + 14 ) % 6;\n\t\tint i15 = ( i + 15 ) % 6;\n\t\tint i16 = ( i + 16 ) % 6;\n\t\tint i17 = ( i + 17 ) % 6;\n\t\tint i18 = ( i + 18 ) % 6;\n\t\tint i19 = ( i + 19 ) % 6;\n\t\tint i20 = ( i + 20 ) % 6;\n\t\tint i21 = ( i + 21 ) % 6;\n\t\tint i22 = ( i + 22 ) % 6;\n\t\tint i23 = ( i + 23 ) % 6;\n\t\tint i24 = ( i + 24 ) % 6;\n\t\tint i25 = ( i + 25 ) % 6;\n\t\tint i26 = ( i + 26 ) % 6;\n\t\tint i27 = ( i + 27 ) % 6;\n\t\tint i28 = ( i", "\n\treturn length( p - c ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n\tvec2 q = abs( p - c ) - r;\n\treturn length( max( q, vec2( 0.0 ) ) ) + min( max( q.x, q.y ), 0.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPolygon( in vec2 p, in vec2[] v )\n{\n\tfloat d = dot( p, v[0].xy );\n\tfloat s = 0.0;\n\tfor( int i = 1; i < v.length; i++ )\n\t{\n\t\tfloat s1 = dot( p, v[i].xy );\n\t\tfloat d1 = length( v[i].xy );\n\t\tfloat s2 = dot( p, v[i-1].xy );\n\t\tfloat d2 = length( v[i-1].xy );\n\t\tfloat a = acos( clamp( ( d1 * d1 + d2 * d2 - s1 * s1 ) / ( 2.0 * d1 * d2 ), -1.0, 1.0 ) );\n\t\ts += a * d1;\n\t\td = s1;\n\t}\n\treturn abs( s ) - d;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPolyLine( in vec2 p, in vec2[] v )\n{\n\tfloat d = dot( p, v[0].xy );\n\tfloat s = 0.0;\n\tfor( int i = 1; i < v.length; i++ )\n\t{\n\t\tfloat s1 = dot( p, v[i].xy );\n\t\tfloat d1 = length( v[i].xy );\n\t\tfloat s2 = dot( p, v[i-1].xy );\n\t\tfloat d2 = length( v[i-1].xy );\n\t\tfloat a = acos( clamp( ( d1 * d1 + d2 * d2", "\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b, in float r ) \n{\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b, in float r, in float s ) \n{\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - s;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b, in float r, in float s, in float t ) \n{\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - s - t;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b, in float r, in float s, in float t, in float u ) \n{\n    vec2 d = abs(p-c) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r - s - t - u;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b, in float r, in float s, in float t, in float u,", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - 0.5;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqLineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqLineSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqLineSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 q = a + ba*t;\n\treturn length( p - q ) - r - h;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqLineSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float h, in float k )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec2 q = a + ba*t;\n\treturn", "\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat e = dot( pa, ba );\n\tfloat f = dot( pa, pa ) - e*e;\n\tfloat x = 0.0;\n\tif ( f > 0.0 )\n\t{\n\t\tfloat k = 1.0 / f;\n\t\tfloat s = e * k;\n\t\tfloat t = clamp( s, 0.0, 1.0 );\n\t\tx = length( pa - ba * t );\n\t}\n\tfloat y = length( pa ) - h;\n\treturn vec2( x, y );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min, out vec2 n )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat e = dot( pa, ba );\n\tfloat f = dot( pa, pa ) - e*e;\n\tfloat x = 0.0;\n\tif ( f > 0.0 )\n\t{\n\t\tfloat k = 1.0 / f;\n\t\tfloat s = e * k;\n\t\tfloat t = clamp( s, 0.0, 1.0 );\n\t\tx = length( pa - ba * t );\n\t}\n\tfloat y = length( pa ) - h;\n\tfloat d = sqrt( x*x + y*y );\n\tif ( d < d2min )\n\t{\n\t\tn = normalize( pa - ba * t );\n\t}\n\treturn d;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min, out vec2 n, out vec2 np )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h2 = h*h;\n\tfloat e = dot(", "\n\tfloat d = 0.0;\n\tfloat t = 0.0;\n\tfloat s = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat A = 0.0;\n\tfloat B = 0.0;\n\tfloat C = 0.0;\n\tfloat D = 0.0;\n\tfloat E = 0.0;\n\tfloat F = 0.0;\n\tfloat G = 0.0;\n\tfloat H = 0.0;\n\tfloat I = 0.0;\n\tfloat J = 0.0;\n\tfloat K = 0.0;\n\tfloat L = 0.0;\n\tfloat M = 0.0;\n\tfloat N = 0.0;\n\tfloat O = 0.0;\n\tfloat P = 0.0;\n\tfloat Q = 0.0;\n\tfloat R = 0.0;\n\tfloat S = 0.0;\n\tfloat T = 0.0;\n\tfloat U = 0.0;\n\tfloat V = 0.0;\n\t", "\nvec2 q = vec2( 0.0, 0.0 );\nq.x = p.x - 0.5;\nq.y = p.y - 0.5;\nq.x *= 1.0;\nq.y *= 1.0;\nreturn length( q );\n}\n\n// correct inside, incorrect outside\nfloat sdB( in vec2 p )\n{\nvec2 q = vec2( 0.0, 0.0 );\nq.x = p.x - 0.5;\nq.y = p.y - 0.5;\nq.x *= 1.0;\nq.y *= 1.0;\nreturn length( q ) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdC( in vec2 p )\n{\nvec2 q = vec2( 0.0, 0.0 );\nq.x = p.x - 0.5;\nq.y = p.y - 0.5;\nq.x *= 1.0;\nq.y *= 1.0;\nreturn length( q ) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdD( in vec2 p )\n{\nvec2 q = vec2( 0.0, 0.0 );\nq.x = p.x - 0.5;\nq.y = p.y - 0.5;\nq.x *= 1.0;\nq.y *= 1.0;\nreturn length( q ) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdE( in vec2 p )\n{\nvec2 q = vec2( 0.0, 0.0 );\nq.x = p.x - 0.5;\nq.y = p.y - 0.5;\nq.x *= 1.0;\nq.y *= 1.0;\nreturn length( q ) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat sdF( in vec2 p )\n{\nvec2 q = vec2( 0.0, 0.0 );", "\n\tvec2 q = vec2( 1.0, 0.0 );\n\tvec2 r = vec2( 0.0, 1.0 );\n\tvec2 s = vec2( 0.0, 0.0 );\n\tvec2 t = vec2( 0.0, 0.0 );\n\tvec2 u = vec2( 0.0, 0.0 );\n\tvec2 v = vec2( 0.0, 0.0 );\n\tvec2 w = vec2( 0.0, 0.0 );\n\tvec2 x = vec2( 0.0, 0.0 );\n\tvec2 y = vec2( 0.0, 0.0 );\n\tvec2 z = vec2( 0.0, 0.0 );\n\tvec2 A = vec2( 0.0, 0.0 );\n\tvec2 B = vec2( 0.0, 0.0 );\n\tvec2 C = vec2( 0.0, 0.0 );\n\tvec2 D = vec2( 0.0, 0.0 );\n\tvec2 E = vec2( 0.0, 0.0 );\n\tvec2 F = vec2( 0.0, 0.0 );\n\tvec2 G = vec2( 0.0, 0.0 );\n\tvec2 H = vec2( 0.0, 0.0 );\n\tvec2 I = vec2( 0.0, 0.0 );\n\tvec2 J = vec2( 0.0, 0.0 );\n\tvec2 K = vec2( 0.0, 0.0 );\n\tvec2 L = vec2( 0.0, 0.0 );\n\tvec2 M = vec2( 0.0, 0.0 );\n\tvec2 N = vec2( 0.0, 0.0 );\n\tvec2 O = vec2( 0.0, 0.0 );\n\tvec2 P = vec2( 0.0, 0.0 );\n\tvec2 Q = vec2( 0.0, 0.0", "\n\tvec3 pattern = vec3( 0.0 );\n\tuv *= 10.0;\n\tuv = mod( uv, 2.0 );\n\tif( uv.x < 1.0 )\n\t{\n\t\tif( uv.y < 1.0 )\n\t\t{\n\t\t\tpattern = vec3( 1.0 );\n\t\t}\n\t}\n\treturn pattern;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in vec3 color )\n{\n\tvec3 pattern = vec3( 0.0 );\n\tuv *= 10.0;\n\tuv = mod( uv, 2.0 );\n\tif( uv.x < 1.0 )\n\t{\n\t\tif( uv.y < 1.0 )\n\t\t{\n\t\t\tpattern = color;\n\t\t}\n\t}\n\treturn pattern;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in vec3 color, in float opacity )\n{\n\tvec3 pattern = vec3( 0.0 );\n\tuv *= 10.0;\n\tuv = mod( uv, 2.0 );\n\tif( uv.x < 1.0 )\n\t{\n\t\tif( uv.y < 1.0 )\n\t\t{\n\t\t\tpattern = color;\n\t\t}\n\t}\n\treturn pattern * opacity;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in vec3 color, in float opacity, in float scale )\n{\n\tvec3 pattern = vec3( 0.0 );\n\tuv *= 10.0;\n\tuv = mod( uv, 2.0 );\n\tif( uv.x < 1.0 )\n\t{\n\t\tif( uv.y < 1.0 )\n\t\t{\n\t\t\tpattern = color;\n\t\t}\n\t}\n\treturn pattern * opacity * scale;\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv, in vec3", "\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat d1 = dot(ap, ab);\n\tfloat d2 = dot(ab, ab);\n\tfloat t = clamp( d1 / d2, 0.0, 1.0 );\n\tvec2 result = a + t * ab;\n\tfloat dist = distance( p, result );\n\tif( dist < th )\n\t{\n\t\treturn result;\n\t}\n\telse\n\t{\n\t\treturn vec2( 0.0 );\n\t}\n}\n\n// Closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float th )\n{\n\tvec2 result = cloSegment( p, a, b, th );\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p, b, c, th );\n\t}\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p, c, a, th );\n\t}\n\treturn result;\n}\n\n// Closest point on polygon\nvec2 cloPolygon( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float th )\n{\n\tvec2 result = cloSegment( p, a, b, th );\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p, b, c, th );\n\t}\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p, c, a, th );\n\t}\n\treturn result;\n}\n\n// Closest point on convex polygon\nvec2 cloConvexPolygon( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float th )\n{\n\tvec2 result = cloSegment( p, a, b, th );\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p, b, c, th );\n\t}\n\tif( result.x == 0.0 )\n\t{\n\t\tresult = cloSegment( p", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - th;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n\tvec2 pa = p - a, ba = b - a, ca = c - a;\n\tfloat s = 1.0 / length( cross( ba, ca ) );\n\tfloat t = s * dot( cross( pa, ca ), cross( ba, ca ) );\n\tfloat u = s * dot( cross( ba, pa ), cross( ca, ba ) );\n\treturn min( min( sdSegment( p, a, b, 0.0 ), sdSegment( p, b, c, 0.0 ) ), sdSegment( p, c, a, 0.0 ) ) - t*u;\n}\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to circle\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n\tvec2 q = vec2( length(p.x*p.x), length(p.y*p.y) ) / r;\n\treturn length( max( q - vec2(1.0), vec2(0.0) ) );\n}\n\n// distance to polygon\nfloat sdPolygon( in vec2 p, in vec2[] v )\n{\n\tfloat d = sdSegment( p, v[0], v[1], 0.0 );\n\tfor( int i = 1; i < v.length; i++ )\n\t\td = min( d, sdSegment( p, v[i], v[i+1],", "\n\tvec2 d = abs(p) - b;\n\tvec2 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n\tvec2 d = abs(p) - b;\n\tvec2 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec3 cloRoundBox( in vec3 p, in vec3 b, float r )\n{\n\tvec3 d = abs(p) - b;\n\tvec3 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec3 cloRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n\tvec3 d = abs(p) - b;\n\tvec3 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec4 cloRoundBox( in vec4 p, in vec4 b, float r )\n{\n\tvec4 d = abs(p) - b;\n\tvec4 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec4 cloRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n\tvec4 d = abs(p) - b;\n\tvec4 q = clamp(d, 0.0, r);\n\treturn p - q;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r, float m )\n{\n\tvec2 d = abs(p) - b;\n\tvec2 q = clamp(d, 0.0, r);\n\treturn p - q * m;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, float m )\n{\n\tvec2 d = abs(p) - b;", "\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y,0.0),max(q.x,q.y)) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y+q.z,0.0),max(q.x+q.y,max(q.x,q.y))) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, float r )\n{\n\tvec4 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y+q.z+q.w,0.0),max(q.x+q.y+q.z,max(q.x+q.y,max(q.x,q.y)))) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y,0.0),max(q.x,q.y)) - length(r);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x+q.y+q.z,0.0),max(q.x+q.y,max(q.x,q.y))) - length(r);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r )\n{\n\tvec4 q = abs(p) - b", "\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to plane\nfloat sdPlane( in vec3 p, in vec3 n, in float d )\n{\n\treturn dot(p,n) - d;\n}\n\n// distance to sphere\nfloat sdSphere( in vec3 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec3 p, in vec3 n, in float r, in float h )\n{\n\tvec3 q = abs(p) - vec3(length(p),0.0,0.0);\n\treturn length(max(q,vec3(0.0))) - r;\n}\n\n// distance to cone\nfloat sdCone( in vec3 p, in vec3 n, in float r, in float h )\n{\n\tfloat a = dot(p,n);\n\tfloat b = length(p) - r;\n\treturn sqrt(max(a*a - b*b,0.0)) - h;\n}\n\n// distance to torus\nfloat sdTorus( in vec3 p, in float r1, in float r2 )\n{\n\tvec2 q = vec2(length(p.xz) - r1,p.y);\n\treturn length(q) - r2;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n\tvec3 q = abs(p)/r;\n\treturn length(max(q,vec3(0.0))) - 1.0;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float m )\n{\n\tvec3 q = abs(p)/r;\n\treturn length(max(q,vec3(0.0))) - m;\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r, in float m, in float n )\n{\n\tvec3", "\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec2 p){\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec2 p){\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash15(vec2 p){\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash16(vec2 p){\n\tp = fract(p *.1031);\n\tp += dot(p, p + 19.19);\n\treturn fract((p.x + p.y) * p.x * p.y);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2", "\n\treturn fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n\treturn fract(sin(dot(x, vec3(12.9898, 78.233, 12.9898))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n\treturn fract(sin(dot(x, vec4(12.9898, 78.233, 12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n\treturn fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y)\n{\n\treturn fract(sin(x + y) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z)\n{\n\treturn fract(sin(x + y + z) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x, float y, float z, float w)\n{\n\treturn fract(sin(x + y + z + w) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, float y)\n{\n\treturn fract(sin(dot(x, vec2(12.9898, 78.233)) + y) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// From iq\nfloat fbm( vec2 st ){\n    float v = 0.0;\n    float a = 0.5;\n    for( int i=0; i<6; i++ ){\n        v += a * noise( st );\n        a *= 0.5;\n        st *= 2.0;\n    }\n    return v;\n}\n\n// From iq\nfloat fbm( vec3 st ){\n    float v = 0.0;\n    float a = 0.5;\n    for( int i=0; i<6; i++ ){\n        v += a * noise( st );\n        a *= 0.5;\n        st *= 2.0;\n    }\n    return v;\n}\n\n// From iq\nfloat fbm( vec4 st ){\n    float v = 0.0;\n    float a = 0.5;\n    for( int i=0; i<6; i++ ){\n        v += a * noise( st );\n        a *= ", "\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 57.0;\n\n\tfloat res = mix(mix(snoise(vec2(n + 0.0, n + 57.0)), snoise(vec2(n + 1.0, n + 58.0)), f.x),\n\t\t\t\t\tmix(snoise(vec2(n + 57.0, n + 0.0)), snoise(vec2(n + 58.0, n + 1.0)), f.x), f.y);\n\n\treturn res;\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 57.0 + p.z * 113.0;\n\n\tfloat res = mix(mix(snoise(vec3(n + 0.0, n + 57.0, n + 113.0)), snoise(vec3(n + 1.0, n + 58.0, n + 114.0)), f.x),\n\t\t\t\t\tmix(snoise(vec3(n + 57.0, n + 0.0, n + 113.0)), snoise(vec3(n + 58.0, n + 1.0, n + 114.0)), f.x), f.y);\n\n\tres = mix(res, mix(snoise(vec3(n + 113.0, n + 113.0, n + 0.0)), snoise(vec3(n + 114.0, n + 114.", "\n\tfloat sum = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tsum += amp * noise(x * freq);\n\t\tamp *= 0.5;\n\t\tfreq *= 2.0;\n\t}\n\treturn sum;\n}\n\n// 2D Perlin noise\nfloat perlin(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat u = fade(f.x);\n\tfloat v = fade(f.y);\n\n\tvec2 a = vec2(p.x, p.y);\n\tvec2 b = vec2(p.x + 1.0, p.y);\n\tvec2 c = vec2(p.x, p.y + 1.0);\n\tvec2 d = vec2(p.x + 1.0, p.y + 1.0);\n\n\tvec2 u1 = mix(grad(hash(a), a), grad(hash(b), b), u);\n\tvec2 u2 = mix(grad(hash(c), c), grad(hash(d), d), u);\n\n\treturn mix(u1, u2, v);\n}\n\n// 2D Simplex noise\nfloat simplex(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat u = fade(f.x);\n\tfloat v = fade(f.y);\n\n\tvec2 a = vec2(p.x, p.y);\n\tvec2 b = vec2(p.x + 1.0, p.y);\n\tvec2 c = vec2(p.x, p.y + 1.0);\n\tvec2 d = vec2(p.x + 1.0, p.y + 1.0);\n\n\tvec2 u1 = mix(grad(p, a), grad(p + 1.0, b), u);\n\tvec2 u2 = mix(grad(p, c), grad(p + 1.0", "\n\tfloat a = 1.0;\n\tfloat b = 1.0;\n\tfloat c = 1.0;\n\tfloat d = 1.0;\n\tfloat e = 1.0;\n\tfloat f = 1.0;\n\tfloat g = 1.0;\n\tfloat h = 1.0;\n\tfloat i = 1.0;\n\tfloat j = 1.0;\n\tfloat k = 1.0;\n\tfloat l = 1.0;\n\tfloat m = 1.0;\n\tfloat n = 1.0;\n\tfloat o = 1.0;\n\tfloat p = 1.0;\n\tfloat q = 1.0;\n\tfloat r = 1.0;\n\tfloat s = 1.0;\n\tfloat t = 1.0;\n\tfloat u = 1.0;\n\tfloat v = 1.0;\n\tfloat w = 1.0;\n\tfloat x1 = 1.0;\n\tfloat y1 = 1.0;\n\tfloat z1 = 1.0;\n\tfloat w1 = 1.0;\n\tfloat x2 = 1.0;\n\tfloat y2 = 1.0;\n\tfloat z2 = 1.0;\n\tfloat w2 = 1.0;\n\tfloat x3 = 1.0;\n\tfloat y3 = 1.0;\n\tfloat z3 = 1.0;\n\tfloat w3 = 1.0;\n\tfloat x4 = 1.0;\n\tfloat y4 = 1.0;\n\tfloat z4 = 1.0;\n\tfloat w4 = 1.0;\n\tfloat x5 = 1.0;\n\tfloat y5 = 1.0;\n\tfloat z5 = 1.0;\n\tfloat w5 = 1.0;\n\tfloat x6 = 1.0;\n\tfloat y6 = 1.0;\n\tfloat z6 = 1.0;\n\tfloat w6 = 1.0;\n\tfloat x7 = 1.0;\n\tfloat y7 = ", "\n    return x * y;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    return 2.0f * atan(y) * areaElement(x, y);\n}\n\n//\n// Compute the solid angle of a cubemap texel.\n//\n// The cubemap texel is a square with the given size.\n//\n// The solid angle of the texel is the area of the\n// square times the inverse of the distance from the\n// center of the texel to the center of the cubemap.\n//\n// The distance from the center of the texel to the\n// center of the cubemap is the diagonal of the\n// cubemap.\n//\n// The solid angle of the texel is the area of the\n// square times the inverse of the diagonal of the\n// cubemap.\n//\n// The area of the square is the product of the\n// dimensions of the square.\n//\n// The diagonal of the cubemap is the square root of\n// the sum of the squares of the dimensions of the\n// cubemap.\n//\n// The solid angle of the texel is the product of\n// the area of the square and the inverse of the\n// diagonal of the cubemap.\n//\n// The area of the square is the product of the\n// dimensions of the square.\n//\n// The diagonal of the cubemap is the square root of\n// the sum of the squares of the dimensions of the\n// cubemap.\n//\n// The solid angle of the texel is the product of\n// the area of the square and the inverse of the\n// diagonal of the cubemap.\n//\n// The area of the square is the product of the\n// dimensions of the square.\n//\n// The diagonal of the cubemap is the square root of\n// the sum of the squares of the dimensions of the\n// cubemap.\n//\n// The solid angle of the texel is the product of\n// the area of the square and the inverse of the\n// diagonal of the cubemap.\n//\n// The area of the square is the product of the\n// dimensions of the square.\n//\n// The diagonal of the cubemap is the square root of\n// the sum of the squares of the dimensions of the\n// cubemap.\n//\n// The solid angle of the tex", "\n\tp3 = fract(p3 *.1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix(hash33(i + vec3(0.0, 0.0, 0.0)), hash33(i + vec3(1.0, 0.0, 0.0)), u.x), mix(hash33(i + vec3(0.0, 1.0, 0.0)), hash33(i + vec3(1.0, 1.0, 0.0)), u.x), u.y);\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf += 0.5000 * noise(p); p = p * 2.02;\n\tf += 0.2500 * noise(p); p = p * 2.03;\n\tf += 0.1250 * noise(p); p = p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat fbm(vec3 p, float lacunarity, float gain) {\n\tfloat f = 0.0;\n\tfloat amp = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tf += amp * noise(p);\n\t\tp = p *", "\n    vec3  F3 = fract(cos(p) * C.xyz) - 0.5;\n    vec3  i = floor(p);\n    vec3  d = p - i;\n    vec3  m = max(0.6 - d * d, 0.0);\n    vec3  s = 0.5 - m * m;\n    vec3  sh = s * s * s;\n    return 4375.0 * (dot(s, dot(m, vec3(dot(i, C.www), dot(i + vec3(1.0), C.zzz), dot(i + vec3(1.0, 1.0), C.xxx)))));\n}\n\n// From  (MIT licensed): https://www.shadertoy.com/view/4l33zN\nfloat simplex4d(vec4 p) {\n    vec4  n = p + dot(p, vec4(1.0, 1.0, 1.0, 1.0));\n    vec4  n2 = n * n;\n    vec4  n3 = n2 * n;\n    vec4  i = floor(n);\n    vec4  f = fract(n);\n    vec4  u = f * f * (3.0 - 2.0 * f);\n    vec4  n4 = n3 * n2;\n    vec4  n5 = n4 * n;\n    vec4  n6 = n5 * n2;\n    vec4  n7 = n6 * n;\n    vec4  n8 = n7 * n2;\n    vec4  n9 = n8 * n;\n    vec4  n10 = n9 * n2;\n    vec4  n11 = n10 * n2;\n    vec4  n12 = n11 * n2;\n    vec4  n13 = n12 * n2;\n    vec4  n14 = n13 * n2;\n    vec4  n15 = n14 * n2;\n    vec4  n16 = n15 * n2;\n    vec4  n17 = n16 * n2;\n    vec4  n18 = n17 * n2;\n    vec4", "\n    return fract(sin(x)*43758.5453123);\n}\n\n// 2D simplex noise\nfloat snoise(vec2 v)\n{\n    const vec2  C = vec2(0.138196601125011, 0.138196601125011);\n    vec2  i  = floor(v + dot(v, C));\n    vec2  x0 = v - i + dot(i, C);\n    vec2  x1 = x0 - 1.0 + 2.0 * C;\n    vec4  x2 = x0.xyxy + C.xyxy;\n    vec3  i3 = floor(x2 * x2 * 0.211324865405187);\n    vec2  x3 = x0.xyxy + i3.xy;\n    vec4  i4 = floor(x3 + dot(x3, x3 * 0.142857142857143));\n    vec4  x4 = x0.xyxy + i4.xyxy;\n    vec4  i5 = floor(x4 * x4 * 0.0666666666666667);\n    vec4  x5 = x0.xyxy + i5.xyxy;\n    vec4  i6 = floor(x5 * x5 * 0.0333333333333333);\n    vec4  x6 = x0.xyxy + i6.xyxy;\n    vec4  i7 = floor(x6 * x6 * 0.0166666666666667);\n    vec4  x7 = x0.xyxy + i7.xyxy;\n    vec4  i8 = floor(x7 * x7 * 0.00833333333333333);\n    vec4  x8 = x0.xyxy + i8.xyxy;\n    vec4  i9 = floor(x8 * x8 * 0.0", "\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa,ba);\n\tfloat l = dot(ba,ba);\n\tfloat t = clamp( h / l, 0.0, 1.0 );\n\treturn length( pa - ba*t );\n}\n\n// for visualization purposes only\nfloat sdCircle( in vec2 p, in float r )\n{\n\treturn length( p ) - r;\n}\n\n// for visualization purposes only\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// for visualization purposes only\nfloat sdCapsule( in vec2 p, in float r, in float h )\n{\n\tfloat d = length(p) - r;\n\treturn min(d,abs(p.y)-h*0.5);\n}\n\n// for visualization purposes only\nfloat sdCylinder( in vec2 p, in float r, in float h )\n{\n\tvec2 q = abs(p.xy) - vec2(r,h*0.5);\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// for visualization purposes only\nfloat sdSphere( in vec2 p, in float r )\n{\n\treturn length(p) - r;\n}\n\n// for visualization purposes only\nfloat sdTorus( in vec2 p, in float r1, in float r2 )\n{\n\tvec2 q = vec2(length(p)-r1,p.y);\n\treturn length(q) - r2;\n}\n\n// for visualization purposes only\nfloat sdEllipsoid( in vec2 p, in vec2 r )\n{\n\tvec2 q = vec2(length(p.xy/r.x)-1.0,p.y);\n\treturn length(q) - r.y;\n}\n\n// for visualization purposes only\nfloat sdEllipticParaboloid( in vec2 p, in vec2", "\n\tvec2 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n\tvec3 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y - r.z;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n\tvec4 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y - r.z - r.w;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in float h )\n{\n\tvec2 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y - h;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r, in float h )\n{\n\tvec3 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y - r.z - h;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r, in float h )\n{\n\tvec4 d = abs(p) - b;\n\td = max(d,0.0);\n\treturn length(d) - r.x - r.y - r.z - r.w - h;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r, in float h, in float d )\n{\n\tvec2 d1 = abs(p) - b;\n\td1 = max(d1,", "\n    // Project the center of the disk onto the plane.\n    proj_center = proj_info.xy * center;\n\n    // Project the normal of the disk onto the plane.\n    vec3 proj_normal = proj_info.xy * normal;\n\n    // Project the radius of the disk onto the plane.\n    float proj_radius = proj_info.z * radius;\n\n    // Project the major axis of the disk onto the plane.\n    major = proj_info.xy * (center + proj_normal * proj_radius);\n\n    // Project the minor axis of the disk onto the plane.\n    minor = proj_info.xy * (center - proj_normal * proj_radius);\n}\n\n// Disk projection code (project_disk()) is by me and is CC0.\n// Currently, there's some float instability near grazing angles.\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor,\n    out vec2 major_tangent,\n    out vec2 minor_tangent\n){\n    // Project the center of the disk onto the plane.\n    proj_center = proj_info.xy * center;\n\n    // Project the normal of the disk onto the plane.\n    vec3 proj_normal = proj_info.xy * normal;\n\n    // Project the radius of the disk onto the plane.\n    float proj_radius = proj_info.z * radius;\n\n    // Project the major axis of the disk onto the plane.\n    major = proj_info.xy * (center + proj_normal * proj_radius);\n\n    // Project the minor axis of the disk onto the plane.\n    minor = proj_info.xy * (center - proj_normal * proj_radius);\n\n    // Project the major axis tangent of the disk onto the plane.\n    major_tangent = proj_info.xy * (center + proj_", "\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash13(vec2 p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash14(vec2 p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash15(vec2 p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash16(vec2 p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash17(vec2 p)\n{\n    p = fract(p *.1031);\n    p += dot(p, p + 33.3);\n    return fract((p.x + p.y) * p.x * p.y);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash18(vec2 p)\n{\n    p = fract(p *.1031);", "\n\tfloat d = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat q = 0.0;\n\tfloat r2 = r*r;\n\tfloat r3 = r2*r;\n\tfloat r4 = r3*r;\n\tfloat r5 = r4*r;\n\tfloat r6 = r5*r;\n\tfloat r7 = r6*r;\n\tfloat r8 = r7*r;\n\tfloat r9 = r8*r;\n\tfloat r10 = r9*r;\n\tfloat r11 = r10*r;\n\tfloat r12 = r11*r;\n\tfloat r13 = r12*r;\n\tfloat r14 = r13*r;\n\tfloat r15 = r14*r;\n\tfloat r16 = r15*r;\n\tfloat r17 = r16*r;\n\tfloat r18 = r17*r;\n\tfloat r19 = r18*r;\n\tfloat r20 = r19*r;\n\tfloat r21 = r20*r;\n\tfloat r22 = r21*r;\n\tfloat r23 = r22*r;\n\tfloat r24 = r23*r;\n\tfloat r25 = r24*r;\n\tfloat r26 = r25*r;\n\tfloat r27 = r26*r;\n\tfloat r28 = r27*r;\n\tfloat r29 = r28*r;\n\tfloat r30 = r29*r;\n\tfloat r31 = r30*r;\n\tfloat r32 = r31", "\n\tvec3 a = p - v[0];\n\tvec3 b = p - v[1];\n\tvec3 c = p - v[2];\n\tvec3 d = p - v[3];\n\tvec3 n = normalize( cross( a, b ) + cross( b, c ) + cross( c, d ) + cross( d, a ) );\n\treturn n;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, vec3 n )\n{\n\tvec3 a = p - v[0];\n\tvec3 b = p - v[1];\n\tvec3 c = p - v[2];\n\tvec3 d = p - v[3];\n\tvec3 n2 = normalize( cross( a, b ) + cross( b, c ) + cross( c, d ) + cross( d, a ) );\n\treturn normalize( n + n2 );\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, vec3 n, float h )\n{\n\tvec3 a = p - v[0];\n\tvec3 b = p - v[1];\n\tvec3 c = p - v[2];\n\tvec3 d = p - v[3];\n\tvec3 n2 = normalize( cross( a, b ) + cross( b, c ) + cross( c, d ) + cross( d, a ) );\n\treturn normalize( n + n2 * h );\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, vec3 n, float h, float k )\n{\n\tvec3 a = p - v[0];\n\tvec3 b = p - v[1];\n\tvec3 c = p - v[2];\n\tvec3 d = p - v[3];\n\tvec3 n2 = normalize( cross( a, b ) + cross( b, c ) + cross( c, d ) + cross( d, a ) );\n\treturn normalize( n + n2 * h + n2 * k );\n}\n", "\n    float t = t0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (t > t1)\n            return 1.0;\n        if (scene.intersect(p, t))\n            return 0.0;\n        t += EPSILON;\n    }\n    return 1.0;\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1, vec3 &normal)\n{\n    float t = t0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (t > t1)\n            return 1.0;\n        if (scene.intersect(p, t, normal))\n            return 0.0;\n        t += EPSILON;\n    }\n    return 1.0;\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1, vec3 &normal, vec3 &color)\n{\n    float t = t0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (t > t1)\n            return 1.0;\n        if (scene.intersect(p, t, normal, color))\n            return 0.0;\n        t += EPSILON;\n    }\n    return 1.0;\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that", "\n\tfloat ao = 0.0;\n\tfloat dist = 0.0;\n\tfloat step = 0.01;\n\tfloat maxDist = 0.05;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tdist += step;\n\t\tvec3 dir = nor * dist;\n\t\tvec3 p = pos + dir;\n\t\tfloat d = distance( p, vec3( 0.0 ) );\n\t\tif( d > maxDist )\n\t\t\tbreak;\n\t\tao += 1.0 - d;\n\t}\n\treturn ao / 10.0;\n}\n\nvoid main()\n{\n\tvec3 pos = vPosition;\n\tvec3 nor = normalize( vNormal );\n\tvec3 col = vec3( 0.0 );\n\tfloat ao = calcAO( pos, nor );\n\tcol = vec3( ao );\n\tgl_FragColor = vec4( col, 1.0 );\n}\n`;\n\nexport const fragmentShader = `\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec3 uColor;\n\nvoid main()\n{\n\tgl_FragColor = vec4( uColor, 1.0 );\n}\n`;\n/src/components/App/App.js\nimport React, { Component } from'react';\nimport { connect } from'react-redux';\nimport { bindActionCreators } from'redux';\nimport * as actions from '../../actions';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from'react-router-dom';\nimport {\n  Home,\n  About,\n  Contact,\n  NotFound,\n  Login,\n  Register,\n  Profile,\n  Settings,\n  Logout,\n  ResetPassword,\n  ResetPasswordConfirm,\n  ResetPasswordRequest,\n  ResetPasswordRequestConfirm,\n  ResetPasswordRequestComplete,\n  ResetPasswordRequestCompleteConfirm,\n  ResetPasswordRequestCompleteComplete,\n  ResetPasswordRequestCompleteCompleteConfirm,\n  ResetPasswordRequestCompleteCompleteComplete,\n  ResetPasswordRequestCompleteCompleteCompleteConfirm,\n  ResetPasswordRequestCompleteCompleteCompleteComplete,\n  ResetPasswordRequestCompleteCompleteCompleteCompleteConfirm,\n  ResetPasswordRequestCompleteCompleteCompleteCompleteComplete,\n  ResetPasswordRequestCompleteCompleteCompleteCompleteCompleteConfirm,\n  ResetPassword", "\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\tfloat t = 1 - c;\n\n\tvec3 axis_normalized = normalize(axis);\n\n\treturn mat3(\n\t\tt * axis_normalized.x * axis_normalized.x + c,\n\t\tt * axis_normalized.x * axis_normalized.y + s * axis_normalized.z,\n\t\tt * axis_normalized.x * axis_normalized.z - s * axis_normalized.y,\n\t\tt * axis_normalized.x * axis_normalized.y - s * axis_normalized.z,\n\t\tt * axis_normalized.y * axis_normalized.y + c,\n\t\tt * axis_normalized.y * axis_normalized.z + s * axis_normalized.x,\n\t\tt * axis_normalized.x * axis_normalized.z + s * axis_normalized.y,\n\t\tt * axis_normalized.y * axis_normalized.z - s * axis_normalized.x,\n\t\tt * axis_normalized.z * axis_normalized.z + c\n\t);\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, -s,\n\t\t0, s, c\n\t);\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat3(\n\t\tc, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c\n\t);\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat3(\n\t\tc, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t);\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle", "\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0) * 2.0 - 1.0);\n\tray.z = -1.0;\n\treturn ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec3 cameraPos, vec3 cameraDir, vec3 cameraUp) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0) * 2.0 - 1.0);\n\tray.z = -1.0;\n\treturn ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec3 cameraPos, vec3 cameraDir, vec3 cameraUp, float fov) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0) * 2.0 - 1.0);\n\tray.z = -1.0;\n\treturn ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec3 cameraPos, vec3 cameraDir, vec3 cameraUp, float fov, float aspect) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0) * 2.0 - 1.0);\n\tray.z = -1.0;\n\treturn ray;\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord, vec3 cameraPos, vec3 cameraDir, vec3 cameraUp, float fov, float aspect, float near, float far) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 1.0) * 2.0 - 1.0);\n\tray.z = -", "\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3dTime(vec3 co){\n\treturn fract(sin(dot(co.xyz,vec3(12.9898,78.233,12.9898))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4dTime(vec4 co){\n\treturn fract(sin(dot(co.xyzw,vec4(12.9898,78.233,12.9898,12.9898))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co){\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co){\n\treturn fract(sin(dot(co.xyz,vec3(12.9898,78.233,12.9898))) * 43758.5453);\n}\n\n// 4d noise\nfloat rand4d(vec4 co){\n\treturn fract(sin(dot(co.xyzw,vec4(12.9898,78.233,12.9898,12.9898))) * 43758.5453);\n}\n\n// 2d noise\nfloat rand2d(vec2 co){\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 3d noise\nfloat rand3d(vec3 co){\n\treturn fract(sin(dot(co.", "\n\tfloat a = p.x + p.y + p.z;\n\ta = (a + (a << 8)) & 0x00ff00ff;\n\ta = (a ^ (a >> 9)) & 0x0000ffff;\n\treturn (float)a / 65536.0f;\n}\n\n// Hash for 4d vectors\nfloat rand4d(vec4 p){\n\tfloat a = p.x + p.y + p.z + p.w;\n\ta = (a + (a << 10)) & 0x000003ff;\n\ta = (a ^ (a << 6)) & 0x0003ffff;\n\ta = (a ^ (a << 3)) & 0x1fffffff;\n\treturn (float)a / 1073741824.0f;\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\tfloat a = p.x + p.y;\n\ta = (a + (a << 8)) & 0x00ff00ff;\n\ta = (a ^ (a >> 9)) & 0x0000ffff;\n\treturn (float)a / 65536.0f;\n}\n\n// Hash for 1d vectors\nfloat rand1d(vec1 p){\n\tfloat a = p.x;\n\ta = (a + (a << 8)) & 0x00ff00ff;\n\ta = (a ^ (a >> 9)) & 0x0000ffff;\n\treturn (float)a / 65536.0f;\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n\tfloat a = p.x + p.y;\n\ta = (a + (a << 8)) & 0x00ff00ff;\n\ta = (a ^ (a >> 9)) & 0x0000ffff;\n\treturn (float)a / 65536.0f;\n}\n", "\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(grad3(n+0.0), grad3(n+1.0), f.x), grad3(n+57.0), f.y), grad3(n+113.0), f.z);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x, float seed){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(grad3(n+seed+0.0), grad3(n+seed+1.0), f.x), grad3(n+seed+57.0), f.y), grad3(n+seed+113.0), f.z);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x, vec3 seed){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(grad3(n+seed.x+0.0), grad3(n+seed.x+1.0), f.x), grad3(n+seed.x+57.0), f.y), grad3(n+seed.x+113.0), f.z);\n}\n\n// 3D value noise\nfloat noise3d(vec3 x, vec3 seed, float scale){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3", "\n\tvec3 p0 = floor(p);\n\tvec3 p1 = p0 + vec3(1,1,1);\n\tvec3 p2 = p0 + vec3(1,0,0);\n\tvec3 p3 = p0 + vec3(0,1,0);\n\tvec3 p4 = p0 + vec3(0,0,1);\n\tvec3 p5 = p0 + vec3(1,1,0);\n\tvec3 p6 = p0 + vec3(1,0,1);\n\tvec3 p7 = p0 + vec3(0,1,1);\n\tvec3 p8 = p0 + vec3(1,1,1);\n\tvec3 p9 = p0 + vec3(0,0,0);\n\tvec3 p10 = p0 + vec3(1,0,0);\n\tvec3 p11 = p0 + vec3(0,1,0);\n\tvec3 p12 = p0 + vec3(0,0,1);\n\tvec3 p13 = p0 + vec3(1,1,0);\n\tvec3 p14 = p0 + vec3(1,0,1);\n\tvec3 p15 = p0 + vec3(0,1,1);\n\tvec3 p16 = p0 + vec3(1,1,1);\n\tvec3 p17 = p0 + vec3(0,0,0);\n\tvec3 p18 = p0 + vec3(1,0,0);\n\tvec3 p19 = p0 + vec3(0,1,0);\n\tvec3 p20 = p0 + vec3(0,0,1);\n\tvec3 p21 = p0 + vec3(1,1,0);\n\tvec3 p22 = p0 + vec3(1,0,1);\n\tvec3 p23 = p0 + vec3(0,1,1);\n\tvec3 p24 = p0 + vec3(1,1,1);\n\tvec3 p25 = p0 + vec3(0,0,0);\n\tvec3 p26 = p0", "\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfloat lacunarity = 2.0;\n\tfloat gain = 0.5;\n\tfloat offset = 1.0;\n\tfloat octaves = 6.0;\n\tfor(int i = 0; i < octaves; i++){\n\t\tfbm += amp * noise(p);\n\t\tamp *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn fbm;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain, float octaves){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < octaves; i++){\n\t\tfbm += amp * noise(p);\n\t\tamp *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn fbm;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain, float octaves, float offset){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfloat freq = 1.0;\n\tfor(int i = 0; i < octaves; i++){\n\t\tfbm += amp * noise(p);\n\t\tamp *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn fbm + offset;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain, float octaves, float offset, float freq){\n\tfloat fbm = 0.0;\n\tfloat amp = 1.0;\n\tfor(int i = 0; i < octaves; i++){\n\t\tfbm += amp * noise(p);\n\t\tamp *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn fbm + offset;\n}\n\n// FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain, float oct", "\n\tvec2 result = vec2(0.0);\n\tfloat cloudDensity = 0.0;\n\tfloat cloudColor = 0.0;\n\tfloat cloudColor2 = 0.0;\n\tfloat cloudColor3 = 0.0;\n\tfloat cloudColor4 = 0.0;\n\tfloat cloudColor5 = 0.0;\n\tfloat cloudColor6 = 0.0;\n\tfloat cloudColor7 = 0.0;\n\tfloat cloudColor8 = 0.0;\n\tfloat cloudColor9 = 0.0;\n\tfloat cloudColor10 = 0.0;\n\tfloat cloudColor11 = 0.0;\n\tfloat cloudColor12 = 0.0;\n\tfloat cloudColor13 = 0.0;\n\tfloat cloudColor14 = 0.0;\n\tfloat cloudColor15 = 0.0;\n\tfloat cloudColor16 = 0.0;\n\tfloat cloudColor17 = 0.0;\n\tfloat cloudColor18 = 0.0;\n\tfloat cloudColor19 = 0.0;\n\tfloat cloudColor20 = 0.0;\n\tfloat cloudColor21 = 0.0;\n\tfloat cloudColor22 = 0.0;\n\tfloat cloudColor23 = 0.0;\n\tfloat cloudColor24 = 0.0;\n\tfloat cloudColor25 = 0.0;\n\tfloat cloudColor26 = 0.0;\n\tfloat cloudColor27 = 0.0;\n\tfloat cloudColor28 = 0.0;\n\tfloat cloudColor29 = 0.0;\n\tfloat cloudColor30 = 0.0;\n\tfloat cloudColor31 = 0.0;\n\tfloat cloudColor32 = 0.0;\n\tfloat cloudColor33 = 0.0;\n\tfloat cloudColor34 = 0.0;\n\tfloat cloudColor35 = 0.0;\n\tfloat cloudColor36 = 0.0;\n\tfloat cloudColor37 = 0.0;\n\tfloat cloudColor38 = 0.0;\n\tfloat cloud", "\n\tfloat ground = 0.0;\n\tfloat ground_dist = 0.0;\n\tfloat ground_dist_max = 0.0;\n\tfloat ground_dist_min = 0.0;\n\tfloat ground_dist_max_min = 0.0;\n\tfloat ground_dist_max_min_max = 0.0;\n\tfloat ground_dist_max_min_min = 0.0;\n\tfloat ground_dist_max_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_min = 0.0;\n\tfloat ground_dist_max_min_min_min_min_min_min_min_min_min_max = 0.0;\n\tfloat ground_dist_max_min_min", "\n\tvec3 color = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat step = 0.001;\n\tfloat maxDist = 100.0;\n\tfloat fog = 0.0;\n\tfloat fogDensity = 0.0005;\n\tfloat fogColor = 0.0;\n\tfloat fogMax = 0.0;\n\tfloat fogMin = 0.0;\n\tfloat fogMaxDist = 100.0;\n\tfloat fogMinDist = 10.0;\n\tfloat fogMaxColor = 0.0;\n\tfloat fogMinColor = 0.0;\n\tfloat fogMaxDensity = 0.0005;\n\tfloat fogMinDensity = 0.00005;\n\tfloat fogMaxDist2 = 100.0;\n\tfloat fogMinDist2 = 10.0;\n\tfloat fogMaxColor2 = 0.0;\n\tfloat fogMinColor2 = 0.0;\n\tfloat fogMaxDensity2 = 0.0005;\n\tfloat fogMinDensity2 = 0.00005;\n\tfloat fogMaxDist3 = 100.0;\n\tfloat fogMinDist3 = 10.0;\n\tfloat fogMaxColor3 = 0.0;\n\tfloat fogMinColor3 = 0.0;\n\tfloat fogMaxDensity3 = 0.0005;\n\tfloat fogMinDensity3 = 0.00005;\n\tfloat fogMaxDist4 = 100.0;\n\tfloat fogMinDist4 = 10.0;\n\tfloat fogMaxColor4 = 0.0;\n\tfloat fogMinColor4 = 0.0;\n\tfloat fogMaxDensity4 = 0.0005;\n\tfloat fogMinDensity4 = 0.00005;\n\tfloat fogMaxDist5 = 100.0;\n\tfloat fogMinDist5 = 10.0;\n\tfloat fogMaxColor5 = 0.0;\n\tfloat fogMinColor5 = 0.0;\n\tfloat fogMaxDensity", "\n\tcolor = color * (1.0 / 1.055) - (16.0 / 116.0);\n\tcolor = max(vec3(0.0), color);\n\treturn 2.51 * pow(color, vec3(2.4)) * (1.0 / 1.0893);\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma) {\n\treturn pow(color, vec3(1.0 / gamma));\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure) {\n\treturn pow(color * exposure, vec3(1.0 / gamma));\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure, float white) {\n\treturn pow(color * exposure / white, vec3(1.0 / gamma));\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure, float white, float black) {\n\treturn pow(color * exposure / white, vec3(1.0 / gamma)) * (1.0 - black);\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure, float white, float black, float white_point) {\n\treturn pow(color * exposure / white, vec3(1.0 / gamma)) * (1.0 - black) + black;\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure, float white, float black, float white_point, float black_point) {\n\treturn pow(color * exposure / white, vec3(1.0 / gamma)) * (1.0 - black) + black;\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure, float white, float black, float white_point, float black_point, float white_point_exposure) {\n\treturn pow(color * exposure / white, vec3(1.0 / gamma)) * (1.0 - black) + black;\n}\n\n// Gamma correction\nvec3 gamma_correction(vec3 color, float gamma, float exposure,"]}