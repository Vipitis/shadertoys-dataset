{"generations": ["\n    return 0.282095;\n}\n\nfloat SH_1_0( in vec3 s ) {\n    return -0.488603 * s.y;\n}\n\nfloat SH_1_1( in vec3 s ) {\n    return 0.488603 * s.z;\n}\n\nfloat SH_1_2( in vec3 s ) {\n    return 0.488603 * s.x;\n}\n\nfloat SH_2_0( in vec3 s ) {\n    return 1.092548 * s.x * s.y;\n}\n\nfloat SH_2_1( in vec3 s ) {\n    return -1.092548 * s.y * s.z;\n}\n\nfloat SH_2_2( in vec3 s ) {\n    return 0.315392 * ( 3.0 * s.z * s.z - 1.0 );\n}\n\nfloat SH_2_3( in vec3 s ) {\n    return -1.092548 * s.x * s.z;\n}\n\nfloat SH_2_4( in vec3 s ) {\n    return 0.546274 * ( s.x * s.x - s.y * s.y );\n}\n\nfloat SH_3_0( in vec3 s ) {\n    return -0.5900434 * s.x * s.y * s.z;\n}\n\nfloat SH_3_1( in vec3 s ) {\n    return 2.890611 * s.y * ( s.z * s.z - s.x * s.x );\n}\n\nfloat SH_3_2( in vec3 s ) {\n    return -0.4570458 * s.z * ( 3.0 * s.z * s.z - 1.0 );\n}\n\nfloat SH_3_3( in vec3 s ) {\n    return 0.3731767 * ( s.z * s.z - s.x * s.x );\n}\n\nfloat SH_3_4( in vec3 s ) {\n    return -0.4570458 * s.x * ( s.z * s.z - 3.0 * s.x * s.x );\n}\n\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat segment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat ray( in vec2 a, in vec2 dir, in vec2 p )\n{\n    return length( (p-a)*dir - (p-a) );\n}\n\n// distance to a triangle\nfloat triangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 v0 = b - a, v1 = c - b, v2 = a - c;\n    float dot00 = dot( v0, v0 );\n    float dot01 = dot( v0, v1 );\n    float dot02 = dot( v0, v2 );\n    float dot11 = dot( v1, v1 );\n    float dot12 = dot( v1, v2 );\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return (u < 0.0 || v < 0.0 || (u + v) > 1.0)? min( min( length( pa ), length( pb ) ), length( pc ) ) : length( pa * u + pb * v );\n}\n\n// distance to a quad\nfloat quad( in vec2 a, in vec2 b, in vec2 c, in vec2 d,", "ip\n    return ( dot(v,r) < 0.0 )? -v : v;\n}", "lecture 1\n    return v - 2.0 * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return v - 2.0 * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return v - 2.0 * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in float t )\n{\n    return v - t * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in float t )\n{\n    return v - t * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r, in float t )\n{\n    return v - t * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in vec2 t )\n{\n    return v - t * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r, in vec3 t )\n{\n    return v - t * r * dot( r, v );\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in", "ip\n\treturn v.x < 0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n\treturn v.x < 0.0? vec3(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n\treturn v.x < 0.0? vec4(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in float r )\n{\n\treturn v.x < 0.0? vec2(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in float r )\n{\n\treturn v.x < 0.0? vec3(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in float r )\n{\n\treturn v.x < 0.0? vec4(0.0) : v;\n}", "// a,b are the start and end points of the arrow, w1 is the width of the arrow at the start, w2 is the width at the end\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix( w1, w2, h );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w )\n{\n    return sdArrow( p, a, b, w, w );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow( p, a, b, 0.1, 0.1 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w, float h )\n{\n    return sdArrow( p, a, b, w, h );\n}", " isSun = (dot(rayDir, sunDir) > 0.0);\n  if (isSun)\n  {\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle3 = sunAngle2 * sunAngle;\n    float sunAngle4 = sunAngle3 * sunAngle;\n    float sunAngle5 = sunAngle4 * sunAngle;\n    float sunAngle6 = sunAngle5 * sunAngle;\n    float sunAngle7 = sunAngle6 * sunAngle;\n    float sunAngle8 = sunAngle7 * sunAngle;\n    float sunAngle9 = sunAngle8 * sunAngle;\n    float sunAngle10 = sunAngle9 * sunAngle;\n    float sunAngle11 = sunAngle10 * sunAngle;\n    float sunAngle12 = sunAngle11 * sunAngle;\n    float sunAngle13 = sunAngle12 * sunAngle;\n    float sunAngle14 = sunAngle13 * sunAngle;\n    float sunAngle15 = sunAngle14 * sunAngle;\n    float sunAngle16 = sunAngle15 * sunAngle;\n    float sunAngle17 = sunAngle16 * sunAngle;\n    float sunAngle18 = sunAngle17 * sunAngle;\n    float sunAngle19 = sunAngle18 * sunAngle;\n    float sunAngle20 = sunAngle19 * sunAngle;\n    float sunAngle21 = sunAngle20 * sunAngle;\n    float sunAngle22 = sunAngle21 * sunAngle;\n    float sunAngle23 = sunAngle22 * sunAngle;\n    float sunAngle24 = sunAngle23 * sunAngle;\n    float sunAngle25 = sunAngle24 * sunAngle;\n    float sunAngle26 = sunAngle25 * sunAngle;\n    float sunAngle27 = sunAngle26 * sunAngle;\n    float sunAngle28 = sunAngle27 * sunAngle;\n    float sunAngle29 = sunAngle28 * sunAngle;\n    float sunAngle30 = sunAngle29 * sunAngle;\n    float sunAngle31 = sunAngle30 * sunAngle;\n    float sunAngle32 = sunAngle31 * sunAngle;\n    float sunAngle33 = sunAngle32 * sunAngle;\n    float sunAngle34 = sunAngle33 * sunAngle;\n    float sunAngle35 = sunAngle", "ine\n    float t2 = t * t;\n    float t3 = t2 * t;\n\n    return 0.5 * ((2.0 * p1) +\n                  (-p0 + p2) * t +\n                  (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n                  (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t3);\n}", "ic\n\tfloat r = 0.0;\n\tfloat w = 1.0;\n\tfloat freq = 1.0;\n\tvec3 bp = p;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tr += -0.5*w*sin(6.2831*0.5*dot(p,bp));\n\t\tbp = normalize(bp*nudge + vec3(w,w,w));\t// rotate and nudge the basis vector\n\t\tw *= normalizer;\t// closer to plane, the smaller the rotation, the more sin waves\n\t\tfreq *= 1.1892;\t// 1.1892 = 3^(1/3) = e^(1/3) is relative fundamental frequency, others are ratios of this\n\t}\n\treturn r / freq;\n}", "\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\n\treturn 0.5 * ((2.0 * p1) + (-p0 + p2) * t + (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 + (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t3);\n}\n\n// from a time t, this finds the derivative of the camera path.\n// It uses Catmull-Rom splines\nvec4 CamVel(float t)\n{\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n\n\treturn 0.5 * ((-p0 + p2) + 2.0 * (-p0 + p1) * t + 3.0 * (p0 - 2.0 * p1 + p2) * t2);\n}\n\n// from a time t, this finds the second derivative of the camera path.\n// It uses Catmull-Rom splines\nvec4 CamAcc(float t)\n{\n\tvec4 p0 = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 p", "\n    u = fract(u * 0.8);\n    u = u * u * (3. - 2. * u);\n    return u;\n}\n\nfloat Hash2d(vec2 uv)\n{\n    uv = fract(uv * 0.8);\n    uv = uv * uv * (3. - 2. * uv);\n    return uv.x * uv.y;\n}\n\nfloat Hash3d(vec3 p)\n{\n    p = fract(p * 0.8);\n    p = p * p * (3. - 2. * p);\n    return p.x * p.y * p.z;\n}\n\nfloat Noise1d(float u)\n{\n    float i = floor(u);\n    float f = fract(u);\n    return mix(Hash1d(i), Hash1d(i + 1.0), smoothstep(0., 1., f));\n}\n\nfloat Noise2d(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    return mix(mix(Hash2d(i), Hash2d(i + vec2(1.0, 0.0)), smoothstep(0., 1., f.x)),\n               mix(Hash2d(i + vec2(0.0, 1.0)), Hash2d(i + vec2(1.0, 1.0)), smoothstep(0., 1., f.x)),\n               smoothstep(0., 1., f.y));\n}\n\nfloat Noise3d(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return mix(mix(mix(Hash3d(i), Hash3d(i + vec3(1.0, 0.0, 0.0)), smoothstep(0., 1., f.x)),\n                   mix(Hash3d(i + vec3(0.0, 1.0, 0.0)), Hash3d(i + vec3(1.0, 1.0, 0.0)), smoothstep(0., ", "nudge;\n\tfloat rot = 0.0;\n\tfloat f = 0.0;\n\tfloat w = 0.5;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfloat s = sin(rot);\n\t\tfloat c = cos(rot);\n\t\tp.x = c*p.x - s*p.y;\n\t\tp.y = s*p.x + c*p.y;\n\t\trot += 0.1;\n\t\tp = abs(p);\n\t\tp -= 0.1;\n\t\tf += w*p.x;\n\t\tw *= 0.8;\n\t\tp += 0.1;\n\t}\n\treturn f;\n}\n\n// 3D value noise by Dave Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\nfloat ValueNoise3D(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\tvec3 u = f*f*(3.0-2.0*f);\n\treturn mix(mix(mix(hash(i + vec3(0.0, 0.0, 0.0)), hash(i + vec3(1.0, 0.0, 0.0)), u.x),\n\t\t\t\t   mix(hash(i + vec3(0.0, 1.0, 0.0)), hash(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n\t\t\t   mix(mix(hash(i + vec3(0.0, 0.0, 1.0)), hash(i + vec3(1.0, 0.0, 1.0)), u.x),\n\t\t\t\t   mix(hash(i + vec3(0.0, 1.0, 1.0)), hash(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\n// 3D simplex noise by Ian McEwan\n// https://www.shadertoy.com/view", " isect = vec3(0.0);\n  float d = 0.0;\n  float t = 0.0;\n  float h = 0.0;\n  float s = 0.0;\n  float ns = 0.0;\n  float n = 0.0;\n  float m = 0.0;\n  float f = 0.0;\n  float r = 0.0;\n  float g = 0.0;\n  float b = 0.0;\n  float a = 0.0;\n  float c = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  ", "ure(rayDir.y < 0.0)\n    {\n        return vec3(0.0);\n    }\n\n    vec3 envColor = vec3(0.0);\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle3 = sunAngle2 * sunAngle;\n    float sunAngle4 = sunAngle3 * sunAngle;\n    float sunAngle5 = sunAngle4 * sunAngle;\n    float sunAngle6 = sunAngle5 * sunAngle;\n    float sunAngle7 = sunAngle6 * sunAngle;\n    float sunAngle8 = sunAngle7 * sunAngle;\n    float sunAngle9 = sunAngle8 * sunAngle;\n    float sunAngle10 = sunAngle9 * sunAngle;\n    float sunAngle11 = sunAngle10 * sunAngle;\n    float sunAngle12 = sunAngle11 * sunAngle;\n    float sunAngle13 = sunAngle12 * sunAngle;\n    float sunAngle14 = sunAngle13 * sunAngle;\n    float sunAngle15 = sunAngle14 * sunAngle;\n    float sunAngle16 = sunAngle15 * sunAngle;\n    float sunAngle17 = sunAngle16 * sunAngle;\n    float sunAngle18 = sunAngle17 * sunAngle;\n    float sunAngle19 = sunAngle18 * sunAngle;\n    float sunAngle20 = sunAngle19 * sunAngle;\n    float sunAngle21 = sunAngle20 * sunAngle;\n    float sunAngle22 = sunAngle21 * sunAngle;\n    float sunAngle23 = sunAngle22 * sunAngle;\n    float sunAngle24 = sunAngle23 * sunAngle;\n    float sunAngle25 = sunAngle24 * sunAngle;\n    float sunAngle26 = sunAngle25 * sunAngle;\n    float sunAngle27 = sunAngle26 * sunAngle;\n    float sunAngle28 = sunAngle27 * sunAngle;\n    float sunAngle29 = sunAngle28 * sunAngle;\n    float sunAngle30 = sunAngle29 * sunAngle;\n    float sunAngle31 = sunAngle30 * sunAngle;\n    float sunAngle32 = sunAngle31 * sunAngle;\n    float sunAngle33 = sunAngle32 * sunAngle;\n    float sunAngle34 = sunAngle", " interpolation = smoothstep( a - k, a + k, b );\n  return min( a, b ) - k * interpolation * ( 1.0 - interpolation );\n}", "\n\tvec3 distVec = spherePos - pos;\n\tfloat dist = length(distVec);\n\tfloat distSq = dist * dist;\n\tfloat radSq = rad * rad;\n\tfloat distSqMinusRadSq = distSq - radSq;\n\tfloat distSqMinusRadSqSq = distSqMinusRadSq * distSqMinusRadSq;\n\tfloat dirVecDotDistVec = dot(dirVecPLZNormalizeMeFirst, distVec);\n\tfloat dirVecDotDistVecSq = dirVecDotDistVec * dirVecDotDistVec;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSq = dirVecDotDistVecSq - distSqMinusRadSqSq;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSqSq = dirVecDotDistVecSqMinusDistSqMinusRadSqSq * dirVecDotDistVecSqMinusDistSqMinusRadSqSq;\n\tfloat dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt = sqrt(dirVecDotDistVecSqMinusDistSqMinusRadSqSqSq);\n\tfloat t1 = dirVecDotDistVec - dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt;\n\tfloat t2 = dirVecDotDistVec + dirVecDotDistVecSqMinusDistSqMinusRadSqSqSqSqrt;\n\tfloat t = min(t1, t2);\n\treturn t;\n}", " theta = 0.0;\n  phi = 0.0;\n  \n  // Sphere\n  vec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n  float sphereRadius = 1.0;\n  vec3 sphereNormal = normalize(p - sphereCenter);\n  float sphereDistance = length(p - sphereCenter) - sphereRadius;\n  \n  // Cylinder\n  vec3 cylinderCenter = vec3(0.0, 0.0, 0.0);\n  float cylinderRadius = 0.5;\n  float cylinderHeight = 1.0;\n  vec3 cylinderNormal = normalize(vec3(0.0, 1.0, 0.0));\n  float cylinderDistance = abs(dot(p - cylinderCenter, cylinderNormal)) - cylinderRadius;\n  \n  // Combine the distances\n  float distance = min(sphereDistance, cylinderDistance);\n  \n  // Calculate the normal vector\n  vec3 normal = normalize(sphereNormal);\n  \n  // Return the distance and normal vector\n  return vec2(distance, normal.x);\n}", "\n    return vec3(t, 0.0, 0.0);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(0.0, 0.0, 1.0);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD14(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 mapD15(float t)\n{\n    return vec", "\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    return normalize(p1 - p);\n}\n\n// curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    vec3 p2 = map(t + 0.0002);\n    return normalize(p2 - 2.0 * p1 + p);\n}\n\n// curve third derivative (jerk)\nvec3 mapD3(float t)\n{\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    vec3 p2 = map(t + 0.0002);\n    vec3 p3 = map(t + 0.0003);\n    return normalize(p3 - 3.0 * p2 + 3.0 * p1 - p);\n}\n\n// curve fourth derivative (snap)\nvec3 mapD4(float t)\n{\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    vec3 p2 = map(t + 0.0002);\n    vec3 p3 = map(t + 0.0003);\n    vec3 p4 = map(t + 0.0004);\n    return normalize(p4 - 4.0 * p3 + 6.0 * p2 - 4.0 * p1 + p);\n}\n\n// curve fifth derivative (crackle)\nvec3 mapD5(float t)\n{\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.0001);\n    vec3 p2 = map(t + 0.0002);\n    vec3 p3 = map(t + 0.0003);\n    vec3 p4 = map(t + 0.0004);\n    vec3 p5 = map(t + 0.0005);\n    return normalize(p5 - 5.0 * p4 + 10.0", "\n    vec3 p = map(t);\n    vec3 p1 = map(t + 0.001);\n    vec3 p2 = map(t + 0.002);\n    vec3 p3 = map(t + 0.003);\n    vec3 p4 = map(t + 0.004);\n    vec3 p5 = map(t + 0.005);\n    vec3 p6 = map(t + 0.006);\n    vec3 p7 = map(t + 0.007);\n    vec3 p8 = map(t + 0.008);\n    vec3 p9 = map(t + 0.009);\n    vec3 p10 = map(t + 0.01);\n    vec3 p11 = map(t + 0.011);\n    vec3 p12 = map(t + 0.012);\n    vec3 p13 = map(t + 0.013);\n    vec3 p14 = map(t + 0.014);\n    vec3 p15 = map(t + 0.015);\n    vec3 p16 = map(t + 0.016);\n    vec3 p17 = map(t + 0.017);\n    vec3 p18 = map(t + 0.018);\n    vec3 p19 = map(t + 0.019);\n    vec3 p20 = map(t + 0.02);\n    vec3 p21 = map(t + 0.021);\n    vec3 p22 = map(t + 0.022);\n    vec3 p23 = map(t + 0.023);\n    vec3 p24 = map(t + 0.024);\n    vec3 p25 = map(t + 0.025);\n    vec3 p26 = map(t + 0.026);\n    vec3 p27 = map(t + 0.027);\n    vec3 p28 = map(t + 0.028);\n    vec3 p29 = map(t + 0.029);\n    vec3 p30 = map(t + 0.03);\n    vec3 p31 = map(t + 0.031);\n    vec", " distance = length(cross(b-a,a-p))/length(b-a);\n  vec3 c = clamp( dot(a-p,b-a)/dot(b-a,b-a), 0., 1. )*b + (1.-clamp( dot(b-a,b-a)/dot(b-a,b-a), 0., 1. ))*a;\n  return vec2( distance, c );\n}", "(a,b,o,d)\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    vec3 abd = cross( ab, d );\n    vec3 oab = cross( ao, ab );\n    float t = dot( ao, abd ) / dot( abd, abd );\n    float u = dot( d, oab ) / dot( abd, abd );\n    vec3 p = a + ab * clamp( t, 0.0, 1.0 );\n    return vec2( length( o - p ), u );\n}", ".\n    vec2 q = abs(p)-b+r.xy;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.z;\n}", " isSun = (dot(rayDir, sunDir) > 0.0);\n  if (isSun)\n  {\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = sunAngle * sunAngle;\n    float sunAngle3 = sunAngle2 * sunAngle;\n    float sunAngle4 = sunAngle3 * sunAngle;\n    float sunAngle5 = sunAngle4 * sunAngle;\n    float sunAngle6 = sunAngle5 * sunAngle;\n    float sunAngle7 = sunAngle6 * sunAngle;\n    float sunAngle8 = sunAngle7 * sunAngle;\n    float sunAngle9 = sunAngle8 * sunAngle;\n    float sunAngle10 = sunAngle9 * sunAngle;\n    float sunAngle11 = sunAngle10 * sunAngle;\n    float sunAngle12 = sunAngle11 * sunAngle;\n    float sunAngle13 = sunAngle12 * sunAngle;\n    float sunAngle14 = sunAngle13 * sunAngle;\n    float sunAngle15 = sunAngle14 * sunAngle;\n    float sunAngle16 = sunAngle15 * sunAngle;\n    float sunAngle17 = sunAngle16 * sunAngle;\n    float sunAngle18 = sunAngle17 * sunAngle;\n    float sunAngle19 = sunAngle18 * sunAngle;\n    float sunAngle20 = sunAngle19 * sunAngle;\n    float sunAngle21 = sunAngle20 * sunAngle;\n    float sunAngle22 = sunAngle21 * sunAngle;\n    float sunAngle23 = sunAngle22 * sunAngle;\n    float sunAngle24 = sunAngle23 * sunAngle;\n    float sunAngle25 = sunAngle24 * sunAngle;\n    float sunAngle26 = sunAngle25 * sunAngle;\n    float sunAngle27 = sunAngle26 * sunAngle;\n    float sunAngle28 = sunAngle27 * sunAngle;\n    float sunAngle29 = sunAngle28 * sunAngle;\n    float sunAngle30 = sunAngle29 * sunAngle;\n    float sunAngle31 = sunAngle30 * sunAngle;\n    float sunAngle32 = sunAngle31 * sunAngle;\n    float sunAngle33 = sunAngle32 * sunAngle;\n    float sunAngle34 = sunAngle33 * sunAngle;\n    float sunAngle35 = sunAngle", "\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}", "\n    vec3 p = currentRayPosition - vec3( 0.0, 0.0, 0.0 );\n    float d = length( p ) - 1.0;\n    return vec2( d, 0.0 );\n}", "\n    \n    // get the distance to each thing\n    float distanceToThing1 = distance( thing1, vec2(0.0) );\n    float distanceToThing2 = distance( thing2, vec2(0.0) );\n    \n    // compare the distances\n    if( distanceToThing1 < distanceToThing2 ){\n        return thing1;\n    }\n    else{\n        return thing2;\n    }\n}", " theWorld;\n    float closestDistance = 100000.0;\n    float closestThing = 0.0;\n    \n    // Loop through all the things in the world\n    for( int i = 0; i < theWorld.length(); i++ ){\n        // Get the distance to the thing\n        float distanceToThing = distanceToThing( currentRayPosition, theWorld[i] );\n        \n        // If it's closer than the closest thing so far\n        if( distanceToThing < closestDistance ){\n            // Set the closest distance to this thing\n            closestDistance = distanceToThing;\n            // Set the closest thing to this thing\n            closestThing = float(i);\n        }\n    }\n    \n    // Return the closest distance and closest thing\n    return vec2( closestDistance, closestThing );\n}", " we need to find the normal of the surface\n    // We are going to use the SDF to find the normal of the surface\n    // We are going to do this by taking the SDF at the position of the hit\n    // and the SDF at the position of the hit plus a small amount in the x direction\n    // and the SDF at the position of the hit plus a small amount in the y direction\n    // and the SDF at the position of the hit plus a small amount in the z direction\n    // and then subtracting the SDF at the position of the hit from each of these values\n    // and then dividing the result by the small amount we used to move in each direction\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions\n    // and then we are going to take the average of these three values\n    // This will give us the normal of the surface at the position of the hit\n    // We are going to do this for each of the x, y, and z directions", " theColor = vec3(0.0); }", "s\n    return normalOfSurface * 0.5 + 0.5;\n}", " isInside = false;\n    vec3 color = vec3( 0.0 );\n    vec3 normal = vec3( 0.0 );\n    vec3 hitPosition = vec3( 0.0 );\n    vec3 hitColor = vec3( 0.0 );\n    vec3 hitNormal = vec3( 0.0 );\n    vec3 hitEmission = vec3( 0.0 );\n    vec3 hitReflectivity = vec3( 0.0 );\n    vec3 hitTransparency = vec3( 0.0 );\n    vec3 hitRefractivity = vec3( 0.0 );\n    vec3 hitRefractiveIndex = vec3( 0.0 );\n    vec3 hitRoughness = vec3( 0.0 );\n    vec3 hitMetallic = vec3( 0.0 );\n    vec3 hitSpecular = vec3( 0.0 );\n    vec3 hitDiffuse = vec3( 0.0 );\n    vec3 hitAmbient = vec3( 0.0 );\n    vec3 hitShininess = vec3( 0.0 );\n    vec3 hitGlossiness = vec3( 0.0 );\n    vec3 hitSpecularity = vec3( 0.0 );\n    vec3 hitDiffuseness = vec3( 0.0 );\n    vec3 hitAmbientness = vec3( 0.0 );\n    vec3 hitShininessness = vec3( 0.0 );\n    vec3 hitGlossinessness = vec3( 0.0 );\n    vec3 hitSpecularness = vec3( 0.0 );\n    vec3 hitDiffusenessness = vec3( 0.0 );\n    vec3 hitAmbientnessness = vec3( 0.0 );\n    vec3 hitShininessnessness = vec3( 0.0 );\n    vec3 hitGlossinessnessness = vec3( 0.0 );\n    vec3 hitSpecularnessness = vec3( 0.0 );\n    vec3 hitDiffusenessnessness = vec3( 0.0 );\n    vec3 hitAmbientnessnessness = vec3(", "(\n    return x / (((1.0 / b) - 2.0) * (1.0 - x) + 1.0);\n}", " noise(p); return fract(noise(p)); }\n\n// creates white noise in the range -1..1 including -1 excluding 1\nfloat randSigned(vec2 p){ noise(p); return fract(noise(p))*2.0-1.0; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec3 p){ noise(p); return fract(noise(p)); }\n\n// creates white noise in the range -1..1 including -1 excluding 1\nfloat randSigned(vec3 p){ noise(p); return fract(noise(p))*2.0-1.0; }\n\n// creates white noise in the range 0..1 including 0 excluding 1\nfloat rand(vec4 p){ noise(p); return fract(noise(p)); }\n\n// creates white noise in the range -1..1 including -1 excluding 1\nfloat randSigned(vec4 p){ noise(p); return fract(noise(p))*2.0-1.0; }", " noise(p); return fract(noise(p)); }\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec2 p){ noise(p); return fract(noise(p)) * 0.999; }\n\n// creates white noise in the range -1..1 excluding -1 and 1\nfloat rand_signed(vec2 p){ noise(p); return fract(noise(p)) * 2.0 - 1.0; }\n\n// creates white noise in the range -1..1 including -1 and 1\nfloat rand_signed_inclusive(vec2 p){ noise(p); return fract(noise(p)) * 2.0 - 1.0; }\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec3 p){ noise(p); return fract(noise(p)); }\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec3 p){ noise(p); return fract(noise(p)) * 0.999; }\n\n// creates white noise in the range -1..1 excluding -1 and 1\nfloat rand_signed(vec3 p){ noise(p); return fract(noise(p)) * 2.0 - 1.0; }\n\n// creates white noise in the range -1..1 including -1 and 1\nfloat rand_signed_inclusive(vec3 p){ noise(p); return fract(noise(p)) * 2.0 - 1.0; }\n\n// creates white noise in the range 0..1 including 0 including 1\nfloat rand_inclusive(vec4 p){ noise(p); return fract(noise(p)); }\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec4 p){ noise(p); return fract(noise(p)) * 0.999; }\n\n// creates white noise in the range -1..1 excluding -1 and 1\nfloat rand_signed(vec4 p){ noise(p); return fract(noise(p)) * 2.0 - 1.0; }\n\n// creates white noise in the range -1..", "(\n    return length(p) - r;\n)\n}", "\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}", "(\n    float h = clamp( 0.5 + 0.5*(d2-d1)/smoothness, 0.0, 1.0 );\n    return mix( d2, d1, h ) - smoothness*h*(1.0-h);\n)\n}", "~~~~~~~\n    return max(min(d1,d2),0.0) + sqrt(max(d1,d2)-pow(d1*d2,0.5));\n}\n\n// ~~~~~~~ distance union, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opUnion( float d1, float d2)\n{~~~~~~~\n    return min(d1,d2);\n}\n\n// ~~~~~~~ distance subtraction, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opSubtraction( float d1, float d2)\n{~~~~~~~\n    return max(d1,-d2);\n}\n\n// ~~~~~~~ distance intersection, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opIntersection( float d1, float d2)\n{~~~~~~~\n    return max(d1,d2);\n}\n\n// ~~~~~~~ distance smooth union, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> smoothing factor\n// output --> blended object\nfloat opSmoothUnion( float d1, float d2, float k)\n{~~~~~~~\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance smooth subtraction, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// input k --> smoothing factor\n// output --> blended object\nfloat opSmoothSubtraction( float d1, float d2, float k)\n{~~~~~~~\n    float h = clamp( 0.5 - 0.5*(d2", "(\n    float c = cos(t*p.y);\n    float s = sin(t*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}", "~~~~\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{~~~~\n    if (o1.x > o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opD(vec2 o1, vec2 o2)\n{~~~~\n    if (o1.x < -o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Symmetric Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opSD(vec2 o1, vec2 o2)\n{~~~~\n    if (o1.x < -o2.x)\n        return o1;\n    else if (o1.x > o2.x)\n        return o2;\n    else\n        return vec2(abs(o1.x)-abs(o2.x), o1.y);\n}\n\n// ~~~~~~~ do Symmetric Difference / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{~~~~\n    if (o1.x < -o2.x)\n        return o1;\n    else if (o1.x > o2.x)\n        return o2;\n    else\n        return vec2(abs(o1.x)-", "~~~~\n    // vec2 res = vec2(10000.0, 0.0);\n    // for (int i = 0; i < 10; i++)\n    // {\n    //     vec3 q = p - vec3(0.0, 0.0, 0.0);\n    //     float d = length(q) - 1.0;\n    //     if (d < res.x)\n    //     {\n    //         res = vec2(d, i);\n    //     }\n    // }\n    // return res;\n    // ~~~~~~~\n    // vec2 res = vec2(10000.0, 0.0);\n    // for (int i = 0; i < 10; i++)\n    // {\n    //     vec3 q = p - vec3(0.0, 0.0, 0.0);\n    //     float d = length(q) - 1.0;\n    //     if (d < res.x)\n    //     {\n    //         res = vec2(d, i);\n    //     }\n    // }\n    // return res;\n    // ~~~~~~~\n    // vec2 res = vec2(10000.0, 0.0);\n    // for (int i = 0; i < 10; i++)\n    // {\n    //     vec3 q = p - vec3(0.0, 0.0, 0.0);\n    //     float d = length(q) - 1.0;\n    //     if (d < res.x)\n    //     {\n    //         res = vec2(d, i);\n    //     }\n    // }\n    // return res;\n    // ~~~~~~~\n    // vec2 res = vec2(10000.0, 0.0);\n    // for (int i = 0; i < 10; i++)\n    // {\n    //     vec3 q = p - vec3(0.0, 0.0, 0.0);\n    //     float d = length(q) - 1.0;\n    //     if (d < res.x)\n    ", "~~~~~~~\n\tvec2 res = vec2( INF, -1.0 );\n\tfloat t = 0.0;\n\tfor( int i = 0; i < MAX_STEPS; i++ )\n\t{\n\t\tvec3 p = ro + rd * t;\n\t\tfloat d = map( p );\n\t\tt += d;\n\t\tif( d < EPSILON )\n\t\t{\n\t\t\tres = vec2( t, float(i) );\n\t\t\tbreak;\n\t\t}\n\t\tif( t > MAX_DIST ) break;\n\t}\n\treturn res;\n}", "~~~~~~~\n    // ~~~~~~~ find closest surface\n    // input ro --> ray original position\n    // input rd --> ray direction\n    // output --> surface position\n    vec3 p = find_closest_surface(ro, rd);\n    \n    // ~~~~~~~ apply color\n    // input p --> surface position\n    // output --> surface color\n    return apply_color(p);\n}", "(\n    vec3 ww = normalize( camPos - targetPos );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n)\n}", "\n    if (id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if (id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if (id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if (id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if (id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if (id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if (id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (id == 7.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (id == 8.0)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if (id == 9.0)\n    {\n        return vec3(0.5, 0.0, 0.0);\n    }\n    else if (id == 10.0)\n    {\n        return vec3(0.0, 0.5, 0.0);\n    }\n    else if (id == 11.0)\n    {\n        return vec3(0.0, 0.0, 0.5);\n    }\n    else if (id == 12.0)\n    {\n        return vec3(0.5, 0.5, 0.0);\n    }\n    else if (id == 13.0)\n    {\n        return vec", "\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}", "~~~~\n    return p.y;\n}", "~~~~\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax( float d1, float d2, float k)\n{~~~~\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin_exp( float d1, float d2, float k)\n{~~~~\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*pow(1.0-h,2.0);\n}\n\n// ~~~~~~~ smooth maximum function (exponential version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smax_exp( float d1, float d2, float k)\n{~~~~\n    float h = clamp( 0.5 + 0.5*(", "\n    float d1 = o1.x;\n    float d2 = o2.x;\n    float d = mix(d1, d2, bf);\n    vec3 c1 = o1.yzw;\n    vec3 c2 = o2.yzw;\n    vec3 c = mix(c1, c2, bf);\n    return vec4(d, c);\n}", "~~~~\n    return max(d1,-d2);\n}", "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "\n    // vec4(distance, color)\n    vec4 res = vec4(10000.0, vec3(0.0));\n    \n    // sphere\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q) - 1.0;\n    res = vec4(d, vec3(0.0, 0.0, 1.0));\n    \n    // plane\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float d = dot(p, n);\n    res = vec4(d, vec3(1.0, 0.0, 0.0));\n    \n    // torus\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float r = 0.5;\n    float R = 1.0;\n    float d = length(vec2(length(q.xz) - R, q.y)) - r;\n    res = vec4(d, vec3(1.0, 1.0, 0.0));\n    \n    // box\n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    res = vec4(d, vec3(0.0, 1.0, 0.0));\n    \n    // cylinder\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q.xz) - 0.5;\n    res = vec4(d, vec3(1.0, 0.0, 1.0));\n    \n    // cone\n    vec3 q = p - vec3(0.0, 0.0, 0.0);\n    float d = length(q.xz) * sin(q.y);\n    res = vec4(d, vec3(0.", "~~~~\n    vec4 hit = vec4(0.0,0.0,0.0,0.0);\n    float t = 0.0;\n    float id = 0.0;\n    float itter = 0.0;\n    float maxDistance = 100.0;\n    float minDistance = 0.01;\n    float maxItter = 100.0;\n    float maxItterRatio = 0.0;\n    float itterRatio = itterRatio;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0;\n    float maxItterRatio = 0.0", "~~~~\n    const int maxIter = 64;\n    const float maxDist = 100.0;\n    const float minDist = 0.001;\n    const float eps = 0.001;\n    const float k = 1.0;\n    const float k2 = k * k;\n    const float k3 = k2 * k;\n    const float k4 = k3 * k;\n    const float k5 = k4 * k;\n    const float k6 = k5 * k;\n    const float k7 = k6 * k;\n    const float k8 = k7 * k;\n    const float k9 = k8 * k;\n    const float k10 = k9 * k;\n    const float k11 = k10 * k;\n    const float k12 = k11 * k;\n    const float k13 = k12 * k;\n    const float k14 = k13 * k;\n    const float k15 = k14 * k;\n    const float k16 = k15 * k;\n    const float k17 = k16 * k;\n    const float k18 = k17 * k;\n    const float k19 = k18 * k;\n    const float k20 = k19 * k;\n    const float k21 = k20 * k;\n    const float k22 = k21 * k;\n    const float k23 = k22 * k;\n    const float k24 = k23 * k;\n    const float k25 = k24 * k;\n    const float k26 = k25 * k;\n    const float k27 = k26 * k;\n    const float k28 = k27 * k;\n    const float k29 = k28 * k;\n    const float k30 = k29 * k;\n    const float k31 = k30 * k;\n    const float k32 = k31 * k;\n    const float k33 = k32 * k;\n    const float k34 = k33 * k;\n    const float k35 = k34 * k;\n    const float k36 = k35 * k;\n    const float k37 = k36 * k;\n    const float k38 = k37 * k;\n    const float k39 = k38 * k", "(\n    float t = 0.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 5; i++)\n    {\n        t += 0.1;\n        d = map(sp + nor * t);\n        occ += (t - d) / (t + 0.01);\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}", "\n    vec3 n = oN;\n    vec3 n1 = oN;\n    vec3 n2 = oN;\n    vec3 n3 = oN;\n    vec3 n4 = oN;\n    vec3 n5 = oN;\n    vec3 n6 = oN;\n    vec3 n7 = oN;\n    vec3 n8 = oN;\n    vec3 n9 = oN;\n    vec3 n10 = oN;\n    vec3 n11 = oN;\n    vec3 n12 = oN;\n    vec3 n13 = oN;\n    vec3 n14 = oN;\n    vec3 n15 = oN;\n    vec3 n16 = oN;\n    vec3 n17 = oN;\n    vec3 n18 = oN;\n    vec3 n19 = oN;\n    vec3 n20 = oN;\n    vec3 n21 = oN;\n    vec3 n22 = oN;\n    vec3 n23 = oN;\n    vec3 n24 = oN;\n    vec3 n25 = oN;\n    vec3 n26 = oN;\n    vec3 n27 = oN;\n    vec3 n28 = oN;\n    vec3 n29 = oN;\n    vec3 n30 = oN;\n    vec3 n31 = oN;\n    vec3 n32 = oN;\n    vec3 n33 = oN;\n    vec3 n34 = oN;\n    vec3 n35 = oN;\n    vec3 n36 = oN;\n    vec3 n37 = oN;\n    vec3 n38 = oN;\n    vec3 n39 = oN;\n    vec3 n40 = oN;\n    vec3 n41 = oN;\n    vec3 n42 = oN;\n    vec3 n43 = oN;\n    vec3 n44 = oN;\n    vec3 n45 = oN;\n    vec3 n46 = oN;\n    vec3 n47 = oN;\n    vec3 n48 = oN;\n    vec3 n49 = oN;\n    vec3 n50 = oN;\n    vec", "(\n    vec3 gamma = vec3(1.0/2.2);\n    return pow(c, gamma);\n)\n}", "\n    float f = 1.0-exp(-fs.x*d);\n    vec3  fog = mix(fc1,fc2,pow(dot(cRD,lRD),fs.y));\n    return mix(c,fog,f);\n}", "\n\tfloat attn = 1.0f;\n\tattn -= cF * d;\n\tattn -= lF * d;\n\tattn -= qF * d * d;\n\treturn attn;\n}", "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "~~~~\n    // ~~~~~~~ init\n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    float d_prev = 0.0;\n    float d_next = 0.0;\n    float d_max = 0.0;\n    float d_min = 0.0;\n    float d_avg = 0.0;\n    float d_avg_prev = 0.0;\n    float d_avg_next = 0.0;\n    float d_avg_prev_prev = 0.0;\n    float d_avg_next_next = 0.0;\n    float d_avg_prev_next = 0.0;\n    float d_avg_next_prev = 0.0;\n    float d_avg_prev_prev_prev = 0.0;\n    float d_avg_next_next_next = 0.0;\n    float d_avg_prev_next_next = 0.0;\n    float d_avg_next_prev_prev = 0.0;\n    float d_avg_prev_prev_next = 0.0;\n    float d_avg_next_next_prev = 0.0;\n    float d_avg_prev_next_prev = 0.0;\n    float d_avg_next_prev_next = 0.0;\n    float d_avg_prev_next_next_prev = 0.0;\n    float d_avg_next_prev_prev_next = 0.0;\n    float d_avg_prev_prev_next_next = 0.0;\n    float d_avg_next_next_prev_prev = 0.0;\n    float d_avg_prev_prev_next_prev = 0.0;\n    float d_avg_next_prev_next_next = 0.0;\n    float d_avg_prev_next_prev_prev = 0.0;\n    float d_avg_next_prev_prev_next = 0.0;\n    ", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "pace\n    vec3 d = abs(p) - radius;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec2 radius)\n{\n    return length(p.xz - radius.x) - radius.y;\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec3 normal, float offset)\n{\n    return dot(p, normal) + offset;\n}\n\n// capsule distance field\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - radius;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    return length(q) - radius.y;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius, float twist)\n{\n    vec2 q = vec2(length(p.xz) - radius.x, p.y);\n    float angle = atan(q.x, q.y) * twist;\n    q = vec2(cos(angle), sin(angle));\n    return length(q) - radius.y;\n}\n\n// torus knot distance field\nfloat sdTorusKnot(vec3 p, vec2 radius, float twist, float radius2)", "id++;\n    return length(p.xz)-r;\n}\n\n// simple sphere distance field\nfloat sph(vec3 p, float r)\n{id++;\n    return length(p)-r;\n}\n\n// simple plane distance field\nfloat pln(vec3 p, vec3 n, float d)\n{id++;\n    return dot(p,n)-d;\n}\n\n// simple box distance field\nfloat box(vec3 p, vec3 b)\n{id++;\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// simple torus distance field\nfloat tor(vec3 p, float r, float R)\n{id++;\n    vec2 q = vec2(length(p.xz)-r,p.y);\n    return length(q)-R;\n}\n\n// simple ellipsoid distance field\nfloat ell(vec3 p, vec3 r)\n{id++;\n    return (length(p/r)-1.0)*min(min(min(r.x,r.y),r.z),1.0);\n}\n\n// simple capsule distance field\nfloat cap(vec3 p, vec3 a, vec3 b, float r)\n{id++;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n// simple cylinder distance field\nfloat cyl(vec3 p, vec3 a, vec3 b, float r)\n{id++;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n// simple cone distance field\nfloat con(vec3 p, vec3 a, vec3 b, float r)\n{id++;\n    vec3 pa = p - a, ba = b - a;\n    float", " isect = vec2(0.0, 0.0);\n  // Sphere\n  isect.x = length(p) - 1.0;\n  // Plane\n  isect.x = p.y;\n  // Cylinder\n  isect.x = length(p.xz) - 1.0;\n  // Cone\n  isect.x = length(p.xz) * sin(p.y) - 1.0;\n  // Torus\n  isect.x = length(vec2(length(p.xz) - 1.0, p.y)) - 0.5;\n  // Torus Knot\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Trefoil Knot\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Klein Bottle\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Klein Bottle\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Klein Bottle\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Klein Bottle\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0.5, p.y)) - 0.5;\n  // Klein Bottle\n  isect.x = length(vec2(length(p.xz - vec2(0.5, 0.0)) - 0", "\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float theta2 = theta * theta;\n    float theta3 = theta2 * theta;\n    float theta4 = theta3 * theta;\n    float theta5 = theta4 * theta;\n    float r5 = pow(r, 5.0);\n    float r4 = r5 * r;\n    float r3 = r4 * r;\n    float r2 = r3 * r;\n    float r1 = r2 * r;\n    float r0 = r1 * r;\n    float r_theta = r0 * cos(5.0 * theta);\n    float i_theta = r0 * sin(5.0 * theta);\n    return vec2(r_theta, i_theta);\n}", " theta = 0.0;\n  vec2 coord2 = coord;\n  vec2 coord3 = coord;\n  vec2 coord4 = coord;\n  vec2 coord5 = coord;\n  vec2 coord6 = coord;\n  vec2 coord7 = coord;\n  vec2 coord8 = coord;\n  vec2 coord9 = coord;\n  vec2 coord10 = coord;\n  vec2 coord11 = coord;\n  vec2 coord12 = coord;\n  vec2 coord13 = coord;\n  vec2 coord14 = coord;\n  vec2 coord15 = coord;\n  vec2 coord16 = coord;\n  vec2 coord17 = coord;\n  vec2 coord18 = coord;\n  vec2 coord19 = coord;\n  vec2 coord20 = coord;\n  vec2 coord21 = coord;\n  vec2 coord22 = coord;\n  vec2 coord23 = coord;\n  vec2 coord24 = coord;\n  vec2 coord25 = coord;\n  vec2 coord26 = coord;\n  vec2 coord27 = coord;\n  vec2 coord28 = coord;\n  vec2 coord29 = coord;\n  vec2 coord30 = coord;\n  vec2 coord31 = coord;\n  vec2 coord32 = coord;\n  vec2 coord33 = coord;\n  vec2 coord34 = coord;\n  vec2 coord35 = coord;\n  vec2 coord36 = coord;\n  vec2 coord37 = coord;\n  vec2 coord38 = coord;\n  vec2 coord39 = coord;\n  vec2 coord40 = coord;\n  vec2 coord41 = coord;\n  vec2 coord42 = coord;\n  vec2 coord43 = coord;\n  vec2 coord44 = coord;\n  vec2 coord45 = coord;\n  vec2 coord46 = coord;\n  vec2 coord47 = co", "i\n    vec4 color = vec4(0.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec2 offset = vec2(0.0);\n        if(i == 0) offset = vec2(0.25, 0.25);\n        if(i == 1) offset = vec2(-0.25, 0.25);\n        if(i == 2) offset = vec2(0.25, -0.25);\n        if(i == 3) offset = vec2(-0.25, -0.25);\n        color += texture(iChannel0, uv + offset * constant);\n    }\n    return color / 4.0;\n}", "s\n    return x - floor(x);\n}\n\nfloat triangle(float x) {\n    return repeat(x) * 2.0 - 1.0;\n}\n\nfloat saw(float x) {\n    return repeat(x) * 2.0 - 1.0;\n}\n\nfloat square(float x) {\n    return step(0.5, repeat(x));\n}\n\nfloat noise(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat saw(float x, float frequency) {\n    return repeat(x * frequency) * 2.0 - 1.0;\n}\n\nfloat square(float x, float frequency) {\n    return step(0.5, repeat(x * frequency));\n}\n\nfloat triangle(float x, float frequency) {\n    return repeat(x * frequency) * 2.0 - 1.0;\n}\n\nfloat noise(float x, float frequency) {\n    return fract(sin(x * frequency) * 43758.5453);\n}\n\nfloat saw(float x, float frequency, float amplitude) {\n    return repeat(x * frequency) * 2.0 - 1.0 * amplitude;\n}\n\nfloat square(float x, float frequency, float amplitude) {\n    return step(0.5, repeat(x * frequency)) * amplitude;\n}\n\nfloat triangle(float x, float frequency, float amplitude) {\n    return repeat(x * frequency) * 2.0 - 1.0 * amplitude;\n}\n\nfloat noise(float x, float frequency, float amplitude) {\n    return fract(sin(x * frequency) * 43758.5453) * amplitude;\n}\n\nfloat saw(float x, float frequency, float amplitude, float offset) {\n    return repeat(x * frequency) * 2.0 - 1.0 * amplitude + offset;\n}\n\nfloat square(float x, float frequency, float amplitude, float offset) {\n    return step(0.5, repeat(x * frequency)) * amplitude + offset;\n}\n\nfloat triangle(float x, float frequency, float amplitude, float offset) {\n    return repeat(x * frequency) * 2.0 - 1.0 * amplitude", "\n    vec2 p = pB - pA;\n    float len = length(p);\n    vec2 dir = p / len;\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 perp3 = vec2(-dir.y, dir.x) * 0.5;\n    vec2 perp4 = vec2(dir.y, -dir.x) * 0.5;\n    vec2 perp5 = vec2(-dir.y, dir.x) * 0.25;\n    vec2 perp6 = vec2(dir.y, -dir.x) * 0.25;\n    vec2 perp7 = vec2(-dir.y, dir.x) * 0.125;\n    vec2 perp8 = vec2(dir.y, -dir.x) * 0.125;\n    vec2 perp9 = vec2(-dir.y, dir.x) * 0.0625;\n    vec2 perp10 = vec2(dir.y, -dir.x) * 0.0625;\n    vec2 perp11 = vec2(-dir.y, dir.x) * 0.03125;\n    vec2 perp12 = vec2(dir.y, -dir.x) * 0.03125;\n    vec2 perp13 = vec2(-dir.y, dir.x) * 0.015625;\n    vec2 perp14 = vec2(dir.y, -dir.x) * 0.015625;\n    vec2 perp15 = vec2(-dir.y, dir.x) * 0.0078125;\n    vec2 perp16 = vec2(dir.y, -dir.x) * 0.0078125;\n    vec2 perp17 = vec2(-dir.y, dir.x) * 0.00390625;\n    vec2 perp18 = vec2(dir.y, -dir.x) * 0.00390625;\n    vec2 perp19 = vec2(-dir.y, dir.x) * ", " aa = 1.0;\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 p1 = p - perp * thick.x;\n    vec2 p2 = p + perp * thick.x;\n    vec2 p3 = p + perp2 * thick.y;\n    vec2 p4 = p - perp2 * thick.y;\n    float d1 = length(p1 - pA);\n    float d2 = length(p2 - pB);\n    float d3 = length(p3 - pB);\n    float d4 = length(p4 - pA);\n    float d = min(min(d1, d2), min(d3, d4));\n    float r = length(p - pB);\n    float rd = r - d;\n    float a = 1.0 - smoothstep(0.0, rounded, rd);\n    return a;\n}", " is_outline = 1;\n    float d = 0.0;\n    float dA = DistanceToLine(uv, pA, pB);\n    float dB = DistanceToLine(uv, pB, pA);\n    float dC = DistanceToLine(uv, pA, pB, thick);\n    float dD = DistanceToLine(uv, pB, pA, thick);\n    float dE = DistanceToLine(uv, pA, pB, thick, rounded);\n    float dF = DistanceToLine(uv, pB, pA, thick, rounded);\n    float dG = DistanceToLine(uv, pA, pB, thick, rounded, outlineThick);\n    float dH = DistanceToLine(uv, pB, pA, thick, rounded, outlineThick);\n    d = min(d, dA);\n    d = min(d, dB);\n    d = min(d, dC);\n    d = min(d, dD);\n    d = min(d, dE);\n    d = min(d, dF);\n    d = min(d, dG);\n    d = min(d, dH);\n    return d;\n}", " a\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 pPerp = p * perp;\n    vec2 pPerp2 = p * perp2;\n    vec2 pDir = p * dir;\n    float d = length(pPerp);\n    float d2 = length(pPerp2);\n    float dDir = abs(pDir.x);\n    float dDir2 = abs(pDir.y);\n    float dRounded = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded2 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded3 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded4 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded5 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded6 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded7 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded8 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded9 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded10 = length(max(vec2(dDir, dDir2) - vec2(rounded), 0.0));\n    float dRounded11 = length(max(vec2(dDir", " a\n    vec2 p = uv - pA;\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perp2 = vec2(dir.y, -dir.x);\n    vec2 perp3 = vec2(-dir.y, dir.x);\n    vec2 perp4 = vec2(dir.y, -dir.x);\n    vec2 perp5 = vec2(-dir.y, dir.x);\n    vec2 perp6 = vec2(dir.y, -dir.x);\n    vec2 perp7 = vec2(-dir.y, dir.x);\n    vec2 perp8 = vec2(dir.y, -dir.x);\n    vec2 perp9 = vec2(-dir.y, dir.x);\n    vec2 perp10 = vec2(dir.y, -dir.x);\n    vec2 perp11 = vec2(-dir.y, dir.x);\n    vec2 perp12 = vec2(dir.y, -dir.x);\n    vec2 perp13 = vec2(-dir.y, dir.x);\n    vec2 perp14 = vec2(dir.y, -dir.x);\n    vec2 perp15 = vec2(-dir.y, dir.x);\n    vec2 perp16 = vec2(dir.y, -dir.x);\n    vec2 perp17 = vec2(-dir.y, dir.x);\n    vec2 perp18 = vec2(dir.y, -dir.x);\n    vec2 perp19 = vec2(-dir.y, dir.x);\n    vec2 perp20 = vec2(dir.y, -dir.x);\n    vec2 perp21 = vec2(-dir.y, dir.x);\n    vec2 perp22 = vec2(dir.y, -dir.x);\n    vec2 perp23 = vec2(-dir.y, dir.x);\n    vec2 perp24 = vec2(dir.y, -dir.x);\n    vec2 perp25 = vec2(-dir.y, dir.", "ure\n    vec2 p = uv - pA;\n    vec2 d = pB - pA;\n    float l = length(d);\n    d /= l;\n    vec2 n = vec2(-d.y, d.x);\n    float r = l * rounded;\n    float t = outlineThick;\n    float a = max(0.0, dot(n, p) - r);\n    float b = max(0.0, dot(n, p - d) - r);\n    float c = max(0.0, dot(n, p - d - t * d) - r);\n    float d = max(0.0, dot(n, p - t * d) - r);\n    return max(max(a, b), max(c, d));\n}", " isect = 1; col = vec3(1); }", "\n    float denom = dot( nor, rd );\n    if( abs(denom) < 0.0001 ) return -1.0;\n    float t = ( dot( nor, cen ) - dot( nor, ro ) ) / denom;\n    if( t < 0.0 ) return -1.0;\n    vec3 p = ro + t * rd;\n    float d = distance( p, cen ) - rad;\n    return d;\n}\n\n// ray-sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd,              // ray: origin, direction\n               in vec3 cen, float rad )             // sphere: center, radius\n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad * rad;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\n// ray-triangle intersection\nfloat iTriangle( in vec3 ro, in vec3 rd,              // ray: origin, direction\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) // triangle: vertices\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3 rd_ = cross( rd, v2v0 );\n    float inv_denom  = 1.0 / dot( v1v0, rd_ );\n    float u = dot( rov0, rd_ ) * inv_denom;\n    if( u < 0.0 || u > 1.0 ) return -1.0;\n    vec3 pv0 = cross( rov0, v1v0 );\n    float v = dot( rd, pv0 ) * inv_denom;\n    if( v < 0.0 || u + v > 1.0 ) return -1.0;\n    float t = dot( v2v0", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection (simplified)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-triangle intersection (simplified)\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c ) \n{\n    vec3 v1 = b - a;\n    vec3 v2 = c - a;\n    vec3 n = cross( v1, v2 );\n    float d = -dot( n, a );\n    float t = ( -dot( n, ro ) - d ) / dot( n, rd );\n    vec3 p = ro + t*rd;\n    vec3 vp1 = p - a;\n    vec3 vp2 = p - b;\n    vec3 vp3 = p - c;\n    if( dot( cross( v1, vp1 ), n ) < 0.0 ) return vec2(-1.0);\n    if( dot( cross( v2, vp2 ), n ) < 0.0 ) return vec2(-", "----------------------------------------------------------------------------------------\n//  pa: cylinder base\n//  pb: cylinder top\n//  ra: cylinder radius\n//----------------------------------------------------------------------------------------\n    vec3  ba = pb - pa;\n    float h = length(ba);\n    vec3  ca = normalize(ba);\n    vec3  da = abs(ca);\n    vec3  pbca = pb - ca * dot(pb,ca);\n    vec3  pab = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  paa = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paab = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pabb = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabb = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pbaabb = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabbc = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pbaabbc = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabbcd = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pbaabbcd = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabbcdi = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pbaabbcdi = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabbcdij = pa + ba * saturate( dot(pa-pbca,ca) / h );\n    vec3  pbaabbcdij = pa + ba * saturate( dot(pa-pbca,-ca) / h );\n    vec3  paabbcdijk = pa + ba * saturate( dot(pa-", "\n    vec3  ba = pb - pa;\n    vec3  oc = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float rdba = dot(rd,ba);\n    float rd2  = dot(rd,rd);\n    float tca = baoc / baba;\n    float d2  = baoc*baoc - baba*tca*tca;\n    float h2 = ra*ra * rd2 - d2;\n    if( h2 < 0.0 ) return vec4(0.0);\n    float h = sqrt(h2);\n    float t0 = tca - h;\n    float t1 = tca + h;\n    if( t0 < 0.0 && t1 < 0.0 ) return vec4(0.0);\n    float t = (t0 < 0.0)? t1 : t0;\n    vec3  n = normalize(oc + ba*t - rd*t*rdba/baba);\n    return vec4(t,n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, in float ra )\n{\n    vec3  oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec4(0.0);\n    h = sqrt( h );\n    return vec4( -b-h, vec3(0.0,1.0,0.0) );\n}\n\n// ray-plane intersection (returns t and normal)\nvec4 iPlane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n )\n{\n    float den = dot(rd,n);\n    float nom = dot(p-ro,n);\n    if( abs(den) < 0.0001 ) return vec4(0", "-\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro-cen;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(0.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    vec3 oc = ro - cen;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(0.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-triangle intersection\nvec2 iTriangle( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c ) \n{\n    vec3 v1 = b - a;\n    vec3 v2 = c - a;\n    vec3 n = cross( v1, v2 );\n    float d = -dot( n, a );\n    float t = ( -dot( n, ro ) - d ) / dot( n, rd );\n    if( t < 0.0 ) return vec2(0.0);\n    vec3 p = ro + t*rd;\n    vec3 vp1 = p - a;\n    vec3 vp2 = p - b;\n    vec3 vp3 = p - c;\n    if( dot( cross( v1, vp1 ), n ) < 0.0 ) return vec2(0.0);\n    if( dot( cross( v2, vp2", "ection( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    vec3 ob = ro - pb;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdba = dot(rd,ba);\n    float oaba = dot(oa,ba);\n    float rdob = dot(rd,ob);\n    float obba = dot(ob,ba);\n    float a = baba - rdba*rdba;\n    float b = baba*rdob - baoa*rdba;\n    float c = baba*oaba - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    float t = -1.0;\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        float t0 = (-b-h)/a;\n        float t1 = (-b+h)/a;\n        t = max( t0, min(t1,0.0) );\n        float s = oaba + t*rdba;\n        if( s < 0.0 || s > baba ) t = -1.0;\n    }\n    return t;\n}", "(\n    vec3 ab = b - a;\n    vec3 ap = pos - a;\n    float t = dot( ap, ab ) / dot( ab, ab );\n    vec3 c = a + ab * t;\n    return normalize( pos - c );\n)\n}", "-\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(0.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 pos, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(0.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// ray-sphere intersection in box space\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 pos, in float rad ) \n{\n    vec3 oc = ro - pos;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(0.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// ray-sphere intersection in world space\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec", "\n    float t = 0.0;\n    float h = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float n = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0", "\n    float phi = 2.0 * PI * i / n;\n    float z = 1.0 - (2.0 * i + 1.0) / n;\n    float r = sqrt(1.0 - z * z);\n    return vec3(cos(phi) * r, sin(phi) * r, z);\n}\n\n// inverse spherical fibonazzi mapping\nvec3 inverseSF( vec3 p )\n{\n    float z = p.z;\n    float r = sqrt(1.0 - z * z);\n    float phi = atan(p.y, p.x);\n    float i = (r * phi + 2.0 * PI) * (n / (2.0 * PI));\n    return vec3(i, 1.0 - (2.0 * i + 1.0) / n, z);\n}", "\n    vec3 p = ro;\n    vec3 d = rd;\n    float t = 0.0;\n    float m = 0.0;\n    float h = 0.0;\n    float s = 0.0;\n    float cs = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float l = 0.0;\n    float a = 0.0;\n    float g = 0.0;\n    float f = 0.0;\n    float e = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float A = 0.0;\n    float B = 0.0;\n    float C = 0.0;\n    float D = 0.0;\n    float E = 0.0;\n    float F = 0.0;\n    float G = 0.0;\n    float H = 0.0;\n    float I = 0.0;\n    float J = 0.0;\n    float K = 0.0;\n    float L = 0.0;\n    float M = 0.0;\n    float N = 0.0;\n    float O = 0.0;\n    float P = 0.0;\n    float Q = 0.0;\n    float R = 0.0;\n    float S = 0.0;\n    float T = 0.0;\n    float U = 0.0;\n    float V = 0.0;\n    float W = 0.0;\n    float X = 0.0;\n    float Y = 0.0;\n    float Z =", "er\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( vec3( texture( iChannel0, (i+vec2(0.0,0.0))/iChannelResolution[0].xy ) ),\n                     vec3( texture( iChannel0, (i+vec2(1.0,0.0))/iChannelResolution[0].xy ) ), u.x),\n                mix( vec3( texture( iChannel0, (i+vec2(0.0,1.0))/iChannelResolution[0].xy ) ),\n                     vec3( texture( iChannel0, (i+vec2(1.0,1.0))/iChannelResolution[0].xy ) ), u.x), u.y).xyz;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( vec3( texture( iChannel0, (i+vec3(0.0,0.0,0.0))/iChannelResolution[0].xyz ) ),\n                          vec3( texture( iChannel0, (i+vec3(1.0,0.0,0.0))/iChannelResolution[0].xyz ) ), u.x),\n                    mix( vec3( texture( iChannel0, (i+vec3(0.0,1.0,0.0))/iChannelResolution[0].xyz ) ),\n                         vec3( texture( iChannel0, (i+vec3(1.0,1.0,0.0))/iChannelResolution[0].xyz ) ), u.x), u.y),\n                mix( mix( vec3( texture( iChannel0, (i+vec3(0.0,0.0,1.0))/iChannelResolution", "ance\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) + radius;\n}\n\nfloat smoothMerge(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat box(vec2 p, vec2 size, float radius, float k)\n{\n    return smoothMerge(boxDist(p, size, radius), boxDist(p, size, radius - k), k);\n}\n\nfloat box(vec2 p, vec2 size, float radius)\n{\n    return box(p, size, radius, 0.01);\n}\n\nfloat box(vec2 p, vec2 size)\n{\n    return box(p, size, 0.01);\n}\n\nfloat box(vec2 p, float size, float radius)\n{\n    return box(p, vec2(size), radius);\n}\n\nfloat box(vec2 p, float size)\n{\n    return box(p, vec2(size));\n}\n\nfloat box(vec2 p, float size, float radius, float k)\n{\n    return box(p, vec2(size), radius, k);\n}\n\nfloat box(vec2 p, float size, float k)\n{\n    return box(p, vec2(size), k);\n}\n\nfloat box(vec2 p, float size, float radius, float k, float k2)\n{\n    return box(p, vec2(size), radius, k, k2);\n}\n\nfloat box(vec2 p, float size, float k, float k2)\n{\n    return box(p, vec2(size), k, k2);\n}\n\nfloat box(vec2 p, float size, float radius, float k, float k2, float k3)\n{\n    return box(p, vec2(size), radius, k, k2, k3);\n}\n\nfloat box(", "1\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 2\nvec3 pat2(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 6\nvec3 pat6(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 7\nvec3 pat7(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 8\nvec3 pat8(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 9\nvec3 pat9(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 10\nvec3 pat10(vec2 uv, vec2 orient)\n{\n    return vec3(uv.x * orient.x, uv.y * orient.y, 0.0);\n}\n\n// Pattern 11\nvec3 pat11(vec2", "1\n    float d = dot(uv, orient);\n    float s = sin(d * 10.0);\n    float c = cos(d * 10.0);\n    float a = atan(c, s);\n    float r = length(vec2(s, c));\n    return vec3(r, a, 0.0);\n}", " =\n    vec2 a = abs(p);\n    vec2 s = sign(p);\n    vec2 i = floor(a);\n    vec2 f = a - i;\n    vec2 w = f*f*(3.0-2.0*f);\n    vec2 g = s*f;\n    vec2 u = g + vec2(1.0,0.0);\n    vec2 v = g + vec2(0.0,1.0);\n    vec2 d = vec2(ddx.x,ddy.y);\n    vec2 n = vec2(ddx.y,ddy.x);\n    vec2 iu = i + u;\n    vec2 iv = i + v;\n    vec2 du = d*iu;\n    vec2 dv = d*iv;\n    vec2 nu = n*iu;\n    vec2 nv = n*iv;\n    float a0 = dot(du,nu);\n    float a1 = dot(dv,nu);\n    float a2 = dot(du,nv);\n    float a3 = dot(dv,nv);\n    return (a0*w.x + a1*w.y + a2*(1.0-w.x) + a3*(1.0-w.y));\n}", "\n    vec3 e = vec3(0.01,0.0,0.0);\n    return normalize( vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx) ) );\n}\n\n// raymarching\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n    float dO=0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + rd*dO;\n        float dS = map( p );\n        dO += dS;\n        if( dO>MAX_DIST || abs(dS)<SURF_DIST ) break;\n    }\n    return dO;\n}\n\n// raymarching with shadow\nfloat raymarchShadow( in vec3 ro, in vec3 rd )\n{\n    float dO=0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + rd*dO;\n        float dS = map( p );\n        dO += dS;\n        if( dO>MAX_DIST || abs(dS)<SURF_DIST ) break;\n    }\n    return dO;\n}\n\n// raymarching with soft shadow\nfloat raymarchSoftShadow( in vec3 ro, in vec3 rd )\n{\n    float dO=0.0;\n    float dS;\n    float res = 1.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        vec3 p = ro + rd*dO;\n        dS = map( p );\n        dO += dS;\n        if( dO>MAX_DIST || abs(dS)<SURF_DIST ) break;\n        res = min( res, 8.0*dS/dO );", "\n\tv33 c=a;\n\ta.x=c.x;\n\ta.y=c.z;\n\ta.z=c.y;\n\tb.x=c.y;\n\tb.y=c.x;\n\tb.z=c.z;\n}", "\n\treturn {a.a-b,a.b};\n}\nv33 add(v33 a,vec3 b){\n\treturn {a.a+b,a.b};\n}\nv33 mul(v33 a,vec3 b){\n\treturn {a.a*b,a.b};\n}\nv33 div(v33 a,vec3 b){\n\treturn {a.a/b,a.b};\n}\nv33 add(v33 a,v33 b){\n\treturn {a.a+b.a,a.b+b.b};\n}\nv33 sub(v33 a,v33 b){\n\treturn {a.a-b.a,a.b-b.b};\n}\nv33 mul(v33 a,v33 b){\n\treturn {a.a*b.a,a.b*b.b};\n}\nv33 div(v33 a,v33 b){\n\treturn {a.a/b.a,a.b/b.b};\n}\nv33 add(v33 a,float b){\n\treturn {a.a+b,a.b};\n}\nv33 sub(v33 a,float b){\n\treturn {a.a-b,a.b};\n}\nv33 mul(v33 a,float b){\n\treturn {a.a*b,a.b};\n}\nv33 div(v33 a,float b){\n\treturn {a.a/b,a.b};\n}\nv33 add(float a,v33 b){\n\treturn {a+b.a,b.b};\n}\nv33 sub(float a,v33 b){\n\treturn {a-b.a,b.b};\n}\nv33 mul(float a,v33 b){\n\treturn {a*b.a,b.b};\n}\nv33 div(float a,v33 b){\n\treturn {a/b.a,b.b};\n}\nv33 add(v33 a,int b){\n\treturn {a.a+b,a.b};\n}\nv33 sub(v33 a,int b){\n\treturn {a", "tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){tract(a,b);return a;}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd", "\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,float t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,vec2 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,vec3 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,vec4 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,mat2 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,mat3 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,mat4 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,mat2x3 t){\n\treturn vec2(\n\t\tb.x.x-a.x.x,\n\t\tb.x.y-a.x.y\n\t);\n}\nvec2 dt(v33 a,v33 b,mat3x2 t){\n\treturn vec2(\n\t\tb.x.x-", "product(a,b);}\nvec2 dt(vec3 a,v33 b){product(a,b);}\nvec2 dt(v33 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec2 b){product(a,b);}\nvec2 dt(vec2 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec4 b){product(a,b);}\nvec2 dt(vec4 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec3 b){product(a,b);}\nvec2 dt(vec3 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec2 b){product(a,b);}\nvec2 dt(vec2 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec4 b){product(a,b);}\nvec2 dt(vec4 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec3 b){product(a,b);}\nvec2 dt(vec3 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec2 b){product(a,b);}\nvec2 dt(vec2 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec4 b){product(a,b);}\nvec2 dt(vec4 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec3 b){product(a,b);}\nvec2 dt(vec3 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec2 b){product(a,b);}\nvec2 dt(vec2 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec4 b){product(a,b);}\nvec2 dt(vec4 a,v33 b){product(a,b);}\nvec2 dt(v33 a,vec3 b){product(a,b);}\nvec2 dt(", "\n\tv33 c;\n\tc.x=a.x*b.x-a.y*b.y;\n\tc.y=a.x*b.y+a.y*b.x;\n\treturn c;\n}\nv33 add(v33 a,v33 b){\n\tv33 c;\n\tc.x=a.x+b.x;\n\tc.y=a.y+b.y;\n\treturn c;\n}\nv33 sub(v33 a,v33 b){\n\tv33 c;\n\tc.x=a.x-b.x;\n\tc.y=a.y-b.y;\n\treturn c;\n}\nv33 div(v33 a,vec2 b){\n\tv33 c;\n\tc.x=a.x/b.x-a.y/b.y;\n\tc.y=a.x/b.y+a.y/b.x;\n\treturn c;\n}\nv33 neg(v33 a){\n\tv33 c;\n\tc.x=-a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 conj(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 inv(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 pow(v33 a,int b){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 sqrt(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 log(v33 a){\n\tv33 c;\n\tc.x=a.x;\n\tc.y=-a.y;\n\treturn c;\n}\nv33 exp(v33 a){\n\tv33 c;\n\tc.x=", "\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),2.0);\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF(vec3 p,vec3 w){\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),2.0);\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF(vec3 p,vec3 w,float s){\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),s);\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF(vec3 p,vec3 w,float s,float t){\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),s)+t;\n}\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF(vec3 p,vec3 w,float s,float t,float u){\n    vec3 q=vec3(dot(p,w.xyy),dot(p,w.yxx),dot(p,w.yyz));\n    return mod(floor(q.x)+floor(q.y)+floor(q.z),s)+t+u;\n}\n//tri(a,Fa)2xTap for box-filter", "tic();\n\tvec3 a=abs(p);\n\tvec3 b=vec3(1.0)/w;\n\tvec3 c=vec3(1.0)/(a+b);\n\tvec3 d=vec3(1.0)/(a-b);\n\tvec3 e=vec3(1.0)/(a+b+b);\n\tvec3 f=vec3(1.0)/(a-b+b);\n\tvec3 g=vec3(1.0)/(a+b-b);\n\tvec3 h=vec3(1.0)/(a-b-b);\n\tvec3 i=vec3(1.0)/(a+b+b+b);\n\tvec3 j=vec3(1.0)/(a-b+b+b);\n\tvec3 k=vec3(1.0)/(a+b-b+b);\n\tvec3 l=vec3(1.0)/(a-b-b+b);\n\tvec3 m=vec3(1.0)/(a+b+b-b);\n\tvec3 n=vec3(1.0)/(a-b+b-b);\n\tvec3 o=vec3(1.0)/(a+b-b-b);\n\tvec3 p=vec3(1.0)/(a-b-b-b);\n\tvec3 q=vec3(1.0)/(a+b+b+b+b);\n\tvec3 r=vec3(1.0)/(a-b+b+b+b);\n\tvec3 s=vec3(1.0)/(a+b-b+b+b);\n\tvec3 t=vec3(1.0)/(a-b-b+b+b);\n\tvec3 u=vec3(1.0)/(a+b+b-b+b);\n\tvec3 v=vec3(1.0)/(a-b+b-b+b);\n\tvec3 w=vec3(1.0)/(a+b-b-b+b);\n\tvec3 x=vec3(1.0)/(a-b-b-b+b);\n", "here:\n\tfloat t=dot(s.xyz,r.xyz);\n\tif(t<0.)return 0.;\n\tfloat d=dot(s.xyz,s.xyz)-t*t;\n\tif(d>s.w*s.w)return 0.;\n\treturn 1.;\n}", "here\n\tvec3 d=s.xyz-u;\n\tfloat r=s.w;\n\tfloat t=dot(d,n);\n\tfloat h=sqrt(dot(d,d)-t*t);\n\treturn h<r?1.0:0.0;\n}", "ct\n    vec2 a = p0 - 2.0*p1 + p2;\n    vec2 b = 2.0*(p1 - p0);\n    vec2 c = p0;\n\n    vec2 d = bboxQuad(a, b, c);\n\n    return vec4(d.x, d.y, d.x + d.y, 1.0);\n}", "ation\n    vec2 p01 = (p0 + p1) * 0.5;\n    vec2 p12 = (p1 + p2) * 0.5;\n    vec2 p012 = (p01 + p12) * 0.5;\n    vec2 d = p2 - p012;\n    return vec4(p012 - d, p012 + d);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 p01 = (p0 + p1) * 0.5;\n    vec2 p12 = (p1 + p2) * 0.5;\n    vec2 p012 = (p01 + p12) * 0.5;\n    vec2 d = p2 - p012;\n    return vec4(p012 - d, p012 + d);\n}\n\n// Approximated BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 p01 = (p0 + p1) * 0.5;\n    vec2 p12 = (p1 + p2) * 0.5;\n    vec2 p23 = (p2 + p3) * 0.5;\n    vec2 p012 = (p01 + p12) * 0.5;\n    vec2 p123 = (p12 + p23) * 0.5;\n    vec2 p0123 = (p012 + p123) * 0.5;\n    vec2 d = p3 - p0123;\n    return vec4(p0123 - d, p0123 + d);\n}\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4 )\n{\n    vec2 p01 = (p0 + p1) * 0.5;\n    vec2 p12 = (p1 + p", "\n    vec3 a = p1 - p0;\n    vec3 b = p2 - p1;\n    vec3 c = p3 - p2;\n\n    vec3 d = p0 - 2.0*p1 + p2;\n    vec3 e = p1 - 2.0*p2 + p3;\n\n    vec3 f = p0;\n\n    vec3 g = 3.0*d;\n    vec3 h = 3.0*e;\n\n    vec3 i = 6.0*a;\n    vec3 j = 6.0*b;\n\n    vec3 k = 2.0*i;\n    vec3 l = 2.0*j;\n\n    vec3 m = k + l + h;\n    vec3 n = g + j + 2.0*h;\n    vec3 o = g + k;\n\n    vec3 p = o + n + m;\n\n    vec3 q = f + e + c;\n    vec3 r = e + c + 2.0*q;\n\n    vec3 s = 6.0*(p + r);\n    vec3 t = 2.0*(m + n) + s;\n\n    vec3 u = 2.0*(o + n);\n    vec3 v = 2.0*(k + l) + s;\n\n    vec3 w = 2.0*(g + h);\n\n    vec3 x = 2.0*(i + j);\n\n    vec3 y = 6.0*(w + x);\n    vec3 z = 2.0*(u + v) + y;\n\n    vec3 A = 2.0*(u + v + z);\n\n    vec3 B = vec3( 0.0 );\n    B.x = dot( A, A );\n    B.y = 3.0*dot( y, A );\n    B.z = 6.0*dot( x, y );\n    B.w = 6.0*dot( w, x );\n\n    vec3 C = vec3( 0.0 );\n    C.x = dot( B, B );\n    C.y = 2.0*dot( z, B );\n    C", "ximport(\"bbox.glsl\");\n    vec2 min = min(min(p0, p1), min(p2, p3));\n    vec2 max = max(max(p0, p1), max(p2, p3));\n    return vec4(min, max);\n}\n\n// Conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{ximport(\"bbox.glsl\");\n    vec2 min = min(min(p0, p1), min(p2, p3));\n    vec2 max = max(max(p0, p1), max(p2, p3));\n    vec2 d = max - min;\n    float dmax = max(d.x, d.y);\n    float dmin = min(d.x, d.y);\n    float dmid = dmax - dmin;\n    float dmin2 = dmin * dmin;\n    float dmid2 = dmid * dmid;\n    float dmax2 = dmax * dmax;\n    float dmin3 = dmin2 * dmin;\n    float dmid3 = dmid2 * dmid;\n    float dmax3 = dmax2 * dmax;\n    float dmin4 = dmin3 * dmin;\n    float dmid4 = dmid3 * dmid;\n    float dmax4 = dmax3 * dmax;\n    float dmin5 = dmin4 * dmin;\n    float dmid5 = dmid4 * dmid;\n    float dmax5 = dmax4 * dmax;\n    float dmin6 = dmin5 * dmin;\n    float dmid6 = dmid5 * dmid;\n    float dmax6 = dmax5 * dmax;\n    float dmin7 = dmin6 * dmin;\n    float dmid7 = dmid6 * dmid;\n    float dmax7 = dmax6 * dmax;\n    float dmin8 = dmin7 * dmin;\n    float dmid8 = dmid7 * dmid;\n    float dmax8 = dmax7 *", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p3 - p2;\n\n    vec2 d01 = p012 - p01;\n    vec2 d12 = p123 - p12;\n    vec2 d23 = p23 - p123;\n\n    vec2 d012 = p0123 - p012;\n\n    vec2 d0121 = p012 - p0123;\n    vec2 d1232 = p123 - p0123;\n\n    vec2 d01212 = p0123 - p012;\n\n    float d01_len = length(d01);\n    float d12_len = length(d12);\n    float d23_len = length(d23);\n    float d012_len = length(d012);\n\n    float d0121_len = length(d0121);\n    float d1232_len = length(d1232);\n    float d01212_len = length(d01212);\n\n    float d01_dot = dot(d01, d01);\n    float d12_dot = dot(d12, d12);\n    float d23_dot = dot(d23, d23);\n    float d012_dot = dot(d012, d012);\n\n    float d0121_dot = dot(d0121, d0121);\n    float d1232_dot = dot(d1232, d1232);\n    float d01212_dot = dot(d01212, d01212);\n\n    float d01_dot_inv = 1.0 / d01_dot;\n    float d12", "angle\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 pvec = cross( rd, v0v2 );\n    float det = dot( v0v1, pvec );\n    vec3 tvec;\n    vec3 qvec;\n    if( det > 0.0 )\n    {\n        tvec = ro - v0;\n        qvec = cross( tvec, v0v1 );\n    }\n    else\n    {\n        det = -det;\n        tvec = v0 - ro;\n        qvec = cross( v0v1, tvec );\n    }\n    if( det < 0.00001 ) return vec3( -1.0 );\n    float invDet = 1.0 / det;\n    vec3 uvw = vec3( dot( tvec, pvec ) * invDet, dot( rd, qvec ) * invDet, dot( tvec, v0v2 ) * invDet );\n    if( uvw.y < 0.0 || uvw.x + uvw.y > 1.0 ) return vec3( -1.0 );\n    return uvw;\n}", "\u5f62\n\tvec3 v0v1 = v1 - v0;\n\tvec3 v0v2 = v2 - v0;\n\tvec3 pvec = cross( pos - v0, v0v1 );\n\tvec3 tvec = cross( v0v2, v0v1 );\n\tfloat det = dot( v0v1, tvec );\n\tfloat invDet = 1.0 / det;\n\tfloat u = dot( pos - v0, pvec ) * invDet;\n\tfloat v = dot( pos - v0, tvec ) * invDet;\n\tfloat w = 1.0 - u - v;\n\treturn max( 0.0, dot( nor, cross( v0v1, v0v2 ) ) ) * ( 1.0 - u - v - w ) + u * dot( nor, cross( v0v1, v1 - v0 ) ) + v * dot( nor, cross( v0v2, v2 - v0 ) );\n}", " between\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        res = distance( pos, A + t*(B-A) + (t*(t-2.0)*t + 1.0)*(C - 2.0*B + A) );\n    }\n    else\n    {\n        float i = sqrt(-p);\n        float u = -q / (2.0*i);\n        float v = sqrt(i*i - kz);\n        float t = clamp( u + v - kx, 0.0, 1.0 );\n\n        // 1 root\n        res = distance( pos, A + t*(B-A) + (t*(t-2.0)*t + 1.0)*(C - 2.0*B + A) );\n    }\n\n    return res;\n}", "\n    float w = r2-r1;\n    float q = length(p.x);\n    float h = (w*p.y + r1*r2*he)/w;\n    float d = abs(q*he - p.y) - h;\n    float s = max(r1-q, 0.0);\n    return length(vec2(d,s)) * step(0.0, d);\n}", "\n    vec2 w = (b-a)*0.5;\n    vec2  c = (b+a)*0.5;\n    vec2  s = vec2( w.y, -w.x );\n    \n    float d = length( p - c );\n    float e = length( vec2( dot( p - c, w.yx ), dot( p - c, s.yx ) ) );\n    float f = clamp( dot( p - c, s ) / dot( w, s ), 0.0, length(w) );\n    \n    return (d - max(e,f)) * (ra + rb);\n}", "\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdf( pos + e.xyy ) + \n                      e.yyx*sdf( pos + e.yyx ) + \n                      e.yxy*sdf( pos + e.yxy ) + \n                      e.xxx*sdf( pos + e.xxx ) );\n}", ":// raymarch\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    ivec2 p = q;\n    p = ((p >> 16) ^ p) * 0x45d9f3b;\n    p = ((p >> 16) ^ p) * 0x45d9f3b;\n    p = ((p >> 16) ^ p);\n    return float(p.x ^ p.y) / 4294967296.0;\n}\n\n// random hash\nfloat hash( in vec2 p )\n{\n    vec2 q = fract( p );\n    return hash( ivec2( q * 10000.0 ) );\n}\n\n// random hash\nfloat hash( in float p )\n{\n    return hash( ivec2( p * 10000.0 ) );\n}\n\n// random hash\nfloat hash( in float p, in float q )\n{\n    return hash( ivec2( p * 10000.0, q * 10000.0 ) );\n}\n\n// random hash\nfloat hash( in float p, in float q, in float r )\n{\n    return hash( ivec2( p * 10000.0, q * 10000.0 ), r * 10000.0 );\n}\n\n// random hash\nfloat hash( in float p, in float q, in float r, in float s )\n{\n    return hash( ivec2( p * 10000.0, q * 10000.0 ), r * 10000.0, s * 10000.0 );\n}\n\n// random hash\nfloat hash( in float p, in float q, in float r, in float s, in float t )\n{\n    return hash( ivec2( p * 10000.0, q * 10000.0 ), r * 10000.0, s * 10000.0, t * 10000.0 );\n}\n\n// random hash\nfloat hash( in float p, in float q, in float r, in float s, in float t, in float u )\n{\n    return hash( ivec2( p * 10000.0, q * 10000.0 ), r * 10000.0, s * 10000.0, t * 10000.0, u * ", " noise_int_t i, f;\n  float r = 0.0;\n  for( i = 0; i < p; i++ )\n  { f = noise_hash( i, x );\n    r += noise_lerp( f.x, f.y, f.z, x );\n  }\n  return r / float(p);\n}\n\n// basic value noise with octaves\nfloat noise( in vec2 x, in int p, in int o )\n{ noise_int_t i, f;\n  float r = 0.0;\n  float w = 1.0;\n  for( i = 0; i < p; i++ )\n  { f = noise_hash( i, x );\n    r += noise_lerp( f.x, f.y, f.z, x ) * w;\n    x *= 2.0;\n    w *= 0.5;\n  }\n  return r;\n}\n\n// basic value noise with octaves and persistence\nfloat noise( in vec2 x, in int p, in int o, in float pers )\n{ noise_int_t i, f;\n  float r = 0.0;\n  float w = 1.0;\n  for( i = 0; i < p; i++ )\n  { f = noise_hash( i, x );\n    r += noise_lerp( f.x, f.y, f.z, x ) * w;\n    x *= 2.0;\n    w *= pers;\n  }\n  return r;\n}\n\n// basic value noise with octaves, persistence and lacunarity\nfloat noise( in vec2 x, in int p, in int o, in float pers, in float lac )\n{ noise_int_t i, f;\n  float r = 0.0;\n  float w = 1.0;\n  for( i = 0; i < p; i++ )\n  { f = noise_hash( i, x );\n    r += noise_lerp( f.x, f.y, f.z, x ) * w;\n    x *= lac;\n    w *= pers;\n  }", "(\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < p; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n)\n}", "ip\n    return (length(max(abs(p)-r,0.0)) + min(max(p.x,max(p.y,p.z)),0.0));\n}", "p.y-=r.y; return length(max(abs(p)-r,0.0))-0.01;}\n\n// symmetric ellipsoid - APPROXIMATE distance\nfloat sdEllipsoidXXZ_Approx( in vec3 p, in vec2 r ) \n{p.y-=r.y; return length(max(abs(p)-r,0.0))-0.01;}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{return length(max(abs(p)-r,0.0))-0.01;}\n\n// symmetric ellipsoid - APPROXIMATE distance\nfloat sdEllipsoidXYZ_Approx( in vec3 p, in vec3 r ) \n{return length(max(abs(p)-r,0.0))-0.01;}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ_Approx( in vec3 p, in vec3 r, in vec3 q ) \n{return length(max(abs(p)-r,0.0))-length(max(abs(p)-q,0.0))-0.01;}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ_Approx( in vec3 p, in vec3 r, in vec3 q, in vec3 s ) \n{return length(max(abs(p)-r,0.0))-length(max(abs(p)-q,0.0))-length(max(abs(p)-s,0.0))-0.01;}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ_Approx( in vec3 p, in vec3 r, in vec3 q, in vec3 s, in vec3 t ) \n{return length(max(abs(p)-r,0.0))-length(max(abs(p)-q,0.0))-length(max(abs(p)-s,0.0))-length(max(abs(p)-t,0", "ip\n    p = abs(p);\n    if ( p.x > p.z ) { p.xy = p.yx; r.xy = r.yx; }\n    if ( p.x > p.y ) { p.xy = p.yx; r.xy = r.yx; }\n    if ( p.z > p.y ) { p.xz = p.zx; r.xz = r.zx; }\n    return (length(max(p-r,0.0)) + min(max(p.x,max(p.y,p.z)),0.0));\n}", "ip\n    p = abs(p);\n    if ( p.x > p.z ) {\n        p.xy = vec2(p.y,p.x);\n    }\n    if ( p.x > p.y ) {\n        p.xz = vec2(p.z,p.x);\n    }\n    if ( p.y > p.z ) {\n        p.yz = vec2(p.z,p.y);\n    }\n    return length(max(p-r,0.0)) * min(max(p.x/r.x,max(p.y/r.y,p.z/r.z)),1.0);\n}", ":// p is in [-1,1]\n    vec2 q = abs(p);\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    vec2 u = f*f*(3.0-2.0*f);\n    float v = mix( mix( u.x, u.y, f.x ), mix( u.x, u.y, f.y ), f.y );\n    return mix( v, 1.0-v, step( 1.0, mod(i.x,2.0) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 size )\n{\n    vec2 q = abs(p);\n    vec2 i = floor(q/size);\n    vec2 f = fract(q/size);\n    vec2 u = f*f*(3.0-2.0*f);\n    float v = mix( mix( u.x, u.y, f.x ), mix( u.x, u.y, f.y ), f.y );\n    return mix( v, 1.0-v, step( 1.0, mod(i.x,2.0) ) );\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 size, in float scale )\n{\n    vec2 q = abs(p);\n    vec2 i = floor(q/size);\n    vec2 f = fract(q/size);\n    vec2 u = f*f*(3.0-2.0*f);\n    float v = mix( mix( u.x, u.y, f.x ), mix( u.x, u.y, f.y ), f.y );\n    return mix( v, 1.0-v, step( 1.0, mod(i.x,2.0) ) ) * scale;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 size, in float scale, in float offset )\n{\n    vec2 q = abs(p);\n    vec2 i = floor(q/size);\n    vec2 f = fract(q/size);\n    vec2 u = f*f*(3.0-", ",\n    return a * x / ( a - x * ( a - 1.0 ) );\n}", "er\n    float y = x - floor(x);\n    if (y < p)\n        return y / p;\n    else\n        return (y - p) / (1.0 - p);\n}", "\n    float a = 0.5 * h;\n    float b = 0.5 * h;\n    float c = 0.5 * h;\n    float d = 0.5 * h;\n    float e = 0.5 * h;\n    float f = 0.5 * h;\n    float g = 0.5 * h;\n    float hh = 0.5 * h;\n    float i = 0.5 * h;\n    float j = 0.5 * h;\n    float k = 0.5 * h;\n    float l = 0.5 * h;\n    float m = 0.5 * h;\n    float n = 0.5 * h;\n    float o = 0.5 * h;\n    float p = 0.5 * h;\n    float q = 0.5 * h;\n    float r = 0.5 * h;\n    float s = 0.5 * h;\n    float t = 0.5 * h;\n    float u = 0.5 * h;\n    float v = 0.5 * h;\n    float w = 0.5 * h;\n    float x = 0.5 * h;\n    float y = 0.5 * h;\n    float z = 0.5 * h;\n    float aa = 0.5 * h;\n    float ab = 0.5 * h;\n    float ac = 0.5 * h;\n    float ad = 0.5 * h;\n    float ae = 0.5 * h;\n    float af = 0.5 * h;\n    float ag = 0.5 * h;\n    float ah = 0.5 * h;\n    float ai = 0.5 * h;\n    float aj = 0.5 * h;\n    float ak = 0.5 * h;\n    float al = 0.5 * h;\n    float am = 0.5 * h;\n    float an = 0.5 * h;\n    float ao = 0.5 * h;\n    float ap = 0.5 * h;\n    float aq =", "\n    vec3  pa_pb = pb - pa;\n    vec3  pa_ro = ro - pa;\n    float b = dot(pa_pb, rd);\n    float c = dot(pa_pb, pa_pb) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = -b-h;\n    vec3  p = ro + t*rd;\n    vec3  pa_p = p - pa;\n    float s = dot(pa_pb, pa_p) / dot(pa_pb, pa_pb);\n    if( s<0.0 || s>1.0 )\n    {\n        t = -b+h;\n        p = ro + t*rd;\n        s = dot(pa_pb, pa_p) / dot(pa_pb, pa_pb);\n    }\n    return length(pa_p - s*pa_pb)*step(s,1.0);\n}", "://parametrization\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(ra,rb,h);\n}", "\n    vec3 ab = b - a;\n    vec3 ao = ro - a;\n    vec3 bo = ro - b;\n    float t = dot( ao, ab ) / dot( ab, ab );\n    vec3 p = a + ab * clamp( t, 0.0, 1.0 );\n    float d = length( ao - p );\n    float s = ( d - r ) / k;\n    float w = clamp( 1.0 - s * s, 0.0, 1.0 );\n    return w * w;\n}\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    return capShadow( ro, rd, a, b, r, 1.0 );\n}\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n    return capShadow( ro, rd, a, b, 0.05 );\n}\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k, in float bias )\n{\n    vec3 ab = b - a;\n    vec3 ao = ro - a;\n    vec3 bo = ro - b;\n    float t = dot( ao, ab ) / dot( ab, ab );\n    vec3 p = a + ab * clamp( t, 0.0, 1.0 );\n    float d = length( ao - p );\n    float s = ( d - r ) / k;\n    float w = clamp( 1.0 - s * s, 0.0, 1.0 );\n    return w * w * ( 1.0 - bias );\n}\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k, in float bias, in float maxDist )\n{\n    vec3 ab = b - a;\n    vec3 ao = ro - a;\n    vec3 bo = ro - b;\n    float t = dot( ao, ab", "\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float d = rad1 - rad2;\n    float t = rad1 - th;\n    float s = rad1 + th;\n    float f = rad2 - th;\n    float g = rad2 + th;\n    float h = rad1 - rad2 - th;\n    float i = rad1 + rad2 + th;\n    float j = rad1 - rad2 + th;\n    float k = rad1 + rad2 - th;\n    float l = rad1 - rad2 - th;\n    float m = rad1 + rad2 + th;\n    float n = rad1 - rad2 + th;\n    float o = rad1 + rad2 - th;\n    float p = rad1 - rad2 - th;\n    float q = rad1 + rad2 + th;\n    float r = rad1 - rad2 + th;\n    float s = rad1 + rad2 - th;\n    float t = rad1 - rad2 - th;\n    float u = rad1 + rad2 + th;\n    float v = rad1 - rad2 + th;\n    float w = rad1 + rad2 - th;\n    float x = rad1 - rad2 - th;\n    float y = rad1 + rad2 + th;\n    float z = rad1 - rad2 + th;\n    float aa = rad1 + rad2 - th;\n    float ab = rad1 - rad2 - th;\n    float ac = rad1 + rad2 + th;\n    float ad = rad1 - rad2 + th;\n    float ae = rad1 + rad2 - th;\n    float af = rad1 - rad2 - th;\n    float ag = rad1 + rad2 + th;\n    float ah = rad1 - rad2 + th;\n    float ai = rad1 + rad2 - th;\n    float aj = rad1 - rad2 - th;\n    float ak = rad1 + rad2 + th;\n    float al = rad1 - rad2 + th;\n    float am = rad1 + rad2 - th;\n    float an = rad1 - rad2 - th;\n    float ao", " theta = acos(c.x);\n  float s = sin(theta);\n  float h = c.y*s;\n  float d = length(p-c.xy*r);\n  float sgn = (c.x<0.)?-1.:1.;\n  float a = sgn*acos(d/r);\n  float b = sgn*acos(h/r);\n  float k = (a-b)*r;\n  return d-k;\n}", "/\n    float r = 1.0;\n    float a = 0.5;\n    float d = length(pos);\n    float f = d*d*d*d - r*r*r*r;\n    return vec3(4.0*pos.x*pos.x*pos.x*pos.x + 4.0*pos.y*pos.y*pos.y*pos.y + 4.0*pos.z*pos.z*pos.z*pos.z - 4.0*a*a*a*a,\n                4.0*pos.x*pos.x*pos.x*pos.x + 4.0*pos.y*pos.y*pos.y*pos.y + 4.0*pos.z*pos.z*pos.z*pos.z - 4.0*a*a*a*a,\n                4.0*pos.x*pos.x*pos.x*pos.x + 4.0*pos.y*pos.y*pos.y*pos.y + 4.0*pos.z*pos.z*pos.z*pos.z - 4.0*a*a*a*a);\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos, in float r, in float a )\n{\n    float d = length(pos);\n    float f = d*d*d*d - r*r*r*r;\n    return vec3(4.0*pos.x*pos.x*pos.x*pos.x + 4.0*pos.y*pos.y*pos.y*pos.y + 4.0*pos.z*pos.z*pos.z*pos.z - 4.0*a*a*a*a,\n                4.0*pos.x*pos.x*pos.x*pos.x + 4.0*pos.y*pos.y*pos.y*pos.y + 4.0*pos", " isect = vec4(0.0);\n  float s = dot(sca,scb);\n  float c = dot(sca,sca) - 1.0;\n  float b = dot(p,sca);\n  float a = dot(p,p) - rb*rb;\n  float d = b*b - a*c;\n  if( d < 0.0 ) return -1.0;\n  d = -2.0*sqrt(d);\n  float t0 = (b+d)*c;\n  float t1 = (b-d)*c;\n  float t = 0.0;\n  if( t0 > 0.0 )\n  { t = t0;\n    if( t1 > 0.0 && t1 < t ) t = t1;\n  }\n  else if( t1 > 0.0 ) t = t1;\n  if( t < 0.0 ) return -1.0;\n  float r = sqrt(t)/abs(s);\n  if( r > ra ) return -1.0;\n  return sqrt(ra*ra-r*r);\n}", ":// raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    const float eps = 0.0001;\n    const vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*sdf( pos + e.xyy*eps, time ) +\n                      e.yyx*sdf( pos + e.yyx*eps, time ) +\n                      e.yxy*sdf( pos + e.yxy*eps, time ) +\n                      e.xxx*sdf( pos + e.xxx*eps, time ) );\n}", ":// raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", ":// p is the point in space\n  // dpdx and dpdy are the derivatives of the point\n  // in space with respect to screen coordinates\n  //\n  // returns a value in the range [0,1]\n  // 0 is black, 1 is white\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to get a smooth transition\n  // between the checker colors\n  //\n  // the function is designed to be used with\n  // a gradient texture to", "\n    return sign(x)*(abs(x)-.5)/k;\n}\n\n// Inverse of the staircase function\nfloat staircase_inv( in float x, in float k )\n{\n    return sign(x)*(abs(x)+.5)*k;\n}\n\n// Derivative of the staircase function\nfloat staircase_deriv( in float x, in float k )\n{\n    return sign(x)*(1.-abs(x)/k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv( in float x, in float k )\n{\n    return sign(x)*(1.+abs(x)/k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv2( in float x, in float k )\n{\n    return sign(x)*(1./k-abs(x)/k*k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv3( in float x, in float k )\n{\n    return sign(x)*(1./k-2.*abs(x)/k*k+abs(x)/k*k*k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv4( in float x, in float k )\n{\n    return sign(x)*(1./k-3.*abs(x)/k*k+3.*abs(x)/k*k*k-abs(x)/k*k*k*k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv5( in float x, in float k )\n{\n    return sign(x)*(1./k-4.*abs(x)/k*k+6.*abs(x)/k*k*k-4.*abs(x)/k*k*k*k+abs(x)/k*k*k*k*k);\n}\n\n// Derivative of the inverse of the staircase function\nfloat staircase_inv_deriv6( in float x, in float k )\n{\n    return sign(x)*(1./k-5.*abs(x)/k", "\n    vec3 atmosphere_col = vec3(0.0);\n    float atmosphere_intensity = 0.0;\n    float atmosphere_distance = 0.0;\n    float atmosphere_step = 0.01;\n    float atmosphere_steps = 100.0;\n    for (float i = 0.0; i < atmosphere_steps; i += 1.0) {\n        vec3 atmosphere_pos = sample_pos + atmosphere_distance * surface_normal;\n        vec3 atmosphere_sample = texture(atmosphere_texture, atmosphere_pos).rgb;\n        atmosphere_col += atmosphere_sample * atmosphere_step;\n        atmosphere_intensity += 1.0;\n        atmosphere_distance += atmosphere_step;\n    }\n    atmosphere_col /= atmosphere_intensity;\n    return atmosphere_col;\n}", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n    float sphere_radius_sq = sphere_radius * sphere_radius;\n    float dist_to_sphere = length(sphere_pos - pos);\n    float dist_to_sphere_sq = dist_to_sphere * dist_to_sphere;\n    float dist_to_sphere_sq_minus_radius_sq = dist_to_sphere_sq - sphere_radius_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq = dist_to_sphere_sq_minus_radius_sq * dist_to_sphere_sq_minus_radius_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq_sq = dist_to_sphere_sq_minus_radius_sq_sq * dist_to_sphere_sq_minus_radius_sq_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq_sq_sq = dist_to_sphere_sq_minus_radius_sq_sq_sq * dist_to_sphere_sq_minus_radius_sq_sq_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq = dist_to_sphere_sq_minus_radius_sq_sq_sq_sq * dist_to_sphere_sq_minus_radius_sq_sq_sq_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq_sq = dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq * dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq;\n    float dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq_sq_sq = dist_to_sphere_sq_minus_radius_sq_sq_sq_sq_sq_sq * dist_to_sphere_sq_minus_radius_sq_", "\n    vec2 uv = coord / resolution.xy;\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 1.0 / sqrt(dot(xy, xy) + 1.0);\n    return vec3(xy, z);\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec2 uv = coord / resolution.xy;\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 1.0 / sqrt(dot(xy, xy) + 1.0);\n    return vec3(xy, z);\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec2 uv = coord / resolution.xy;\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 1.0 / sqrt(dot(xy, xy) + 1.0);\n    return vec3(xy, z);\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n    vec2 uv = coord / resolution.xy;\n    vec2 xy = uv * 2.0 - 1.0;\n    float z = 1.0 / sqrt(dot(xy, xy) + 1.0);\n    return vec3(xy, z);\n}\n\n/*\nnow we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction", " isect = vec4(0.0);\n  float res = 1e5;\n  float r = length(p.xz);\n  if (r < ra)\n  { float s = sign(p.x);\n    float z = sqrt(ra*ra - r*r);\n    float a = atan(p.z, s*p.x);\n    float b = a - c.x;\n    float d = c.y - abs(b);\n    float e = clamp(d, 0.0, ra);\n    float f = length(vec2(e, p.y));\n    res = min(res, f);\n  }\n  return res;\n}", " color = vec3(0.0);\n    if (material == 1) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 2) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 3) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 4) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 5) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 6) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 7) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 8) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 9) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 10) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 11) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 12) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 13) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 14) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 15) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == 16) { color = vec3(0.0, 0.0, 0.0); }\n    else if (material == ", "ivity.\n    if (material == MATERIAL_METAL) {\n        return 1.0;\n    } else if (material == MATERIAL_GLASS) {\n        return 0.9;\n    } else if (material == MATERIAL_DIFFUSE) {\n        return 0.0;\n    } else {\n        return 0.0;\n    }\n}", " ofstream fout; fout.open(\"materials.txt\");\n    if (material == 0) {\n        return 1.0;\n    } else if (material == 1) {\n        return 1.5;\n    } else if (material == 2) {\n        return 1.33;\n    } else if (material == 3) {\n        return 1.4;\n    } else if (material == 4) {\n        return 1.6;\n    } else if (material == 5) {\n        return 1.7;\n    } else if (material == 6) {\n        return 1.8;\n    } else if (material == 7) {\n        return 1.9;\n    } else if (material == 8) {\n        return 2.0;\n    } else if (material == 9) {\n        return 2.1;\n    } else if (material == 10) {\n        return 2.2;\n    } else if (material == 11) {\n        return 2.3;\n    } else if (material == 12) {\n        return 2.4;\n    } else if (material == 13) {\n        return 2.5;\n    } else if (material == 14) {\n        return 2.6;\n    } else if (material == 15) {\n        return 2.7;\n    } else if (material == 16) {\n        return 2.8;\n    } else if (material == 17) {\n        return 2.9;\n    } else if (material == 18) {\n        return 3.0;\n    } else if (material == 19) {\n        return 3.1;\n    } else if (material == 20) {\n        return 3.2;\n    } else if (material == 21) {\n        return 3.3;\n    } else if (material == 22) {\n        return 3.4;\n    } else if (material == 23) {\n        return 3.5;\n    } else if (material == 24) {\n        return 3.6", " ofShader shader; shader.load(\"shaders/get_material_opacity.vert\", \"shaders/get_material_opacity.frag\"); shader.begin(); shader.setUniform1i(\"material\", material); shader.end(); return shader.getUniformf(\"opacity\"); }\n\n// Get the color of a material.\n// The color is in the range [0, 1].\n// The color is in the order (r, g, b).\nvec3 get_material_color(int material) { ofShader shader; shader.load(\"shaders/get_material_color.vert\", \"shaders/get_material_color.frag\"); shader.begin(); shader.setUniform1i(\"material\", material); shader.end(); return shader.getUniform3f(\"color\"); }\n\n// Get the texture of a material.\n// The texture is in the range [0, 1].\n// The texture is in the order (r, g, b).\nvec3 get_material_texture(int material) { ofShader shader; shader.load(\"shaders/get_material_texture.vert\", \"shaders/get_material_texture.frag\"); shader.begin(); shader.setUniform1i(\"material\", material); shader.end(); return shader.getUniform3f(\"texture\"); }\n\n// Get the normal of a material.\n// The normal is in the range [-1, 1].\n// The normal is in the order (x, y, z).\nvec3 get_material_normal(int material) { ofShader shader; shader.load(\"shaders/get_material_normal.vert\", \"shaders/get_material_normal.frag\"); shader.begin(); shader.setUniform1i(\"material\", material); shader.end(); return shader.getUniform3f(\"normal\"); }\n\n// Get the specular of a material.\n// The specular is in the range [0, 1].\n// The specular is in the order (r, g, b).\nvec3 get_material_specular(int material) { ofShader shader; shader.load(\"shaders/get_material_specular.vert\",", "ine_a, line_b, tri_a, tri_b, tri_c);\n    vec3 e1 = tri_b - tri_a;\n    vec3 e2 = tri_c - tri_a;\n    vec3 p = cross(line_b - line_a, e2);\n    float det = dot(e1, p);\n    if (det == 0.0) return vec3(0.0);\n    vec3 t = line_a - tri_a;\n    float u = dot(t, p) / det;\n    if (u < 0.0 || u > 1.0) return vec3(0.0);\n    vec3 q = cross(t, e1);\n    float v = dot(line_b - line_a, q) / det;\n    if (v < 0.0 || u + v > 1.0) return vec3(0.0);\n    float t_ = dot(e2, q) / det;\n    return vec3(1.0, u, v);\n}", "\n    vec3 v1 = tri_b - tri_a;\n    vec3 v2 = tri_c - tri_a;\n    return normalize(cross(v1, v2));\n}", " a\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    return mat3(x_axis, y_axis, z_axis);\n}", "\n    cast_ray_result result;\n    result.hit = false;\n    result.distance = 0.0f;\n    result.normal = vec3(0.0f);\n    result.color = vec3(0.0f);\n\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n\n    for (int i = 0; i < scene_triangles.size(); i++) {\n        vec3 v0 = scene_triangles[i].v0;\n        vec3 v1 = scene_triangles[i].v1;\n        vec3 v2 = scene_triangles[i].v2;\n\n        vec3 edge1 = v1 - v0;\n        vec3 edge2 = v2 - v0;\n\n        vec3 h = cross(ray_direction, edge2);\n        float a = dot(edge1, h);\n\n        if (a > -0.00001 && a < 0.00001) {\n            continue;\n        }\n\n        float f = 1.0f / a;\n        vec3 s = ray_origin - v0;\n        float u = f * dot(s, h);\n\n        if (u < 0.0f || u > 1.0f) {\n            continue;\n        }\n\n        vec3 q = cross(s, edge1);\n        float v = f * dot(ray_direction, q);\n\n        if (v < 0.0f || u + v > 1.0f) {\n            continue;\n        }\n\n        float t = f * dot(edge2, q);\n\n        if (t > 0.00001) {\n            if (!result.hit || t < result.distance) {\n                result.hit = true;\n                result.distance = t;\n                result.normal = normalize(cross(edge1, edge2));\n                result.color = scene_triangles[i].color;\n            }\n        }\n    }\n\n    return result;\n}", "\n    vec3 ray_direction = ray_target - ray_origin;\n    float ray_length = length(ray_direction);\n    ray_direction /= ray_length;\n\n    vec3 ray_pos = ray_origin;\n    float shadow_amount = 0.0;\n\n    for (int i = 0; i < 32; i++) {\n        if (ray_length < 0.01) {\n            break;\n        }\n\n        vec3 sample_pos = ray_pos + ray_direction * 0.01;\n        vec3 sample_normal = get_normal(sample_pos);\n        float sample_dist = length(sample_pos - ray_origin);\n        float sample_opacity = get_opacity(sample_pos);\n\n        if (sample_opacity > 0.0) {\n            shadow_amount += (1.0 - sample_opacity) * (1.0 - shadow_amount);\n        }\n\n        ray_length -= sample_dist;\n        ray_pos += ray_direction * sample_dist;\n    }\n\n    return shadow_amount;\n}", "\n    return fract( sin( x ) * 43758.5453 );\n}\n\n// 2D noise\nfloat bnoise( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2 f = fract( x );\n    f = f * f * ( 3.0 - 2.0 * f );\n    float res = mix(\n        mix( bnoise( p ), bnoise( p + vec2( 1.0, 0.0 ) ), f.x ),\n        mix( bnoise( p + vec2( 0.0, 1.0 ) ), bnoise( p + vec2( 1.0, 1.0 ) ), f.x ),\n        f.y );\n    return res * res;\n}\n\n// 3D noise\nfloat bnoise( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    f = f * f * ( 3.0 - 2.0 * f );\n    float res = mix(\n        mix( mix( bnoise( p ), bnoise( p + vec3( 1.0, 0.0, 0.0 ) ), f.x ),\n             mix( bnoise( p + vec3( 1.0, 1.0, 0.0 ) ), bnoise( p + vec3( 2.0, 1.0, 0.0 ) ), f.x ), f.y ),\n        mix( mix( bnoise( p + vec3( 0.0, 0.0, 1.0 ) ), bnoise( p + vec3( 1.0, 0.0, 1.0 ) ), f.x ),\n             mix( bnoise( p + vec3( 1.0, 1.0, 1.0 ) ), bnoise( p + vec3( 2.0, 1.0, 1.0 ) ), f.x ), f.y ),\n        f.z );\n    return res * res;\n}\n\n// 4D noise\nfloat bnoise( in vec4 x )\n{\n    vec4 p = floor( x );\n    vec4 f = fract(", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f * f * ( 3.0 - 2.0 * f );\n    return mix( hash( i ), hash( i + 1.0 ), u );\n}\n\n// Smooth gradient noise\nfloat snoise( in float p )\n{\n    float i = floor( p );\n    float f = fract( p );\n    float g = smoothstep( 0.0, 1.0, f );\n    return mix( hash( i ), hash( i + 1.0 ), g );\n}\n\n// Traditional gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( mix( hash( i ), hash( i + vec2( 1.0, 0.0 ) ), u.x ),\n                mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), u.x ), u.y );\n}\n\n// Smooth gradient noise\nfloat snoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 g = smoothstep( 0.0, 1.0, f );\n    return mix( mix( hash( i ), hash( i + vec2( 1.0, 0.0 ) ), g.x ),\n                mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), g.x ), g.y );\n}\n\n// Traditional gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( mix( mix( hash( i ), hash( i + vec3( 1.0, ", "\n    int k = n;\n    k = (k+0x7ed55d16) + (k<<12);\n    k = (k^0xc761c23c) ^ (k>>19);\n    k = (k+0x165667b1) + (k<<5);\n    k = (k+0xd3a2646c) ^ (k<<9);\n    k = (k+0xfd7046c5) + (k<<3);\n    k = (k^0xb55a4f09) ^ (k>>16);\n    return k;\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    return hash( *(int*)&n ) / 2147483647.0;\n}\n\n// 2D float hash copied from Hugo Elias\nfloat hash( float n, float m ) \n{\n    return hash( hash( n ) + m ) / 2147483647.0;\n}\n\n// 3D float hash copied from Hugo Elias\nfloat hash( float n, float m, float o ) \n{\n    return hash( hash( n, m ) + o ) / 2147483647.0;\n}\n\n// 4D float hash copied from Hugo Elias\nfloat hash( float n, float m, float o, float p ) \n{\n    return hash( hash( n, m, o ) + p ) / 2147483647.0;\n}\n\n// 2D integer hash copied from Hugo Elias\nint hash( int n, int m ) \n{\n    return hash( hash( n ) + m );\n}\n\n// 3D integer hash copied from Hugo Elias\nint hash( int n, int m, int o ) \n{\n    return hash( hash( n, m ) + o );\n}\n\n// 4D integer hash copied from Hugo Elias\nint hash( int n, int m, int o, int p ) \n{\n    return hash( hash( n, m, o ) + p );\n}\n\n// 2D integer hash copied from Hugo Elias\nint hash( int n, int m ) \n{\n    return hash( hash( n ) + m );\n}\n\n", "\n    float i = floor( p );\n    float f = fract( p );\n    float u = f * f * ( 3.0 - 2.0 * f );\n    return mix( hash( i ), hash( i + 1.0 ), u );\n}\n\n// 2D gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( mix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), u.x ),\n                mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), u.x ),\n                u.y );\n}\n\n// 3D gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( mix( mix( hash( i + vec3( 0.0, 0.0, 0.0 ) ), hash( i + vec3( 1.0, 0.0, 0.0 ) ), u.x ),\n                     mix( hash( i + vec3( 0.0, 1.0, 0.0 ) ), hash( i + vec3( 1.0, 1.0, 0.0 ) ), u.x ), u.y ),\n                mix( mix( hash( i + vec3( 0.0, 0.0, 1.0 ) ), hash( i + vec3( 1.0, 0.0, 1.0 ) ), u.x ),\n                     mix( hash( i + vec3( 0.0, 1.0, 1.0 ) ), hash( i + vec3( 1.0, 1.0, 1.0 )", "\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x * G + 0.5;\n        a *= p;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec2 x, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x * G + 0.5;\n        a *= p;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x * G + 0.5;\n        a *= p;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec4 x, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x );\n        x = x * G + 0.5;\n        a *= p;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in float x, in float y, in float G )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float p = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise( x, y );\n        x = x * G + 0.5", "\n    vec3 c = vec3(0.0);\n    vec3 q = p;\n    float t = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        float d = dot( q, q );\n        float s = sqrt( d );\n        float a = atan( s, q.z );\n        float b = atan( q.y, q.x );\n        float r = 0.5 * ( 1.0 + cos( a + b ) );\n        float g = 0.5 * ( 1.0 + cos( a - b ) );\n        float bb = 0.5 * ( 1.0 + sin( a + b ) );\n        float aa = 0.5 * ( 1.0 + sin( a - b ) );\n        c += vec3( r, g, bb ) * aa;\n        q = q * 2.0 + vec3( 1.0, 1.0, 1.0 );\n        t += 1.0;\n    }\n    return c / float( t );\n}\n\n// Return a color based on the solutions of the associate quadratic polynomial\n// for a point in the sphere's surface that is at a distance of 'd' from the\n// origin.\nvec3 getColor( in float d )\n{\n    return getColor( vec3( d, 0.0, 0.0 ) );\n}\n\n// Return a color based on the solutions of the associate quadratic polynomial\n// for a point in the sphere's surface that is at a distance of 'd' from the\n// origin, and that is rotated by 'a' radians around the y-axis.\nvec3 getColor( in float d, in float a )\n{\n    return getColor( vec3( d * cos( a ), d * sin( a ), 0.0 ) );\n}\n\n// Return a color based on the solutions of the associate quadratic polynomial\n// for a point in the sphere's surface that is at a distance of 'd' from the\n// origin, and that is rotated by 'a' radians around the y-axis, and that is\n// rotated by 'b", "the\n    vec3 p = pb * 0.5 + 0.5;\n    vec3 c = vec3(0.0);\n    float a = 0.0;\n    float b = 0.0;\n    float d = 0.0;\n    float t = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;", ":// ray-box intersection\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec4(0.0); // no intersection\n    return vec4(cen + rd*tN, tF-tN);\n}\n\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in float rad ) \n{\n    return boxIntersect(ro, rd, cen, vec3(rad));\n}\n\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float rot ) \n{\n    // rotate ray\n    vec3 rdx = vec3(rd.x*cos(rot), rd.x*sin(rot), rd.z);\n    vec3 rdy = vec3(rd.y*cos(rot), rd.y*sin(rot), rd.z);\n    vec3 rdz = vec3(rd.x*sin(rot),-rd.x*cos(rot), rd.z);\n    // rotate center\n    vec3 cdx = vec3(cen.x*cos(rot), cen.x*sin(rot), cen.z);\n    vec3 cdy = vec3(cen.y*cos(rot), cen.y*sin(rot), cen.z);\n    vec3 cdz = vec3(cen.x*sin(rot),-cen.x*cos(rot), cen.z);\n    // rotate radius\n    vec3 rdx2 = vec3(rad.x*cos(rot), rad.x*sin(rot), rad.z);\n    vec3 rdy2 = vec3(rad.y*cos(rot), rad.y*sin(", "://ro: ray origin, rd: ray direction, cen: box center, rad: box radius\n    vec3  oc = ro - cen;\n    vec3  rd_ = rd / rad;\n    vec3  oc_ = oc / rad;\n    float b = dot(oc_,rd_);\n    float h = b*b - dot(oc_,oc_) + 1.0;\n    if( h<0.0 ) return 1.0;\n    h = sqrt(h);\n    float t1 = b - h;\n    float t2 = b + h;\n    float t = t1;\n    if( t2>0.0 && t2<length(oc) ) t = t2;\n    float d = t / length(rd);\n    return clamp( 1.0 - d, 0.0, 1.0 );\n}\n\nfloat box( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{//ro: ray origin, rd: ray direction, cen: box center, rad: box radius\n    vec3  oc = ro - cen;\n    vec3  rd_ = rd / rad;\n    vec3  oc_ = oc / rad;\n    float b = dot(oc_,rd_);\n    float h = b*b - dot(oc_,oc_) + 1.0;\n    if( h<0.0 ) return 1e5;\n    h = sqrt(h);\n    float t1 = b - h;\n    float t2 = b + h;\n    float t = t1;\n    if( t2>0.0 && t2<length(oc) ) t = t2;\n    return t;\n}\n\nfloat boxSDF( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{//ro: ray origin, rd: ray direction, cen: box center, rad: box radius\n    vec3  oc = ro - cen;\n    vec3  rd_ = rd / rad;\n    vec3  oc_ = oc / rad;\n    float b = dot(oc_,rd_);\n    float h = b*b - dot(", "\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 32; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, w * h / t);\n        t += clamp(h, 0.02, 0.5);\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}", " Carlo_seed = (Carlo_seed * 16807) % 2147483647; return (Carlo_seed - 1) / 2147483646.0; }\n\nfloat shadow(vec3 p, vec3 l, float r) {\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tt += rand() * r;\n\t\tif (length(p + l * t) < 0.01) return 0.0;\n\t}\n\treturn 1.0;\n}", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float e )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float e, in float f )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f*t );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float e, in float f, in float g )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f*t + g*t*t );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float e, in float f, in float g, in float h )\n{\n    return a + b*cos( 6.28318*(c*t+d) + e + f*t + g*t*t + h*t*t*t );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float e,", "\n    vec2 q = abs(p.xz);\n    float k = max(la,lb);\n    float d = max(k*h - abs(q.x*h + q.y*la - la*h*lb),\n                  lb*q.x + la*q.y - la*lb);\n    return length(max(d,0.0)) + min(max(d,0.0),ra);\n}", " =\n    vec2 pa = p - a, ba = b - a;\n    float t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 closest = a + t*ba;\n    float dist = length( p - closest );\n    float perim = length( ba );\n    float total = length( p - a ) + length( p - b );\n    return vec4( dist, perim, total, sdfSegment( p, a, b, r, band ) );\n}", " =\n    vec2 d = abs(p)-b;\n    vec2 e = max(d,vec2(0.0));\n    vec2 f = min(d,vec2(0.0));\n    float g = length(e);\n    float h = min(max(e.x,e.y),0.0);\n    float i = max(e.x,e.y);\n    float j = length(max(d,vec2(0.0)));\n    float k = min(max(d.x,d.y),0.0);\n    float l = max(d.x,d.y);\n    float m = length(max(d,vec2(0.0)));\n    float n = min(max(d.x,d.y),0.0);\n    float o = max(d.x,d.y);\n    float p = length(max(d,vec2(0.0)));\n    float q = min(max(d.x,d.y),0.0);\n    float r = max(d.x,d.y);\n    float s = length(max(d,vec2(0.0)));\n    float t = min(max(d.x,d.y),0.0);\n    float u = max(d.x,d.y);\n    float v = length(max(d,vec2(0.0)));\n    float w = min(max(d.x,d.y),0.0);\n    float x = max(d.x,d.y);\n    float y = length(max(d,vec2(0.0)));\n    float z = min(max(d.x,d.y),0.0);\n    float aa = max(d.x,d.y);\n    float ab = length(max(d,vec2(0.0)));\n    float ac = min(max(d.x,d.y),0.0);\n    float ad = max(d.x,d.y);\n    float ae = length(max(d,vec2(0.0)));\n    float af = min(max(d.x,d.y),0.0);\n", " = sdgBox( p, b, vec3(0) ); }\nvec3 sdgBox( in vec2 p, in vec2 b, in vec3 c )\n{\n    vec2 d = abs(p) - b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,d.y),0.0), c.yz );\n}", " =\n    vec2 q = abs(p);\n    float d = length(q - r);\n    float b = length(q - (r - band));\n    float a = length(q - (r + band));\n    float w = min(min(d, a), b);\n    return vec4(d, w, a, b);\n}", "// verts must be in clockwise order\n    float d = 1e10;\n    for( int i=0; i<4; i++ )\n    {\n        vec2 a = verts[i], b = verts[(i+1)%4];\n        vec2 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min( d, length( pa - ba*h ) - r );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5] ) \n{// verts must be in clockwise order\n    float d = 1e10;\n    for( int i=0; i<4; i++ )\n    {\n        vec2 a = verts[i], b = verts[(i+1)%4];\n        vec2 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min( d, length( pa - ba*h ) );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float r2 ) \n{// verts must be in clockwise order\n    float d = 1e10;\n    for( int i=0; i<4; i++ )\n    {\n        vec2 a = verts[i], b = verts[(i+1)%4];\n        vec2 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min( d, length( pa - ba*h ) - r );\n        d = min( d, length( pa - ba*h ) - r2 );\n    }\n    return d;\n}\n\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r, in float r2, in float r3 ) \n", " =\n    vec2 q = p;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float", " = sdgSegment( p, a, b, 1.0 );\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), h, dot(pa,ba) );\n}", " = vec3(0.);\n    p = abs(p);\n    vec2 q = vec2(p.x+p.y,p.y-p.x);\n    vec2 a = vec2(r,r*0.5);\n    vec2 b = vec2(r*0.866025,r*0.5);\n    float k = max(dot(a,b),dot(b,vec2(a.y,-a.x)));\n    vec2 w = vec2(dot(q,a),dot(q,b));\n    vec2 e = vec2(w.y-k,k-w.x);\n    float s = (e.x>0.0)?e.x:(-e.y);\n    if( (w.x<0.0) || (w.y<0.0) )\n        s = max(s,w.x);\n    if( (w.x>a.x) || (w.y>b.y) )\n        s = max(s,w.y);\n    if( (s<0.0) && (w.x>-b.x) && (w.y>a.y) )\n        s = max(s,w.x+w.y-k);\n    if( (s<0.0) && (w.x>b.x) && (w.y>b.y) )\n        s = max(s,w.x+w.y-k);\n    vec2 d = vec2(s,s);\n    if( (s<0.0) && (w.x>-b.x) && (w.y>-a.y) )\n        d = vec2(w.x,w.y);\n    if( (s<0.0) && (w.x>a.x) && (w.y>b.y) )\n        d = vec2(w.y,-w.x+k);\n    if( (s<0.0) && (w.x>b.x) && (w.y>b.y) )\n        d = vec2(-w.x+k,w.y);\n    if( (s<", "1\n    vec3 q = X * p;\n    float a = dot(q, q);\n    float b = dot(p, X[2]);\n    float c = dot(p, p) - 1.;\n    float d = b * b - a * c;\n    if (d < 0.) {\n        tan1 = tan2 = vec3(0);\n        return false;\n    }\n    d = sqrt(d);\n    tan1 = (p - q * (b + d) / a) / length(p - q * (b + d) / a);\n    tan2 = (p - q * (b - d) / a) / length(p - q * (b - d) / a);\n    return true;\n}", "\n    vec3 c = a;\n    if (b.x == 0.0) {\n        c.x += 0.0001;\n    }\n    if (b.y == 0.0) {\n        c.y += 0.0001;\n    }\n    if (b.z == 0.0) {\n        c.z += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec2 div(vec2 a, float b) {\n    vec2 c = a;\n    if (b == 0.0) {\n        c.x += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nfloat div(float a, float b) {\n    float c = a;\n    if (b == 0.0) {\n        c += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nfloat div(float a, int b) {\n    float c = a;\n    if (b == 0) {\n        c += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nfloat div(int a, float b) {\n    float c = a;\n    if (b == 0.0) {\n        c += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nfloat div(int a, int b) {\n    float c = a;\n    if (b == 0) {\n        c += 0.0001;\n    }\n    return c / b;\n}\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a,", "\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 RotateX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 a)\n{\n    return RotateZ(RotateY(RotateX(p, a.x), a.y), a.z);\n}\n\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nvec3 Scale(vec3 p, vec3 s)\n{\n    return p / s;\n}\n\nvec3 Transform(vec3 p, mat4 m)\n{\n    return (m * vec4(p, 1.0)).xyz;\n}\n\n// Primitives\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat Cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),", "ic\n\treturn pow(R - x, 3);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn R - x;\n}\n\n// Exponential falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn exp(-x / R);\n}\n\n// Gaussian falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn exp(-(x * x) / (R * R));\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smoothstep falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n\treturn smoothstep(0.0, R, x);\n}\n\n// Smooth", " theta = 0.5 * (1.0 + sqrt(1.0 + 4.0 * e / R));\n  return 0.5 * (1.0 + sqrt(1.0 + 4.0 * e / R));\n}", " theta = 0.5 * (a + b);\n  return (theta - a) * (theta - b) / (e * R * R);\n}", "\n    return e * max(0.0, length(p - c) - R);\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// h: height\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float h, float e)\n{\n    vec3 d = abs(p - c) - vec3(R, R, h);\n    return e * max(max(d.x, d.y), d.z);\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    return e * max(0.0, length(p - c) - R);\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// s: size\n// e: energy\nfloat Box(vec3 p, vec3 c, vec3 s, float e)\n{\n    vec3 d = abs(p - c) - s;\n    return e * max(max(d.x, d.y), d.z);\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// r: ring radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float r, float e)\n{\n    vec2 q = vec2(length(p.xz - c.xz) - R, p.y - c.y);\n    return e * max(length(q) - r, q.x);\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// h: height\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float h, float e)\n{\n    vec2 q = vec2(length(p.xz - c.xz) - R, p.y - c.y);\n    return e * max(q.x * q.x / (R * R) + q.y * q.y - h", "uates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat d = distance(c, a);\nfloat d2 = distance(c, b);\nfloat d3 = distance(a, b);\nfloat d4 = distance(c, b);\nfloat d5 = distance(c, a);\nfloat d6 = distance(a, b);\nfloat d7 = distance(c, a);\nfloat d8 = distance(c, b);\nfloat d9 = distance(a, b);\nfloat d10 = distance(c, a);\nfloat d11 = distance(c, b);\nfloat d12 = distance(a, b);\nfloat d13 = distance(c, a);\nfloat d14 = distance(c, b);\nfloat d15 = distance(a, b);\nfloat d16 = distance(c, a);\nfloat d17 = distance(c, b);\nfloat d18 = distance(a, b);\nfloat d19 = distance(c, a);\nfloat d20 = distance(c, b);\nfloat d21 = distance(a, b);\nfloat d22 = distance(c, a);\nfloat d23 = distance(c, b);\nfloat d24 = distance(a, b);\nfloat d25 = distance(c, a);\nfloat d26 = distance(c, b);\nfloat d27 = distance(a, b);\nfloat d28 = distance(c, a);\nfloat d29 = distance(c, b);\nfloat d30 = distance(a, b);\nfloat d31 = distance(c, a);\nfloat d32 = distance(c, b);\nfloat d33 = distance(a, b);\nfloat d34 = distance(c, a);\nfloat d35 = distance(c, b);\nfloat d36 = distance(a, b);\nfloat d37 = distance(c, a);\nfloat d38 = distance(c, b);\nfloat d39 = distance(a, b);\nfloat d40 = distance(c, a);\nfloat d41 = distance(c, b);\nfloat d42 = distance(a, b);\nfloat d43 = distance", "\n    float d = 1e10;\n    d = min(d, Tree(p));\n    return d;\n}\n\n// Tree\nfloat Tree(vec3 p)\n{\n    float d = 1e10;\n    float h = 0.0;\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 q = p - vec3(0.0, -0.5, 0.0);\n        h = max(h, q.y);\n        float s = 1.0 - 5.0 * float(i) / 2.0;\n        q.y -= s * h;\n        d = min(d, S(q));\n    }\n    return d;\n}\n\n// Smooth union\nfloat S(vec3 p)\n{\n    float d1 = Box(p, vec3(0.5, 0.5, 0.5));\n    float d2 = Box(p, vec3(0.5, 0.5, 0.5));\n    return SmoothUnion(d1, d2, 0.1);\n}\n\n// Box\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Smooth union\nfloat SmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}", "\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b)\n{\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c)\n{\n    return length(a - b) + length(b - c) + length(c - a);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c)\n{\n    return length(a - b) + length(b - c) + length(c - a);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return length(a - b) + length(b - c) + length(c - d) + length(d - a);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return length(a - b) + length(b - c) + length(c - d) + length(d - a);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e)\n{\n    return length(a - b) + length(b - c) + length(c - d) + length(d - e) + length(e - a);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d, vec2 e)\n{\n    return length(a - b) + length(b - c) + length(c - d) + length(d - e) + length(e - a);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f)\n{\n    return length(a - b) + length(b - c) + length(c - d) + length(d - e) + length(e - f) + length(f - a);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, vec2 c, vec2 d, vec2", "\n    vec2 e = vec2(.001, 0);\n    return normalize(vec3(\n        ObjectDistance(p + e.xyy) - ObjectDistance(p - e.xyy),\n        ObjectDistance(p + e.yxy) - ObjectDistance(p - e.yxy),\n        ObjectDistance(p + e.yyx) - ObjectDistance(p - e.yyx)\n    ));\n}\n\n// Normal evaluation with derivatives\nvec3 ObjectNormal(in vec3 p, in vec3 d)\n{\n    return normalize(vec3(\n        d.x * ObjectDistance(p + d * vec3(.001, 0, 0)) - d.x * ObjectDistance(p - d * vec3(.001, 0, 0)),\n        d.y * ObjectDistance(p + d * vec3(0,.001, 0)) - d.y * ObjectDistance(p - d * vec3(0,.001, 0)),\n        d.z * ObjectDistance(p + d * vec3(0, 0,.001)) - d.z * ObjectDistance(p - d * vec3(0, 0,.001))\n    ));\n}\n\n// Normal evaluation with derivatives and a custom epsilon\nvec3 ObjectNormal(in vec3 p, in vec3 d, in float e)\n{\n    return normalize(vec3(\n        d.x * ObjectDistance(p + d * vec3(e, 0, 0)) - d.x * ObjectDistance(p - d * vec3(e, 0, 0)),\n        d.y * ObjectDistance(p + d * vec3(0, e, 0)) - d.y * ObjectDistance(p - d * vec3(0, e, 0)),\n        d.z * ObjectDistance(p + d * vec3(0, 0, e)) - d.z * ObjectDistance(p - d * vec3(0, 0, e))\n    ));\n}\n\n// Normal evaluation with derivatives and a custom epsilon and a custom normal\nvec3 ObjectNormal(in vec3 p, in vec3 d,", " sphere_tracing_start:\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            s = i;\n            return t;\n        }\n        t += d;\n    }\n    h = false;\n    s = 0;\n    return t;\n}\n\n// Trace ray using raymarching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Raymarching(vec3 o, vec3 u, out bool h, out int s)\n{ raymarching_start:\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            s = i;\n            return t;\n        }\n        t += d;\n    }\n    h = false;\n    s = 0;\n    return t;\n}\n\n// Trace ray using raymarching with normal\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// n : normal\nvec3 RaymarchingWithNormal(vec3 o, vec3 u, out bool h, out int s, out vec3 n)\n{ raymarching_with_normal_start:\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = o + u * t;\n        float d = Distance(p);\n        if (d < 0.001)\n        {\n            h = true;\n            s = i;\n            n = Normal(p);\n            return p;\n        }\n        t += d;\n    }\n    h = false;\n    s = 0;\n    n = vec3(0", " ray_t r = ray_t(o, u);\n  float t = 0.0;\n  for (s = 0; s < MAX_STEPS; s++)\n  { vec3 p = r.o + r.d * t;\n    float d = Distance(p);\n    if (d < EPSILON)\n    { h = true;\n      return t;\n    }\n    t += d;\n    if (t > MAX_DISTANCE)\n    { h = false;\n      return MAX_DISTANCE;\n    }\n  }\n  h = false;\n  return MAX_DISTANCE;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{ ray_t r = ray_t(o, u);\n  float t = 0.0;\n  for (s = 0; s < MAX_STEPS; s++)\n  { p = r.o + r.d * t;\n    float d = Distance(p);\n    if (d < EPSILON)\n    { h = true;\n      return t;\n    }\n    t += d;\n    if (t > MAX_DISTANCE)\n    { h = false;\n      return MAX_DISTANCE;\n    }\n  }\n  h = false;\n  return MAX_DISTANCE;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out float d)\n{ ray_t r = ray_t(o, u);\n  float t = 0.0;\n  for (s = 0; s < MAX_STEPS; s++)\n  { p = r.o + r.d * t;\n    d = Distance(p);\n    if (d < EPSILON", "\n    return vec3(0.0);\n}\n\nvec3 Sky(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Ground(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Light(vec3 rd)\n{\n    return vec3(0.0);\n}\n\nvec3 Shade(vec3 rd, vec3 ro, vec3 col, float dist, int i)\n{\n    vec3 light = Light(rd);\n    vec3 sky = Sky(rd);\n    vec3 ground = Ground(rd);\n    vec3 background = Background(rd);\n    \n    vec3 col2 = col;\n    \n    if (i == 0)\n    {\n        col2 = background;\n    }\n    else if (i == 1)\n    {\n        col2 = sky;\n    }\n    else if (i == 2)\n    {\n        col2 = ground;\n    }\n    else if (i == 3)\n    {\n        col2 = light;\n    }\n    \n    return col2;\n}", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h)\n{\n    vec3 pa = p - a, ba = b - a;\n    float hh = clamp(dot(pa, ba) / dot(ba, ba), 0.0, h);\n    return length(pa - ba * hh) - r;\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float r2)\n{\n    vec3 pa = p - a, ba = b - a;\n    float hh = clamp(dot(pa, ba) / dot(ba, ba), 0.0, h);\n    return length(pa - ba * hh) - mix(r, r2, hh / h);\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float r2, float h2)\n{\n    vec3 pa = p - a, ba = b - a;\n    float hh = clamp(dot(pa, ba) / dot(ba, ba), 0.0, h);\n    return length(pa - ba * hh) - mix(r, r2, hh / h);\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float h, float r2, float h2, float r3)\n{\n    vec3 pa = p - a, ba = b - a;\n    float hh = clamp(dot(pa, ba) / dot(ba, ba), 0.0, h);\n    return length(pa - ba * hh) - mix(r, mix(r2, r3, hh / h2), hh / h);\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec", ":// ray-box intersection\n    vec3 m = 1.0/rd; // inverse direction\n    vec3 n = m*ro;   // inverse origin\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos ) \n{\n    vec3 m = 1.0/rd; // inverse direction\n    vec3 n = m*(ro-pos);   // inverse origin\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec3(-1.0); // no intersection\n    return vec3( tN, tF, tF-tN );\n}\n\nvec3 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 pos, in vec3 rot ) \n{\n    vec3 m = 1.0/rd; // inverse direction\n    vec3 n = m*(ro-pos);   // inverse origin\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.", "\n    return (coord + vec2(1.0)) / 2.0;\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return (coord + vec2(1.0)) / size;\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return (coord + offset + vec2(1.0)) / size;\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord + offset + vec2(1.0)) / (size * scale);\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate) {\n    return (coord + offset + vec2(1.0)) / (size * scale);\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 rotate_offset) {\n    return (coord + offset + vec2(1.0)) / (size * scale);\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 rotate_offset, vec2 rotate_scale) {\n    return (coord + offset + vec2(1.0)) / (size * scale);\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 rotate_offset, vec2 rotate_scale, vec2 rotate_scale_offset) {\n    return (coord + offset + vec2(1.0)) / (size * scale);\n}\n\n// normalized texture coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale, vec2 rotate, vec2 rotate_offset, vec2 rotate_scale, vec2 rotate_scale_offset, vec2 rotate_scale_offset_scale", "\n    vec2  d = max( vec2(0.0), p.yx-q.yx );\n    vec2  a = vec2( dot( d, vec2(0.5,0.0) ), d.x );\n    vec2  b = vec2( dot( d, vec2(0.0,0.5) ), d.y );\n    vec2  c = vec2( dot( d, vec2(0.5,0.5) ), d.x+d.y );\n    vec2  s = min( a, min( b, c ) );\n    vec2  r = max( a, max( b, c ) );\n    vec2  e = min( s, r );\n    vec2  f = max( s, r );\n    vec2  g = vec2( dot( d, vec2(0.5,0.5) ), d.x+d.y );\n    vec2  h = vec2( dot( d, vec2(0.5,0.0) ), d.x );\n    vec2  i = vec2( dot( d, vec2(0.0,0.5) ), d.y );\n    vec2  j = vec2( dot( d, vec2(0.5,0.0) ), d.x );\n    vec2  k = vec2( dot( d, vec2(0.0,0.5) ), d.y );\n    vec2  l = vec2( dot( d, vec2(0.0,0.0) ), d.x+d.y );\n    vec2  m = vec2( dot( d, vec2(0.0,0.0) ), d.x );\n    vec2  n = vec2( dot( d, vec2(0.0,0.0) ), d.y );\n    vec2  o = vec2( dot( d, vec2(0.0,0.0) ), d.x );\n    vec2  p1 = vec2( dot( d, vec2(0.0,0.0) ), d.y );\n    vec2  q1 = vec2( dot( d, vec2(0.0,0", " = vec3(0.0);\n    float a = atan(p.y, p.x);\n    float b = a / PI;\n    float c = 1.0 - b;\n    float s = sin(a);\n    float t = tan(a);\n    float u = 1.0 / (1.0 + t * t);\n    float v = 1.0 / (1.0 + s * s);\n    float w = 1.0 / (1.0 + c * c);\n    float x = 1.0 / (1.0 + s * s + c * c);\n    float y = 1.0 / (1.0 + s * s + t * t);\n    float z = 1.0 / (1.0 + c * c + t * t);\n    float A = 1.0 / (1.0 + s * s + c * c + t * t);\n    float B = 1.0 / (1.0 + s * s + c * c + t * t + r * r);\n    float C = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d);\n    float D = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d + r * d);\n    float E = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d + r * d + d * r);\n    float F = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d + r * d + d * r + r * r);\n    float G = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d + r * d + d * r + r * r + d * d);\n    float H = 1.0 / (1.0 + s * s + c * c + t * t + r * r + d * d + r * d + d * r + r * r + d * d", " = sdgPie( p, c, r, 1.0 ); }\nvec3 sdgPie( in vec2 p, in vec2 c, in float r, in float a )\n{\n    vec2 q = abs(p);\n    float d = length(q - c*r);\n    float s = sign(q.x - c.x*r);\n    float t = sign(q.y - c.y*r);\n    float aa = a*0.5;\n    float b = step( aa, atan(t,s) );\n    float f = step( r, d )*b;\n    return vec3( f, d*b, atan(t,s) );\n}", " = sdgTriangle( p, v[0], v[1], v[2] ); }\n\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec3 res = vec3( 0.0 );\n    vec2 v0 = b - a, v1 = c - b, v2 = a - c;\n    vec2 v0p = p - a, v1p = p - b, v2p = p - c;\n    vec2 n = cross( v0, v1 );\n    float d = dot( n, v0 );\n    float u = dot( n, v0p ) / d;\n    float v = dot( n, v1p ) / d;\n    float w = dot( n, v2p ) / d;\n    if( u >= 0.0 && v >= 0.0 && w >= 0.0 )\n    {\n        res.x = length( v0p ) * u + length( v1p ) * v + length( v2p ) * w;\n        res.y = u;\n        res.z = v;\n        res.yz = normalize( v0p * u + v1p * v + v2p * w );\n    }\n    else\n    {\n        vec2 v0p2 = p - a, v1p2 = p - b, v2p2 = p - c;\n        vec2 n2 = cross( v0, v2 );\n        float d2 = dot( n2, v0 );\n        float u2 = dot( n2, v0p2 ) / d2;\n        float v2 = dot( n2, v2p2 ) / d2;\n        float w2 = dot( n2, v1p2 ) / d2;\n        if( u2 >= 0.0 && v2 >= 0.0 && w2 >= 0.0 )\n        {\n            res.x = length( v0p2 ) * u2 + length( v2p2 ) * v2 + length( v1p2 ) * w2;\n            res.y = u2;\n            res.z =", "\n    vec2 q = vec2( dot(sca,p), dot(scb,p) );\n    vec2 w = vec2( ra, rb ) - abs(q);\n    float s = max(w.x,w.y);\n    return vec3(s,sca*(q+sign(w)*vec2(s,s))-p);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r )\n{\n    vec2 q = vec2( dot(sca,p), dot(scb,p) );\n    vec2 w = vec2( ra, rb ) - abs(q);\n    float s = max(w.x,w.y);\n    return vec3(s,sca*(q+sign(w)*vec2(s,s))-p);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float r, in float t )\n{\n    vec2 q = vec2( dot(sca,p), dot(scb,p) );\n    vec2 w = vec2( ra, rb ) - abs(q);\n    float s = max(w.x,w.y);\n    return vec3(s,sca*(q+sign(w)*vec2(s,s))-p);\n}\n\n//.x = f", "(a.x*b.y)-(a.y*b.x);}\nfloat cdot( in vec2 a, in vec2 b ) {(a.x*b.x)+(a.y*b.y);}\nvec2 cnormalize( in vec2 a ) {return a/length(a);}\nvec2 cmult( in vec2 a, in vec2 b ) {return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 cdiv( in vec2 a, in vec2 b ) {return vec2(a.x*b.x+a.y*b.y,a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y);}\nvec2 cadd( in vec2 a, in vec2 b ) {return vec2(a.x+b.x,a.y+b.y);}\nvec2 csub( in vec2 a, in vec2 b ) {return vec2(a.x-b.x,a.y-b.y);}\nvec2 cneg( in vec2 a ) {return vec2(-a.x,-a.y);}\nvec2 cconj( in vec2 a ) {return vec2(a.x,-a.y);}\nvec2 cexp( in vec2 a ) {return vec2(cos(a.y),sin(a.y))*exp(a.x);}\nvec2 clog( in vec2 a ) {return vec2(log(length(a)),atan(a.y,a.x));}\nvec2 csqrt( in vec2 a ) {return cexp(0.5*clog(a));}\nvec2 cpow( in vec2 a, in float b ) {return cexp(b*clog(a));}\nvec2 cpow( in vec2 a, in vec2 b ) {return cexp(b*clog(a));}\nvec2 csin( in vec2 a ) {return cdiv(csub(cexp(csub(a,cneg(a))),ce", " = sdgEllipse( p, ab, vec3( 0.0 ) ); }\nvec3 sdgEllipse( vec2 p, in vec2 ab, in vec3 c )\n{\n    vec2 d = abs( p ) - ab;\n    vec3 dg = vec3( length( max( d, 0.0 ) ), sign( d.x ) * sign( d.y ) );\n    return vec3( length( dg.xy ), dg.z ) + c;\n}", " = sdgSphere( p, rb );\n  vec4 d = sdgSphere( p, ra );\n  d.yzw = normalize( d.yzw );\n  return d;\n}", " = sdgSphere( p, a, r );\n  if( d.x > 0.0 )\n  { = sdgSphere( p, b, r );\n    if( d.x > 0.0 )\n    { = sdgLine( p, a, b );\n      if( d.x > 0.0 )\n      { = sdgSphere( p, a, r );\n        if( d.x > 0.0 )\n        { = sdgSphere( p, b, r );\n          if( d.x > 0.0 )\n          { = sdgSphere( p, (a+b)/2.0, r );\n            if( d.x > 0.0 )\n            { = sdgSphere( p, (a+b)/2.0, r );\n              if( d.x > 0.0 )\n              { = sdgSphere( p, (a+b)/2.0, r );\n                if( d.x > 0.0 )\n                { = sdgSphere( p, (a+b)/2.0, r );\n                  if( d.x > 0.0 )\n                  { = sdgSphere( p, (a+b)/2.0, r );\n                    if( d.x > 0.0 )\n                    { = sdgSphere( p, (a+b)/2.0, r );\n                      if( d.x > 0.0 )\n                      { = sdgSphere( p, (a+b)/2.0, r );\n                        if( d.x > 0.0 )\n                        { = sdgSphere( p, (a+b)/2.0, r );\n                          if( d.x > 0.0 )\n                          { = sdgSphere( p, (a+b)/2.0, r );\n                            if( d.x > 0.0 )\n                            { = sdgSphere( p, (a+b)/2.0, r );\n                              if( d.x >", " to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_4( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_5( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_6( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_7( in vec2 p, float wi, float he, float sk )\n{ to_local(p, wi, he, sk);\n  return sdParallelogram(p, wi, he);\n}\n\n// signed distance to a 2D parallelogram (", " = sdgParallelogram( p, vec2( wi, he ), sk );\n    vec2 q = vec2( p.x, p.y * sk );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c = vec2( 0.0, he );\n    vec2 d = vec2( wi, he );\n    vec2 e = vec2( 0.0, 0.0 );\n    vec2 f = vec2( wi, he );\n    vec2 g = vec2( 0.0, 0.0 );\n    vec2 h = vec2( wi, 0.0 );\n    vec2 i = vec2( 0.0, he );\n    vec2 j = vec2( wi, he );\n    vec2 k = vec2( 0.0, 0.0 );\n    vec2 l = vec2( wi, he );\n    vec2 m = vec2( 0.0, 0.0 );\n    vec2 n = vec2( wi, 0.0 );\n    vec2 o = vec2( 0.0, he );\n    vec2 p = vec2( wi, he );\n    vec2 q = vec2( 0.0, 0.0 );\n    vec2 r = vec2( wi, 0.0 );\n    vec2 s = vec2( 0.0, he );\n    vec2 t = vec2( wi, he );\n    vec2 u = vec2( 0.0, 0.0 );\n    vec2 v = vec2( wi, 0.0 );\n    vec2 w = vec2( 0.0, he );\n    vec2 x = vec2( wi, he );\n    vec2 y = vec2( 0.0, 0.0 );\n    vec2 z = vec2( wi, 0.0 );\n    vec2 a = vec2( 0.0, 0.0 );\n    vec2 b = vec2( wi, 0.0 );\n    vec2 c", "----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p + c;\n\treturn r;\n\t}\nfloat opRep2D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p - c;\n\treturn r;\n\t}\nfloat opRep3D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p * c;\n\treturn r;\n\t}\nfloat opRep4D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p / c;\n\treturn r;\n\t}\nfloat opRep5D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p % c;\n\treturn r;\n\t}\nfloat opRep6D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p ^ c;\n\treturn r;\n\t}\nfloat opRep7D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p & c;\n\treturn r;\n\t}\nfloat opRep8D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p | c;\n\treturn r;\n\t}\nfloat opRep9D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p >> c;\n\treturn r;\n\t}\nfloat opRep10D( float p, float c )\n\t{----------oPeraciones de Repeticion\n\tfloat r;\n\tr = p << c;\n\treturn r;\n\t}", "\n    return a + b * k;\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    return a + b * (1.0 - k);\n}\n\n// IQ's polynominal clamp\nfloat pclamp(float a, float b, float k) {\n    return pmin(pmax(a, 0.0), b, k);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n    float t = pclamp((k - a) / (b - a), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    float t = pclamp((k - a) / (b - a), 0.0, 1.0);\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n    float t = pclamp((k - a) / (b - a), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// IQ's polynominal smootherstep\nfloat psmootherstep(float a, float b, float k) {\n    float t = pclamp((k - a) / (b - a), 0.0, 1.0);\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// IQ's polynominal smoothstep\nfloat psmoothstep(float a, float b, float k) {\n    float t = pclamp((k - a) / (b - a), 0.0, 1.0);\n    return t * t * (3.", "://size must be power of 2\n    vec2 n = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return n;\n}\n\nfloat sdf_box(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdf_box_frame(vec2 p, vec2 size, float thickness) {\n    return sdf_box(p, size - thickness) - thickness;\n}\n\nfloat sdf_box_frame_2(vec2 p, vec2 size, float thickness) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - thickness;\n}\n\nfloat sdf_box_frame_3(vec2 p, vec2 size, float thickness) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - thickness;\n}\n\nfloat sdf_box_frame_4(vec2 p, vec2 size, float thickness) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - thickness;\n}\n\nfloat sdf_box_frame_5(vec2 p, vec2 size, float thickness) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - thickness;\n}\n\nfloat sdf_box_frame_6(vec2 p, vec2 size, float thickness) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) +", "//https://gist.github.com/mjackson/5311256\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c) {//https://gist.github.com/mjackson/5311256\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec4 c) {//https://gist.github.com/mjackson/5311256\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    vec3 oc = ro - s;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 s, float r, out vec3 n) {\n    vec3 oc = ro - s;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    n = oc + (b - h) * rd;\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 s, float r, out vec3 n, out float t) {\n    vec3 oc = ro - s;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    n = oc + (b - h) * rd;\n    t", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0);\n    outNormal = -sign(rd) * step( t1.yzx, t1.xyz ) * step( t1.zxy, t1.xyz );\n    return vec2( tN, tF );\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius, out vec3 outNormal )  {\n    vec3 oc = ro - center;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - radius * radius;\n    float h = b * b - c;\n    if( h < 0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    float tN = -b - h;\n    float tF = -b + h;\n    if( tN < 0.0 ) tN = tF;\n    if( tN < 0.0 ) return vec2(-1.0);\n    outNormal = normalize( ro + tN * rd - center );\n    return vec2( tN, tF );\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec3 outNormal )  {\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3 rd_ = cross( rd, v2v0 );\n", " theta = atan(p.y, p.x);\n    if (theta < 0) theta += 2 * PI;\n    if (theta < PI / 2) {\n        e1 = vec2(d.x, 0);\n        e2 = vec2(0, d.y);\n        e3 = vec2(-d.x, 0);\n        e4 = vec2(0, -d.y);\n    } else if (theta < PI) {\n        e1 = vec2(0, d.y);\n        e2 = vec2(-d.x, 0);\n        e3 = vec2(0, -d.y);\n        e4 = vec2(d.x, 0);\n    } else if (theta < 3 * PI / 2) {\n        e1 = vec2(-d.x, 0);\n        e2 = vec2(0, -d.y);\n        e3 = vec2(d.x, 0);\n        e4 = vec2(0, d.y);\n    } else {\n        e1 = vec2(0, -d.y);\n        e2 = vec2(d.x, 0);\n        e3 = vec2(0, d.y);\n        e4 = vec2(-d.x, 0);\n    }\n}", "ions\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return min(\n        min(\n            linedist(p, a, b),\n            linedist(p, b, c)\n        ),\n        min(\n            linedist(p, c, d),\n            linedist(p, d, a)\n        )\n    );\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h) {\n    return min(\n        min(\n            dist(p, a, b, c, d),\n            dist(p, e, f, g, h)\n        ),\n        min(\n            dist(p, c, d, e, f),\n            dist(p, a, b, g, h)\n        )\n    );\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h, vec2 i, vec2 j, vec2 k, vec2 l) {\n    return min(\n        min(\n            dist(p, a, b, c, d),\n            dist(p, e, f, g, h)\n        ),\n        min(\n            dist(p, c, d, e, f),\n            dist(p, a, b, g, h)\n        )\n    );\n}\n\nfloat dist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f, vec2 g, vec2 h, vec2 i, vec2 j, vec2 k, vec2 l, vec2 m, vec2 n, vec2 o, vec2 p) {\n    return min(\n        min(\n            dist(p, a, b, c, d),\n            dist(", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, out vec2 q )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    q = pa - ba*h;\n    return length( q ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, out vec2 q, out float d )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    q = pa - ba*h;\n    d = length( q ) - w1 - w2;\n    return d;\n}", ":\n    vec2 q = vec2(length(rd.xz) - 1.0, rd.y);\n    float d = length(q) - tor.y;\n    float e = length(q - d*rd.xz);\n    float f = max(tor.x - e, 0.0);\n    return dot(q,rd.xz) - d*d*rd.y - f*f;\n}", ":\n    vec3  q = vec3(length(pos.xz)-tor.x, pos.y, 0.0);\n    return normalize(q);\n}\n\nfloat torusSDF(vec3 pos, vec2 tor) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y-r;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r, float r2) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y-r-r2;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r, float r2, float r3) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y-r-r2-r3;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r, float r2, float r3, float r4) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y-r-r2-r3-r4;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r, float r2, float r3, float r4, float r5) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    return length(q)-tor.y-r-r2-r3-r4-r5;\n}\n\nfloat torusSDF(vec3 pos, vec2 tor, float r, float r2, float r3, float r4, float r5, float r6) {\n    vec2 q = vec2(length(pos.xz)-tor.x, pos.y);\n    ", "\n    float x2 = x * x;\n    return x * (27 + x2) / (27 + 9 * x2);\n}", ":\n    col = pow(col, vec3(0.4545));\n    col = mix(col, vec3(dot(col, vec3(0.2125, 0.7154, 0.0721))), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5), 0.5);\n    col = mix(col, vec3(0.5", ":\n    p = mod(p, size) - 0.5 * size;\n    return p;\n}", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 uv) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvec4 effect(vec4 color, Image texture, vec2 texture_coords, vec2 screen_coords) {\n    vec2 uv = texture_coords * 10.0;\n    float value = fbm(uv);\n    vec4 color = vec4(value, value, value, 1.0);\n    return color;\n}", " between the two points\n    return length(p-c)-r;\n}", "(\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", " between(a,b)? 0.0 : dot(a,b); }\nfloat sdt2dTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a; vec2 pa = p-a;\n    vec2 cb = c-b; vec2 pb = p-b;\n    vec2 ac = a-c; vec2 pc = p-c;\n    vec2 bc = b-c; vec2 qc = p-c;\n    float s = cro(ba,pa);\n    float t = cro(cb,pb);\n    if( s<0.0 && t<0.0 ) return cro(ac,pc)/length(ac);\n    float d = cro(bc,qc);\n    if( s>0.0 && t>0.0 ) return cro(ba,pa)/length(ba);\n    return min( min( length(pa)*sign(s), length(pb)*sign(t) ), d );\n}\n\n// signed distance to a 2D quad\nfloat sdt2dQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    return min( min( sdt2dTriangle( p, a, b, c ), sdt2dTriangle( p, a, c, d ) ), 0.0 );\n}\n\n// signed distance to a 2D polygon\nfloat sdt2dPolygon( in vec2 p, in vec2* pts, in int n )\n{\n    float d = dot( pts[0]-p, pts[0]-p );\n    for( int i=1; i<n; i++ )\n    {\n        d = min( d, dot( pts[i]-p, pts[i]-p ) );\n        d = min( d, sdt2dTriangle( p, pts[i-1], pts[i], pts[(i+1)%n] ) );\n    }\n    return d;\n}\n\n// signed distance to a 2D polygon\nfloat sdt2dPolygon( in vec2 p,", "\n    vec2 d = abs(p)-vec2(s,s);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}", "\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 aces_filmic(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 aces_filmic_s_curve(vec3 x)\n{\n    return aces_filmic(s_curve(x));\n}", "\n    return vec3(\n        -6.0 * x.x * x.x * x.x + 6.0 * x.x * x.x,\n        -6.0 * x.y * x.y * x.y + 6.0 * x.y * x.y,\n        -6.0 * x.z * x.z * x.z + 6.0 * x.z * x.z\n    );\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y)\n{\n    return vec3(\n        -6.0 * x.x * x.x * x.x + 6.0 * x.x * x.x,\n        -6.0 * x.y * x.y * x.y + 6.0 * x.y * x.y,\n        -6.0 * x.z * x.z * x.z + 6.0 * x.z * x.z\n    ) * y;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z)\n{\n    return vec3(\n        -6.0 * x.x * x.x * x.x + 6.0 * x.x * x.x,\n        -6.0 * x.y * x.y * x.y + 6.0 * x.y * x.y,\n        -6.0 * x.z * x.z * x.z + 6.0 * x.z * x.z\n    ) * y * z;\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, vec3 y, vec3 z, vec3 w)\n{\n    return vec3(\n        -6.0 * x.x * x.x * x.x + 6.0 * x.x * x.x,\n        -6.0 * x.y * x.y * x.y + 6.0 * x.y * x.y,\n        -6.0 * x.z * x.z * x.z + 6.0 * x.", "\n    float a = atan(p.y,p.x)/6.28318;\n    float b = mod(a,1.0);\n    float c = abs(b-0.5)*2.0;\n    float d = sin(k*6.28318*c);\n    return length(p)-w*d;\n}", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance)\n{\n    return transmittance * exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float transmittance)\n{\n    return transmittance * exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 extinction)\n{\n    return transmittance * exp(-opticalDepth * extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float transmittance, float extinction)\n{\n    return transmittance * exp(-opticalDepth * extinction);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 extinction, vec3 scattering)\n{\n    return transmittance * exp(-opticalDepth * (extinction + scattering));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float transmittance, float extinction, float scattering)\n{\n    return transmittance * exp(-opticalDepth * (extinction + scattering));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 transmittance, vec3 extinction, vec3 scattering, vec3 absorption)\n{\n    return transmittance * exp(-opticalDepth * (extinction + scattering + absorption));\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float transmittance, float extinction, float scattering, float absorption)\n{\n    return transmittance", "\n    // Calculate the transmittance for the ray.\n    vec3 transmittanceAtStart = exp(-rayLength * lightColor * (1.0 / 0.01));\n    transmittance = transmittanceAtStart;\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = vec3(0.0);\n    float opticalDepth = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        // Calculate the position of the current sample.\n        vec3 samplePos = rayStart + rayDir * (float(i) / 100.0) * rayLength;\n\n        // Calculate the optical depth for the current sample.\n        float sampleOpticalDepth = length(samplePos - rayStart) * lightColor * (1.0 / 0.01);\n\n        // Add the optical depth to the total optical depth.\n        opticalDepth += sampleOpticalDepth;\n\n        // Calculate the transmittance for the current sample.\n        vec3 sampleTransmittance = exp(-sampleOpticalDepth);\n\n        // Add the transmittance to the total transmittance.\n        transmittance *= sampleTransmittance;\n\n        // Calculate the scattering for the current sample.\n        vec3 sampleScattering = vec3(0.0);\n        for (int j = 0; j < 100; j++)\n        {\n            // Calculate the position of the current scattering sample.\n            vec3 scatteringSamplePos = samplePos + lightDir * (float(j) / 100.0) * rayLength;\n\n            // Calculate the scattering for the current scattering sample.\n            vec3 scatteringSample = vec3(0.0);\n            for (int k = 0; k < 100; k++)\n            {\n                // Calculate the position of the current scattering sample.\n                vec3 scatteringSamplePos = scatteringSamplePos + lightDir * (float(k) / 100.0) * rayLength;\n\n                // Calculate the scattering for the current scattering sample.\n                scatteringSample += vec3(0.0);\n            }\n\n            // Add the scattering for the current scattering sample to the total scattering.\n            sampleScattering", " ========================================================================\n    // p2 = position of the small sphere\n    // ra = radius of the big sphere\n    // rb = radius of the small sphere\n    // d  = distance between the two spheres\n    //\n    // returns the distance to the death star\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving\n    // the big sphere is the one that is static\n    //\n    // the death star is a sphere with a small sphere inside it\n    // the small sphere is the one that is moving", "\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y)-h) - t;\n}", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", "\n    float d = length(p.xz) - r;\n    return max(d, p.y-h);\n}", "\n    const float eps = 0.0005;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(\n              sdf(pos+h.xyy).x - sdf(pos-h.xyy).x,\n              sdf(pos+h.yxy).x - sdf(pos-h.yxy).x,\n              sdf(pos+h.yyx).x - sdf(pos-h.yyx).x ) );\n}", "=\n    float d = length(p.x) - r;\n    return max(d, p.y-h);\n}", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// 3d fractal noise function\nfloat fbm( in vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3d fractal noise function\nfloat fbm2( in vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3d fractal noise function\nfloat fbm3( in vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3d fractal noise function\nfloat fbm4( in vec3 p )\n{", "(\n    // Initial values\n    float f = 0.0;\n    float w = 0.5;\n    float wmax = 0.0;\n    float fmax = 0.0;\n\n    //\n    // Loop of octaves\n    //\n    for( int i=0; i<4; i++ )\n    {\n        f += w * noise( p );\n\n        w *= 0.5;\n        p *= 2.0;\n        wmax += w;\n        fmax += w * noise( p );\n    }\n\n    return f / wmax;\n}", "\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(mix(hash31(i + vec3(0, 0, 0)), hash31(i + vec3(1, 0, 0)), f.x),\n                   mix(hash31(i + vec3(0, 1, 0)), hash31(i + vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash31(i + vec3(0, 0, 1)), hash31(i + vec3(1, 0, 1)), f.x),\n                   mix(hash31(i + vec3(0, 1, 1)), hash31(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n}\n\n//value noise with frequency\nfloat noise(vec3 p, float frequency)\n{\n    return noise(p * frequency);\n}\n\n//value noise with frequency and amplitude\nfloat noise(vec3 p, float frequency, float amplitude)\n{\n    return noise(p * frequency) * amplitude;\n}\n\n//value noise with frequency, amplitude and lacunarity\nfloat noise(vec3 p, float frequency, float amplitude, float lacunarity)\n{\n    return noise(p * frequency, amplitude) * lacunarity;\n}\n\n//value noise with frequency, amplitude, lacunarity and persistence\nfloat noise(vec3 p, float frequency, float amplitude, float lacunarity, float persistence)\n{\n    return noise(p * frequency, amplitude, lacunarity) * persistence;\n}\n\n//value noise with frequency, amplitude, lacunarity, persistence and octaves\nfloat noise(vec3 p, float frequency, float amplitude, float lacunarity, float persistence", " \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "// Converts an HSV color value to RGB.\n    // Adapted from: https://stackoverflow.com/a/17897228/418488\n    // Assumes h, s, and v are contained in the set [0, 1] and\n    // returns r, g, and b in the set [0, 1].\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {// Converts an RGB color value to HSV.\n    // Adapted from: https://stackoverflow.com/a/17897228/418488\n    // Assumes r, g, and b are contained in the set [0, 1] and\n    // returns h, s, and v in the set [0, 1].\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 rg", ":\n    float res = floor(p/size);\n    p = mod(p,size);\n    return res;\n}\n\nfloat mod2(inout vec2 p, vec2 size) {:\n    vec2 res = floor(p/size);\n    p = mod(p,size);\n    return res.x + res.y*1e3;\n}\n\nfloat mod3(inout vec3 p, vec3 size) {:\n    vec3 res = floor(p/size);\n    p = mod(p,size);\n    return res.x + res.y*1e3 + res.z*1e6;\n}\n\nfloat mod4(inout vec4 p, vec4 size) {:\n    vec4 res = floor(p/size);\n    p = mod(p,size);\n    return res.x + res.y*1e3 + res.z*1e6 + res.w*1e9;\n}", "\n    return fract(sin(co * 12.9898) * 43758.5453);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat fbm(float x) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = 100.0;\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float v = fbm(uv.x * 10.0);\n    vec3 col = vec3(v);\n    fragColor = vec4(col,1.0);\n}", ":\n    return t <= 0.0031308? 12.92 * t : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\n\nvec3 sRGB(vec3 t) {:\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\nvec4 sRGB(vec4 t) {:\n    return vec4(sRGB(t.rgb), t.a);\n}\n\nvec3 sRGB(vec3 t, float gamma) {:\n    return vec3(pow(t.r, 1.0 / gamma), pow(t.g, 1.0 / gamma), pow(t.b, 1.0 / gamma));\n}\n\nvec4 sRGB(vec4 t, float gamma) {:\n    return vec4(pow(t.rgb, 1.0 / gamma), t.a);\n}\n\nvec3 sRGB(vec3 t, float gamma, float exposure) {:\n    return vec3(pow(t.r, 1.0 / gamma) * exposure, pow(t.g, 1.0 / gamma) * exposure, pow(t.b, 1.0 / gamma) * exposure);\n}\n\nvec4 sRGB(vec4 t, float gamma, float exposure) {:\n    return vec4(pow(t.rgb, 1.0 / gamma) * exposure, t.a);\n}\n\nvec3 sRGB(vec3 t, float gamma, float exposure, float contrast) {:\n    return vec3(pow(t.r, 1.0 / gamma) * exposure * contrast, pow(t.g, 1.0 / gamma) * exposure * contrast, pow(t.b, 1.0 / gamma) * exposure * contrast);\n}\n\nvec4 sRGB(vec4 t, float gamma, float exposure, float contrast) {:\n    return vec4(pow(t.rgb, 1.0 / gamma) * exposure * contrast, t.a);\n}\n\nvec3 sRGB(vec3 t, float gamma, float exposure, float contrast, float saturation) {:", ":\n    return pow(c, vec3(2.2));\n}\n\nvec3 RGB(in vec3 c) {:\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec3 hsv2rgb(in vec3 c) {:\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(in vec3 c) {:\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 rgb2hsl(in vec3 c) {:\n    vec3 hsv = rgb2hsv(c);\n    return vec3(hsv.x, (hsv.y + hsv.z) / 2.0, hsv.y * hsv.z);\n}\n\nvec3 hsl2rgb(in vec3 c) {:\n    vec3 hsv = vec3(c.x, (2.0 * c.z - c.y) / (c.y - c.z), c.", ":\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", ":\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = (-b - h + dbuffer);\n    float y = (abs(t) < 1000.0)? dot(rd, oc + t * rd) : -1.0;\n    if (y < 0.0 || y > sph.w) t = -1.0;\n    return t;\n}", "\n    vec4 q = p;\n    q.xyz = abs(q.xyz);\n    q.xyz = q.xyz - 1.0;\n    q.xyz = q.xyz * q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.xyz * q.xyz;\n    q.xyz = q.", "\n    vec3 q = abs(p)/r-1.0;\n    return vec4(length(max(q,0.0)), dot(q,vec3(1.0)), 0.0, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4(length(p)-r, p.x, p.y, p.z);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec4(length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0), 0.0, 0.0, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec4(length(max(d,0.0)) + min(max(d.x,d.y),0.0), 0.0, 0.0, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(", "\n    return front + back * (1.0 - front.a);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return front + back * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n    return front + back * (1.0 - alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2) {\n    return front + back * (1.0 - alpha * alpha2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2) {\n    return front + back * (1.0 - alpha * alpha2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, vec4 alpha2) {\n    return front + back * (1.0 - alpha * alpha2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, float alpha2) {\n    return front + back * (1.0 - alpha * alpha2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, float alpha3) {\n    return front + back * (1.0 - alpha * alpha2 * alpha3);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3) {\n    return front + back * (1.0 - alpha * alpha2 * alpha3);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, float alpha3, float alpha4) {\n    return front + back * (1.0 - alpha * alpha2 * alpha3 * alpha4);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3, vec4 alpha4) {\n    return front + back * (1.0 - alpha * alpha2 * alpha3 * alpha4);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, float alpha3, float alpha", "\n    return (front.a == 0.0)? back : (front.rgb * front.a + back * back * (1.0 - front.a));\n}\n\nvec4 texture2D(sampler2D sampler, vec2 coord) {\n    return texture(sampler, coord);\n}\n\nvec4 texture2D(sampler2D sampler, vec2 coord, float bias) {\n    return texture(sampler, coord, bias);\n}\n\nvec4 texture2DProj(sampler2D sampler, vec3 coord) {\n    return textureProj(sampler, coord);\n}\n\nvec4 texture2DProj(sampler2D sampler, vec4 coord) {\n    return textureProj(sampler, coord);\n}\n\nvec4 texture2DProj(sampler2D sampler, vec3 coord, float bias) {\n    return textureProj(sampler, coord, bias);\n}\n\nvec4 texture2DProj(sampler2D sampler, vec4 coord, float bias) {\n    return textureProj(sampler, coord, bias);\n}\n\nvec4 texture2DLod(sampler2D sampler, vec2 coord, float lod) {\n    return textureLod(sampler, coord, lod);\n}\n\nvec4 texture2DLod(sampler2D sampler, vec2 coord) {\n    return textureLod(sampler, coord, 0.0);\n}\n\nvec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod) {\n    return textureProjLod(sampler, coord, lod);\n}\n\nvec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod) {\n    return textureProjLod(sampler, coord, lod);\n}\n\nvec4 texture2DProjLod(sampler2D sampler, vec3 coord) {\n    return textureProjLod(sampler, coord, 0.0);\n}\n\nvec4 texture2DProjLod(sampler2D sampler, vec4 coord)", ":\n    p = abs(p);\n    float s = 0.8660254 * r;\n    float d = length(p - vec2(0.5*r,s)) * 1.1547005;\n    d = min(d, length(p - vec2(0.5*r,-s)) * 1.1547005);\n    d = min(d, length(p - vec2(r,0.0)) * 0.70710678);\n    return d - r;\n}", ":\n    vec3 a = v * (2.51 * v + 0.03);\n    return clamp(a / (v * (2.43 * v + 0.59) + 0.14), 0.0, 1.0);\n}", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm2(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise2(p); p = p * 2.02;\n    f += 0.2500 * noise2(p); p = p * 2.03;\n    f += 0.1250 * noise2(p); p = p * 2.01;\n    f += 0.0625 * noise2(p);\n    return f / 0.9375;\n}\n\nfloat fbm2_2(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise2(p); p = p * 2.02;\n    f += 0.2500 * noise2(p); p = p * 2.03;\n    f += 0.1250 * noise2(p); p = p * 2.01;\n    f += 0.0625 * noise2(p", "\n    Temp = clamp(Temp, 0.0, 1.0);\n    vec3 bb = vec3(0.0);\n    bb.r = 3.92 * pow(Temp, 4.0) +.002 * pow(Temp, 5.0);\n    bb.g = 3.92 * pow(Temp, 3.0) +.000 * pow(Temp, 4.0);\n    bb.b = 3.92 * pow(Temp, 2.0) +.000 * pow(Temp, 3.0);\n    return bb;\n}\n\nvec3 blackbody(float Temp, float Intensity) {\n    return blackbody(Temp) * Intensity;\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation) {\n    vec3 bb = blackbody(Temp, Intensity);\n    return mix(bb, vec3(0.5), Saturation);\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation, float Brightness) {\n    vec3 bb = blackbody(Temp, Intensity, Saturation);\n    return mix(bb, vec3(1.0), Brightness);\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation, float Brightness, float Gamma) {\n    vec3 bb = blackbody(Temp, Intensity, Saturation, Brightness);\n    return pow(bb, vec3(1.0 / Gamma));\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation, float Brightness, float Gamma, float Offset) {\n    vec3 bb = blackbody(Temp, Intensity, Saturation, Brightness, Gamma);\n    return bb + Offset;\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation, float Brightness, float Gamma, float Offset, float TempOffset) {\n    vec3 bb = blackbody(Temp + TempOffset, Intensity, Saturation, Brightness, Gamma, Offset);\n    return bb;\n}\n\nvec3 blackbody(float Temp, float Intensity, float Saturation, float Brightness,", ":\n    return texture(iChannel0, p * 0.01).r;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = p*2.02;\n    f += 0.2500 * noise( p ); p = p*2.03;\n    f += 0.1250 * noise( p ); p = p*2.01;\n    f += 0.0625 * noise( p );\n    return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    float f = fbm( p + fbm( p + fbm( p ) ) );\n\n    fragColor = vec4(vec3(f),1.0);\n}", ":\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}", " = vec3(0.0);\n    float r = length(p);\n    float d = r - 1.0;\n    float s = sign(d);\n    float a = atan(p.y, p.x);\n    float b = pow(abs(d), n);\n    float c = pow(b + 1.0, 1.0 / n);\n    float f = c - 1.0;\n    float g = pow(abs(f), 1.0 / n);\n    float h = pow(g + 1.0, 1.0 / n);\n    float i = pow(h + 1.0, 1.0 / n);\n    float j = pow(i + 1.0, 1.0 / n);\n    float k = pow(j + 1.0, 1.0 / n);\n    float l = pow(k + 1.0, 1.0 / n);\n    float m = pow(l + 1.0, 1.0 / n);\n    float o = pow(m + 1.0, 1.0 / n);\n    float p = pow(o + 1.0, 1.0 / n);\n    float q = pow(p + 1.0, 1.0 / n);\n    float r = pow(q + 1.0, 1.0 / n);\n    float s = pow(r + 1.0, 1.0 / n);\n    float t = pow(s + 1.0, 1.0 / n);\n    float u = pow(t + 1.0, 1.0 / n);\n    float v = pow(u + 1.0, 1.0 / n);\n    float w = pow(v + 1.0, 1.0 / n);\n    float x = pow(w + 1.0, 1.0 / n);\n    float y = pow(x + 1.0, 1.0 / n);\n    float z = pow(y + 1.0, 1.0 / n);\n    float aa = pow(z + 1.0, ", "\n    return 0.5f * ( x + t );\n}\n\nfloat cantor( float x, float y, float t )\n{\n    return 0.5f * ( x + y + t );\n}\n\nfloat cantor( float x, float y, float z, float t )\n{\n    return 0.5f * ( x + y + z + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float t )\n{\n    return 0.5f * ( x + y + z + w + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float t )\n{\n    return 0.5f * ( x + y + z + w + u + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float v, float t )\n{\n    return 0.5f * ( x + y + z + w + u + v + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float v, float a, float t )\n{\n    return 0.5f * ( x + y + z + w + u + v + a + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float v, float a, float b, float t )\n{\n    return 0.5f * ( x + y + z + w + u + v + a + b + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float v, float a, float b, float c, float t )\n{\n    return 0.5f * ( x + y + z + w + u + v + a + b + c + t );\n}\n\nfloat cantor( float x, float y, float z, float w, float u, float v, float a, float b, float c, float d, float t )\n{\n    return 0.5f * ( x + y + z + w + u + v + a + b + c + d + t );\n}\n\nfloat cantor( float x, float y", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a, pa = p-a;\n    vec2 cb = c-b, pb = p-b;\n    vec2 ac = a-c, pc = p-c;\n    vec2 ab_pc = cross(ba,pc);\n    vec2 bc_pa = cross(cb,pa);\n    vec2 ca_pb =", "\n    float d = 1e10;\n    for (int i = 0; i < 3; i++) {\n        float t = i == idx? 1.0 : 0.0;\n        d = min(d, length(p - vec3(t, 0.0, 0.0)) - 0.5);\n        d = min(d, length(p - vec3(0.0, t, 0.0)) - 0.5);\n        d = min(d, length(p - vec3(0.0, 0.0, t)) - 0.5);\n    }\n    return d;\n}\n\n// main raymarch func\nfloat raymarch(in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * d;\n        float m = map(p, 0);\n        if (m < 0.001) {\n            return d;\n        }\n        d += m;\n    }\n    return -1.0;\n}\n\n// main shader func\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 q = -1.0 + 2.0 * uv;\n    q.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(q.x * uu + q.y * vv + 1.5 * ww);\n\n    float d = raymarch(ro, rd);\n\n    vec3 col = vec", ":\n    return (x > 0.0)? atan(y / x) : ((y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.1415926535897932384626433832795 / 2.0);\n}\n\nfloat atan2_approx(float y, float x) {\n    return (x > 0.0)? atan(y / x) : ((y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.1415926535897932384626433832795 / 2.0);\n}\n\nfloat atan2_approx(vec2 v) {\n    return (v.x > 0.0)? atan(v.y / v.x) : ((v.y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.1415926535897932384626433832795 / 2.0);\n}\n\nfloat atan2_approx(vec3 v) {\n    return (v.x > 0.0)? atan(v.y / v.x) : ((v.y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.1415926535897932384626433832795 / 2.0);\n}\n\nfloat atan2_approx(vec4 v) {\n    return (v.x > 0.0)? atan(v.y / v.x) : ((v.y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.1415926535897932384626433832795 / 2.0);\n}\n\nfloat atan2_approx(float y, float x, float epsilon) {\n    return (x > 0.0)? atan(y / x) : ((y > 0.0)? 3.1415926535897932384626433832795 / 2.0 : -3.141592653589793238462", "(z.x * w.x) - (z.y * w.y), (z.x * w.y) + (z.y * w.x)}\nvec2 cdiv(vec2 z, vec2 w) {(z.x * w.x) + (z.y * w.y), (z.y * w.x) - (z.x * w.y)}\nvec2 csqrt(vec2 z) {\n    float m = length(z);\n    float a = atan(z.y, z.x);\n    return vec2(sqrt(m) * cos(a / 2.0), sqrt(m) * sin(a / 2.0));\n}\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\nvec2 catanh(vec2 z) {\n    return cdiv(log((z + 1.0) / (1.0 - z)), 2.0);\n}\nvec2 catan(vec2 z) {\n    return cdiv(log((1.0 + z) / (1.0 - z)), 2.0);\n}\nvec2 ctanh(vec2 z) {\n    return cdiv((exp(z) - exp(-z)) / (exp(z) + exp(-z)), 2.0);\n}\nvec2 csinh(vec2 z) {\n    return cdiv((exp(z) - exp(-z)) / 2.0, 1.0);\n}\nvec2 ccosh(vec2 z) {\n    return cdiv((exp(z) + exp(-z)) / 2.0, 1.0);\n}\nvec2 ctanh(vec2 z) {\n    return cdiv", "\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Hyperbolic tangent\nvec2 ctanh(vec2 z) {\n    return 0.5 * log((1.0 + z) / (1.0 - z));\n}\n\n// Hyperbolic sine\nvec2 csinh(vec2 z) {\n    return 0.5 * (exp(z) - exp(-z));\n}\n\n// Hyperbolic cosine\nvec2 ccosh(vec2 z) {\n    return 0.5 * (exp(z) + exp(-z));\n}\n\n// Hyperbolic tangent\nvec2 ctanh(vec2 z) {\n    return 0.5 * (exp(z) - exp(-z)) / (exp(z) + exp(-z));\n}\n\n// Hyperbolic cotangent\nvec2 cctanh(vec2 z) {\n    return 0.5 * (exp(z) + exp(-z)) / (exp(z) - exp(-z));\n}\n\n// Hyperbolic secant\nvec2 csech(vec2 z) {\n    return 1.0 / ccosh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1.0 / csinh(z);\n}\n\n// Hyperbolic cosecant\nvec2 ccosech(vec2 z) {\n    return 1", "own\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec2 ctanh(vec2 z) {\n    return (exp(z) - exp(-z)) / (exp(z) + exp(-z));\n}\n\n// The built-in function\nvec2 ctanh(vec2 z) {\n    return tanh(z);\n}", "(z.x * w.x) - (z.y * w.y), (z.x * w.y) + (z.y * w.x)}\nvec2 cdiv(vec2 z, vec2 w) {(z.x * w.x) + (z.y * w.y), (z.y * w.x) - (z.x * w.y)}\nvec2 csqrt(vec2 z) {\n    float m = length(z);\n    float a = atan(z.y, z.x);\n    return vec2(sqrt(m) * cos(a / 2.0), sqrt(m) * sin(a / 2.0));\n}\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\nvec2 ctanh(vec2 z) {\n    return cdiv(csinh(z), ccosh(z));\n}\nvec2 catanh(vec2 z) {\n    return cdiv(vec2(0.0, 1.0), z) - cdiv(vec2(0.0, 1.0), cmul(z, z) + vec2(1.0, 0.0));\n}\nvec2 catan(vec2 z) {\n    return cdiv(vec2(0.0, 1.0), z) - cdiv(vec2(0.0, 1.0), cmul(z, z) - vec2(1.0, 0.0));\n}\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\nvec2 ccos", "\n    return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n}\n\nvec2 ctanh(vec2 z) {\n    return (exp(z) - exp(-z)) / (exp(z) + exp(-z));\n}\n\n// The original\nvec2 ctanh(vec2 z) {\n    return (exp(z) - exp(-z)) / (exp(z) + exp(-z));\n}", "\n    float alphaSum = alpha.r + alpha.g + alpha.b;\n    alpha = alpha / alphaSum;\n    alpha = pow(alpha, vec4(contrast));\n    alpha = alpha * alphaSum;\n    return alpha;\n}", "\n    vec3 q = abs(p);\n    return max(q.x + q.y, max(q.x, q.y) + q.z) - 1.0;\n}", "\n    tilingVal3D tval;\n    tval.val = 0.0;\n    tval.type = 0;\n    \n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw * 3.0;\n    vec3 uvw4 = uvw * 4.0;\n    vec3 uvw5 = uvw * 5.0;\n    vec3 uvw6 = uvw * 6.0;\n    vec3 uvw7 = uvw * 7.0;\n    vec3 uvw8 = uvw * 8.0;\n    vec3 uvw9 = uvw * 9.0;\n    vec3 uvw10 = uvw * 10.0;\n    vec3 uvw11 = uvw * 11.0;\n    vec3 uvw12 = uvw * 12.0;\n    vec3 uvw13 = uvw * 13.0;\n    vec3 uvw14 = uvw * 14.0;\n    vec3 uvw15 = uvw * 15.0;\n    vec3 uvw16 = uvw * 16.0;\n    vec3 uvw17 = uvw * 17.0;\n    vec3 uvw18 = uvw * 18.0;\n    vec3 uvw19 = uvw * 19.0;\n    vec3 uvw20 = uvw * 20.0;\n    vec3 uvw21 = uvw * 21.0;\n    vec3 uvw22 = uvw * 22.0;\n    vec3 uvw23 = uvw * 23.0;\n    vec3 uvw24 = uvw * 24.0;\n    vec3 uvw25 = uvw * 25.0;\n    vec3 uvw26 = uvw * 26.0;\n    vec3 uvw27 = uvw * 27.0;\n    vec3 uvw28 = u", " =\n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw * 3.0;\n    vec3 uvw4 = uvw * 4.0;\n    vec3 uvw5 = uvw * 5.0;\n    vec3 uvw6 = uvw * 6.0;\n    vec3 uvw7 = uvw * 7.0;\n    vec3 uvw8 = uvw * 8.0;\n    vec3 uvw9 = uvw * 9.0;\n    vec3 uvw10 = uvw * 10.0;\n    vec3 uvw11 = uvw * 11.0;\n    vec3 uvw12 = uvw * 12.0;\n    vec3 uvw13 = uvw * 13.0;\n    vec3 uvw14 = uvw * 14.0;\n    vec3 uvw15 = uvw * 15.0;\n    vec3 uvw16 = uvw * 16.0;\n    vec3 uvw17 = uvw * 17.0;\n    vec3 uvw18 = uvw * 18.0;\n    vec3 uvw19 = uvw * 19.0;\n    vec3 uvw20 = uvw * 20.0;\n    vec3 uvw21 = uvw * 21.0;\n    vec3 uvw22 = uvw * 22.0;\n    vec3 uvw23 = uvw * 23.0;\n    vec3 uvw24 = uvw * 24.0;\n    vec3 uvw25 = uvw * 25.0;\n    vec3 uvw26 = uvw * 26.0;\n    vec3 uvw27 = uvw * 27.0;\n    vec3 uvw28 = uvw * 28.0;\n    vec3 uvw29 = uvw * 29.0;\n    vec3 uvw", "\n    vec3 uvw2 = uvw * gridRes;\n    vec3 uvw3 = uvw2 * uvw2;\n    vec3 uvw4 = uvw3 * uvw2;\n    vec3 uvw5 = uvw4 * uvw2;\n    vec3 uvw6 = uvw5 * uvw2;\n    vec3 uvw7 = uvw6 * uvw2;\n    vec3 uvw8 = uvw7 * uvw2;\n    vec3 uvw9 = uvw8 * uvw2;\n    vec3 uvw10 = uvw9 * uvw2;\n    vec3 uvw11 = uvw10 * uvw2;\n    vec3 uvw12 = uvw11 * uvw2;\n    vec3 uvw13 = uvw12 * uvw2;\n    vec3 uvw14 = uvw13 * uvw2;\n    vec3 uvw15 = uvw14 * uvw2;\n    vec3 uvw16 = uvw15 * uvw2;\n    vec3 uvw17 = uvw16 * uvw2;\n    vec3 uvw18 = uvw17 * uvw2;\n    vec3 uvw19 = uvw18 * uvw2;\n    vec3 uvw20 = uvw19 * uvw2;\n    vec3 uvw21 = uvw20 * uvw2;\n    vec3 uvw22 = uvw21 * uvw2;\n    vec3 uvw23 = uvw22 * uvw2;\n    vec3 uvw24 = uvw23 * uvw2;\n    vec3 uvw25 = uvw24 * uvw2;\n    vec3 uvw26 = uvw25 * uvw2;\n    vec3 uvw27 = uvw26 * uvw2;\n    vec3 uvw28 = uvw27 * uvw2;\n    ", "hedron\n    p = abs(p);\n    return (p.x + p.y + p.z - 1.0) * sqrt(3.0);\n}", "ormat3 cool = mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    cool[0][0] = 0.0;\n    cool[0][1] = 0.0;\n    cool[0][2] = 0.0;\n    cool[1][0] = 0.0;\n    cool[1][1] = 0.0;\n    cool[1][2] = 0.0;\n    cool[2][0] = 0.0;\n    cool[2][1] = 0.0;\n    cool[2][2] = 0.0;\n    return cool * vec3(t);\n}", " a = normalize(a);\n  return v * cos(a.z) + cross(a, v) * sin(a.z) + a * dot(a, v) * (1.0 - cos(a.z));\n}", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x), mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 co) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.0;\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * noise(co);\n        co *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += fbm(uv * 3.0 + iTime * 0.1) * vec3(1.0, 0.5, 0.2);\n    color += fbm(uv * 5.0 + iTime * 0.2) * vec3(0.2, 0.5, 1.0);\n    color += fbm(uv * 7.0 + iTime * 0.3) * vec3(1.0, 0.2, 0.5);\n    fragColor = vec4(color, 1.0);\n}", "agonal distance from the 0,0 coords\nfloat q = abs(p.x) + abs(p.y);\nreturn max(q - 1.0, (p.x * p.x + p.y * p.y).sqrt() - 0.5);\n}", " https://www.shadertoy.com/view/3sSGWt\n    hexParams hp;\n    vec2 p = uv * 2.0 - 1.0;\n    vec2 q = p;\n    float r = sqrt(dot(q, q));\n    float a = atan(q.y, q.x);\n    if (r > 1.0) {\n        p = vec2(cos(a), sin(a));\n        q = p;\n        r = sqrt(dot(q, q));\n    }\n    hp.r = r;\n    hp.a = a;\n    hp.p = p;\n    hp.q = q;\n    return hp;\n}", "idis\n    vec3 a = vec3(0.129, 0.278, 0.537);\n    vec3 b = vec3(0.000, 0.125, 0.541);\n    vec3 c = vec3(0.000, 0.125, 0.541);\n    vec3 d = vec3(0.000, 0.125, 0.541);\n    vec3 e = vec3(0.000, 0.125, 0.541);\n    vec3 f = vec3(0.000, 0.125, 0.541);\n    vec3 g = vec3(0.000, 0.125, 0.541);\n    vec3 h = vec3(0.000, 0.125, 0.541);\n    vec3 i = vec3(0.000, 0.125, 0.541);\n    vec3 j = vec3(0.000, 0.125, 0.541);\n    vec3 k = vec3(0.000, 0.125, 0.541);\n    vec3 l = vec3(0.000, 0.125, 0.541);\n    vec3 m = vec3(0.000, 0.125, 0.541);\n    vec3 n = vec3(0.000, 0.125, 0.541);\n    vec3 o = vec3(0.000, 0.125, 0.541);\n    vec3 p = vec3(0.000, 0.125, 0.541);\n    vec3 q = vec3(0.000, 0.125, 0.541);\n    vec3 r = vec3(0.000, 0.125, 0.541);\n    vec3 s = vec3(0.000, 0.125, 0.541);\n    vec3 t = vec3(0.000, 0.125, 0.541);\n    vec3 u = vec3(0.000, 0.125, 0.541);\n    vec3 v = vec3(0.000, 0.125, 0.541);\n    vec3 w", " the value to be shifted\n\treturn (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be shifted\n\treturn x * 2 - 1;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeMinus1to1(float x) { the value to be", "ated\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float xOffset = offset.x * gridRes;\n    float yOffset = offset.y * gridRes;\n    float xPos = x + xOffset;\n    float yPos = y + yOffset;\n    float xPosMod = mod(xPos, len);\n    float yPosMod = mod(yPos, len);\n    float xPosMod2 = mod(xPos + len / 2.0, len);\n    float yPosMod2 = mod(yPos + len / 2.0, len);\n    float xPosMod3 = mod(xPos + len / 4.0, len);\n    float yPosMod3 = mod(yPos + len / 4.0, len);\n    float xPosMod4 = mod(xPos + len / 8.0, len);\n    float yPosMod4 = mod(yPos + len / 8.0, len);\n    float xPosMod5 = mod(xPos + len / 16.0, len);\n    float yPosMod5 = mod(yPos + len / 16.0, len);\n    float xPosMod6 = mod(xPos + len / 32.0, len);\n    float yPosMod6 = mod(yPos + len / 32.0, len);\n    float xPosMod7 = mod(xPos + len / 64.0, len);\n    float yPosMod7 = mod(yPos + len / 64.0, len);\n    float xPosMod8 = mod(xPos + len / 128.0, len);\n    float yPosMod8 = mod(yPos + len / 128.0, len);\n    float xPosMod9 = mod(xPos + len / 256.0, len);\n    float yPosMod9 = mod(yPos + len / 256.0, len);\n    float xPosMod10 = mod(xPos + len / 512.0, len);\n    float yPosMod10 = mod(yPos + len / 512.0, len);\n    float xPosMod11 = mod(xPos +", "\n    float gridSize = 1.0 / gridRes;\n    float gridSizeHalf = gridSize * 0.5;\n    float gridSizeHalf2 = gridSizeHalf * 2.0;\n    float gridSizeHalf3 = gridSizeHalf * 3.0;\n    float gridSizeHalf4 = gridSizeHalf * 4.0;\n    float gridSizeHalf5 = gridSizeHalf * 5.0;\n    float gridSizeHalf6 = gridSizeHalf * 6.0;\n    float gridSizeHalf7 = gridSizeHalf * 7.0;\n    float gridSizeHalf8 = gridSizeHalf * 8.0;\n    float gridSizeHalf9 = gridSizeHalf * 9.0;\n    float gridSizeHalf10 = gridSizeHalf * 10.0;\n    float gridSizeHalf11 = gridSizeHalf * 11.0;\n    float gridSizeHalf12 = gridSizeHalf * 12.0;\n    float gridSizeHalf13 = gridSizeHalf * 13.0;\n    float gridSizeHalf14 = gridSizeHalf * 14.0;\n    float gridSizeHalf15 = gridSizeHalf * 15.0;\n    float gridSizeHalf16 = gridSizeHalf * 16.0;\n    float gridSizeHalf17 = gridSizeHalf * 17.0;\n    float gridSizeHalf18 = gridSizeHalf * 18.0;\n    float gridSizeHalf19 = gridSizeHalf * 19.0;\n    float gridSizeHalf20 = gridSizeHalf * 20.0;\n    float gridSizeHalf21 = gridSizeHalf * 21.0;\n    float gridSizeHalf22 = gridSizeHalf * 22.0;\n    float gridSizeHalf23 = gridSizeHalf * 23.0;\n    float gridSizeHalf24 = gridSizeHalf * 24.0;\n    float gridSizeHalf25 = gridSizeHalf * 25.0;\n    float gridSizeHalf26 = gridSizeHalf * 26.0;\n    float gridSizeHalf", " ofVec2f flow;\n    float dist = length(point);\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float speed = 0.01 * (radius - dist);\n        flow.x = speed * cos(angle + time);\n        flow.y = speed * sin(angle + time);\n    }\n    return flow;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    float dist = length(point);\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float speed = 0.01 * (radius - dist);\n        return vec2(speed * cos(angle + time), speed * sin(angle + time));\n    }\n    return vec2(0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    float dist = length(point);\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float speed = 0.01 * (radius - dist);\n        return vec2(speed * cos(angle + time), speed * sin(angle + time));\n    }\n    return vec2(0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    float dist = length(point);\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float speed = 0.01 * (radius - dist);\n        return vec2(speed * cos(angle + time), speed * sin(angle + time));\n    }\n    return vec2(0.0);\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {\n    float dist = length(point);\n    if (dist < radius) {\n        float angle = atan(point.y, point.x);\n        float speed = 0", " theta = atan(pos.y, pos.x);\n    return vec2(cos(theta), sin(theta)) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, float theta) {\n    return vec2(cos(theta), sin(theta)) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir) {\n    return vec2(dot(dir, vec2(1.0, 0.0)), dot(dir, vec2(0.0, 1.0))) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, float theta) {\n    return vec2(dot(dir, vec2(1.0, 0.0)), dot(dir, vec2(0.0, 1.0))) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 dir2) {\n    return vec2(dot(dir, vec2(1.0, 0.0)), dot(dir, vec2(0.0, 1.0))) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 dir2, float theta) {\n    return vec2(dot(dir, vec2(1.0, 0.0)), dot(dir, vec2(0.0, 1.0))) * 0.5 + 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 dir, vec2 dir2, vec2 dir3) {\n    return vec2(dot(dir, vec2(1.0, 0.0)), dot(dir,", " theta = atan(p2.y - p1.y, p2.x - p1.x); return abs(cross(p - p1, p2 - p1) / length(p2 - p1)); }\n\n// Computes the signed distance from a triangle\nfloat triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    vec2 e1 = p2 - p1, e2 = p3 - p2, e3 = p1 - p3;\n    float s1 = sign(cross(e1, p - p1)), s2 = sign(cross(e2, p - p2)), s3 = sign(cross(e3, p - p3));\n    if (s1 == s2 && s2 == s3) return min(min(length(p - p1), length(p - p2)), length(p - p3));\n    return min(min(line(p, p1, p2), line(p, p2, p3)), line(p, p3, p1));\n}\n\n// Computes the signed distance from a quad\nfloat quad(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    vec2 e1 = p2 - p1, e2 = p3 - p2, e3 = p4 - p3, e4 = p1 - p4;\n    float s1 = sign(cross(e1, p - p1)), s2 = sign(cross(e2, p - p2)), s3 = sign(cross(e3, p - p3)), s4 = sign(cross(e4, p - p4));\n    if (s1 == s2 && s2 == s3 && s3 == s4) return min(min(min(length(p - p1), length(p - p2)), length(p - p3)), length(p - p4));\n    return min(min(min(line(p, p1, p2), line(p, p2, p3)), line(p, p3, p4)), line(p, p4, p1));\n}\n\n// Computes the signed distance from a polygon\nfloat polygon(", "\n    // Arrow is a triangle with a base of 1.0 and height of 0.5\n    // The arrow is centered on the x-axis\n    // The arrow is rotated 45 degrees counterclockwise\n    // The arrow is scaled by the length desired in pixels for arrows\n    // The arrow is translated to the center of the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is clipped to the tile\n    // The arrow is", " theta = 0.5 * (x + 1.0); }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2.0 * x - 1.0; }\n\n//shifts value range from 0-1 to -1-1\nvec2 makeMinus1to1(vec2 x) { theta = 2", " a = atan(point.y, point.x);\n  r = length(point);\n  return vec2(sin(a + offset), cos(a + offset)) * r * spread;\n}", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r,r2,h);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2, in float r3 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(mix(r,r2,h),r3,h);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2, in float r3, in float r4 )\n{\n    vec2 pa = p-a, ba", "\n    // get the base SDF\n    float d = sdSphere( p, vec3(0.0), sp );\n    \n    // get the rotation matrix\n    mat2 rot = rot2( time * 0.1 + id.x );\n    \n    // rotate the point\n    p = rot * p;\n    \n    // get the SDF of the rotated sphere\n    float d2 = sdSphere( p, vec3(0.0), sp * 0.5 );\n    \n    // subtract the rotated sphere from the base SDF\n    d = max( d, -d2 );\n    \n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp )\n{\n    // get the base SDF\n    float d = sdSphere( p, vec3(0.0), sp );\n    \n    // get the rotation matrix\n    mat2 rot = rot2( 0.0 );\n    \n    // rotate the point\n    p = rot * p;\n    \n    // get the SDF of the rotated sphere\n    float d2 = sdSphere( p, vec3(0.0), sp * 0.5 );\n    \n    // subtract the rotated sphere from the base SDF\n    d = max( d, -d2 );\n    \n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id )\n{\n    // get the base SDF\n    float d = sdSphere( p, vec3(0.0), 1.0 );\n    \n    // get the rotation matrix\n    mat2 rot = rot2( 0.0 );\n    \n    // rotate the point\n    p = rot * p;\n    \n    // get the SDF of the rotated sphere\n    float d2 = sdSphere( p, vec3(0.0), 0.5 );\n    \n    // subtract the rotated sphere from the base SDF\n    d = max( d, -d2 );\n    \n    return d;\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p )\n{\n    ", "\n    float a = atan(p.y,p.x) + time;\n    float r = length(p);\n    float d = cos( floor(.5+a/sp) * sp - a ) * r;\n    return d - ra;\n}\n\nfloat sdCircle( in vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdCircleRepetition( in vec2 p, float ra, float sp, float time )\n{\n    float a = atan(p.y,p.x) + time;\n    float r = length(p);\n    float d = cos( floor(.5+a/sp) * sp - a ) * r;\n    return d - ra;\n}\n\nfloat sdCircleRepetition( in vec2 p, float ra, float sp, float time, float r )\n{\n    float a = atan(p.y,p.x) + time;\n    float rr = length(p);\n    float d = cos( floor(.5+a/sp) * sp - a ) * rr;\n    return d - ra - r;\n}\n\nfloat sdCircleRepetition( in vec2 p, float ra, float sp, float time, float r, float rr )\n{\n    float a = atan(p.y,p.x) + time;\n    float d = cos( floor(.5+a/sp) * sp - a ) * length(p);\n    return d - ra - r - rr;\n}\n\nfloat sdCircleRepetition( in vec2 p, float ra, float sp, float time, float r, float rr, float rrr )\n{\n    float a = atan(p.y,p.x) + time;\n    float d = cos( floor(.5+a/sp) * sp - a ) * length(p);\n    return d - ra - r - rr - rrr;\n}\n\nfloat sdCircleRepetition( in vec2 p, float ra, float sp, float time, float r, float rr, float rrr, float rrrr )\n{\n    float a = atan(", " = \n    float d = min(min(uvw.x, uvw.y), uvw.z);\n    return d;\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size) {\n    vec3 d = abs(uvw) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size, vec3 offset) {\n    vec3 d = abs(uvw - offset) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size, vec3 offset, vec3 rotation) {\n    vec3 d = abs(uvw - offset) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size, vec3 offset, vec3 rotation, vec3 scale) {\n    vec3 d = abs(uvw - offset) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size, vec3 offset, vec3 rotation, vec3 scale, vec3 shear) {\n    vec3 d = abs(uvw - offset) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw, vec3 size, vec3 offset, vec3 rotation, vec3 scale, vec3 shear,", "(\n    vec3 uvw = fract(uvw);\n    vec3 uvw2 = abs(uvw - 0.5);\n    vec3 uvw3 = abs(uvw - 1.0);\n    vec3 uvw4 = abs(uvw - 0.0);\n    vec3 uvw5 = abs(uvw - 0.25);\n    vec3 uvw6 = abs(uvw - 0.75);\n    vec3 uvw7 = abs(uvw - 0.125);\n    vec3 uvw8 = abs(uvw - 0.375);\n    vec3 uvw9 = abs(uvw - 0.625);\n    vec3 uvw10 = abs(uvw - 0.875);\n    vec3 uvw11 = abs(uvw - 0.0625);\n    vec3 uvw12 = abs(uvw - 0.3125);\n    vec3 uvw13 = abs(uvw - 0.5625);\n    vec3 uvw14 = abs(uvw - 0.8125);\n    vec3 uvw15 = abs(uvw - 0.1875);\n    vec3 uvw16 = abs(uvw - 0.4375);\n    vec3 uvw17 = abs(uvw - 0.6875);\n    vec3 uvw18 = abs(uvw - 0.9375);\n    vec3 uvw19 = abs(uvw - 0.03125);\n    vec3 uvw20 = abs(uvw - 0.28125);\n    vec3 uvw21 = abs(uvw - 0.53125);\n    vec3 uvw22 = abs(uvw - 0.78125);\n    vec3 uvw23 = abs(uvw - 0.09375);\n    vec3 uvw24 = abs(uvw - 0.34375);\n    vec3 uvw25 = abs(uvw - 0.59375);\n    vec3 uvw26 = abs(uvw - 0.84375);\n    vec3 uvw", "\n    vec3 uvw_ = uvw - offset;\n    vec3 uvw_abs = abs(uvw_);\n    vec3 uvw_sign = sign(uvw_);\n    vec3 uvw_sign_abs = abs(uvw_sign);\n    vec3 uvw_sign_abs_inv = 1.0 - uvw_sign_abs;\n    vec3 uvw_sign_abs_inv_abs = abs(uvw_sign_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv = 1.0 - uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs;\n    vec3 uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv_abs = abs(uvw_sign_abs_inv_abs_inv_abs_inv_abs_inv_abs_inv);\n    vec3 uvw_sign_abs_inv_abs_inv_", "Y = clamp(t, 0., 1.);\n    return mix(vec3(0.231372549, 0.231372549, 0.858823529), vec3(0.858823529, 0.231372549, 0.231372549), Y);\n}", "\n    vec3 q = abs(p);\n    return max(q.x + q.y + q.z - 1.0, max(q.x, max(q.y, q.z)) - 0.5);\n}", " colormap_winter(t); }\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) { colormap_summer(t); }\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) { colormap_spring(t); }\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) { colormap_autumn(t); }\n\n// makes cool colormap with polynimal 6\nvec3 cool(float t) { colormap_cool(t); }\n\n// makes hot colormap with polynimal 6\nvec3 hot(float t) { colormap_hot(t); }\n\n// makes jet colormap with polynimal 6\nvec3 jet(float t) { colormap_jet(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv(float t) { colormap_hsv(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv2(float t) { colormap_hsv2(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv3(float t) { colormap_hsv3(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv4(float t) { colormap_hsv4(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv5(float t) { colormap_hsv5(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv6(float t) { colormap_hsv6(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv7(float t) { colormap_hsv7(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv8(float t) { colormap_hsv8(t); }\n\n// makes hsv colormap with polynimal 6\nvec3 hsv9(float t) { colormap", "\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    vec2 s = step(d, vec2(1.0));\n    return vec3(s.x * s.y);\n}\n\n// simple circle Tiling\nvec3 circleTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    float s = step(length(d), 1.0);\n    return vec3(s);\n}\n\n// simple diamond Tiling\nvec3 diamondTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    float s = step(max(d.x, d.y), 1.0);\n    return vec3(s);\n}\n\n// simple triangle Tiling\nvec3 triangleTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    float s = step(max(d.x, d.y), 1.0);\n    return vec3(s);\n}\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    float s = step(max(d.x, d.y), 1.0);\n    return vec3(s);\n}\n\n// simple octagon Tiling\nvec3 octagonTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5) * 2.0;\n    float s = step(max(d.x, d.y), 1.0);\n    return vec3(s);\n}\n\n// simple pentagon Tiling\nvec3 pentagonTile(vec2 uv) {\n    vec2 p = fract(uv);\n    vec2 d = abs(p - 0.5)", "ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale) {ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x) * scale;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset) {ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x) * scale + offset;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation) {ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x) * scale + offset * cos(rotation);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation, float rotationOffset) {ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x) * scale + offset * cos(rotation) + rotationOffset;\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv, float scale, float offset, float rotation, float rotationOffset, float rotationOffset2) {ic\n    vec2 p = uv * 2. - 1.;\n    vec2 q = abs(p.yx) - 1.;\n    return vec3(max(q, 0.), p.x) * scale + offset * cos(rotation) +", " a\n    vec2 gridUV = uv * gridRes;\n    vec2 gridUVOffset = gridUV + offset;\n    vec2 gridUVFloor = floor(gridUVOffset);\n    vec2 gridUVFract = fract(gridUVOffset);\n    vec2 gridUVFractInverse = 1.0 - gridUVFract;\n    vec2 gridUVFractInverseSqrt = sqrt(gridUVFractInverse);\n    vec2 gridUVFractSqrt = sqrt(gridUVFract);\n    vec2 gridUVFractSqrtInverse = 1.0 - gridUVFractSqrt;\n    vec2 gridUVFractSqrtInverseSqrt = sqrt(gridUVFractSqrtInverse);\n    vec2 gridUVFractSqrtSqrt = sqrt(gridUVFractSqrt);\n    vec2 gridUVFractSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtInverse);\n    vec2 gridUVFractSqrtSqrtSqrt = sqrt(gridUVFractSqrtSqrt);\n    vec2 gridUVFractSqrtSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtSqrtInverse);\n    vec2 gridUVFractSqrtSqrtSqrtSqrt = sqrt(gridUVFractSqrtSqrtSqrt);\n    vec2 gridUVFractSqrtSqrtSqrtSqrtInverse = 1.0 - gridUVFractSqrtSqrtSqrtSqrt;\n    vec2 gridUVFractSqrtSqrtSqrtSqrtInverseSqrt = sqrt(gridUVFractSqrtSqrtSq", ".\n    vec2 grid = floor(uv * gridRes);\n    vec2 gridUV = grid / gridRes;\n    vec2 gridUV2 = gridUV * 2.0 - 1.0;\n    vec2 gridUV3 = gridUV2 *.5 +.5;\n    return vec3(gridUV3, 1.0);\n}", "ated\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float xOffset = offset.x * gridRes;\n    float yOffset = offset.y * gridRes;\n    float xPos = floor(x + xOffset);\n    float yPos = floor(y + yOffset);\n    float xPos2 = floor(x - xOffset);\n    float yPos2 = floor(y - yOffset);\n    float xPos3 = floor(x + xOffset + gridRes);\n    float yPos3 = floor(y + yOffset + gridRes);\n    float xPos4 = floor(x - xOffset + gridRes);\n    float yPos4 = floor(y - yOffset + gridRes);\n    float xPos5 = floor(x + xOffset - gridRes);\n    float yPos5 = floor(y + yOffset - gridRes);\n    float xPos6 = floor(x - xOffset - gridRes);\n    float yPos6 = floor(y - yOffset - gridRes);\n    float xPos7 = floor(x + xOffset + gridRes * 2.);\n    float yPos7 = floor(y + yOffset + gridRes * 2.);\n    float xPos8 = floor(x - xOffset + gridRes * 2.);\n    float yPos8 = floor(y - yOffset + gridRes * 2.);\n    float xPos9 = floor(x + xOffset - gridRes * 2.);\n    float yPos9 = floor(y + yOffset - gridRes * 2.);\n    float xPos10 = floor(x - xOffset - gridRes * 2.);\n    float yPos10 = floor(y - yOffset - gridRes * 2.);\n    float xPos11 = floor(x + xOffset + gridRes * 3.);\n    float yPos11 = floor(y + yOffset + gridRes * 3.);\n    float xPos12 = floor(x - xOffset + gridRes * 3.);\n    float yPos12 = floor(y - yOffset + gridRes * 3.);\n    float xPos13 = floor(x + xOffset - gridRes *", "ated\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float xi = floor(x);\n    float yi = floor(y);\n    float xf = x - xi;\n    float yf = y - yi;\n    float xi1 = mod(xi + 1.0, gridRes);\n    float yi1 = mod(yi + 1.0, gridRes);\n    float xi2 = mod(xi + 2.0, gridRes);\n    float yi2 = mod(yi + 2.0, gridRes);\n    float xi3 = mod(xi + 3.0, gridRes);\n    float yi3 = mod(yi + 3.0, gridRes);\n    float xi4 = mod(xi + 4.0, gridRes);\n    float yi4 = mod(yi + 4.0, gridRes);\n    float xi5 = mod(xi + 5.0, gridRes);\n    float yi5 = mod(yi + 5.0, gridRes);\n    float xi6 = mod(xi + 6.0, gridRes);\n    float yi6 = mod(yi + 6.0, gridRes);\n    float xi7 = mod(xi + 7.0, gridRes);\n    float yi7 = mod(yi + 7.0, gridRes);\n    float xi8 = mod(xi + 8.0, gridRes);\n    float yi8 = mod(yi + 8.0, gridRes);\n    float xi9 = mod(xi + 9.0, gridRes);\n    float yi9 = mod(yi + 9.0, gridRes);\n    float xi10 = mod(xi + 10.0, gridRes);\n    float yi10 = mod(yi + 10.0, gridRes);\n    float xi11 = mod(xi + 11.0, gridRes);\n    float yi11 = mod(yi + 11.0, gridRes);\n    float xi12 = mod(xi + 12.", "\n    // grid\n    vec2 w = vec2( 0.5 ) - fract( p );\n    vec2 ww = 3.0*smoothstep( 0.0, vec2( 1.0 ), 3.0*ddx ) *\n              smoothstep( 0.0, vec2( 1.0 ), 3.0*ddy );\n    vec2 w1 = w-ww;\n    vec2 w2 = w+ww;\n\n    // derivatives of the grid\n    vec2 dgx = 6.0*ddx;\n    vec2 dgy = 6.0*ddy;\n\n    // distance to grid\n    vec2 p1 = p + w1;\n    vec2 p2 = p + w2;\n    vec2 d1 = dgx*w1.yx;\n    vec2 d2 = dgx*w2.yx;\n\n    // distance to grid\n    float d = min( dot(w1,w1), dot(w2,w2) );\n    float d1a = dot(p1,p1);\n    float d2a = dot(p2,p2);\n\n    // distance to grid\n    float d1b = dot(p1,d1);\n    float d2b = dot(p2,d2);\n\n    // distance to grid\n    float d1c = dot(p1,d1*d1);\n    float d2c = dot(p2,d2*d2);\n\n    // distance to grid\n    float d1d = dot(p1,d1*d1*d1);\n    float d2d = dot(p2,d2*d2*d2);\n\n    // distance to grid\n    float d1e = dot(p1,d1*d1*d1*d1);\n    float d2e = dot(p2,d2*d2*d2*d2);\n\n    // distance to grid\n    float d1f = dot(p1,d1*d1*d1*d1*d1);\n    float d2f = dot(p2,d2*d2*d2*d2*d2);\n\n", "\n    vec2 q = abs(p);\n    return max(q.x + q.y * 0.5, q.x * 0.866025 + q.y * 0.5) - r;\n}\n\nfloat hexagon(vec2 p, float r, float a) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b, c);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b, c, d);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d, float e) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b, c, d, e);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d, float e, float f) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b, c, d, e, f);\n}\n\nfloat hexagon(vec2 p, float r, float a, float b, float c, float d, float e, float f, float g) {\n    p = mat2(a, -0.5, 0.5, a) * p;\n    return hexagon(p, r, b, c, d", ":\n\tp *= 0.5;\n\tp.x += p.y * 0.5;\n\tp.y = fract(p.y * 1.5);\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p) {\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p, float scale) {\n\tp *= scale;\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p, float scale, float offset) {\n\tp *= scale;\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\tp.y += offset;\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p, float scale, float offset, float offset2) {\n\tp *= scale;\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\tp.y += offset;\n\tp.x += offset2;\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p, float scale, float offset, float offset2, float offset3) {\n\tp *= scale;\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\tp.y += offset;\n\tp.x += offset2;\n\tp.y += offset3;\n\treturn p;\n}\n\nvec2 hexgrid(inout vec2 p, float scale, float offset, float offset2, float offset3, float offset4) {\n\tp *= scale;\n\tp = hextile(p);\n\tp.x -= 0.5;\n\tp.y -= 0.25;\n\tp.y += offset;\n\tp.x += offset2;\n\tp", "\n    return 0.5 + 0.5 * sin( x * 3.1415 );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( mix( fun( dot( i + vec2( 0.0, 0.0 ), u - vec2( 0.0, 0.0 ) ) ),\n                     fun( dot( i + vec2( 1.0, 0.0 ), u - vec2( 1.0, 0.0 ) ) ),\n                     u.x ),\n                mix( fun( dot( i + vec2( 0.0, 1.0 ), u - vec2( 0.0, 1.0 ) ) ),\n                     fun( dot( i + vec2( 1.0, 1.0 ), u - vec2( 1.0, 1.0 ) ) ),\n                     u.x ),\n                u.y );\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * fun( noise( p ) ); p = p * 2.02;\n    f += 0.2500 * fun( noise( p ) ); p = p * 2.03;\n    f += 0.1250 * fun( noise( p ) ); p = p * 2.01;\n    f += 0.0625 * fun( noise( p ) );\n    return f / 0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 5.0 - 2.5;\n    float f = fbm( p );\n    fragColor = vec4( vec3( f ), 1.0 );\n}", ":\n    return mix(\n        pow(t, vec3(2.4)) * 1.055 - 0.055,\n        t * 12.92,\n        lessThan(t, vec3(0.0031308))\n    );\n}\n\nvec3 sRGB(float t) {:\n    return sRGB(vec3(t));\n}\n\nvec3 sRGB(int t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(uint t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(bool t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(double t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(half t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(short t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(unsigned short t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(char t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(unsigned char t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(long t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(unsigned long t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(long long t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(unsigned long long t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(double t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(half t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(short t) {:\n    return sRGB(float(t));\n}\n\nvec3 sRGB(unsigned short t) {:\n    return sRGB", "angle(p.x, p.y); return length(p) - 1.0;}\nfloat df1(vec2 p) {angle(p.x, p.y); return length(p) - 0.5;}\nfloat df2(vec2 p) {angle(p.x, p.y); return length(p) - 0.25;}\nfloat df3(vec2 p) {angle(p.x, p.y); return length(p) - 0.125;}\nfloat df4(vec2 p) {angle(p.x, p.y); return length(p) - 0.0625;}\nfloat df5(vec2 p) {angle(p.x, p.y); return length(p) - 0.03125;}\nfloat df6(vec2 p) {angle(p.x, p.y); return length(p) - 0.015625;}\nfloat df7(vec2 p) {angle(p.x, p.y); return length(p) - 0.0078125;}\nfloat df8(vec2 p) {angle(p.x, p.y); return length(p) - 0.00390625;}\nfloat df9(vec2 p) {angle(p.x, p.y); return length(p) - 0.001953125;}\nfloat df10(vec2 p) {angle(p.x, p.y); return length(p) - 0.0009765625;}\nfloat df11(vec2 p) {angle(p.x, p.y); return length(p) - 0.00048828125;}\nfloat df12(vec2 p) {angle(p.x, p.y); return length(p) - 0.000244140625;}\nfloat df13(vec2 p) {angle(p.x, p.y); return length(p) - 0.0001220703125;}\nfloat df14(vec2 p) {angle(p.x, p.y); return length(p) - 0.00006103515625;}\nfloat df15(vec2 p) {angle(p.x, p.y); return length(p) - 0.000030", "isInside = true; return length(p)-1.0;}\nfloat df2(vec2 p) {isInside = true; return length(p)-0.5;}\nfloat df3(vec2 p) {isInside = true; return length(p)-0.25;}\nfloat df4(vec2 p) {isInside = true; return length(p)-0.125;}\nfloat df5(vec2 p) {isInside = true; return length(p)-0.0625;}\nfloat df6(vec2 p) {isInside = true; return length(p)-0.03125;}\nfloat df7(vec2 p) {isInside = true; return length(p)-0.015625;}\nfloat df8(vec2 p) {isInside = true; return length(p)-0.0078125;}\nfloat df9(vec2 p) {isInside = true; return length(p)-0.00390625;}\nfloat df10(vec2 p) {isInside = true; return length(p)-0.001953125;}\nfloat df11(vec2 p) {isInside = true; return length(p)-0.0009765625;}\nfloat df12(vec2 p) {isInside = true; return length(p)-0.00048828125;}\nfloat df13(vec2 p) {isInside = true; return length(p)-0.000244140625;}\nfloat df14(vec2 p) {isInside = true; return length(p)-0.0001220703125;}\nfloat df15(vec2 p) {isInside = true; return length(p)-0.00006103515625;}\nfloat df16(vec2 p) {isInside = true; return length(p)-0.000030517578125;}\nfloat df17(vec2 p) {isInside = true; return length(p)-0.0000152587890625;}\nfloat df18(vec2 p) {isInside = true; return length(p)-0.00000762939453125;}\nfloat df19(vec2 p) {isInside = true; return length(p)-0.000003814697265625;}\nfloat", " between(p, p0, p1)? sdSegment(p, p0, p1) :\nbetween(p, p1, p2)? sdSegment(p, p1, p2) :\nbetween(p, p2, p0)? sdSegment(p, p2, p0) :\nmin( sdSegment(p, p0, p1), min( sdSegment(p, p1, p2), sdSegment(p, p2, p0) ) );\n}", ":\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float s1 = -b - h;\n    float s2 = -b + h;\n    if (s1 > 0.0) {\n        if (s2 > 0.0) return min(s1, s2);\n        return s1;\n    }\n    if (s2 > 0.0) return s2;\n    return -1.0;\n}", ":\n    float d = length(p.x) - w;\n    return max(d, -r + sqrt(r*r - dot(p,p)));\n}", "\n    p.x = abs(p.x);\n    float a = p.x+k*p.y;\n    float b = (k-1.0)+k*abs(p.y);\n    return max(a,b);\n}", "\n    float d = length(p);\n    return d - 1.0/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r )\n{\n    float d = length(p);\n    return d - r/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2 )\n{\n    float d = length(p);\n    return d - r/d - r2/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2, in float r3 )\n{\n    float d = length(p);\n    return d - r/d - r2/d - r3/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2, in float r3, in float r4 )\n{\n    float d = length(p);\n    return d - r/d - r2/d - r3/d - r4/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2, in float r3, in float r4, in float r5 )\n{\n    float d = length(p);\n    return d - r/d - r2/d - r3/d - r4/d - r5/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2, in float r3, in float r4, in float r5, in float r6 )\n{\n    float d = length(p);\n    return d - r/d - r2/d - r3/d - r4/d - r5/d - r6/d;\n}\n\n// distance to y=1/x\nfloat sdOOX( in vec2 p, in float r, in float r2, in float r3, in float r4, in float r5, in float r6, in float r7 )\n{\n    float d = length(", ":\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "\n    return a < 0.0? -a : a;\n}\n\nfloat pabs(float a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(vec2 a, float k) {\n    return max(pabs(a.x, k), pabs(a.y, k));\n}\n\nfloat pabs(vec2 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(vec3 a, float k) {\n    return max(pabs(a.x, k), max(pabs(a.y, k), pabs(a.z, k)));\n}\n\nfloat pabs(vec3 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(vec4 a, float k) {\n    return max(pabs(a.x, k), max(pabs(a.y, k), max(pabs(a.z, k), pabs(a.w, k))));\n}\n\nfloat pabs(vec4 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(mat2 a, float k) {\n    return max(pabs(a[0], k), pabs(a[1], k));\n}\n\nfloat pabs(mat2 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(mat3 a, float k) {\n    return max(pabs(a[0], k), max(pabs(a[1], k), pabs(a[2], k)));\n}\n\nfloat pabs(mat3 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(mat4 a, float k) {\n    return max(pabs(a[0], k), max(pabs(a[1], k), max(pabs(a[2], k), pabs(a[3], k))));\n}\n\nfloat pabs(mat4 a) {\n    return pabs(a, 1.0);\n}\n\nfloat pabs(mat2x2 a, float k) {\n    return max(pabs(a[", ":\n    p = p*vec2(0.5,1.0);\n    p = abs(p);\n    float d = length(p-vec2(0.0,0.0)) - 0.3;\n    d = max(d, length(p-vec2(0.0,0.5)) - 0.2);\n    d = max(d, length(p-vec2(0.0,1.0)) - 0.1);\n    d = max(d, length(p-vec2(0.0,1.5)) - 0.05);\n    d = max(d, length(p-vec2(0.0,2.0)) - 0.02);\n    d = max(d, length(p-vec2(0.0,2.5)) - 0.01);\n    d = max(d, length(p-vec2(0.0,3.0)) - 0.005);\n    d = max(d, length(p-vec2(0.0,3.5)) - 0.002);\n    d = max(d, length(p-vec2(0.0,4.0)) - 0.001);\n    d = max(d, length(p-vec2(0.0,4.5)) - 0.0005);\n    d = max(d, length(p-vec2(0.0,5.0)) - 0.0002);\n    d = max(d, length(p-vec2(0.0,5.5)) - 0.0001);\n    d = max(d, length(p-vec2(0.0,6.0)) - 0.00005);\n    d = max(d, length(p-vec2(0.0,6.5)) - 0.00002);\n    d = max(d, length(p-vec2(0.0,7.0)) - 0.00001);\n    d = max(d, length(p-vec2(0.0,7.5)) - 0.000005);\n    d = max(d, length(p-", "er\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D Random\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n    float frequency = 0.;\n\n    // Loop of octaves\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * noise(", "\n    vec2 AB = mix( A, B, 0.333333 );\n    vec2 BC = mix( B, C, 0.333333 );\n    vec2 ABC = mix( AB, BC, 0.5 );\n\n    vec2 p = pos - ABC;\n    vec2 e = ABC - pos;\n\n    float k = dot(e,e) - 4.0;\n    float h = dot(p,e);\n\n    vec2 q = p + p;\n    vec2 hq = q * h;\n    vec2 kq = q * k;\n    vec2 hhq = h * h * q;\n\n    float m = hq.x + hq.y - 3.0 * kq.x - 3.0 * kq.y;\n    float n = hhq.x + hhq.y - 4.0 * kq.x - 6.0 * kq.y;\n    float l = hhq.x + hhq.y;\n\n    float z = sqrt(n*n - 4.0*m*l);\n\n    float u = (-n - z) / (2.0 * m);\n    float v = (-n + z) / (2.0 * m);\n\n    float u2 = u*u;\n    float v2 = v*v;\n\n    float u_term = 3.0 * u2 - 4.0 * u;\n    float v_term = 3.0 * v2 - 4.0 * v;\n\n    float u_term_inv = 1.0 / u_term;\n    float v_term_inv = 1.0 / v_term;\n\n    float u_term_inv_sq = u_term_inv * u_term_inv;\n    float v_term_inv_sq = v_term_inv * v_term_inv;\n\n    float u_term_inv_cube = u_term_inv_sq * u_term_inv;\n    float v_term_inv_cube = v_term_inv_sq * v_term_inv;\n\n    float u_term_inv_quad = u_term_inv_sq * u_", " = vec3(0.0);\n    float d = length(pos);\n    float h = he - wi*wi*wi/12.0;\n    float y = pos.y - h*d*d;\n    float z = pos.x - wi*d*d;\n    float yz = sqrt(y*y + z*z);\n    float x = sqrt(d*d - yz*yz);\n    return vec3(x,y,z);\n}", " = vec3( pos.x, pos.x*pos.x*k, k );\n}", " = vec3(0.0);\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float b = sqrt(1.0-ra*ra/r/r);\n    float c = sqrt(1.0-rb*rb/r/r);\n    float d1 = a/b/b;\n    float d2 = (a-PI)/b/b;\n    float d3 = (a+PI)/c/c;\n    float d4 = (a+2.0*PI)/c/c;\n    float d5 = (a-2.0*PI)/c/c;\n    float d6 = (a+3.0*PI)/c/c;\n    float d7 = (a-3.0*PI)/c/c;\n    float d8 = (a+4.0*PI)/c/c;\n    float d9 = (a-4.0*PI)/c/c;\n    float d10 = (a+5.0*PI)/c/c;\n    float d11 = (a-5.0*PI)/c/c;\n    float d12 = (a+6.0*PI)/c/c;\n    float d13 = (a-6.0*PI)/c/c;\n    float d14 = (a+7.0*PI)/c/c;\n    float d15 = (a-7.0*PI)/c/c;\n    float d16 = (a+8.0*PI)/c/c;\n    float d17 = (a-8.0*PI)/c/c;\n    float d18 = (a+9.0*PI)/c/c;\n    float d19 = (a-9.0*PI)/c/c;\n    float d20 = (a+10.0*PI)/c/c;\n    float d21 = (a-10.0*PI)/c/c;\n    float d22 = (a+11.0*PI)/c/c;\n    float d23 = (a-11.0*PI)/c/c;\n    float d24 = (a+12.0*PI)/c/", "ctions\n    v = v * ivec2(0xff51afd7, 0xed558ccd) + ivec2(0xb236d53a, 0xcc96a91b);\n    v = v ^ (v >> 16);\n    v = v * ivec2(0xff51afd7, 0xed558ccd) + ivec2(0xb236d53a, 0xcc96a91b);\n    return v;\n}\n\nfloat Pcg2(float v)\n{\n    v = v * 0xff51afd7 + 0xb236d53a;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + 0xb236d53a;\n    return v;\n}\n\nfloat Pcg2(float v, float seed)\n{\n    v = v * 0xff51afd7 + seed;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + seed;\n    return v;\n}\n\nfloat Pcg2(float v, float seed, float seed2)\n{\n    v = v * 0xff51afd7 + seed;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + seed2;\n    return v;\n}\n\nfloat Pcg2(float v, float seed, float seed2, float seed3)\n{\n    v = v * 0xff51afd7 + seed;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + seed2;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + seed3;\n    return v;\n}\n\nfloat Pcg2(float v, float seed, float seed2, float seed3, float seed4)\n{\n    v = v * 0xff51afd7 + seed;\n    v = v ^ (v >> 16);\n    v = v * 0xff51afd7 + seed2", "ctions\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\nfloat Pcg1(ivec3 v)\n{\n    v = Pcg3(v);\n    return float(v.x) / float(0xffffffffu);\n}\n\nvec3 Pcg3(vec3 v)\n{\n    v = v * 1664525.0 + 1013904223.0;\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return v;\n}\n\nfloat Pcg1(vec3 v)\n{\n    v = Pcg3(v);\n    return v.x / 4294967295.0;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p)\n{\n    float n = sin(dot(p, vec3(7.0, 157.0, 113.0)));\n    return fract(vec3(2097152.0, 262144.0, 32768.0)*n);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p, float seed)\n{\n    float n = sin(dot(p, vec3(7.0, 157.0, 113.0)) + seed);\n    return fract(vec3(2097152.0, 262144.0, 32768.0)*n);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p, vec3 seed)\n{\n    float n = sin(dot(p, vec3(7.0, 157.0, 113.0)) + dot(seed, vec3(157.0, 113.0, 7.0)));\n", " between\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0.0, 1.0);\n\n        vec2 qos = d + (c + b * t) * t;\n        res = length(qos);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n\n        vec2 qos = d + (c + b * t.x) * t.x;\n        float dis = length(qos);\n        res = min(res, dis);", ":\n    return sign(cross(p - a, b - a));\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) * winding_sign(p, b, c) * winding_sign(p, c, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) * winding_sign(p, b, c, d) * winding_sign(p, c, d, a) * winding_sign(p, d, a, b);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) * winding_sign(p, b, c, d, e) * winding_sign(p, c, d, e, a) * winding_sign(p, d, e, a, b) * winding_sign(p, e, a, b, c);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) * winding_sign(p, b, c, d, e, f) * winding_sign(p, c, d, e, f, a) * winding_sign(p, d, e, f, a, b) * winding_sign(p, e, f, a, b, c) * winding_sign(p, f, a, b, c, d);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b, c, d, e, f) * winding_sign(p, b, c", " ============================================================================\n  vec3  n = vec3(0.0);\n  float d = 0.0;\n  float t = 0.0;\n  float m = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n  float y = 0.0;\n  float z = 0.0;\n  float a = 0.0;\n  float b = 0.0;\n  float c = 0.0;\n  float d = 0.0;\n  float e = 0.0;\n  float f = 0.0;\n  float g = 0.0;\n  float h = 0.0;\n  float i = 0.0;\n  float j = 0.0;\n  float k = 0.0;\n  float l = 0.0;\n  float m = 0.0;\n  float n = 0.0;\n  float o = 0.0;\n  float p = 0.0;\n  float q = 0.0;\n  float r = 0.0;\n  float s = 0.0;\n  float t = 0.0;\n  float u = 0.0;\n  float v = 0.0;\n  float w = 0.0;\n  float x = 0.0;\n", "\n    float f = a * b + x;\n    ret_n = int(floor(f));\n    return fract(f);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, int b, float x) {\n    float f = a * b + x;\n    ret_n = int(floor(f));\n    return fract(f);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, int b, int x) {\n    float f = a * b + x;\n    ret_n = int(floor(f));\n    return fract(f);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, int b, uint x) {\n    float f = a * b + x;\n    ret_n = int(floor(f));\n    return fract(f);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, uint b, uint x) {\n    float f = a * b + x;\n    ret_n = int(floor(f));\n    return fract(f);\n}\n\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*", " = a;\n    if( k == 0.0 )\n        return a;\n    float h = clamp( 0.5+0.5*(b.z-a.z)/k, 0.0, 1.0 );\n    vec3 c = mix( a, b, h ) - k*h*(1.0-h);\n    c.z = a.z + k*(h*(1.0-h)-a.z);\n    return c;\n}", "\n    float a = ab.x;\n    float b = ab.y;\n    float c = sqrt(a*a - b*b);\n    float d = sqrt(p.x*p.x + p.y*p.y);\n    float e = atan(p.y/p.x);\n    float f = 1.0 / (a*a);\n    float g = 1.0 / (b*b);\n    float h = 1.0 / (c*c);\n    float i = 1.0 / (d*d);\n    float j = e*e;\n    float k = f + g - h - i - j;\n    float l = sqrt(k*k + 4.0);\n    float m = 2.0 / l;\n    float n = sqrt(m);\n    float o = 1.0 / (n*n);\n    float p = sqrt(o);\n    float q = 1.0 / (p*p);\n    float r = sqrt(q);\n    float s = 1.0 / (r*r);\n    float t = sqrt(s);\n    float u = 1.0 / (t*t);\n    float v = sqrt(u);\n    float w = 1.0 / (v*v);\n    float x = sqrt(w);\n    float y = 1.0 / (x*x);\n    float z = sqrt(y);\n    float A = m + n - o - p + q - r + s - t + u - v + w - x + y - z;\n    float B = m - n + o - p - q + r - s + t - u + v - w + x - y + z;\n    float C = m - n - o + p - q - r + s - t + u - v - w + x - y - z;\n    float D = m - n - o - p - q - r - s + t - u - v - w - x - y - z;\n    float E = m - n + o + p - q + r - s - t + u - v - w - x - y + z;", "ision testing\nfloat add_ploss(in float a, in float b){\n    return a + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float a = 0.5;\n    float b = 0.5;\n    \n    float c = add_ploss(a, b);\n    \n    fragColor = vec4(c);\n}", "\n    vec2 sols = vec2(0.0);\n    float a = ab.x;\n    float b = ab.y;\n    float c = a*a - b*b;\n    float d = sqrt(c);\n    float e = 1.0 / (1.0 + d);\n    float f = 1.0 / (1.0 - d);\n    float g = 1.0 / (1.0 + d*d);\n    float h = 1.0 / (1.0 - d*d);\n    float i = 1.0 / (1.0 + d*d*d);\n    float j = 1.0 / (1.0 - d*d*d);\n    float k = 1.0 / (1.0 + d*d*d*d);\n    float l = 1.0 / (1.0 - d*d*d*d);\n    float m = 1.0 / (1.0 + d*d*d*d*d);\n    float n = 1.0 / (1.0 - d*d*d*d*d);\n    float o = 1.0 / (1.0 + d*d*d*d*d*d);\n    float p = 1.0 / (1.0 - d*d*d*d*d*d);\n    float q = 1.0 / (1.0 + d*d*d*d*d*d*d);\n    float r = 1.0 / (1.0 - d*d*d*d*d*d*d);\n    float s = 1.0 / (1.0 + d*d*d*d*d*d*d*d);\n    float t = 1.0 / (1.0 - d*d*d*d*d*d*d*d);\n    float u = 1.0 / (1.0 + d*d*d*d*d*d*d*d*d);\n    float v = 1.0 / (1.0 - d*d*d*d*d*d*d*d*d);\n    float w = 1", "  \n    vec3 ba = b - a;\n    float l2 = dot(ba, ba);\n    float r2 = (ra + rb) * (ra + rb);\n    float d2 = dot(p - a, p - b);\n    float s = clamp(dot(p - a, ba) / l2, 0.0, 1.0);\n    vec3 c = a + s * ba;\n    float x = length(p - c);\n    float y = x - (ra - rb);\n    float z = y * y;\n    float w = max(0.0, z * l2 / r2 - s * s);\n    return vec4(sqrt(z) * sign(y), c + s * ba);\n}", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}", "\n    return length(p-cen)-rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h", "\n    if( showSurface )\n    {\n        return normalize( samplePoint - pos );\n    }\n    else\n    {\n        vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n        return normalize( e.xyy*sdf( pos + e.xyy ) +\n                          e.yyx*sdf( pos + e.yyx ) +\n                          e.yxy*sdf( pos + e.yxy ) +\n                          e.xxx*sdf( pos + e.xxx ) );\n    }\n}", "\n    float res = 1.0;\n    float t = 0.02;\n    float h = 1.0;\n    float s = 1.0;\n    float k = 1.0;\n    float d = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        if( h<0.001 ) break;\n        d = map(ro + rd*t, samplePoint);\n        h = d;\n        res = min( res, k*h/t );\n        t += d;\n        k += 0.05;\n    }\n    if( showSurface )\n    {\n        if( t>1.0 ) res = 1.0;\n    }\n    return clamp( res, 0.0, 1.0 );\n}", " = sdTrapezoid( p, ra, rb, he );\n    vec2 q = abs(p)-vec2(ra,he);\n    vec2 d = vec2(length(max(q,0.0))+min(max(q.x,q.y),0.0),he-abs(p.y));\n    ocl = d.xy;\n    return vec3(length(d)-rb,d.x,d.y);\n}", " is this correct?\n    vec2 q = vec2(length(p.xz)-ra,p.y);\n    return vec4(length(q)-rb,1.0);\n}", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.01;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r,r2,h);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2, in float r3 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r,mix(r2,r3,h),h);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2, in float r3, in float r4 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float", "\n    return dot(v, v);\n}\n\nfloat sdCappedCone(in vec3 p, in float h, in float r1, in float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0)? -r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0)? -1.0 : 1.0;\n    return s * sqrt(min(dot2(ca), dot2(cb))) * s;\n}\n\nfloat sdCappedCone(in vec3 p, in float h, in float r1, in float r2, in float r3) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0)? -r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0)? -1.0 : 1.0;\n    float d = min(dot2(ca), dot2(cb));\n    return s * sqrt(d) * s;\n}\n\nfloat sdCappedCone(in vec3 p, in float h,", " aabb( p, minCorner, maxCorner );\n  return dot( p, p ); }\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size ) \n{ aabb( p, minCorner, maxCorner, size );\n  return dot( p, p ); }\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset ) \n{ aabb( p, minCorner, maxCorner, size, offset );\n  return dot( p, p ); }\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset, in vec2 rotation ) \n{ aabb( p, minCorner, maxCorner, size, offset, rotation );\n  return dot( p, p ); }\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset, in vec2 rotation, in vec2 scale ) \n{ aabb( p, minCorner, maxCorner, size, offset, rotation, scale );\n  return dot( p, p ); }\n\n// Essentially the box from iq\n// Squared distance so you only have to take one sqrt for multiple aabbs\nfloat sqAABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in vec2 size, in vec2 offset, in vec2 rotation, in vec2 scale, in vec2 shear ) \n{ aabb( p, minCorner, maxCorner, size, offset,", "ural\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    float f = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.", "\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z)\n{\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = z;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, vec3 cam)\n{\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = z;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, vec3 cam, vec3 up)\n{\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = z;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, vec3 cam, vec3 up, vec3 right)\n{\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = z;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, vec3 cam, vec3 up, vec3 right, vec3 forward)\n{\n    vec3 ray = vec3(0.0);\n    ray.xy = uv * 2.0 - 1.0;\n    ray.z = z;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv, float z, vec3 cam", "ion\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz", "\n    return length(p-c)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 c, in float r )\n{\n    vec2 d = abs(p-c)-r;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a, pa = p-a;\n    vec2 cb = c-b, pb = p-b;\n    vec2 ac = a-c, pc = p-c;\n    vec2 ab_pc = cross(ba,pc);\n    vec2 bc_pa = cross(cb,pa);\n    vec2 ca_pb = cross(ac,pb);\n    if( sign(ab_pc)==sign(bc_pa) && sign(bc_pa)==sign(ca_pb) )\n        return min( min( length(ab_pc), length(bc_pa) ), length(ca_pb) );\n    float s = clamp( -dot(ba,pa)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa + ba*s;\n    return length(p-q);\n}\n\nfloat sdRoundedTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n    vec2 ba = b-a, pa = p-a;\n    vec2 cb = c-b, pb = p-b;\n    vec2 ac = a-c, pc = p-c;\n    vec2 ab_pc = cross(ba,pc);\n    vec2 bc_pa = cross(cb,pa);\n    vec2 ca_", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    // c is", "\n    if( d < m.x )\n    {\n        m.x = d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opUnion( vec2 m, vec2 d )\n{\n    if( d.x < m.x )\n    {\n        m = d;\n    }\n    return m;\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    if( d > -m.x )\n    {\n        m.x = -d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opSubtraction( vec2 m, vec2 d )\n{\n    if( d.x > -m.x )\n    {\n        m.x = -d.x;\n    }\n    return m;\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    if( d > m.x )\n    {\n        m.x = d;\n        m.y = a;\n    }\n    return m;\n}\n\nvec2 opIntersection( vec2 m, vec2 d )\n{\n    if( d.x > m.x )\n    {\n        m = d;\n    }\n    return m;\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a, float k )\n{\n    float h = clamp( 0.5 + 0.5*(m.x-d)/k, 0.0, 1.0 );\n    m.x = mix( m.x, d, h ) - k*h*(1.0-h);\n    m.y = mix( m.y, a, h );\n    return m;\n}\n\nvec2 opSmoothUnion( vec2 m, vec2 d, float k )\n{\n    float h = clamp( 0.5 + 0.5*(m.x-d.x)/k, 0.0, 1.0 );\n    m.x = mix( m.x, d.x, h ) - k*h*(1.0-h);\n    m.", "\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4(0.0);\n        p2 = vec4(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p1 = vec4(ro + rd*(-b-h), 1.0);\n        p2 = vec4(ro + rd*(-b+h), 1.0);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec2 p1, out vec2 p2 )\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec2(0.0);\n        p2 = vec2(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p1 = ro + rd*(-b-h);\n        p2 = ro + rd*(-b+h);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out vec2 p )\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 )\n    {\n        p = vec2(0.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        p = ro + rd*(-b-h);\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCircle( in vec2 ro, in vec2 rd, float rad, out float p )\n{", "\n    vec2 d = p - c;\n    return vec3( dot(d,d) - r*r, d.x, d.y );\n}\n\nvec3 sdgRect( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c) - s;\n    return vec3( max(d.x,d.y), d.x, d.y );\n}\n\nvec3 sdgTriangle( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c);\n    return vec3( max(d.x*0.866025+d.y*0.5,-d.y), d.x, d.y );\n}\n\nvec3 sdgSquare( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c) - s;\n    return vec3( max(d.x,d.y), d.x, d.y );\n}\n\nvec3 sdgHexagon( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c);\n    return vec3( max(d.x*0.866025+d.y*0.5,-d.y), d.x, d.y );\n}\n\nvec3 sdgOctagon( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c);\n    return vec3( max(d.x*0.866025+d.y*0.5,-d.y), d.x, d.y );\n}\n\nvec3 sdgStar( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p - c);\n    return vec3( max(d.x*0.866025+d.y*0.5,-d.y), d.x, d.y );\n}\n\nvec3 sdgCross( in vec2 p, in vec2 c, in vec2 s ) \n{\n    vec2 d = abs(p", "\n    vec2 d = abs(p)-b;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                d.x,d.y);\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    return vec3(length(p)-r, p.x, p.y);\n}\n\nvec3 sdgLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3(length(pa-ba*h), pa.x, pa.y);\n}\n\nvec3 sdgTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a, pa = p-a;\n    vec2 cb = c-b, pb = p-b;\n    vec2 ac = a-c, pc = p-c;\n    vec2 ab_pc = pa.x*ba.y-pa.y*ba.x;\n    vec2 bc_pb = pb.x*cb.y-pb.y*cb.x;\n    vec2 ca_pc = pc.x*ac.y-pc.y*ac.x;\n    return vec3( min( min(\n                          sdgLine(p,a,b).x,\n                          sdgLine(p,b,c).x ),\n                      sdgLine(p,c,a).x ),\n                 ab_pc, bc_pb );\n}\n\nvec3 sdgQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 ab = b-a, am = p-a, dc = c-d, dm = p-d;\n    vec2 e = ab.y*dc.x-ab.x*dc.y < 0.0? dm : am", " = vec3(0.0);\n    float d = length(p) - 1.0;\n    float h = 0.0;\n    float r = 0.0;\n    float a = 0.0;\n    float s = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float q = 0.0;\n    float r = 0.0", "antialiasing = 0.01;\n    float a = a1 + (a2 - a1) * x;\n    float b = b1 + (b2 - b1) * x;\n    return a * x + b * (1.0 - x);\n}\n\nfloat f(float a1, float b1, float a2, float b2, float a3, float b3, float a4, float b4, float x) {\n    float y1 = g(a1, b1, a2, b2, x);\n    float y2 = g(a3, b3, a4, b4, x);\n    return y1 + y2 * (1.0 - x);\n}\n\nvec2 f(vec2 a1, vec2 b1, vec2 a2, vec2 b2, vec2 a3, vec2 b3, vec2 a4, vec2 b4, float x) {\n    return vec2(f(a1.x, b1.x, a2.x, b2.x, a3.x, b3.x, a4.x, b4.x, x),\n                f(a1.y, b1.y, a2.y, b2.y, a3.y, b3.y, a4.y, b4.y, x));\n}\n\nvec2 f(vec2 a1, vec2 b1, vec2 a2, vec2 b2, vec2 a3, vec2 b3, vec2 a4, vec2 b4, vec2 a5, vec2 b5, vec2 a6, vec2 b6, vec2 a7, vec2 b7, vec2 a8, vec2 b8, float x) {\n    return vec2(f(a1.x, b1.x, a2.x, b2.x, a3.x, b3.x, a4.x, b4.x, a5.x, b5.x, a6.x, b6.x, a7.x, b7.x, a8.x, b8.x, x),\n                f(a1.y, b1.y, a2.y", "\n    return pow(abs(x), n) * (a * sign(x) + b);\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat v(float a, float b, float n, float y) {\n    return pow(abs(y), n) * (a * sign(y) + b);\n}\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat w(float a, float b, float n, float z) {\n    return pow(abs(z), n) * (a * sign(z) + b);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nvec3 hvw(float a, float b, float n, vec3 p) {\n    return vec3(h(a, b, n, p.x), v(a, b, n, p.y), w(a, b, n, p.z));\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nvec3 hv(float a, float b, float n, vec3 p) {\n    return vec3(h(a, b, n", ":\n                float t = iTime;\n                float noise = 0.0;\n                float freq = 1.0;\n                float amp = 1.0;\n                float maxAmp = 0.0;\n                for(int i = 0; i < 4; i++){\n                    noise += amp * noise2(uv * freq + t);\n                    maxAmp += amp;\n                    amp *= 0.5;\n                    freq *= 2.0;\n                }\n                return noise / maxAmp;\n            }\n            \n            void mainImage(out vec4 fragColor, in vec2 fragCoord){\n                vec2 uv = fragCoord / iResolution.xy;\n                vec3 color = vec3(0.0);\n                \n                // Add some noise to the background\n                color += paperNoise(uv) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 10.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 20.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 40.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 80.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 160.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 320.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 640.0) * 0.1;\n                \n                // Add some noise to the foreground\n                color += paperNoise(uv * 1280.0) * 0.1;", "\n    vec3 color = vec3( 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        color += vec3( 1.0, 0.0, 0.0 );\n        color += vec3( 0.0, 1.0, 0.0 );\n        color += vec3( 0.0, 0.0, 1.0 );\n    }\n    return color;\n}", "\n    return length(p-c)-r;\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0)) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 pa = p-a, ba = b-a, dc = d-c;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  pj = a + ba*h;\n    float k = clamp( dot(pj-c,dc)/dot(dc,dc), 0.0, 1.0 );\n    return length( pj - c - dc*k );\n}\n\nfloat sdSegment( in vec2 p, in vec2", "\n    vec2 d = abs(p)-c;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r ) \n{\n    return length(p-c)-r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) \n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c ) \n{\n    vec2 ba = b-a, pa = p-a;\n    vec2 cb = c-b, pb = p-b;\n    vec2 ac = a-c, pc = p-c;\n    vec2 ab_pc = pa*ba.y - ba*pa.y;\n    vec2 bc_pb = pb*cb.y - cb*pb.y;\n    vec2 ca_pc = pc*ac.y - ac*pc.y;\n    return min( min(\n            dot(ab_pc,ab_pc)/dot(ba,ba),\n            dot(bc_pb,bc_pb)/dot(cb,cb) ),\n            dot(ca_pc,ca_pc)/dot(ac,ac) );\n}\n\nfloat sdQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d ) \n{\n    vec2 ab = b-a, am = p-a, dc = c-d, dm = p-d;\n    vec2 n = ab.y*dc.x - ab.x*dc.y;\n    float s = clamp( (am.x*dc.y - am.y*dc.x)/dot(n,n), 0.0, 1.0 );\n    float t = clamp( (dm.x*ab.y - dm", ".\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h), h );\n}", ".\n    vec2 pa = p-a, ba = b-a;\n    float h2 = h*h;\n    float ba2 = dot(ba,ba);\n    float t = clamp( -dot(pa,ba)/ba2, 0.0, 1.0 );\n    vec2  c = a + t*ba;\n    float d2 = dot(pa,pa) - 2.0*t*dot(pa,ba) + t*t*ba2;\n    float s = sign(h2-d2);\n    float r = s*sqrt(h2-d2);\n    float d = max(r,d2-d2min);\n    return vec2(d,r);\n}", "\n    // kType[0] = 0, 1, 2, 3, 4, 5, 6\n    // kType[1] = 0, 1, 2, 3, 4, 5, 6\n    // kType[2] = 0, 1, 2, 3, 4, 5, 6\n    // kType[3] = 0, 1, 2, 3, 4, 5, 6\n    // kType[4] = 0, 1, 2, 3, 4, 5, 6\n    // kType[5] = 0, 1, 2, 3, 4, 5, 6\n    // kType[6] = 0, 1, 2, 3, 4, 5, 6\n\n    // kPath[0] = 0.0\n    // kPath[1] = 0.0\n    // kPath[2] = 0.0\n    // kPath[3] = 0.0\n    // kPath[4] = 0.0\n    // kPath[5] = 0.0\n    // kPath[6] = 0.0\n    // kPath[7] = 0.0\n    // kPath[8] = 0.0\n    // kPath[9] = 0.0\n    // kPath[10] = 0.0\n    // kPath[11] = 0.0\n    // kPath[12] = 0.0\n    // kPath[13] = 0.0\n    // kPath[14] = 0.0\n    // kPath[15] = 0.0\n    // kPath[16] = 0.0\n\n    // kType[0] = 0, 1, 2, 3, 4, 5, 6\n    // kType[1] = 0, 1, 2, 3, 4, 5, 6\n    // kType[2] = 0, 1, 2, 3, 4, 5, 6\n", "\n    vec2 q = vec2( length(p.xy), p.y );\n    return -sdBox( q, vec2(1.0) );\n}\n\nfloat sdB( in vec2 p )\n{\n    vec2 q = vec2( length(p.xy), p.y );\n    return sdBox( q, vec2(0.5) );\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opRepeat( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p,c)-0.5*c;\n    return sdA(q);\n}\n\nfloat opRepeat( in vec2 p, in float c )\n{\n    vec2 q = mod(p,c)-0.5*c;\n    return sdA(q);\n}\n\nfloat opRepeat( in vec2 p, in vec", "\n    vec2 q = abs(p)-vec2(1.,.5);\n    return min(max(q.x,q.y),0.) + length(max(q,0.));\n}\n\n// correct outside, incorrect inside\nfloat sdC( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + min(max(q.x,q.y),0.);\n}\n\n// correct outside, incorrect inside\nfloat sdD( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + max(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdE( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + min(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdF( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + max(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdG( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + min(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdH( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + max(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdI( in vec2 p )\n{\n    vec2 q = abs(p)-vec2(1.,.5);\n    return length(max(q,0.)) + min(q.x,q.y);\n}\n\n// correct outside, incorrect inside\nfloat sdJ( in vec2 p )\n{\n    vec2 q = abs", "ated by the given UV coordinates.\n    vec3 color = vec3(0.0);\n    \n    // Calculate the grid size based on the UV coordinates.\n    float gridSize = 10.0;\n    \n    // Calculate the grid position based on the UV coordinates.\n    vec2 gridPos = floor(uv * gridSize);\n    \n    // Determine the color based on the grid position.\n    if (mod(gridPos.x + gridPos.y, 2.0) < 1.0) {\n        color = vec3(1.0);\n    }\n    \n    return color;\n}", "est\n    vec2 ap = p - a, ab = b - a;\n    float d = dot( ap, ab ) / dot( ab, ab );\n    if( d < 0.0 ) return a;\n    if( d > 1.0 ) return b;\n    return a + d * ab;\n}\n\n// Distance from point to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    return length( cloSegment( p, a, b, th ) - p );\n}\n\n// Distance from point to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    return length( cloSegment( p, a, b ) - p );\n}\n\n// Distance from point to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b, in float th, out vec2 c )\n{\n    vec2 ap = p - a, ab = b - a;\n    float d = dot( ap, ab ) / dot( ab, ab );\n    if( d < 0.0 ) { c = a; return length( ap ); }\n    if( d > 1.0 ) { c = b; return length( p - b ); }\n    c = a + d * ab;\n    return length( ap );\n}\n\n// Distance from point to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b, out vec2 c )\n{\n    vec2 ap = p - a, ab = b - a;\n    float d = dot( ap, ab ) / dot( ab, ab );\n    if( d < 0.0 ) { c = a; return length( ap ); }\n    if( d > 1.0 ) { c = b; return length( p - b ); }\n    c = a + d * ab;\n    return length( ap );\n}\n\n// Distance from point to segment\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b, in float th, out vec2 c, out float d )\n{\n    vec2 ap = p - a, ab =", "(\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}", " toBox(p,b);\n  float d = length(p);\n  if( d<r ) return p;\n  return p*r/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r )\n{ toBox(p,b);\n  float d = length(p);\n  if( d<r.x ) return p;\n  return p*r.x/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 a )\n{ toBox(p,b);\n  float d = length(p);\n  if( d<r.x ) return p;\n  return p*r.x/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 a, in vec2 c )\n{ toBox(p,b);\n  float d = length(p);\n  if( d<r.x ) return p;\n  return p*r.x/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 a, in vec2 c, in vec2 d )\n{ toBox(p,b);\n  float d = length(p);\n  if( d<r.x ) return p;\n  return p*r.x/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 a, in vec2 c, in vec2 d, in vec2 e )\n{ toBox(p,b);\n  float d = length(p);\n  if( d<r.x ) return p;\n  return p*r.x/d;\n}\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, in vec2 r, in vec2 a, in vec2 c, in vec2 d, in vec2 e, in vec2 f", "\n    vec2 q = abs(p)-b+r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, float r )\n{\n    vec3 q = abs(p)-b+r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    vec3 q = abs(p)-b+r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r.x;\n}", " box_size = b;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to sphere\nfloat sdSphere( in vec3 p, in float s )\n{ return length(p)-s;\n}\n\n// distance to cylinder\nfloat sdCylinder( in vec3 p, in vec3 c )\n{ return length(p.xz-c.xy)-c.z;\n}\n\n// distance to torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{ vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// distance to plane\nfloat sdPlane( in vec3 p, in vec3 n, in float h )\n{ return dot(p,n)+h;\n}\n\n// distance to capsule\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{ vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// distance to cone\nfloat sdCone( in vec3 p, in vec3 c, in float r, in float h )\n{ vec2 q = vec2( length(p.xz), p.y );\n  float d1 = -q.y-c.z;\n  float d2 = max( dot(q,c.xy), q.y-c.z );\n  return length(q-c.xy*clamp(d1/c.x,0.0,1.0)) * sign(d2);\n}\n\n// distance to ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{ return (length( p/r )-1.0)*min(min(r.x,r.y),r.z);\n}\n\n// distance to torus\nfloat sdTorus( in vec3", "\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3D Noise from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D FBM\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// 3D Curl Noise\nvec3 curlNoise(vec3 p)\n{\n    const float e =.1;\n    vec3 dx = vec3(e  , 0.0, 0.0);\n    vec3 dy = vec3(0.0, e , 0.0);\n    vec3 dz = vec3(0.0, 0.0, e  );\n    return (noise(p + dx) - noise(p - dx) +\n            noise(p + dy) - noise(p - dy) +\n            noise(p + dz) - noise(p - dz))/e;\n}\n\n// 3D Voronoi\nvec3 voronoi(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(", "\n    return fract(sin(dot(x, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x, vec4(12.9898, 78.233, 45.164, 20.765))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(uint x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(bool x)\n{\n    return fract(sin(float(x)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x, int y)\n{\n    return fract(sin(float(x + y)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(uint x, uint y)\n{\n    return fract(sin(float(x + y)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(bool x, bool y)\n{\n    return fract(sin(float(x + y)) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(int x, int y, int z)\n{\n    return fract(sin(float(x + y + z)) * 43758.5453);\n}\n\n//", "(st.x * 12.9898 + st.y * 78.233);\n    return fract(sin(vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)))) * 43758.5453);\n}\n\n// From iq\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n                   dot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n               mix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n                   dot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// From iq\nfloat fbm(vec2 st){\n    float value = 0.0;\n    float amplitude =.5;\n    for (int i = 0; i < 4; i++){\n        value += amplitude * noise(st);\n        st *= 2.0;\n        amplitude *=.5;\n    }\n    return value;\n}\n\n// From iq\nfloat fbm2(vec2 st){\n    float value = 0.0;\n    float amplitude =.5;\n    for (int i = 0; i < 4; i++){\n        value += amplitude * noise(st);\n        st *= 2.0;\n        amplitude *=.5;\n    }\n    return value;\n}\n\n// From iq\nfloat fbm3(vec2 st){\n    float value = 0.0;\n    float amplitude =.5;\n    for (int i", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(mix(dot(u, vec2(0.0, 0.0) - f + i), \n                   dot(u, vec2(0.0, 1.0) - f + i), f.x),\n               mix(dot(u, vec2(1.0, 0.0) - f + i), \n                   dot(u, vec2(1.0, 1.0) - f + i), f.x), f.y);\n}\n\nfloat triValueNoise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    vec3 u = f*f*(3.0-2.0*f);\n    \n    return mix(mix(mix(dot(u, vec3(0.0, 0.0, 0.0) - f + i), \n                       dot(u, vec3(0.0, 1.0, 0.0) - f + i), f.x),\n                   dot(u, vec3(0.0, 0.0, 1.0) - f + i), f.y),\n               mix(mix(dot(u, vec3(1.0, 0.0, 0.0) - f + i), \n                       dot(u, vec3(1.0, 1.0, 0.0) - f + i), f.x),\n                   dot(u, vec3(1.0, 0.0, 1.0) - f + i), f.y), f.z);\n}", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 4; ++i)\n    {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}", "p = vec2(0.0);\n    p.x = 0.5 + 0.5*sin(x.x*0.5);\n    p.y = 0.5 + 0.5*sin(x.y*0.5);\n    return p.x*p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv;\n    p.x = 2.0*p.x - 1.0;\n    p.y = 2.0*p.y - 1.0;\n    float c = pattern(p);\n    fragColor = vec4(vec3(c),1.0);\n}", "\n    return 4.0 * atan(1.0) / (x * y);\n}\n\nfloat texelSolidAngle(vec2 texelCoord, vec2 texelSize)\n{\n    float x = texelCoord.x * texelSize.x;\n    float y = texelCoord.y * texelSize.y;\n    float dx = x + 0.5 * texelSize.x;\n    float dy = y + 0.5 * texelSize.y;\n    float dxx = dx - 0.5 * texelSize.x;\n    float dyy = dy - 0.5 * texelSize.y;\n    float area = areaElement(dx, dy) - areaElement(dxx, dy) - areaElement(dx, dyy) + areaElement(dxx, dyy);\n    return area;\n}\n\nvec3 sampleCubeMap(samplerCube cubeMap, vec3 direction, vec2 texelSize)\n{\n    vec3 color = vec3(0.0);\n    float totalWeight = 0.0;\n    for (int i = 0; i < 6; i++)\n    {\n        vec3 direction = vec3(0.0);\n        direction.x = (i == 0)? -1.0 : (i == 1)? 1.0 : 0.0;\n        direction.y = (i == 2)? -1.0 : (i == 3)? 1.0 : 0.0;\n        direction.z = (i == 4)? -1.0 : (i == 5)? 1.0 : 0.0;\n        vec3 sampleColor = texture(cubeMap, direction).rgb;\n        float weight = texelSolidAngle(vec2(i, 0.0), texelSize);\n        color += sampleColor * weight;\n        totalWeight += weight;\n    }\n    return color / totalWeight;\n}", "'\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat noise33(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec2 uv = (i.xy + vec2(37.0, 17.0) * i.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fbm33(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise33(p); p = p * 2.02;\n    f += 0.2500 * noise33(p); p = p * 2.03;\n    f += 0.1250 * noise33(p); p = p * 2.01;\n    f += 0.0625 * noise33(p);\n    return f / 0.9375;\n}\n\nfloat fbm33(vec3 p, float octaves) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < octaves; i++) {\n        f += amp * noise33(p);\n        p = p * 2.02;\n        amp *= 0.5;\n    }\n    return f;\n}\n\nfloat fbm33(vec3 p, float octaves, float lacunarity, float gain) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < octaves; i++) {\n        f += amp * noise33(p);\n        p = p * lacunarity;\n", " https://www.shadertoy.com/view/XsX3zB\n    vec3 s = floor(p + dot(p, vec3(7.0, 157.0, 113.0)));\n    vec3 x = p - s + dot(s, vec3(7.0, 157.0, 113.0));\n    vec3 x_ = fract(x * 1e-4);\n    x = x - floor(x);\n    vec3 w = x_ * x_ * (3.0 - 2.0 * x_);\n    vec3 a = x + w - 0.5;\n    vec3 a_ = abs(a);\n    vec3 a_2 = a_ * a_;\n    vec3 d = a_2 * a_2 * vec3(0.0, 0.2, 0.4);\n    float t = 0.0;\n    t += dot(a, vec3(0.0, 0.5, 1.0)) * 0.15915494309189533576888376337251;\n    t += dot(d, vec3(0.0, 0.1, 0.2));\n    return t;\n}", " for( int i=0; i<2; i++ ) x = vec2( dot(x,vec2(127.1,311.7)), dot(x,vec2(269.5,183.3)) ); return fract(sin(x)*43758.5453); }\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    vec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm2( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;", " in float l2 = dot(b-a,b-a);\n  in float t = clamp( dot(p-a,b-a) / l2, 0.0, 1.0 );\n  return length( p - a - t*(b-a) );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{ return length(p)-r;\n}\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{ in vec3 pa = p - a, ba = b - a;\n  in float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b )\n{ in vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( in vec3 p, in vec2 t )\n{ in vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{ return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{ return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec3 c )\n{ return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{ return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdRoundCylinder( in vec3 p, in float r1, in float r2, in float h )\n{ in vec2 d = vec2(length(p.xz)-2.0*r1+r2,abs(p.y)-h);\n  return min", " is the distance to the box\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) +\n           length(max(d,0.0)) - r.x;\n}", "\n    // The projection of a disk is an ellipse.\n    // The center of the ellipse is the projection of the center of the disk.\n    // The major and minor axes are the projections of the radii of the disk.\n    // The major axis is the projection of the normal of the disk.\n    // The minor axis is the projection of the normal of the disk rotated by 90 degrees.\n    // The major and minor axes are perpendicular to each other.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes are parallel to the projection of the radii of the disk.\n    // The major and minor axes", "// 2D Random\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash13(vec3 p3)\n{// 3D Random\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash14(vec4 p4)\n{// 4D Random\n    p4  = fract(p4 *.1031);\n    p4 += dot(p4, p4.wzxy + 31.32);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nfloat Hash21(vec2 p)\n{// 2D Random\n    vec3 p3  = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash31(vec3 p3)\n{// 3D Random\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash41(vec4 p4)\n{// 4D Random\n    p4  = fract(p4 *.1031);\n    p4 += dot(p4, p4.wzxy + 31.32);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nfloat Hash22(vec2 p)\n{// 2D Random\n    vec3 p3  = fract(vec3(p.xyx) *.103", "\n    float a = acs.x, c = acs.y;\n    float b = bn * a;\n    float n = m * PI / bn;\n    float d = 0.0;\n    float s = 1.0;\n    float t = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n", "\n    const float eps = 0.0001;\n    const vec2  d   = vec2(1.0,-1.0);\n\n    return normalize( d.xyy*sdf( p + d.xyy*eps ) + \n                      d.yyx*sdf( p + d.yyx*eps ) + \n                      d.yxy*sdf( p + d.yxy*eps ) + \n                      d.xxx*sdf( p + d.xxx*eps ) );\n}", "(\n    float t = t0;\n    float res = 1.0;\n    for(int i = 0; i < 32; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, 64.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(res < EPSILON || t > t1) break;\n    }\n    return clamp(res, 0.0, 1.0);\n)\n}", "//AO\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcAO2( in vec3 pos, in vec3 nor )\n{//AO\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcAO3( in vec3 pos, in vec3 nor )\n{//AO\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcAO4( in vec3 pos, in vec3 nor )\n{//AO\n    ", "(\n    float s = sin(angle);\n    float c = cos(angle);\n    float t = 1.0 - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    return mat3(\n        t * x * x + c, t * x * y - s * z, t * x * z + s * y,\n        t * x * y + s * z, t * y * y + c, t * y * z - s * x,\n        t * x * z - s * y, t * y * z + s * x, t * z * z + c\n    );\n)\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    return createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), angle);\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    return createRotationMatrixAxisAngle(vec3(0.0, 1.0, 0.0), angle);\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    return createRotationMatrixAxisAngle(vec3(0.0, 0.0, 1.0), angle);\n}\n\n// Helper function generating a rotation matrix around the x, y, and z axes by the angles\nmat3 createRotationMatrixXYZ(float xAngle, float yAngle, float zAngle) {\n    return createRotationMatrixX(xAngle) * createRotationMatrixY(yAngle) * createRotationMatrixZ(zAngle);\n}\n\n// Helper function generating a rotation matrix around the x, y, and z axes by the angles\nmat3 createRotationMatrixXYZ(vec3 angles) {\n    return createRotationMatrixXYZ(angles.x, angles.y, angles.z);\n}\n\n// Helper function generating a rotation matrix around the x, y, and z axes by the angles\nmat3 createRotationMatrixXYZ(float xAngle", "er\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    return rd;\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat rand(vec2 uv, float seed) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453 + seed);\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat rand(vec2 uv, float seed, float seed2) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453 + seed + seed2);\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat rand(vec2 uv, float seed, float seed2, float seed3) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453 + seed + seed2 + seed3);\n}\n\n// Helper function that generates a random number based on UV and mouse\nfloat rand(vec2 uv, float seed, float seed2, float seed3, float seed4) {\n    return fract(sin(dot(uv, vec2(", "\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453 + sin(time) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9898,78.233, 45.454))) * 43758.5453 + sin(time) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9898,78.233, 45.454))) * 43758.5453);\n}\n\n// 2d noise\nfloat noise2d(vec2 co){\n    vec2 i = floor(co);\n    vec2 f = fract(co);\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(rand2d(i), rand2d(i + vec2(1.0, 0.0)), u.x), mix(rand2d(i + vec2(0.0, 1.0)), rand2d(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// 3d noise\nfloat noise3d(vec3 co){\n    vec3 i = floor(co);\n    vec3 f = fract(co);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix(rand3d(i), rand3d(i + vec3(1.0, 0.0, 0.0)), u.x), mix(rand3d(i + vec3(0.0, 1.0, 0.0)), rand3d(i + vec3(1", "nopure;\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){nopure;\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\n// Hash for 1d values\nfloat rand1d(float p){nopure;\n    return fract(sin(p)*43758.5453);\n}\n\n// Hash for 1d values\nfloat rand1d(float p, float seed){nopure;\n    return fract(sin(p+seed)*43758.5453);\n}\n\n// Hash for 2d values\nfloat rand2d(float p, float seed){nopure;\n    return fract(sin(p+seed)*43758.5453);\n}\n\n// Hash for 3d values\nfloat rand3d(float p, float seed){nopure;\n    return fract(sin(p+seed)*43758.5453);\n}\n\n// Hash for 4d values\nfloat rand4d(float p, float seed){nopure;\n    return fract(sin(p+seed)*43758.5453);\n}\n\n// Hash for 2d values\nfloat rand2d(vec2 p, float seed){nopure;\n    return fract(sin(dot(p,vec2(127.1,311.7))+seed)*43758.5453);\n}\n\n// Hash for 3d values\nfloat rand3d(vec3 p, float seed){nopure;\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7))+seed)*43758.5453);\n}\n\n// Hash for 4d values\nfloat rand4d(vec4 p, float seed){nopure;\n    return fract(sin(dot(p,vec4(127.1,311.7, 74.7, 10.3))+seed)*43758.5453);\n}\n\n// Hash for 2d values\nfloat rand2d(vec2 p, vec2", "DIM=3;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D value noise\nfloat noise2d(vec2 x){DIM=2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p+f);\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).xy;\n    return mix(rg.x, rg.y, f.y);\n}\n\n// 1D value noise\nfloat noise1d(float x){DIM=1;\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float uv = (p+f);\n    float rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).x;\n    return mix(rg, rg, f);\n}\n\n// 3D perlin noise\nfloat perlin3d(vec3 x){DIM=3;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n//", "(p.x+p.y+p.z)*0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "ible\n    float f = 0.0;\n    float a = 0.5;\n    for(int i = 0; i < 4; i++){\n        f += a * noise(p);\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return f;\n}", " isClouds = true;\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tvec3 p1 = p;\n\tvec3 p2 = p;\n\tvec3 p3 = p;\n\tvec3 p4 = p;\n\tvec3 p5 = p;\n\tvec3 p6 = p;\n\tvec3 p7 = p;\n\tvec3 p8 = p;\n\tvec3 p9 = p;\n\tvec3 p10 = p;\n\tvec3 p11 = p;\n\tvec3 p12 = p;\n\tvec3 p13 = p;\n\tvec3 p14 = p;\n\tvec3 p15 = p;\n\tvec3 p16 = p;\n\tvec3 p17 = p;\n\tvec3 p18 = p;\n\tvec3 p19 = p;\n\tvec3 p20 = p;\n\tvec3 p21 = p;\n\tvec3 p22 = p;\n\tvec3 p23 = p;\n\tvec3 p24 = p;\n\tvec3 p25 = p;\n\tvec3 p26 = p;\n\tvec3 p27 = p;\n\tvec3 p28 = p;\n\tvec3 p29 = p;\n\tvec3 p30 = p;\n\tvec3 p31 = p;\n\tvec3 p32 = p;\n\tvec3 p33 = p;\n\tvec3 p34 = p;\n\tvec3 p35 = p;\n\tvec3 p36 = p;\n\tvec3 p37 = p;\n\tvec3 p38 = p;\n\tvec3 p39 = p;\n\tvec3 p40 = p;\n\tvec3 p41 = p;\n\tvec3 p42 = p;\n\tvec3 p43 = p;\n\tvec3 p44 = p;\n\tvec3 p45 = p;\n\tvec3 p46 = p;\n\tvec3 p47 = p;\n\tvec3 p48 = p;\n\tvec3 p49 = p;\n\tvec3 p50 = p;\n\tvec3 p51 = p;\n\tvec3 p52 = p;\n\tvec3 p53 = p;\n\tvec3 p54 = p;\n\tvec", "\n    vec3 color = vec3(0.0);\n    float coverage = 0.0;\n    float step = 0.01;\n    float direction = 0.0;\n    float random2 = random * 0.5 + 0.5;\n    for(float i = 0.0; i < 1.0; i += step){\n        float height = 0.0;\n        float height2 = 0.0;\n        float height3 = 0.0;\n        float height4 = 0.0;\n        float height5 = 0.0;\n        float height6 = 0.0;\n        float height7 = 0.0;\n        float height8 = 0.0;\n        float height9 = 0.0;\n        float height10 = 0.0;\n        float height11 = 0.0;\n        float height12 = 0.0;\n        float height13 = 0.0;\n        float height14 = 0.0;\n        float height15 = 0.0;\n        float height16 = 0.0;\n        float height17 = 0.0;\n        float height18 = 0.0;\n        float height19 = 0.0;\n        float height20 = 0.0;\n        float height21 = 0.0;\n        float height22 = 0.0;\n        float height23 = 0.0;\n        float height24 = 0.0;\n        float height25 = 0.0;\n        float height26 = 0.0;\n        float height27 = 0.0;\n        float height28 = 0.0;\n        float height29 = 0.0;\n        float height30 = 0.0;\n        float height31 = 0.0;\n        float height32 = 0.0;\n        float height33 = 0.0;\n        float height34 = 0.0;\n        float height35 = 0.0;\n        float height36 = 0.0;\n        float height37 = 0.0;\n        float height38 = 0.0;\n        float height39 = 0.0", "ight, float random){\n    vec3 point = pointStart + (pointEnd - pointStart) * dist;\n    vec3 ray = normalize(pointEnd - pointStart);\n    float fog = 1.0 - exp(-dist * 0.01);\n    float density = 0.0;\n    for(int i = 0; i < 32; i++){\n        float d = density * 0.1;\n        vec3 p = point + ray * d;\n        float noise = texture(iChannel0, p.xz * 0.01).r;\n        noise = smoothstep(0.0, 1.0, noise);\n        density += noise * 0.01;\n    }\n    density = clamp(density, 0.0, 1.0);\n    vec3 color = mix(background, vec3(1.0), density);\n    color = mix(color, background, fog);\n    return color;\n}", "er\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color*(a*color+b))/(color*(c*color+d)+e), 0.0, 1.0);\n}"]}