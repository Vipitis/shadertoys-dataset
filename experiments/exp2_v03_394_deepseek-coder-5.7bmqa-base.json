{"generations": [" return 0.282095; }\nfloat SH_1_1( in vec3 s ) { return 0.488603 * s.y; }\nfloat SH_1_0( in vec3 s ) { return 0.488603 * s.z; }\nfloat SH_1_m1( in vec3 s ) { return 0.488603 * s.x; }\nfloat SH_2_2( in vec3 s ) { return 1.092548 * s.x * s.y; }\nfloat SH_2_1( in vec3 s ) { return 1.092548 * s.y * s.z; }\nfloat SH_2_0( in vec3 s ) { return 0.315392 * (3.0 * s.z * s.z - 1.0); }\nfloat SH_2_m1( in vec3 s ) { return 1.092548 * s.x * s.z; }\nfloat SH_2_m2( in vec3 s ) { return 0.546274 * (s.x * s.x - s.y * s.y); }\nfloat SH_3_3( in vec3 s ) { return 0.590044 * s.x * s.y * s.z; }\nfloat SH_3_2( in vec3 s ) { return 2.890611 * s.y * s.z * s.x; }\nfloat SH_3_1( in vec3 s ) { return 0.457046 * (5.0 * s.z * s.z * s.z - 3.0 * s.z); }\nfloat SH_3_0( in vec3 s ) { return 0.373176 * (7.0 * s.z * s.z - 1.0); }\nfloat SH_3_m1( in vec3 s ) { return 2.503343 * s.x * s.z", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line segment\nfloat lineSegment( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat ray( in vec2 a, in vec2 b, in vec2 p )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat ray( in vec3 a, in vec3 b, in vec3 p )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat ray( in vec4 a, in vec4 b, in vec4 p )\n{\n    vec4 pa = p - a;\n    vec4 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat ray( in vec2 a, in vec2 b, in vec2 p, in float r )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h", "\n    return (v.x >= 0.0)? v : vec2(r.x - v.x, r.y - v.y);\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r )\n{\n    return (v.x >= 0.0)? v : vec3(r.x - v.x, r.y - v.y, r.z - v.z);\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r )\n{\n    return (v.x >= 0.0)? v : vec4(r.x - v.x, r.y - v.y, r.z - v.z, r.w - v.w);\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r, in vec2 s )\n{\n    return (v.x >= 0.0)? v : vec2(r.x - v.x, r.y - v.y);\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec3 flipIfNeg( in vec3 v, in vec3 r, in vec3 s )\n{\n    return (v.x >= 0.0)? v : vec3(r.x - v.x, r.y - v.y, r.z - v.z);\n}\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec4 flipIfNeg( in vec4 v, in vec4 r, in vec4 s )\n{\n    return (v.x >= 0.0)? v : vec4(r.x - v.x, r.y - v.y, r.z - v.z, r.w - v.w);\n", "\n    return (v.x < 0.0)? vec2(-v.x, v.y) : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec2 reflIfPos( in vec2 v, in vec2 r )\n{\n    return (v.x > 0.0)? vec2(-v.x, v.y) : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec3 reflIfNeg( in vec3 v, in vec3 r )\n{\n    return (v.x < 0.0)? vec3(-v.x, v.y, v.z) : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec3 reflIfPos( in vec3 v, in vec3 r )\n{\n    return (v.x > 0.0)? vec3(-v.x, v.y, v.z) : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec4 reflIfNeg( in vec4 v, in vec4 r )\n{\n    return (v.x < 0.0)? vec4(-v.x, v.y, v.z, v.w) : v;\n}\n\n// Reflect v if in the positive half plane defined by r (this works in 3D too)\nvec4 reflIfPos( in vec4 v, in vec4 r )\n{\n    return (v.x > 0.0)? vec4(-v.x, v.y, v.z, v.w) : v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r, in vec2 n )\n{\n    return (v.x < 0.0)? vec2(-v.x, v.y) :", "\n    return (v.x*r.x<0.0)? vec2(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in vec2 v, in vec2 r )\n{\n    return (v.x*r.x>0.0)? vec2(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec3 clipIfNeg( in vec3 v, in vec3 r )\n{\n    return (v.x*r.x<0.0)? vec3(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec3 clipIfPos( in vec3 v, in vec3 r )\n{\n    return (v.x*r.x>0.0)? vec3(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec4 clipIfNeg( in vec4 v, in vec4 r )\n{\n    return (v.x*r.x<0.0)? vec4(0.0) : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec4 clipIfPos( in vec4 v, in vec4 r )\n{\n    return (v.x*r.x>0.0)? vec4(0.0) : v;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r, in vec2 s )\n{\n    return (v.x*r.x<0.0)? s : v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec2 clipIfPos( in ve", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min( length( pa - ba*h ),\n                length( pa - ba*h - sign(ba)*w1*normalize(ba)*clamp( dot(pa,ba)/dot(ba,ba), -1.0, 1.0 ) ) - w2 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1 )\n{\n    return sdArrow( p, a, b, w1, 0.0 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b )\n{\n    return sdArrow( p, a, b, 0.01 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, float w1 )\n{\n    return sdArrow( p, a, a + vec2(1.0,0.0), w1 );\n}\n\nfloat sdArrow( in vec2 p, float w1 )\n{\n    return sdArrow( p, vec2(0.0,0.0), vec2(1.0,0.0), w1 );\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float t )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min( length( pa - ba*h ),\n                length( pa - ba*h - sign(ba)*w1*normalize(ba)*clamp( dot(pa,ba)/dot(ba,ba), -1.0, 1.0 ) ) - w2 ) * t;\n}\n\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1", "\n    vec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\n    vec3 sunCol2 = vec3(255.0, 255.0, 255.0) / 4255.0;\n    float sunAngle = dot(rayDir, sunDir);\n    float sunAngle2 = dot(rayDir, -sunDir);\n    float sunAngle3 = dot(rayDir, normalize(vec3(sunDir.x, 0.0, sunDir.z)));\n    float sunAngle4 = dot(rayDir, normalize(vec3(-sunDir.x, 0.0, sunDir.z)));\n    float sunAngle5 = dot(rayDir, normalize(vec3(sunDir.x, 0.0, -sunDir.z)));\n    float sunAngle6 = dot(rayDir, normalize(vec3(-sunDir.x, 0.0, -sunDir.z)));\n    float sunAngle7 = dot(rayDir, normalize(vec3(0.0, sunDir.y, sunDir.z)));\n    float sunAngle8 = dot(rayDir, normalize(vec3(0.0, -sunDir.y, sunDir.z)));\n    float sunAngle9 = dot(rayDir, normalize(vec3(0.0, sunDir.y, -sunDir.z)));\n    float sunAngle10 = dot(rayDir, normalize(vec3(0.0, -sunDir.y, -sunDir.z)));\n    float sunAngle11 = dot(rayDir, normalize(vec3(sunDir.x, sunDir.y, 0.0)));\n    float sunAngle12 = dot(rayDir, normalize(vec3(-sunDir.x, sunDir.y, 0.0)));\n    float sunAngle13 = dot(rayDir, normalize(vec3(sunDir.x, -sunDir.y, 0.0)));", "\n    vec4 a = 2.0 * p1;\n    vec4 b = p2 - p0;\n    vec4 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec4 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n    return a + (b * t) + (c * t * t) + (d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec3 CatmullRom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    vec3 a = 2.0 * p1;\n    vec3 b = p2 - p0;\n    vec3 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec3 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n    return a + (b * t) + (c * t * t) + (d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec2 CatmullRom(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    vec2 a = 2.0 * p1;\n    vec2 b = p2 - p0;\n    vec2 c = 2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3;\n    vec2 d = -p0 + 3.0 * p1 - 3.0 * p2 + p3;\n    return a + (b * t) + (c * t * t) + (d * t * t * t);\n}\n\n// This is a spline used for the camera path\nvec4 Hermite(vec4 p0, vec4 p1, vec4 m0, vec4 m1, float t)\n{\n    vec4 a = 2.0 *", "\n\tfloat product = 1.0;\n\tfloat scale = 1.0;\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 n = vec3(p.x, p.y, p.z * scale);\n\t\tsum += abs(nudge - abs(n.x) - abs(n.y) - abs(n.z)) * scale;\n\t\tscale *= 2.0;\n\t\tproduct *= 0.5;\n\t}\n\treturn sum * normalizer - 0.5;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nfloat SpiralNoise(vec2 p)\n{\n\tfloat product = 1.0;\n\tfloat scale = 1.0;\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec2 n = vec2(p.x, p.y * scale);\n\t\tsum += abs(nudge - abs(n.x) - abs(n.y)) * scale;\n\t\tscale *= 2.0;\n\t\tproduct *= 0.5;\n\t}\n\treturn sum * normalizer - 0.5;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nfloat SpiralNoise(vec3 p)\n{\n\tfloat product = 1.0;\n\tfloat scale = 1.0;\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 n = vec3(p.x, p.y, p.z * scale);\n\t\tsum += abs(nudge - abs(n.x) - abs", "\n    vec4 p0 = texture(CameraPositions, t);\n    vec4 p1 = texture(CameraPositions, t + 0.0001);\n    vec4 p2 = texture(CameraPositions, t + 0.0002);\n    vec4 p3 = texture(CameraPositions, t + 0.0003);\n\n    float tt = t * t;\n    float ttt = tt * t;\n\n    vec4 a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;\n    vec4 b = 1.0 * p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3;\n    vec4 c = -0.5 * p0 + 0.5 * p2;\n    vec4 d = p1;\n\n    return a * ttt + b * tt + c * t + d;\n}\n\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamDir(float t)\n{\n    vec4 p0 = texture(CameraDirections, t);\n    vec4 p1 = texture(CameraDirections, t + 0.0001);\n    vec4 p2 = texture(CameraDirections, t + 0.0002);\n    vec4 p3 = texture(CameraDirections, t + 0.0003);\n\n    float tt = t * t;\n    float ttt = tt * t;\n\n    vec4 a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;\n    vec4 b = 1.0 * p0 - 2.5 * p1 + 2.0 * p2 - 0.5 * p3;\n    vec4 c = -0.5 * p0 + 0.5 * p2;\n    vec4 d = p1;\n\n    return a * ttt +", "\n    return fract(sin(u) * 43758.5453123);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat Hash3d(vec3 uv)\n{\n    return fract(sin(dot(uv, vec3(12.9898, 78.233, 154.545))) * 43758.5453123);\n}\n\nfloat Noise1d(float u)\n{\n    float i = floor(u);\n    float f = fract(u);\n    float a = Hash1d(i);\n    float b = Hash1d(i + 1.0);\n    return mix(a, b, f);\n}\n\nfloat Noise2d(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = Hash2d(i);\n    float b = Hash2d(i + vec2(1.0, 0.0));\n    float c = Hash2d(i + vec2(0.0, 1.0));\n    float d = Hash2d(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat Noise3d(vec3 uv)\n{\n    vec3 i = floor(uv);\n    vec3 f = fract(uv);\n    float a = Hash3d(i);\n    float b = Hash3d(i + vec3(1.0, 0.0, 0.0));\n    float c = Hash3d(i", "\n\tfloat product = 1.0;\n\tfloat freq = 4.0;\n\tfloat n = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += abs(pnoise(vec3(p.x*freq, p.y*freq, p.z*freq), vec3(10.0)) * product);\n\t\tfreq *= 2.0;\n\t\tproduct *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 2D version of the above noise function.\nfloat RustNoise2D(vec2 p)\n{\n\tfloat product = 1.0;\n\tfloat freq = 4.0;\n\tfloat n = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += abs(pnoise(vec2(p.x*freq, p.y*freq), vec2(10.0)) * product);\n\t\tfreq *= 2.0;\n\t\tproduct *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 1D version of the above noise function.\nfloat RustNoise1D(float p)\n{\n\tfloat product = 1.0;\n\tfloat freq = 4.0;\n\tfloat n = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += abs(pnoise(p*freq, 10.0) * product);\n\t\tfreq *= 2.0;\n\t\tproduct *= 0.5;\n\t}\n\treturn n * normalizer;\n}\n\n// This is a 3D version of the above noise function.\nfloat RustNoise3D(vec3 p)\n{\n\tfloat product = 1.0;\n\tfloat freq = 4.0;\n\tfloat n = 0.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tn += abs(pnoise(vec3(p.x*freq, p.y*freq, p.z*freq), vec3(", "\n    float d = p.y;\n    float s = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        p.xz *= mat2(0.707106781, -0.707106781, 0.707106781, 0.707106781);\n        p.xz += vec2(0.5, 0.5);\n        p.xz = abs(p.xz - 2.0 * clamp(p.xz, 0.0, 1.0));\n        p.xz -= 2.0 * min(p.xz, 0.0);\n        p.xz -= 0.5;\n        p.xz *= s;\n        s *= 1.5;\n        p.y -= 0.5 / s;\n        p.y = abs(p.y) - 0.5 / s;\n        d = min(d, length(p.xz) * 0.866025404); // \u221a3/3\n    }\n    return d * 0.6;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = p.y;\n    float s = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        p.xz *= mat2(0.707106781, -0.707106781, 0.707106781, 0.707106781);\n        p.xz += vec2(0.5, 0.5);\n        p.xz = abs(p.xz - 2.0 * clamp(p.xz, 0.0, 1.0));\n        p.xz -= 2.0 * min(p.xz, 0.0);\n        p.xz", "\n    vec3 envColor = vec3(0.0);\n\n    // Softbox\n    float softbox = Softbox(rayDir, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), 0.01);\n    envColor += softbox * vec3(0.0, 0.0, 0.0);\n\n    // Lights\n    float light = Light(rayDir, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.01);\n    envColor += light * vec3(1.0, 1.0, 1.0);\n\n    // Fade\n    float fade = Fade(rayDir, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.01, 0.0);\n    envColor += fade * vec3(1.0, 1.0, 1.0);\n\n    return envColor;\n}\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\n// The softbox is rotated 45 degrees around the Y axis.\nvec3 GetEnvColor3(vec3 rayDir, vec3 sunDir)\n{\n    vec3 envColor = vec3(0.0);\n\n    // Softbox\n    float softbox = Softbox(rayDir, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), 0.01);\n    envColor += softbox * vec3(0.0, 0.0, 0.0);\n\n    // Lights\n    float light = Light(rayDir, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ", "\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b.x, a.x, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( a.x, b.x, h ) + k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b.x, a.x, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat smax( vec3 a, vec3 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix(", "\n    vec3 L = spherePos - pos;\n    float tca = dot(L, dirVecPLZNormalizeMeFirst);\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > rad * rad) return -1.0;\n    float thc = sqrt(rad * rad - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\n    if (t0 > t1) {\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n\n    if (t0 < 0) {\n        t0 = t1; // if t0 is negative, let's use t1 instead \n        if (t0 < 0) return -1.0; // both t0 and t1 are negative \n    }\n\n    return t0;\n}\n\nvec3 getNormal(vec3 pos, vec3 spherePos, float rad)\n{\n    return normalize(pos - spherePos);\n}\n\nvec3 getColor(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, vec3 sphereColor)\n{\n    float t = SphereIntersect(pos, dirVecPLZNormalizeMeFirst, spherePos, rad);\n    if (t > 0.0) {\n        vec3 normal = getNormal(pos + dirVecPLZNormalizeMeFirst * t, spherePos, rad);\n        return sphereColor;\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid main()\n{\n    vec3 spherePos = vec3(0.0, 0.0, -10.0);\n    float rad = 1.0;\n    vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 dirVec = normalize(vec3(0.0, 0.0, ", "\n    // Calculate the distance to the object.\n    float d = sdSphere(p, 1.0);\n\n    // Calculate the distance field.\n    return vec2(d, 0.0);\n}\n\n// Calculate the normal of the object.\nvec3 CalculateNormal(vec3 p)\n{\n    // Calculate the distance to the object.\n    float d = DistanceToObject(p).x;\n\n    // Calculate the normal.\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(\n        DistanceToObject(p - e.xyy).x,\n        DistanceToObject(p - e.yxy).x,\n        DistanceToObject(p - e.yyx).x\n    );\n\n    // Return the normal.\n    return normalize(n);\n}\n\n// Calculate the color of the object.\nvec3 CalculateColor(vec3 p)\n{\n    // Calculate the distance to the object.\n    float d = DistanceToObject(p).x;\n\n    // Calculate the color.\n    vec3 c = vec3(0.0);\n    if (d < 0.0)\n    {\n        c = vec3(1.0);\n    }\n\n    // Return the color.\n    return c;\n}\n\n// Calculate the color of the object.\nvec3 CalculateColor(vec3 p, vec3 n)\n{\n    // Calculate the distance to the object.\n    float d = DistanceToObject(p).x;\n\n    // Calculate the color.\n    vec3 c = vec3(0.0);\n    if (d < 0.0)\n    {\n        c = vec3(1.0);\n    }\n\n    // Return the color.\n    return c;\n}\n\n// Calculate the color of the object.\nvec3 CalculateColor(vec3 p, vec3 n, vec3 v)\n{\n    // Calculate the distance to the object.\n    float d = DistanceToObject(p).x;\n", "\n    return vec3(t, t, t);\n}\n\nvec3 mapD1(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD2(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD3(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD4(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD5(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD6(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD7(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD8(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD9(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD10(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD11(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD12(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD13(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD14(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD15(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD16(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD17(float t)\n{\n    return vec3(t, t, t);\n}\n\nvec3 mapD18(float t)\n", "\n    vec3 p = map(t);\n    vec3 dp = vec3(0.0);\n    dp.x = map(t + eps.x).x - p.x;\n    dp.y = map(t + eps.y).y - p.y;\n    dp.z = map(t + eps.z).z - p.z;\n    return dp;\n}\n\n// curve derivative (acceleration)\nvec3 mapD2(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = vec3(0.0);\n    dp.x = mapD1(t + eps.x).x - mapD1(t).x;\n    dp.y = mapD1(t + eps.y).y - mapD1(t).y;\n    dp.z = mapD1(t + eps.z).z - mapD1(t).z;\n    return dp;\n}\n\n// curve derivative (jerk)\nvec3 mapD3(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = vec3(0.0);\n    dp.x = mapD2(t + eps.x).x - mapD2(t).x;\n    dp.y = mapD2(t + eps.y).y - mapD2(t).y;\n    dp.z = mapD2(t + eps.z).z - mapD2(t).z;\n    return dp;\n}\n\n// curve derivative (snap)\nvec3 mapD4(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = vec3(0.0);\n    dp.x = mapD3(t + eps.x).x - mapD3(t).x;\n    dp.y = mapD3(t + eps.y).y - mapD3(t).y;\n    dp.z = mapD3(t + eps.z).z - mapD3(t).", "\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    vec3 ddp = mapD2(t);\n    return ddp;\n}\n\n// curve first derivative (velocity)\nvec3 mapD(float t)\n{\n    vec3 p = map(t);\n    vec3 dp = mapD(t);\n    return dp;\n}\n\n// curve position\nvec3 map(float t)\n{\n    vec3 p = vec3(0.0);\n    p.x = sin(t);\n    p.y = cos(t);\n    p.z = t;\n    return p;\n}\n\n// curve length\nfloat mapLength(float t0, float t1)\n{\n    float length = 0.0;\n    float dt = 0.001;\n    float t = t0;\n    while (t < t1)\n    {\n        vec3 p = map(t);\n        vec3 dp = mapD(t);\n        length += length(dp) * dt;\n        t += dt;\n    }\n    return length;\n}\n\n// curve length\nfloat mapLength(float t0, float t1, float dt)\n{\n    float length = 0.0;\n    float t = t0;\n    while (t < t1)\n    {\n        vec3 p = map(t);\n        vec3 dp = mapD(t);\n        length += length(dp) * dt;\n        t += dt;\n    }\n    return length;\n}\n\n// curve length\nfloat mapLength(float t0, float t1, float dt, float t)\n{\n    float length = 0.0;\n    while (t < t1)\n    {\n        vec3 p = map(t);\n        vec3 dp = mapD(t);\n        length += length(dp) * dt;\n        t += dt;\n    }\n    return length;\n}\n\n// curve length\nfloat mapLength(float t0, float t1, float dt, float t, float length)\n{\n    while (t < t", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return pa * pa - ba * ba + ba * h * h;\n}\n\n// signed squared distance between point and segment\nfloat ssPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    return dot( p - a, p - b );\n}\n\n// signed squared distance between point and triangle\nfloat ssPointTriangle( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ba = b - a, ca = c - a;\n    vec3 pa = p - a, pb = p - b, pc = p - c;\n    vec3 x = ba * dot( pa, ba ) - pa * dot( ba, ba );\n    vec3 y = ca * dot( pb, ca ) - pb * dot( ca, ca );\n    vec3 z = ba * dot( pc, ba ) - pc * dot( ba, ba );\n    vec3 xp = x * pa - pa * dot( x, pa );\n    vec3 yp = y * pb - pb * dot( y, pb );\n    vec3 zp = z * pc - pc * dot( z, pc );\n    float xs = dot( xp * xp, vec3( 1.0, 0.0, 1.0 ) );\n    float ys = dot( yp * yp, vec3( 1.0, 0.0, 1.0 ) );\n    float zs = dot( zp * zp, vec3( 1.0, 0.0, 1.0 ) );\n    return min( min( xs, ys ), zs );\n}\n\n// signed squared distance between point and tetrahedron\nfloat ssPointTetrahedron( in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec", "\n    vec3 ab = b - a;\n    vec3 ao = o - a;\n    float t = dot( ao, ab ) / dot( ab, ab );\n    if( t < 0.0 )\n    {\n        t = 0.0;\n    }\n    else if( t > 1.0 )\n    {\n        t = 1.0;\n    }\n    vec3 p = a + t * ab;\n    return vec2( length2( p - o ), t );\n}\n\n// unsigned squared distance between ray and triangle\nvec2 usqdTriangle( vec3 a, vec3 b, vec3 c, vec3 o, vec3 d )\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ao = o - a;\n    vec3 n = cross( ab, ac );\n    float t = dot( ao, n ) / dot( d, n );\n    vec3 p = o + t * d;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n    if( dot( ab, ap ) < 0.0 )\n    {\n        t = dot( bp, bp ) / dot( bp, bp );\n        p = b;\n    }\n    else if( dot( ac, cp ) < 0.0 )\n    {\n        t = dot( cp, cp ) / dot( cp, cp );\n        p = c;\n    }\n    else if( dot( ab, ap ) + dot( ac, ap ) > dot( ab, ab ) )\n    {\n        t = dot( ap, ap ) / dot( ap, ap );\n        p = a;\n    }\n    return vec2( length2( p - o ), t );\n}\n\n// unsigned squared distance between ray and quad\nvec2 usqdQuad( vec3 a, vec3 b, vec3 c, vec3 d, vec3 o, vec3 d )\n{\n    vec3 ab = b - a;\n", "\n    r = vec4(r.x,r.y,r.z,r.w);\n    vec2 q = abs(p);\n    return length(max(q-b+r.x,q*r.yzw)) - r.x;\n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in vec4 r ) \n{\n    r = vec4(r.x,r.y,r.z,r.w);\n    vec3 q = abs(p);\n    return length(max(q-b+r.x,q*r.yzw)) - r.x;\n}\n\nfloat sdRoundBox( in vec4 p, in vec3 b, in vec4 r ) \n{\n    r = vec4(r.x,r.y,r.z,r.w);\n    vec3 q = abs(p.xyz);\n    return length(max(q-b+r.x,q*r.yzw)) - r.x;\n}\n\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r ) \n{\n    r = vec4(r.x,r.y,r.z,r.w);\n    vec3 q = abs(p.xyz);\n    return length(max(q-b.xyz+r.x,q*b.wxy)) - r.x;\n}\n\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r, in float roundness ) \n{\n    r = vec4(r.x,r.y,r.z,r.w);\n    vec3 q = abs(p.xyz);\n    return length(max(q-b.xyz+r.x,q*b.wxy)) - r.x;\n}\n\nfloat sdRoundBox( in vec4 p, in vec4 b, in vec4 r, in vec4 roundness ) \n{\n    r = vec4(r.x,", "\n    vec3 sunColor = sunCol;\n    float sunFalloff = clamp(dot(rayDir, sunDir), 0.0, 1.0);\n    sunFalloff = pow(sunFalloff, 10.0);\n    return sunColor * sunFalloff;\n}\n\n// This function basically is a procedural environment map that makes the moon\nvec3 GetMoonColorReflection(vec3 rayDir, vec3 moonDir)\n{\n    vec3 moonColor = vec3(100.0, 100.0, 100.0) / 3555.0;\n    float moonFalloff = clamp(dot(rayDir, moonDir), 0.0, 1.0);\n    moonFalloff = pow(moonFalloff, 10.0);\n    return moonColor * moonFalloff;\n}\n\n// This function basically is a procedural environment map that makes the stars\nvec3 GetStarColorReflection(vec3 rayDir, vec3 starDir)\n{\n    vec3 starColor = vec3(255.0, 255.0, 255.0) / 3555.0;\n    float starFalloff = clamp(dot(rayDir, starDir), 0.0, 1.0);\n    starFalloff = pow(starFalloff, 10.0);\n    return starColor * starFalloff;\n}\n\n// This function basically is a procedural environment map that makes the stars\nvec3 GetCloudColorReflection(vec3 rayDir, vec3 cloudDir)\n{\n    vec3 cloudColor = vec3(255.0, 255.0, 255.0) / 3555.0;\n    float cloudFalloff = clamp(dot(rayDir, cloudDir), 0.0, 1.0);\n    cloudFalloff = pow(cloudFalloff, 10.0);\n    return cloudColor * cloudFalloff;\n}\n\n// This function basically is a procedural environment map that makes", "\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// This is the main function that does the ray marching.\n// It returns the distance to the closest object and the normal at that point.\nvec2 raymarch( in vec3 ro, in vec3 rd, in float start, in float end, in float precis, in float maxiter )\n{\n    float h=precis*2.0;\n    float t = start;\n    float res = -1.0;\n    float h0 = start;\n    float h1 = start;\n    for( int i=0; i<int(maxiter); i++ )\n    {\n        if( h<precis||t>end ) break;\n        h = sceneSDF( ro+rd*t );\n        h0 = h;\n        h1 = sceneSDF( ro+rd*(t+h) );\n        t += h;\n    }\n\n    if( t<end )\n    {\n        res = t;\n    }\n\n    return vec2( res, h0 );\n}\n\n// This is the main function that does the ray marching.\n// It returns the distance to the closest object and the normal at that point.\nvec2 raymarch( in vec3 ro, in vec3 rd, in float start, in float end, in float precis, in float maxiter, in float time )\n{\n    float h=precis*2.0;\n    float t = start;\n    float res = -1.0;\n    float h0 = start;\n    float h1 = start;\n    for( int i=0; i<int(maxiter); i++ )\n    {\n        if( h<precis||t>end ) break;\n        h = sceneSDF( ro+rd*t, time );\n        h0 = h;\n       ", "\n    vec2 result = vec2( 1.0, 0.0 );\n    float d = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44 = 0.0;\n    float d45 = 0.0;\n    float d46", "\n\tfloat distanceToThing1 = distance(thing1, vec2(0.0));\n\tfloat distanceToThing2 = distance(thing2, vec2(0.0));\n\tif(distanceToThing1 < distanceToThing2){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec3 whichThingAmICloserTo( vec3 thing1, vec3 thing2 ){\n\tfloat distanceToThing1 = distance(thing1, vec3(0.0));\n\tfloat distanceToThing2 = distance(thing2, vec3(0.0));\n\tif(distanceToThing1 < distanceToThing2){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nvec4 whichThingAmICloserTo( vec4 thing1, vec4 thing2 ){\n\tfloat distanceToThing1 = distance(thing1, vec4(0.0));\n\tfloat distanceToThing2 = distance(thing2, vec4(0.0));\n\tif(distanceToThing1 < distanceToThing2){\n\t\treturn thing1;\n\t}else{\n\t\treturn thing2;\n\t}\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer\nfloat whichThingAmICloserTo( float thing1, float thing2 ){\n\tfloat distanceToThing1 = distance(thing1, 0.0);\n\tfloat distanceToThing2 = distance(thing2, 0.0);\n\tif(distanceToThing1", "\n    // The distance to the closest thing in the world\n    float distanceToClosestThing = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use the SDF to figure out the normal\n    // of the surface. \n    // We are going to use", "\n    return vec3(0.0);\n}\n\n// this is the function that does the actual raymarching.\n// it returns the distance to the closest object,\n// and also sets the normal and color of the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching distance to the closest object.\n// it also sets the raymarching", "\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n// We also use the position of the hit to show you\n// how you can use the position of the hit to do\n// interesting things.\nvec3 doSphereColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n// We also use the position of the hit to show you\n// how you can use the position of the hit to do\n// interesting things.\nvec3 doPlaneColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n// We also use the position of the hit to show you\n// how you can use the position of the hit to do\n// interesting things.\nvec3 doTriangleColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n// We also use the position of the hit to show you\n// how you can use the position of the hit to do\n// interesting things.\nvec3 doCylinderColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be.\n// We also use the position of the hit to show you\n// how you can use the position of the hit to do\n// interesting things.\nvec3 doConeColor(vec3 positionOfHit, vec3 normalOfSurface ){\n    return normalOfSurface;\n}\n\n// Here we are using the normal of the", "\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    vec3 color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // color = vec3(0.0);\n\n    // This is", "\n    return x / ((((1.0 / b) - 2.0) * (1.0 - x)) + 1.0);\n}\n\n// gain\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain(float x, float b) {\n    return b * x / ((((1.0 / b) - 2.0) * (1.0 - x)) + 1.0);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain_exp(float x, float b) {\n    return b * pow(x, log(b) / log(0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain_exp_inv(float x, float b) {\n    return b * pow(x, log(1.0 - b) / log(0.5));\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat gain_exp_inv_2(float x, float b) {\n", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= resolution.x / resolution.y;\n\n    float r = rand(uv);\n    float g = rand(uv + vec2(1.0));\n    float b = rand(uv + vec2(2.0));\n\n    gl_FragColor = vec4(r, g, b, 1.0);\n}\n", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.5;\n}\n\n// creates white noise in the range -1..1\nfloat rand_range(vec2 p){\n    return rand_inclusive(p) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive_01(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) + 0.5;\n}\n\n// creates white noise in the range -1..1 excluding 0\nfloat rand_exclusive_11(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\n// creates white noise in the range 0..1 excluding 0 and 1\nfloat rand_exclusive_01(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 123.456))) * 43758.5453) + 0.5;\n}\n\n// creates white noise in the range -1..1 excluding 0\nfloat rand_exclusive_11(vec3 p){\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 1", "\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed fistance fuction for box\n// input b --> is box size\n// pretty simple, just compare point to radius of sphere\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input t --> is torus size\n// pretty simple, just compare point to radius of sphere\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// ~~~~~~~ signed fistance fuction for cylinder\n// input c --> is cylinder size\n// pretty simple, just compare point to radius of sphere\nfloat sdCylinder(vec3 p, vec3 c)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(c.x, c.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ~~~~~~~ signed fistance fuction for plane\n// input p --> is plane size\n// pretty simple, just compare point to radius of sphere\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\n// ~~~~~~~ signed fistance fuction for torus\n// input t --> is torus size\n// pretty simple, just compare point to radius of sphere\nfloat sdCone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\n// ~~~~~~~ signed f", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for box\n// input p --> box specs where:\n// \tp.x = box width\n//\tp.y = box height\n//\tp.z = box depth\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for sphere\n// input p --> sphere specs where:\n// \tp.x = sphere radius\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for capsule\n// input p --> capsule specs where:\n// \tp.x = capsule radius\n//\tp.y = capsule length\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input p --> cylinder specs where:\n// \tp.x = cylinder radius\n//\tp.y = cylinder height\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(c.x,c.y);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for plane\n// input p --> plane specs where:\n// \tp.x = plane width\n//\tp.y = plane height\nfloat", "\n    float k = 1.0;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float d3)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k, float d3, float d4)\n{\n    float h = clamp( 0.", "\n    return d1 - d2;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k)\n{\n    return d1 - k * d2;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float d)\n{\n    return d1 - k * d2 * d;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float d, float d3)\n{\n    return d1 - k * d2 * d * d3;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float d, float d3, float d4)\n{\n    return d1 - k * d2 * d * d3 * d4;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1 --> distance of object 1\n// input d2 --> distance of object 2\n// output --> blended object\nfloat opBlend( float d1, float d2, float k, float d, float d3, float d4, float d5)\n{\n    return d1 - k * d2 * d * d3 * d4 * d5;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input d1", "\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t )\n{\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch )\n{\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw, float pitch, float roll )\n{\n    float c = cos(t);\n    float s = sin(t);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n", "\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opI(vec2 o1, vec2 o2)\n{\n    if (o1.x > o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Subtraction / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opS(vec2 o1, vec2 o2)\n{\n    if (o1.x > o2.x)\n        return o1;\n    else\n        return vec2(-o2.x, o2.y);\n}\n\n// ~~~~~~~ do Smooth Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opSm(vec2 o1, vec2 o2)\n{\n    float k = 0.1;\n    float h = clamp( 0.5 + 0.5*(o2.x-o1.x)/k, 0.0, 1.0 );\n    return mix( o2, o1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ do Smooth Intersection / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a max() but we use if() \nvec2 opSi(vec2 o1, vec2 o2)\n{\n    float k = 0.1;\n    float h = clamp( 0.5 - 0.5*(o2.x-o1", "\n    vec2 res = vec2(0.0);\n    res.x = length(p) - 1.0;\n    res.y = 1.0;\n    return res;\n}\n\n// ~~~~~~~ ray marching\n// input p --> is ray position\n// input d --> is ray direction\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nfloat rayMarch(vec3 p, vec3 d)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 m = map(p + d * t);\n        t += m.x;\n        if (m.x < 0.001 || t > 100.0)\n            break;\n    }\n    return t;\n}\n\n// ~~~~~~~ normal\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    );\n    return normalize(n);\n}\n\n// ~~~~~~~ lighting\n// input p --> is ray position\n// input n --> is ray normal\n// input l --> is light position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec3 getLight(vec3 p, vec3 n, vec3 l)\n{\n    vec3 light = vec3(0.0);\n    vec3 lightColor = vec3", "\n    float tmin = 0.001;\n    float tmax = 100.0;\n    float t = tmin;\n    float m = -1.0;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        float precis = 0.0001;\n        float h = map(ro+rd*t);\n        if( h<precis || t>tmax ) break;\n        t += h;\n    }\n    if(t<tmax) m=t;\n    return vec2( m, 0.0 );\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd, inout vec3 pos)\n{\n    float tmin = 0.001;\n    float tmax = 100.0;\n    float t = tmin;\n    float m = -1.0;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        float precis = 0.0001;\n        float h = map(ro+rd*t);\n        if( h<precis || t>tmax ) break;\n        t += h;\n    }\n    if(t<tmax) m=t;\n    pos = ro + rd * t;\n    return vec2( m, 0.0 );\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// output is vec2 where\n// \t.x = distance travelled by ray\n//.y = hit object's ID\n//\nvec2 castRay( vec3 ro, vec3 rd, inout vec3 pos, inout vec3 nor)\n{\n    float tmin = 0.00", "\n    // ~~~~~~~ find closest surface\n    float t = 0.0;\n    float tmin = 10000.0;\n    int id = 0;\n    for (int i = 0; i < NUM_SURFACES; i++)\n    {\n        float ti = intersect(ro, rd, i);\n        if (ti > 0.0 && ti < tmin)\n        {\n            tmin = ti;\n            id = i;\n        }\n    }\n\n    // ~~~~~~~ find surface color\n    vec3 col = vec3(0.0);\n    if (tmin < 10000.0)\n    {\n        col = surfaceColor(id, ro + rd * tmin);\n    }\n\n    return col;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, out int id)\n{\n    // ~~~~~~~ find closest surface\n    float t = 0.0;\n    float tmin = 10000.0;\n    id = 0;\n    for (int i = 0; i < NUM_SURFACES; i++)\n    {\n        float ti = intersect(ro, rd, i);\n        if (ti > 0.0 && ti < tmin)\n        {\n            tmin = ti;\n            id = i;\n        }\n    }\n\n    // ~~~~~~~ find surface color\n    vec3 col = vec3(0.0);\n    if (tmin < 10000.0)\n    {\n        col = surfaceColor(id, ro + rd * tmin);\n    }\n\n    return col;\n}\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// output --> pixel color\nvec3 render(vec3 ro, vec3 rd, out", "\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross( camDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, camDir ) );\n\n    return mat3( camRight, camUp, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 roll )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross( camDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, camDir ) );\n\n    return mat3( camRight, camUp, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in vec3 roll, in vec3 up )\n{\n    vec3 camDir = normalize( targetPos - camPos );\n    vec3 camRight = normalize( cross( camDir, up ) );\n    vec3 camUp = normalize( cross( camRight, camDir ) );\n\n    return mat3( camRight, camUp, camDir );\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, in", "\n    if(id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else if(id == 6.0)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if(id == 7.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(int id)\n{\n    if(id == 0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2)\n    {\n        return vec3(0.0,", "\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// ~~~~~~~ signed distance function for box\n// input p --> box size\n// input s --> box thickness\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed distance function for sphere\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n// ~~~~~~~ signed distance function for capsule\n// input p --> capsule position\n// input a --> capsule radius\n// input b --> capsule length\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa - ba*h) - r;\n}\n\n// ~~~~~~~ signed distance function for cylinder\n// input p --> cylinder position\n// input h --> cylinder height\n// input r --> cylinder radius\nfloat sdCylinder(vec3 p, vec3 c, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,c.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for cone\n// input p --> cone position\n// input h --> cone height\n// input r --> cone radius\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n    vec2 q = h*vec2(c.x/c.y,-1.0);\n    vec2 w = vec", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> height\n//        ps.z --> width\nfloat sdSphere(vec3 p, vec3 ps)\n{\n    vec3 q = p - ps.xyz;\n    return length(q) - ps.x;\n}\n\n// ~~~~~~~ signed distance function for box\n//  input ps --> specs of box\n//        ps.x --> size x\n//        ps.y --> size y\n//        ps.z --> size z\nfloat sdBox(vec3 p, vec3 ps)\n{\n    vec3 q = abs(p) - ps;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// ~~~~~~~ signed distance function for cylinder\n//  input ps --> specs of cylinder\n//        ps.x --> radius\n//        ps.y --> height\nfloat sdCylinder(vec3 p, vec3 ps)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - ps.xy;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ~~~~~~~ signed distance function for torus\n//  input ps --> specs of torus\n//        ps.x --> radius\n//        ps.y --> thickness\nfloat sdTorus(vec3 p, vec2 ps)\n{\n    vec2 q = vec2(length(p.xz)-ps.x,p.y);\n    return length(q)-ps.y;\n}\n\n// ~~~~~~~ signed distance function for capsule\n//  input ps --> specs of capsule\n//        ps.x --> radius\n//        ps.y --> height\nfloat sdCapsule(vec3 p, vec3 ps)\n{\n    vec3 q = p - ps.xyz", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{\n    float h = clamp(", "\n    vec4 o = o1;\n    o.xyz = mix(o1.xyz, o2.xyz, bf);\n    o.w = mix(o1.w, o2.w, bf);\n    return o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 o = o1;\n    o.xyz = mix(o1.xyz, o2.xyz, bf);\n    o.w = mix(o1.w, o2.w, bf);\n    return o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{\n    vec4 o = o1;\n    o.xyz = mix(o1.xyz, o2.xyz, bf);\n    o.w = mix(o1.w, o2.w, bf);\n    return o;\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC", "\n    float d = d1 - d2;\n    return d;\n}\n\n// ~~~~~~~ do shape intersect, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opIntersect(float d1,float d2)\n{\n    float d = max(d1,d2);\n    return d;\n}\n\n// ~~~~~~~ do shape union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opUnion(float d1,float d2)\n{\n    float d = min(d1,d2);\n    return d;\n}\n\n// ~~~~~~~ do shape difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opDifference(float d1,float d2)\n{\n    float d = max(d1,-d2);\n    return d;\n}\n\n// ~~~~~~~ do shape smooth union, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSmoothUnion(float d1,float d2,float k)\n{\n    float h = clamp(0.5 + 0.5*(d2+d1)/k,0.0,1.0);\n    return mix(d2,d1,-h) + k*h*(1.0-h);\n}\n\n// ~~~~~~~ do shape smooth difference, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt", "\n    // ~~~~~~~~~~ generate random point on sphere\n    float theta = rand(gl_FragCoord.xy) * 2.0 * PI;\n    float phi = rand(gl_FragCoord.xy * 2.0) * PI;\n    float r = rand(gl_FragCoord.xy * 3.0);\n    vec3 point = vec3(r * cos(theta) * cos(phi), r * sin(theta) * cos(phi), r * sin(phi));\n\n    // ~~~~~~~~~~ generate random point on sphere\n    float theta2 = rand(gl_FragCoord.xy * 4.0) * 2.0 * PI;\n    float phi2 = rand(gl_FragCoord.xy * 5.0) * PI;\n    float r2 = rand(gl_FragCoord.xy * 6.0);\n    vec3 point2 = vec3(r2 * cos(theta2) * cos(phi2), r2 * sin(theta2) * cos(phi2), r2 * sin(phi2));\n\n    // ~~~~~~~~~~ generate random point on sphere\n    float theta3 = rand(gl_FragCoord.xy * 7.0) * 2.0 * PI;\n    float phi3 = rand(gl_FragCoord.xy * 8.0) * PI;\n    float r3 = rand(gl_FragCoord.xy * 9.0);\n    vec3 point3 = vec3(r3 * cos(theta3) * cos(phi3), r3 * sin(theta3) * cos(phi3), r3 * sin(phi3));\n\n    // ~~~~~~~~~~ generate random point on sphere\n    float theta4 = rand(gl_FragCoord.xy * 10.0) * 2.0 * PI;\n    float phi4 = rand(gl_FragCoord.xy * 11.0) * PI;\n    float r4 = rand(gl_FragCoord.xy * 12.0", "\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n    // res.xyz = p;\n    // return res;\n\n    // vec4 res = vec4(0.0);\n", "\n    vec4 res = vec4(-1.0);\n    float tmin = 1.0;\n    float tmax = 100.0;\n    float t = tmin;\n    float m = -1.0;\n    for(int i=0; i<MAX_OBJECTS; i++)\n    {\n        float tt = scene(ro+rd*t, i);\n        if(tt>0.001 && tt<t)\n        {\n            t = tt;\n            m = float(i);\n        }\n    }\n    if(m>-0.5)\n    {\n        res = vec4(t,m,0.0,0.0);\n        if(t>tmin && t<tmax)\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, m);\n            vec3 ref = reflect(rd, nor);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            float con = clamp(dot(nor,rd),0.0,1.0);\n            float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n            float sha = 0.0;\n            if(nor.y>0.0)\n            {\n                sha=softshadow(pos,lightPos,0.02);\n            }\n            vec3 lig = normalize(lightPos-pos);\n            float spe = pow(clamp(dot(ref,lig),0.0,1.0),16.0);\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float bac = clamp(0.2+0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0,1.0);\n            float dom = smoothstep(-0.1,0.1,ref.y);\n            float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0", "\n    float res = 1.0;\n    float tmin = 0.001;\n    float tmax = 100.0;\n    float t = tmin;\n    float k = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(sp + lp * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.001 || t > tmax) break;\n        k =.25;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow_2(vec3 sp, vec3 lp)\n{\n    float res = 1.0;\n    float tmin = 0.001;\n    float tmax = 100.0;\n    float t = tmin;\n    float k = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        float h = map(sp + lp * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.001 || t > tmax) break;\n        k =.25;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.ht", "\n    float t = 0.0;\n    float h = 0.0;\n    float d = 0.0;\n    float ao = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        h = map(sp + nor * t);\n        d = h;\n        ao += h * h * 0.0001;\n        t += h;\n        if (h < 0.0001 || t > 10.0)\n            break;\n    }\n    return 1.0 - ao;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat ambientOcclusion(vec3 sp, vec3 nor)\n{\n    float t = 0.0;\n    float h = 0.0;\n    float d = 0.0;\n    float ao = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        h = map(sp + nor * t);\n        d = h;\n        ao += h * h * 0.0001;\n        t += h;\n        if (h < 0.0001 || t > 10.0)\n            break;\n    }\n    return 1.0 - ao;\n}\n\n// ~~~~~~~ ambientOcclusion_2\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat ambientOcclusion_2(vec3 sp, vec3 nor)\n{\n    float t = 0.0;\n    float h = 0.0;\n    float d = 0.0;\n    float ao = 0.0;\n    for (int i = 0; i < 10; i++)\n    {\n        h = map(sp", "\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 pt = p + vec3(0.0, 0.0, 0.01) * float(i);\n        vec3 n = normalize(texture(u_normalMap, pt).xyz);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n = n * 2.0 - 1.0;\n        n = normalize(n);\n        n = n * 0.5 + 0.5;\n        n =", "\n    return pow(c, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec4 c)\n{\n    return pow(c.rgb, vec3(1.0 / 2.2));\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec4 c)\n{\n    return vec4(pow(c.rgb, vec3(1.0 / 2.2)), c.a);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec3 c, float a)\n{\n    return vec4(pow(c, vec3(1.0 / 2.2)), a);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec4 applyGammaCorrection(vec4 c, float a)\n{\n    return vec4(pow(c.rgb, vec3(1.0 / 2.2)), a);\n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting", "\n    float f = exp2(-fs.x*d);\n    float f2 = exp2(-fs.x*d*fs.y);\n    float f3 = exp2(-fs.x*d*fs.y*fs.y);\n    float f4 = exp2(-fs.x*d*fs.y*fs.y*fs.y);\n    float f5 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y);\n    float f6 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f7 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f8 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f9 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f10 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f11 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f12 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n    float f13 = exp2(-fs.x*d*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y*fs.y);\n   ", "\n    return 1.0 / (cF + lF * d + qF * d * d);\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0)\n{\n    return 1.0 / (cF + lF * d + qF * d * d) * (1.0 / (1.0 + (d - d0) / d0));\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0, float d1)\n{\n    return 1.0 / (cF + lF * d + qF * d * d) * (1.0 / (1.0 + (d - d0) / d0)) * (1.0 / (1.0 + (d - d1) / d1));\n}\n\n// ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n// input cF --> constant factor\n// input lF --> linear factor\n// input qF --> quadratic factor\n// the factors above should range between 0 and 1\n// pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d, float d0, float d1", "\n    vec3 rayDir = vec3(fCoord.x, fCoord.y, 1.0);\n    rayDir = rayDir * cMatrix;\n    return normalize(rayDir);\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix)\n{\n    vec3 rayOrigin = vec3(fCoord.x, fCoord.y, 0.0);\n    rayOrigin = rayOrigin * cMatrix;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, float z)\n{\n    vec3 rayOrigin = vec3(fCoord.x, fCoord.y, z);\n    rayOrigin = rayOrigin * cMatrix;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, float z, float w)\n{\n    vec3 rayOrigin = vec3(fCoord.x, fCoord.y, z);\n    rayOrigin = rayOrigin * cMatrix;\n    rayOrigin.z = w;\n    return rayOrigin;\n}\n\n// ~~~~~~~ generate camera ray origin, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray origin\nvec3 calculateRayOrigin(vec2 fCoord, mat3 cMatrix, float z, float w, float h)\n{\n    vec3 rayOrigin = vec3(fCoord.x, fCoord.y, z);\n    rayOrigin = ray", "\n    vec3 cDir = normalize(cPos - vec3(fCoord,0.0));\n    vec3 cPos2 = cPos + cDir;\n    vec3 cDir2 = normalize(cPos2 - vec3(fCoord,0.0));\n    vec3 cPos3 = cPos + cDir2;\n    vec3 cDir3 = normalize(cPos3 - vec3(fCoord,0.0));\n    vec3 cPos4 = cPos + cDir3;\n    vec3 cDir4 = normalize(cPos4 - vec3(fCoord,0.0));\n    vec3 cPos5 = cPos + cDir4;\n    vec3 cDir5 = normalize(cPos5 - vec3(fCoord,0.0));\n    vec3 cPos6 = cPos + cDir5;\n    vec3 cDir6 = normalize(cPos6 - vec3(fCoord,0.0));\n    vec3 cPos7 = cPos + cDir6;\n    vec3 cDir7 = normalize(cPos7 - vec3(fCoord,0.0));\n    vec3 cPos8 = cPos + cDir7;\n    vec3 cDir8 = normalize(cPos8 - vec3(fCoord,0.0));\n    vec3 cPos9 = cPos + cDir8;\n    vec3 cDir9 = normalize(cPos9 - vec3(fCoord,0.0));\n    vec3 cPos10 = cPos + cDir9;\n    vec3 cDir10 = normalize(cPos10 - vec3(fCoord,0.0));\n    vec3 cPos11 = cPos + cDir10;\n    vec3 cDir11 = normalize(cPos11 - vec3(fCoord,0.0));\n    vec3 cPos12 = cPos + cDir11;\n    vec3 cDir12 = normalize(cPos12 - vec3(", "\n    // Setup\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec2 c = uv;\n    float zoom = 1.0;\n    float iters = 100.0;\n    float itersf = float(iters);\n    float itersf2 = itersf * itersf;\n    float itersf3 = itersf * itersf2;\n    float itersf4 = itersf * itersf3;\n    float itersf5 = itersf * itersf4;\n    float itersf6 = itersf * itersf5;\n    float itersf7 = itersf * itersf6;\n    float itersf8 = itersf * itersf7;\n    float itersf9 = itersf * itersf8;\n    float itersf10 = itersf * itersf9;\n    float itersf11 = itersf * itersf10;\n    float itersf12 = itersf * itersf11;\n    float itersf13 = itersf * itersf12;\n    float itersf14 = itersf * itersf13;\n    float itersf15 = itersf * itersf14;\n    float itersf16 = itersf * itersf15;\n    float itersf17 = itersf * itersf16;\n    float itersf18 = itersf * itersf17;\n    float itersf19 = itersf * itersf18;\n    float itersf20 = itersf * itersf19;\n    float itersf21 = itersf * itersf20;\n    float itersf22 = itersf * itersf21;\n    float itersf23 = it", "\n    vec3 d = abs(p) - radius;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// sphere distance field\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// torus distance field\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    vec2 q = vec2(length(p.xz)-radius.x,p.y);\n    return length(q)-radius.y;\n}\n\n// cylinder distance field\nfloat sdCylinder(vec3 p, vec3 radius)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - radius;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// plane distance field\nfloat sdPlane(vec3 p, vec4 n)\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n// union of two distance fields\nfloat opUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\n// subtraction of two distance fields\nfloat opSubtraction(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\n// intersection of two distance fields\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n// smooth union of two distance fields\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// smooth subtraction of two distance fields\nfloat opSmoothSubtraction(float d1, float d", "\n    return length(p.xy) - r;\n}\n\n// simple sphere distance field\nfloat sph(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// simple box distance field\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// simple torus distance field\nfloat tor(vec2 p, vec2 t)\n{\n    return length(p - t.x * vec2(cos(iTime), sin(iTime))) - t.y;\n}\n\n// simple plane distance field\nfloat pln(vec2 p, vec2 n)\n{\n    return dot(p, n);\n}\n\n// simple plane distance field\nfloat pln(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n\n// simple plane distance field\nfloat pln(vec4 p, vec4 n)\n{\n    return dot(p, n);\n}\n\n// simple plane distance field\nfloat pln(vec2 p, vec3 n)\n{\n    return dot(p, n.xy);\n}\n\n// simple plane distance field\nfloat pln(vec3 p, vec2 n)\n{\n    return dot(p, n.xy);\n}\n\n// simple plane distance field\nfloat pln(vec4 p, vec2 n)\n{\n    return dot(p, n.xy);\n}\n\n// simple plane distance field\nfloat pln(vec2 p, vec4 n)\n{\n    return dot(p, n.xy);\n}\n\n// simple plane distance field\nfloat pln(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz);\n}\n\n// simple plane distance field\nfloat pln(vec4 p, vec3 n)\n{\n    return dot(p, n.xyz);\n}\n\n// simple plane distance field\nfloat pln(vec4 p, vec4 n", "\n    // The distance to the nearest surface\n    float d = 1000000.0;\n\n    // The material number\n    int material = 0;\n\n    // The distance to the sphere\n    float dSphere = sdSphere(p - vec3(0.0, 0.0, 0.0), 1.0);\n\n    // The distance to the box\n    float dBox = sdBox(p - vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // The distance to the torus\n    float dTorus = sdTorus(p - vec3(0.0, 0.0, 0.0), vec2(1.0, 0.5));\n\n    // The distance to the plane\n    float dPlane = sdPlane(p - vec3(0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0));\n\n    // The distance to the capsule\n    float dCapsule = sdCapsule(p - vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 1.0);\n\n    // The distance to the cylinder\n    float dCylinder = sdCylinder(p - vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec2(1.0, 1.0));\n\n    // The distance to the cone\n    float dCone = sdCone(p - vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec2(1.0, 1.0));\n\n    // The distance to the torus\n    float dTorus = sdTorus", "\n    return vec2(c.x*c.x*c.x*c.x*c.x - 10.0*c.x*c.x*c.x*c.x + c.x*c.x*c.x*c.x + 10.0*c.x*c.x*c.x - 10.0*c.x*c.x + c.x*c.x + 10.0*c.x - 1.0,\n                5.0*c.y*c.y*c.y*c.y*c.y - 10.0*c.y*c.y*c.y*c.y + c.y*c.y*c.y*c.y + 10.0*c.y*c.y*c.y - 10.0*c.y*c.y + c.y*c.y + 10.0*c.y - 1.0);\n}\n\n//Function that returns a complex number to power of 4\nvec2 complexPower4(vec2 c)\n{\n    return vec2(c.x*c.x*c.x*c.x - 10.0*c.x*c.x*c.x + c.x*c.x*c.x + 10.0*c.x*c.x - 10.0*c.x + c.x*c.x + 10.0*c.x - 1.0,\n                4.0*c.y*c.y*c.y*c.y - 10.0*c.y*c.y*c.y + c.y*c.y*c.y + 10.0*c.y*c.y - 10.0*c.y + c.y*c.y + 10.0*c.y - 1.0);\n}\n\n//Function that returns a complex number to power of 3\nvec2 complexPower3(vec2 c)\n{\n    return vec2(c.x*c.x*c.x - 10.0", "\n    vec2 coord2 = coord;\n    coord2.x += morphConstant.x;\n    coord2.y += morphConstant.y;\n    vec2 coord3 = coord2;\n    coord3.x += morphConstant.x;\n    coord3.y += morphConstant.y;\n    vec2 coord4 = coord3;\n    coord4.x += morphConstant.x;\n    coord4.y += morphConstant.y;\n    vec2 coord5 = coord4;\n    coord5.x += morphConstant.x;\n    coord5.y += morphConstant.y;\n    vec2 coord6 = coord5;\n    coord6.x += morphConstant.x;\n    coord6.y += morphConstant.y;\n    vec2 coord7 = coord6;\n    coord7.x += morphConstant.x;\n    coord7.y += morphConstant.y;\n    vec2 coord8 = coord7;\n    coord8.x += morphConstant.x;\n    coord8.y += morphConstant.y;\n    vec2 coord9 = coord8;\n    coord9.x += morphConstant.x;\n    coord9.y += morphConstant.y;\n    vec2 coord10 = coord9;\n    coord10.x += morphConstant.x;\n    coord10.y += morphConstant.y;\n    vec2 coord11 = coord10;\n    coord11.x += morphConstant.x;\n    coord11.y += morphConstant.y;\n    vec2 coord12 = coord11;\n    coord12.x += morphConstant.x;\n    coord12.y += morphConstant.y;\n    vec2 coord13 = coord12;\n    coord13.x += morphConstant.x;\n    coord13.y += morphConstant.y;\n    vec2 coord14 = coord13;\n    coord14.x += morphConstant.x;\n    coord14.y += morphConstant.y;\n    vec2 coord15 = coord14;\n    coord15.x += morphConstant.x;\n    coord15.y += morphConstant.y;", "\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < SAMPLES; i++)\n    {\n        vec2 offset = vec2(0.0);\n        offset.x = (float(i) / float(SAMPLES)) * 2.0 - 1.0;\n        offset.y = (float(i) / float(SAMPLES)) * 2.0 - 1.0;\n        color += texture(u_texture, uv + offset * constant);\n    }\n    return color / float(SAMPLES);\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, vec2 offset)\n{\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < SAMPLES; i++)\n    {\n        vec2 offset = vec2(0.0);\n        offset.x = (float(i) / float(SAMPLES)) * 2.0 - 1.0;\n        offset.y = (float(i) / float(SAMPLES)) * 2.0 - 1.0;\n        color += texture(u_texture, uv + offset * constant + offset * offset * constant);\n    }\n    return color / float(SAMPLES);\n}\n\n//Simple multisampling-antialising\n//Effectively the same as rendering the thing in a larger resolution and then downscaling\nvec4 antiAliasedBiomorph(vec2 uv, vec2 constant, vec2 offset, vec2 offset2)\n{\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < SAMPLES; i++)\n    {\n        vec2 offset = vec2(0.0);\n        offset.x = (float(i) / float(SAMPLES)) * 2.0 - 1.0;\n        offset.y = (float(i) / float(SAMPLES)) * ", "\n    return x - floor(x);\n}\n\nfloat triangle(float x) {\n    return abs(repeat(x) - 0.5) * 4.0 - 1.0;\n}\n\nfloat sawtooth(float x) {\n    return x - floor(x);\n}\n\nfloat square(float x) {\n    return step(0.5, repeat(x));\n}\n\nfloat pulse(float x, float width) {\n    return step(width, repeat(x));\n}\n\nfloat pulse(float x, float width, float duty) {\n    return step(duty, repeat(x));\n}\n\nfloat pulse(float x, float width, float duty, float phase) {\n    return step(duty, repeat(x + phase));\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert) {\n    return step(duty, repeat(x + phase)) * invert;\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert, float invert2) {\n    return step(duty, repeat(x + phase)) * invert * invert2;\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert, float invert2, float invert3) {\n    return step(duty, repeat(x + phase)) * invert * invert2 * invert3;\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert, float invert2, float invert3, float invert4) {\n    return step(duty, repeat(x + phase)) * invert * invert2 * invert3 * invert4;\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert, float invert2, float invert3, float invert4, float invert5) {\n    return step(duty, repeat(x + phase)) * invert * invert2 * invert3 * invert4 * invert5;\n}\n\nfloat pulse(float x, float width, float duty, float phase, float invert, float invert2, float invert3, float invert4, float invert5, float invert6) {\n    return step(duty, repeat(x + phase)) * invert * invert2", "\n    // Get the distance from the line\n    float dist = distance(uv, pA);\n    dist = min(dist, distance(uv, pB));\n\n    // Get the distance from the line end points\n    float distA = distance(uv, pA);\n    float distB = distance(uv, pB);\n\n    // Get the distance from the line end points\n    float distA2 = distance(uv, pA + vec2(thick.x, 0.0));\n    float distB2 = distance(uv, pB + vec2(-thick.x, 0.0));\n\n    // Get the distance from the line end points\n    float distA3 = distance(uv, pA + vec2(0.0, thick.y));\n    float distB3 = distance(uv, pB + vec2(0.0, -thick.y));\n\n    // Get the distance from the line end points\n    float distA4 = distance(uv, pA + vec2(thick.x, thick.y));\n    float distB4 = distance(uv, pB + vec2(-thick.x, -thick.y));\n\n    // Get the distance from the line end points\n    float distA5 = distance(uv, pA + vec2(thick.x, -thick.y));\n    float distB5 = distance(uv, pB + vec2(-thick.x, thick.y));\n\n    // Get the distance from the line end points\n    float distA6 = distance(uv, pA + vec2(-thick.x, thick.y));\n    float distB6 = distance(uv, pB + vec2(thick.x, -thick.y));\n\n    // Get the distance from the line end points\n    float distA7 = distance(uv, pA + vec2(-thick.x, -thick.y));\n    float distB7 = distance(uv, pB + vec2(thick.x, thick.y));\n\n    // Get the distance from the line end points\n    float distA8 = distance(uv, pA + vec2(thick.x, 0.0));\n    float distB8 = distance", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    vec2 bb = pB - uv;\n    float h = length(ba);\n    ba = normalize(ba);\n    float a = dot(pa, ba);\n    float b = dot(bb, ba);\n    float d = sqrt(a * a - h * h + b * b);\n    float da = sqrt(a * a - rounded * rounded);\n    float db = sqrt(b * b - rounded * rounded);\n    float t = (d - da) / (db - da);\n    float s = smoothstep(0.0, 1.0, t);\n    return s;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick, float rounded) {\n    return FillLinePix(uv, pA, pB, vec2(thick, thick), rounded);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, float thick) {\n    return FillLinePix(uv, pA, pB, vec2(thick, thick), 0.0);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB) {\n    return FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick) {\n    return FillLinePix(uv, pA, pB, thick", "\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    float dist = distance(pA, pB);\n    float distA = distance(pA, uv);\n    float distB = distance(pB, uv);\n    float distAB = distance(pA, pB);\n    float distAB2 = distAB * distAB;\n    float distAB4 = distAB2 * distAB2;\n    float distAB6 = distAB4 * distAB2;\n    float distAB8 = distAB6 * distAB2;\n    float distAB10 = distAB8 * distAB2;\n    float distAB12 = distAB10 * distAB2;\n    float distAB14 = distAB12 * distAB2;\n    float distAB16 = distAB14 * distAB2;\n    float distAB18 = distAB16 * distAB2;\n    float distAB20 = distAB18 * distAB2;\n    float distAB22 = distAB20 * distAB2;\n    float distAB24 = distAB22 * distAB2;\n    float distAB26 = distAB24 * distAB2;\n    float distAB28 = distAB26 * distAB2;\n    float distAB30 = distAB28 * distAB2;\n    float distAB32 = distAB30 * distAB2;\n    float distAB34 = distAB32 * distAB2;\n    float distAB36 = distAB34 * distAB2;\n    float distAB38 = distAB36 * distAB2;\n    float distAB40 = distAB38 * distAB2;\n    float distAB42 = distAB40 * distAB2;\n    float distAB44 = distAB42 * distAB2;\n    float distAB46 = distAB44 * distAB2;\n    float distAB48 = distAB46 * distAB2;\n    float distAB50 = distAB48 * distAB2;\n    float distAB52", "\n    vec2 pa = pA - uv;\n    vec2 ba = pB - pA;\n    float h = length(ba);\n    ba = normalize(ba);\n    float d = dot(pa, ba);\n    float e = dot(pa - ba * d, ba);\n    float i = clamp((d - thick.x) / thick.y, 0.0, 1.0);\n    float o = clamp((h - d - thick.x) / thick.y, 0.0, 1.0);\n    float r = clamp(e / thick.x, 0.0, 1.0);\n    float f = clamp(e / thick.y, 0.0, 1.0);\n    float t = clamp(d / thick.x, 0.0, 1.0);\n    float u = clamp(d / thick.y, 0.0, 1.0);\n    float v = clamp(h - d - thick.x, 0.0, 1.0);\n    float w = clamp(h - d - thick.y, 0.0, 1.0);\n    float x = clamp(e / thick.x, 0.0, 1.0);\n    float y = clamp(e / thick.y, 0.0, 1.0);\n    float z = clamp(d / thick.x, 0.0, 1.0);\n    float a = clamp(d / thick.y, 0.0, 1.0);\n    float b = clamp(h - d - thick.x, 0.0, 1.0);\n    float c = clamp(h - d - thick.y, 0.0, 1.0);\n    float dd = clamp(e / thick.x, 0.0, 1.0);\n    float ee = clamp(e / thick.y, 0.0, 1.0);\n    float ff = clamp(d / thick.x, 0.0, 1.0);\n    float gg = clamp(d / thick", "\n    vec2 dir = normalize(pB - pA);\n    vec2 perp = vec2(-dir.y, dir.x);\n    float dist = dot(uv - pA, dir);\n    float dist2 = dot(uv - pA, perp);\n    float dist3 = dot(uv - pB, perp);\n    float dist4 = dot(uv - pB, dir);\n    float dist5 = min(dist, dist4);\n    float dist6 = min(dist2, dist3);\n    float dist7 = max(dist2, dist3);\n    float dist8 = max(dist, dist4);\n    float dist9 = min(dist5, dist6);\n    float dist10 = min(dist7, dist8);\n    float dist11 = max(dist5, dist6);\n    float dist12 = max(dist7, dist8);\n    float dist13 = dist12 - dist11;\n    float dist14 = dist10 - dist9;\n    float dist15 = dist14 - dist13;\n    float dist16 = dist15 - thick.x;\n    float dist17 = dist15 + thick.x;\n    float dist18 = dist16 - thick.y;\n    float dist19 = dist16 + thick.y;\n    float dist20 = dist17 - thick.y;\n    float dist21 = dist17 + thick.y;\n    float dist22 = dist18 - thick.x;\n    float dist23 = dist18 + thick.x;\n    float dist24 = dist19 - thick.x;\n    float dist25 = dist19 + thick.x;\n    float dist26 = dist20 - thick.y;\n    float dist27 = dist20 + thick.y;\n    float dist28 = dist21 - thick.y;\n    float dist29 = dist21 + thick.y;\n    float dist30 = dist22 - thick.x;\n    float dist31 = dist22 + thick.x;\n    float dist32 = dist23 - thick.x;\n    float", "\n    vec2 p = pA + (pB - pA) * uv;\n    vec2 d = pB - pA;\n    float l = length(d);\n    d /= l;\n    float t = dot(d, normalize(vec2(d.y, -d.x)));\n    float r = l * 0.5;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n   ", "\n    float d = length(uv - p);\n    if (d < 0.001) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n}\n\n// This is the main function that draws the point.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    // Draw a point at the center of the screen.\n    DrawPoint(uv, vec2(0.5), col);\n\n    // Draw a point at the mouse position.\n    DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n\n    // Draw a point at the mouse position, but only if the mouse is pressed.\n    if (iMouse.z > 0.0) {\n        DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n    }\n\n    // Draw a point at the mouse position, but only if the mouse is pressed and the mouse is in the top left corner.\n    if (iMouse.z > 0.0 && iMouse.x < 100.0 && iMouse.y < 100.0) {\n        DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n    }\n\n    // Draw a point at the mouse position, but only if the mouse is pressed and the mouse is in the top left corner and the mouse is not in the top right corner.\n    if (iMouse.z > 0.0 && iMouse.x < 100.0 && iMouse.y < 100.0 && iMouse.x > 100.0) {\n        DrawPoint(uv, iMouse.xy / iResolution.xy, col);\n    }\n\n    // Draw a point at the mouse position, but only if the mouse is pressed and the mouse is in the top left corner and the mouse is not in the top right corner and the mouse is not in the bottom left corner.\n    if (iMouse.z > 0.0 && iMouse.x < 100.0 && iMouse", "\n    float t = dot( cen - ro, nor );\n    float b = dot( ro - cen, nor );\n    float r2 = rad * rad;\n    float c = dot( ro, ro ) - 2.0 * t * b + b * b;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float s = -b - h;\n    if( s < 0.0 ) s = 0.0;\n    float t1 = s / dot( rd, rd );\n    float t2 = ( s + h ) / dot( rd, rd );\n    if( t1 > t2 ) { t1 = t2; t2 = t1; }\n    if( t1 < 0.0 ) {\n        t1 = t2;\n        if( t1 < 0.0 ) return -1.0;\n    }\n    return t1;\n}\n\n// ray-cylinder intersection\nfloat iCylinder( in vec3 ro, in vec3 rd,\n                 in vec3 cen, in vec3 nor, float rad, float hei )\n{\n    float t = dot( cen - ro, nor );\n    float b = dot( ro - cen, nor );\n    float r2 = rad * rad;\n    float c = dot( ro, ro ) - 2.0 * t * b + b * b;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float s = -b - h;\n    if( s < 0.0 ) s = 0.0;\n    float t1 = s / dot( rd, rd );\n    float t2 = ( s + h ) / dot( rd, rd );\n    if( t1 > t2 ) { t1 = t2; t2 = t1; }\n    if( t1 < 0.0 ) {\n        t1 = t2;\n        if( t1 < 0.0 ) return -1.0;\n    }\n", "\n    vec3 m = (ro-cen)/rad;\n    vec3 n = sign(m);\n    m = abs(m)*n;\n    vec3 q = m*rad;\n    float t = max(q.x,max(q.y,q.z));\n    float t2 = min(max(q.x,max(q.y,q.z)),0.0);\n    return vec2(t,t2);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) \n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) \n{\n    return -ro.y/rd.y;\n}\n\n// ray-triangle intersection\nvec2 iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n    vec3 e1 = v1-v0;\n    vec3 e2 = v2-v0;\n    vec3 p = cross( rd, e2 );\n    float det = dot( e1, p );\n    if( det<0.000001 ) return vec2(-1.0);\n    float invDet = 1.0/det;\n    vec3 t = ro - v0;\n    float u = dot( t, p )*invDet;\n    if( u<0.0 || u>1.0 ) return vec2(-1.0);\n    vec3 q = cross( t, e1 );\n", "\n    vec3 ba = pb - pa;\n    float l = length(ba);\n    vec3 r = ba / l;\n    vec3 u = vec3( r.z, 0.0, -r.x );\n    vec3 v = cross( r, u );\n    vec3 c = (pa + pb) * 0.5;\n    float rr = ra * ra;\n    float a = dot( u, u ) * rr;\n    float b = dot( u, v ) * 2.0 * ra;\n    float c = dot( v, v ) * rr - 0.25;\n    float d = dot( u, c );\n    float e = dot( v, c );\n    float f = dot( c, c ) - 0.25;\n    float s = 4.0 * a * f - b * b;\n    float p0 = b * e - c * d;\n    float p1 = b * d - a * e;\n    float q = vec3( -d, e - b * l, f - a * l ) * inversesqrt( vec3( s, p1 * inversesqrt( s ), p0 * inversesqrt( s ) ) );\n    vec3 res0 = c + q * v - ra * r;\n    vec3 res1 = c + q * v + ra * r;\n    return bound3( min( res0, res1 ), max( res0, res1 ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/boundingsphere/boundingsphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - r, p + r );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a box (http://iquilezles.org/www/articles/orientedbbox/orientedbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BoxAABB( in vec3 p, in vec3 b )\n{", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float babo = dot(ba,oa);\n    float raba = ra*baba;\n    float bab2 = baba*2.;\n    float denom = bab2 - babo*babo;\n    float t = -1.;\n    if( denom>0. )\n    {\n        float t1 = (babo-sqrt(denom))/bab2;\n        float t2 = (babo+sqrt(denom))/bab2;\n        float ta = t1<t2?t1:t2;\n        float tb = t1>t2?t1:t2;\n        t = ta>0.?ta:tb;\n    }\n    vec3 pos = ro + t*rd;\n    vec3 nor = normalize( pos-pa );\n    return vec4( t, nor );\n}\n\n// ray-cylinder intersetion (returns t and normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra, in float rb ) // point a, point b, radius\n{\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float babo = dot(ba,oa);\n    float raba = ra*baba;\n    float bab2 = baba*2.;\n    float denom = bab2 - babo*babo;\n    float t = -1.;\n    if( denom>0. )\n    {\n        float t1 = (babo-sqrt(denom))/bab2;\n        float t2 = (babo+sqrt(denom))/bab2;\n        float ta = t1<t2?t1:t2;\n        float tb = t1>t2?t1:t2;\n        t = ta>0.?ta:tb;\n   ", "\n    vec3 m = (ro - cen) / rad;\n    vec3 n = sign(m);\n    m = abs(m) - 1.0;\n    vec3 q = n * m * 0.5;\n    vec2 h = max(q.xy, q.yz);\n    float t = min(max(h.x, h.y), 0.0) + length(max(h, 0.0));\n    float d = length(max(m - q, 0.0));\n    return vec2(t, d);\n}\n\n// ray-sphere intersection\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) \n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// ray-plane intersection\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) \n{\n    return -ro.y / rd.y;\n}\n\n// ray-triangle intersection\nvec2 iTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 ) \n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross(rd, e2);\n    float det = dot(e1, p);\n    if (det < 1e-8) return vec2(-1.0);\n    float invDet = 1.0 / det;\n    vec3 t = ro - v0;\n    float u = dot(t, p) * invDet;\n    if (u < 0.0 || u > 1.", "\n    vec3 pa2 = pa - rd * r;\n    vec3 pb2 = pb - rd * r;\n    vec3 pa2pb2 = pa2 - pb2;\n    vec3 pa2ro = pa2 - ro;\n    float a = dot( pa2pb2, pa2pb2 );\n    float b = 2.0 * dot( pa2pb2, pa2ro );\n    float c = dot( pa2ro, pa2ro ) - r * r;\n    float h = b * b - 4.0 * a * c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float t1 = (-b - h) / (2.0 * a);\n    float t2 = (-b + h) / (2.0 * a);\n    float t = t1;\n    if( t < 0.0 ) t = t2;\n    if( t < 0.0 ) return -1.0;\n    vec3 q = ro + rd * t;\n    float u = dot( q - pa, pb - pa );\n    float v = dot( q - pb, pa - pb );\n    if( u < 0.0 || u > dot( pb - pa, pb - pa ) ) return -1.0;\n    if( v < 0.0 || v > dot( pa - pb, pa - pb ) ) return -1.0;\n    return t;\n}\n\n// intersect sphere : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w * sph.w;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// intersect plane : http", "\n    vec3 n = normalize( pos - a );\n    vec3 u = normalize( b - a );\n    vec3 v = normalize( cross( n, u ) );\n    return normalize( u * r * cos( pos.x ) + v * r * sin( pos.x ) );\n}\n\n// compute tangent\nvec3 capTangent( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 n = normalize( pos - a );\n    vec3 u = normalize( b - a );\n    vec3 v = normalize( cross( n, u ) );\n    return normalize( u * r * sin( pos.x ) - v * r * cos( pos.x ) );\n}\n\n// compute bitangent\nvec3 capBitangent( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 n = normalize( pos - a );\n    vec3 u = normalize( b - a );\n    vec3 v = normalize( cross( n, u ) );\n    return normalize( v * r );\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h )\n{\n    vec3 n = normalize( pos - a );\n    vec3 u = normalize( b - a );\n    vec3 v = normalize( cross( n, u ) );\n    return normalize( u * r * cos( pos.x ) + v * r * sin( pos.x ) + v * h );\n}\n\n// compute tangent\nvec3 capTangent( in vec3 pos, in vec3 a, in vec3 b, in float r, in float h )\n{\n    vec3 n = normalize( pos - a );\n    vec3 u = normalize( b - a );\n    vec3 v = normalize( cross( n, u ) );\n    return normalize( u * r * sin( pos.x ) - v * r * cos(", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// ray-box intersection in world space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad, in mat3 m ) \n{\n    vec3 rd_ = m*rd;\n    vec3 ro_ = m*(ro-vec3(0.0));\n    return iBox( ro_, rd_, rad );\n}\n\n// ray-sphere intersection in box space\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    float b = dot(n,n);\n    float d = sqrt(b*b - dot(n,n)*rad*rad);\n    return vec2( -d-b, d-b );\n}\n\n// ray-sphere intersection in world space\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad, in mat3 m ) \n{\n    vec3 rd_ = m*rd;\n    vec3 ro_ = m*(ro-vec3(0.0));\n    return iSphere( ro_, rd_, rad );\n}\n\n// ray-plane intersection in box space\nvec2 iPlane( in vec3 ro, in vec3 rd, in vec3 n, in float d ) \n{\n    float denom = dot(n,rd);\n    if ( denom > 0.0 ) return vec2( -1.0, -1.0 );\n    return vec2( -dot", "\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tmid = 0.0;\n    float tmid2 = 0.0;\n    float tmid3 = 0.0;\n    float tmid4 = 0.0;\n    float tmid5 = 0.0;\n    float tmid6 = 0.0;\n    float tmid7 = 0.0;\n    float tmid8 = 0.0;\n    float tmid9 = 0.0;\n    float tmid10 = 0.0;\n    float tmid11 = 0.0;\n    float tmid12 = 0.0;\n    float tmid13 = 0.0;\n    float tmid14 = 0.0;\n    float tmid15 = 0.0;\n    float tmid16 = 0.0;\n    float tmid17 = 0.0;\n    float tmid18 = 0.0;\n    float tmid19 = 0.0;\n    float tmid20 = 0.0;\n    float tmid21 = 0.0;\n    float tmid22 = 0.0;\n    float tmid23 = 0.0;\n    float tmid24 = 0.0;\n    float tmid25 = 0.0;\n    float tmid26 = 0.0;\n    float tmid27 = 0.0;\n    float tmid28 = 0.0;\n    float tmid29 = 0.0;\n    float tmid30 = 0.0;\n    float tmid31 = 0.0;\n    float tmid32 = 0.0;\n    float tmid33 = 0.0;\n    float tmid34 = 0.0;\n    float tmid35 = 0.0;\n    float tmid36 = 0.0;\n    float tmid37 = 0.0;\n    float tmid38 = 0.0;\n    float tmid39 = 0.0;\n    float tmid40 = 0.0;\n    float tmid41 = 0.0", "\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(phi), r*sin(phi), z);\n}\n\nvec3 inverseSF( float i, float n) \n{\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(phi), r*sin(phi), z);\n}\n\nvec3 forwardSF( float i, float n, float r) \n{\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(phi), r*sin(phi), z);\n}\n\nvec3 inverseSF( float i, float n, float r) \n{\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(phi), r*sin(phi), z);\n}\n\nvec3 forwardSF( float i, float n, float r, float z) \n{\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(phi), r*sin(phi), z);\n}\n\nvec3 inverseSF( float i, float n, float r, float z) \n{\n    float phi = (i+0.5)/n * 2.0 * PI;\n    float z = i/n;\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(", "\n    vec3 p = ro;\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tmid = 0.0;\n    float tmid2 = 0.0;\n    float tmid3 = 0.0;\n    float tmid4 = 0.0;\n    float tmid5 = 0.0;\n    float tmid6 = 0.0;\n    float tmid7 = 0.0;\n    float tmid8 = 0.0;\n    float tmid9 = 0.0;\n    float tmid10 = 0.0;\n    float tmid11 = 0.0;\n    float tmid12 = 0.0;\n    float tmid13 = 0.0;\n    float tmid14 = 0.0;\n    float tmid15 = 0.0;\n    float tmid16 = 0.0;\n    float tmid17 = 0.0;\n    float tmid18 = 0.0;\n    float tmid19 = 0.0;\n    float tmid20 = 0.0;\n    float tmid21 = 0.0;\n    float tmid22 = 0.0;\n    float tmid23 = 0.0;\n    float tmid24 = 0.0;\n    float tmid25 = 0.0;\n    float tmid26 = 0.0;\n    float tmid27 = 0.0;\n    float tmid28 = 0.0;\n    float tmid29 = 0.0;\n    float tmid30 = 0.0;\n    float tmid31 = 0.0;\n    float tmid32 = 0.0;\n    float tmid33 = 0.0;\n    float tmid34 = 0.0;\n    float tmid35 = 0.0;\n    float tmid36 = 0.0;\n    float tmid37 = 0.0;\n    float tmid38 = 0.0;\n   ", "\n    vec3 n = vec3(0.0);\n    n.xy = p;\n    n.z = texture( iChannel0, p*.0625 ).x;\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p )\n{\n    vec3 n = vec3(0.0);\n    n.xy = p.xy;\n    n.z = texture( iChannel0, p.xy*.0625 ).x;\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec4 p )\n{\n    vec3 n = vec3(0.0);\n    n.xy = p.xy;\n    n.z = texture( iChannel0, p.xy*.0625 ).x;\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p, in float time )\n{\n    vec3 n = vec3(0.0);\n    n.xy = p;\n    n.z = texture( iChannel0, p*.0625 + time*.0001 ).x;\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec3 p, in float time )\n{\n    vec3 n = vec3(0.0);\n    n.xy = p.xy;\n    n.z = texture( iChannel0, p.xy*.0625 + time*.0001 ).x;\n    return n;\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec4 p, in float time )\n{\n    vec3 n = vec3(0.0);\n    n.xy = p.xy;\n    n.z = texture( iChannel0, p.xy*.0625 + time*.0001 ).x;\n    return n", "\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat sphereDist(vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothSubtract(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat smoothIntersect(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat smoothMax(float d1, float d2, float k", "\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    float angle_offset = angle + PI;\n    float angle_offset_2 = angle_offset + PI;\n    float angle_offset_3 = angle_offset_2 + PI;\n    float angle_offset_4 = angle_offset_3 + PI;\n    float angle_offset_5 = angle_offset_4 + PI;\n    float angle_offset_6 = angle_offset_5 + PI;\n    float angle_offset_7 = angle_offset_6 + PI;\n    float angle_offset_8 = angle_offset_7 + PI;\n    float angle_offset_9 = angle_offset_8 + PI;\n    float angle_offset_10 = angle_offset_9 + PI;\n    float angle_offset_11 = angle_offset_10 + PI;\n    float angle_offset_12 = angle_offset_11 + PI;\n    float angle_offset_13 = angle_offset_12 + PI;\n    float angle_offset_14 = angle_offset_13 + PI;\n    float angle_offset_15 = angle_offset_14 + PI;\n    float angle_offset_16 = angle_offset_15 + PI;\n    float angle_offset_17 = angle_offset_16 + PI;\n    float angle_offset_18 = angle_offset_17 + PI;\n    float angle_offset_19 = angle_offset_18 + PI;\n    float angle_offset_20 = angle_offset_19 + PI;\n    float angle_offset_21 = angle_offset_20 + PI;\n    float angle_offset_22 = angle_offset_21 + PI;\n    float angle_offset_23 = angle_offset_22 + PI;\n    float angle_offset_24 = angle_offset_23 + PI;\n    float angle_offset_25 = angle_offset_24 + PI;\n    float angle_offset_26 = angle_offset", "\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r = fract(a / (3.1415926535897932384626433832795 / 3.0));\n    float f = smoothstep(0.0, 1.0, fract(d * 10.0));\n    col = mix(vec3(0.0), vec3(1.0), f);\n    return col;\n}\n\n// Pattern 3\nvec3 pat3(vec2 uv, vec2 orient)\n{\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r = fract(a / (3.1415926535897932384626433832795 / 3.0));\n    float f = smoothstep(0.0, 1.0, fract(d * 10.0));\n    col = mix(vec3(0.0), vec3(1.0), f);\n    return col;\n}\n\n// Pattern 4\nvec3 pat4(vec2 uv, vec2 orient)\n{\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r = fract(a / (3.1415926535897932384626433832795 / 3.0));\n    float f = smoothstep(0.0, 1.0, fract(d * 10.0));\n    col = mix(vec3(0.0), vec3(1.0), f);\n    return col;\n}\n\n// Pattern 5\nvec3 pat5(vec2 uv, vec2", "\n    vec2 g = dFdx( p );\n    vec2 g2 = dFdy( p );\n    return 0.5 * ( dot( g, ddx ) + dot( g2, ddy ) );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    return gridTextureGradBox( p, ddx, ddy ) / ( gridTextureGradBox( p, vec2( 1.0 ), vec2( 1.0 ) ) + 1.0 );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p )\n{\n    return gridTextureGrad( p, dFdx( p ), dFdy( p ) );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec3 p )\n{\n    return gridTextureGrad( p.xy, dFdx( p.xy ), dFdy( p.xy ) );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec4 p )\n{\n    return gridTextureGrad( p.xy, dFdx( p.xy ), dFdy( p.xy ) );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGradBox( p, ddx, ddy ) / ( gridTextureGradBox( p, vec2( 1.0 ), vec2( 1.0 ) ) + scale );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec3 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGrad( p.xy, ddx, ddy, scale );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec4 p, in vec2 ddx, in vec2 ddy, in float scale )\n{\n    return gridTextureGrad( p.xy, ddx, ddy, scale );\n}\n\n// grid ratio\nfloat gridTextureGrad( in vec2 p, in vec2 ddx, in vec2 ddy", "\n    vec3 d = vec3(0.0);\n    d.x = map(p+vec3(0.001,0.0,0.0)).x - map(p-vec3(0.001,0.0,0.0)).x;\n    d.y = map(p+vec3(0.0,0.001,0.0)).y - map(p-vec3(0.0,0.001,0.0)).y;\n    d.z = map(p+vec3(0.0,0.0,0.001)).z - map(p-vec3(0.0,0.0,0.001)).z;\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in float t )\n{\n    vec3 d = vec3(0.0);\n    d.x = map(p+vec3(0.001,0.0,0.0),t).x - map(p-vec3(0.001,0.0,0.0),t).x;\n    d.y = map(p+vec3(0.0,0.001,0.0),t).y - map(p-vec3(0.0,0.001,0.0),t).y;\n    d.z = map(p+vec3(0.0,0.0,0.001),t).z - map(p-vec3(0.0,0.0,0.001),t).z;\n    return d;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p, in vec3 t )\n{\n    vec3 d = vec3(0.0);\n    d.x = map(p+vec3(0.001,0.0,0.0),t).x - map(p-vec3(0.001,0.0,0.0),t).x;\n    d.y", "\n    v33 c=a;\n    a=b;\n    b=c;\n}\n\n//this is the main function that does the ray-transpose\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c){\n    v33 d=a;\n    a=b;\n    b=c;\n    c=d;\n}\n\n//this is the main function that does the ray-transpose\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c,inout v33 d){\n    v33 e=a;\n    a=b;\n    b=c;\n    c=d;\n    d=e;\n}\n\n//this is the main function that does the ray-transpose\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e){\n    v33 f=a;\n    a=b;\n    b=c;\n    c=d;\n    d=e;\n    e=f;\n}\n\n//this is the main function that does the ray-transpose\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e,inout v33 f){\n    v33 g=a;\n    a=b;\n    b=c;\n    c=d;\n    d=e;\n    e=f;\n    f=g;\n}\n\n//this is the main function that does the ray-transpose\nvoid rayTransp(inout v33 a,inout v33 b,inout v33 c,inout v33 d,inout v33 e,inout v33 f,inout v33 g){\n    v33 h=a;\n    a=b;\n    b=c;\n    c=d;\n    d=e;\n    e=f;\n    f=g;\n    g=h;\n}\n\n//this", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 add(v33 a,vec3 b){\n    return v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n    return v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n    return v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mod(v33 a,vec3 b){\n    return v33(a.x%b.x,a.y%b.y,a.z%b.z);\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 pow(v33 a,vec3 b){\n    return v33(pow(a.x,b.x),pow(a.y,b.y),pow(a.z,b.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 max(v33 a,vec3 b){\n    return v33(max(a.x,b.x),max(a.y,b.y),max(a.z,b.z));\n}\n\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 min(v33 a,vec3 b){\n    return v33(min(a.x,b.x", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//component wise ray addition(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 addc(v33  a,v33 b){\n    return v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n//component wise ray multiplication(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 mulc(v33  a,v33 b){\n    return v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n//component wise ray division(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 divc(v33  a,v33 b){\n    return v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n//component wise ray modulo(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 modc(v33  a,v33 b){\n    return v33(fmod(a.x,b.x),fmod(a.y,b.y),fmod(a.z,b.z));\n}\n//component wise ray power(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 powc(v33  a,v33 b){\n    return v33(pow(a.x,b.x),pow(a.y,b.y),pow(a.z,b.z));\n}\n//component wise ray square root(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 sqrtc(v33  a){\n    return v33(sqrt(a.x),sqrt(a.y),sqrt(a.z));\n}\n//component wise ray cube root(this one is a bit odd", "\n    return v2(length(b.x-a.x),length(b.y-a.y));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n    return v2(length(b.x-a.x),length(c.x-a.x));\n}\n\n//v33-differentials for AA\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v3", "\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,v33 f,v33 g,v33 h){\n    return vec2(dot(a,b),dot(a,b));\n}\n\n//dual dotprodiuct on v33s\nvec2 dt(v33 a,v33 b,v33 c,v33 d,v33 e,", "\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\nv33 mul(v33 a,v33 b){\n    return v33(a.x*b.x,a.y*b.x,a.z*b.x,a.x*b.y,a.y*b.y,a.z*b.y,a.x*b.z,a.y*b.z,a.z*b.z);\n}\nv33 mul(v33 a,float b){\n    return v33(a.x*b,a.y*b,a.z*b,a.x*b,a.y*b,a.z*b,a.x*b,a.y*b,a.z*b);\n}\nv33 mul(float a,v33 b){\n    return v33(a*b.x,a*b.y,a*b.z,a*b.x,a*b.y,a*b.z,a*b.x,a*b.y,a*b.z);\n}\nv33 mul(v33 a,mat3 b){\n    return v33(a.x*b.x.x+a.y*b.x.y+a.z*b.x.z,a.x*b.y.x+a.y*b.y.y+a.z*b.y.z,a.x*b.z.x+a.y*b.z.y+a.z*b.z.z,a.x*b.x.x+a.y*b.x.y+a.z*b.x.z,a.x*b.y.x+a.y*b.y.y+a.z*b.y.z,a.x*", "\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF3(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF4(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF5(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF6(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF7(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat checkerF8(vec3 p,vec3 w){\n    vec3 a=abs(fract(p)-.5);\n    a=min(a,1.-a);\n    return max(a.x,max(a.y,a.z));\n}\n", "\n    vec3 a=p*w;\n    vec3 b=floor(a);\n    vec3 c=fract(a);\n    vec3 d=c*c*(3.0-2.0*c);\n    vec3 e=b+vec3(0.0,1.0,2.0);\n    vec3 f=mix(mix(mix(fract(sin(e)*43758.5453),fract(sin(e.y)*43758.5453),d.x),\n                   mix(fract(sin(e.z)*43758.5453),fract(sin(e.x)*43758.5453),d.x),d.y),\n               mix(mix(fract(sin(e.x)*43758.5453),fract(sin(e.y)*43758.5453),d.x),\n                   mix(fract(sin(e.z)*43758.5453),fract(sin(e.x)*43758.5453),d.x),d.y),d.z);\n    return mix(mix(f.x,f.y,d.z),mix(f.z,f.w,d.z),d.y);\n}\n\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF3()\nfloat checkerF2(vec3 p,vec3 w){\n    vec3 a=p*w;\n    vec3 b=floor(a);\n    vec3 c=fract(a);\n    vec3 d=c*c*(3.0-2.0*c);\n    vec3 e=b+vec3(0.0,1.0,2.0);\n    vec3 f=mix(mix(mix(fract(sin(e)*43758.5453),fract(sin(e.y)*43758.5453),d.x),\n                   mix", "\n    v33 o=r.xyz-s.xyz;\n    float b=dot(o,r.xyz);\n    float c=dot(o,o)-s.w*s.w;\n    float d=b*b-c;\n    if(d<0.0)return 0.0;\n    return (b-sqrt(d))/c;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k){\n    v33 o=r.xyz-s.xyz;\n    float b=dot(o,r.xyz);\n    float c=dot(o,o)-s.w*s.w;\n    float d=b*b-c;\n    if(d<0.0)return 0.0;\n    return (b-sqrt(d))/c;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float d){\n    v33 o=r.xyz-s.xyz;\n    float b=dot(o,r.xyz);\n    float c=dot(o,o)-s.w*s.w;\n    float d=b*b-c;\n    if(d<0.0)return 0.0;\n    return (b-sqrt(d))/c;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float d,float e){\n    v33 o=r.xyz-s.xyz;\n    float b=dot(o,r.xyz);\n    float c=dot(o,o)-s.w*s.w;\n    float d=b*b-c;\n    if(d<0.0)return 0.0;\n    return (b-sqrt(d))/c;\n}\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s,float k,float d,float e,float", "\n    vec3 v=u-s.xyz;\n    float b=dot(v,n);\n    float c=dot(v,v)-s.w*s.w;\n    float d=b*b-c;\n    if(d>0.0)return 0.0;\n    return 1.0;\n}\n\n//box occlusion\nfloat occBox(vec3 u,vec3 n,vec4 s){\n    vec3 v=u-s.xyz;\n    vec3 m=abs(v)-s.w;\n    float c=max(m.x,max(m.y,m.z));\n    float d=min(max(m.x,max(m.y,m.z)),0.0);\n    float b=dot(v,n);\n    if(b>0.0)return 0.0;\n    if(c<0.0)return 1.0;\n    return (1.0-d/c);\n}\n\n//capsule occlusion\nfloat occCapsule(vec3 u,vec3 n,vec4 s){\n    vec3 v=u-s.xyz;\n    float b=dot(v,n);\n    float c=dot(v,v)-s.w*s.w;\n    float d=b*b-c;\n    if(d>0.0)return 0.0;\n    return 1.0;\n}\n\n//cylinder occlusion\nfloat occCylinder(vec3 u,vec3 n,vec4 s){\n    vec3 v=u-s.xyz;\n    float b=dot(v,n);\n    float c=dot(v,v)-s.w*s.w;\n    float d=b*b-c;\n    if(d>0.0)return 0.0;\n    return 1.0;\n}\n\n//cone occlusion\nfloat occCone(vec3 u,vec3 n,vec4 s){\n    vec3 v=u-s.xyz;\n    float b=dot(v,n);\n    float c=dot(v", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p02 = p2 - p0;\n    vec2 p012 = p2 - p0;\n    vec2 p012_2 = p012 * 2.0;\n    vec2 p01_2 = p01 * 2.0;\n    vec2 p12_2 = p12 * 2.0;\n    vec2 p0_2 = p0 * 2.0;\n    vec2 p1_2 = p1 * 2.0;\n    vec2 p2_2 = p2 * 2.0;\n    vec2 p01_p012 = p01 + p012;\n    vec2 p01_p012_2 = p01_p012 * 2.0;\n    vec2 p01_p012_2_p012 = p01_p012_2 + p012;\n    vec2 p01_p012_2_p012_2 = p01_p012_2_p012 * 2.0;\n    vec2 p01_p012_2_p012_2_p012 = p01_p012_2_p012_2 + p012;\n    vec2 p01_p012_2_p012_2_p012_2 = p01_p012_2_p012_2_p012 * 2.0;\n    vec2 p01_p012_2_p012_2_p012_2_p012 = p01_p012_2_p012_2_p012_2 + p012;\n    vec2 p01_p012_2_p012_2_p012", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p0122 = mix(p012, p2, 0.5);\n    vec2 p01222 = mix(p0122, p2, 0.5);\n    vec2 p012222 = mix(p01222, p2, 0.5);\n    vec2 p0122222 = mix(p012222, p2, 0.5);\n    vec2 p01222222 = mix(p0122222, p2, 0.5);\n    vec2 p012222222 = mix(p01222222, p2, 0.5);\n    vec2 p0122222222 = mix(p012222222, p2, 0.5);\n    vec2 p01222222222 = mix(p0122222222, p2, 0.5);\n    vec2 p012222222222 = mix(p01222222222, p2, 0.5);\n    vec2 p0122222222222 = mix(p012222222222, p2, 0.5);\n    vec2 p01222222222222 = mix(p0122222222222, p2, 0.5);\n    vec2 p012222222222222 = mix(p01222222222222, p2, 0.5", "\n    bound3 b;\n    b.min = vec3( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ),\n                  min( min( p0.y, p1.y ), min( p2.y, p3.y ) ),\n                  min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    b.max = vec3( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ),\n                  max( max( p0.y, p1.y ), max( p2.y, p3.y ) ),\n                  max( max( p0.z, p1.z ), max( p2.z, p3.z ) ) );\n    return b;\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4 )\n{\n    bound3 b;\n    b.min = vec3( min( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ), p4.x ),\n                  min( min( min( p0.y, p1.y ), min( p2.y, p3.y ) ), p4.y ),\n                  min( min( min( p0.z, p1.z ), min( p2.z, p3.z ) ), p4.z ) );\n    b.max = vec3( max( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ), p4.x ),\n                  max( max( max( p0.y, p1.y ), max( p2.y, p3.y ) ), p4.y ),\n                  max( max( max( p0", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n\n    vec2 min = min(min(p0, p1), min(p2, p3));\n    vec2 max = max(max(p0, p1), max(p2, p3));\n\n    return vec4(min(min(min, p01), min(p12, p23)), max(max(max, p01), max(p12, p23)), 0.0, 0.0);\n}\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p23 = mix(p2, p3, 0.5);\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p123 = mix(p12, p23, 0.5);\n    vec2 p0123 = mix(p012, p123, 0.5);\n\n    vec2 p01234 = mix(p0123, p0123, 0.5);\n\n    vec2 min = min(min(min(p0, p1), min(p2, p3)), p", "\n    vec2 p = mix(mix(p0, p1, pos.x), mix(p1, p2, pos.x), pos.y);\n    return mix(p, p3, pos.y);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos, out vec2 deriv)\n{\n    vec2 p = mix(mix(p0, p1, pos.x), mix(p1, p2, pos.x), pos.y);\n    vec2 dp = mix(p1 - p0, p2 - p1, pos.x);\n    deriv = mix(dp, p2 - p1, pos.x);\n    return mix(p, p3, pos.y);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos, out vec2 deriv, out vec2 deriv2)\n{\n    vec2 p = mix(mix(p0, p1, pos.x), mix(p1, p2, pos.x), pos.y);\n    vec2 dp = mix(p1 - p0, p2 - p1, pos.x);\n    deriv = mix(dp, p2 - p1, pos.x);\n    vec2 ddp = p2 - 2.0 * p1 + p0;\n    deriv2 = mix(ddp, 2.0 * (p2 - p1), pos.x);\n    return mix(p, p3, pos.y);\n}\n\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 pos, out vec2 deriv, out vec2 deriv2, out vec2 deriv3)\n{\n    vec2 p = mix(mix(p0, p1, pos.x), mix(p1, p2, pos.x), pos.y);\n    vec2 dp = mix(p1 - p0, p2 - p1, pos.", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    vec3 q = cross( ro - v0, e1 );\n    vec3 t = vec3( dot( q, e2 ), dot( p, ro - v0 ), dot( q, v0 ) );\n    vec3 uv = vec3( dot( p, e1 ), dot( q, rd ), dot( p, ro - v0 ) );\n    return vec3( t.x / t.z, uv.x / uv.z, uv.y / uv.z );\n}\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 n0, in vec3 n1, in vec3 n2 )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( rd, e2 );\n    vec3 q = cross( ro - v0, e1 );\n    vec3 t = vec3( dot( q, e2 ), dot( p, ro - v0 ), dot( q, v0 ) );\n    vec3 uv = vec3( dot( p, e1 ), dot( q, rd ), dot( p, ro - v0 ) );\n    return vec3( t.x / t.z, uv.x / uv.z, uv.y / uv.z );\n}\n\n// Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 n0, in vec3 n1, in vec3 n2, in vec2 tex0, in vec2 tex1, in vec2", "\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 n = cross( e0, e1 );\n    vec3 p = cross( n, e0 );\n    vec3 q = cross( n, e1 );\n    vec3 r = cross( p, q );\n    vec3 v = pos - v0;\n    float d = dot( v, r );\n    return d;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 e2 = v3 - v0;\n    vec3 n = cross( e0, e1 );\n    vec3 p = cross( n, e0 );\n    vec3 q = cross( n, e1 );\n    vec3 r = cross( p, q );\n    vec3 v = pos - v0;\n    float d = dot( v, r );\n    return d;\n}\n\n// Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4 )\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 e2 = v3 - v0;\n    vec3 e3 = v4 - v0;\n    vec3 n = cross( e0, e1 );\n    vec3 p = cross( n, e0 );\n    vec3 q = cross( n, e1 );\n    vec3 r = cross( p, q );\n    vec3 v = pos - v0;\n    float d = dot( v, r );\n    return d;\n", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);          \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0 )\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h) - q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.7320508075688772935274463415059;\n        vec3  t = clamp( vec3(m+m, -n-m, n-m)*z - kx, 0.0, 1.0 );\n        res = min( dot2(d + (c + b*t.x)*t.x),\n                   dot2(d + (c + b*t.", "\n    vec2 k = vec2(r1,he);\n    p.x = abs(p.x);\n    vec2 d1 = vec2( p.x-max(p.y,0.0),k.y );\n    vec2 d2 = vec2( p.x+max(p.y,0.0),k.y );\n    vec2 d = (p.y<=0.0)? d1 : d2;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r2;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k = vec2(r1,he);\n    p.y = abs(p.y);\n    vec2 d1 = vec2( p.y-max(p.x,0.0),k.y );\n    vec2 d2 = vec2( p.y+max(p.x,0.0),k.y );\n    vec2 d = (p.x<=0.0)? d1 : d2;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r2;\n}\n\n// trapezoid / capped cone, specialized for X alignment\nfloat sdTrapezoid( in vec3 p, in float r1, float r2, float he )\n{\n    vec2 k = vec2(r1,he);\n    p.yz = abs(p.yz);\n    vec2 d1 = vec2( p.y-max(p.z,0.0),k.y );\n    vec2 d2 = vec2( p.y+max(p.z,0.0),k.y );\n    vec2 d = (p.z<=0.0)? d1 : d2;\n    return min(max(d.x,d", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = dot(pa,pa) - h*h*dot(ba,ba);\n    float r = mix( ra, rb, h );\n    return d<r*r? sqrt(d) * sign(p.y-a.y) : length(pa-ba*h);\n}\n\n// capped cone\nfloat sdCappedCone( in vec3 p, in float h, in float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// capped cone\nfloat sdCappedCone( in vec3 p, in float h, in float r1, float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// capped cone\nfloat sdCappedCone( in vec3 p, in float h, in float r1,", "\n    vec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat s", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    vec3 nor = vec3(0.0);\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.0;\n", "\n    q = ivec2( q.x * 127.0, q.y * 123.0 );\n    return fract(sin(dot(vec2( q.x, q.y * 1.00000314159265358979323846264338327950288419716939937510 ), vec2( 12.9898, 78.233 ) )) * 43758.5453);\n}\n\n// random value in [0, 1]\nfloat rand( in ivec2 q )\n{\n    return hash( q );\n}\n\n// random value in [-1, 1]\nfloat rand2( in ivec2 q )\n{\n    return rand( q ) * 2.0 - 1.0;\n}\n\n// random value in [0, 1]\nfloat rand( in vec2 q )\n{\n    return rand( ivec2( q ) );\n}\n\n// random value in [-1, 1]\nfloat rand2( in vec2 q )\n{\n    return rand2( ivec2( q ) );\n}\n\n// random value in [0, 1]\nfloat rand( in float q )\n{\n    return rand( ivec2( q ) );\n}\n\n// random value in [-1, 1]\nfloat rand2( in float q )\n{\n    return rand2( ivec2( q ) );\n}\n\n// random value in [0, 1]\nfloat rand( in ivec3 q )\n{\n    return rand( ivec2( q.xy ) );\n}\n\n// random value in [-1, 1]\nfloat rand2( in ivec3 q )\n{\n    return rand2( ivec2( q.xy ) );\n}\n\n// random value in [0, 1]\nfloat rand( in vec3 q )\n{\n    return rand( ivec3( q )", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = dot(i, vec2(1.0, 57.0));\n    float b = dot(i+vec2(1.0, 0.0), vec2(57.0, 58.0));\n    float c = dot(i+vec2(0.0, 1.0), vec2(58.0, 59.0));\n    float d = dot(i+vec2(1.0, 1.0), vec2(59.0, 60.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(a,f-vec2(0.0, 0.0)), dot(b,f-vec2(1.0, 0.0)), u.x),\n                   mix(dot(c,f-vec2(0.0, 1.0)), dot(d,f-vec2(1.0, 1.0)), u.x), u.y),\n               mix(mix(dot(a,f-vec2(0.0, 0.0)), dot(b,f-vec2(1.0, 0.0)), u.x),\n                   mix(dot(c,f-vec2(0.0, 1.0)), dot(d,f-vec2(1.0, 1.0)), u.x), u.y), u.y);\n}\n\n// basic value noise\nfloat noise( in vec3 x, in int p )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float a = dot(i, vec3(1.0, 57.0, 113.0));\n    float b = dot(i+vec3(1.0, 0.0, 0.0), vec3(57.0, 58.0, 59.0));\n    float c = dot(i+vec3(0.0, 1.0", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for( int i = 0; i < p; i++ )\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for( int i = 0; i < p; i++ )\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for( int i = 0; i < p; i++ )\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for( int i = 0; i < p; i++ )\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for( int i = 0; i <", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic sphere - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdSphere( in vec3 p, in float s )\n{\n    return length(p)-s;\n}\n\n// generic box - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// generic cylinder - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCylinder( in vec3 p, in vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\n// generic cone - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// generic torus - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// generic plane - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xy", "\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x)? p.xz : p.zx;\n    p.xz = (p.z>p.x)? p.xz : p.zx;\n    vec2 q = p.xz - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXYZ( in vec3 p, in vec3 r ) \n{\n    p.xyz = abs(p.xyz);\n    p.xyz = (p.z>p.y)? p.xyz : p.yzx;\n    p.xyz = (p.z>p.x)? p.xyz : p.zxy;\n    vec3 q = p.xyz - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    p.xyz = abs(p.xyz);\n    p.xyz = (p.z>p.y)? p.xyz : p.yzx;\n    p.xyz = (p.z>p.x)? p.xyz : p.zxy;\n    vec3 q = p.xyz - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoid( in vec3 p, in vec2 r ) \n{\n    p.xyz = abs(p.xyz);\n    p.xyz = (p.z>p.y)? p.xyz : p.yzx;\n", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in float smoothness ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in float smoothness, in float smoothness2 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in float smoothness, in float smoothness2, in float smoothness3 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in float smoothness, in float smoothness2, in float smoothness3, in float smoothness4 ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r, in float smoothness, in float smoothness2, in float smoothness3, in float smoothness4, in float smoothness5 )", "\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// generic sphere - improved approximated distance\nfloat sdSphere( in vec3 p, in float s ) \n{\n    return length(p)-s;\n}\n\n// generic box - improved approximated distance\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// generic torus - improved approximated distance\nfloat sdTorus( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// generic cylinder - improved approximated distance\nfloat sdCylinder( in vec3 p, in vec3 c ) \n{\n    return length(p.xz-c.xy)-c.z;\n}\n\n// generic plane - improved approximated distance\nfloat sdPlane( in vec3 p, in vec4 n ) \n{\n    return dot(p,n.xyz) + n.w;\n}\n\n// generic torus - improved approximated distance\nfloat sdTorus( in vec3 p, in vec2 t ) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// generic box - improved approximated distance\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// generic cylinder - improved approximated distance\nfloat sdC", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 m = vec2( 0.0 );\n    m.x = mix( hash( i + vec2( 0.0, 0.0 ) ),\n               hash( i + vec2( 1.0, 0.0 ) ), f.x );\n    m.y = mix( hash( i + vec2( 0.0, 1.0 ) ),\n               hash( i + vec2( 1.0, 1.0 ) ), f.x );\n    m = mix( m.x, m.y, f.y );\n\n    return m;\n}\n\nfloat checkersGradBox( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    vec3 m = vec3( 0.0 );\n    m.x = mix( hash( i + vec3( 0.0, 0.0, 0.0 ) ),\n               hash( i + vec3( 1.0, 0.0, 0.0 ) ), f.x );\n    m.y = mix( hash( i + vec3( 0.0, 0.0, 1.0 ) ),\n               hash( i + vec3( 1.0, 0.0, 1.0 ) ), f.x );\n    m.z = mix( hash( i + vec3( 0.0, 1.0, 0.0 ) ),\n               hash( i + vec3( 1.0, 1.0, 0.0 ) ), f.x );\n    m = mix( m.x, m.y, f.y );\n    m = mix( m.x, m.z, f.z );\n\n    return m;\n}\n\nfloat checkersGradBox( in vec4 p )\n{\n    vec4 i = floor( p );\n    vec4 f = fract( p );\n\n    vec4 m = vec4( 0.0 );\n    m", "\n    return a * x + (1.0 - a) * x * x * x;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x, float y )\n{\n    return a * x + (1.0 - a) * x * x * x * y;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x, float y, float z )\n{\n    return a * x + (1.0 - a) * x * x * x * y * z;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x, float y, float z, float w )\n{\n    return a * x + (1.0 - a) * x * x * x * y * z * w;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x, float y, float z, float w, float u )\n{\n    return a * x + (1.0 - a) * x * x * x * y * z * w * u;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x, float y, float z, float w, float u, float v )\n{\n    return a * x + (1.0 - a) * x * x * x * y * z * w * u * v;\n}\n\n// Schlick bias function, from http://dept-info.labri.u-borde", "\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased triangle\nfloat my_tri( float x, float p )\n{\n    return 2.0 * abs( 2.0 * ( x - p * floor( x / p ) ) - 1.0 ) - 1.0;\n}\n\n// biased square\nfloat my_sqr( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) ) < 1.0? 1.0 : -1.0;\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    return 2.0 * ( x - p * floor( x / p ) );\n}\n\n// biased sawtooth\nfloat my", "\n    float r = h * 0.5;\n    float g = h * 0.5;\n    float b = h * 0.5;\n\n    if ( h < 0.5 )\n    {\n        r = 1.0;\n        g = h * 2.0;\n    }\n    else\n    {\n        r = ( 1.0 - h ) * 2.0;\n        b = 1.0;\n    }\n\n    return vec3( r, g, b );\n}\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n}\n\nvec3 hsv2rgb( float h, float s, float v )\n{\n    return hsv2rgb( vec3( h, s, v ) );\n}\n\nvec3 rgb2hsv( vec3 c )\n{\n    vec4 K = vec4( 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 );\n    vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n    vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n\n    float d = q.x - min( q.w, q.y );\n    float e = 1.0e-10;\n    return vec3( abs( q.z + ( q.w - q.y ) / ( 6.0 * d + e ) ), d / (", "\n    vec3 pa2 = pa - ro;\n    vec3 pb2 = pb - ro;\n    vec3 ba = pb2 - pa2;\n    float baba = dot(ba,ba);\n    float r2 = r*r;\n    float rba = dot(ba,rd);\n    float c = dot(pa2,pa2) - r2;\n    float b = dot(pa2,rd);\n    float d = (b*b) - c;\n    float sI = -1.0;\n    float sqrtD = sqrt(d);\n    float s[2];\n    s[0] = (b-sqrtD);\n    s[1] = (b+sqrtD);\n    for( int i=0; i<2; i++ )\n    {\n        if( s[i]>=0.0 && s[i]<=baba )\n        {\n            float si = s[i];\n            float ti = (rba + si*baba)/babal;\n            float yi = si + 2.0*ti*rba/baba;\n            float xi = sqrt(r2 - yi*yi);\n            float zi = si*rba/baba;\n            float d2 = dot(pa2+xi*ba+zi*rd,pa2+xi*ba+zi*rd) - r2;\n            if( d2<0.0 )\n            {\n                if( si<0.0 )\n                    sI = -1.0;\n                else if( si>baba )\n                    sI = -1.0;\n                else\n                    sI = si;\n                break;\n            }\n        }\n    }\n    return sI;\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCone( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra, in float rb )\n{\n    vec3 ba = pb - pa;\n    float baba = dot(ba,ba);\n", "\n    float rba = rb-ra;\n    float baba = dot(b,b);\n    float papa = dot(a,a);\n    float paba = dot(a,b);\n    float x = dot(p,a);\n    float y = dot(p,b);\n    float x2 = x*x;\n    float y2 = y*y;\n    float d = (x*y*(paba-rba)-y2*ra-x2*rb) / (x2*paba-y2*baba);\n    float z = sqrt(max(0.0,d*d*(paba-2.0*d)+x2+y2));\n    return -z+ra;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0)? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    \n    float x = length( pa*baba-ba*paba ) - r1*", "\n    float res = 1.0;\n    float t = r;\n    for( int i=0; i<4; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<4; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<4; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.001, 0.1 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// fakesoft shadow occlusion\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<4; i++ )\n    {\n        float h = map( ro + rd*t ).x", "\n    float d = length(uv);\n    float a = atan(uv.y, uv.x);\n    float r = rad1 + (rad2 - rad1) * smoothstep(0.0, 1.0, abs(d - rad1) / (rad2 - rad1));\n    float s = smoothstep(rad1 - th, rad1, d) * smoothstep(rad2, rad2 + th, d);\n    return vec2(r * cos(a), r * sin(a)) * s;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    uv -= 0.5;\n    uv.x *= resolution.x / resolution.y;\n\n    vec2 p = snake(uv, 0.2, 0.8, 0.01);\n    vec2 q = snake(uv, 0.2, 0.8, 0.01);\n    vec2 r = snake(uv, 0.2, 0.8, 0.01);\n\n    vec3 col = vec3(0.0);\n    col += vec3(0.5000, 0.5000, 0.5000) * smoothstep(0.0, 0.01, length(p));\n    col += vec3(0.5000, 0.5000, 0.5000) * smoothstep(0.0, 0.01, length(q));\n    col += vec3(0.5000, 0.5000, 0.5000) * smoothstep(0.0, 0.01, length(r));\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    p.x = abs(p.x);\n    float l = length(p)-r;\n    float m = length(p-2.0*r*c);\n    float n = abs(p.x-r)-r;\n    float k = sign(p.y-r)*r-abs(p.y-r)-r;\n    if( k > 0.0 ) m = min(m,k);\n    return min(min(l,m),n);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec3 p, in vec2 c, in float r )\n{\n    p.xz = abs(p.xz);\n    float l = length(p)-r;\n    float m = length(p-2.0*r*c);\n    float n = abs(p.x-r)-r;\n    float k = sign(p.z-r)*r-abs(p.z-r)-r;\n    if( k > 0.0 ) m = min(m,k);\n    return min(min(l,m),n);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec4 p, in vec2 c, in float r )\n{\n    p.xyz = abs(p.xyz);\n    float l = length(p)-r;\n    float m = length(p-2.0*r*c);\n    float n = abs(p.x-r)-r;\n    float k = sign(p.z-r)*r-abs(p.z-r)-r;\n    if( k > 0.0 ) m = min(m,k);\n    return min(min(l,m),n);\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r, in float h )\n{\n    p.x = abs(p.x);\n    float l = length(p)-r;\n    float m = length(p-2.0*r*c", "\n    return 4.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 + z^2 - ra^2\nvec3 nSphere2( in vec3 pos )\n{\n    return 2.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^3 + y^3 + z^3 - ra^3\nvec3 nSphere3( in vec3 pos )\n{\n    return 3.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 - ra^2\nvec3 nCircle2( in vec3 pos )\n{\n    return 2.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^3 + y^3 - ra^3\nvec3 nCircle3( in vec3 pos )\n{\n    return 3.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 - ra^4\nvec3 nCircle4( in vec3 pos )\n{\n    return 4.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 - ra^2\nvec3 nCircle2( in vec3 pos )\n{\n    return 2.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 - ra^2\nvec3 nCircle2( in vec3 pos )\n{\n    return 2.0*pos;\n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^2 + y^2 - ra^2\nvec3 nCircle2( in vec3 pos )\n{", "\n    p.x = abs(p.x);\n    float k = dot(p,sca);\n    if( k > ra ) return length(p-sca*ra) - rb;\n    if( p.x > k ) {\n        if( p.y<0.0 ) return length(p-sca*k-scb*rb) - ra;\n        if( p.y>rb ) return length(p-sca*k+scb*rb) - ra;\n        return -ra;\n    }\n    if( p.y>rb ) return length(p-scb*rb) - ra;\n    if( p.y<-rb ) return length(p+scb*rb) - ra;\n    return -ra;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc )\n{\n    p.x = abs(p.x);\n    float k = dot(p,sca);\n    if( k > ra ) return length(p-sca*ra) - rb;\n    if( p.x > k ) {\n        if( p.y<0.0 ) return length(p-sca*k-scb*rb) - ra;\n        if( p.y>rb ) return length(p-sca*k+scb*rb) - ra;\n        return -ra;\n    }\n    if( p.y>rb ) return length(p-scb*rb) - ra;\n    if( p.y<-rb ) return length(p+scb*rb) - ra;\n    return -ra;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc, in float rd )\n{\n    p.x = abs(p.x);\n    float k = dot(p,sca);\n    if( k > ra ) return length(p-sca*ra) - rb;\n    if( p.x > k ) {\n        if( p.", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n           length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, time );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos, float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{\n    vec3 col = vec3(0.7,0.9,1.0);\n    vec2 res = iResolution.xy;\n\n    // raymarch\n    float t", "\n    vec2 p2 = p * 0.5;\n    vec2 p3 = p2 * 0.5;\n    vec2 p4 = p3 * 0.5;\n    vec2 p5 = p4 * 0.5;\n    vec2 p6 = p5 * 0.5;\n    vec2 p7 = p6 * 0.5;\n    vec2 p8 = p7 * 0.5;\n    vec2 p9 = p8 * 0.5;\n    vec2 p10 = p9 * 0.5;\n    vec2 p11 = p10 * 0.5;\n    vec2 p12 = p11 * 0.5;\n    vec2 p13 = p12 * 0.5;\n    vec2 p14 = p13 * 0.5;\n    vec2 p15 = p14 * 0.5;\n    vec2 p16 = p15 * 0.5;\n    vec2 p17 = p16 * 0.5;\n    vec2 p18 = p17 * 0.5;\n    vec2 p19 = p18 * 0.5;\n    vec2 p20 = p19 * 0.5;\n    vec2 p21 = p20 * 0.5;\n    vec2 p22 = p21 * 0.5;\n    vec2 p23 = p22 * 0.5;\n    vec2 p24 = p23 * 0.5;\n    vec2 p25 = p24 * 0.5;\n    vec2 p26 = p25 * 0.5;\n    vec2 p27 = p26 * 0.5;\n    vec2 p28 = p27 * 0.5;\n    vec2 p29 = p28 * 0.5;\n    vec2 p30 = p29 * 0.5;\n    vec2 p31", "\n    return floor(x*k)/k;\n}\n\n//\n// Smoothstep function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat smoothstep( in float x, in float k )\n{\n    return smoothstep(0.0,1.0,staircase(x,k));\n}\n\n//\n// Smootherstep function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat smootherstep( in float x, in float k )\n{\n    return smootherstep(0.0,1.0,staircase(x,k));\n}\n\n//\n// Smoothstep function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat smoothstep( in vec2 x, in float k )\n{\n    return smoothstep(0.0,1.0,staircase(x,k));\n}\n\n//\n// Smootherstep function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat smootherstep( in vec2 x, in float k )\n{\n    return smootherstep(0.0,1.0,staircase(x,k));\n}\n\n//\n// Smoothstep function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n//", "\n    vec3 sky_col = vec3(0.0);\n    float sky_intensity = 0.0;\n    float sky_intensity_max = 0.0;\n    float sky_intensity_min = 0.0;\n    float sky_intensity_step = 0.0;\n    float sky_intensity_step_max = 0.0;\n    float sky_intensity_step_min = 0.0;\n    float sky_intensity_step_min_max = 0.0;\n    float sky_intensity_step_min_max_step = 0.0;\n    float sky_intensity_step_min_max_step_max = 0.0;\n    float sky_intensity_step_min_max_step_min = 0.0;\n    float sky_intensity_step_min_max_step_min_max = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_max = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max_step = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max_step_max = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max_step_min = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max_step_min_max = 0.0;\n    float sky_intensity_step_min_max_step_min_max_step_min_max_step_min_max_step = 0.0;\n    float sky_intensity_step_min_max_step_min", "\n    vec4 color = vec4(0.0);\n    float dist = 0.0;\n\n    // render the planet\n    vec3 planet_pos = vec3(0.0, 0.0, 0.0);\n    float planet_radius = 1.0;\n    float planet_dist = sdSphere(pos - planet_pos, planet_radius);\n    if (planet_dist < dist) {\n        dist = planet_dist;\n        color = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n\n    return vec4(color.xyz, dist);\n}\n\n/*\nThe following function returns the color of the atmosphere\n\nin this case, the function renders a blue sky\ncolor is in.xyz, distance in.w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_atmosphere(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec4 color = vec4(0.0);\n    float dist = 0.0;\n\n    // render the sky\n    float sky_dist = sdSphere(pos, 1000.0);\n    if (sky_dist < dist) {\n        dist = sky_dist;\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n\n    return vec4(color.xyz, dist);\n}\n\n/*\nThe following function returns the color of the light\n\nin this case, the function renders a red light\ncolor is in.xyz, distance in.w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_light(vec3 pos, vec3 dir, vec3 light_dir) {\n    vec4 color = vec4(0.0);\n    float dist = 0.0;\n\n    // render the light\n    float light_dist = sdSphere(pos - light_dir, 0.1);\n", "\n    vec3 camera_vector = vec3(0.0);\n    camera_vector.x = (2.0 * (coord.x + 0.5) / resolution.x - 1.0) * resolution.z;\n    camera_vector.y = (2.0 * (coord.y + 0.5) / resolution.y - 1.0) * resolution.z;\n    camera_vector.z = -1.0;\n    return normalize(camera_vector);\n}\n\n/*\nthis function calculates the color of the current pixel\n*/\nvec3 get_color(vec3 resolution, vec2 coord) {\n    vec3 camera_vector = get_camera_vector(resolution, coord);\n    vec3 color = vec3(0.0);\n    color = ray_march(camera_vector);\n    return color;\n}\n\n/*\nthis function is the main function of the shader\nit calls the get_color function for each pixel and writes the result to the output buffer\n*/\nvoid main() {\n    vec2 coord = gl_FragCoord.xy;\n    vec3 color = get_color(resolution, coord);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float a2 = atan(c.x, c.y);\n    float da = atan(p.x, p.z) - a2;\n    float d = length(p.xz) * sign(p.z);\n    float r = length(p.xz) * c.y - p.y;\n    return sqrt(r*r + d*d) * sign(cos(da)) - ra;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb)\n{\n    float a2 = atan(c.x, c.y);\n    float da = atan(p.x, p.z) - a2;\n    float d = length(p.xz) * sign(p.z);\n    float r = length(p.xz) * c.y - p.y;\n    return max(sqrt(r*r + d*d) * sign(cos(da)) - ra, r - rb);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc)\n{\n    float a2 = atan(c.x, c.y);\n    float da = atan(p.x, p.z) - a2;\n    float d = length(p.xz) * sign(p.z);\n    float r = length(p.xz) * c.y - p.y;\n    return max(max(sqrt(r*r + d*d) * sign(cos(da)) - ra, r - rb), r - rc);\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra, float rb, float rc, float rd)\n{\n    float a2 = atan(c.x, c.y);\n    float da = atan(p.x, p.z) - a2;\n    float d = length(p.xz)", "\n    vec3 color = vec3(0.0);\n    if (material == 0) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 1) {\n        color = vec3(0.0, 0.0, 1.0);\n    } else if (material == 2) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else if (material == 3) {\n        color = vec3(0.0, 1.0, 0.0);\n    } else if (material == 4) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else if (material == 5) {\n        color = vec3(0.0, 1.0, 1.0);\n    } else if (material == 6) {\n        color = vec3(1.0, 0.0, 1.0);\n    } else if (material == 7) {\n        color = vec3(1.0, 1.0, 1.0);\n    } else if (material == 8) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 9) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 10) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 11) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 12) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 13) {\n        color = vec3(0.0, 0.0, 0.0);\n    } else if (material == 14) {\n        color = vec3(0.0, 0.0, 0.0", "\n    if (material == MATERIAL_GLASS) {\n        return 0.1;\n    } else if (material == MATERIAL_MIRROR) {\n        return 0.9;\n    } else if (material == MATERIAL_METAL) {\n        return 0.5;\n    } else if (material == MATERIAL_PLASTIC) {\n        return 0.5;\n    } else if (material == MATERIAL_WOOD) {\n        return 0.5;\n    } else if (material == MATERIAL_PAPER) {\n        return 0.5;\n    } else if (material == MATERIAL_LEATHER) {\n        return 0.5;\n    } else if (material == MATERIAL_CLOTH) {\n        return 0.5;\n    } else if (material == MATERIAL_STONE) {\n        return 0.5;\n    } else if (material == MATERIAL_ICE) {\n        return 0.5;\n    } else if (material == MATERIAL_GRASS) {\n        return 0.5;\n    } else if (material == MATERIAL_SAND) {\n        return 0.5;\n    } else if (material == MATERIAL_SNOW) {\n        return 0.5;\n    } else if (material == MATERIAL_WATER) {\n        return 0.5;\n    } else if (material == MATERIAL_LAVA) {\n        return 0.5;\n    } else if (material == MATERIAL_FIRE) {\n        return 0.5;\n    } else if (material == MATERIAL_EARTH) {\n        return 0.5;\n    } else if (material == MATERIAL_AIR) {\n        return 0.5;\n    } else if (material == MATERIAL_SKY) {\n        return 0.5;\n    } else if (material == MATERIAL_WATER_FLOW) {\n        return 0.5;", "\n    if (material == MATERIAL_AIR) {\n        return 1.0;\n    } else if (material == MATERIAL_GLASS) {\n        return 1.5;\n    } else if (material == MATERIAL_METAL) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_GOLD) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_SILVER) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_COPPER) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_ALUMINUM) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_TITANIUM) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_CHROME) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_NICKEL) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_COBALT) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_IRON) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_ZINC) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_COPPER_COATED) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_NICKEL_COATED) {\n        return 1.0;\n    } else if (material == MATERIAL_PLASTIC_ALUMINUM_COATED) {\n        return ", "\n    if (material == MATERIAL_AIR) {\n        return 1.0;\n    }\n    if (material == MATERIAL_GLASS) {\n        return 0.5;\n    }\n    if (material == MATERIAL_METAL) {\n        return 0.5;\n    }\n    if (material == MATERIAL_WATER) {\n        return 0.5;\n    }\n    if (material == MATERIAL_ICE) {\n        return 0.5;\n    }\n    if (material == MATERIAL_LAVA) {\n        return 0.5;\n    }\n    if (material == MATERIAL_SAND) {\n        return 0.5;\n    }\n    if (material == MATERIAL_SNOW) {\n        return 0.5;\n    }\n    if (material == MATERIAL_STONE) {\n        return 0.5;\n    }\n    if (material == MATERIAL_WOOD) {\n        return 0.5;\n    }\n    if (material == MATERIAL_LEAVES) {\n        return 0.5;\n    }\n    if (material == MATERIAL_PLANT) {\n        return 0.5;\n    }\n    if (material == MATERIAL_GRASS) {\n        return 0.5;\n    }\n    if (material == MATERIAL_FLOWER) {\n        return 0.5;\n    }\n    if (material == MATERIAL_TREE) {\n        return 0.5;\n    }\n    if (material == MATERIAL_BUSH) {\n        return 0.5;\n    }\n    if (material == MATERIAL_CACTUS) {\n        return 0.5;\n    }\n    if (material == MATERIAL_ROCK) {\n        return 0.5;\n    }\n    if (material == MATERIAL_SANDSTONE) {\n        return 0.5;\n    }\n    if (material == MATERIAL", "\n    vec3 line_dir = line_b - line_a;\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_normal = cross(tri_ab, tri_ac);\n    float denom = dot(tri_normal, line_dir);\n    if (abs(denom) < 0.000001) {\n        return vec3(false, 0.0, 0.0);\n    }\n    vec3 line_a_to_tri_a = tri_a - line_a;\n    float u = dot(line_a_to_tri_a, tri_normal) / denom;\n    if (u < 0.0 || u > 1.0) {\n        return vec3(false, 0.0, 0.0);\n    }\n    vec3 tri_normal_cross_line_dir = cross(tri_normal, line_dir);\n    float v = dot(line_a_to_tri_a, tri_normal_cross_line_dir) / denom;\n    if (v < 0.0 || u + v > 1.0) {\n        return vec3(false, 0.0, 0.0);\n    }\n    return vec3(true, u, v);\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 line_dir = line_b - line_a;\n    vec3 tri_ab = tri_b - tri_a;\n    vec3 tri_ac = tri_c - tri_a;\n    vec3 tri_normal = cross(tri_ab, tri_ac);\n    float denom = dot(tri_normal, line_dir);\n", "\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Given a point and a surface normal, compute the distance from the point to the plane defined by the surface normal.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nfloat get_point_to_plane_distance(vec3 point, vec3 surface_normal) {\n    return dot(point, surface_normal);\n}\n\n// Given a point and a surface normal, compute the distance from the point to the plane defined by the surface normal.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nfloat get_point_to_plane_distance(vec3 point, vec3 surface_normal, float surface_distance) {\n    return dot(point, surface_normal) - surface_distance;\n}\n\n// Given a point and a surface normal, compute the distance from the point to the plane defined by the surface normal.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nfloat get_point_to_plane_distance(vec3 point, vec3 surface_normal, vec3 surface_point) {\n    return dot(point, surface_normal) - dot(surface_point, surface_normal);\n}\n\n// Given a point and a surface normal, compute the distance from the point to the plane defined by the surface normal.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nfloat get_point_to_plane_distance(vec3 point, ve", "\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n\n    return mat3(right, up, forward);\n}\n\n// Generate a perspective projection matrix.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix\nmat4 perspective_matrix(float fov, float aspect_ratio, float near, float far) {\n    float f = 1.0 / tan(radians(fov) / 2.0);\n\n    return mat4(\n        f / aspect_ratio, 0.0, 0.0, 0.0,\n        0.0, f, 0.0, 0.0,\n        0.0, 0.0, (far + near) / (near - far), -1.0,\n        0.0, 0.0, (2.0 * far * near) / (near - far), 0.0\n    );\n}\n\n// Generate a view matrix based on a camera position and rotation.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat4 view_matrix(vec3 camera_position, vec3 camera_rotation) {\n    mat3 rotation = mat3(\n        vec3(cos(radians(camera_rotation.y)), 0.0, sin(radians(camera_rotation.y))),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(radians(camera_rotation.y)), 0.0, cos(radians(camera_rotation.y)))\n    ) * mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad", "\n    cast_ray_result result = cast_ray_result(false, 0.0, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0));\n    float closest_distance = INFINITY;\n    for (int i = 0; i < scene_triangles.length(); i++) {\n        triangle t = scene_triangles[i];\n        vec3 intersection_point = vec3(0.0, 0.0, 0.0);\n        float distance = INFINITY;\n        if (intersect_ray_triangle(ray_origin, ray_target, t, intersection_point, distance)) {\n            if (distance < closest_distance) {\n                closest_distance = distance;\n                result.hit = true;\n                result.distance = distance;\n                result.intersection_point = intersection_point;\n                result.normal = t.normal;\n            }\n        }\n    }\n    return result;\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray_with_shadow(vec3 ray_origin, vec3 ray_target) {\n    cast_ray_result result = cast_ray_result(false, 0.0, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0));\n    float closest_distance = INFINITY;\n    for (int i = 0; i < scene_triangles.length(); i++) {\n        triangle t = scene_triangles[i];\n        vec3 intersection_point = vec3(0.0, 0.0, 0.0);\n        float distance = INFINITY;\n        if (intersect_ray_triangle(ray_origin, ray_target, t, intersection_point, distance)) {\n            if (distance < closest_distance) {\n                closest_distance = distance;\n                result.hit = true;\n                result.distance =", "\n    float shadow_factor = 1.0;\n    float shadow_distance = 0.0;\n    float shadow_step = 0.01;\n    float shadow_step_factor = 1.0;\n    float shadow_step_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor = 1.0;\n    float shadow_step_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor", "\n    return fract( sin( x ) * 43758.5453 );\n}\n\n// Basic noise with period\nfloat bnoise( in float x, in float p )\n{\n    return fract( sin( x * p ) * 43758.5453 );\n}\n\n// Basic noise with period and offset\nfloat bnoise( in float x, in float p, in float o )\n{\n    return fract( sin( x * p + o ) * 43758.5453 );\n}\n\n// Basic noise with period, offset and scale\nfloat bnoise( in float x, in float p, in float o, in float s )\n{\n    return fract( sin( x * p + o ) * s );\n}\n\n// Basic noise with period, offset, scale and phase\nfloat bnoise( in float x, in float p, in float o, in float s, in float ph )\n{\n    return fract( sin( x * p + o ) * s + ph );\n}\n\n// Basic noise with period, offset, scale, phase and amplitude\nfloat bnoise( in float x, in float p, in float o, in float s, in float ph, in float a )\n{\n    return fract( sin( x * p + o ) * s + ph ) * a;\n}\n\n// Basic noise with period, offset, scale, phase, amplitude and bias\nfloat bnoise( in float x, in float p, in float o, in float s, in float ph, in float a, in float b )\n{\n    return fract( sin( x * p + o ) * s + ph ) * a + b;\n}\n\n// Basic noise with period, offset, scale, phase, amplitude, bias and bias scale\nfloat bnoise( in float x, in float p, in float o, in float s, in float ph, in float a, in float b, in float bs )\n{\n    return fract( sin( x * p + o ) * s + ph ) * a + b * bs;\n}\n\n// Basic noise with period, offset, scale, phase, amplitude, bias, bias scale and bias phase\nfloat bnoise( in float x, in float p, in float", "\n    return frac( sin( p ) * 43758.5453 );\n}\n\n// Gradient noise\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // Four corners in 2D of a tile\n    float a = gnoise( i );\n    float b = gnoise( i + vec2( 1.0, 0.0 ) );\n    float c = gnoise( i + vec2( 0.0, 1.0 ) );\n    float d = gnoise( i + vec2( 1.0, 1.0 ) );\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec3( mix( mix( a, b, smoothstep( 0.0, 1.0, f.x ) ),\n    //                   mix( c, d, smoothstep( 0.0, 1.0, f.x ) ),\n    //                   smoothstep( 0.0, 1.0, f.y ) ) );\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    return mix( a, b, u.x ) + ( c - a ) * u.y * ( 1.0 - u.x ) + ( d - b ) * u.x * u.y;\n}\n\n// Gradient noise\nfloat gnoise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    // Four corners in 3D of a tile\n    float a = gnoise( i );\n    float b = gnoise( i + vec3( 1.0, 0.0, 0.0 ) );\n    float c = gnoise( i + vec3( 0.0, 1.0, 0.0 ) );\n    float d = gnoise( i + vec3( 1.0, ", "\n    n = (n << 13) ^ n;\n    n = (n * 15731) + 1;\n    n = (n * 15731) + 1;\n    return (float)n * (1.0 / 2147483648.0);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( float n ) \n{\n    return fract(sin(n)*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 p ) \n{\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 p ) \n{\n    return fract(sin(dot(p.xyz,vec3(12.9898,78.233,123.456)))*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec4 p ) \n{\n    return fract(sin(dot(p.xyzw,vec4(12.9898,78.233,123.456,45.678)))*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec2 p, float seed ) \n{\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233))+seed)*43758.5453);\n}\n\n// float hash copied from Hugo Elias\nfloat hash( vec3 p, float seed ) \n{\n    return fract(sin(dot(p.xyz,vec3(12.9898,78.233,123.456))+seed)*43758.5453);\n}\n\n// float hash copied from Hug", "\n    return fract(sin(p)*43758.5453);\n}\n\n// 2D noise\nfloat noise( in vec2 p )\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    // Noise contributions from the three corners\n    float a = gnoise(ip.x + gnoise(ip.y));\n    float b = gnoise(ip.x + 1.0 + gnoise(ip.y));\n    float c = gnoise(ip.x + gnoise(ip.y + 1.0));\n    float d = gnoise(ip.x + 1.0 + gnoise(ip.y + 1.0));\n    // Blend contributions along x\n    vec2 u = fp*fp*(3.0-2.0*fp);\n    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;\n}\n\n// 3D noise\nfloat noise( in vec3 p )\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    // Noise contributions from the three corners\n    float a = gnoise(ip.x + gnoise(ip.y + gnoise(ip.z)));\n    float b = gnoise(ip.x + 1.0 + gnoise(ip.y + gnoise(ip.z)));\n    float c = gnoise(ip.x + gnoise(ip.y + 1.0 + gnoise(ip.z)));\n    float d = gnoise(ip.x + 1.0 + gnoise(ip.y + 1.0 + gnoise(ip.z)));\n    // Blend contributions along x\n    vec3 u = fp*fp*(3.0-2.0*fp);\n    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;\n}\n\n// 4D noise\nfloat noise( in vec4 p )\n{\n", "\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise(x);\n        x = x * G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nvec3 fbm( in vec3 x, in float G )\n{\n    vec3 f = vec3(0.0);\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise(x);\n        x = x * G;\n        a *= b;\n    }\n    return f;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G, in float offset, in float scale )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise(x);\n        x = x * G;\n        a *= b;\n    }\n    return f * scale + offset;\n}\n\n// fbm\nvec3 fbm( in vec3 x, in float G, in float offset, in float scale )\n{\n    vec3 f = vec3(0.0);\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f += a * noise(x);\n        x = x * G;\n        a *= b;\n    }\n    return f * scale + offset;\n}\n\n// fbm\nfloat fbm( in vec3 x, in float G, in float offset, in float scale, in float detail )\n{\n    float f = 0.0;\n    float a = 0.5;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        f +=", "\n    // The quadratic polynomial is:\n    //   p^2 - 2*p*c + c^2 = 0\n    //\n    // The solutions are:\n    //   p = (2*c +- sqrt(4*c^2 - 4)) / 2\n    //\n    // We want to find the solution that is closest to the origin.\n    //\n    // The distance from the origin to the solution is:\n    //   d = |p| = sqrt(p.x^2 + p.y^2 + p.z^2)\n    //\n    // We can rewrite the distance as:\n    //   d = sqrt(p.x^2 + p.y^2 + p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //\n    // We can rewrite the distance as:\n    //   d = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //\n    // We can rewrite the distance as:\n    //   d = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt(p.x^2) + sqrt(p.y^2) + sqrt(p.z^2)\n    //      = sqrt", "\n    // The 4D point is mapped to a cubic polynomial\n    // a*x^3 + b*x^2 + c*x + d\n    // The 3 polar angles are mapped to a 4D point\n    // in a unit sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    // sphere.\n    // The 4D point is mapped to a 4D point in a unit\n    //", "\n    vec3 m = abs(rd)-rad;\n    float t = max(max(m.x,m.y),m.z);\n    vec3 q = ro + rd*t;\n    vec3 k = sign(rd)*rad-abs(q-cen);\n    float s = max(max(k.x,k.y),k.z);\n    float t2 = t-s;\n    return vec4(t2,s,q,cen);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0", "\n    vec3 m = (cen-ro)/rd;\n    vec3 a = m*m;\n    vec3 b = m*cen;\n    vec3 c = cen*cen;\n    vec3 d = rad*rad;\n    float s = dot(a,d);\n    float e = dot(b,d);\n    float f = dot(c,d);\n    float t1 = e-s;\n    float t2 = f-e-s;\n    float t3 = f-s;\n    float t4 = e-s;\n    float t5 = e-s;\n    float t6 = f-e-s;\n    float t7 = f-s;\n    float t8 = e-s;\n    float t9 = e-s;\n    float t10 = f-e-s;\n    float t11 = f-s;\n    float t12 = e-s;\n    float t13 = e-s;\n    float t14 = f-e-s;\n    float t15 = f-s;\n    float t16 = e-s;\n    float t17 = e-s;\n    float t18 = f-e-s;\n    float t19 = f-s;\n    float t20 = e-s;\n    float t21 = e-s;\n    float t22 = f-e-s;\n    float t23 = f-s;\n    float t24 = e-s;\n    float t25 = e-s;\n    float t26 = f-e-s;\n    float t27 = f-s;\n    float t28 = e-s;\n    float t29 = e-s;\n    float t30 = f-e-s;\n    float t31 = f-s;\n    float t32 = e-s;\n    float t33 = e-s;\n    float t34 = f-e-s;\n    float t35 = f-s;\n    float t36 = e-s;\n    float t37 = e-s;\n", "\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, w * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, w * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w, float k, float d)\n{\n    float res = 1.0;\n    float t = mint;\n    for(", " return fract(sin(seed++) * 43758.5453); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat rand(vec3 co) { return fract(sin(dot(co.xyz,vec3(12.9898,78.233,123.456))) * 43758.5453); }\n\nfloat rand(vec4 co) { return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,123.456,45.678))) * 43758.5453); }\n\nfloat rand(vec2 co, float seed) { return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453 + seed); }\n\nfloat rand(vec3 co, float seed) { return fract(sin(dot(co.xyz,vec3(12.9898,78.233,123.456))) * 43758.5453 + seed); }\n\nfloat rand(vec4 co, float seed) { return fract(sin(dot(co.xyzw,vec4(12.9898,78.233,123.456,45.678))) * 43758.5453 + seed); }\n\nfloat rand(vec2 co, vec2 seed) { return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453 + seed.x + seed.y * 10000.0); }\n\nfloat rand(vec3 co, vec3 seed) { return fract(sin(dot(co", "\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Inigo Quilez's Palette Function\n//", "\n    p = abs(p);\n    float b = la - lb;\n    float B = la + lb;\n    float hb = h * lb;\n    float a = p.x * ra;\n    float c = p.y * ra;\n    float d = p.z * ra;\n    float k = ra * ra * hb;\n    if (ra * hb <= p.y)\n        return sqrt(min(min(a * a, b * b + c * c), d * d) - ra * ra * hb) * sign(p.y);\n    if (ra * ra * h <= a)\n        return sqrt(min(a * a, min(b * b + c * c, d * d)) - 0.25 * k) * sign(a);\n    if (ra * ra * h <= b)\n        return sqrt(min(b * b, min(a * a, d * d)) - 0.25 * k) * sign(b);\n    vec2 q = vec2(sqrt(a * a + c * c) - ra * ra * hb, d);\n    return sign(q.x) * sqrt(min(dot(q, q), k)) * sign(q.y);\n}\n\n// p=position, b=base, h=height, r=radius\nfloat sdCone(vec3 p, vec3 b, float h, float r)\n{\n    float b2 = dot(b, b);\n    float t2 = dot(p, p) * b2;\n    float b_p = dot(b, p) * 2.0;\n    float c = t2 - b2 + r * r;\n    float pb = b_p - h;\n    float l1 = b_p + r;\n    float m = sqrt(r * r - h * h);\n    float l2 = b_p - r;\n    float sc = sqrt(c / b2);\n    float s1 = b_p - m;\n    float s2 = b_p + m;\n    float d1 = min(max(pb, s1), l1)", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( pa - ba*h, h, 1.0-h, length(pa-ba*h) - r );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRay( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( pa - ba*h, h, 1.0-h, length(pa-ba*h) - r );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRay( in vec2 p, vec2 a, vec2 b, float r ) \n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( pa - ba*h, h, 1.0-h, length(pa-ba*h) - r );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRay( in vec2 p, vec2 a, vec2 b ) \n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( pa - ba*h, h, 1.0-h, length(pa-ba*h) );\n}", "\n    p = abs(p)-b;\n    vec2 q = abs(p+r)-r;\n    float d = min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n    float sd = d;\n    vec2 dd = abs(p)-b;\n    float z = max(dd.x,dd.y);\n    float y = min(max(dd.x,dd.y),0.0) + length(max(dd,0.0)) - r;\n    float x = length(max(vec2(d,y),0.0)) - r;\n    return vec4(x,y,z,sd);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec3 p, \n            in vec3 b, in float r, \n            in float s )\n{\n    p = abs(p)-b;\n    vec3 q = abs(p+r)-r;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n    float sd = d;\n    vec3 dd = abs(p)-b;\n    float z = max(dd.x,max(dd.y,dd.z));\n    float y = min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.0)) - r;\n    float x = length(max(vec3(d,y,z),0.0)) - r;\n    return vec4(x,y,z,sd);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec4 p, \n            in vec4 b, in float r, \n            in float s )\n{\n    p = abs(p)-b;\n    vec", "\n    vec2 d = abs(p)-b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,d.y),0.0), // d.x, d.y > 0.0? -1.0 : 1.0,\n                 normalize(d),\n                 vec2(d.x,d.y) );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0),\n                 normalize(d),\n                 vec2(d.x,d.y) );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec4 p, in vec3 b )\n{\n    vec3 d = abs(p.xyz)-b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0),\n                 normalize(d),\n                 vec2(d.x,d.y) );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgBox( in vec4 p, in vec4 b )\n{\n    vec3 d = abs(p.xyz)-b.xyz;\n    return vec3( length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0),\n                 normalize(d),\n                 vec2(d.x,d.y) );\n}\n\n//.", "\n    vec2 q = p;\n    q.x = abs(q.x);\n    float d = length(q) - r;\n    float w = d - band;\n    return vec4(p, d, w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRect( in vec2 p, vec2 b, float band ) \n{\n    vec2 q = abs(p) - b;\n    vec2 d = max(q,0.0);\n    float w = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    return vec4(p, d, w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paRoundRect( in vec2 p, vec2 b, float r, float band ) \n{\n    vec2 q = abs(p) - b;\n    vec2 d = max(q,0.0);\n    float w = length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n    return vec4(p, d, w);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paTriangle( in vec2 p, vec2 a, vec2 b, vec2 c, float band ) \n{\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 pa = p - a;\n    vec2 qa = p - a;\n    vec2 qb = p - b;\n    vec2 qc = p - c;\n    vec2 x = vec2(dot(qa,ba), dot(qb,ca));\n    vec2 d = max(x, vec2(0.0));\n    float", "\n    float d = dot(p,p);\n    float r2 = r*r;\n    float d2 = d*d;\n    float d3 = d*d2;\n    float d4 = d2*d2;\n    float d5 = d4*d;\n    float d6 = d4*d2;\n    float d7 = d6*d;\n    float d8 = d6*d2;\n    float d9 = d8*d;\n    float d10 = d8*d2;\n    float d11 = d10*d;\n    float d12 = d10*d2;\n    float d13 = d12*d;\n    float d14 = d12*d2;\n    float d15 = d14*d;\n    float d16 = d14*d2;\n    float d17 = d16*d;\n    float d18 = d16*d2;\n    float d19 = d18*d;\n    float d20 = d18*d2;\n    float d21 = d20*d;\n    float d22 = d20*d2;\n    float d23 = d22*d;\n    float d24 = d22*d2;\n    float d25 = d24*d;\n    float d26 = d24*d2;\n    float d27 = d26*d;\n    float d28 = d26*d2;\n    float d29 = d28*d;\n    float d30 = d28*d2;\n    float d31 = d30*d;\n    float d32 = d30*d2;\n    float d33 = d32*d;\n    float d34 = d32*d2;\n    float d35 = d34*d;\n    float d36 = d34*d2;\n    float d37 = d36*d;\n    float d38 = d36*d2;\n    float d39 = d38", "\n    vec2 q = p;\n    vec2 w = vec2(0.0);\n    float d = 0.0;\n    float z = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float t = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h), (ba*(1.0-h))/dot(ba,ba), h );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h)-r, (ba*(1.0-h))/dot(ba,ba), h );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h)-r, (ba*(1.0-h))/dot(ba,ba), h );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r, in float r2, in float r3 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, ", "\n    const float k = sqrt(3.0);\n    p = abs(p);\n    p.x -= 2.0*r;\n    if( p.x+k*p.y < 0.0 ) p = vec2( p.x-k*p.y, -k*p.x-p.y )/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    vec2 w = vec2( length(p.xy), p.x );\n    p = (p.x < 0.0)? p.yx : p;\n    p.x -= 2.0*r;\n    if( p.x+k*p.y < 0.0 ) p = vec2( p.x-k*p.y, -k*p.x-p.y )/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    vec2 v = vec2( length(p.xy), p.x );\n    return vec3( sqrt(min(w.x,v.x))*sign(p.y), w.y, v.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHexagon( in vec3 p, in float r ) \n{\n    const float k = sqrt(3.0);\n    p = abs(p);\n    p.x -= 2.0*r;\n    if( p.x+k*p.y < 0.0 ) p = vec3( p.x-k*p.y, -k*p.x-p.y, -p.z )/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    vec3 w = vec3(", "\n    vec3 a = X[0];\n    vec3 b = X[1];\n    vec3 c = X[2];\n    float a2 = dot(a, a);\n    float b2 = dot(b, b);\n    float c2 = dot(c, c);\n    float a2b2 = a2 * b2;\n    float a2c2 = a2 * c2;\n    float b2c2 = b2 * c2;\n    float a2b = sqrt(a2b2);\n    float a2c = sqrt(a2c2);\n    float b2c = sqrt(b2c2);\n    float a2b2c2 = a2b2 + c2;\n    float a2b2c = sqrt(a2b2c2);\n    float a2b2c3 = a2b2c2 * a2b2c;\n    float a2b2c4 = a2b2c3 * a2b2c;\n    float a2b2c5 = a2b2c4 * a2b2c;\n    float a2b2c6 = a2b2c5 * a2b2c;\n    float a2b2c7 = a2b2c6 * a2b2c;\n    float a2b2c8 = a2b2c7 * a2b2c;\n    float a2b2c9 = a2b2c8 * a2b2c;\n    float a2b2c10 = a2b2c9 * a2b2c;\n    float a2b2c11 = a2b2c10 * a2b2c;\n    float a2b2c12 = a2b2c11 * a2b2c;\n    float a2b2c13 = a2b2c12 * a2b2c;\n    float a2b2c14 = a2b2c13 * a2b2c;\n    float a2b2c15 = a2b2c14 * a2b2c;\n    float a2b2c1", "\n    return a / (b + vec3(0.000001));\n}\n\n//returns the normal of a triangle\nvec3 normal(vec3 a, vec3 b, vec3 c) {\n    return normalize(cross(b - a, c - a));\n}\n\n//returns the distance from a point to a plane\nfloat distanceToPlane(vec3 point, vec3 planeNormal, vec3 planePoint) {\n    return dot(point - planePoint, planeNormal);\n}\n\n//returns the distance from a point to a sphere\nfloat distanceToSphere(vec3 point, vec3 sphereCenter, float sphereRadius) {\n    return length(point - sphereCenter) - sphereRadius;\n}\n\n//returns the distance from a point to a box\nfloat distanceToBox(vec3 point, vec3 boxCenter, vec3 boxSize) {\n    vec3 q = abs(point - boxCenter) - boxSize;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//returns the distance from a point to a cylinder\nfloat distanceToCylinder(vec3 point, vec3 cylinderCenter, vec3 cylinderNormal, float cylinderRadius) {\n    vec3 q = point - cylinderCenter;\n    float d = length(q - cylinderNormal * dot(q, cylinderNormal)) - cylinderRadius;\n    float s = dot(cylinderNormal, q);\n    return max(d, abs(s) - cylinderRadius);\n}\n\n//returns the distance from a point to a cone\nfloat distanceToCone(vec3 point, vec3 coneCenter, vec3 coneNormal, float coneRadius, float coneHeight) {\n    vec3 q = point - coneCenter;\n    float d = length(q - coneNormal * dot(q, coneNormal)) - coneRadius;\n    float s = dot(coneNormal, q);\n    return max(d, s - coneHeight);\n}\n\n//returns the distance from a point to a torus\nfloat distanceToTorus(vec3 point, vec3 tor", "\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Transforms\nvec3 Translate(vec3 p, vec3 t)\n{\n    return p - t;\n}\n\n// Scales\nvec3 Scale(vec3 p, vec3 s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return p / vec3(sx, sy, sz);\n}\n\n// Scales\nvec3 Scale(vec3 p, float s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return p / vec3(sx, sy, sz);\n}\n\n// Scales\nvec3 Scale(vec3 p, float s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return p / vec3(sx, sy, sz);\n}\n\n// Scales\nvec3 Scale(vec3 p, float s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return p / vec3(sx, sy, sz);\n}\n\n// Scales\nvec3 Scale(vec3 p, float s)\n{\n    return p / s;\n}\n\n// Scales\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    return p / vec3(sx, sy, sz);\n}\n\n// Scales\nvec3 Scale(vec3 p,", "\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float R2 = R * R;\n    float R3 = R2 * R;\n    float R4 = R3 * R;\n    float R5 = R4 * R;\n    float R6 = R5 * R;\n    float R7 = R6 * R;\n    float R8 = R7 * R;\n    float R9 = R8 * R;\n    float R10 = R9 * R;\n    float R11 = R10 * R;\n    float R12 = R11 * R;\n    float R13 = R12 * R;\n    float R14 = R13 * R;\n    float R15 = R14 * R;\n    float R16 = R15 * R;\n    float R17 = R16 * R;\n    float R18 = R17 * R;\n    float R19 = R18 * R;\n    float R20 = R19 * R;\n    float R21 = R20 * R;\n    float R22 = R21 * R;\n    float R23 = R22 * R;\n    float R24 = R23 * R;\n    float R25 = R24 * R;\n    float R26 = R25 * R;\n    float R27 = R26 * R;\n    float R28 = R27 * R;\n    float R29 = R28 * R;\n    float R30 = R29 * R;\n    float R31 = R30 * R;\n    float R32 = R31 * R;\n    float R33 = R32 * R;\n    float R34 = R33 * R;\n    float R35 = R34 * R;\n    float R36 = R35 * R;\n    float R37 = R36 * R;\n    float R38 = R37 * R;\n    float R39 = R38 * R;\n    float R40 = R39 * R;\n   ", "\n    return 1.0f / (1.0f + e * R);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2)\n{\n    return 1.0f / (1.0f + e * R2);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2, float R3)\n{\n    return 1.0f / (1.0f + e * R3);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2, float R3, float R4)\n{\n    return 1.0f / (1.0f + e * R4);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2, float R3, float R4, float R5)\n{\n    return 1.0f / (1.0f + e * R5);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2, float R3, float R4, float R5, float R6)\n{\n    return 1.0f / (1.0f + e * R6);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R, float R2, float R3, float R4, float R5, float R6, float R7)\n{\n    return 1.0f / (1.0f + e * R7);\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e,", "\n    float k = (a - b) / (R * R);\n    float k2 = k * k;\n    float k3 = k2 * k;\n    float k4 = k3 * k;\n    float k5 = k4 * k;\n    float k6 = k5 * k;\n    float k7 = k6 * k;\n    float k8 = k7 * k;\n    float k9 = k8 * k;\n    float k10 = k9 * k;\n    float k11 = k10 * k;\n    float k12 = k11 * k;\n    float k13 = k12 * k;\n    float k14 = k13 * k;\n    float k15 = k14 * k;\n    float k16 = k15 * k;\n    float k17 = k16 * k;\n    float k18 = k17 * k;\n    float k19 = k18 * k;\n    float k20 = k19 * k;\n    float k21 = k20 * k;\n    float k22 = k21 * k;\n    float k23 = k22 * k;\n    float k24 = k23 * k;\n    float k25 = k24 * k;\n    float k26 = k25 * k;\n    float k27 = k26 * k;\n    float k28 = k27 * k;\n    float k29 = k28 * k;\n    float k30 = k29 * k;\n    float k31 = k30 * k;\n    float k32 = k31 * k;\n    float k33 = k32 * k;\n    float k34 = k33 * k;\n    float k35 = k34 * k;\n    float k36 = k35 * k;\n    float k37 = k36 * k;\n    float k38 = k37 * k;\n    float k39 = k38 * k;\n    float k40 = k39 * k;\n    float k41 =", "\n    return length(p - c) - R;\n}\n\n// Sphere primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Sphere(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Cylinder primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cylinder(vec3 p, vec3 c, float R, float e)\n{\n    return length(p.xz - c.xz) - R;\n}\n\n// Cone primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Cone(vec3 p, vec3 c, float R, float e)\n{\n    return length(p.xz - c.xz) - R;\n}\n\n// Torus primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Torus(vec3 p, vec3 c, float R, float e)\n{\n    return length(p.xz - c.xz) - R;\n}\n\n// Plane primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Plane(vec3 p, vec3 c, float R, float e)\n{\n    return p.y - c.y;\n}\n\n// Box primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Box(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Capsule primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Capsule(vec3 p, vec3 c, float R, float e)\n{\n    return length(p - c) - R;\n}\n\n// Capsule primitive field function\n// p: world point\n// c: center\n// R:", "\n    vec3 d = b - a;\n    float t = dot(c - a, d) / dot(d, d);\n    t = clamp(t, 0.0, 1.0);\n    vec3 p = a + t * d;\n    return VertexK(c, R, e, p);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a triangle\n// c: center\n// R: radius\n// e: energy\n// a: triangle vertex 1\n// b: triangle vertex 2\n// c: triangle vertex 3\nfloat VertexKTriangle(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 n = cross(ab, ac);\n    float d = dot(c, n);\n    float t = dot(c - a, n) / dot(n, n);\n    t = clamp(t, 0.0, 1.0);\n    vec3 p = a + t * n;\n    return VertexK(c, R, e, p);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a tetrahedron\n// c: center\n// R: radius\n// e: energy\n// a: tetrahedron vertex 1\n// b: tetrahedron vertex 2\n// c: tetrahedron vertex 3\n// d: tetrahedron vertex 4\nfloat VertexKTetrahedron(vec3 c, float R, float e, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ab = b - a;\n    vec3 ac = c - a;\n    vec3 ad = d - a;\n    vec3 n = cross(ab, ac);\n    float d1 = dot(c, n);\n    float d2 = dot(d, n);\n    float t = dot(c - a, n) / dot(n, n);\n    t = clamp(t, ", "\n    return p.y;\n}\n\n// Raymarching\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        float d = Object(ro + rd * t);\n        if (d < 0.001)\n        {\n            return t;\n        }\n        t += d;\n    }\n    return -1.0;\n}\n\n// Normal\nvec3 Normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        Object(p + e.xyy) - Object(p - e.xyy),\n        Object(p + e.yxy) - Object(p - e.yxy),\n        Object(p + e.yyx) - Object(p - e.yyx)\n    ));\n}\n\n// Lighting\nvec3 Lighting(vec3 p, vec3 n, vec3 l)\n{\n    vec3 color = vec3(0.0);\n    float diffuse = max(0.0, dot(n, l));\n    color += diffuse;\n    return color;\n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = RayMarch(ro, rd);\n    if (t > 0.0)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = Normal(p);\n        vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 color =", "\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b)\n{\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b)\n{\n    return length(a - b);\n}\n\n// K root\nfloat KSegment(vec2 a, vec4 b)\n{\n    return length(vec3(a, 0.0) - vec3(b.xy, 0.0));\n}\n\n// K root\nfloat KSegment(vec4 a, vec2 b)\n{\n    return length(vec3(a.xy, 0.0) - vec3(b, 0.0));\n}\n\n// K root\nfloat KSegment(vec3 a, vec2 b)\n{\n    return length(vec3(a, 0.0) - vec3(b, 0.0));\n}\n\n// K root\nfloat KSegment(vec2 a, vec3 b)\n{\n    return length(vec3(a, 0.0) - vec3(b, 0.0));\n}\n\n// K root\nfloat KSegment(vec4 a, vec3 b)\n{\n    return length(vec3(a.xy, 0.0) - vec3(b, 0.0));\n}\n\n// K root\nfloat KSegment(vec3 a, vec4 b)\n{\n    return length(vec3(a, 0.0) - vec3(b.xy, 0.0));\n}\n\n// K root\nfloat KSegment(vec2 a, vec2 b, float k)\n{\n    return pow(KSegment(a, b), k);\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b, float k)\n{\n    return pow(KSegment(a, b), k);\n}\n\n// K root\nfloat KSegment(vec4 a, vec4 b, float k)\n{\n    return pow(KSegment(a, b), k);\n}\n\n// K root\nfloat KSegment", "\n    vec3 n = vec3(0.0);\n    for( int i=0; i<NUM_OBJECTS; i++ )\n    {\n        n += ObjectNormal(p, i);\n    }\n    return normalize(n);\n}\n\n// Raymarching\nfloat RayMarch( in vec3 ro, in vec3 rd, in float start, in float end )\n{\n    float t = start;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float h = ObjectDistance(ro + rd*t);\n        if( h<MIN_DIST || t>end ) break;\n        t += h;\n    }\n    return t;\n}\n\n// Shadow\nfloat RayShadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n        float h = ObjectDistance(ro + rd*t);\n        if( h<MIN_DIST )\n        {\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n        if( res<0.0001 ) break;\n    }\n    return res;\n}\n\n// Material\nvec3 Material( in vec3 p, in vec3 n, in vec3 rd, in vec3 ro, in vec3 lightPos, in vec3 lightColor, in float specular )\n{\n    vec3 color = vec3(0.0);\n    for( int i=0; i<NUM_OBJECTS; i++ )\n    {\n        color += ObjectMaterial(p, n, rd, ro, lightPos, lightColor, specular, i);\n    }\n    return color;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n", "\n    h = false;\n    s = 0;\n    float t = 0.0;\n    vec3 p = o;\n    for(int i = 0; i < 100; i++)\n    {\n        s++;\n        p = o + t * u;\n        if(length(p) > 1.0)\n        {\n            h = true;\n            break;\n        }\n        t += length(p) - 1.0;\n    }\n    return t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p)\n{\n    h = false;\n    s = 0;\n    float t = 0.0;\n    p = o;\n    for(int i = 0; i < 100; i++)\n    {\n        s++;\n        p = o + t * u;\n        if(length(p) > 1.0)\n        {\n            h = true;\n            break;\n        }\n        t += length(p) - 1.0;\n    }\n    return t;\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s, out vec3 p, out vec3 n)\n{\n    h = false;\n    s = 0;\n    float t = 0.0;\n    p = o;\n    for(int i = 0; i < 100; i++)\n    {\n        s++;\n        p = o + t * u;\n        if(length(p) > 1.0)\n        {\n            h = true;\n            break;\n        }\n        t += length(p) - 1.0;\n    }\n    n = normalize(p);\n    return t;\n}\n\n// Trace ray using sphere tracing\n// o :", "\n    h = false;\n    s = 0;\n    float t = 0.0;\n    float d = 0.0;\n    float tMax = 100.0;\n    float tMin = 0.0;\n    float tStep = 0.0;\n    float tStepMax = 0.0;\n    float tStepMin = 0.0;\n    float tStepMax2 = 0.0;\n    float tStepMin2 = 0.0;\n    float tStepMax3 = 0.0;\n    float tStepMin3 = 0.0;\n    float tStepMax4 = 0.0;\n    float tStepMin4 = 0.0;\n    float tStepMax5 = 0.0;\n    float tStepMin5 = 0.0;\n    float tStepMax6 = 0.0;\n    float tStepMin6 = 0.0;\n    float tStepMax7 = 0.0;\n    float tStepMin7 = 0.0;\n    float tStepMax8 = 0.0;\n    float tStepMin8 = 0.0;\n    float tStepMax9 = 0.0;\n    float tStepMin9 = 0.0;\n    float tStepMax10 = 0.0;\n    float tStepMin10 = 0.0;\n    float tStepMax11 = 0.0;\n    float tStepMin11 = 0.0;\n    float tStepMax12 = 0.0;\n    float tStepMin12 = 0.0;\n    float tStepMax13 = 0.0;\n    float tStepMin13 = 0.0;\n    float tStepMax14 = 0.0;\n    float tStepMin14 = 0.0;\n    float tStepMax15 = 0.0;\n    float tStepMin15 = 0.0;\n    float tStepMax16 = 0.0;\n    float tStepMin16 = 0.0;\n    float tStepMax17 = 0.0;\n    float tStepMin17 = 0.0;\n    float tStepMax18 = 0.0;\n    float tStepMin18 = 0.0;\n   ", "\n    return vec3(0.0);\n}\n\nvec3 Shading(vec3 p, vec3 n, vec3 rd, vec3 ld, vec3 lc, vec3 ka, vec3 kd, vec3 ks, float ns)\n{\n    vec3 l = normalize(ld - p);\n    vec3 v = normalize(-rd);\n    vec3 r = normalize(reflect(-l, n));\n    vec3 h = normalize(l + v);\n\n    float diffuse = max(0.0, dot(n, l));\n    float specular = pow(max(0.0, dot(n, h)), ns);\n\n    return lc * (ka + kd * diffuse + ks * specular);\n}\n\n// Raymarching functions\nfloat Sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat Box(vec3 p, vec3 c, vec3 b)\n{\n    vec3 d = abs(p - c) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat Cylinder(vec3 p, vec3 c, float r)\n{\n    return length(p.xz - c.xz) - r;\n}\n\nfloat Cone(vec3 p, vec3 c, float r)\n{\n    float d = length(p.xz - c.xz);\n    return d * cos(c.y) - r * p.y;\n}\n\nfloat Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat Union(float d1, float d", "\n    vec3 pa = p - a, ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n\n    float x = length(pa*baba - ba*paba) - r*baba;\n    float y = abs(paba - baba*0.5) - baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x, y) < 0.0)? -min(x2, y2) :\n        (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? y2 : 0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// arbitrary orientation\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n\n    float x = length(pa*baba - ba*paba) - r*baba;\n    float y = abs(paba - 0.5*baba) - 0.5*baba;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x, y) < 0.0)? -min(x2, y2) :\n        (((x > 0.0)? x2 : 0.0) + ((y > 0.0)? y2 : 0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// arbitrary orientation\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba", "\n    return coord * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord) {\n    return coord.xy * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord) {\n    return coord.xy * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size) {\n    return coord / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord, vec2 size) {\n    return coord.xy / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord, vec2 size) {\n    return coord.xy / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset) {\n    return (coord - offset) / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord, vec2 size, vec2 offset) {\n    return (coord.xy - offset) / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec4 coord, vec2 size, vec2 offset) {\n    return (coord.xy - offset) / size * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord - offset) / size * scale * 2.0 - 1.0;\n}\n\n// normalized fragment coordinate\nvec2 uv_coord(vec3 coord, vec2 size, vec2 offset, vec2 scale) {\n    return (coord.xy - offset) / size * scale * 2.", "\n    vec2 a = vec2(1.0,0.0);\n    vec2 b = normalize(q);\n    vec2 c = normalize(2.0*q);\n    vec2 x = p*mat2(a,b);\n    vec2 y = mat2(a,b)*p;\n    vec2 z = mat2(b,c)*p;\n    vec2 d = sign(z.yx)*((z.x<z.y)?z.xy:z.yx);\n    vec2 e = vec2(1.0,-1.0)*d;\n    vec2 i = x + e*vec2(d.x,-d.y);\n    vec2 h = abs(x)-abs(e);\n    float s = max(max(h.x, h.y),0.0);\n    float t = clamp( (p.x*p.y-p.y*q.x+q.y*q.x)/(s+1e-10), -1.0, 1.0 );\n    vec2 r = (s<1e-10 || t<=0.0)? x : x+(t-1.0)*e;\n    float v = s*(r.x+r.y)/2.0;\n    return vec3( sqrt(2.0)*v, mat2(a,b)*r );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p)\nvec3 sdgTriangle( in vec2 p, in vec2 q, in vec2 r )\n{\n    vec2 a = p-q;\n    vec2 b = r-q;\n    vec2 c = vec2(1.0,-1.0);\n    vec2 x = mat2(b,c)*p;\n    vec2 y = mat2(b,c)*r;\n    vec2 d = sign(x.yx)*((x.x<x.y)?x.xy:x.yx);\n    vec2 e = vec2(1.0,-", "\n    float l = length(p);\n    float t = atan(p.y, p.x);\n    float a = mod(t, 2.0 * PI) - PI;\n    float s = sign(a);\n    float h = abs(a) - PI / 2.0;\n    float k = r * r / d;\n    float f = (l - r) * (l - r) / (2.0 * k * k) - 1.0;\n    float g = s * sqrt(1.0 - f * f);\n    float hf = h * f;\n    float rx = r * cos(hf);\n    float ry = r * sin(hf);\n    float sx = s * (l - rx);\n    float sy = -s * (l - ry);\n    float dx = sx - p.x;\n    float dy = sy - p.y;\n    float dz = sqrt(dx * dx + dy * dy);\n    float ds = sign(dz - r);\n    float ex = rx + ds * r;\n    float ey = ry + ds * r;\n    float gx = ex - p.x;\n    float gy = ey - p.y;\n    float gz = sqrt(gx * gx + gy * gy);\n    float hx = gx / gz;\n    float hy = gy / gz;\n    float sz = ds * sqrt(1.0 - f * f);\n    float tx = s * (l - rx);\n    float ty = s * (l - ry);\n    float tz = sqrt(tx * tx + ty * ty);\n    float ux = tx / tz;\n    float uy = ty / tz;\n    float uz = sign(tz - r);\n    float vx = ux - p.x;\n    float vy = uy - p.y;\n    float vz = sqrt(vx * vx + vy * vy);\n    float wx = vx / vz;\n    float wy = vy / vz;\n    float wz", "\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c*clamp(dot(p,c),0.0,r));\n    float n = abs(dot(p,c)) - r;\n    float k = sign(r)*r;\n    if( n < 0.0 )\n        return vec3(l,sign(l)*n,k);\n    if( m < 0.0 )\n        return vec3(m,0.0,sign(k)*k);\n    return vec3(k,l,m);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the center of the circle\n// r is the radius\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r )\n{\n    p -= c;\n    float l = length(p) - r;\n    float m = dot(p,normalize(p));\n    return vec3(l,m,r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the center of the ellipse\n// r is the radius\nvec3 sdgEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    p = (p-c)/r;\n    float l = length(p);\n    float m = atan(p.y,p.x);\n    return vec3(l,m,r);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f", "\n    vec2 e0 = v[1] - v[0];\n    vec2 e1 = v[2] - v[0];\n    vec2 q = p - v[0];\n    float a = dot(q, e0);\n    float b = dot(q, e1);\n    float c = dot(e0, e0);\n    float d = dot(e1, e1);\n    float e = dot(e0, e1);\n    float s = a*d - b*c;\n    float t = b*c - a*e;\n    if (s + t < eps) {\n        float det = c*d - e*e;\n        if (det < eps) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        s = clamp(s/det, 0.0, 1.0);\n        t = clamp(t/det, 0.0, 1.0);\n        return vec3(1.0 - s - t, s, t);\n    }\n    float det = c*d - e*e;\n    if (det < eps) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    float invDet = 1.0/det;\n    float w = (a*d - b*e)*invDet;\n    float v = (b*c - a*e)*invDet;\n    float u = 1.0 - w - v;\n    if (u < 0.0 || v < 0.0 || w < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return vec3(u, v, w);\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgCircle( in vec2 p, in float r )\n{\n    float d = length(p) - r;\n    return vec3(d, p/d);\n}\n", "\n    p.x = abs(p.x);\n    float k = dot(p,sca);\n    if( k > ra ) return vec3( k-ra, -sca.y,-sca.x );\n    if( p.x > ra )\n    {\n        p = vec2(ra,p.y);\n        k = dot(p,scb);\n    }\n    else k = dot2(p);\n    if( k <= rb ) return vec3( k, scb.x, scb.y );\n    p = vec2(ra,rb*inversesqrt(k));\n    return vec3( length(p)-rb, scb.x*p.x, scb.y*p.y );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb, in float rc )\n{\n    p.x = abs(p.x);\n    float k = dot(p,sca);\n    if( k > ra ) return vec3( k-ra, -sca.y,-sca.x );\n    if( p.x > ra )\n    {\n        p = vec2(ra,p.y);\n        k = dot(p,scb);\n    }\n    else k = dot2(p);\n    if( k <= rb ) return vec3( k, scb.x, scb.y );\n    p = vec2(ra,rb*inversesqrt(k));\n    k = length(p);\n    if( k <= rc ) return vec3( k-rc, scb.x*p.x, scb.y*p.y );\n    p = vec2(rc,k*inversesqrt(k-rc));\n    return vec3( length(", " return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec3 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec4 a, in vec4 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec3 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec3 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat cro( in vec2 a, in vec4 b ) { return a.x*b.y - a.y*b.x;", "\n    p = vec2(p.x*ab.x,p.y*ab.y);\n    float a = dot(p,p);\n    float b = dot(p,p+vec2(-2.0*ab.x,0.0));\n    float d = b*b - 4.0*a*dot(ab,ab);\n    if( d<0.0 ) return vec3( 0.0, 0.0, 0.0 );\n    d = sqrt(d);\n    float s = clamp( (-b-d)/(2.0*a), 0.0, 1.0 );\n    vec2  q = p + (s-1.0)*ab;\n    float h = length(q);\n    float phi = atan(q.y,q.x) + 0.5*PI/ab.x;\n    float z = sqrt(1.0-h*h);\n    float r = sqrt(a);\n    float x = r*cos(phi);\n    float y = r*sin(phi);\n    return vec3( x, y, z );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgEllipsoid( vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    float ex2 = (k0-1.0)/k1;\n    float ey2 = (k0-1.0)/k0;\n    float ez2 = (k1-1.0)/k1;\n    float ex = sqrt(ex2);\n    float ey = sqrt(ey2);\n    float ez = sqrt(ez2);\n    vec3 q;\n    q.x = ex*p.x;\n    q.y = ey*p.y;\n    q.z = ez*", "\n  vec3 q = vec3(length(p.xz)-ra,p.y,0.0);\n  return vec4(length(q)-rb,normalize(vec3(q.x,q.y,q.z)),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, float ra, float rb )\n{\n  vec2 d = vec2( length(p.xz)-ra, abs(p.y)-rb );\n  return vec4(min(max(d.x,d.y),0.0)+length(max(d,0.0)),normalize(vec3(p.x,sign(d.x-d.y),p.z)),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCone( vec3 p, float ra, float rb )\n{\n  float q = length(p.xz);\n  return vec4(dot(vec2(q,p.y),normalize(vec2(ra,rb))),normalize(vec3(q*ra-p.x,q*rb-p.y,p.z)),0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.w = \u2202f(p)/\u2202z\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return vec4( length( pa - ba * h ) - r, ba * (h - 1.0) / dot(ba, ba) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return vec4( length( pa - ba * h ) - r, ba * (h - 1.0) / dot(ba, ba) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec4 sdgCylinder( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length( pa*baba - ba*paba ) - r*baba;\n    float y = abs(paba - baba*h) - baba*r;\n    float x2 = x*x, y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    vec3 res;\n    res.x = sqrt(d)*sign(max(x,y));\n    res.yz = p - a - ba*clamp(paba/", "\n    p = abs(p);\n    float h = he*.5;\n    float w = wi*.5;\n    float a = w*sk;\n    float b = h*sk;\n    if( p.x<=a && p.y<=b )\n        return dot(p,normalize(vec2(-sk,1.)));\n    vec2 d = vec2( abs(p.x-a), p.y/sk );\n    return sign(p.y)*max(d.x,d.y)-b;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    p = abs(p);\n    float h = he*.5;\n    float w = wi*.5;\n    float a = w*sk;\n    float b = h*sk;\n    if( p.x<=a && p.y<=b )\n        return dot(p,normalize(vec2(-sk,1.)));\n    vec2 d = vec2( abs(p.x-a), p.y/sk );\n    return sign(p.y)*max(d.x,d.y)-b;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    p = abs(p);\n    float h = he*.5;\n    float w = wi*.5;\n    float a = w*sk;\n    float b = h*sk;\n    if( p.x<=a && p.y<=b )\n        return dot(p,normalize(vec2(-sk,1.)));\n    vec2 d = vec2( abs(p.x-a), p.y/sk );\n    return sign(p.y)*max(d.x,d.y)-b;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParalle", "\n    vec2 q = abs(p);\n    float b = he*he/4.0;\n    float a = wi*he;\n    float h = clamp( (sk-q.x*0.5-q.y*0.5)/(a+b), 0.0, 1.0 );\n    float s = mix( -he*0.5, he*0.5, h );\n    float t = mix( -wi*0.5, wi*0.5, h );\n    float d2 = dot( q-vec2(t,s), vec2(t,s) );\n    float si = mix( t, s, step( 0.0, -q.x ) );\n    float d = sign( q.y-si )*sqrt( d2 );\n    return vec3( d, vec2( t, s ) );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk, float r )\n{\n    vec2 q = abs(p);\n    float b = he*he/4.0;\n    float a = wi*he;\n    float h = clamp( (sk-q.x*0.5-q.y*0.5)/(a+b), 0.0, 1.0 );\n    float s = mix( -he*0.5, he*0.5, h );\n    float t = mix( -wi*0.5, wi*0.5, h );\n    float d2 = dot( q-vec2(t,s), vec2(t,s) );\n    float si = mix( t, s, step( 0.0, -q.x ) );\n    float d = sign( q.y-si )*sqrt( d2 );\n    vec2 g = sign(p-vec2(t,s))*vec2(t,s);\n    return vec3( d, normalize(g) );\n}\n\n//.x =", "\n\t\tfloat r;\n\t\tr = p * c;\n\t\treturn r;\n\t}\n\nfloat opRep2D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep3D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep4D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep5D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep6D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep7D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep8D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep9D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep10D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c * c * c * c * c;\n\t\treturn r;\n\t}\n\nfloat opRep11D( float p, float c )\n\t{\n\t\tfloat r;\n\t\tr = p * c * c * c * c * c * c * c * c * c * c * c;\n\t\treturn r;", "\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's polynominal max\nfloat pmax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(a, b, h) + k * h * (1.0 - h);\n}\n\n// IQ's smooth min\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's smooth max\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(a, b, h) + k * h * (1.0 - h);\n}\n\n// IQ's smooth min\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// IQ's smooth max\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0.0, 1.0);\n    return lerp(a, b, h) + k * h * (1.0 - h);\n}\n\n// IQ's smooth min\nfloat smin(float a, float b, float k", "\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec2 mod2(inout vec2 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec3 mod2(inout vec3 p, vec2 size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec3 mod2(inout vec3 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec4 mod2(inout vec4 p, vec2 size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec4 mod2(inout vec4 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb_smooth(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv_smooth(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 rad) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2(tN, tF);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 pl) {\n    return -(dot(ro, pl.xyz) + pl.w) / dot(rd, pl.xyz);\n}\n\n// IQ's ray triangle intersection\nfloat rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 N = cross(v0v1, v0v2);\n    float area2 = length(N);\n    vec3 v0p = ro - v0;\n    float t = dot(v0p, N) / dot(rd, N);\n    vec3 q = ro + t * rd;\n    vec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0 ) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec2( tN, tF );\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, float rad, out vec3 outNormal) {\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray plane intersection\nvec2 rayPlane(vec3 ro, vec3 rd, vec4 plane, out vec3 outNormal) {\n    float denom = dot(plane.xyz, rd);\n    if (abs(denom) > 0.0001) {\n        float t = -(dot(plane.xyz, ro) + plane.w) / denom;\n        if (t >= 0.0) {\n            outNormal = plane.xyz;\n            return vec2(t, t);\n        }\n    }\n    return vec2(-1.0);\n}\n\n// IQ's ray triangle intersection\nvec2 rayTriangle(vec3 ro, vec3 rd, ve", "\n    e1 = vec2(0.0);\n    e2 = vec2(0.0);\n    e3 = vec2(0.0);\n    e4 = vec2(0.0);\n    if (p.x < d.x) {\n        e1 = vec2(-1.0, 0.0);\n        e2 = vec2(1.0, 0.0);\n    } else {\n        e1 = vec2(1.0, 0.0);\n        e2 = vec2(-1.0, 0.0);\n    }\n    if (p.y < d.y) {\n        e3 = vec2(0.0, -1.0);\n        e4 = vec2(0.0, 1.0);\n    } else {\n        e3 = vec2(0.0, 1.0);\n        e4 = vec2(0.0, -1.0);\n    }\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge3(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3) {\n    e1 = vec2(0.0);\n    e2 = vec2(0.0);\n    e3 = vec2(0.0);\n    if (p.x < d.x) {\n        e1 = vec2(-1.0, 0.0);\n        e2 = vec2(1.0, 0.0);\n    } else {\n        e1 = vec2(1.0, 0.0);\n        e2 = vec2(-1.0, 0.0);\n    }\n    if (p.y < d.y) {\n        e3 = vec2(0.0, -1.0);\n    } else {\n        e3 = vec2(0.0, 1.0);\n    }\n}\n\n//returns the vectors pointing to each", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n    p = abs(p);\n    vec2 q = abs(p - b) - vec2(r);\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\nfloat box(vec2 p, vec2 b) {\n    p = abs(p);\n    vec2 q = abs(p - b) - b;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\nfloat box(vec2 p, float r) {\n    return box(p, vec2(r));\n}\n\nfloat box(vec2 p) {\n    return box(p, 1.0);\n}\n\nfloat box(vec3 p, vec3 b) {\n    p = abs(p);\n    vec3 q = abs(p - b) - b;\n    return min(max(q.x, max(q.y, q.z)), 0.0) + length(max(q, 0.0));\n}\n\nfloat box(vec3 p, float r) {\n    return box(p, vec3(r));\n}\n\nfloat box(vec3 p) {\n    return box(p, 1.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n    p = abs(p);\n    vec4 q = abs(p - b) - b;\n    return min(max(q.x, max(q.y, max(q.z, q.w))), 0.0) + length(max(q, 0.0));\n}\n\nfloat box(vec4 p, float r) {\n    return box(p, vec4(r));\n}\n", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float w = w1 + w2*h;\n    return d-w;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec3 p, vec3 a, vec3 b, float w1, float w2 )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float w = w1 + w2*h;\n    return d-w;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec4 p, vec4 a, vec4 b, float w1, float w2 )\n{\n    vec4 pa = p - a;\n    vec4 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    float w = w1 + w2*h;\n    return d-w;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2, float t )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d", "\n    vec3  c = vec3(0.0, 0.0, -1.0);\n    float r1 = 0.4;\n    float r2 = 0.1;\n    vec3  o = ro - c;\n    float k1 = dot(o, o) - r1 * r1;\n    float k2 = dot(o, rd) - dot(o, c) * dot(rd, c);\n    float k3 = dot(c, c) - dot(o, c) * dot(o, c) - r2 * r2;\n    float p = k2 * k2 - k1 * k3;\n    if (p < 0.0) return -1.0;\n    p = sqrt(p);\n    float q = -k2 - p;\n    float t1 = q / k1;\n    float t2 = k2 / k1;\n    if (t1 >= 0.0) return t1;\n    if (t2 >= 0.0) return t2;\n    return -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 >= 0.0) return t1;\n    if (t2 >= 0.0) return t2;\n    return -1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat ray", "\n    vec3 n = vec3(pos.x, pos.y, 0.0);\n    n = normalize(n);\n    return n;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat torusIntersect(vec3 ro, vec3 rd, vec2 tor) {\n    vec2 xy = vec2(length(ro.xz) - tor.x, ro.y);\n    float d = length(xy) - tor.y;\n    vec2 xy2 = vec2(length(ro.xz) - (tor.x + rd.y * 0.1), ro.y);\n    float d2 = length(xy2) - tor.y;\n    return max(d, d2);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusUV(vec3 pos, vec2 tor) {\n    vec2 xy = vec2(length(pos.xz) - tor.x, pos.y);\n    return vec3(atan(xy.x, xy.y) / 6.2832, length(xy) / tor.y, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusColor(vec3 pos, vec2 tor) {\n    vec2 xy = vec2(length(pos.xz) - tor.x, pos.y);\n    return vec3(0.0, 0.0, 0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 torusLight(vec3 pos", "\n    float x2 = x * x;\n    return x * (27.0 + x2) / (27.0 + 9.0 * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx_deriv(float x) {\n    float x2 = x * x;\n    return 1.0 - 49.0 * x2 / (27.0 + 9.0 * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat sigmoid_deriv(float x) {\n    float s = sigmoid(x);\n    return s * (1.0 - s);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu(float x) {\n    return x > 0.0? x : 0.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat relu_deriv(float x) {\n    return x > 0.0? 1.0 : 0.0;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu(float x) {\n    return x > 0.0? x : 0.01 * x;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat leaky_relu_deriv(float x) {\n    return x > 0.0? 1.0 : 0.01;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat softplus(float x) {\n    return log(1.0 + exp(x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat softplus_deriv(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n// License: Unknown, author: Unknown,", "\n    col = pow(col, vec3(0.4545));\n    col = clamp(col, 0.0, 1.0);\n    col = col * 0.6 + col * col * 0.4;\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    return col;\n}\n", "\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec2 mod2(inout vec2 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec3 mod2(inout vec3 p, vec3 size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec3 mod2(inout vec3 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec4 mod2(inout vec4 p, vec4 size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\nvec4 mod2(inout vec4 p, float size) {\n    return p = mod(p, size) - 0.5 * size;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 repeat2(inout vec2 p, vec2 size) {\n    return p = mod(p, size);\n}\n\nvec2 repeat2(inout vec2 p, float size) {\n    return p = mod(p, size);\n}\n\nvec3 repeat2(inout vec3 p, vec3 size) {\n    return p = mod(p, size);\n}\n\nvec3 repeat2(inout vec3 p, float size) {\n    return p = mod(p, size);\n}\n\nvec4 repeat2(inout vec4 p, vec4 size) {\n    return p = mod(p, size);\n}\n\nvec4 repeat2(inout vec4 p, float size) {\n    return p = mod(p, size);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 repeat2(inout vec2 p, vec2 size, vec2 offset) {\n", "\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    uv.y *= resolution.y / resolution.x;\n    uv *= 10.0;\n    float n = noise(uv);\n    gl_FragColor = vec4(n, n, n, 1.0);\n}\n", "\n    return length(p-c) - r;\n}\n\n// signed distance to a box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// signed distance to a rounded box\nfloat sdRoundedBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// signed distance to a cylinder\nfloat sdCylinder( in vec2 p, in vec2 c )\n{\n    return length(p-c.xy) - c.y;\n}\n\n// signed distance to a torus\nfloat sdTorus( in vec2 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// signed distance to a plane\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n// signed distance to a torus\nfloat sdTorus( in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// signed distance to a box\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// signed distance to a sphere\nfloat sdSphere( in vec3 p,", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat sdRay( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a ray\nfloat sdRay( in vec2 p, in vec2 a, in vec2 b, float maxLen )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) * step( h, maxLen );\n}\n\n// distance to a line segment with rounding\nfloat sdSegmentRound( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance to a line segment with rounding\nfloat sdSegmentRound( in vec2 p, in vec2 a, in vec2 b, float r, float maxLen )\n{\n    vec2 pa = p", " return a.x*b.y - a.y*b.x; }\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return cro(v1, v2) > 0.0? cro(v0, v2) > 0.0? (u >= 0.0 && v >= 0.0 && u + v <= 1.0? cro(v0, v1) * sqrt(u * (1.0 - u) * (1.0 - v) * v) : 1e20) : cro(v0, v2) * sqrt(u * (1.0 - u) * (1.0 - v) * v) : cro(v0, v1) > 0.0? cro(v1, v2) * sqrt(u * v * (1.0 - u) * (1.0 - v)) : cro(v0, v2) * sqrt(u * (1.0 - u) * (1.0 - v) * v);\n}\n\n// signed distance to a 2D rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n", "\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return d-r;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float m ) \n{\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return mix(d-r, d+r, m);\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float m, in float d ) \n{\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return mix(d-r, d+r, m) - d;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float m, in float d, in float e ) \n{\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return mix(d-r, d+r, m) - d;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float m, in float d, in float e, in float f ) \n{\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return mix(d-r, d+r, m) - d;\n}\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r, in float m, in float d, in float e, in float f, in float g ) \n{\n    r = max(r, 0.001);\n    float d = length(p)-s;\n    return mix(d-r, d+r, m)", "\n    return x * (2.0 * x * x - 3.0 * x + 1.0);\n}\n\nvec3 r_curve(vec3 x)\n{\n    return x * (x * x * x - 0.66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666", "\n    return vec3(x.x * (1.0 - x.x) * (1.0 - x.x),\n                x.y * (1.0 - x.y) * (1.0 - x.y),\n                x.z * (1.0 - x.z) * (1.0 - x.z));\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, float t)\n{\n    return vec3(x.x * (1.0 - x.x) * (1.0 - x.x),\n                x.y * (1.0 - x.y) * (1.0 - x.y),\n                x.z * (1.0 - x.z) * (1.0 - x.z));\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, float t, float dt)\n{\n    return vec3(x.x * (1.0 - x.x) * (1.0 - x.x),\n                x.y * (1.0 - x.y) * (1.0 - x.y),\n                x.z * (1.0 - x.z) * (1.0 - x.z));\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, float t, float dt, float ddt)\n{\n    return vec3(x.x * (1.0 - x.x) * (1.0 - x.x),\n                x.y * (1.0 - x.y) * (1.0 - x.y),\n                x.z * (1.0 - x.z) * (1.0 - x.z));\n}\n\n// derivative of s-curve\nvec3 d_s_curve(vec3 x, float t, float dt, float ddt, float dddt)\n{\n    return vec3(x.x * (1.0 - x.x) * (1.0 - x.x),\n                x.y * (1.0 - x.y) * (1.0", "\n    float a = atan(p.x,p.y);\n    float t = a*k;\n    float r = w*sqrt(a);\n    return r*cos(t) - r*sin(t);\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec3 p, float w, in float k )\n{\n    float a = atan(p.x,p.y);\n    float t = a*k;\n    float r = w*sqrt(a);\n    return r*cos(t) - r*sin(t);\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec4 p, float w, in float k )\n{\n    float a = atan(p.x,p.y);\n    float t = a*k;\n    float r = w*sqrt(a);\n    return r*cos(t) - r*sin(t);\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec2 p, float w, in float k, in float d )\n{\n    float a = atan(p.x,p.y);\n    float t = a*k;\n    float r = w*sqrt(a);\n    return d - r*cos(t) + r*sin(t);\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec3 p, float w, in float k, in float d )\n{\n    float a = atan(p.x,p.y);\n    float t = a*k;\n    float r = w*sqrt(a);\n    return d - r*cos(t) + r*sin(t);\n}\n\n// w is the width / distance from center to tip\n// k is the number of rotations\nfloat sdSpiral( in vec4 p, float w, in float k, in float d )\n{\n    float a = at", "\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth)\n{\n    return exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nfloat Absorb(float opticalDepth, float distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(float opticalDepth, vec3 distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, float distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth, vec3 distance)\n{\n    return exp(-opticalDepth * distance);\n}\n\n// Calculate", "\n    // Calculate the transmittance for the ray.\n    transmittance = exp(-ScatteringCoefficient * rayLength);\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = vec3(0.0);\n    float stepSize = rayLength / float(ScatteringSamples);\n    float t = 0.0;\n    for (int i = 0; i < ScatteringSamples; i++)\n    {\n        vec3 samplePos = rayStart + rayDir * t;\n        vec3 sampleNormal = GetNormal(samplePos);\n        vec3 sampleAlbedo = GetAlbedo(samplePos);\n        vec3 sampleLight = lightColor * max(dot(sampleNormal, lightDir), 0.0);\n        scattering += sampleAlbedo * sampleLight * stepSize;\n        t += stepSize;\n    }\n\n    return scattering;\n}\n\n// Integrate scattering over a ray for multiple directional light sources.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir[], vec3 lightColor[], out vec3 transmittance)\n{\n    // Calculate the transmittance for the ray.\n    transmittance = exp(-ScatteringCoefficient * rayLength);\n\n    // Calculate the scattering for the ray.\n    vec3 scattering = vec3(0.0);\n    float stepSize = rayLength / float(ScatteringSamples);\n    float t = 0.0;\n    for (int i = 0; i < ScatteringSamples; i++)\n    {\n        vec3 samplePos = rayStart + rayDir * t;\n        vec3 sampleNormal = GetNormal(samplePos);\n        vec3 sampleAlbedo = GetAlbedo(samplePos);\n        vec3 sampleLight = vec3(0.0);\n        for (int j = 0; j < LightCount; j++)\n        {\n            sampleLight += lightColor[j] * max(dot(sampleNormal, lightDir[j]), 0.0", "\n    vec3 p = p2;\n    p.y -= d;\n    float r = ra - rb;\n    float b = dot(p,p) - r*r;\n    float a = length(p.xz) - r;\n    float k = max(a,b);\n    float s = sign(max(a,b));\n    return s*sqrt(max(k,0.0)) + min(max(a,b),0.0) - r;\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d )\n{\n    return sdDeathStar( p - vec3(0.0,d,0.0), ra, rb, d );\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d, in float r )\n{\n    return sdDeathStar( p - vec3(0.0,d,0.0), ra, rb, d, r );\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d, in float r, in float s )\n{\n    return sdDeathStar( p - vec3(0.0,d,0.0), ra, rb, d, r, s );\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p, in float ra, float rb, in float d, in float r, in float s, in float t )\n{\n    return sdDeathStar( p - vec3(0.0,d,0.0), ra, rb, d, r, s", "\n    float d = length(p)-r;\n    float e = abs(d)-t;\n    float i = max(d,e);\n    float s = sign(d);\n    return s*i + t*e*s;\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutSphere( vec3 p, float r, float h, float t )\n{\n    float d = length(p)-r;\n    float e = abs(d)-t;\n    float i = max(d,e);\n    float s = sign(d);\n    return s*i - t*e*(1.0-s);\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowCylinder( vec3 p, float r, float h, float t )\n{\n    vec2 d = abs(vec2(length(p.xz)-r,p.y)) - vec2(0.0,t);\n    float _out = length(max(d,0.0));\n    float _out2 = length(min(d,0.0));\n    float _in = min(max(d.x,d.y),0.0);\n    float i = _in + _out;\n    float o = _out2 - t;\n    float s = sign(max(d.x,d.y)); // sign not working?\n    return s*(i+o) + (1.0-s)*(i-o);\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutCylinder( vec3 p, float r, float h, float t )\n{\n    vec2 d = abs(vec2(length(p.xz)-r,p.y)) - vec2(0.0,t);\n    float _out = length(max(d,0.0));\n    float _out2 = length(min(d,0.0));\n    float _in = min(max(d.x,d", "\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( in vec", "\n    return length(p) - r - h;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d )\n{\n    return length(p) - r - h - d;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d, in float e )\n{\n    return length(p) - r - h - d - e;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d, in float e, in float f )\n{\n    return length(p) - r - h - d - e - f;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d, in float e, in float f, in float g )\n{\n    return length(p) - r - h - d - e - f - g;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d, in float e, in float f, in float g, in float hh )\n{\n    return length(p) - r - h - d - e - f - g - hh;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h, in float d, in float e, in float f, in float g, in float hh, in float ii )\n{\n    return length(p) - r - h - d - e - f - g - hh - ii;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p,", "\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// https://iquilezles.org/articles/normals\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// https://iquilezles.org/articles/normals\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+eps.yyx)-map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n// https://iquilezles.org/articles/normals\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy)-map(pos-eps.xyy),\n        map(pos+eps.yxy)-map(pos-eps.yxy),\n        map(pos+", "\n    vec2 q = vec2(length(p.x),p.y);\n    float d1 = length(q-vec2(r,0.0))-r;\n    float d2 = max(dot(normalize(q),vec2(0.0,1.0)),q.y);\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p.x),p.y);\n    float d1 = length(q-vec2(r,0.0))-r;\n    float d2 = max(dot(normalize(q),vec2(0.0,1.0)),q.y);\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec3 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d1 = length(q-vec2(r,0.0))-r;\n    float d2 = max(dot(normalize(q),vec2(0.0,1.0)),q.y);\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec4 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float d1 = length(q-vec2(r,0.0))-r;\n    float d2 = max(dot(normalize(q),vec2(0.0,1.0)),q.y);\n    return max(d1,d2);\n}\n\n// r=radius, h=height\nfloat sdCutCone( in vec2 p, in float r, in float h, in float a )\n{\n    vec2 q = vec2(length(p.x),p.y);\n    float d1", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// 3d noise function\nfloat fbm( in vec3 x )\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < 4; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 3d noise function\nfloat fbm( in vec3 x, in float a )\n{\n    float v = 0.0;\n    float shift = a;\n    float aa = a;\n    for (int i = 0; i < 4; ++i) {\n        v += aa * noise(x);\n        x = x * 2.0 + shift;\n        aa *= 0.5;\n    }\n    return v;\n}\n\n// 3d noise function\nfloat fbm( in vec3 x, in float a, in float b )\n{\n    float v = 0.0;\n    float shift = a;\n    float aa = a;\n    for (int i = 0; i < 4; ++i) {\n        v += aa * noise(x);\n        x = x * 2.0 + shift;\n        aa *= 0.5;\n    }\n    return v;\n}\n\n// 3d noise function\nfloat fbm( in vec3 x, in float a, in float b, in float c )\n{\n    float v = 0.0;\n    float", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, out vec3 q, out vec3 r )\n{\n    q = vec3(0.0);\n    r = vec3(0.0);\n    float f = 0.0;\n    f += 0.5000*noise( p, q, r ); p = m*p*2.02; q *= 2.02; r *= 2.02;\n    f += 0.2500*noise( p, q, r ); p = m*p*2.03; q *= 2.03; r *= 2.03;\n    f += 0.1250*noise( p, q, r ); p = m*p*2.01; q *= 2.01; r *= 2.01;\n    f += 0.0625*noise( p, q, r );\n    return f/0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p, out vec3 q, out vec3 r, out vec3 s )\n{\n    q = vec3(0.0);\n    r = vec3(0.0);\n    s = vec3(0.0);\n    float f = 0.0;\n    f += 0.5000*noise( p, q, r, s ); p = m*p*2.02; q *= 2.02; r *= 2.02; s *= 2.02;\n", "\n\tp3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    // Four corners in 2D of a tile\n    float a = hash31(i);\n    float b = hash31(i + vec3(1.0, 0.0, 0.0));\n    float c = hash31(i + vec3(0.0, 1.0, 0.0));\n    float d = hash31(i + vec3(1.0, 1.0, 0.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//value noise\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    // Four corners in 2D of a tile\n    float a = hash31(i);\n    float b = hash31(i + vec2(1.0, 0.0));\n    float c = hash31(i + vec2(0.0, 1.0));\n    float d = hash31(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//value noise\nfloat noise(float p)", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float f = cos(a * 10.0 + t) * 0.5 + 0.5;\n    float v = smoothstep(0.0, 1.0, f);\n    vec3 col = vec3(v);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n    vec3 color = hsv2rgb(vec3(0.0, 0.0, 0.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y-c.x;\n    float d2 = max(dot(q, c.yx)-c.x*length(c.yx), q.x);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(length", "\n    return fract(sin(co) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + i.y * 57.0 + 1.0);\n    float d = hash(i.x + 1.0 + i.y * 57.0 + 1.0);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude =.5;\n\n    // Loop of octaves\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *=.5;\n    }\n    return value;\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy / resolution.xy;\n    st.x *= resolution.x / resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(st + 0.00 * time);\n    q.y = fbm(st + vec2(1.0));\n\n    vec2 r = vec", "\n    return (t <= 0.0031308)? 12.92 * t : 1.055 * pow(t, 0.41666) - 0.055;\n}\n\nvec3 sRGB(vec3 t) {\n    return vec3(sRGB(t.r), sRGB(t.g), sRGB(t.b));\n}\n\nfloat linear(float t) {\n    return (t <= 0.04045)? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\nvec3 linear(vec3 t) {\n    return vec3(linear(t.r), linear(t.g), linear(t.b));\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.", " return pow(c, vec3(0.4545454545)); }\nvec3 linear(in vec3 c) { return pow(c, vec3(2.2)); }\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb_smooth(vec3 c) {\n    vec3 rgb = hsv2rgb(c);\n    return rgb;\n}\n\nvec3 rgb2hsv_smooth(vec3 c) {\n    vec3 hsv = rgb2hsv(c);\n    return hsv;\n}\n\nvec3 hsv2rgb_hard(vec3 c) {\n    vec3 rgb = hsv2rgb(c);\n", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmax(float a, float b, float k) {\n    return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < 0.0) t = -b + h;\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphere_d(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nfloat sphere_s(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot", "\n    vec4 z = p;\n    vec4 c = p;\n    float iter = 0.0;\n    for (int i = 0; i < 128; i++) {\n        iter = float(i);\n        z = vec4(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > 4.0) break;\n    }\n    return vec4(iter / 128.0, iter / 128.0, iter / 128.0, 1.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n    vec4 z = p;\n    vec4 c = p;\n    float iter = 0.0;\n    for (int i = 0; i < 128; i++) {\n        iter = float(i);\n        z = vec4(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > 4.0) break;\n    }\n    return vec4(iter / 128.0, iter / 128.0, iter / 128.0, 1.0);\n}\n\n// \"Amazing Surface\" fractal\n// https://www.shadertoy.com/view/XsBXWt\nvec4 formula(vec4 p) {\n    vec4 z = p;\n    vec4 c = p;\n    float iter = 0.0;\n    for (int i = 0; i < 128; i++) {\n        iter = float(i);\n        z = vec4(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > 4.0) break;\n    }\n    return ve", "\n    vec3 q = abs(p) - r;\n    return vec4( length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), normalize(q) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\nvec4 sdgSphere( vec3 p, float r )\n{\n    return vec4( length(p) - r, normalize(p) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\nvec4 sdgBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return vec4( length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), normalize(q) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\nvec4 sdgCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec4( min(max(d.x,d.y),0.0) + length(max(d,0.0)), normalize(vec3(p.x,sign(d.x),p.z)) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\nvec4 sdgCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    return vec4( dot(c,vec2(q,p.y)), vec3(p.x/q,sign(p.z)*c.y,p.z/q) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\nvec4 sdgTorus( vec3 p, vec2 t", "\n    float alpha = front.a + back.a * (1.0 - front.a);\n    vec3 color = mix(back.rgb, front.rgb, front.a) * (1.0 / alpha);\n    return vec4(color, alpha);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha));\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha.r));\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, float alpha, float alpha2) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha), alpha2);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha.r), alpha2.r);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha.r), alpha2.r, alpha3.r);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3, vec4 alpha4) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha.r), alpha2.r, alpha3.r, alpha4.r);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front, vec4 alpha, vec4 alpha2, vec4 alpha3, vec4 alpha4, vec4 alpha5) {\n    return alphaBlend(back, vec4(front.rgb, front.a * alpha.r), alpha2", "\n    return back + front.rgb * (1.0 - back.a) * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n    return back + front.rgba * (1.0 - back.a) * front.a;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec3 front) {\n    return back + vec4(front, 1.0) * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec3 front) {\n    return back + front * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, float front) {\n    return back + vec4(front, front, front, front) * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, float front) {\n    return back + vec3(front, front, front) * (1.0 - back.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(float back, vec4 front) {\n    return vec4(back, back, back, back) + front * (1.0 - back);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(float back, vec3 front) {\n    return vec3(back, back, back) + front * (1.0 - back);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front, float alpha) {\n    return back + front.rgba * (1.0 - back.a) * alpha;\n}\n\n// License: Unknown, author: Unknown, found:", "\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    p.xz -= 2.0*min(dot(k.xz, p.xz), 0.0)*k.xz;\n    p.yz -= 2.0*min(dot(k.yz, p.yz), 0.0)*k.yz;\n    return length(p.xy)*sign(p.z);\n}\n\nfloat hex_dist(vec2 p, float r) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p) {\n    return hex(p, 1.0);\n}\n\nfloat hex_dist(vec2 p, float r, float t) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d, float f) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d, float f, float g) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d, float f, float g, float h) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d, float f, float g, float h, float i) {\n    return hex(p, r);\n}\n\nfloat hex_dist(vec2 p, float r, float t, float s, float d, float f, float g,", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nvec3 aces_approx_inv(vec3 v) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(v*(", "\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = (a.x > a.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x), sign(a.y));\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\n    vec3 n = h * h * h * h * vec3(dot(a, hash2(i + 0.0)), dot(b, hash2(i + o)), dot(c, hash2(i + 1.0)));\n\n    return dot(n, vec3(70.0)); // * 1.5;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p);\n    f += 0.2500 * noise(p * 2.0);\n    f += 0.1250 * noise(p * ", "\n    Temp = clamp(Temp, 1000.0, 40000.0) / 100.0;\n    vec3 ret = vec3(0.0);\n    if (Temp <= 66.0) {\n        ret.r = 255.0;\n    } else {\n        ret.r = Temp - 60.0;\n        ret.r = 329.698727446 * pow(ret.r, -0.1332047592);\n        if (Temp >= 1000.0) {\n            ret.r = ret.r - (0.27105 * (Temp - 1000.0));\n        }\n    }\n    if (Temp <= 66.0) {\n        ret.g = Temp;\n        ret.g = 99.4708025861 * log(ret.g) - 161.1195681661;\n    } else {\n        ret.g = Temp - 60.0;\n        ret.g = 288.1221695283 * pow(ret.g, -0.0755148492);\n    }\n    if (Temp >= 66.0) {\n        ret.b = 255.0;\n    } else if (Temp <= 19.0) {\n        ret.b = 0.0;\n    } else {\n        ret.b = Temp - 10.0;\n        ret.b = 138.5177312231 * log(ret.b) - 305.0447927307;\n    }\n    return ret * (1.0 / 255.0);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)),\n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)),\n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p); p = p*2.04;\n    f += 0.0312*noise(p);\n    return f/0.984375;\n}\n\nfloat fbm_2(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p); p = p*2.04;\n    f += 0.0312*noise(p);\n    return f/0.984375;\n}\n\nfloat fbm_3(vec2 p) {\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 raySphereNormal(vec3 pos, vec4 sph) {\n    return (pos - sph.xyz) / sph.w;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 raySphereColor(vec3 pos, vec4 sph) {\n    return sph.xyz;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 raySphereReflect(vec3 pos, vec3 normal, vec4 sph) {\n    return reflect(pos - sph.xyz, normal);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec3 raySphereRefract(vec3 pos, vec3 normal, vec4 sph, float ior) {\n    float eta = sph.w / ior;\n    float cosi = clamp(dot(normal, pos - sph.xyz), -1.0, 1.0);\n    float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    return eta * pos + (eta * cosi - sqrt(abs(cost2))) * normal;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/sphe", "\n    p = abs(p);\n    float d = length(p) - 1.0;\n    float m = dot(p, p) - 1.0;\n    float n2 = n * n;\n    float d2 = d * d / 4.0;\n    float m2 = m * m * n2;\n    float b = -m / (2.0 * n);\n    float h = b * b - d2;\n    if (h < 0.0)\n        return vec3(d, 0.0, 0.0);\n    h = sqrt(h);\n    vec3 res;\n    res.x = -b - h;\n    res.y = m + n * res.x;\n    res.z = m - n * res.x;\n    res.yz *= rsqrt(dot(res.yz, res.yz));\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdCylinder(vec2 p, float r)\n{\n    p.x = abs(p.x);\n    float d = length(p) - r;\n    float m = p.x - r;\n    float b = -m / (2.0 * r);\n    float h = b * b - d * d;\n    if (h < 0.0)\n        return vec3(d, 0.0, 0.0);\n    h = sqrt(h);\n    vec3 res;\n    res.x = -b - h;\n    res.y = m + r * res.x;\n    res.z = m - r * res.x;\n    res.yz *= rsqrt(dot(res.yz, res.yz));\n    return res;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p", "\n    return (x + t * x * (1.0 - x));\n}\n\nfloat cantor( float x )\n{\n    return cantor( x, 0.5 );\n}\n\nfloat cantor( float x, float t, float n )\n{\n    float y = x;\n    for (int i = 0; i < n; i++)\n    {\n        y = cantor( y, t );\n    }\n    return y;\n}\n\nfloat cantor( float x, float n )\n{\n    return cantor( x, 0.5, n );\n}\n\nfloat cantor( float x, float t, float n, float m )\n{\n    float y = x;\n    for (int i = 0; i < n; i++)\n    {\n        y = cantor( y, t );\n    }\n    return y * m;\n}\n\nfloat cantor( float x, float n, float m )\n{\n    return cantor( x, 0.5, n, m );\n}\n\nfloat cantor( float x, float t, float n, float m, float a )\n{\n    float y = x;\n    for (int i = 0; i < n; i++)\n    {\n        y = cantor( y, t );\n    }\n    return y * m + a;\n}\n\nfloat cantor( float x, float n, float m, float a )\n{\n    return cantor( x, 0.5, n, m, a );\n}\n\nfloat cantor( float x, float t, float n, float m, float a, float b )\n{\n    float y = x;\n    for (int i = 0; i < n; i++)\n    {\n        y = cantor( y, t );\n    }\n    return y * m + a + b;\n}\n\nfloat cantor( float x, float n, float m, float a, float b )\n{\n    return cantor( x, 0.5, n, m, a, b );\n}\n\nfloat cantor( float x, float t, float n, float m, float a, float b, float c )", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    return (length(p)-dot(ab,ab)) / length(max(p,ab));\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n", "\n    float d = p.x;\n    for (int i = 0; i < 4; i++) {\n        p.xy = abs(p.xy) - 1.0;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy = p.yx;\n        p.xy =", "\n    return x == 0.0? sign(y) * 1.57079632679489661923 : atan(y, x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(float y, float x) {\n    return x == 0.0? sign(y) * 1.57079632679489661923 : atan(y, x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y_over_x) {\n    return y_over_x == 0.0? sign(y_over_x) * 1.57079632679489661923 : atan(y_over_x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(float y_over_x) {\n    return y_over_x == 0.0? sign(y_over_x) * 1.57079632679489661923 : atan(y_over_x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(vec2 p) {\n    return atan(p.x, p.y);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan2_approx(vec2 p) {\n    return atan(p.y, p.x);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flS", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2((z.x * w.x + z.y * w.y) / (w.x * w.x + w.y * w.y), (z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rw = pow(r, w.x);\n    float thetaw = w.x * theta + w.y * log(r);\n    return vec2(rw * cos(thetaw), rw * sin(thetaw));\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rw = sqrt(r);\n    float thetaw = theta / 2.0;\n    return vec2(rw * cos(thetaw), rw * sin(thetaw));\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return cdiv(csin(z), ccos(z));\n}\n\nvec2 catan(vec2", "\n    return 0.5 * log(1.0 + z) - 0.5 * log(1.0 - z);\n}\n\n// Inverse hyperbolic cotangent\nvec2 cacoth(vec2 z) {\n    return 0.5 * log(1.0 + z) - 0.5 * log(1.0 - z);\n}\n\n// Inverse hyperbolic secant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// Inverse hyperbolic cosecant\nvec2 casinh(vec2 z) {\n    return 0.5 * log(z + sqrt(z * z + 1.0));\n}\n\n// In", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x) * cosh(z.y), tanh(z.x) * sinh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return vec2(pow(z.x, w.x) * pow(z.y, w.y), pow(z.x, w.y) * pow(z.y, w.x));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x) * cos(0.5 * atan(z.y / z.x)), sqrt(z.x) * sin(0.5 * atan(z.y / z.x)));\n}\n\nvec2 cabs(vec2 z) {\n    return vec2(sqrt(z.x * z.x + z.y * z.y), 0.0);\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x) * cosh(z.y), sinh(z.y) / cosh(", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2((z.x * w.x + z.y * w.y) / (w.x * w.x + w.y * w.y), (z.y * w.x - z.x * w.y) / (w.x * w.x + w.y * w.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    return vec2(pow(r, w.x) * cos(w.y * theta), pow(r, w.x) * sin(w.y * theta));\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    return vec2(sqrt(r) * cos(0.5 * theta), sqrt(r) * sin(0.5 * theta));\n}\n\nvec2 cpow(vec2 z, float w) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    return vec2(pow(r, w) * cos(w * theta), pow(r, w) * sin(w * theta));\n}\n\nvec2 csqrt(float z) {\n    return vec2(sqrt(z) * cos(0.25 * PI), sqrt(z) * sin(0.25 * PI));\n}\n\nvec2 cexp(vec2 z) {\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z", "\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n    return vec2(tanh(z.x) * cosh(z.y), tanh(z.x) * sinh(z.y));\n}\n\nvec2 csinh(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 ccosh(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    return vec2(pow(z.x, w.x) * pow(z.y, w.y), pow(z.x, w.y) * pow(z.y, w.x));\n}\n\nvec2 csqrt(vec2 z) {\n    return vec2(sqrt(z.x) * cos(0.5 * atan(z.y / z.x)), sqrt(z.x) * sin(0.5 * atan(z.y / z.x)));\n}\n\nvec2 cabs(vec2 z) {\n    return vec2(sqrt(z.x * z.x + z.y * z.y), 0.0);\n}\n\nvec2 csin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 ccos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 ctan(vec2 z) {\n    return vec2(tan(z.x) * cosh(z.y), sinh(z.y) / cosh(", "\n    return alpha * (1.0 + contrast) / 2.0;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 3 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float midpoint) {\n    return alpha * (1.0 + contrast) / 2.0 + midpoint;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 4 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float midpoint, float gamma) {\n    return alpha * (1.0 + contrast) / 2.0 + midpoint;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 5 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float midpoint, float gamma, float power) {\n    return alpha * (1.0 + contrast) / 2.0 + midpoint;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 6 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float midpoint, float gamma, float power, float offset) {\n    return alpha * (1.0 + contrast) / 2.0 + midpoint;\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 7 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast, float midpoint, float gamma, float power, float offset, float scale) {\n    return alpha * (1.0 + contrast) / 2.0 + midpoint", "\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.y-p.z;\n    float d3 = p.z-p.x;\n    float d4 = p.x-p.y;\n    float d5 = p.x+p.y-1.0;\n    float d6 = p.y+p.z-1.0;\n    float d7 = p.z+p.x-1.0;\n    float d8 = p.x+p.y+p.z-3.0;\n    return -min(0.0, max(d1, max(d2, max(d3, max(d4, max(d5, max(d6, max(d7, d8))))))));\n}\n\n//Distance from the Edge of Tetrahedron\nfloat tetraDist(vec3 p) {\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.y-p.z;\n    float d3 = p.z-p.x;\n    float d4 = p.x-p.y;\n    return -min(0.0, max(d1, max(d2, max(d3, d4))));\n}\n\n//Distance from the Edge of Cube\nfloat cubeDist(vec3 p) {\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.y-p.z;\n    float d3 = p.z-p.x;\n    float d4 = p.x-p.y;\n    float d5 = p.x+p.y-1.0;\n    float d6 = p.y+p.z-1.0;\n    float d7 = p.z+p.x-1.0;\n    return -min(0.0, max(d1, max(d2, max(d3, max(d4, max(d5, max(", "\n    vec3 p = uvw;\n    vec3 q = p - 0.5;\n    vec3 r = p - 0.5;\n    vec3 s = p - 0.5;\n    vec3 t = p - 0.5;\n    vec3 u = p - 0.5;\n    vec3 v = p - 0.5;\n    vec3 w = p - 0.5;\n    vec3 x = p - 0.5;\n    vec3 y = p - 0.5;\n    vec3 z = p - 0.5;\n    vec3 a = p - 0.5;\n    vec3 b = p - 0.5;\n    vec3 c = p - 0.5;\n    vec3 d = p - 0.5;\n    vec3 e = p - 0.5;\n    vec3 f = p - 0.5;\n    vec3 g = p - 0.5;\n    vec3 h = p - 0.5;\n    vec3 i = p - 0.5;\n    vec3 j = p - 0.5;\n    vec3 k = p - 0.5;\n    vec3 l = p - 0.5;\n    vec3 m = p - 0.5;\n    vec3 n = p - 0.5;\n    vec3 o = p - 0.5;\n    vec3 p1 = p - 0.5;\n    vec3 q1 = p - 0.5;\n    vec3 r1 = p - 0.5;\n    vec3 s1 = p - 0.5;\n    vec3 t1 = p - 0.5;\n    vec3 u1 = p - 0.5;\n    vec3 v1 = p - 0.5;\n    vec3 w1 = p - 0.5;\n    vec3 x1 = p - 0.5;\n    vec3 y1 = p - 0.5;\n", "\n    vec3 p = uvw;\n    p.xz = mod(p.xz, gridRes) - gridRes / 2.;\n    p.y = mod(p.y, gridRes) - gridRes / 2.;\n    p += offset;\n    p.xz = abs(p.xz);\n    p.y = abs(p.y);\n    float d = min(p.x, min(p.y, p.z));\n    p = p - d * normalize(p);\n    return tilingVal3D(p, gridRes);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float gridRes2) {\n    vec3 p = uvw;\n    p.xz = mod(p.xz, gridRes) - gridRes / 2.;\n    p.y = mod(p.y, gridRes2) - gridRes2 / 2.;\n    p += offset;\n    p.xz = abs(p.xz);\n    p.y = abs(p.y);\n    float d = min(p.x, min(p.y, p.z));\n    p = p - d * normalize(p);\n    return tilingVal3D(p, gridRes);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes, float gridRes2, float gridRes3) {\n    vec3 p = uvw;\n    p.xz = mod(p.xz, gridRes) - gridRes / 2.;\n    p.y = mod(p.y, gridRes2) - gridRes2 / 2.;\n    p.z = mod(p.z, gridRes3) - gridRes3 / 2.;\n    p += offset;\n    p.xz = abs(p.xz);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    float d", "\n    uvw.xy = abs(uvw.xy);\n    uvw.xy = uvw.xy - 0.5;\n    uvw.xy = uvw.xy * gridRes;\n    uvw.xy = floor(uvw.xy);\n    uvw.xy = uvw.xy / gridRes;\n    uvw.xy = uvw.xy + 0.5;\n    uvw.xy = uvw.xy - uvw.z;\n    uvw.xy = uvw.xy * contrast;\n    uvw.xy = uvw.xy + uvw.z;\n    return uvw;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float offset) {\n    uvw.xy = abs(uvw.xy);\n    uvw.xy = uvw.xy - 0.5;\n    uvw.xy = uvw.xy * gridRes;\n    uvw.xy = floor(uvw.xy);\n    uvw.xy = uvw.xy / gridRes;\n    uvw.xy = uvw.xy + 0.5;\n    uvw.xy = uvw.xy - uvw.z;\n    uvw.xy = uvw.xy * contrast;\n    uvw.xy = uvw.xy + uvw.z;\n    uvw.xy = uvw.xy + offset;\n    return uvw;\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float offset, float offset2) {\n    uvw.xy = abs(uvw.xy);\n    uvw.xy = uvw.xy - 0.5;\n    uvw.xy = uvw.xy * gridRes;\n    uvw.xy = floor(uvw.xy);\n   ", "\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r) {\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t * r;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float s) {\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t * r * s;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float s, float t) {\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t * r * s * t;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float s, float t, float u) {\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t * r * s * t * u;\n}\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p, float r, float s, float t, float u, float v) {\n    float d = dot(p, p);\n    float t = (3.0 - sqrt(1.0 + 8.0 * d)) / 2.0;\n    return cbrt(d) * t * r * s * t * u * v;", "\n    return vec3(\n        pow(t, 0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    float s = sin(a.y);\n    float c = cos(a.y);\n    mat3 m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    return m * v;\n}\n\n// returns a random number from 0 to 1\nfloat random(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// returns a random number from 0 to 1\nfloat random(float st)\n{\n    return fract(sin(st) * 43758.5453123);\n}\n\n// returns a random number from 0 to 1\nfloat random(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 123.456))) * 43758.5453123);\n}\n\n// returns a random number from 0 to 1\nfloat random(vec4 st)\n{\n    return fract(sin(dot(st.xyzw, vec4(12.9898, 78.233, 123.456, 45.678))) * 43758.5453123);\n}\n\n// returns a random number from 0 to 1\nfloat random(float st, float max)\n{\n    return fract(sin(st) * max);\n}\n\n// returns a random number from 0 to 1\nfloat random(vec2 st, float max)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * max);\n}\n\n// returns a random number from 0 to 1\nfloat random(vec3 st, float max)\n{\n    return fract(sin(dot(st.xyz, vec3(1", "\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= resolution.x / resolution.y;\n\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float v = hash(floor(vec2(a, r)));\n\n    gl_FragColor = vec4(v, v, v, 1.0);\n}\n", "\n    p = abs(p);\n    return max(p.x, max(p.y, p.x + p.y));\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec3 p) {\n    p = abs(p);\n    return max(p.x, max(p.y, max(p.z, p.x + p.y + p.z)));\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec4 p) {\n    p = abs(p);\n    return max(p.x, max(p.y, max(p.z, max(p.w, p.x + p.y + p.z + p.w))));\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p, float scale) {\n    p = abs(p);\n    return max(p.x, max(p.y, p.x + p.y)) * scale;\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec3 p, float scale) {\n    p = abs(p);\n    return max(p.x, max(p.y, max(p.z, p.x + p.y + p.z))) * scale;\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec4 p, float scale) {\n    p = abs(p);\n    return max(p.x, max(p.y, max(p.z, max(p.w, p.x + p.y + p.z + p.w)))) * scale;\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec2 p, vec2 scale) {\n    p = abs(p);\n    return max(p.x, max(p.y, p.x + p.y)) * max(scale.x, scale.y);\n}\n\n// Hexagonal distance from the 0,0 coords\nfloat hexDist(vec3 p, vec3 scale) {\n    p = abs", "\n    vec2 p = uv;\n    p.x *= 1.5;\n    p.x -= floor(p.x * 0.5) * 2.0;\n    p.x = abs(p.x - 1.0);\n    p.y = abs(p.y - 0.5);\n    p.y = min(p.y, 1.0 - p.y);\n    p.y *= 2.0;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 0.5;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 2.0;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 0.5;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 2.0;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 0.5;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 2.0;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 0.5;\n    p.y = min(p.y, 1.0 - p.y);\n    p.y = abs(p.y - 1.0);\n    p.y *= 2.0;\n    p.y = min(p", "\n    vec3 a = vec3(0.270598, 0.00984309, 0.333333);\n    vec3 b = vec3(0.988235, 0.956863, 0.752941);\n    vec3 c = vec3(0.992157, 0.121569, 0.00784314);\n    vec3 d = vec3(0.200000, 0.129412, 0.160784);\n    vec3 e = vec3(0.000000, 0.000000, 0.000000);\n    vec3 f = vec3(0.000000, 0.000000, 0.000000);\n    return a + b * cos(6.28318530718 * (c * t + d)) + e * cos(6.28318530718 * (f * t));\n}\n\n// makes viridis colormap with polynimal 5 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    vec3 a = vec3(0.270598, 0.00984309, 0.333333);\n    vec3 b = vec3(0.988235, 0.956863, 0.752941);\n    vec3 c = vec3(0.992157, 0.121569, 0.00784314);\n    vec3 d = vec3(0.200000, 0.129412, 0.160784);\n   ", "\n    return (x + 1) / 2;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat makeNeg1to1(float x) {\n    return x * 2 - 1;\n}\n\n//shifts value range from 0-1 to 0-255\nint make0to255(float x) {\n    return (int)(x * 255);\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0-1\nfloat make0to1from255(int x) {\n    return (float)x / 255;\n}\n\n//shifts value range from 0-255 to 0", "\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.01, wave);\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.01, wave);\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len, float len2) {\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.01, wave) + smoothstep(len2, len2 + 0.01, wave);\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len, float len2, float len3) {\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.01, wave) + smoothstep(len2, len2 + 0.01, wave) + smoothstep(len3, len3 + 0.01, wave);\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec2 offset, float gridRes, float time, float len, float len2, float len3, float len4) {\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.01, wave) + smoothstep(len2, len2 + 0.01, wave) + smoothstep(len3, len3 + 0.01, wave) + smoothstep(len4, len4 + 0.01, wave);\n}\n\n// generates pixelated directional waves\nfloat flowHex(vec2 uv, vec", "\n    float t = time * 0.001;\n    float x = uv.x * gridRes;\n    float y = uv.y * gridRes;\n    float x1 = floor(x);\n    float y1 = floor(y);\n    float x2 = ceil(x);\n    float y2 = ceil(y);\n    float x3 = x1;\n    float y3 = y2;\n    float x4 = x2;\n    float y4 = y1;\n    float x5 = x1;\n    float y5 = y1;\n    float x6 = x2;\n    float y6 = y2;\n    float x7 = x1;\n    float y7 = y2;\n    float x8 = x2;\n    float y8 = y1;\n    float x9 = x1;\n    float y9 = y1;\n    float x10 = x2;\n    float y10 = y2;\n    float x11 = x1;\n    float y11 = y2;\n    float x12 = x2;\n    float y12 = y1;\n    float x13 = x1;\n    float y13 = y1;\n    float x14 = x2;\n    float y14 = y2;\n    float x15 = x1;\n    float y15 = y2;\n    float x16 = x2;\n    float y16 = y1;\n    float x17 = x1;\n    float y17 = y1;\n    float x18 = x2;\n    float y18 = y2;\n    float x19 = x1;\n    float y19 = y2;\n    float x20 = x2;\n    float y20 = y1;\n    float x21 = x1;\n    float y21 = y1;\n    float x22 = x2;\n    float y22 = y2;\n    float x23 = x1;\n    float y23 = y2;\n    float x24 = x2;\n    float y24 = y1;\n    float x", "\n    vec2 center = vec2(0.0, 0.0);\n    float angle = atan(point.y - center.y, point.x - center.x);\n    float distance = length(point - center);\n    float speed = distance / time;\n    float angleSpeed = speed / radius;\n    float newAngle = angle + angleSpeed * time;\n    float newDistance = radius;\n    vec2 newPoint = vec2(cos(newAngle), sin(newAngle)) * newDistance;\n    return newPoint;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle) {\n    vec2 center = vec2(0.0, 0.0);\n    float distance = length(point - center);\n    float speed = distance / time;\n    float angleSpeed = speed / radius;\n    float newAngle = angle + angleSpeed * time;\n    float newDistance = radius;\n    vec2 newPoint = vec2(cos(newAngle), sin(newAngle)) * newDistance;\n    return newPoint;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float distance) {\n    vec2 center = vec2(0.0, 0.0);\n    float speed = distance / time;\n    float angleSpeed = speed / radius;\n    float newAngle = angle + angleSpeed * time;\n    float newDistance = radius;\n    vec2 newPoint = vec2(cos(newAngle), sin(newAngle)) * newDistance;\n    return newPoint;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time, float angle, float distance, float angleSpeed) {\n    vec2 center = vec2(0.0, 0.0);\n    float speed = distance / time;\n    float newAngle = angle + angleSpeed * time;\n    float newDistance = radius;\n    vec2 newPoint = vec2(cos(new", "\n    vec2 tileSize = vec2(1.0, 1.0);\n    vec2 tilePos = floor(pos / tileSize);\n    return tilePos * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize) {\n    vec2 tilePos = floor(pos / tileSize);\n    return tilePos * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tilePos) {\n    return tilePos * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tilePos, vec2 tileOffset) {\n    return (tilePos + tileOffset) * tileSize + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tilePos, vec2 tileOffset, vec2 tileScale) {\n    return (tilePos + tileOffset) * tileSize * tileScale + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tilePos, vec2 tileOffset, vec2 tileScale, vec2 tileRotation) {\n    return (tilePos + tileOffset) * tileSize * tileScale + tileSize / 2.0;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos, vec2 tileSize, vec2 tilePos, vec2 tileOffset, vec2 tileScale, vec2 tileRotation, vec2 tileSheetSize) {\n    return (tilePos + tileOffset) * tileSize * tileScale + tileSize / 2.0", "\n    vec2 d = p2 - p1;\n    vec2 t = p - p1;\n    float t2 = dot(t, d);\n    float t1 = dot(t, d);\n    float t3 = dot(t, d);\n    float t4 = dot(t, d);\n    float t5 = dot(t, d);\n    float t6 = dot(t, d);\n    float t7 = dot(t, d);\n    float t8 = dot(t, d);\n    float t9 = dot(t, d);\n    float t10 = dot(t, d);\n    float t11 = dot(t, d);\n    float t12 = dot(t, d);\n    float t13 = dot(t, d);\n    float t14 = dot(t, d);\n    float t15 = dot(t, d);\n    float t16 = dot(t, d);\n    float t17 = dot(t, d);\n    float t18 = dot(t, d);\n    float t19 = dot(t, d);\n    float t20 = dot(t, d);\n    float t21 = dot(t, d);\n    float t22 = dot(t, d);\n    float t23 = dot(t, d);\n    float t24 = dot(t, d);\n    float t25 = dot(t, d);\n    float t26 = dot(t, d);\n    float t27 = dot(t, d);\n    float t28 = dot(t, d);\n    float t29 = dot(t, d);\n    float t30 = dot(t, d);\n    float t31 = dot(t, d);\n    float t32 = dot(t, d);\n    float t33 = dot(t, d);\n    float t34 = dot(t, d);\n    float t35 = dot(t, d);\n    float t36 = dot(t, d);\n    float t37 = dot(t, d);\n    float t38 = dot(t, d);\n   ", "\n    float d = length(v);\n    float a = atan(v.y, v.x);\n    float r = d / 2.0;\n    float r2 = r * r;\n    float r3 = r2 * r;\n    float r4 = r3 * r;\n    float r5 = r4 * r;\n    float r6 = r5 * r;\n    float r7 = r6 * r;\n    float r8 = r7 * r;\n    float r9 = r8 * r;\n    float r10 = r9 * r;\n    float r11 = r10 * r;\n    float r12 = r11 * r;\n    float r13 = r12 * r;\n    float r14 = r13 * r;\n    float r15 = r14 * r;\n    float r16 = r15 * r;\n    float r17 = r16 * r;\n    float r18 = r17 * r;\n    float r19 = r18 * r;\n    float r20 = r19 * r;\n    float r21 = r20 * r;\n    float r22 = r21 * r;\n    float r23 = r22 * r;\n    float r24 = r23 * r;\n    float r25 = r24 * r;\n    float r26 = r25 * r;\n    float r27 = r26 * r;\n    float r28 = r27 * r;\n    float r29 = r28 * r;\n    float r30 = r29 * r;\n    float r31 = r30 * r;\n    float r32 = r31 * r;\n    float r33 = r32 * r;\n    float r34 = r33 * r;\n    float r35 = r34 * r;\n    float r36 = r35 * r;\n    float r37 = r36 * r;\n    float r38 = r37 * r;\n    float r39 = r38 * r", "\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeNeg1to1(vec2 x) {\n    return (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec3 make0to1(vec3 x) {\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 makeNeg1to1(vec3 x) {\n    return (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec4 make0to1(vec4 x) {\n    return (x + 1.0) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec4 makeNeg1to1(vec4 x) {\n    return (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x, vec2 min, vec2 max) {\n    return (x - min) / (max - min);\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeNeg1to1(vec2 x, vec2 min, vec2 max) {\n    return (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec3 make0to1(vec3 x, vec3 min, vec3 max) {\n    return (x - min) / (max - min);\n}\n\n//shifts value range from 0-1 to -1-1\nvec3 makeNeg1to1(vec3 x, vec3 min, vec3 max) {\n    return (x * 2.0) - 1.0;\n}\n\n//shifts value range from -1-1 to 0-", "\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius + spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a circle centered on point\nvec2 circleFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius + spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a square centered on point\nvec2 squareFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius + spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a triangle centered on point\nvec2 triangleFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius + spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the shape of a hexagon centered on point\nvec2 hexagonFlow(vec2 point, float spread, float offset)\n{\n    float angle = atan(point.y, point.x);\n    float radius = length(point);\n    float angleOffset = angle + offset;\n    float radiusOffset = radius + spread;\n    return vec2(cos(angleOffset) * radiusOffset, sin(angleOffset) * radiusOffset);\n}\n\n// makes a simple flowmap in the", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r2;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r3;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r4;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4, in float r5 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r5;\n}\n", "\n    float d = length(p) - sp;\n    d = max(d, -length(p - vec2(0.0, sp)) + sp);\n    d = max(d, -length(p - vec2(sp, 0.0)) + sp);\n    d = max(d, -length(p - vec2(0.0, -sp)) + sp);\n    d = max(d, -length(p - vec2(-sp, 0.0)) + sp);\n    d = max(d, -length(p - vec2(sp, sp)) + sp);\n    d = max(d, -length(p - vec2(sp, -sp)) + sp);\n    d = max(d, -length(p - vec2(-sp, sp)) + sp);\n    d = max(d, -length(p - vec2(-sp, -sp)) + sp);\n    d = max(d, -length(p - vec2(0.0, 2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(2.0 * sp, 0.0)) + sp);\n    d = max(d, -length(p - vec2(0.0, -2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(-2.0 * sp, 0.0)) + sp);\n    d = max(d, -length(p - vec2(2.0 * sp, 2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(2.0 * sp, -2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(-2.0 * sp, 2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(-2.0 * sp, -2.0 * sp)) + sp);\n    d = max(d, -length(p - vec2(3.0 * sp, 0.0)) + sp);\n    d = max(d,", "\n    float d = length(p) - ra;\n    float a = atan(p.y, p.x);\n    float r = (a + sp * time) / sp;\n    float da = abs(r) - 1.0;\n    return max(d, da);\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset )\n{\n    float d = length(p) - ra;\n    float a = atan(p.y, p.x);\n    float r = (a + sp * time) / sp;\n    float da = abs(r) - 1.0;\n    return max(d, da) + offset;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset, float scale )\n{\n    float d = length(p) - ra;\n    float a = atan(p.y, p.x);\n    float r = (a + sp * time) / sp;\n    float da = abs(r) - 1.0;\n    return max(d, da) + offset * scale;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset, float scale, float offset2 )\n{\n    float d = length(p) - ra;\n    float a = atan(p.y, p.x);\n    float r = (a + sp * time) / sp;\n    float da = abs(r) - 1.0;\n    return max(d, da) + offset * scale + offset2;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time, float offset, float scale, float offset2, float scale2 )\n{\n    float d = length(p) - ra;\n    float a = atan(p.y, p.x);\n    float r = (a + sp * time) / sp;", "\n    uvw = abs(uvw);\n    return max(uvw.x, max(uvw.y, uvw.z));\n}\n\n//edge distance of a Sphere\nfloat sphereDist(vec3 uvw) {\n    return length(uvw) - 1.0;\n}\n\n//edge distance of a Torus\nfloat torusDist(vec3 uvw) {\n    uvw.x = length(uvw.xy) - 1.0;\n    return length(uvw.xy) - 0.25;\n}\n\n//edge distance of a Cylinder\nfloat cylinderDist(vec3 uvw) {\n    uvw.x = length(uvw.xy) - 1.0;\n    return max(uvw.z, uvw.x);\n}\n\n//edge distance of a Cone\nfloat coneDist(vec3 uvw) {\n    uvw.x = length(uvw.xy) - 1.0;\n    return max(uvw.z, uvw.x);\n}\n\n//edge distance of a Plane\nfloat planeDist(vec3 uvw) {\n    return uvw.z;\n}\n\n//edge distance of a Hexagonal Prism\nfloat hexagonalPrismDist(vec3 uvw) {\n    uvw.xy = abs(uvw.xy);\n    return max(uvw.z, max(uvw.x, uvw.y));\n}\n\n//edge distance of a Triangular Prism\nfloat triangularPrismDist(vec3 uvw) {\n    uvw.xy = abs(uvw.xy);\n    return max(uvw.z, max(uvw.x, uvw.y));\n}\n\n//edge distance of a Octahedron\nfloat octahedronDist(vec3 uvw) {\n    uvw.xy = abs(uvw.xy);\n    return max(uvw.z, max(uvw.x, uvw.y));\n}\n\n//edge distance of a Tetrahedron\nfloat tetrahedronDist(vec3 uvw", "\n    vec3 uvw2 = uvw * 2.0;\n    vec3 uvw3 = uvw * 3.0;\n    vec3 uvw4 = uvw * 4.0;\n    vec3 uvw5 = uvw * 5.0;\n    vec3 uvw6 = uvw * 6.0;\n    vec3 uvw7 = uvw * 7.0;\n    vec3 uvw8 = uvw * 8.0;\n    vec3 uvw9 = uvw * 9.0;\n    vec3 uvw10 = uvw * 10.0;\n    vec3 uvw11 = uvw * 11.0;\n    vec3 uvw12 = uvw * 12.0;\n    vec3 uvw13 = uvw * 13.0;\n    vec3 uvw14 = uvw * 14.0;\n    vec3 uvw15 = uvw * 15.0;\n    vec3 uvw16 = uvw * 16.0;\n    vec3 uvw17 = uvw * 17.0;\n    vec3 uvw18 = uvw * 18.0;\n    vec3 uvw19 = uvw * 19.0;\n    vec3 uvw20 = uvw * 20.0;\n    vec3 uvw21 = uvw * 21.0;\n    vec3 uvw22 = uvw * 22.0;\n    vec3 uvw23 = uvw * 23.0;\n    vec3 uvw24 = uvw * 24.0;\n    vec3 uvw25 = uvw * 25.0;\n    vec3 uvw26 = uvw * 26.0;\n    ve", "\n    vec3 uvw_ = uvw - offset;\n    vec3 uvw_abs = abs(uvw_);\n    vec3 uvw_sign = sign(uvw_);\n    vec3 uvw_abs_ = uvw_abs - gridRes;\n    vec3 uvw_abs_sign = sign(uvw_abs_);\n    vec3 uvw_abs_sign_ = uvw_abs_sign * 0.5;\n    vec3 uvw_abs_sign__ = uvw_abs_sign_ * 2.0;\n    vec3 uvw_abs_sign___ = uvw_abs_sign__ * 0.5;\n    vec3 uvw_abs_sign____ = uvw_abs_sign___ * 2.0;\n    vec3 uvw_abs_sign_____ = uvw_abs_sign____ * 0.5;\n    vec3 uvw_abs_sign______ = uvw_abs_sign_____ * 2.0;\n    vec3 uvw_abs_sign_______ = uvw_abs_sign______ * 0.5;\n    vec3 uvw_abs_sign________ = uvw_abs_sign_______ * 2.0;\n    vec3 uvw_abs_sign_________ = uvw_abs_sign________ * 0.5;\n    vec3 uvw_abs_sign__________ = uvw_abs_sign_________ * 2.0;\n    vec3 uvw_abs_sign___________ = uvw_abs_sign__________ * 0.5;\n    vec3 uvw_abs_sign____________ = uvw_abs_sign___________ * 2.0;\n    vec3 uvw_abs_sign_____________ = uvw_abs_sign____________ * 0.5;\n    vec3 uvw_abs_sign______________ = uvw_abs_sign_____________ * 2.0;\n    vec3 uvw_abs_sign", "\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    t = clamp(t, 0.0, 1.0);\n    if (t < 0.16666666666666666) {\n        c.r = 0.0;\n        c.g = 4.0 * t;\n    } else if (t < 0.5) {\n        c.r = 0.0;\n        c.b = 1.0 + 4.0 * (0.5 - t);\n    } else if (t < 0.6666666666666666) {\n        c.r = 4.0 * (t - 0.5);\n        c.b = 0.0;\n    } else if (t < 0.8333333333333334) {\n        c.g = 1.0 + 4.0 * (0.8333333333333334 - t);\n        c.b = 0.0;\n    } else {\n        c.g = 1.0;\n        c.b = 4.0 * (t - 0.8333333333333334);\n    }\n    return c;\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    t = clamp(t, 0.0, 1.0);\n    if (t < 0.16666666666666666) {\n        c.r = 0.0;\n        c.g = 4.0 * t;\n    } else if (t < 0.5) {\n        c.r = 0.0;\n        c.b = 1.0 + 4.0 * (0.5 -", "\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.x+p.y-1.0;\n    float d3 = p.x+p.z-1.0;\n    float d4 = p.y+p.z-1.0;\n    float d5 = p.x-0.5;\n    float d6 = p.y-0.5;\n    float d7 = p.z-0.5;\n    return -min(0.0, max(d1, max(max(d2, max(d3, max(d4, max(d5, max(d6, d7))))), 0.0)));\n}\n\n//Distance from the Edge of Icosahedron\nfloat icosDist(vec3 p) {\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.x+p.y-1.0;\n    float d3 = p.x+p.z-1.0;\n    float d4 = p.y+p.z-1.0;\n    float d5 = p.x-0.5;\n    float d6 = p.y-0.5;\n    float d7 = p.z-0.5;\n    return -min(0.0, max(d1, max(max(d2, max(d3, max(d4, max(d5, max(d6, d7))))), 0.0)));\n}\n\n//Distance from the Edge of Dodecahedron\nfloat dodecDist(vec3 p) {\n    p = abs(p);\n    float d1 = p.x+p.y+p.z-1.0;\n    float d2 = p.x+p.y-1.0;\n    float d3 = p.x+p.z-1.0;\n    float d4 = p.y+p.z-1.0;\n    float d5 = p.x-0.5;\n    float d6", "\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes summer colormap with polynimal 6\nvec3 summer(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes autumn colormap with polynimal 6\nvec3 autumn(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes spring colormap with polynimal 6\nvec3 spring(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b = pow(t, 6.0);\n    return vec3(r, g, b);\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    float r = pow(t, 6.0);\n    float g = pow(t, 6.0);\n    float b", "\n    vec2 tile = floor(uv);\n    vec2 coord = fract(uv);\n    return mix(\n        mix(vec3(0.0), vec3(1.0), coord.x),\n        mix(vec3(0.0), vec3(1.0), coord.y),\n        step(0.5, mod(tile.x + tile.y, 2.0))\n    );\n}\n\n// simple diamond Tiling\nvec3 diamondTile(vec2 uv) {\n    vec2 tile = floor(uv);\n    vec2 coord = fract(uv);\n    return mix(\n        mix(vec3(0.0), vec3(1.0), coord.x),\n        mix(vec3(0.0), vec3(1.0), coord.y),\n        step(0.5, mod(tile.x + tile.y, 2.0))\n    );\n}\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) {\n    vec2 tile = floor(uv);\n    vec2 coord = fract(uv);\n    return mix(\n        mix(vec3(0.0), vec3(1.0), coord.x),\n        mix(vec3(0.0), vec3(1.0), coord.y),\n        step(0.5, mod(tile.x + tile.y, 2.0))\n    );\n}\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) {\n    vec2 tile = floor(uv);\n    vec2 coord = fract(uv);\n    return mix(\n        mix(vec3(0.0), vec3(1.0), coord.x),\n        mix(vec3(0.0), vec3(1.0), coord.y),\n        step(0.5, mod(tile.x + tile.y, 2.0))\n    );\n}\n\n// simple hexagon Tiling\nvec3 hexagonTile(vec2 uv) {\n    vec2 tile = floor(uv);\n    vec2 coord = fract(uv);", "\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = vec2(0.5, 0.5);\n    vec2 d = f - s;\n    vec2 m = vec2(0.5, 0.5);\n    vec2 a = abs(d);\n    float h = max(a.x, a.y);\n    float k = (h == a.x)? 1.0 : 0.0;\n    vec2 g = p + k - m;\n    return vec3(g, h);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile2(vec2 uv) {\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = vec2(0.5, 0.5);\n    vec2 d = f - s;\n    vec2 m = vec2(0.5, 0.5);\n    vec2 a = abs(d);\n    float h = max(a.x, a.y);\n    float k = (h == a.x)? 1.0 : 0.0;\n    vec2 g = p + k - m;\n    return vec3(g, h);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile3(vec2 uv) {\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = vec2(0.5, 0.5);\n    vec2 d = f - s;\n    vec2 m = vec2(0.5, 0.5);\n    vec2 a = abs(d);\n    float h = max(a.x, a.y);\n    float k = (h == a.x)? 1.0 : 0.0;\n    vec2 g = p + k - m;\n    return vec3(g, h);\n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile4", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 pixel = fract(uv * gridRes);\n    vec2 pixelOffset = vec2(0.5) - pixel;\n    vec2 pixelOffset2 = vec2(0.5) + pixel;\n    vec2 pixelOffset3 = vec2(0.5) - pixel;\n    pixelOffset3.x *= -1.0;\n    vec2 pixelOffset4 = vec2(0.5) + pixel;\n    pixelOffset4.x *= -1.0;\n    vec2 pixelOffset5 = vec2(0.5) - pixel;\n    pixelOffset5.y *= -1.0;\n    vec2 pixelOffset6 = vec2(0.5) + pixel;\n    pixelOffset6.y *= -1.0;\n    vec2 pixelOffset7 = vec2(0.5) - pixel;\n    pixelOffset7.x *= -1.0;\n    pixelOffset7.y *= -1.0;\n    vec2 pixelOffset8 = vec2(0.5) + pixel;\n    pixelOffset8.x *= -1.0;\n    pixelOffset8.y *= -1.0;\n    vec2 pixelOffset9 = vec2(0.5) - pixel;\n    pixelOffset9.x *= -1.0;\n    pixelOffset9.y *= -1.0;\n    vec2 pixelOffset10 = vec2(0.5) + pixel;\n    pixelOffset10.x *= -1.0;\n    pixelOffset10.y *= -1.0;\n    vec2 pixelOffset11 = vec2(0.5) - pixel;\n    pixelOffset11.x *= -1.0;\n    pixelOffset11.y *= -1.0;\n    vec2 pixelOffset12 = vec2(0.5) + pixel;\n    pixelOffset12.x *= -1.0;\n    pixelOffset12.y *= -1.0;\n    vec2 pixelOffset13 = vec", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 gridUV = fract(uv * gridRes);\n    vec2 gridCenter = vec2(0.5);\n    vec2 gridCenterUV = fract(uv * gridRes);\n    vec2 gridCenterToUV = gridCenterUV - gridCenter;\n    vec2 gridCenterToUVNormalized = gridCenterToUV / gridRes;\n    vec2 gridCenterToUVNormalizedAbs = abs(gridCenterToUVNormalized);\n    vec2 gridCenterToUVNormalizedAbsMax = max(gridCenterToUVNormalizedAbs.x, gridCenterToUVNormalizedAbs.y);\n    vec2 gridCenterToUVNormalizedAbsMin = min(gridCenterToUVNormalizedAbs.x, gridCenterToUVNormalizedAbs.y);\n    vec2 gridCenterToUVNormalizedAbsMinMax = max(gridCenterToUVNormalizedAbsMin.x, gridCenterToUVNormalizedAbsMin.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMin = min(gridCenterToUVNormalizedAbsMinMax.x, gridCenterToUVNormalizedAbsMinMax.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMinMax = max(gridCenterToUVNormalizedAbsMinMaxMin.x, gridCenterToUVNormalizedAbsMinMaxMin.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMinMaxMin = min(gridCenterToUVNormalizedAbsMinMaxMinMax.x, gridCenterToUVNormalizedAbsMinMaxMinMax.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMinMaxMinMax = max(gridCenterToUVNormalizedAbsMinMaxMinMaxMin.x, gridCenterToUVNormalizedAbsMinMaxMinMaxMin.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMinMaxMinMaxMin = min(gridCenterToUVNormalizedAbsMinMaxMinMaxMinMax.x, gridCenterToUVNormalizedAbsMinMaxMinMaxMinMax.y);\n    vec2 gridCenterToUVNormalizedAbsMinMaxMinMaxMinMaxMinMax = max(gridCenterToUVNormalizedAbsMinMaxMinMaxMinMaxMin.x, grid", "\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time);\n    return smoothstep(len, len + 0.001, wave);\n}\n\nfloat flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float len) {\n    float wave = flowSquareCell(uv, offset, gridRes, time, len);\n    wave += flowSquareCell(uv, offset + vec2(1.0, 0.0), gridRes, time, len);\n    wave += flowSquareCell(uv, offset + vec2(0.0, 1.0), gridRes, time, len);\n    wave += flowSquareCell(uv, offset + vec2(1.0, 1.0), gridRes, time, len);\n    return wave / 4.0;\n}\n\nfloat flowSquare(vec2 uv, float gridRes, float time, float len) {\n    return flowSquare(uv, vec2(0.0), gridRes, time, len);\n}\n\nfloat flowSquare(vec2 uv, float gridRes, float time) {\n    return flowSquare(uv, vec2(0.0), gridRes, time, 0.0);\n}\n\nfloat flowSquare(vec2 uv, float gridRes) {\n    return flowSquare(uv, vec2(0.0), gridRes, 0.0, 0.0);\n}\n\nfloat flowSquare(vec2 uv) {\n    return flowSquare(uv, vec2(0.0), 0.0, 0.0, 0.0);\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len, float amp) {\n    float dist = length(uv - offset);\n    float wave = sin(dist * gridRes - time) * amp;\n    return smoothstep(len, len + 0.001, wave);\n}\n\nfloat flowSquare(vec2 uv, vec2 offset, float gridRes, float time, float", "\n    float waveLen = len;\n    float waveSpeed = 0.001;\n    float waveAmplitude = 0.001;\n    float wavePhase = time * waveSpeed;\n    float waveFreq = 1.0 / waveLen;\n    float wavePhaseOffset = wavePhase * waveFreq;\n    float wavePhaseOffset2 = wavePhaseOffset * 2.0;\n    float wavePhaseOffset3 = wavePhaseOffset * 3.0;\n    float wavePhaseOffset4 = wavePhaseOffset * 4.0;\n    float wavePhaseOffset5 = wavePhaseOffset * 5.0;\n    float wavePhaseOffset6 = wavePhaseOffset * 6.0;\n    float wavePhaseOffset7 = wavePhaseOffset * 7.0;\n    float wavePhaseOffset8 = wavePhaseOffset * 8.0;\n    float wavePhaseOffset9 = wavePhaseOffset * 9.0;\n    float wavePhaseOffset10 = wavePhaseOffset * 10.0;\n    float wavePhaseOffset11 = wavePhaseOffset * 11.0;\n    float wavePhaseOffset12 = wavePhaseOffset * 12.0;\n    float wavePhaseOffset13 = wavePhaseOffset * 13.0;\n    float wavePhaseOffset14 = wavePhaseOffset * 14.0;\n    float wavePhaseOffset15 = wavePhaseOffset * 15.0;\n    float wavePhaseOffset16 = wavePhaseOffset * 16.0;\n    float wavePhaseOffset17 = wavePhaseOffset * 17.0;\n    float wavePhaseOffset18 = wavePhaseOffset * 18.0;\n    float wavePhaseOffset19 = wavePhaseOffset * 19.0;\n    float wavePhaseOffset20 = wavePhaseOffset * 20.0;\n    float wavePhaseOffset21 = wavePhaseOffset * 21.0;\n    float wavePhaseOffset22 = wavePhaseOffset * 22.0;\n    float wavePhaseOffset23 = wave", "\n    vec2 g = vec2( 1.0 );\n    vec2 g2 = g * g;\n    vec2 g3 = g2 * g;\n    vec2 g4 = g3 * g;\n    vec2 g5 = g4 * g;\n    vec2 g6 = g5 * g;\n    vec2 g7 = g6 * g;\n    vec2 g8 = g7 * g;\n    vec2 g9 = g8 * g;\n    vec2 g10 = g9 * g;\n    vec2 g11 = g10 * g;\n    vec2 g12 = g11 * g;\n    vec2 g13 = g12 * g;\n    vec2 g14 = g13 * g;\n    vec2 g15 = g14 * g;\n    vec2 g16 = g15 * g;\n    vec2 g17 = g16 * g;\n    vec2 g18 = g17 * g;\n    vec2 g19 = g18 * g;\n    vec2 g20 = g19 * g;\n    vec2 g21 = g20 * g;\n    vec2 g22 = g21 * g;\n    vec2 g23 = g22 * g;\n    vec2 g24 = g23 * g;\n    vec2 g25 = g24 * g;\n    vec2 g26 = g25 * g;\n    vec2 g27 = g26 * g;\n    vec2 g28 = g27 * g;\n    vec2 g29 = g28 * g;\n    vec2 g30 = g29 * g;\n    vec2 g31 = g30 * g;\n    vec2 g32 = g31 * g;\n    vec2 g33 = g32 * g;\n    vec2 g34 = g33 * g;\n    vec2 g35 = g34 * g;\n    vec", "\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    p.xy -= vec2(clamp(p.x-r*k.z, -2.0*r*k.z, 2.0*r*k.z), r);\n    return -length(p.xy)*sign(p.y) - r*sign(p.x);\n}\n\nfloat hexagon_sdf(vec2 p, float r) {\n    return hexagon(p, r);\n}\n\nfloat hexagon_sdf_smooth(vec2 p, float r) {\n    return smoothstep(0.0, 1.0, hexagon(p, r));\n}\n\nfloat hexagon_sdf_smooth_round(vec2 p, float r, float roundness) {\n    return smoothstep(0.0, 1.0, hexagon(p, r)) - roundness;\n}\n\nfloat hexagon_sdf_smooth_round_smooth(vec2 p, float r, float roundness) {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, hexagon(p, r)) - roundness);\n}\n\nfloat hexagon_sdf_smooth_round_smooth_round(vec2 p, float r, float roundness, float roundness2) {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, hexagon(p, r)) - roundness) - roundness2);\n}\n\nfloat hexagon_sdf_smooth_round_smooth_round_smooth(vec2 p, float r, float roundness, float roundness2, float roundness3) {\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, smoothstep(0.0, 1.", "\n    p = abs(p);\n    vec2 o = vec2(-1.0, 0.0);\n    p = (p.x > p.y)? p.yx : p.xy;\n    p.x -= 0.5 * p.y;\n    if (p.x > p.y) {\n        p = p.yx;\n        o = vec2(0.0, -1.0);\n    }\n    p = (p.x > p.y)? p.yx : p.xy;\n    p.x -= 0.5 * p.y;\n    if (p.x > p.y) {\n        p = p.yx;\n        o = vec2(1.0, 0.0);\n    }\n    p = (p.x > p.y)? p.yx : p.xy;\n    p.x -= 0.5 * p.y;\n    if (p.x > p.y) {\n        p = p.yx;\n        o = vec2(0.0, 1.0);\n    }\n    return o;\n}\n\nvoid main() {\n    vec2 p = gl_FragCoord.xy;\n    vec2 t = hextile(p);\n    gl_FragColor = vec4(t, 0.0, 1.0);\n}\n", "\n    return sin(x*1.0)*0.5+0.5;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    // Four corners in 2D of a tile\n    float a = fun( i.x+i.y );\n    float b = fun( i.x+1.0+i.y );\n    float c = fun( i.x+i.y+1.0 );\n    float d = fun( i.x+1.0+i.y+1.0 );\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n    // return vec2( mix( mix( a, b, smoothstep(0.0,1.0,f.x) ),\n    //                   mix( c, d, smoothstep(0.0,1.0,f.x) ),\n    //                   smoothstep(0.0,1.0,f.y) ) );\n\n    // Same code, with the clamps in smoothstep and common subexpressions\n    // optimized away.\n    return mix(a, b, f.x) + (c - a) * f.y * (1.0 - f.x) + (d - b) * f.x * f.y;\n}\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm2( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.", " return pow(t, vec3(2.2)); }\nvec3 linear(vec3 t) { return pow(t, vec3(1.0/2.2)); }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb_smooth(vec3 c)\n{\n    vec3 rgb = hsv2rgb(c);\n    return rgb;\n}\n\nvec3 rgb2hsv_smooth(vec3 c)\n{\n    vec3 hsv = rgb2hsv(c);\n    return hsv;\n}\n\nvec3 hsv2rgb_hard(vec3 c)\n{\n    vec3 rgb = hsv2rgb(c);\n    return", "\n    return 0.5 + 0.5 * cos(6.28318 * p.x) * cos(6.28318 * p.y);\n}\n\n// Classic truchet pattern\nfloat df1(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318 * p.x) * sin(6.28318 * p.y);\n}\n\n// Classic truchet pattern\nfloat df2(vec2 p) {\n    return 0.5 + 0.5 * sin(6.28318 * p.x) * cos(6.28318 * p.y);\n}\n\n// Classic truchet pattern\nfloat df3(vec2 p) {\n    return 0.5 + 0.5 * sin(6.28318 * p.x) * sin(6.28318 * p.y);\n}\n\n// Classic truchet pattern\nfloat df4(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318 * p.x) * cos(6.28318 * p.y) * sin(6.28318 * p.x);\n}\n\n// Classic truchet pattern\nfloat df5(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318 * p.x) * cos(6.28318 * p.y) * cos(6.28318 * p.x);\n}\n\n// Classic truchet pattern\nfloat df6(vec2 p) {\n    return 0.5 + 0.5 * sin(6.28318 * p.x) * sin(6.28318 * p.y) * cos(6.28318 * p.x);\n}\n\n// Classic truchet pattern\nfloat df7(vec2 p) {\n    return 0.5 + 0.5 * sin(6.28318 * p.x) * sin(6.28318 * p.y", "\n    return 0.5 + 0.5 * cos(6.28318530718 * p.x);\n}\n\nfloat df2(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * p.y);\n}\n\nfloat df3(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x + p.y));\n}\n\nfloat df4(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x - p.y));\n}\n\nfloat df5(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x + p.y * 2.0));\n}\n\nfloat df6(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x - p.y * 2.0));\n}\n\nfloat df7(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x + p.y * 3.0));\n}\n\nfloat df8(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x - p.y * 3.0));\n}\n\nfloat df9(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x + p.y * 4.0));\n}\n\nfloat df10(vec2 p) {\n    return 0.5 + 0.5 * cos(6.28318530718 * (p.x - p.y * 4.0));\n}\n\n", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0 * clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1 * clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2 * clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(\n        vec2( dot( pq0, pq0 ), s * (v0.x*e0.y - v0.y*e0.x) ),\n        vec2( dot( pq1, pq1 ), s * (v1.x*e1.y - v1.y*e1.x) )\n    ),\n        vec2( dot( pq2, pq2 ), s * (v2.x*e2.y - v2.y*e2.x) )\n    );\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// signed distance to a 2D rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// signed distance to a 2D ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < 0.0) t = -b + h;\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\nfloat sphere(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < 0.0) t = -b + h;\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\nfloat sphere_d(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    float t = -b - h;\n    if (t < 0.0) t = -b + h;\n    if (t < 0.0) return -1.0;\n    return t;\n}\n\nfloat sphere_d(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, r", "\n    return abs(p.x) - w + r;\n}\n\nfloat roundedY(vec2 p, float w, float r) {\n    return abs(p.y) - w + r;\n}\n\nfloat roundedBox(vec2 p, vec2 b, float r) {\n    return max(roundedX(p, b.x, r), roundedY(p, b.y, r));\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r) {\n    return roundedBox(p, vec2(w, h), r);\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r, float r2) {\n    return max(roundedBox(p, w, h, r), roundedBox(p, w, h, r2));\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r, float r2, float r3) {\n    return max(roundedBox(p, w, h, r), max(roundedBox(p, w, h, r2), roundedBox(p, w, h, r3)));\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r, float r2, float r3, float r4) {\n    return max(roundedBox(p, w, h, r), max(roundedBox(p, w, h, r2), max(roundedBox(p, w, h, r3), roundedBox(p, w, h, r4))));\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r, float r2, float r3, float r4, float r5) {\n    return max(roundedBox(p, w, h, r), max(roundedBox(p, w, h, r2), max(roundedBox(p, w, h, r3), max(roundedBox(p, w, h, r4), roundedBox(p, w, h, r5)))));\n}\n\nfloat roundedBox(vec2 p, float w, float h, float r, float r2, float r3, float r4, float r5, float r6", "\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    float f = float(p.x+p.y);\n    return max(dot(p,vec2(1.0,k)),p.x*k) - f*k;\n}\n\n// k in (-1,1) range\nfloat sdHyperbolicCross( in vec2 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    float f = float(p.x+p.y);\n    return max(dot(p,vec2(1.0,k)),p.x*k) - f*k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    float f = float(p.x+p.y+p.z);\n    return max(dot(p,vec3(1.0,k,k)),p.x*k) - f*k;\n}\n\n// k in (-1,1) range\nfloat sdHyperbolicCross( in vec3 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    float f = float(p.x+p.y+p.z);\n    return max(dot(p,vec3(1.0,k,k)),p.x*k) - f*k;\n}\n\n// k in (0,1) range\nfloat sdHyperbolicCross( in vec4 p, float k )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    p.w = abs(p.w);\n    float f = float(p.x+p.y+p.z+p.w);\n", "\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOY( in vec2 p )\n{\n    p.y = abs(p.y);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOZ( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOXY( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOYX( in vec2 p )\n{\n    p.y = abs(p.y);\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOZY( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOZX( in vec2 p )\n{\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOYZ( in vec2 p )\n{\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    return length(p) - 1.0;\n}\n\n// distance to y=1/x\nfloat sdOOXYZ( in vec2 p )\n{\n    p.x = abs(p.x);\n    p.y = abs", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n    return -pmin(-a, -b, k);\n}\n\nfloat pmin(vec2 a, vec2 b, float k) {\n    return vec2(pmin(a.x, b.x, k), pmin(a.y, b.y, k));\n}\n\nfloat pmax(vec2 a, vec2 b, float k) {\n    return vec2(pmax(a.x, b.x, k), pmax(a.y, b.y, k));\n}\n\nfloat pmin(vec3 a, vec3 b, float k) {\n    return min(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z)) - k;\n}\n\nfloat pmax(vec3 a, vec3 b, float k) {\n    return max(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z)) + k;\n}\n\nfloat pmin(vec4 a, vec4 b, float k) {\n    return min(min(min(a.x, b.x), min(a.y, b.y)), min(a.z, b.z), min(a.w, b.w)) - k;\n}\n\nfloat pmax(vec4 a, vec4 b, float k) {\n    return max(max(max(a.x, b.x), max(a.y, b.y)), max(a.z, b.z), max(a.w, b.w)) + k;\n}\n\nfloat pmin(float a, float b, float c, float k) {\n    return pmin(pmin(a, b, k), c, k);\n}\n\nfloat pmax(float a, float b, float c, float", "\n    return mix(a, -a, k);\n}\n\nvec2 pabs(vec2 a, float k) {\n    return mix(a, -a, k);\n}\n\nvec3 pabs(vec3 a, float k) {\n    return mix(a, -a, k);\n}\n\nvec4 pabs(vec4 a, float k) {\n    return mix(a, -a, k);\n}\n\nvec2 pabs(vec2 a, vec2 k) {\n    return mix(a, -a, k);\n}\n\nvec3 pabs(vec3 a, vec3 k) {\n    return mix(a, -a, k);\n}\n\nvec4 pabs(vec4 a, vec4 k) {\n    return mix(a, -a, k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat psign(float a, float k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec2 psign(vec2 a, float k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec3 psign(vec3 a, float k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec4 psign(vec4 a, float k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec2 psign(vec2 a, vec2 k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec3 psign(vec3 a, vec3 k) {\n    return mix(abs(a), -abs(a), k);\n}\n\nvec4 psign(vec4 a, vec4 k) {\n    return mix(abs(a), -abs(a), k);\n}\n\n// License: CC0, author: M\u00e5rten R\u00e5nge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float", "\n    p.x = abs(p.x);\n    float d1 = length(p - vec2(0.0, p.y * 0.5)) - 0.25;\n    float k = (1.0 - 0.25 * p.y);\n    float d2 = (p.x - 1.0) * k;\n    d2 = clamp(d2, 0.0, 1.0);\n    return length(vec2(d1, d2)) * sign(d1);\n}\n\nfloat heart2(vec2 p) {\n    p.x = abs(p.x);\n    float d1 = length(p - vec2(0.0, p.y * 0.5)) - 0.25;\n    float k = (1.0 - 0.25 * p.y);\n    float d2 = (p.x - 1.0) * k;\n    d2 = clamp(d2, 0.0, 1.0);\n    return length(vec2(d1, d2)) * sign(d1);\n}\n\nfloat heart3(vec2 p) {\n    p.x = abs(p.x);\n    float d1 = length(p - vec2(0.0, p.y * 0.5)) - 0.25;\n    float k = (1.0 - 0.25 * p.y);\n    float d2 = (p.x - 1.0) * k;\n    d2 = clamp(d2, 0.0, 1.0);\n    return length(vec2(d1, d2)) * sign(d1);\n}\n\nfloat heart4(vec2 p) {\n    p.x = abs(p.x);\n    float d1 = length(p - vec2(0.0, p.y * 0.5)) - 0.25;\n    float k = (1.0 - 0.25 * p.y);\n    float d2 = (p.x - 1.0) * k;\n    d2 = clamp(d2", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash14(vec4 p4) {\n    p4 = fract(p4 * vec4(.1031,.1030,.0973,.1099));\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.x + p4.y) * p4.z);\n}\n\nfloat hash12(vec3 p3) {\n    vec4 p4 = vec4(p3, 1.0);\n    return hash14(p4);\n}\n\nfloat hash13(vec2 p2) {\n    vec3 p3 = vec3(p2, 1.0);\n    return hash13(p3);\n}\n\nfloat hash14(vec2 p2) {\n    vec4 p4 = vec4(p2.xy, 1.0, 1.0);\n    return hash14(p4);\n}\n\nfloat hash12(float p) {\n    return hash12(vec2(p));\n}\n\nfloat hash13(float p) {\n    return hash13(vec3(p));\n}\n\nfloat hash14(float p) {\n    return hash14(vec4(p));\n}\n\nfloat hash12(vec4 p4) {\n    return hash14(p4);\n}\n\nfloat hash13(vec2 p2) {", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = pos - A;\n    float kk = 1.0 / dot(a, a);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a * d) - dot(b, d));\n    float kz = kk * (1.0 - dot(b, b) +  dot(b, d) * kx);\n    float res = dot(d, d) - kz;\n    float w = sqrt(kx + 1.0);\n    vec2 v = vec2(dot(w, d) + kx, w * (dot(w, a) - ky));\n    return vec3(res, v);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec3 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C, in vec2 D )\n{\n    vec2 a = C - A;\n    vec2 b = A - 3.0 * B + 3.0 * C - D;\n    vec2 c = 3.0 * (B - 2.0 * C + D);\n    vec2 d = a * 2.0;\n    vec2 e = pos - A;\n    float kk = 1.0 / dot(a, a);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a * e) - dot(b, e));\n    float kz = kk * (1.0 - dot(b, b) +  dot(b, e) * kx);\n    float res = dot(e,", "\n    vec2 p = pos;\n    float x = p.x;\n    float y = p.y;\n    float z = x*x - y*y;\n    float d = length(vec2(x,y));\n    float dz = 2.0*vec2(x,y);\n    float dz2 = dz*d;\n    float dz3 = dz2*d;\n    float dz4 = dz2*dz;\n    float dz5 = dz4*d;\n    float dz6 = dz4*dz;\n    float dz7 = dz6*d;\n    float dz8 = dz6*dz;\n    float dz9 = dz8*d;\n    float dz10 = dz8*dz;\n    float dz11 = dz10*d;\n    float dz12 = dz10*dz;\n    float dz13 = dz12*d;\n    float dz14 = dz12*dz;\n    float dz15 = dz14*d;\n    float dz16 = dz14*dz;\n    float dz17 = dz16*d;\n    float dz18 = dz16*dz;\n    float dz19 = dz18*d;\n    float dz20 = dz18*dz;\n    float dz21 = dz20*d;\n    float dz22 = dz20*dz;\n    float dz23 = dz22*d;\n    float dz24 = dz22*dz;\n    float dz25 = dz24*d;\n    float dz26 = dz24*dz;\n    float dz27 = dz26*d;\n    float dz28 = dz26*dz;\n    float dz29 = dz28*d;\n    float dz30 = dz28*dz;\n    float dz31 = dz30*d;\n    float dz32 = d", "\n    vec2 p = pos;\n    float x = p.x;\n    float y = p.y;\n    float z = x*x*k + y*y;\n    float d = length(p) - 1.0;\n    float dy = dot(p, p.yx*k);\n    float dz = dot(p, vec2(1.0, 1.0)*k);\n    return vec3(d, dy, dz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec3 pos, in float k )\n{\n    vec2 p = pos.xy;\n    float x = p.x;\n    float y = p.y;\n    float z = x*x*k + y*y;\n    float d = length(p) - 1.0;\n    float dy = dot(p, p.yx*k);\n    float dz = dot(p, vec2(1.0, 1.0)*k);\n    return vec3(d, dy, dz);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdParabola( in vec4 pos, in float k )\n{\n    vec2 p = pos.xy;\n    float x = p.x;\n    float y = p.y;\n    float z = x*x*k + y*y;\n    float d = length(p) - 1.0;\n    float dy = dot(p, p.yx*k);\n    float dz = dot(p, vec2(1.0, 1.0)*k);\n    return vec3(d, dy, d", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float b = sqrt(p.x*p.x + p.y*p.y);\n    float c = sqrt(b*b + d*d - 2.0*b*d*cos(a));\n    float s = sign(d);\n    float h = sqrt(r*r - d*d);\n    float rp = sqrt(r*r - h*h);\n    float t = (rp - ra) / (rb - ra);\n    float u = (rp + ra + s*d) / (rb + ra);\n    float v = (rp - ra - s*d) / (rb - ra);\n    float w = (rp + ra - s*d) / (rb + ra);\n    float x = (rp - ra - s*d) / (rb - ra);\n    float y = (rp + ra + s*d) / (rb + ra);\n    float z = (rp - ra + s*d) / (rb - ra);\n    float q = (rp + ra + s*d) / (rb + ra);\n    float f = (rp - ra + s*d) / (rb - ra);\n    float g = (rp + ra - s*d) / (rb + ra);\n    float hh = (rp - ra - s*d) / (rb - ra);\n    float i = (rp + ra - s*d) / (rb + ra);\n    float j = (rp - ra - s*d) / (rb - ra);\n    float k = (rp + ra + s*d) / (rb + ra);\n    float l = (rp - ra + s*d) / (rb - ra);\n    float m = (rp + ra - s*d) / (rb + ra);\n    float n = (rp - ra + s*d) / (rb - ra);\n    float o = (rp + ra + s*d) / (rb + ra);\n    float p = (rp - ra + s*d) / (rb - ra);\n    float qq = (rp + ra + s*d)", "\n    v = v * 1664525u;\n    v = ((v << 17u) | (v >> 15u)) * 1664525u;\n    v = ((v << 17u) | (v >> 15u)) * 1664525u;\n    return v;\n}\n\nfloat Pcg2(float v)\n{\n    v = v * 1664525.0f;\n    v = ((v << 17u) | (v >> 15u)) * 1664525.0f;\n    v = ((v << 17u) | (v >> 15u)) * 1664525.0f;\n    return v;\n}\n\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg3(ivec2 v)\n{\n    v = v * 1664525u;\n    v = ((v << 17u) | (v >> 15u)) * 1664525u;\n    v = ((v << 17u) | (v >> 15u)) * 1664525u;\n    return v;\n}\n\nfloat Pcg3(float v)\n{\n    v = v * 1664525.0f;\n    v = ((v << 17u) | (v >> 15u)) * 1664525.0f;\n    v = ((v << 17u) | (v >> 15u)) * 1664525.0f;\n    return v;\n}\n\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg4(ivec2 v)\n{\n    v = v * 1664525u;\n    v = ((v << 17u) | (v >> 15u)) * 1664525u;\n    v", "\n    v = v * 1664525u;\n    v = ((v >> uvec3(16, 8, 0)) ^ v) * 1013904223u;\n    v = ((v >> uvec3(16, 8, 0)) ^ v) * 1013904223u;\n    return v;\n}\n\nfloat Pcg3f(ivec3 v)\n{\n    v = v * 1664525u;\n    v = ((v >> uvec3(16, 8, 0)) ^ v) * 1013904223u;\n    v = ((v >> uvec3(16, 8, 0)) ^ v) * 1013904223u;\n    return float(v.x ^ v.y ^ v.z) / 4294967296.0;\n}\n\n// https://www.shadertoy.com/view/Xlf3zl\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/Xlf3zl\nfloat hash12(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/Xlf3zl\nfloat hash12(vec4 p4)\n{\n    p4 = fract(p4 * vec4(.1031,.103", "\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b));\n    float kz = kk * dot(d, a);\n    float res = 0.0;\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n    if (h >= 0.0) {\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        res = dot(d + (c + b * t) * t, d);\n    } else {\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.7320508075688772935274463415059;\n        vec3 t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        res = min(min(dot(d + (c + b * t.x) * t.x, d), dot(d + (c + b * t.", "\n    return (p.x - a.x) * (b.y - a.y) - (b.x - a.x) * (p.y - a.y);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    return winding_sign(p, a, b) + winding_sign(p, b, c) + winding_sign(p, c, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return winding_sign(p, a, b, c) + winding_sign(p, c, d, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e) {\n    return winding_sign(p, a, b, c, d) + winding_sign(p, d, e, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f) {\n    return winding_sign(p, a, b, c, d, e) + winding_sign(p, e, f, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g) {\n    return winding_sign(p, a, b, c, d, e, f) + winding_sign(p, f, g, a);\n}\n\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h) {\n    return winding_sign(p, a, b, c, d,", "\n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 m = (p + q) * 0.5;\n    vec3 d = q - p;\n    vec3 a = abs(d);\n    float da = max(a.x, max(a.y, a.z));\n    float da2 = da * da;\n    float da3 = da2 * da;\n    float da4 = da3 * da;\n    float da5 = da4 * da;\n    float da6 = da5 * da;\n    float da7 = da6 * da;\n    float da8 = da7 * da;\n    float da9 = da8 * da;\n    float da10 = da9 * da;\n    float da11 = da10 * da;\n    float da12 = da11 * da;\n    float da13 = da12 * da;\n    float da14 = da13 * da;\n    float da15 = da14 * da;\n    float da16 = da15 * da;\n    float da17 = da16 * da;\n    float da18 = da17 * da;\n    float da19 = da18 * da;\n    float da20 = da19 * da;\n    float da21 = da20 * da;\n    float da22 = da21 * da;\n    float da23 = da22 * da;\n    float da24 = da23 * da;\n    float da25 = da24 * da;\n    float da26 = da25 * da;\n    float da27 = da26 * da;\n    float da28 = da27 * da;\n    float da29 = da28 * da;\n    float da30 = da29 * da;\n    float da31 = da30 * da;\n    float da32 = da31 * da;\n    float da33 = da32 * da;\n    float da34 = da33 * da;\n    float da35 = da34 * da;\n    float da36", "\n    int a_n = a & 0x7fffff;\n    int a_s = a >> 23;\n    int b_n = int(b * 1048576.0);\n    int b_s = int(b * 1048576.0) >> 23;\n    int x_n = int(x * 1048576.0);\n    int x_s = int(x * 1048576.0) >> 23;\n    int r_n = a_n * b_n;\n    int r_s = a_s + b_s - 23;\n    int r_m = r_n >> 24;\n    r_n &= 0x7fffff;\n    r_n += x_n;\n    r_s += x_s;\n    if (r_n & 0x800000) {\n        r_n -= 0x1000000;\n        r_s--;\n    }\n    r_n += r_m;\n    r_s += r_m;\n    if (r_n & 0x800000) {\n        r_n -= 0x1000000;\n        r_s--;\n    }\n    ret_n = r_n;\n    return float(r_n) / 1048576.0 * float(r_s - 127);\n}\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32_2 (out int ret_n, int a, float b, float x) {\n    int a_n = a & 0x7fffff;\n    int a_s = a >> 23;\n    int b_n = int(", "\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//.x = f(p)\n//.yz = \u2207f(p)\n//.w = |\u2207f(p)|\nvec4 sdgSMax( in vec3 a, in vec3 b, in float k )\n{\n    vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec4( mix( b, a, h ) + k*h*(1.0-h), abs(h) );\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\n//.w = |\u2207f(p)|\nvec4 sdgSMin( in vec4 a, in vec4 b, in float k )\n{\n    vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\n//.w = |\u2207f(p)|\nvec4 sdgSMax( in vec4 a, in vec4 b, in float k )\n{\n    vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\n//.x = f(p)\n//.yzw = \u2207f(p)\n//.w = |\u2207f(p)|\nvec4 sdgSMin( in vec4 a, in vec4 b, in float k, in float k2 )\n{\n    vec4 h = clamp( ", "\n    return (p.x*p.x)/(ab.x*ab.x) - (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 cd){\n    return (p.x*p.x)/(ab.x*ab.x) - (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef){\n    return (p.x*p.x)/(ab.x*ab.x) - (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef, in vec2 gh){\n    return (p.x*p.x)/(ab.x*ab.x) - (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef, in vec2 gh, in vec2 ij){\n    return (p.x*p.x)/(ab.x*ab.x) - (p.y*p.y)/(ab.y*ab.y) - 1.0;\n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab, in vec2 cd, in vec2 ef, in vec2 gh,", "\n    return a+b;\n}\n\nfloat sub_ploss(in float a, in float b){\n    return a-b;\n}\n\nfloat mul_ploss(in float a, in float b){\n    return a*b;\n}\n\nfloat div_ploss(in float a, in float b){\n    return a/b;\n}\n\nfloat mod_ploss(in float a, in float b){\n    return a%b;\n}\n\nfloat pow_ploss(in float a, in float b){\n    return pow(a,b);\n}\n\nfloat sqrt_ploss(in float a){\n    return sqrt(a);\n}\n\nfloat log_ploss(in float a){\n    return log(a);\n}\n\nfloat exp_ploss(in float a){\n    return exp(a);\n}\n\nfloat sin_ploss(in float a){\n    return sin(a);\n}\n\nfloat cos_ploss(in float a){\n    return cos(a);\n}\n\nfloat tan_ploss(in float a){\n    return tan(a);\n}\n\nfloat asin_ploss(in float a){\n    return asin(a);\n}\n\nfloat acos_ploss(in float a){\n    return acos(a);\n}\n\nfloat atan_ploss(in float a){\n    return atan(a);\n}\n\nfloat sinh_ploss(in float a){\n    return sinh(a);\n}\n\nfloat cosh_ploss(in float a){\n    return cosh(a);\n}\n\nfloat tanh_ploss(in float a){\n    return tanh(a);\n}\n\nfloat asinh_ploss(in float a){\n    return asinh(a);\n}\n\nfloat acosh_ploss(in float a){\n    return acosh(a);\n}\n\nfloat atanh_ploss(in float a){\n    return atanh(a);\n}\n\nfloat floor_ploss(in float a){\n    return floor(a);\n}\n\nfloat ceil_ploss(in float a){\n   ", "\n    vec2 q = p - ab;\n    float d = dot(q,q);\n    float r = ab.x*ab.x + ab.y*ab.y;\n    float b = d - r;\n    float c = d*r - s1*s1*d;\n    float h = b*b - 4.0*c;\n    if( h<0.0 ) return vec2(0.0);\n    h = sqrt(h);\n    float qq = -0.5*(b + h);\n    float t1 = s1/qq;\n    float t2 = s2/qq;\n    float tmin = min(t1,t2);\n    float tmax = max(t1,t2);\n    if( tmin>0.0 ) return vec2(tmin,tmax);\n    return vec2(tmax,tmin);\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1 )\n{\n    vec2 q = p - ab;\n    float d = dot(q,q);\n    float r = ab.x*ab.x + ab.y*ab.y;\n    float b = d - r;\n    float c = d*r - s1*s1*d;\n    float h = b*b - 4.0*c;\n    if( h<0.0 ) return vec2(0.0);\n    h = sqrt(h);\n    float qq = -0.5*(b + h);\n    float t1 = s1/qq;\n    float t2 = s1/qq;\n    float tmin = min(t1,t2);\n    float tmax = max(t1,t2);\n    if( tmin>0.0 ) return vec2(tmin,tmax);\n    return vec2(tmax,tmin);\n}\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab )\n{\n    vec2 q = p - ab;", "\n    vec3 pa = p - a, ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n\n    float x = (paba - ra * baba);\n    float y = (paba + ra * baba);\n    float x2 = x * x;\n    float y2 = y * y;\n    float d2 = (ra * ra - rb * rb) * baba * baba;\n\n    if (d2 < x2) return vec4(-1.0, 0.0, 0.0, 0.0);\n    if (d2 < y2) return vec4( sqrt(d2), -paba + ra * sqrt(y2 - d2), pa, 1.0);\n\n    return vec4(length(pa - ba * clamp(dot(pa, ba) / baba, 0.0, 1.0)), pa - ba * clamp(dot(pa, ba) / baba, 0.0, 1.0), pa, 1.0);\n}\n\n//.x   distance to the cone\n//.yzw closest point\nvec4 sdcCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float h)\n{\n    vec3 pa = p - a, ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n\n    float x = (paba - ra * baba);\n    float y = (paba + ra * baba);\n    float x2 = x * x;\n    float y2 = y * y;\n    float d2 = (ra * ra - rb * rb) * baba * baba;\n\n    if (d2 < x2) return vec4(-1.0, 0.0, 0.0, 0.0);\n    if (d2 < y2) return vec4( sqrt(d2), -paba + ra * sqrt(y2 - d2), pa, 1.0);\n", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 c, float r )\n{\n    return length(p.xz-c.xy)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdConeSection( in vec3 p, in float h, in float r1, float r2 )\n{\n    float d1 = -p.z-h;\n    float q = p.y*r1/r2-p.x*r1;\n    float d2 = sign(q)*max(dot(vec2(q,-r1),p.yx),q*sqrt(1.0+r1*r1/r2));\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb", "\n    return length(p-cen) - rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - c.xy;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( in vec3 p, in float", "\n    vec3 normal = vec3(0.0);\n    if (showSurface)\n    {\n        normal = normalize(vec3(\n            sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z)) - sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z)),\n            sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z)) - sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z)),\n            sceneSDF(vec3(pos.x, pos.y, pos.z  + EPSILON)) - sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON))\n        ));\n    }\n    else\n    {\n        normal = normalize(vec3(\n            sceneSDF(vec3(samplePoint.x + EPSILON, samplePoint.y, samplePoint.z)) - sceneSDF(vec3(samplePoint.x - EPSILON, samplePoint.y, samplePoint.z)),\n            sceneSDF(vec3(samplePoint.x, samplePoint.y + EPSILON, samplePoint.z)) - sceneSDF(vec3(samplePoint.x, samplePoint.y - EPSILON, samplePoint.z)),\n            sceneSDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z  + EPSILON)) - sceneSDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z - EPSILON))\n        ));\n    }\n    return normal;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface )\n{\n    return calcNormal(pos, showSurface, pos);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    return calcNormal(pos, true, pos);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(", "\n    float tmin = 0.0;\n    float tmax = 100.0;\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( samplePoint + rd*t );\n        if( h<0.0001 )\n            return 0.0;\n        res = min( res, 8.0*h/t );\n        t += h;\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcShadow( vec3 ro, vec3 rd, in bool showSurface, vec3 samplePoint )\n{\n    float tmin = 0.0;\n    float tmax = 100.0;\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( samplePoint + rd*t );\n        if( h<0.0001 )\n            return 0.0;\n        res = min( res, 8.0*h/t );\n        t += h;\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;", "\n    vec2 q = vec2( p.x*rb/ra, p.y );\n    vec2 w = vec2( ra, he );\n    vec2 d = abs(q)-w;\n    float d1 = max(d.x,d.y);\n    float d2 = min(max(d.x,d.y),0.0);\n    vec2 v = vec2( d1, length(max(d,0.0)) );\n    ocl = q - w*clamp( dot(q,w)/dot(w,w), 0.0, 1.0 );\n    return vec3( v.x, v.y, v.x*v.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec2 p, in float ra, float rb, float he )\n{\n    vec2 ocl;\n    return sdgTrapezoid( p, ra, rb, he, ocl );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec3 p, in float ra, float rb, float he )\n{\n    vec2 ocl;\n    return sdgTrapezoid( p.xy, ra, rb, he, ocl );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgTrapezoid( in vec3 p, in float", "\n  vec2 q = vec2(length(p.xz)-ra,p.y);\n  return vec4(length(q)-rb,vec3(0.0),0.0);\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc )\n{\n  vec3 q = vec3(p.x,p.z,p.y);\n  vec3 d = normalize(q);\n  q -= clamp( d*ra, vec3(-ra), vec3(ra) );\n  return vec4( length(q-d*ra)-rb, vec3(0.0), 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd )\n{\n  vec4 q = vec4(p.x,p.y,p.z,p.y);\n  vec4 d = normalize(q);\n  q -= clamp( d*ra, vec4(-ra), vec4(ra) );\n  return vec4( length(q-d*ra)-rb, vec3(0.0), 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb, float rc, float rd, float re )\n{\n  vec4 q = vec4(p.x,p.y,p.z,p.y);\n  vec4 d = normalize(q);\n  q -= clamp( d*ra, vec4(-ra), vec4(ra) );\n  return vec4( length(q-d*ra)-rb, vec3(0.0), 0.0 );\n}\n\n//where is major radius and minor radius?\n//ra is major and rb is", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float r2 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r,r2,h);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float r2, float r3 )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r,r2,h) - r3;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float r, float r2, float r3, float r4 )\n{\n    vec2 pa = p-a, ba = b", " return dot(v, v); }\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot2(ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(in vec3 p, in vec3 b, in float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(in vec3 p, in vec3 b, in float r, in float smoothness) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(in vec3 p, in vec3 b, in float r, in float smoothness, in float smoothness2) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n// Rounded box https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(in vec3 p, in vec3 b, in float r, in float smoothness, in float smoothness2, in float smoothness3) {\n  vec3 q = abs(p) - b;\n  return length(max(q", "\n    vec2 t = clamp( p, minCorner, maxCorner ) - p;\n    return dot( t, t );\n}\n\n// Essentially the box from iq\nfloat AABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner ) \n{\n    vec2 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t );\n}\n\n// Essentially the box from iq\nfloat AABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner ) \n{\n    vec3 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t );\n}\n\n// Essentially the box from iq\nfloat AABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner ) \n{\n    vec4 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t );\n}\n\n// Essentially the box from iq\nfloat AABB( in vec2 p, in vec2 minCorner, in vec2 maxCorner, in float thickness ) \n{\n    vec2 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t ) - thickness;\n}\n\n// Essentially the box from iq\nfloat AABB( in vec3 p, in vec3 minCorner, in vec3 maxCorner, in float thickness ) \n{\n    vec3 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t ) - thickness;\n}\n\n// Essentially the box from iq\nfloat AABB( in vec4 p, in vec4 minCorner, in vec4 maxCorner, in float thickness ) \n{\n    vec4 t = clamp( p, minCorner, maxCorner ) - p;\n    return length( t ) - thickness;\n}\n\n// Essentially the box from iq\nfloat AABB( in vec", "\n    vec3 color = vec3(0.0);\n\n    // Water color\n    color = vec3(0.0, 0.0, 0.5);\n\n    // Water waves\n    float wave = sin(uv.x * 10.0 + time * 1.0) * 0.1;\n    color += wave;\n\n    // Water reflection\n    float refl = sin(uv.x * 10.0 + time * 1.0) * 0.1;\n    color += refl;\n\n    return color;\n}\n\n// Procedural texture generation for the grass\nvec3 grass(vec2 uv, vec3 cdir)\n{\n    vec3 color = vec3(0.0);\n\n    // Grass color\n    color = vec3(0.0, 0.5, 0.0);\n\n    // Grass pattern\n    float pattern = sin(uv.x * 10.0 + time * 1.0) * 0.1;\n    color += pattern;\n\n    return color;\n}\n\n// Procedural texture generation for the sand\nvec3 sand(vec2 uv, vec3 cdir)\n{\n    vec3 color = vec3(0.0);\n\n    // Sand color\n    color = vec3(0.5, 0.5, 0.0);\n\n    // Sand pattern\n    float pattern = sin(uv.x * 10.0 + time * 1.0) * 0.1;\n    color += pattern;\n\n    return color;\n}\n\n// Procedural texture generation for the snow\nvec3 snow(vec2 uv, vec3 cdir)\n{\n    vec3 color = vec3(0.0);\n\n    // Snow color\n    color = vec3(0.5, 0.5, 0.5);\n\n    // Snow pattern\n    float pattern = sin(uv.x * 10.0 + time * 1.0) * 0.1;\n    color += pattern;\n\n    return color;\n}\n\n// Procedural texture", "\n    vec3 ray = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    ray.x *= aspect;\n    ray.y *= -1.0;\n    ray.z *= -1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray_persp(vec2 uv)\n{\n    vec3 ray = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    ray.x *= aspect;\n    ray.y *= -1.0;\n    ray.z *= -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray_persp_fov(vec2 uv)\n{\n    vec3 ray = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    ray.x *= aspect;\n    ray.y *= -1.0;\n    ray.z *= -1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray_persp_fov_fov(vec2 uv)\n{\n    vec3 ray = vec3(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0);\n    ray.x *= aspect;\n    ray.y *= -1.0;\n    ray.z *= -1.0;\n    ray.z = -1.0;\n    return ray;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray_persp_fov_fov_fov(", "\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,\n        q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\n// Quaternion-vector multiplication\nvec4 quatmul(vec4 q, vec4 v)\n{\n    return vec4(\n        q.w * v.x + q.x * v.w + q.y * v.z - q.z * v.y,\n        q.w * v.y + q.y * v.w + q.z * v.x - q.x * v.z,\n        q.w * v.z + q.z * v.w + q.x * v.y - q.y * v.x,\n        q.w * v.w - q.x * v.x - q.y * v.y - q.z * v.z\n    );\n}\n\n// Quaternion-quaternion multiplication\nvec4 quatmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y", "\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    return (length(p)-ab.x) * length(p) / ab.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    \n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    \n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( in vec2 p, in float r1, float r2 )\n{\n    vec2 q = vec2( length(p.x), p.y );\n    \n    float b = (r1-r2)/r1;\n    float a = sqrt(1.0-b*b);\n    float h = vec2(a,b)*p;\n    \n    return  -h.x*r2 - h.y*r1 + length(max(vec2(h.x,p.y),0.0)) - r1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( in vec2 p, in float h, in float r1, float r2 )\n{\n    vec2  q = vec2( length(p.x), p.y-h );\n    \n", "\n    return (d < m.x)? vec2(d,a) : m;\n}\n\nvec2 opSubtraction( vec2 m, float d, float a )\n{\n    return (d > m.x)? vec2(d,a) : m;\n}\n\nvec2 opIntersection( vec2 m, float d, float a )\n{\n    return (d > m.x)? vec2(d,a) : m;\n}\n\nvec2 opSmoothUnion( vec2 m, float d, float a )\n{\n    float k = clamp( 0.5 + 0.5*(d+a)/a, 0.0, 1.0 );\n    return vec2( mix( d, -a, k ) - a*sqrt(1.0-k*k), a );\n}\n\nvec2 opSmoothSubtraction( vec2 m, float d, float a )\n{\n    float k = clamp( 0.5 - 0.5*(d+a)/a, 0.0, 1.0 );\n    return vec2( mix( d, a, k ) + a*sqrt(1.0-k*k), a );\n}\n\nvec2 opSmoothIntersection( vec2 m, float d, float a )\n{\n    float k = clamp( 0.5 - 0.5*(d-a)/a, 0.0, 1.0 );\n    return vec2( mix( d, -a, k ) + a*sqrt(1.0-k*k), a );\n}\n\nvec2 opRepeat( vec2 p, vec2 c )\n{\n    vec2 q = mod(p,c);\n    return q - 0.5*c*(sign(q));\n}\n\nvec2 opRepeatXY( vec2 p, vec2 c )\n{\n    vec2 q = mod(p,c);\n    return q - c*clamp(q,0.0,1.0);\n}\n\nvec2 opRepeatXZ( vec2 p, vec2 c )\n", "\n    vec2  oc = ro;\n    float b  = dot( oc, rd );\n    float c  = dot( oc, oc ) - rad*rad;\n    float h  = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n    }\n    else\n    {\n        h = sqrt( h );\n        p1 = vec4( -b-h, rad );\n        p2 = vec4( -b+h, rad );\n    }\n}\n\n// https://iquilezles.org/articles/intersectors/\nvoid intersectCapsule( in vec2 ro, in vec2 rd, float rad, float len, out vec4 p1, out vec4 p2 )\n{\n    vec2  oc = ro;\n    float b  = dot( oc, rd );\n    float c  = dot( oc, oc ) - rad*rad;\n    float h  = b*b - c;\n    if( h<0.0 )\n    {\n        p1 = vec4( 0.0 );\n        p2 = vec4( 0.0 );\n    }\n    else\n    {\n        h = sqrt( h );\n        p1 = vec4( -b-h, rad );\n        p2 = vec4( -b+h, rad );\n    }\n    if( p1.y<0.0 )\n    {\n        p1.y = 0.0;\n        p1.x = -b;\n    }\n    if( p2.y<0.0 )\n    {\n        p2.y = 0.0;\n        p2.x = -b;\n    }\n    if( p1.y>len )\n    {\n        p1.y = len;\n        p1.x = -b + sqrt( len*len - rad*rad );\n    }\n    if( p2.y>len )\n    {\n        p2.y = len;\n        p2.x = -b - sqrt(", "\n    vec2 d = p - c;\n    float l = length(d);\n    return vec3(l - r, d / l, 0.0);\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b ) \n{\n    vec2 d = abs(p) - b;\n    float m = max(d.x, d.y);\n    return vec3(m, normalize(vec2(d.x, d.y)), 0.0);\n}\n\nvec3 sdgRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 d = abs(p) - b;\n    float m = max(d.x, d.y);\n    return vec3(m - r, normalize(vec2(d.x, d.y)), 0.0);\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 a, in vec2 b, in float r ) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length( pa - ba*h ) - r, \n                 normalize(pa - ba*h), \n                 0.0 );\n}\n\nvec3 sdgCylinder( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,c.y);\n    float m = min(max(d.x,d.y),0.0);\n    vec2 n = normalize(d.xy);\n    return vec3( m + r, n, 0.0 );\n}\n\nvec3 sdgCone( in vec2 p, in vec2 c, in float r ) \n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec", "\n    vec2 d = abs(p)-b;\n    return vec3( length(max(d,0.0)) + min(max(d.x,d.y),0.0),\n                 normalize(vec2(d.x,d.y)-d.yx) );\n}\n\nvec3 sdgSphere( in vec2 p, in float r )\n{\n    return vec3( length(p)-r, normalize(p), 0.0 );\n}\n\nvec3 sdgCylinder( in vec2 p, in float r )\n{\n    vec2 d = abs(vec2(length(p.x),p.y)) - vec2(r,0.0);\n    return vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n                 normalize(vec2(d.x,d.y)-d.yx), 0.0 );\n}\n\nvec3 sdgCone( in vec2 p, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.x), p.y );\n    vec2 d = vec2( dot(q,normalize(vec2(r2,1.0))), q.y-r1 );\n    return vec3( d.x, normalize(vec2(d.x,d.y)-d.yx), 0.0 );\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( length(pa-ba*h)-r, normalize(pa-ba*h), 0.0 );\n}\n\nvec3 sdgCapsule( in vec2 p, in vec2 a, in vec2 b, in float r, in float h )\n{", "\n    vec2 q = p - vec2( 0.0, 1.0 );\n    float d = length( q ) * 0.8 - 0.2;\n    float a = atan( q.y, q.x ) - 0.5;\n    float b = atan( q.y, q.x ) + 0.5;\n    float m = cos( a );\n    float n = sin( a );\n    float c = ( 13.0 * cos( b ) - 5.0 * cos( 2.0 * b ) - 2.0 * cos( 3.0 * b ) - cos( 4.0 * b ) ) / 20.0;\n    float s = m * m * m * m * ( d + 0.15 * c );\n    float t = ( m * m * ( 5.0 * d - 3.0 * c ) + 3.0 * n * n * ( 1.0 - m * m ) ) / ( 10.0 * ( 1.0 - m * m ) );\n    return vec3( s, t, m * m * ( d - 0.5 * c ) - 0.5 * n * n );\n}\n\n//.x = f(p)\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec3 sdgHeart2( in vec2 p )\n{\n    vec2 q = p - vec2( 0.0, 1.0 );\n    float d = length( q ) * 0.8 - 0.2;\n    float a = atan( q.y, q.x ) - 0.5;\n    float b = atan( q.y, q.x ) + 0.5;\n    float m = cos( a );\n    float n = sin( a );\n    float c = ( 13.0 * cos( b ) - 5.0 * cos( 2.0 * b ) - 2.0 * cos( 3.0 * b ) - cos( 4.0 * b ) ) / 20.", "\n    return a1 * x + b1;\n}\n\nfloat wobble(float x) {\n    return g(0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return pow(abs(x), n) / (pow(abs(x), n) + pow(a, n));\n}\n\nfloat slowPush(float a, float b, float n, float x) {\n    return h(a, b, n, x) - h(a, b, n, -x);\n}\n\n// Slow push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(abs(x), n) / (pow(abs(x), n) + pow(a, n));\n}\n\nfloat slowPush(float a, float b, float n, float x) {\n    return h(a, b, n, x) - h(a, b, n, -x);\n}\n\n// Slow push -> wobble (green)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(float a, float b, float n, float x) {\n    return pow(abs(x), n) / (pow(abs(x), n) + pow(a, n));\n}\n\nfloat slowPush(float a, float b, float n, float x) {\n    return h(a, b, n, x) - h(a, b, n, -x);\n}\n\n// Slow push -> wobble (blue)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat h(", "\n                uv *= 10.0;\n                vec2 i = floor(uv);\n                vec2 f = fract(uv);\n                f = f*f*(3.0-2.0*f);\n                vec2 uv_bl = (i+vec2(0.0,0.0));\n                vec2 uv_br = (i+vec2(1.0,0.0));\n                vec2 uv_tl = (i+vec2(0.0,1.0));\n                vec2 uv_tr = (i+vec2(1.0,1.0));\n                float bl = random(uv_bl);\n                float br = random(uv_br);\n                float tl = random(uv_tl);\n                float tr = random(uv_tr);\n                float b = mix(bl,br,f.x);\n                float t = mix(tl,tr,f.x);\n                return mix(b,t,f.y);\n            }\n\n            float noise(vec2 uv){\n                return paperNoise(uv);\n            }\n\n            float fbm(vec2 uv){\n                float f = 0.0;\n                f += 0.5000*noise(uv);\n                f += 0.2500*noise(uv*2.0);\n                f += 0.1250*noise(uv*4.0);\n                f += 0.0625*noise(uv*8.0);\n                return f/0.9375;\n            }\n\n            float fbm2(vec2 uv){\n                float f = 0.0;\n                f += 0.5000*noise(uv);\n                f += 0.2500*noise(uv*2.0);\n                f += 0.1250*noise(uv*4.0);\n                f += 0.0625*noise(uv*8.0);\n                return f/0.9375;\n            }\n\n            float fbm3(vec2 uv){\n                float f = 0.0;\n                f += 0.5000*noise", "\n    vec3 color = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 p = vec3(0.0);\n    vec3 d = vec3(0.0);\n    vec3 n = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 v = vec3(0.0);\n    vec3 s = vec3(0.0);\n    vec3 t = vec3(0.0);\n    vec3 u = vec3(0.0);\n    vec3 w = vec3(0.0);\n    vec3 h = vec3(0.0);\n    vec3 b = vec3(0.0);\n    vec3 g = vec3(0.0);\n    vec3 f = vec3(0.0);\n    vec3 e = vec3(0.0);\n    vec3 a = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 k = vec3(0.0);\n    vec3 j = vec3(0.0);\n    vec3 i = vec3(0.0);\n    vec3 h = vec3(0.0);\n    vec3 g = vec3(0.0);\n    vec3 f = vec3(0.0);\n    vec3 e = vec3(0.0);\n    vec3 d = vec3(0.0);\n    vec3 c = vec3(0.0);\n    vec3 b = vec3(0.0);\n    vec3 a = vec3(0.0);\n    vec3 l = vec3(0.0);\n    vec3 k = vec3(0.0);\n    vec3 j = vec3(0.0);\n    vec3 i = vec3(0.0);\n    vec3 h = vec3(0.0);\n   ", "\n    return length(p-c) - r;\n}\n\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float r2 )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r2;\n}\n\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float r2, in float r3 )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r3;\n}\n\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4 )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r4;\n}\n\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4, in float r5 )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r5;\n}\n\nfloat", "\n    p = abs(p)-b;\n    return length(max(p,0.0)) + min(max(p.x,p.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r2;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r3;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r4;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r, in float r2, in float r3, in float r4, in float r5 ) \n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r5;\n}\n\nfloat s", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-ba*h), h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2", "\n    vec2 pa = p - a, ba = b - a;\n    float h2 = h*h, h4 = h2*h2;\n    float l2 = dot(ba,ba);\n    float t = dot(pa,ba)/l2;\n    if( t<0.0 ) return vec2( length(pa)-h, 0.0 );\n    if( t>1.0 ) return vec2( length(p-b)-h, 0.0 );\n    vec2 q = a + t*ba;\n    vec2 dq = pa - ba*t;\n    float l = length(dq);\n    float m2 = l2 - h2;\n    float m = sqrt(m2);\n    float n2 = dot(dq,dq) - m2;\n    float n = sqrt(n2);\n    float c2 = (n2-m2)/l2;\n    float c = sqrt(c2);\n    float d2 = m*c - h*n;\n    float s2 = n2 - c2*l2;\n    float s = sqrt(s2);\n    float d = s*c;\n    float da = (d2<0.0)? 0.0 : (d2<d2min)? 0.5*sqrt(d2min/d2) : 1.0;\n    float db = (s2<0.0)? 0.0 : (s2<s2min)? 0.5*sqrt(s2min/s2) : 1.0;\n    return vec2( 0.5*(d+s)*da + 0.5*(l-d-s)*db, 1.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdCircle( in vec2 p, in float r )\n{\n    return vec2( length(p)-r, 1.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdBox( in vec2 p, in vec2 b )\n", "\n    float d = 1e10;\n    for( int i=0; i<7; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[(i+1)*2], kPath[(i+1)*2+1] );\n        float t = dot( p-a, b-a ) / dot( b-a, b-a );\n        if( kType[i] == 0 )\n        {\n            if( t>0. && t<1. )\n            {\n                vec2 c = a + t*(b-a);\n                d = min( d, length(p-c) );\n            }\n        }\n        else\n        {\n            vec2 c = a + t*(b-a);\n            d = min( d, length(p-c) );\n        }\n    }\n    return d;\n}\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17], float kRadius[7] )\n{\n    float d = 1e10;\n    for( int i=0; i<7; i++ )\n    {\n        vec2 a = vec2( kPath[i*2], kPath[i*2+1] );\n        vec2 b = vec2( kPath[(i+1)*2], kPath[(i+1)*2+1] );\n        float t = dot( p-a, b-a ) / dot( b-a, b-a );\n        if( kType[i] == 0 )\n        {\n            if( t>0. && t<1. )\n            {\n                vec2 c = a + t*(b-a);\n                d = min( d, length(p-c) - kRadius[i] );\n            }\n        }\n        else\n        {\n            vec2 c = a + t*(b-a);\n            d = min( d, length(p-c) - kRadius", "\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1.0;\n}\n\n// correct inside, incorrect outside\nfloat sdA( in vec2 p )\n{\n    p.x = abs(p.x);\n    return length(p) - 1", "\n    vec2 w = vec2(0.707);\n    vec2 i = 2.0*floor(0.5*p)-1.0;\n    vec2 x = 0.5*p-i;\n    vec2 b = x-i;\n    vec2 d = sign(b);\n    vec2 e = vec2(d.x,d.y)*w.xy;\n    vec2 m = b+e;\n    vec2 r = m*m;\n    float rxy = r.x+r.y;\n    float rxy2 = rxy*rxy;\n    float a = 0.5*rxy;\n    float b = -1.5*rxy+0.5*rxy2+0.5;\n    float c = 0.5*rxy2-0.5*rxy;\n    float h = b*b-4.0*a*c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt(h);\n    vec2 z = (sqrt(h)-b)/a;\n    vec2 uv = z/vec2(rxy+z.x,rxy+z.y);\n    return 1.5*(a*uv.x*uv.x+b*uv.x+c)*rxy2/(rxy+z.x);\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = sdB(uv);\n    gl_FragColor = vec4(vec3(d), 1.0);\n}\n", "\n    // The pattern is a grid of squares.\n    // The grid is made up of 4 squares.\n    // Each square is made up of 2 triangles.\n    // Each triangle is made up of 3 vertices.\n    // Each vertex is made up of 3 coordinates.\n    // Each coordinate is made up of 3 values.\n    // Each value is made up of 3 characters.\n    // Each character is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    // Each digit is made up of 3 numbers.\n    // Each number is made up of 3 digits.\n    //", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    return a + ba * h;\n}\n\n// Closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = dot( pa, ba ) / dot( ba, ba );\n    return a + ba * h;\n}\n\n// Closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    vec2 pa = p - a;\n    float h = dot( pa, ba ) / dot( ba, ba );\n    float k = dot( pa, ca ) / dot( ca, ca );\n    float s = 1.0 - h - k;\n    if( s < 0.0 )\n    {\n        h = clamp( h, 0.0, 1.0 );\n        return a + ba * h;\n    }\n    else if( k < 0.0 )\n    {\n        k = clamp( k, 0.0, 1.0 );\n        return a + ca * k;\n    }\n    else if( h < 0.0 )\n    {\n        h = clamp( h, 0.0, 1.0 );\n        return a + ba * h;\n    }\n    else\n    {\n        return a + ba * h + ca * k;\n    }\n}\n\n// Closest point on rectangle\nvec2 cloRect( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    vec2 ad = d - a;", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b - a, pa = p - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 q = a + h*ba;\n    float d = length( pa - q );\n    float s = (p.x-q.x)*(a.y-c.y) - (p.y-q.y)*(a.x-c.x);\n    return d * sign(s);\n}\n\n// distance to rectangle\nfloat sdRect( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded rectangle\nfloat sdRoundRect( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    float a2 = ab.x*ab.x;\n    float b2 = ab.y*ab.y;\n    float px = p.x*p.x;\n    float py = p.y*p.y;\n    float f = (px/a2) + (py/b2) - 1.0;\n    return f*sqrt(px/a2 + py/b2);\n}\n\n// distance to", "\n    vec2 q = abs(p)-b;\n    return (q.y>q.x)? vec2(sign(p.x),r)*b+sign(p.x)*q : vec2(r)*b+sign(p.y)*q;\n}\n\n// closest point on box\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    vec2 q = abs(p)-b;\n    return (q.y>q.x)? vec2(sign(p.x),0)*b+sign(p.x)*q : vec2(0)*b+sign(p.y)*q;\n}\n\n// closest point on line\nvec2 cloLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return a + ba*h;\n}\n\n// closest point on circle\nvec2 cloCircle( in vec2 p, in vec2 c, float r )\n{\n    return c + r*normalize(p-c);\n}\n\n// closest point on ellipse\nvec2 cloEllipse( in vec2 p, in vec2 c, in vec2 r )\n{\n    vec2 q = p-c;\n    return c + r*q/dot(q,q);\n}\n\n// closest point on triangle\nvec2 cloTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec2 ba = b-a, ca = c-a;\n", "\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    float a2 = ab.x*ab.x;\n    float b2 = ab.y*ab.y;\n    float f = (a2*b2 - b2*b2*p.x*p.x) / (a2*p.x*p.x + b2*p.y*p.y);\n    float g = (a2*b2*p.y*p.y) / (b2*p.x*p.x + a2*p.y*p.y);\n    return sqrt(f*f + g*g) * sign(ab.x*p.x);\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0;\n    vec2 e1 = p2-p1;\n    vec2 e2 = p0-p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );", "\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r )\n{\n    vec2 q = abs(p)-b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\n// distance to ellipse\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    float a2 = ab.x*ab.x;\n    float b2 = ab.y*ab.y;\n    float f = (a2*b2 - b2*b2*p.x*p.x) / (a2*p.x*p.x + b2*p.y*p.y);\n    float g = (a2*b2*p.y*p.y) / (b2*p.x*p.x + a2*p.y*p.y);\n    return sqrt(f*f + g*g) * sign(ab.x*p.x + ab.y*p.y);\n}\n\n// distance to triangle\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0;\n    vec2 e1 = p2-p1;\n    vec2 e2 = p0-p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12s(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash with Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13s(vec3 p3){\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view", "\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, float y)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec3 x, float y)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec4 x, float y)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453 + y);\n}\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x, vec2 y)\n{\n    return fract(sin(dot(x.xy, vec2(12.9898, 7", "\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// From iq\nvec3 random3(vec3 c)\n{\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *=.125;\n    r.x = fract(512.0*j);\n    j *=.125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n// From iq\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random2(i).x;\n    float b = random2(i + vec2(1.0, 0.0)).x;\n    float c = random2(i + vec2(0.0, 1.0)).x;\n    float d = random2(i + vec2(1.0, 1.0)).x;\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// From iq\nfloat fbm(vec2 st) {\n    // Initial values\n", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(hash(i + vec2(0.0,0.0)), \n                   hash(i + vec2(1.0,0.0)), u.x),\n               mix(hash(i + vec2(0.0,1.0)), \n                   hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    vec3 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash(i + vec3(0.0,0.0,0.0)), \n                       hash(i + vec3(1.0,0.0,0.0)), u.x),\n                   mix(hash(i + vec3(0.0,1.0,0.0)), \n                       hash(i + vec3(1.0,1.0,0.0)), u.x), u.y),\n               mix(mix(hash(i + vec3(0.0,0.0,1.0)), \n                       hash(i + vec3(1.0,0.0,1.0)), u.x),\n                   mix(hash(i + vec3(0.0,1.0,1.0)), \n                       hash(i + vec3(1.0,1.0,1.0)), u.x), u.y), u.z);\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat tri", "\n    float f = 0.0;\n    f += 0.5000*noise(x); x = x*2.02;\n    f += 0.2500*noise(x); x = x*2.03;\n    f += 0.1250*noise(x); x = x*2.01;\n    f += 0.0625*noise(x); x = x*2.04;\n    f += 0.0312*noise(x); x = x*2.01;\n    f += 0.0156*noise(x); x = x*2.05;\n    f += 0.0078*noise(x); x = x*2.01;\n    f += 0.0039*noise(x); x = x*2.04;\n    return f/0.9688;\n}\n\n// 2D noise function\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\n// 3D noise function\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d*d*(3.0-2.0*d);\n\n    vec2 ip = a.xy + vec2(37.0,17.0)*a.z;\n    float n = dot(rand(ip),d.xyz);\n\n    ip = a.xy + vec2(37.0,17.0)*(a.z+1.0);\n    n += dot(rand(ip),d.xyz)*0.", "\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(rand(n), rand(n+1.0),f.x), mix(rand(n+57.0), rand(n+58.0),f.x),f.y);\n    return res;\n}\n\nfloat fbm(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for (int i = 0; i < 5; ++i) {\n        v += a * pattern(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat noise(vec2 x)\n{\n    return fbm(x);\n}\n\nfloat fbm_fractal(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for (int i = 0; i < 5; ++i) {\n        v += a * pattern(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm_fractal_2(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    for (int i = 0; i < 5; ++i) {\n        v += a * pattern(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm_fractal_3(vec2 x)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(10", "\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r);\n    float phi = atan(y, x);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float areaElement = r * r * sinTheta * ddx(theta) * ddy(phi);\n    return areaElement;\n}\n\nfloat texelSolidAngle(float x, float y)\n{\n    float r = sqrt(x * x + y * y);\n    float theta = atan(r);\n    float phi = atan(y, x);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float texelSolidAngle = r * r * sinTheta * ddx(theta) * ddy(phi);\n    return texelSolidAngle;\n}\n\n//\n// https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n//\nfloat texelSolidAngle(vec2 uv)\n{\n    float r = sqrt(uv.x * uv.x + uv.y * uv.y);\n    float theta = atan(r);\n    float phi = atan(uv.y, uv.x);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float texelSolidAngle = r * r * sinTheta * ddx(theta) * ddy(phi);\n    return texelSolidAngle;\n}\n\n//\n// https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n//\nfloat texelSolidAngle(vec3 uvw)\n{\n   ", "\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec3 g = vec3(u.x, u.y, 1.0 - u.x - u.y);\n    vec3 o1 = hash33(i + vec3(0.0, 0.0, 0.0));\n    vec3 o2 = hash33(i + vec3(1.0, 0.0, 0.0));\n    vec3 o3 = hash33(i + vec3(0.0, 1.0, 0.0));\n    vec3 o4 = hash33(i + vec3(1.0, 1.0, 0.0));\n    vec3 o5 = hash33(i + vec3(0.0, 0.0, 1.0));\n    vec3 o6 = hash33(i + vec3(1.0, 0.0, 1.0));\n    vec3 o7 = hash33(i + vec3(0.0, 1.0, 1.0));\n    vec3 o8 = hash33(i + vec3(1.0, 1.0, 1.0));\n    vec3 o12 = mix(o1, o2, g.x);\n    vec3 o34 = mix(o3, o4, g.x);\n    vec", "\n    // 3D simplex noise\n    // https://github.com/ashima/webgl-noise\n    // by Ashima Arts\n    //\n    // Converted to GLSL by Stefan Gustavson (stefan.gustavson@liu.se)\n    // Optimized by Ian McEwan, Ashima Arts (Twitter: @ashimaartsy)\n    //\n    // Copyright (c) 2011 Ashima Arts. All rights reserved.\n    // Distributed under the MIT License. See LICENSE file.\n    // https://github.com/ashima/webgl-noise\n    //\n\n    // Coordinate permutation\n    vec3 i = floor(p + dot(p, vec3(0.333333)));\n    vec3 x0 = p - i + dot(i, vec3(0.166667));\n\n    // Other corners\n    vec3 g = step(0.5, vec3(dot(x0.xy, x0.xy), dot(x0.yz, x0.yz), dot(x0.zx, x0.zx)));\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + vec3(0.333333);\n    vec3 x2 = x0 - i2 + vec3(0.666667);\n    vec3 x3 = x0 - vec3(1.0);\n\n    // Permutations\n    i = mod289(i);\n   ", "\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nvec3 hash( in vec3 x )   \n{\n    const vec3 k = vec3( 0.3183099, 0.3678794, 0.4145199 );\n    x = x*k + k.yzx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*x.z*(x.x+x.y+x.z)) );\n}\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nvec4 hash( in vec4 x )   \n{\n    const vec4 k = vec4( 0.3183099, 0.3678794, 0.4145199, 0.1212121 );\n    x = x*k + k.yzwx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*x.z*x.w*(x.x+x.y+x.z+x.w)) );\n}\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nfloat hash( in float x )   \n{\n    return fract( 12.9898*x + 0.718281828459045 );\n}\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nvec2 hash2(", "\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p)-r;\n}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r, float f )\n{\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*f;\n}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r, float f, float m )\n{\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*f - m;\n}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r, float f, float m, float n )\n{\n  vec2 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r*f - m*n;\n}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r, float f, float m, float n, float o )\n{\n  vec2", "\n    r = vec2(1.0) - r;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b, in vec3 r )\n{\n    r = vec3(1.0) - r;\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b, in vec4 r )\n{\n    r = vec4(1.0) - r;\n    vec4 d = abs(p) - b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0)) - r.x;\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// This is the final form\nfloat sdBox( in vec4 p, in vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min(max(d.x,max(d.y,max(d.z,d.w))),0.0", "\n    // https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n    // https://en.wikipedia.org/wiki/Ellipse#General_ellipse\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_three_points\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section_(geometry)#Conic_through_two_points_and_a_line\n    // https://en.wikipedia.org/wiki/Conic_section", "\n    vec3 p3 = fract(vec3(p.xyx) *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Noise12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(Hash12(i + vec2(0.0, 0.0)),\n                   Hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash12(i + vec2(0.0, 1.0)),\n                   Hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm12(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * Noise12(p);\n    p *= 2.01;\n    f += 0.2500 * Noise12(p);\n    p *= 1.96;\n    f += 0.1250 * Noise12(p);\n    p *= 1.93;\n    f += 0.0625 * Noise12(p);\n    return f / 0.9375;\n}\n\nfloat fbm12(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000 * Noise12(p.xy);\n    p.xy *= 2.01;\n    f += 0.2500 * Noise12(p.xy);\n    p.xy *= 1.96;\n    f += 0.1250 * Noise12(p.xy);\n    p.xy *= 1.93;\n    f += 0.0625 * Noise12(p.", "\n    float d = r;\n    float a = an;\n    float b = bn;\n    for (int i = 0; i < m; i++)\n    {\n        vec2 q = p - acs;\n        float h = length(q);\n        float aa = atan(q.y, q.x) + a;\n        d = min(d, max(h * cos(aa), h * sin(aa) * m));\n        a += b;\n    }\n    return d;\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in float m) // m=[2,n]\n{\n    float d = r;\n    float a = an;\n    float b = bn;\n    for (int i = 0; i < m; i++)\n    {\n        vec2 q = p;\n        float h = length(q);\n        float aa = atan(q.y, q.x) + a;\n        d = min(d, max(h * cos(aa), h * sin(aa) * m));\n        a += b;\n    }\n    return d;\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m, in float e) // m=[2,n]\n{\n    float d = r;\n    float a = an;\n    float b = bn;\n    for (int i = 0; i < m; i++)\n    {\n        vec2 q = p - acs;\n        float h = length(q);\n        float aa = atan(q.y, q.x) + a;\n        d = min(d, max(h * cos(", "\n    vec3 e = vec3(1.0, 1.0, 1.0);\n    return normalize( vec3(\n        sd(p+e.xyy) - sd(p-e.xyy),\n        sd(p+e.yxy) - sd(p-e.yxy),\n        sd(p+e.yyx) - sd(p-e.yyx) ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*sd( pos + e.xyy ) +\n                      e.yyx*sd( pos + e.yyx ) +\n                      e.yxy*sd( pos + e.yxy ) +\n                      e.xxx*sd( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*sd( pos + e.xyy, t ) +\n                      e.yyx*sd( pos + e.yyx, t ) +\n                      e.yxy*sd( pos + e.yxy, t ) +\n                      e.xxx*sd( pos + e.xxx, t ) );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*sd( pos + e.xyy, t ) +\n                      e.yyx*sd( pos + e.yyx, t ) +\n                      e.yxy*sd( pos + e.yxy, t ) +\n                      e.xxx", "\n    float t = t0;\n    float res = 1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < EPSILON)\n            return 0.0;\n        res = min(res, 8.0 * h / t);\n        t += h;\n        if (t > t1)\n            break;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float t0, float t1)\n{\n    float t = t0;\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n        if (h < EPSILON)\n        {\n            vec3 p = ro + rd * t;\n            vec3 n = normal(p);\n            vec3 r = reflect(rd, n);\n            float m = map(p + n * EPSILON);\n            float f = clamp(0.5 + 0.5 * dot(n, -rd), 0.0, 1.0);\n            float fresnel = pow(1.0 - f, 5.0);\n            float specular = pow(clamp(dot(n, r), 0.0, 1.0), 16.0);\n            float diffuse = max(0.0, dot(n, rd));\n            return vec3(0.0, 0.0, 0.0) +\n                vec3(0.0, 0.0,", "\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp", "\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1 - c;\n\n    return mat3(\n        t * axis.x * axis.x + c, t * axis.x * axis.y - s * axis.z, t * axis.z * axis.x + s * axis.y,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c, t * axis.y * axis.z - s * axis.x,\n        t * axis.z * axis.x - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the x axis by the angle\nmat3 createRotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\n// Helper function generating a rotation matrix around the y axis by the angle\nmat3 createRotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n        -s, 0, c\n    );\n}\n\n// Helper function generating a rotation matrix around the z axis by the angle\nmat3 createRotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat3(\n        c, -s, 0,\n        s, c, 0,\n        0, 0, 1\n    );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1 - c;\n\n    return mat3(\n        t * axis.x *", "\n    vec3 ray = normalize(vec3(fragCoord.x, fragCoord.y, 1.0));\n    return ray;\n}\n\n// Helper function that returns the color of the scene at a given ray\nvec3 getColor(vec3 ray) {\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 point = vec3(0.0);\n    float t = INFINITY;\n    float tmin = INFINITY;\n    float tmax = INFINITY;\n    float tmin_sphere = INFINITY;\n    float tmax_sphere = INFINITY;\n    float tmin_cylinder = INFINITY;\n    float tmax_cylinder = INFINITY;\n    float tmin_cone = INFINITY;\n    float tmax_cone = INFINITY;\n    float tmin_plane = INFINITY;\n    float tmax_plane = INFINITY;\n    float tmin_torus = INFINITY;\n    float tmax_torus = INFINITY;\n    float tmin_box = INFINITY;\n    float tmax_box = INFINITY;\n    float tmin_triangle = INFINITY;\n    float tmax_triangle = INFINITY;\n    float tmin_capsule = INFINITY;\n    float tmax_capsule = INFINITY;\n    float tmin_capsule_2 = INFINITY;\n    float tmax_capsule_2 = INFINITY;\n    float tmin_capsule_3 = INFINITY;\n    float tmax_capsule_3 = INFINITY;\n    float tmin_capsule_4 = INFINITY;\n    float tmax_capsule_4 = INFINITY;\n    float tmin_capsule_5 = INFINITY;\n    float tmax_capsule_5 = INFINITY;\n    float tmin_capsule_6 =", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat rand3dTime(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(12.9898,78.233,123.456))) * 43758.5453);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co){\n    return rand2dTime(co + iTime);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co){\n    return rand3dTime(co + iTime);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed){\n    return rand2dTime(co + seed);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float seed){\n    return rand3dTime(co + seed);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed, float time){\n    return rand2dTime(co + seed + time);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float seed, float time){\n    return rand3dTime(co + seed + time);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed, float time, float seed2){\n    return rand2dTime(co + seed + time + seed2);\n}\n\n// Standard 3d noise\nfloat rand3d(vec3 co, float seed, float time, float seed2){\n    return rand3dTime(co + seed + time + seed2);\n}\n\n// Standard 2d noise\nfloat rand2d(vec2 co, float seed, float time, float seed2, float seed3){\n    return rand2dTime(co + seed + time + seed2 + seed3);\n}\n\n// Standard 3d noise\n", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 151.7182))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat rand2d(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Hash for 1d vectors\nfloat rand1d(float p){\n    return fract(sin(p) * 43758.5453);\n}\n\n// 3d noise\nfloat noise3d(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(rand3d(i + vec3(0.0, 0.0, 0.0)), rand3d(i + vec3(1.0, 0.0, 0.0)), u.x),\n                   mix(rand3d(i + vec3(0.0, 1.0, 0.0)), rand3d(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n               mix(mix(rand3d(i + vec3(0.0, 0.0, 1.0)), rand3d(i + vec3(1.0, 0.0, 1.0)), u.x),\n                   mix(rand3d(i + vec3(0.0, 1.0, 1.0)), rand3d(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\n// 2d noise\nfloat noise2d(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D value noise\nfloat noise2d(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 1D value noise\nfloat noise1d(float x){\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float uv = (p+37.0)*f + p;\n    return textureLod(iChannel0, (uv+0.5)/256.0, 0.0).x;\n}\n\n// 3D value noise\nfloat noise3d(vec3 x, float t){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).y", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\n// 2D simplex noise, cool trick\nfloat supernoise2d(vec2 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (i", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p); p = p*2.04;\n    f += 0.0312*noise(p); p = p*2.01;\n    f += 0.0156*noise(p); p = p*2.05;\n    f += 0.0078*noise(p); p = p*2.01;\n    f += 0.0039*noise(p);\n    return f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain){\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*lacunarity;\n    f += 0.2500*noise(p); p = p*lacunarity;\n    f += 0.1250*noise(p); p = p*lacunarity;\n    f += 0.0625*noise(p); p = p*lacunarity;\n    f += 0.0312*noise(p); p = p*lacunarity;\n    f += 0.0156*noise(p); p = p*lacunarity;\n    f += 0.0078*noise(p); p = p*lacunarity;\n    f += 0.0039*noise(p);\n    return f;\n}\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p, float lacunarity, float gain, int octaves){\n    float f = 0.0;\n    float a = 0.5;\n    for(int i = 0; i < octaves; i++){\n        f += a*noise", "\n    vec2 density = vec2(0.0);\n    float densityFactor = 1.0;\n    float densityFactor2 = 1.0;\n    float densityFactor3 = 1.0;\n    float densityFactor4 = 1.0;\n    float densityFactor5 = 1.0;\n    float densityFactor6 = 1.0;\n    float densityFactor7 = 1.0;\n    float densityFactor8 = 1.0;\n    float densityFactor9 = 1.0;\n    float densityFactor10 = 1.0;\n    float densityFactor11 = 1.0;\n    float densityFactor12 = 1.0;\n    float densityFactor13 = 1.0;\n    float densityFactor14 = 1.0;\n    float densityFactor15 = 1.0;\n    float densityFactor16 = 1.0;\n    float densityFactor17 = 1.0;\n    float densityFactor18 = 1.0;\n    float densityFactor19 = 1.0;\n    float densityFactor20 = 1.0;\n    float densityFactor21 = 1.0;\n    float densityFactor22 = 1.0;\n    float densityFactor23 = 1.0;\n    float densityFactor24 = 1.0;\n    float densityFactor25 = 1.0;\n    float densityFactor26 = 1.0;\n    float densityFactor27 = 1.0;\n    float densityFactor28 = 1.0;\n    float densityFactor29 = 1.0;\n    float densityFactor30 = 1.0;\n    float densityFactor31 = 1.0;\n    float densityFactor32 = 1.0;\n    float densityFactor33 = 1.0;\n    float densityFactor34 = 1.0;\n    float densityFactor35 = 1.0;\n    float densityFactor36 = 1.0;\n    float densityFactor37 = 1.0;\n    float densityFactor38 = 1.0;\n    float densityFactor39 = 1.0;", "\n    vec3 color = vec3(0.0);\n    float coverage = 0.0;\n    float coverage2 = 0.0;\n    float coverage3 = 0.0;\n    float coverage4 = 0.0;\n    float coverage5 = 0.0;\n    float coverage6 = 0.0;\n    float coverage7 = 0.0;\n    float coverage8 = 0.0;\n    float coverage9 = 0.0;\n    float coverage10 = 0.0;\n    float coverage11 = 0.0;\n    float coverage12 = 0.0;\n    float coverage13 = 0.0;\n    float coverage14 = 0.0;\n    float coverage15 = 0.0;\n    float coverage16 = 0.0;\n    float coverage17 = 0.0;\n    float coverage18 = 0.0;\n    float coverage19 = 0.0;\n    float coverage20 = 0.0;\n    float coverage21 = 0.0;\n    float coverage22 = 0.0;\n    float coverage23 = 0.0;\n    float coverage24 = 0.0;\n    float coverage25 = 0.0;\n    float coverage26 = 0.0;\n    float coverage27 = 0.0;\n    float coverage28 = 0.0;\n    float coverage29 = 0.0;\n    float coverage30 = 0.0;\n    float coverage31 = 0.0;\n    float coverage32 = 0.0;\n    float coverage33 = 0.0;\n    float coverage34 = 0.0;\n    float coverage35 = 0.0;\n    float coverage36 = 0.0;\n    float coverage37 = 0.0;\n    float coverage38 = 0.0;\n    float coverage39 = 0.0;\n    float coverage40 = 0.0;\n    float coverage41 = 0.0;\n    float coverage42 = 0.0;\n    float coverage43 = 0.0;\n    float coverage44 = 0.0;\n    float coverage45 = 0.0;\n    float coverage46 = 0.0;\n", "\n    vec3 ray = normalize(pointEnd - pointStart);\n    float t = 0.0;\n    float tMax = 100.0;\n    float tMin = 0.0;\n    float tStep = 0.01;\n    float tStepMax = 100.0;\n    float tStepMin = 0.001;\n    float tStepFactor = 1.0;\n    float tStepFactorMax = 100.0;\n    float tStepFactorMin = 0.001;\n    float tStepFactorFactor = 1.0;\n    float tStepFactorFactorMax = 100.0;\n    float tStepFactorFactorMin = 0.001;\n    float tStepFactorFactorFactor = 1.0;\n    float tStepFactorFactorFactorMax = 100.0;\n    float tStepFactorFactorFactorMin = 0.001;\n    float tStepFactorFactorFactorFactor = 1.0;\n    float tStepFactorFactorFactorFactorMax = 100.0;\n    float tStepFactorFactorFactorFactorMin = 0.001;\n    float tStepFactorFactorFactorFactorFactor = 1.0;\n    float tStepFactorFactorFactorFactorFactorMax = 100.0;\n    float tStepFactorFactorFactorFactorFactorMin = 0.001;\n    float tStepFactorFactorFactorFactorFactorFactor = 1.0;\n    float tStepFactorFactorFactorFactorFactorFactorMax = 100.0;\n    float tStepFactorFactorFactorFactorFactorFactorMin = 0.001;\n    float tStepFactorFactorFactorFactorFactorFactorFactor = 1.0;\n    float tStepFactorFactorFactorFactorFactorFactorFactorMax = 100.0;\n    float tStepFactorFactorFactorFactorFactorFactorFactorMin = 0.001;\n    float tStepFactorF", "\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap_inv(vec3 color) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(color * (a * color + b) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap_inv_approx(vec3 color) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(color * (a * color + b) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap_inv_approx_2(vec3 color) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(color * (a * color + b) / (color * (c * color + d) + e), 0.0, 1.0);\n}\n\n// https://"]}