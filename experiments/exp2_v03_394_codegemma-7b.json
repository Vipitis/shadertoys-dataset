{"generations": ["\n    return 0.25 * ( 1.0 + dot( s, vec3( 0.0, 0.0, 0.0 ) ) );\n}\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "\n    // v.y is the y component of the vector\n    // r.y is the y component of the plane\n    // r.x is the x component of the plane\n    // r.w is the x component of the vector\n    // r.z is the z component of the vector\n    // r.w is the z component of the plane\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.y is the y component of the vector\n    // r.z is the z component of the vector\n    // r.w is the w component of the vector\n    // r.x is the x component of the vector\n    // r.", "\n    return r * (dot( r, v ) < 0.0) + v * (dot( r, v ) >= 0.0);\n}\n\n// Reflect v if in the negative half space defined by r (this works in 3D too)\nvec", "\n    if (dot(v, r) < 0.0)\n    {\n        return vec2(0.0);\n    }\n    return v;\n}\n\n// Clip v if in the positive half plane defined by r (this works in 3D too)\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  hpa = pa - h*ba;\n    return length( hpa ) - w1 - w2*h;\n}\n\n// https://www.shadertoy.com/view/Msl3zS\nfloat", "\n    float sunDist = dot(rayDir, sunDir);\n    if (sunDist < 0.0)\n    {\n        sunDist = 0.0;\n    }\n    return sunCol * sunDist;\n}\n\n// This function is a procedural environment map that makes the sun\nvec", "\n    // The catmull-rom function\n    // p0 and p3 are the control points\n    // p1 and p2 are the anchor points\n    // t is the time\n    // The function returns a point on the curve\n    // The curve is a cubic polynomial\n    // The curve is a catmull-rom curve\n    // The curve is a cubic spline\n    // The curve is a cubic hermite spline\n    // The curve is a cubic bezier curve\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline\n    // The curve is a cubic b-spline", "\n\tfloat f = 0.0, g = 0.0, h = 0.0, i = 0.0, j = 0.0, k = 0.0, l = 0.0, m = 0.0, n = 0.0, o = 0.0, p = 0.0, q = 0.0, r = 0.0, s = 0.0, t = 0.0, u = 0.0, v = 0.0, w = 0.0, x = 0.0, y = 0.0, z = 0.0;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfloat a = float(i);\n\t\tfloat b = float(i + 1);\n\t\tfloat c = float(i + 2);\n\t\tfloat d = float(i + 3);\n\t\tfloat e = float(i + 4);\n\t\tfloat f = float(i + 5);\n\t\tfloat g = float(i + 6);\n\t\tfloat h = float(i + 7);\n\t\tfloat i = float(i + 8);\n\t\tfloat j = float(i + 9);\n\t\tfloat k = float(i + 10);\n\t\tfloat l = float(i + 11);\n\t\tfloat m = float(i + 12);\n\t\tfloat n = float(i + 13);\n\t\tfloat o = float(i + 14);\n\t\tfloat p = float(i + 15);\n\t\tfloat q = float(i + 16);\n\t\tfloat r = float(i + 17);\n\t\tfloat s = float(i + 18);\n\t\tfloat t = float(i + 19);\n\t\tfloat u = float(i + 20);\n\t\tfloat v = float(i + 21);\n\t\tfloat w = float(i + 22);\n\t\tfloat x = float(i + 23);\n\t\tfloat y = float(i + 24);\n\t\tfloat z = float(i + 25);\n\t\t// rotate\n\t\tvec3 q = p * mat3(cos", "\n    // the camera path is a series of 4 points\n    vec4 p0 = vec4(-1.0, -1.0, -1.0, 1.0);\n    vec4 p1 = vec4( 0.0,  0.0,  0.0, 1.0);\n    vec4 p2 = vec4( 1.0,  1.0,  1.0, 1.0);\n    vec4 p3 = vec4( 2.0,  2.0,  2.0, 1.0);\n\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and 1\n    // we want to use it to find a point on the line\n    // between p1 and p2\n    //\n    // the Catmull-Rom spline is a way of doing this\n    //\n    // the t value is a float between 0 and ", "\n    return fract(sin(u) * 43758.5453);\n}\n\nfloat", "\n    float f = 0.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        f += a * sin(b * p.x + c * p.y);\n        p = p * 1.5 + vec3(c, a, b);\n        a *= 0.53;\n        b *= 1.32;\n        c *= 1.72;\n    }\n    return f;\n}\n", "\n    // The distance to the object is the distance to the closest point on the object\n    float d = 1e10;\n    \n    // The object is a sphere\n    float s = length(p);\n    \n    // The object is a torus\n    float t = length(vec2(length(p.xz)-1.0, p.y)) - 0.5;\n    \n    // The object is a box\n    float b = min(min(min(abs(p.x), abs(p.y)), abs(p.z)), 1.0);\n    \n    // The object is a mobius strip\n    float m = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x))));\n    \n    // The object is a klein bottle\n    float k = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k2 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k3 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k4 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k5 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k6 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) - 0.5));\n    \n    // The object is a klein bottle\n    float k7 = min(abs(p.y), abs(p.x - cos(atan(p.z, p.x)) -", "\n    // Overhead softbox\n    vec3 overhead = vec3(0.0, 1.0, 0.0);\n    vec3 overheadDir = normalize(overhead - rayDir);\n    float overheadDist = length(overhead - rayDir);\n    float overheadSize = 1.0;\n    float overheadSizeDist = overheadSize * overheadSize;\n    float overheadSizeDistInv = 1.0 / overheadSizeDist;\n    float overheadSizeDistInvSq = overheadSizeDistInv * overheadSizeDistInv;\n    float overheadSizeDistInvSq2 = overheadSizeDistInvSq * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq3 = overheadSizeDistInvSq2 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq4 = overheadSizeDistInvSq3 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq5 = overheadSizeDistInvSq4 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq6 = overheadSizeDistInvSq5 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq7 = overheadSizeDistInvSq6 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq8 = overheadSizeDistInvSq7 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq9 = overheadSizeDistInvSq8 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq10 = overheadSizeDistInvSq9 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq11 = overheadSizeDistInvSq10 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq12 = overheadSizeDistInvSq11 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq13 = overheadSizeDistInvSq12 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq14 = overheadSizeDistInvSq13 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq15 = overheadSizeDistInvSq14 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq16 = overheadSizeDistInvSq15 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq17 = overheadSizeDistInvSq16 * overheadSizeDistInvSq;\n    float overheadSizeDistInvSq18 = overheadSizeDist", "\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth max (k = 0.1);\nfloat", "\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    vec3 dirVec = dirVecPLZNormalizeMeFirst;\n    ", "\n    // The distance field is the distance to the object.\n    // The normal is the gradient of the distance field.\n    // The sign of the normal is the inside/outside of the object.\n    vec2 d = vec2(length(p - vec3(0.0, 0.0, 0.0)) - 0.5, 1.0);\n    if (length(p - vec3(0.0, 0.0, 1.0)) < 0.5)\n    {\n        d = min(d, vec2(length(p - vec3(0.0, 0.0, 1.0)) - 0.5, -1.0));\n    }\n    if (length(p - vec3(0.0, 1.0, 0.0)) < 0.5)\n    {\n        d = min(d, vec2(length(p - vec3(0.0, 1.0, 0.0)) - 0.5, -1.0));\n    }\n    if (length(p - vec3(0.0, 1.0, 1.0)) < 0.5)\n    {\n        d = min(d, vec2(length(p - vec3(0.0, 1.0, 1.0)) - 0.5, -1.0));\n    }\n    if (length(p - vec3(1.0, 0.0, 0.0)) < 0.5)\n    {\n        d = min(d, vec2(length(p - vec3(1.0, 0.0, 0.0)) - 0.5, -1.0));\n    }\n    if (length(p - vec3(1.0, 1.0, 0.0)) < 0.5)\n    {\n        d = min(d, vec2(length(p - vec3(1.0, 1.0, 0.0)) - 0.5, -1.0));\n    }\n    if (length(p - vec3(1.0, 1.0, 1.0)) < 0", "\n    return vec3(\n        cos(t),\n        sin(t),\n        t\n    );\n}\n\nvec", "\n    vec2 p = map(t);\n    return vec3(p.x * p.y, p.y * (1. - p.x), 1. - p.x - p.y);\n}\n\n// curve second derivative (acceleration)\nvec", "\n    vec3 d2 = vec3(\n        -1.0 * (1.0 - t * t) * (1.0 - t * t),\n        2.0 * t * (1.0 - t * t),\n        2.0 * t * t * (1.0 - t)\n    );\n    return d2;\n}\n\n// curve third derivative (jerk)\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( h*h * dot(ba,ba), dot(pa,pa) - h*h * dot(ba,ba) );\n}\n\n// signed distance between point and segment\nfloat", "\n    vec2 t = vec2( dot( a - o, d ), dot( b - o, d ) );\n    if ( t.x < 0.0 ) return vec2( length( a - o ), 0.0 );\n    if ( t.y < t.x ) return vec2( length( b - o ), 1.0 );\n    return vec2( dot( a - o, a - o ) - t.x * t.x, t.x );\n}\n\n// return the point on the segment closest to the ray\nvec", "\n    vec2 q = abs(p) - b + r.xy;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.w;\n}\n\n// b.x = width\n// b.y = height\n// r.x = roundness top-right  \n// r.y = roundness boottom-right\n// r.z = roundness top-left\n// r.w = roundness bottom-left\nvec", "\n    float sunAngle = dot(rayDir, sunDir);\n    if (sunAngle < 0.0)\n        return vec3(0.0);\n    return sunCol * (sunAngle * sunAngle);\n}\n\n// This function is a procedural environment map that makes the sky\nvec", "\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle of the camera.\n    // The roll is the angle", "\n    vec2 d = currentRayPosition.xy * 0.5;\n    d = abs(d);\n    d = d - vec2(0.5);\n    d = max(d, vec2(0.0));\n    d = d * d;\n    d = d * d;\n    return d.xy;\n}\n", "\n  \n  // This is the distance to thing 1\n  float distanceToThing1 = distance(thing1, position);\n  \n  // This is the distance to thing 2\n  float distanceToThing2 = distance(thing2, position);\n  \n  // If the distance to thing 1 is less than\n  // the distance to thing 2\n  if( distanceToThing1 < distanceToThing2 ){\n    \n    // Return thing 1\n    return thing1;\n    \n  }\n  \n  // If the distance to thing 1 is greater than\n  // the distance to thing 2\n  if( distanceToThing1 > distanceToThing2 ){\n    \n    // Return thing 2\n    return thing2;\n    \n  }\n  \n  // If the distance to thing 1 is equal to\n  // the distance to thing 2\n  if( distanceToThing1 == distanceToThing2 ){\n    \n    // Return thing 1\n    return thing1;\n    \n  }\n  \n  // If the distance to thing 1 is greater than\n  // the distance to thing 2\n  if( distanceToThing1 > distanceToThing2 ){\n    \n    // Return thing 2\n    return thing2;\n    \n  }\n  \n  // If the distance to thing 1 is less than\n  // the distance to thing 2\n  if( distanceToThing1 < distanceToThing2 ){\n    \n    // Return thing 1\n    return thing1;\n    \n  }\n  \n  // If the distance to thing 1 is equal to\n  // the distance to thing 2\n  if( distanceToThing1 == distanceToThing2 ){\n    \n    // Return thing 1\n    return thing1;\n    \n  }\n  \n  // If the distance to thing 1 is greater than\n  // the distance to thing 2\n  if( distanceToThing1 > distanceToThing2 ){\n    \n    // Return thing 2\n    return thing2;\n    \n  }\n  \n  // If the distance to thing 1 is less than\n  // the distance to thing 2\n  if( distanceToThing1 < distanceToThing2 ){\n    \n    // Return thing 1\n    return", "\n    // The distance to the closest object\n    float closestDistance = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    \n    // We are going to use a very small value to calculate the normal\n    // of the surface. This is because we are going to use the SDF\n    // to calculate the normal of the surface.\n    // The SDF is a function that returns the distance from a point\n    // to a surface.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The normal of the surface is the direction that the surface\n    // is facing.\n    // The", "\n    return vec3(0.0);\n}\n\n// we're going to use a simple ray tracing technique\n// to render our scene.\n//\n// we'll start by defining a ray.\n// a ray is a line that goes from a point in space\n// to a point in space.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n// of variables.\n//\n// we'll use a struct to represent a ray.\n// a struct is a data type that contains a bunch\n//", "\n    \n    // We are using the normal of the surface to color the surface\n    // We are using the normal of the surface to color the surface\n    // We are using the normal of the surface to color the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    // The normal is a vector that is perpendicular to the surface\n    \n    \n", "\n    \n    // The color of the world is a combination of\n    // the color of the sky and the color of the ground\n    \n    // The color of the sky is a gradient\n    // from blue to white\n    vec3 skyColor = vec3( 1.0, 1.0, 1.0 ) * ( 1.0 - rayHitInfo.y ) + vec3( 0.0, 0.0, 1.0 ) * rayHitInfo.y;\n    \n    // The color of the ground is a gradient\n    // from green to brown\n    vec3 groundColor = vec3( 0.0, 1.0, 0.0 ) * ( 1.0 - rayHitInfo.y ) + vec3( 1.0, 0.5, 0.0 ) * rayHitInfo.y;\n    \n    // The color of the world is a combination of\n    // the color of the sky and the color of the ground\n    vec3 worldColor = mix( skyColor, groundColor, 0.5 );\n    \n    // The color of the world is a combination of\n    // the color of the world and the color of the sun\n    vec3 sunColor = vec3( 1.0, 1.0, 1.0 ) * ( 1.0 - rayHitInfo.y ) + vec3( 1.0, 1.0, 1.0 ) * rayHitInfo.y;\n    \n    // The color of the world is a combination of\n    // the color of the world and the color of the sun\n    vec3 worldColorWithSun = mix( worldColor, sunColor, 0.5 );\n    \n    // The color of the world is a combination of\n    // the color of the world and the color of the sun\n    vec3 worldColorWithSunAndShadow = mix( worldColorWithSun, vec3( 0.0, 0.0, 0.0 ), 0.5 );\n    \n    // The color of the world is a combination of\n    // the color of the world and the color of the sun\n    vec3 worldColorWithSunAndShadowAndLight = mix( worldColorWithSunAndShadow, vec3( 1.", "\n    return x * (1.0 - b) + b * clamp(x, 0.0, 1.0);\n}\n\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// creates a random number in the range -1..1\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// creates white noise in the range -1..1 including -1 including 1\nfloat", "\n    return length(p)-r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input p --> is point\n// input b --> is box size\n// pretty simple, just compare point to box size\nfloat", "\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\n// ~~~~~~~~~~ signed distance function for sphere\n// input s --> sphere specs where:\n// \ts.x = sphere radius\n//\n// note: this is a very simple sphere, it is not a perfect sphere\n// it is a sphere with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is not a closed shape, it is a \n// closed shape with a flat top and bottom\n//\n// this is because the sphere is", "\n  float k = 0.1;\n  float h = max(k-abs(d1-d2),0.0);\n  return min(d1,d2) - h*h*h*k*0.125;\n}\n", "\n  // distance of object 1\n  float d1 = 1.0 - d1;\n  // distance of object 2\n  float d2 = 1.0 - d2;\n  // blend\n  return d1 * d2;\n}\n", "\n    // twist\n    vec3 q = p;\n    \n    // twist\n    float yaw = yaw * 0.0174532925f;\n    \n    float s = sin( yaw );\n    float c = cos( yaw );\n    \n    // twist\n    q = p * mat3( c, -s, 0.0,\n                  s,  c, 0.0,\n                  0.0, 0.0, 1.0 );\n    \n    // twist\n    float x = q.x;\n    float y = q.y;\n    float z = q.z;\n    \n    // twist\n    float r = length( q );\n    \n    // twist\n    float a = atan( y, x ) * t;\n    \n    // twist\n    float c = cos( a );\n    float s = sin( a );\n    \n    // twist\n    float x = r * c;\n    float y = r * s;\n    \n    // twist\n    return vec3( x, y, z );\n}\n", "\n    if (o1.x < o2.x)\n        return o1;\n    else\n        return o2;\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 -->.x is the distance,.y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec", "\n    vec2 res = vec2(1e30, 0);\n    \n    res = min(res, sphere(p, vec3(0, 0, -1), 0.5));\n    res = min(res, sphere(p, vec3(1, 0, -1), 0.5));\n    res = min(res, sphere(p, vec3(-1, 0, -1), 0.5));\n    \n    return res;\n}\n\n// ~~~~~~~~~~ raymarch\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec", "\n\t// ~~~~~~~~~~ cast ray through the world\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t// ~~~~~~~~~~\n\t//", "\n    // ~~~~~~~~~~ find closest surface\n    vec3 color = vec3(0);\n    float t = 1e10;\n    int id = -1;\n    for (int i = 0; i < n_obj; i++)\n    {\n        float t_obj = intersect(ro, rd, objects[i]);\n        if (t_obj < t)\n        {\n            t = t_obj;\n            id = i;\n        }\n    }\n    // ~~~~~~~~~~ apply color\n    if (id == -1)\n    {\n        color = vec3(0);\n    }\n    else\n    {\n        color = objects[id].color;\n    }\n    return color;\n}\n", "\n    // ~~~~~~~~~~ calculate camera direction\n    vec3 camDir = normalize( targetPos - camPos );\n    \n    // ~~~~~~~~~~ calculate camera right\n    vec3 camRight = cross( camDir, vec3( 0.0, 1.0, 0.0 ) );\n    \n    // ~~~~~~~~~~ calculate camera up\n    vec3 camUp = cross( camRight, camDir );\n    \n    // ~~~~~~~~~~ create camera matrix\n    mat3 camMat = mat3(\n        vec3( camRight.x, camUp.x, -camDir.x ),\n        vec3( camRight.y, camUp.y, -camDir.y ),\n        vec3( camRight.z, camUp.z, -camDir.z )\n    );\n    \n    // ~~~~~~~~~~ rotate camera matrix\n    mat3 camRot = mat3(\n        vec3( cos( roll ), 0.0, sin( roll ) ),\n        vec3( 0.0, 1.0, 0.0 ),\n        vec3( -sin( roll ), 0.0, cos( roll ) )\n    );\n    \n    // ~~~~~~~~~~ return camera matrix\n    return camMat * camRot;\n}\n", "\n    if(id == 0.0)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else if(id == 1.0)\n    {\n        return vec3(0.0, 1.0, 0.0);\n    }\n    else if(id == 2.0)\n    {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    else if(id == 3.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else if(id == 4.0)\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n    else if(id == 5.0)\n    {\n        return vec3(0.0, 1.0, 1.0);\n    }\n    else\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n}\n", "\n    // flatten the y axis\n    vec2 q = vec2(length(p.xz), p.y);\n    // get the distance to the core of the torus\n    return length(q - vec2(t.x/2.0)) - t.y/2.0;\n}\n", "\n    return p.y;\n}\n\n// ~~~~~~~ signed distance function for sphere\n//  input ps --> specs of sphere\n//        ps.x --> radius\n//        ps.y --> position x\n//        ps.z --> position y\n//        ps.w --> position z\nfloat", "\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ smooth maximum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat", "\n    vec4 dist = mix( o1.xyz, o2.xyz, bf);\n    vec4 col = mix( o1.w, o2.w, bf);\n    return vec4( dist, col);\n}\n", "\n  return d1 - d2;\n}\n", "\n    // ~~~~~~~~ generate random number\n    float random = rand() / float(RAND_MAX);\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) * sin(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(1.0 - random)\n    );\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint2 = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) * sin(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(1.0 - random)\n    );\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint3 = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) * sin(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(1.0 - random)\n    );\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint4 = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) * sin(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(1.0 - random)\n    );\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint5 = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) * sin(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(1.0 - random)\n    );\n    \n    // ~~~~~~~~ generate random point in unit sphere\n    vec3 randomPoint6 = vec3(\n        sqrt(random) * cos(2.0 * PI * (rand() / float(RAND_MAX))),\n        sqrt(random) *", "\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    // ~~~~~~~~~~\n    ", "\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n    // ~~~~~~~ set up\n", "\n    vec3 d = lp - sp;\n    float t = length(d);\n    d /= t;\n    float res = 1.0;\n    for (int i = 0; i < 16; i++)\n    {\n        vec3 p = sp + d * float(i) * t / 16.0;\n        res = min(res, 1.0 - (1.0 - shadow(p)) * 0.5);\n    }\n    return res;\n}\n", "\n    vec3 dir = nor;\n    float dist = 0.0;\n    float maxDist = 1.0;\n    float step = 0.01;\n    float t = 0.0;\n    float tMax = 1.0;\n    float tStep = 0.01;\n    float tMin = 0.0;\n    float tMinStep = 0.01;\n    float tMinMax = 0.0;\n    float tMinMaxStep = 0.01;\n    float tMinMin = 0.0;\n    float tMinMinStep = 0.01;\n    float tMinMinMax = 0.0;\n    float tMinMinMaxStep = 0.01;\n    float tMinMinMin = 0.0;\n    float tMinMinMinStep = 0.01;\n    float tMinMinMinMax = 0.0;\n    float tMinMinMinMaxStep = 0.01;\n    float tMinMinMinMin = 0.0;\n    float tMinMinMinMinStep = 0.01;\n    float tMinMinMinMinMax = 0.0;\n    float tMinMinMinMinMaxStep = 0.01;\n    float tMinMinMinMinMin = 0.0;\n    float tMinMinMinMinMinStep = 0.01;\n    float tMinMinMinMinMinMax = 0.0;\n    float tMinMinMinMinMinMaxStep = 0.01;\n    float tMinMinMinMinMinMin = 0.0;\n    float tMinMinMinMinMinMinStep = 0.01;\n    float tMinMinMinMinMinMinMax = 0.0;\n    float tMinMinMinMinMinMinMaxStep = 0.01;\n    float tMinMinMinMinMinMinMin = 0.0;\n    float tMinMinMinMinMinMinMinStep = 0.01;\n    float tMinMinMinMinMinMinMinMax = 0.0;\n    float tMinMinMinMinMinMinMinMaxStep = 0.01;\n    float tMin", "\n    vec3 n = vec3(0.0);\n    int count = 0;\n    \n    for (int i = -1; i < 2; i++)\n    {\n        for (int j = -1; j < 2; j++)\n        {\n            for (int k = -1; k < 2; k++)\n            {\n                if (i == 0 && j == 0 && k == 0)\n                    continue;\n                \n                vec3 p2 = p + vec3(i, j, k);\n                vec3 n2 = getNormal(p2);\n                \n                if (n2 == vec3(0.0))\n                    continue;\n                \n                n += n2;\n                count++;\n            }\n        }\n    }\n    \n    if (count == 0)\n        return oN;\n    \n    return normalize(n / float(count));\n}\n", "\n    // gamma correction\n    float gamma = 2.2;\n    return pow(c, vec3(1.0/gamma));\n}\n\n// ~~~~~~~ do tone mapping\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> tone mapped output\nvec", "\n    // fog density\n    float fogDensity = fs.x;\n    // fog color lerp exponent\n    float fogExp = fs.y;\n    // fog color\n    vec3 fogColor = mix(fc1,fc2,dot(cRD,lRD));\n    // fog factor\n    float fogFactor = exp2(-fogDensity*fogDensity*d*d*fogExp);\n    // apply fog\n    return c*fogFactor + (1.0-fogFactor)*fogColor;\n}\n", "\n  return cF + lF * d + qF * d * d;\n}\n", "\n    // ~~~~~~~~~~ calculate ray direction\n    // ~~~~~~~~~~ ray direction = (fCoord - cMatrix[0][2], cMatrix[1][2], cMatrix[2][2])\n    // ~~~~~~~~~~ fCoord = (x, y)\n    // ~~~~~~~~~~ cMatrix = (\n    //                     (a, b, c),\n    //                     (d, e, f),\n    //                     (g, h, i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x + b * y + c),\n    //                     (d * x + e * y + f),\n    //                     (g * x + h * y + i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n    //                     (a * x - c),\n    //                     (d * x - f),\n    //                     (g * x - i)\n    //                     )\n    // ~~~~~~~~~~ ray direction = (\n", "\n    vec3 col = vec3(0.0);\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~~~\n    \n    // ~~~~~~~~~~\n    // ~~~~ loop\n    // ~~~~~~~~", "\n    // Get the pixel coordinates\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    // Get the pixel color\n    vec3 color = getPixelColor(x, y);\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}\n\n// The function that calculates the color of a pixel\nvec", "\n    return length(max(abs(p)-radius, 0.0)) - min(max(abs(p.x)-radius.x, max(abs(p.y)-radius.y, abs(p.z)-radius.z)), 0.0);\n}\n// sphere distance field\nfloat", "\n    return length(p) - r;\n}\n\n// simple sphere distance field\nfloat", "\n    // The distance to the surface of the sphere\n    float d = length(p) - 1.0;\n    \n    // The distance to the surface of the torus\n    float d2 = length(vec2(length(p.xz)-0.5, p.y)) - 0.25;\n    \n    // The distance to the surface of the cylinder\n    float d3 = length(vec2(p.x, p.z)) - 0.5;\n    \n    // The distance to the surface of the box\n    float d4 = length(max(abs(p) - vec3(0.5, 0.25, 0.5), 0.0)) - 0.25;\n    \n    // The distance to the surface of the cone\n    float d5 = length(vec2(p.x, p.z)) - p.y;\n    \n    // The distance to the surface of the plane\n    float d6 = p.y;\n    \n    // The distance to the surface of the torus knot\n    float d7 = length(vec2(sin(p.y)*0.5+p.x, cos(p.y)*0.5+p.z)) - 0.25;\n    \n    // The distance to the surface of the mobius strip\n    float d8 = length(vec2(cos(p.y)*0.5+p.x, sin(p.y)*0.5+p.z)) - 0.25;\n    \n    // The distance to the surface of the mobius strip\n    float d9 = length(vec2(cos(p.y)*0.5+p.x, sin(p.y)*0.5+p.z)) - 0.25;\n    \n    // The distance to the surface of the mobius strip\n    float d10 = length(vec2(cos(p.y)*0.5+p.x, sin(p.y)*0.5+p.z)) - 0.25;\n    \n    // The distance to the surface of the mobius strip\n    float d11 = length(vec2(cos(p.y)*0.5+p.x,", "\n    //The complex number to the power of 5\n    vec2 z = c * c * c * c * c;\n    \n    //The real part of the complex number\n    float real = z.x;\n    \n    //The imaginary part of the complex number\n    float imag = z.y;\n    \n    //The real part of the complex number to the power of 5\n    float realPower5 = real * real * real * real * real - 5 * real * real * real * imag * imag + 10 * real * real * imag * imag * imag - 10 * real * imag * imag * imag * imag + real * imag * imag * imag * imag * imag;\n    \n    //The imaginary part of the complex number to the power of 5\n    float imagPower5 = 5 * real * real * real * real * imag - 10 * real * real * real * imag * imag * imag + 10 * real * real * imag * imag * imag * imag - 5 * real * imag * imag * imag * imag * imag + imag * imag * imag * imag * imag * imag * imag;\n    \n    //The complex number to the power of 5\n    return vec2(realPower5, imagPower5);\n}\n\n//Function that returns a complex number to power of 6\nvec", "\n    //The color of the biomorph\n    vec4 color = vec4(0.0);\n    \n    //The position of the biomorph\n    vec2 pos = coord * morphConstant;\n    \n    //The distance from the center of the biomorph\n    float dist = length(pos);\n    \n    //The angle of the biomorph\n    float angle = atan(pos.y, pos.x);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n    \n    //The color of the biomorph\n    color = vec4(1.0);\n", "\n    vec2 uvOffset = uv * constant.xy;\n    vec2 uvOffset2 = uv * constant.zw;\n    vec4 color = vec4(0.0);\n    color += texture(tex, uvOffset);\n    color += texture(tex, uvOffset2);\n    return color * 0.5;\n}\n", "\n  return x - floor(x);\n}\n\n// A saw wave\nfloat", "\n    vec2 p = pB - pA;\n    vec2 q = pA - uv;\n    vec2 r = pA - uv;\n    vec2 s = pB - uv;\n    vec2 t = pB - pA;\n    float a = dot(t, t);\n    float b = dot(t, s);\n    float c = dot(s, s);\n    float d = dot(t, q);\n    float e = dot(s, q);\n    float f = dot(q, q);\n    float g = a * c - b * b;\n    float h = b * e - a * f;\n    float i = c * d - b * e;\n    float j = b * h - c * g;\n    float k = a * f - d * b;\n    float l = c * h - a * i;\n    float m = d * b - a * e;\n    float n = d * c - b * f;\n    float o = e * b - c * d;\n    float p = e * c - a * f;\n    float q = f * c - b * e;\n    float r = f * a - d * d;\n    float s = g * g;\n    float t = h * h;\n    float u = i * i;\n    float v = j * j;\n    float w = k * k;\n    float x = l * l;\n    float y = m * m;\n    float z = n * n;\n    float A = o * o;\n    float B = p * p;\n    float C = q * q;\n    float D = r * r;\n    float E = s * g;\n    float F = t * g;\n    float G = u * g;\n    float H = v * g;\n    float I = w * g;\n    float J = x * g;\n    float K = y * g;\n    float L = z * g;\n    float M = A * g;\n    float N = B * g;\n    float O = C * g;\n    float P = D * g;\n    float Q = E * h;\n    float R = F * h", "\n    // Calculate the line vector\n    vec2 line = pB - pA;\n    // Calculate the line length\n    float lineLength = length(line);\n    // Calculate the line direction\n    vec2 lineDir = line / lineLength;\n    // Calculate the line normal\n    vec2 lineNormal = vec2(-lineDir.y, lineDir.x);\n    // Calculate the line thickness\n    vec2 lineThickness = lineDir * thick.x + lineNormal * thick.y;\n    // Calculate the line thickness\n    vec2 lineThicknessInv = lineDir * thick.x - lineNormal * thick.y;\n    // Calculate the line thickness\n    vec2 lineThicknessInv2 = lineDir * thick.y - lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv3 = lineDir * thick.y + lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv4 = lineDir * thick.x - lineNormal * thick.y;\n    // Calculate the line thickness\n    vec2 lineThicknessInv5 = lineDir * thick.y - lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv6 = lineDir * thick.y + lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv7 = lineDir * thick.x + lineNormal * thick.y;\n    // Calculate the line thickness\n    vec2 lineThicknessInv8 = lineDir * thick.y + lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv9 = lineDir * thick.y - lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv10 = lineDir * thick.x + lineNormal * thick.y;\n    // Calculate the line thickness\n    vec2 lineThicknessInv11 = lineDir * thick.y + lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv12 = lineDir * thick.y - lineNormal * thick.x;\n    // Calculate the line thickness\n    vec2 lineThicknessInv13 = lineDir * thick.x + lineNormal * thick.y;\n    // Calculate the line thickness\n    ", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir = dir / len;\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 perpThick = perp * thick;\n    vec2 perpOutline = perp * outlineThick;\n    vec2 a = pA - perpOutline;\n    vec2 b = pA + perpOutline;\n    vec2 c = pB - perpOutline;\n    vec2 d = pB + perpOutline;\n    vec2 e = a - perpThick;\n    vec2 f = a + perpThick;\n    vec2 g = b - perpThick;\n    vec2 h = b + perpThick;\n    vec2 i = c - perpThick;\n    vec2 j = c + perpThick;\n    vec2 k = d - perpThick;\n    vec2 l = d + perpThick;\n    vec2 m = a - perp;\n    vec2 n = b - perp;\n    vec2 o = c - perp;\n    vec2 p = d - perp;\n    vec2 q = a + perp;\n    vec2 r = b + perp;\n    vec2 s = c + perp;\n    vec2 t = d + perp;\n    vec2 u = m - perpOutline;\n    vec2 v = n - perpOutline;\n    vec2 w = o - perpOutline;\n    vec2 x = p - perpOutline;\n    vec2 y = q + perpOutline;\n    vec2 z = r + perpOutline;\n    vec2 aa = s + perpOutline;\n    vec2 bb = t + perpOutline;\n    vec2 cc = m + perpThick;\n    vec2 dd = n + perpThick;\n    vec2 ee = o + perpThick;\n    vec2 ff = p + perpThick;\n    vec2 gg = q - perpThick;\n    vec2 hh = r - perpThick;\n    vec2 ii = s - perpThick;\n    vec2 jj = t - perpThick;\n    vec2 kk = m + perp;\n    vec2 ll = n + perp;\n    vec2 mm = o + perp;\n    vec2 nn = p + perp;\n    vec2 oo = q - perp;\n", "\n    // Calculate the distance from pA to pB\n    vec2 dir = pB - pA;\n    float dist = length(dir);\n    // If the distance is 0, return 0\n    if (dist == 0.0) {\n        return 0.0;\n    }\n    // Calculate the direction of the line\n    dir = dir / dist;\n    // Calculate the distance from pA to the point\n    vec2 point = uv - pA;\n    // Calculate the distance from pA to the point\n    float distToPoint = length(point);\n    // If the distance is greater than the distance from pA to pB, return 0\n    if (distToPoint > dist) {\n        return 0.0;\n    }\n    // Calculate the distance from pA to the point\n    float distToPointDir = dot(point, dir);\n    // If the distance is less than 0, return 0\n    if (distToPointDir < 0.0) {\n        return 0.0;\n    }\n    // Calculate the distance from pA to the point\n    float distToPointDirSq = distToPointDir * distToPointDir;\n    // If the distance is greater than the distance from pA to pB, return 0\n    if (distToPointDirSq > (dist * dist)) {\n        return 0.0;\n    }\n    // Calculate the distance from pA to the point\n    float distToPointDirSqDist = distToPointDirSq - (dist * dist);\n    // If the distance is less than 0, return 0\n    if (distToPointDirSqDist < 0.0) {\n        return 0.0;\n    }\n    // Calculate the distance from pA to the point\n    float distToPointDirSqDistSq = distToPointDirSqDist * distToPointDirSqDist;\n    // If the distance is greater than the distance from pA to pB, return 0\n    if (distToPointDirSqDistSq > (dist * dist)) {\n        return 0.0;\n    }\n    // Calculate the distance from pA to the point\n    float distToPointDirSqDistSqDist = distToPointDirSqDistSq - (dist * dist);\n    // If the distance is less", "\n    vec2 dir = pB - pA;\n    float len = length(dir);\n    dir = dir / len;\n    vec2 perp = vec2(-dir.y, dir.x);\n    vec2 p = pA - uv;\n    vec2 p1 = pA - uv - perp * thick.x * 0.5;\n    vec2 p2 = pA - uv + perp * thick.x * 0.5;\n    vec2 p3 = pB - uv - perp * thick.x * 0.5;\n    vec2 p4 = pB - uv + perp * thick.x * 0.5;\n    float d1 = max(dot(perp, p - p1), 0.0);\n    float d2 = max(dot(perp, p - p2), 0.0);\n    float d3 = max(dot(perp, p - p3), 0.0);\n    float d4 = max(dot(perp, p - p4), 0.0);\n    float d = min(min(min(d1, d2), d3), d4);\n    float t = d / thick.x;\n    if (t < rounded) {\n        return 1.0;\n    }\n    float t1 = t - rounded;\n    float t2 = t + rounded;\n    if (t1 < 0.0 && t2 < len) {\n        return 1.0;\n    }\n    if (t1 < len && t2 < len) {\n        return 1.0;\n    }\n    return 0.0;\n}\n", "\n    // The outline is a line from pA to pB, with a thickness of outlineThick.\n    // The line is offset by thick.\n    // The line is rounded by rounded.\n    // The line is drawn in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the range 0..1 in UV space.\n    // The line is drawn in the", "\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the uv coordinates\n    // to match the size of the point.\n    //\n    // The point is drawn as a square, so we need to scale the", "\n    vec3 oc = ro - cen;\n    float b = dot( oc, nor );\n    float c = dot( oc, oc ) - rad * rad;\n    float h = b * b - c;\n    if( h < 0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// ray-plane intersection\nfloat", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tN = max(t1,t2);\n    vec3 tF = min(t1,t2);\n    float tmin = max(max(tN.x,tN.y),tN.z);\n    float tmax = min(min(tF.x,tF.y),tF.z);\n    if ( tmax < 0 || tmin > tmax )\n        return vec2(-1.0);\n    return vec2( tmin, tmax );\n}\n\n// ray-box intersection\nvec", "\n    vec3 d = pb - pa;\n    vec3 c = pa + d * 0.5;\n    vec3 e = d * 0.5;\n    vec3 r = vec3(ra,ra,ra);\n    vec3 a = abs(c) - e - r;\n    vec3 b = abs(c) + e - r;\n    vec3 k = max( a, 0.0 );\n    vec3 l = max( b, 0.0 );\n    return bound3( c - l, c + l ) + bound3( c - k, c + k );\n}\n", "\n    vec3  d = pb - pa;\n    vec3  c = ro - pa;\n    float b = dot( c, d );\n    float c = dot( c, c ) - ra*ra;\n    float d = b*b - c;\n    \n    if( d < 0.0 )\n        return vec4( 0.0 );\n    \n    d = sqrt( d );\n    \n    vec4 t = vec4( -b - d, -b + d, -b - d, -b + d );\n    \n    if( t.x < 0.0 )\n        t.x = t.y;\n    if( t.z < 0.0 )\n        t.z = t.w;\n    \n    if( t.x < 0.0 )\n        return vec4( 0.0 );\n    \n    vec3  n = normalize( ro + t.x*rd - pa );\n    \n    return vec4( t.x, n );\n}\n", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tN = max(t1, t2);\n    vec3 tF = min(t1, t2);\n    \n    vec2 ret = vec2(-1.0);\n    if( tF.x < tN.x ) ret = vec2( tF.x, tN.x );\n    if( tF.y < tN.y ) ret = vec2( tF.y, tN.y );\n    if( tF.z < tN.z ) ret = vec2( tF.z, tN.z );\n    \n    if( ret.x < 0.0 ) ret = vec2( tN.x, tF.x );\n    if( ret.y < 0.0 ) ret = vec2( tN.y, tF.y );\n    if( ret.z < 0.0 ) ret = vec2( tN.z, tF.z );\n    \n    if( ret.x < ret.y ) ret = vec2( ret.x, ret.y );\n    else                ret = vec2( ret.y, ret.x );\n    \n    return ret;\n}\n\n// ray-sphere intersection\nvec", "\n    vec3  d = pb - pa;\n    vec3  c = pa - ro;\n    float a = dot(rd,rd);\n    float b = 2.0 * dot(rd,c);\n    float c = dot(c,c) - r*r;\n    float b2ac = b*b - 4.0*a*c;\n    if( b2ac < 0.0 ) return -1.0;\n    float t = ( -b - sqrt(b2ac) ) / ( 2.0 * a );\n    if( t < 0.0 ) t = ( -b + sqrt(b2ac) ) / ( 2.0 * a );\n    if( t < 0.0 ) return -1.0;\n    vec3  p = ro + t*rd;\n    if( dot(p-pa,d) < 0.0 ) t = -1.0;\n    if( dot(p-pb,d) < 0.0 ) t = -1.0;\n    return t;\n}\n", "\n    vec3 normal = vec3(0.0);\n    float dist = length(pos - a);\n    if( dist < r )\n    {\n        normal = normalize(pos - a);\n    }\n    else\n    {\n        dist = length(pos - b);\n        if( dist < r )\n        {\n            normal = normalize(pos - b);\n        }\n    }\n    return normal;\n}\n\n// compute normal\nvec", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return max(t1, t2);\n}\n\n// ray-box intersection in world space\nvec", "\n    vec4 res = vec4( 1e10, 0., 0., 0. );\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 p = ro + res.w * rd;\n        float d = length( p.xz ) - 1.;\n        res.w += d * 0.5;\n        if( d < 0.01 )\n            break;\n    }\n    return res;\n}\n\n// raymarch\nvec", "\n    float phi = i * 2.0 * PI / n;\n    float x = cos(phi);\n    float y = sin(phi);\n    float z = 0.0;\n    return vec3(x, y, z);\n}\n\nvec", "\n    vec3 p = ro;\n    vec3 d = rd;\n    mat3 S = mat3( 1.0 );\n    \n    for( int i = 0; i < 100; i++ )\n    {\n        float t = 1e10;\n        \n        // sphere\n        float d2 = length( p - vec3( 0.0, 0.0, 0.0 ) ) - 1.0;\n        if( d2 < t )\n        {\n            t = d2;\n            S = mat3( 1.0 );\n        }\n        \n        // box\n        vec3 q = abs( p ) - vec3( 1.0 );\n        vec3 r = max( q, 0.0 );\n        vec3 s = r * r;\n        if( s.x + s.y + s.z < t )\n        {\n            t = s.x + s.y + s.z;\n            S = mat3( 1.0 );\n        }\n        \n        // plane\n        if( p.y < t )\n        {\n            t = p.y;\n            S = mat3( 1.0 );\n        }\n        \n        // cylinder\n        float d2 = length( p.xz - vec2( 0.0 ) ) - 1.0;\n        if( d2 < t )\n        {\n            t = d2;\n            S = mat3( 1.0 );\n        }\n        \n        // cone\n        if( p.y < t * tan( 0.5 * PI * 0.25 ) )\n        {\n            t = p.y / tan( 0.5 * PI * 0.25 );\n            S = mat3( 1.0 );\n        }\n        \n        // torus\n        vec2 t2 = vec2( length( p.xz - vec2( 0.0 ) ) - 1.0, p.y );\n        float d2 = t2.x * t2.x + t2.y * t2.y - 0.25;\n        if( d2 < t )\n        {\n            ", "\n    vec2 i = floor( p );\n    vec2 f = smoothstep( 0., 1., fract( p ) );\n    vec2 u = f.xyx + f.yxy;\n    vec2 r = p - i;\n    return mix( mix( grad( i + vec2( 0., 0. ) ),\n                     grad( i + vec2( 1., 0. ) ), u.x ),\n                mix( grad( i + vec2( 0., 1. ) ),\n                     grad( i + vec2( 1., 1. ) ), u.x ), u.y );\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec", "\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat", "\n    vec2 p = uv * orient;\n    return vec3(\n        sin(p.x * 1.0 + p.y * 1.0),\n        sin(p.x * 2.0 + p.y * 2.0),\n        sin(p.x * 3.0 + p.y * 3.0));\n}\n\n// Pattern 2\nvec", "\n    // 1.\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv * 10.;\n    // uv = fract(uv);\n    // uv = uv", "\n    return\n        max( abs( ddx.x * p.x + ddy.x * p.y - 0.5 ),\n             abs( ddx.y * p.x + ddy.y * p.y - 0.5 ) )\n        * 2.0;\n}\n\n// grid ratio\nfloat", "\n\tvec2 e = vec2( 0.001, -0.001 );\n\t\n\t// height\n\tfloat h = map( p );\n\t\n\t// derivatives\n\tvec2 d1 = e.xyyy + e.xyyy;\n\tvec2 d2 = e.xyyy - e.xyyy;\n\t\n\t// height\n\tvec3 n = vec3(\n\t\tmap( p + d1.xyxx ) - h,\n\t\tmap( p + d1.yyxx ) - h,\n\t\tmap( p + d1.xxxy ) - h\n\t);\n\t\n\t// normal\n\treturn normalize( n );\n}\n", "\n    v33 t = a;\n    a = b;\n    b = t;\n}\n", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 add(v33 a,vec3 b){\n    return v33(a.x+b.x,a.y+b.y,a.z+b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 mul(v33 a,vec3 b){\n    return v33(a.x*b.x,a.y*b.y,a.z*b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 div(v33 a,vec3 b){\n    return v33(a.x/b.x,a.y/b.y,a.z/b.z);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nv33 cross(v33 a,vec3 b){\n    return v33(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//swap direction(.b)of [a] with origin(.a)of [b]\nvec", "\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){\n    return v33(a.x-b.x,a.y-b.y,a.z-b.z);\n}\n//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v", "\n  vec2 d;\n  d.x = a.x - b.x;\n  d.y = a.y - b.y;\n  return d;\n}\n//v33-differentials for AA\nvec", "\n    return vec2(dot(a.x,b),dot(a.y,b));\n}\n//dot product on v33s\nfloat", "\n    return v33(\n        a.x*b.x,\n        a.y*b.y,\n        a.z*b.z\n    );\n}\n//dual add\nv33 add(v33 a,v33 b){\n    return v33(\n        a.x+b.x,\n        a.y+b.y,\n        a.z+b.z\n    );\n}\n//dual sub\nv33 sub(v33 a,v33 b){\n    return v33(\n        a.x-b.x,\n        a.y-b.y,\n        a.z-b.z\n    );\n}\n//dual neg\nv33 neg(v33 a){\n    return v33(\n        -a.x,\n        -a.y,\n        -a.z\n    );\n}\n//dual dot\nfloat", "\n    return (mod(floor(p.x/w.x)+floor(p.y/w.y)+floor(p.z/w.z),2.0))==0.0?1.0:0.0;\n}\nfloat", "\n    vec3 q=abs(p);\n    vec3 r=max(q.zyx,q.yzx);\n    vec3 s=max(r.zyx,r.yzx);\n    return 1.0-(s.x+s.y+s.z);\n}\n//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat", "\n    float t=dot(r.xyz,s.xyz);\n    float d=length(r.xyz)-s.w;\n    if(t>d)return 1.;\n    if(t<-d)return 0.;\n    return 1.-t/d;\n}\n//sphere softShadow of(ray,sphere)\nfloat", "\n    return 1.0-smoothstep(s.w,s.w+s.z,dot(u,n));\n}\n//plane occlusion\nfloat", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    \n    vec2 a = p - q;\n    vec2 b = q - r;\n    vec2 c = r - p;\n    \n    vec2 d = a - b;\n    \n    vec2 e = a - c;\n    \n    vec2 f = b - c;\n    \n    vec2 g = a - 2.0 * b + c;\n    \n    vec2 h = a - b;\n    \n    vec2 i = b - c;\n    \n    vec2 j = a - c;\n    \n    vec2 k = a - b;\n    \n    vec2 l = b - c;\n    \n    vec2 m = a - c;\n    \n    vec2 n = a - b;\n    \n    vec2 o = b - c;\n    \n    vec2 p = a - c;\n    \n    vec2 q = a - b;\n    \n    vec2 r = b - c;\n    \n    vec2 s = a - c;\n    \n    vec2 t = a - b;\n    \n    vec2 u = b - c;\n    \n    vec2 v = a - c;\n    \n    vec2 w = a - b;\n    \n    vec2 x = b - c;\n    \n    vec2 y = a - c;\n    \n    vec2 z = a - b;\n    \n    vec2 aa = b - c;\n    \n    vec2 bb = a - c;\n    \n    vec2 cc = a - b;\n    \n    vec2 dd = b - c;\n    \n    vec2 ee = a - c;\n    \n    vec2 ff = a - b;\n    \n    vec2 gg = b - c;\n    \n    vec2 hh = a - c;\n    \n    vec2 ii = a - b;\n    \n    vec2 jj = b - c;\n    \n    vec2 kk = a - c;\n    \n    vec2 ll = a - b;\n    \n    vec2 mm = b - c;\n    \n    vec2 nn = a - c;\n    ", "\n    // Compute the control points\n    vec2 c1 = p0 + (p1 - p0) * 0.5f;\n    vec2 c2 = p1 + (p2 - p1) * 0.5f;\n    \n    // Compute the bounding box\n    vec2 min = min(min(p0, p1), p2);\n    vec2 max = max(max(p0, p1), p2);\n    \n    // Return the bounding box\n    return vec4(min.x, min.y, max.x - min.x, max.y - min.y);\n}\n\n// Approximated BBox to a cubic bezier\nvec", "\n    vec3 d = p1 - p0;\n    vec3 e = p2 - p1;\n    vec3 f = p3 - p2;\n    vec3 g = d + e + f;\n    vec3 h = d * d + e * e + f * f - g * g;\n    vec3 i = h.yzxz + h.zxyz;\n    vec3 j = h.xyzz + h.zzxy;\n    vec3 k = h.yzyx + h.xzyx;\n    vec3 l = h.zyzx + h.zxzy;\n    vec3 m = h.yzxy + h.xyzy;\n    vec3 n = h.zyxz + h.xzzy;\n    vec3 o = h.yxzy + h.zyxy;\n    vec3 p = h.zyzx + h.zxzy;\n    vec3 q = h.zyzx + h.zxzy;\n    vec3 r = h.zyzx + h.zxzy;\n    vec3 s = h.zyzx + h.zxzy;\n    vec3 t = h.zyzx + h.zxzy;\n    vec3 u = h.zyzx + h.zxzy;\n    vec3 v = h.zyzx + h.zxzy;\n    vec3 w = h.zyzx + h.zxzy;\n    vec3 x = h.zyzx + h.zxzy;\n    vec3 y = h.zyzx + h.zxzy;\n    vec3 z = h.zyzx + h.zxzy;\n    vec3 A = h.zyzx + h.zxzy;\n    vec3 B = h.zyzx + h.zxzy;\n    vec3 C = h.zyzx + h.zxzy;\n    vec3 D = h.zyzx + h.zxzy;\n    vec3 E = h.zyzx + h.zxzy;\n    vec3 F = h.zyzx + h.zxzy;\n    vec3 G = h.zyzx + h.zxzy;\n    vec3 H = h.zyzx + h.zxzy;\n    vec3 I = h.zyzx + h.zxzy;\n    vec3 J = h.", "\n    // BBox of a cubic bezier\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox.html\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-simple.html\n    vec2 p = p0;\n    vec2 q = p3;\n    vec2 r = p1 - p0;\n    vec2 s = p2 - p3;\n    \n    // BBox of a line segment\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line.html\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line-simple.html\n    vec2 a = p + r;\n    vec2 b = q + s;\n    \n    // BBox of a line segment\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line.html\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line-simple.html\n    vec2 c = a + s;\n    vec2 d = b + r;\n    \n    // BBox of a line segment\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line.html\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line-simple.html\n    vec2 e = p + s;\n    vec2 f = q + r;\n    \n    // BBox of a line segment\n    // http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-bbox-line.html\n    // http://www.cs.mtu", "\n    // https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n    // https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    vec2 p = p0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec2 p1 = mix(p0, p1, pos.x);\n        vec2 p2 = mix(p1, p2, pos.x);\n        vec2 p3 = mix(p2, p3, pos.x);\n        p = mix(p2, p3, pos.y);\n    }\n    return p;\n}\n\n// https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n// https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\nvec", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 s = cross( rd, e2 );\n    float det = dot( e1, s );\n    if( det < 0.0001 )\n        return vec3( -1.0 );\n    vec3 q = ro - v0;\n    float t = dot( q, s ) / det;\n    if( t < 0.0 || t > 1.0 )\n        return vec3( -1.0 );\n    vec3 r = cross( q, e1 );\n    float u = dot( rd, r ) / det;\n    if( u < 0.0 || u > 1.0 )\n        return vec3( -1.0 );\n    float v = 1.0 - t - u;\n    if( v < 0.0 || v > 1.0 )\n        return vec3( -1.0 );\n    return vec3( t, u, v );\n}\n", "\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 p = cross( nor, e2 );\n    float det = dot( e1, p );\n    if( det < 0.0 )\n    {\n        return 1.0;\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n", "\n    vec2 p = pos - A;\n    vec2 q = B - A;\n    vec2 r = C - A;\n    \n    vec2 s = p - q;\n    vec2 t = p - r;\n    \n    float a = dot( q, q );\n    float b = dot( q, r );\n    float c = dot( r, r );\n    float d = dot( q, s );\n    float e = dot( r, t );\n    float f = dot( s, s );\n    \n    float g = a * c - b * b;\n    float h = b * e - c * d;\n    float i = a * f - d * d;\n    \n    float j = h * h - g * i;\n    \n    if( j < 0.0 )\n        return length( p - q * clamp( dot( p, q ) / a, 0.0, 1.0 ) );\n    \n    float k = h + sqrt( j );\n    \n    if( k < 0.0 )\n        return length( p - r * clamp( dot( p, r ) / a, 0.0, 1.0 ) );\n    \n    float l = k / g;\n    float m = e + l * b;\n    \n    if( m > 0.0 )\n    {\n        float n = sqrt( m * m - i );\n        \n        return n - l * c;\n    }\n    \n    return length( p - r * clamp( ( d - e ) / a, 0.0, 1.0 ) );\n}\n", "\n    vec2 q = abs(p);\n    float h = he - q.y;\n    return max(q.x - r1, h - r2);\n}\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat", "\n    vec2 q = abs(p)-vec2(ra,rb);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - a.y;\n}\n\n// 2D box\nfloat", "\n    const float eps = 0.001;\n    return normalize(\n        pos - vec3(\n            sdf( vec3(pos.x - eps, pos.y, pos.z) ),\n            sdf( vec3(pos.x, pos.y - eps, pos.z) ),\n            sdf( vec3(pos.x, pos.y, pos.z - eps) )\n        )\n    );\n}\n", "\n    float res = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        float t = mix( tmin, tmax, float(i) / float(8) );\n        float h = texture( shadowMap, ro + rd * t).r;\n        res = min(res, h);\n    }\n    return res;\n}\n", "\n    return fract(sin(dot(q,ivec2(127.1,311.7))) * 43758.5453);\n}\n\n// random vector\nvec", "\n    vec2 i = floor( x );\n    vec2 f = fract( x );\n    \n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    \n    return mix( mix( dot( pnoise( i + vec2( 0.0, 0.0 ), p ), u ),\n                     dot( pnoise( i + vec2( 1.0, 0.0 ), p ), u - vec2( 1.0, 0.0 ) ),\n                     u.x ),\n                mix( dot( pnoise( i + vec2( 0.0, 1.0 ), p ), u - vec2( 0.0, 1.0 ) ),\n                     dot( pnoise( i + vec2( 1.0, 1.0 ), p ), u - vec2( 1.0, 1.0 ) ),\n                     u.x ),\n                u.y );\n}\n\n// perlin noise\nfloat", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2  shift = vec2(100);\n    for (int i = 0; i < p; i++)\n    {\n        v += a * (noise(x));\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// perlin noise\nfloat", "\n    vec3 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// generic ellipsoid - exact distance: https://www.shadertoy.com/view/ldX3zS\nfloat", "\n    // symmetric ellipsoid\n    // r = (rx, ry, rz)\n    // p = (px, py, pz)\n    \n    // map to unit sphere\n    // p = (px/rx, py/ry, pz/rz)\n    \n    // unit sphere\n    // p = (px, py, pz)\n    \n    // map back to ellipsoid\n    // p = (px*rx, py*ry, pz*rz)\n    \n    // distance to unit sphere\n    float d = length(p);\n    \n    // distance to ellipsoid\n    // d = length(p*r)\n    \n    return d - 1.0;\n}\n", "\n    return length( p - r * clamp( dot( p, r ), 0.0, 1.0 ) ) - r.x;\n}\n\n// generic ellipsoid - good approximated distance\nfloat", "\n    // p = p - c;\n    // r = r * s;\n    // c = c * s;\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    // p = p * (1.0 / s);\n    // r = r * (1.0 / s);\n    \n    //", "\n    return abs( mod( p.x + p.y, 2.0 ) - 1.0 );\n}\n\nfloat", "\n    return a * x + ( 1 - a ) * x * x * x;\n}\n\n// Schlick normal distribution function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat", "\n    return (x - floor(x)) * p;\n}\n\n// biased triangle\nfloat", "\n    vec3 c = vec3(0.0);\n    float a = 1.0 - h;\n    float b = h * h * a;\n    float c1 = 1.0 - b;\n    float c2 = c1 * a;\n    float c3 = c2 * a;\n    float c4 = c3 * a;\n    float c5 = c4 * a;\n    float c6 = c5 * a;\n    float c7 = c6 * a;\n    float c8 = c7 * a;\n    float c9 = c8 * a;\n    float c10 = c9 * a;\n    float c11 = c10 * a;\n    float c12 = c11 * a;\n    float c13 = c12 * a;\n    float c14 = c13 * a;\n    float c15 = c14 * a;\n    float c16 = c15 * a;\n    float c17 = c16 * a;\n    float c18 = c17 * a;\n    float c19 = c18 * a;\n    float c20 = c19 * a;\n    float c21 = c20 * a;\n    float c22 = c21 * a;\n    float c23 = c22 * a;\n    float c24 = c23 * a;\n    float c25 = c24 * a;\n    float c26 = c25 * a;\n    float c27 = c26 * a;\n    float c28 = c27 * a;\n    float c29 = c28 * a;\n    float c30 = c29 * a;\n    float c31 = c30 * a;\n    float c32 = c31 * a;\n    float c33 = c32 * a;\n    float c34 = c33 * a;\n    float c35 = c34 * a;\n    float c36 = c35 * a;\n    float c37 = c36 * a;\n    float c38 = c37 * a", "\n    vec3  d  = pb - pa;\n    vec3  rd = rd;\n    vec3  ro = ro - pa;\n    float a  = dot( rd, rd );\n    float b  = dot( ro, rd );\n    float c  = dot( ro, ro ) - r * r;\n    float h  = b * b - a * c;\n    if( h < 0.0 ) return -1.0;\n    h = sqrt( h );\n    float t = ( -b - h ) / a;\n    if( t > 0.0 )\n    {\n        vec3  p  = ro + t * rd;\n        vec3  pp = p - pa;\n        float q = dot( pp, d );\n        if( q < 0.0 ) t = ( -b + h ) / a;\n        if( t > 0.0 )\n        {\n            pp = p - pb;\n            float q = dot( pp, d );\n            if( q < 0.0 ) t = -1.0;\n        }\n    }\n    return t;\n}\n", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = dot(pa, ba);\n    float r = length(pa - ba * clamp(h / dot(ba, ba), 0.0, 1.0));\n    return r - (ra + rb);\n}\n\nfloat", "\n    // ray-plane intersection\n    float t = dot( a - ro, b - a ) / dot( rd, b - a );\n    \n    // check if the ray is in the shadow\n    if( t < 0.0 )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    vec3 p = ro + t * rd;\n    if( length( p - a ) > r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( length( p - b ) > r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < 0.0 )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the ray is in the cap\n    if( dot( p - a, p - b ) < r * r )\n        return 1.0;\n    \n    // check if the", "\n    vec2 p = uv * rad1;\n    float d = length(p);\n    if (d > th)\n    {\n        vec2 q = p * (rad1 - th) / d;\n        vec2 r = p - q;\n        return r * (rad1 - th) / d + q * (rad1 - th) / d;\n    }\n    else\n    {\n        return p * (rad1 - th) / d;\n    }\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec", "\n    // p = p - c;\n    // p = vec2( abs(p.x), p.y );\n    // return length(p) - r;\n    return length(p) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat", "\n    vec3 n = vec3( 0.0 );\n    float r = length( pos );\n    if( r < 1.0 )\n    {\n        n = pos * ( 1.0 - r ) * 4.0;\n    }\n    return n;\n}\n\n// df/dx,df/dy,df/dz,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec", "\n    // rotate the point\n    vec2 pa = p * sca;\n    // rotate the arc\n    vec2 pb = pa * scb;\n    // get the distance\n    float d = length(pb) - ra - rb;\n    // get the angle\n    float a = abs(atan(pb.y, pb.x)) - ra - rb;\n    // return the minimum\n    return min(d, a);\n}\n", "\n    float res = 0.0;\n    float t = mint;\n    float tinc = 0.01;\n    for (int i = 0; i < 100; i++)\n    {\n        if (t > tmax)\n            break;\n        vec3 pos = ro + t * rd;\n        float dist = length(pos);\n        float dist2 = dist * dist;\n        float dist3 = dist * dist2;\n        float dist4 = dist * dist3;\n        float dist5 = dist * dist4;\n        float dist6 = dist * dist5;\n        float dist7 = dist * dist6;\n        float dist8 = dist * dist7;\n        float dist9 = dist * dist8;\n        float dist10 = dist * dist9;\n        float dist11 = dist * dist10;\n        float dist12 = dist * dist11;\n        float dist13 = dist * dist12;\n        float dist14 = dist * dist13;\n        float dist15 = dist * dist14;\n        float dist16 = dist * dist15;\n        float dist17 = dist * dist16;\n        float dist18 = dist * dist17;\n        float dist19 = dist * dist18;\n        float dist20 = dist * dist19;\n        float dist21 = dist * dist20;\n        float dist22 = dist * dist21;\n        float dist23 = dist * dist22;\n        float dist24 = dist * dist23;\n        float dist25 = dist * dist24;\n        float dist26 = dist * dist25;\n        float dist27 = dist * dist26;\n        float dist28 = dist * dist27;\n        float dist29 = dist * dist28;\n        float dist30 = dist * dist29;\n        float dist31 = dist * dist30;\n        float dist32 = dist * dist31;\n        float dist33 = dist * dist32;\n        float dist34 = dist * dist33;\n        float dist35 = dist * dist34;\n        float", "\n    vec2 e = vec2( 0.001, 0.0 );\n    \n    return normalize( e.xyy * f( pos + e.xyy, time ) +\n                      e.yyx * f( pos + e.yyx, time ) +\n                      e.yxy * f( pos + e.yxy, time ) +\n                      e.xxx * f( pos + e.xxx, time ) );\n}\n", "\n    float res = 0.0;\n    float t = mint;\n    float tinc = 0.01;\n    float tmax = 10.0;\n    for (int i = 0; i < 100; i++)\n    {\n        if (t > tmax)\n            break;\n        vec3 pos = ro + t * rd;\n        float dist = length(pos);\n        float dist2 = dist * dist;\n        float dist3 = dist * dist2;\n        float dist4 = dist * dist3;\n        float dist5 = dist * dist4;\n        float dist6 = dist * dist5;\n        float dist7 = dist * dist6;\n        float dist8 = dist * dist7;\n        float dist9 = dist * dist8;\n        float dist10 = dist * dist9;\n        float dist11 = dist * dist10;\n        float dist12 = dist * dist11;\n        float dist13 = dist * dist12;\n        float dist14 = dist * dist13;\n        float dist15 = dist * dist14;\n        float dist16 = dist * dist15;\n        float dist17 = dist * dist16;\n        float dist18 = dist * dist17;\n        float dist19 = dist * dist18;\n        float dist20 = dist * dist19;\n        float dist21 = dist * dist20;\n        float dist22 = dist * dist21;\n        float dist23 = dist * dist22;\n        float dist24 = dist * dist23;\n        float dist25 = dist * dist24;\n        float dist26 = dist * dist25;\n        float dist27 = dist * dist26;\n        float dist28 = dist * dist27;\n        float dist29 = dist * dist28;\n        float dist30 = dist * dist29;\n        float dist31 = dist * dist30;\n        float dist32 = dist * dist31;\n        float dist33 = dist * dist32;\n        float dist34 = dist * dist33;\n        float dist", "\n    // compute the checkerboard pattern\n    vec2 q = floor( p );\n    vec2 r = fract( p );\n    vec2 s = r*r*(3.0-2.0*r);\n    float c = s.x*s.y;\n    \n    // compute the gradient\n    vec2 d = vec2( dpdx.x*r.x + dpdy.x*r.y,\n                   dpdx.y*r.x + dpdy.y*r.y );\n    \n    // return the gradient\n    return c*d.x + (1.0-c)*d.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n\treturn floor( x * k + 0.5 ) / k;\n}\n\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat", "\n    vec3 skylight_col = vec3(0.0);\n    float skylight_dist = 0.0;\n    float skylight_max_dist = 1000.0;\n    float skylight_min_dist = 0.0;\n    float skylight_min_dist_sq = skylight_min_dist * skylight_min_dist;\n    float skylight_max_dist_sq = skylight_max_dist * skylight_max_dist;\n    float skylight_max_dist_sq_min_dist_sq = skylight_max_dist_sq - skylight_min_dist_sq;\n    float skylight_max_dist_sq_min_dist_sq_inv = 1.0 / skylight_max_dist_sq_min_dist_sq;\n    float skylight_min_dist_sq_inv = 1.0 / skylight_min_dist_sq;\n    float skylight_min_dist_sq_inv_min_dist_sq_inv = skylight_min_dist_sq_inv - skylight_max_dist_sq_min_dist_sq_inv;\n    float skylight_min_dist_sq_inv_min_dist_sq_inv_inv = 1.0 / skylight_min_dist_sq_inv_min_dist_sq_inv;\n    float skylight_min_dist_sq_inv_min_dist_sq_inv_inv_min_dist_sq_inv = skylight_min_dist_sq_inv_min_dist_sq_inv_inv - skylight_min_dist_sq_inv;\n    float skylight_min_dist_sq_inv_min_dist_sq_inv_inv_min_dist_sq_inv_inv = 1.0 / skylight_min_dist_sq_inv_min_dist_sq_inv_inv_min_dist_sq_inv;\n    float skylight_min_dist_sq_inv_min_dist_sq_inv_inv_min_dist_sq_inv_inv_min_dist_sq_inv = skylight_min_dist_sq_inv_min_dist_sq_inv_inv_min", "\n    // the scene color\n    vec3 color = vec3(0);\n    // the distance to the surface\n    float dist = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    //get the camera vector\n    vec2 camera_vector = (coord - resolution / 2.0) / resolution.y;\n    //return the camera vector\n    return camera_vector;\n}\n\n/*\nnow we need a way to calculate the color of a pixel\nthis function does that\n*/\nvec", "\n    vec2 q = p.xy * c - p.z * vec2(c.y, -c.x);\n    return length(q) - ra;\n}\n\n// c is the sin/cos of the desired cone angle\nfloat", "\n    if (material == 0) {\n        // White\n        return vec3(1.0, 1.0, 1.0);\n    } else if (material == 1) {\n        // Red\n        return vec3(1.0, 0.0, 0.0);\n    } else if (material == 2) {\n        // Green\n        return vec3(0.0, 1.0, 0.0);\n    } else if (material == 3) {\n        // Blue\n        return vec3(0.0, 0.0, 1.0);\n    } else if (material == 4) {\n        // Yellow\n        return vec3(1.0, 1.0, 0.0);\n    } else if (material == 5) {\n        // Cyan\n        return vec3(0.0, 1.0, 1.0);\n    } else if (material == 6) {\n        // Magenta\n        return vec3(1.0, 0.0, 1.0);\n    } else if (material == 7) {\n        // Black\n        return vec3(0.0, 0.0, 0.0);\n    } else if (material == 8) {\n        // White\n        return vec3(1.0, 1.0, 1.0);\n    } else if (material == 9) {\n        // Red\n        return vec3(1.0, 0.0, 0.0);\n    } else if (material == 10) {\n        // Green\n        return vec3(0.0, 1.0, 0.0);\n    } else if (material == 11) {\n        // Blue\n        return vec3(0.0, 0.0, 1.0);\n    } else if (material == 12) {\n        // Yellow\n        return vec3(1.0, 1.0, 0.0);\n    } else if (material == 13) {\n        // Cyan\n        return vec3(0.0, 1.0, 1.0);\n    } else if (", "\n    if (material == 0) {\n        return 0.0;\n    } else if (material == 1) {\n        return 0.1;\n    } else if (material == 2) {\n        return 0.2;\n    } else if (material == 3) {\n        return 0.3;\n    } else if (material == 4) {\n        return 0.4;\n    } else if (material == 5) {\n        return 0.5;\n    } else if (material == 6) {\n        return 0.6;\n    } else if (material == 7) {\n        return 0.7;\n    } else if (material == 8) {\n        return 0.8;\n    } else if (material == 9) {\n        return 0.9;\n    } else if (material == 10) {\n        return 1.0;\n    } else {\n        return 0.0;\n    }\n}\n", "\n    switch (material) {\n        case 0:\n            return 1.0;\n        case 1:\n            return 1.5;\n        case 2:\n            return 2.0;\n        case 3:\n            return 2.5;\n        case 4:\n            return 3.0;\n        case 5:\n            return 3.5;\n        case 6:\n            return 4.0;\n        case 7:\n            return 4.5;\n        case 8:\n            return 5.0;\n        case 9:\n            return 5.5;\n        case 10:\n            return 6.0;\n        case 11:\n            return 6.5;\n        case 12:\n            return 7.0;\n        case 13:\n            return 7.5;\n        case 14:\n            return 8.0;\n        case 15:\n            return 8.5;\n        case 16:\n            return 9.0;\n        case 17:\n            return 9.5;\n        case 18:\n            return 10.0;\n        case 19:\n            return 10.5;\n        case 20:\n            return 11.0;\n        case 21:\n            return 11.5;\n        case 22:\n            return 12.0;\n        case 23:\n            return 12.5;\n        case 24:\n            return 13.0;\n        case 25:\n            return 13.5;\n        case 26:\n            return 14.0;\n        case 27:\n            return 14.5;\n        case 28:\n            return 15.0;\n        case 29:\n            return 15.5;\n        case 30:\n            return 16.0;\n        case 31:\n            return 16.5;\n        case 32:\n            return 17.0;\n        case 3", "\n  // Get the material's color.\n  vec4 color = get_material_color(material);\n  // Get the material's alpha value.\n  float alpha = color.a;\n  // Return the material's opacity.\n  return alpha;\n}\n", "\n    // Get the plane of the triangle\n    vec3 tri_normal = cross(tri_b - tri_a, tri_c - tri_a);\n    \n    // Get the distance from the line to the plane\n    float dist = dot(tri_normal, line_a - tri_a);\n    \n    // If the distance is 0, the line is on the plane\n    if (dist == 0.0) {\n        // If the line is on the plane, check if it intersects the triangle\n        // by checking if the line is between the triangle's vertices\n        vec3 line_dir = line_b - line_a;\n        vec3 tri_dir = tri_b - tri_a;\n        \n        // Get the distance from the line to the triangle\n        float line_dist = dot(line_dir, tri_dir) / length(tri_dir);\n        \n        // If the line is between the triangle's vertices, the line intersects the triangle\n        if (line_dist > 0.0 && line_dist < 1.0) {\n            // Get the point of intersection\n            vec3 tri_point = tri_a + line_dist * tri_dir;\n            \n            // Get the distance from the point of intersection to the triangle\n            float tri_dist = dot(tri_normal, tri_point - tri_a);\n            \n            // If the distance is 0, the point of intersection is on the plane\n            if (tri_dist == 0.0) {\n                // If the point of intersection is on the plane, check if it is between the triangle's vertices\n                vec3 tri_dir_a = tri_c - tri_a;\n                vec3 tri_dir_b = tri_b - tri_a;\n                \n                // Get the distance from the point of intersection to the triangle\n                float tri_dist_a = dot(tri_dir_a, tri_point - tri_a) / length(tri_dir_a);\n                float tri_dist_b = dot(tri_dir_b, tri_point - tri_a) / length(tri_dir_b);\n                \n                // If the point of intersection is between the triangle's vertices, the line intersects the triangle\n                if", "\n    vec3 ab = tri_b - tri_a;\n    vec3 ac = tri_c - tri_a;\n    return cross(ab, ac);\n}\n", "\n    vec3 z_axis = normalize(camera_position - camera_target);\n    vec3 x_axis = normalize(cross(vec3(0.0, 1.0, 0.0), z_axis));\n    vec3 y_axis = cross(z_axis, x_axis);\n    \n    mat3 look_at_matrix = mat3(\n        x_axis.x, y_axis.x, z_axis.x,\n        x_axis.y, y_axis.y, z_axis.y,\n        x_axis.z, y_axis.z, z_axis.z\n    );\n    \n    return look_at_matrix;\n}\n", "\n    // TODO: implement this\n    // Hint: you can use the intersect() function in triangle.cpp\n    // Hint: you can use the distance() function in vec3.cpp\n    // Hint: you can use the min() function in stdlib.h\n    // Hint: you can use the cast_ray_result struct\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the ray_origin and ray_target parameters\n    // Hint: you can use the triangles vector in scene.cpp\n    // Hint: you can use the", "\n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_direction = ray_target - ray_origin;\n    float ray_length = length(ray_direction);\n    ray_direction = ray_direction / ray_length;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_end = ray_origin + ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_start = ray_end - ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_end = ray_start + ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_start = ray_end - ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_end = ray_start + ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_start = ray_end - ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_end = ray_start + ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n    vec3 ray_start = ray_end - ray_length * ray_direction;\n    \n    // The ray is cast from the surface to the light source.\n    // The light source is at the origin of the scene.\n", "\n  return noise( x * 1.0 );\n}\n\n// Basic noise\nfloat", "\n    // Get the fractional part of the input\n    float f = mod( p, 1.0 );\n    \n    // Get the integer part of the input\n    int i = int( p );\n    \n    // Calculate the noise value\n    float n = mix(\n        // Linear interpolation between the two closest values\n        mix(\n            // The value at the left of the input\n            grad( p - 1.0 ),\n            // The value at the right of the input\n            grad( p + 1.0 ),\n            // The interpolation factor\n            f\n        ),\n        // The value at the top of the input\n        grad( p + 1.0 ),\n        // The interpolation factor\n        smoothstep( 0.0, 1.0, f )\n    );\n    \n    // Return the noise value\n    return n;\n}\n", "\n    n = (n << 13) ^ n;\n    return (float)( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n}\n\n// float hash copied from Hugo Elias\nfloat", "\n    return fract(sin(p)*43758.5453123);\n}\n\n// gradient noise\nvec", "\n    float v = 0.0;\n    float g = 1.0;\n    for ( int i = 0; i < 4; i++ )\n    {\n        v += g * noise( x );\n        x *= G;\n        g *= 0.5;\n    }\n    return v;\n}\n\n// fbm\nfloat", "\n    // The quadratic polynomial is\n    //   ax^2 + bx + c\n    // where\n    //   a = 1\n    //   b = 2 * dot( p, n )\n    //   c = dot( p, p ) - 1\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are real if\n    //   b^2 - 4ac >= 0\n    //\n    // The solutions are equal if\n    //   b^2 - 4ac = 0\n    //\n    // The solutions are complex if\n    //   b^2 - 4ac < 0\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //\n    // The solutions are\n    //   x = ( -b +/- sqrt( b^2 - 4ac ) ) / 2a\n    //", "\n    // Convert p to a 4D point in a unit sphere\n    vec4 p = vec4( pb, 1.0 );\n    p = normalize( p );\n    \n    // Convert p to a cubic polynomial\n    // a = p.x^3 + p.y^3 + p.z^3\n    // b = p.x^2 + p.y^2 + p.z^2\n    // c = p.x + p.y + p.z\n    // d = 1\n    \n    // The solutions of the cubic are\n    // x = (a + b + c + d)/4\n    // y = (a - b + c - d)/4\n    // z = (a + b - c - d)/4\n    // w = (a - b - c + d)/4\n    \n    // The color is the average of the solutions\n    // (x + y + z + w)/4\n    \n    // The color is the average of the solutions\n    // (a + b + c + d)/4\n    \n    // The color is the average of the solutions\n    // (a - b - c - d)/4\n    \n    // The color is the average of the solutions\n    // (a - b + c - d)/4\n    \n    // The color is the average of the solutions\n    // (a + b - c - d)/4\n    \n    // The color is the average of the solutions\n    // (a - b - c + d)/4\n    \n    // The color is the average of the solutions\n    // (a + b + c - d)/4\n    \n    // The color is the average of the solutions\n    // (a - b + c + d)/4\n    \n    // The color is the average of the solutions\n    // (a + b - c + d)/4\n    \n    // The color is the average of the solutions\n    // (a - b - c - d)/4\n    \n    // The color is the average of the solutions\n    // (a + b + c + d)/4\n    \n    // The color is the average of the solutions\n    // (a - b - c + d)/4\n    \n    // The color is the average of the", "\n    vec3 m = abs(ro - cen) - rad;\n    vec3 k = max(m,0.0);\n    float d = length(max(k,0.0)) + min(max(k.x,max(k.y,k.z)),0.0);\n    return vec4(d, k.x, k.y, k.z);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec", "\n    vec3  p  = ro - cen;\n    float b  = dot( p, rd );\n    vec3  q  = p - b*rd;\n    float h  = max( 0.0, dot( q, q ) - dot( rad, rad ) );\n    float d  = sqrt( h ) - b;\n    return d;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec", "\n    float res = 1.0;\n    float t = tmax;\n    float t1 = tmax;\n    float t2 = tmax;\n    float t3 = tmax;\n    float t4 = tmax;\n    float t5 = tmax;\n    float t6 = tmax;\n    float t7 = tmax;\n    float t8 = tmax;\n    float t9 = tmax;\n    float t10 = tmax;\n    float t11 = tmax;\n    float t12 = tmax;\n    float t13 = tmax;\n    float t14 = tmax;\n    float t15 = tmax;\n    float t16 = tmax;\n    float t17 = tmax;\n    float t18 = tmax;\n    float t19 = tmax;\n    float t20 = tmax;\n    float t21 = tmax;\n    float t22 = tmax;\n    float t23 = tmax;\n    float t24 = tmax;\n    float t25 = tmax;\n    float t26 = tmax;\n    float t27 = tmax;\n    float t28 = tmax;\n    float t29 = tmax;\n    float t30 = tmax;\n    float t31 = tmax;\n    float t32 = tmax;\n    float t33 = tmax;\n    float t34 = tmax;\n    float t35 = tmax;\n    float t36 = tmax;\n    float t37 = tmax;\n    float t38 = tmax;\n    float t39 = tmax;\n    float t40 = tmax;\n    float t41 = tmax;\n    float t42 = tmax;\n    float t43 = tmax;\n    float t44 = tmax;\n    float t45 = tmax;\n    float t46 = tmax;\n    float t47 = tmax;\n    float t48 = tmax;\n    float t49 = tmax;\n    float t50 = tmax;\n    float", "\n  seed = seed * 16807.0 - 1.0;\n  return (seed < 0.0)? (seed + 2147483647.0) : seed;\n}\nfloat", "\n    return a + b * cos( 6.28318 * (c * t + d) );\n}\n\n//Inigo Quilez's Palettize Function\n//https://www.shadertoy.com/view/ll2GD3\nvec", "\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(la, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - ra;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = a + h * ba;\n    vec2  dq = p - q;\n    float d = length(dq);\n    float k = d - r;\n    return vec4(dq, k);\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    vec2 q = abs(p)-b;\n    vec2 d = q-vec2(r);\n    vec2 e = q-vec2(r,0);\n    vec2 f = q-vec2(0,r);\n    vec2 g = q-vec2(r,r);\n    \n    float x = min(min(min(\n        max(max(min(max(min(max(min(max(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min", "\n    vec2 d = abs(p) - b;\n    return vec3(min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n                sign(p.x)*sign(d.x),\n                sign(p.y)*sign(d.y));\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - vec2(r);\n    vec2 a = q * 0.5;\n    vec2 b = q * 0.5 - vec2(band);\n    \n    float x = length(a);\n    float y = length(b);\n    float z = r * 2.0 - band * 2.0;\n    float w = length(p);\n    \n    return vec4( x, y, z, w );\n}\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec", "\n    float d = 1e10;\n    for (int i = 0; i < 5; i++)\n    {\n        int j = i + 1;\n        if (j == 5) j = 0;\n        vec2 a = verts[i], b = verts[j];\n        vec2 pa = p - a, ba = b - a;\n        float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n        vec2 q = a + h*ba;\n        d = min(d, length(p - q));\n    }\n    return d - r;\n}\n\n// https://www.shadertoy.com/view/4ds3z2\nvec", "\n    vec2 v = p - verts[0];\n    vec2 v1 = p - verts[1];\n    vec2 v2 = p - verts[2];\n    vec2 v3 = p - verts[3];\n    vec2 v4 = p - verts[4];\n    \n    float a = length( v1 - v2 );\n    float b = length( v2 - v3 );\n    float c = length( v3 - v4 );\n    float d = length( v4 - v1 );\n    \n    float s = ( a + b + c + d ) * 0.5;\n    float area = sqrt( s * ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) );\n    \n    float x = ( a * b * c * d ) / ( 4.0 * area );\n    \n    float y = ( a * b * c * d ) / ( 4.0 * area * r );\n    \n    float z = ( a + b + c + d ) / 4.0;\n    \n    float w = length( p - verts[0] );\n    \n    return vec4( x, y, z, w );\n}\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec3( dot(pa,pa) - h*h*dot(ba,ba),\n                 pa - h*ba,\n                 ba );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = abs(p);\n    vec2 d = q - r;\n    vec2 e = q - r * vec2(1., 0.);\n    vec2 f = q - r * vec2(0., 1.);\n    vec2 g = q - r * vec2(1., 1.);\n    \n    vec2 h = q - r * vec2(1., 0.) - r * vec2(0., 1.);\n    \n    vec2 i = q - r * vec2(1., 1.) - r * vec2(1., 0.);\n    \n    vec2 j = q - r * vec2(1., 1.) - r * vec2(0., 1.);\n    \n    vec2 k = q - r * vec2(1., 1.) - r * vec2(1., 1.);\n    \n    return vec3(\n        min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(", "\n  // The conic is X * x = 0.\n  // The point is p.\n  // The two tangents are tan1 and tan2.\n  // The two tangents are perpendicular to the two normals.\n  // The two normals are X * tan1 = 0 and X * tan2 = 0.\n  // The two normals are perpendicular to the two tangents.\n  // The two normals are p * tan1 = 0 and p * tan2 = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the point.\n  // The two normals are X * p = 0 and X * p = 0.\n  // The two normals are perpendicular to the", "\n    if (b.x == 0.0) b.x = 0.0001;\n    if (b.y == 0.0) b.y = 0.0001;\n    if (b.z == 0.0) b.z = 0.0001;\n    return a / b;\n}\n\n//if a is less than b, return a. if a is greater than b, return b.\nfloat", "\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        vec3(c, 0.0, s),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-s, 0.0, c));\n    return m * p;\n}\n\nvec", "\n    return 1 - (x / R);\n}\n\n// Linear falloff\n// x: distance\n// R: radius\nfloat", "\n    float k = 1.0 / (1.0 - e);\n    return k * R * R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// e: energy\n// R: radius\n// r: distance\nfloat", "\n    float k = (a - b) / (1 - e);\n    return k * R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\n// k: lipschitz constant\nfloat", "\n    vec3 d = p - c;\n    return e * (1.0 - length(d) / R);\n}\n\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat", "\n    vec3 d = b - a;\n    float dlen = length(d);\n    vec3 n = normalize(d);\n    vec3 p = a + d * 0.5f;\n    vec3 q = p - c;\n    float qlen = length(q);\n    float qlen2 = qlen * qlen;\n    float qlen3 = qlen2 * qlen;\n    float qlen4 = qlen3 * qlen;\n    float qlen5 = qlen4 * qlen;\n    float qlen6 = qlen5 * qlen;\n    float qlen7 = qlen6 * qlen;\n    float qlen8 = qlen7 * qlen;\n    float qlen9 = qlen8 * qlen;\n    float qlen10 = qlen9 * qlen;\n    float qlen11 = qlen10 * qlen;\n    float qlen12 = qlen11 * qlen;\n    float qlen13 = qlen12 * qlen;\n    float qlen14 = qlen13 * qlen;\n    float qlen15 = qlen14 * qlen;\n    float qlen16 = qlen15 * qlen;\n    float qlen17 = qlen16 * qlen;\n    float qlen18 = qlen17 * qlen;\n    float qlen19 = qlen18 * qlen;\n    float qlen20 = qlen19 * qlen;\n    float qlen21 = qlen20 * qlen;\n    float qlen22 = qlen21 * qlen;\n    float qlen23 = qlen22 * qlen;\n    float qlen24 = qlen23 * qlen;\n    float qlen25 = qlen24 * qlen;\n    float qlen26 = qlen25 * qlen;\n    float qlen27 = qlen26 * qlen;\n    float qlen28 = qlen27 * qlen;\n    float qlen29 = qlen28 * qlen;\n    float qlen30 = qlen29 * qlen;", "\n    float d = 0.;\n    \n    // Tree trunk\n    d = max(d, abs(p.y - 0.5) - 0.1);\n    \n    // Tree leaves\n    d = max(d, 1. - length(p - vec3(0., 0.5, 0.)) - 0.1);\n    \n    return d;\n}\n\n// Scene\nfloat", "\n    return sqrt(dot(a - b, a - b));\n}\n\n// K root\nfloat", "\n    vec2 e = vec2(0.001, 0);\n    return normalize(\n        vec3(\n            ObjectValue(p + e.xyy) - ObjectValue(p - e.xyy),\n            ObjectValue(p + e.yxy) - ObjectValue(p - e.yxy),\n            ObjectValue(p + e.yyx) - ObjectValue(p - e.yyx)\n        )\n    );\n}\n\n// Smooth evaluation\nvec", "\n    // Initialize\n    vec3 p = o;\n    vec3 n = vec3(0);\n    vec3 c = vec3(0);\n    vec3 l = vec3(0);\n    vec3 d = vec3(0);\n    vec3 f = vec3(0);\n    vec3 b = vec3(0);\n    vec3 e = vec3(0);\n    vec3 t = vec3(0);\n    vec3 m = vec3(0);\n    vec3 r = vec3(0);\n    vec3 g = vec3(0);\n    vec3 a = vec3(0);\n    vec3 v = vec3(0);\n    vec3 w = vec3(0);\n    vec3 x = vec3(0);\n    vec3 y = vec3(0);\n    vec3 z = vec3(0);\n    vec3 u = vec3(0);\n    vec3 i = vec3(0);\n    vec3 j = vec3(0);\n    vec3 k = vec3(0);\n    vec3 l = vec3(0);\n    vec3 m = vec3(0);\n    vec3 n = vec3(0);\n    vec3 o = vec3(0);\n    vec3 p = vec3(0);\n    vec3 q = vec3(0);\n    vec3 r = vec3(0);\n    vec3 s = vec3(0);\n    vec3 t = vec3(0);\n    vec3 u = vec3(0);\n    vec3 v = vec3(0);\n    vec3 w = vec3(0);\n    vec3 x = vec3(0);\n    vec3 y = vec3(0);\n    vec3 z = vec3(0);\n    vec3 a = vec3(0);\n    vec3 b = vec3(0);\n    vec3 c = vec3(0);\n    vec3 d = vec3(0);\n    vec3 e = vec3(0);\n    vec3 f = vec3(0);\n    vec3 g = vec3(0);\n    vec3 h = vec3(0);\n    vec3 i = vec3(0);\n    vec3 j", "\n    float t = 0.;\n    for (s = 0; s < 1000; s++)\n    {\n        if (t > 100.)\n        {\n            h = false;\n            return t;\n        }\n        if (Distance(o + t * u) < 0.01)\n        {\n            h = true;\n            return t;\n        }\n        t += 0.1;\n    }\n    h = false;\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat", "\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec3 d = pa - ba*h;\n    return length(d) - r;\n}\n\n// arbitrary orientation\nfloat", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 tN = max(t1,t2);\n    vec3 tF = min(t1,t2);\n    float t = max(tN.x,max(tN.y,tN.z));\n    if( t < min(tF.x,min(tF.y,tF.z)) )\n        return vec2(-1.0);\n    return vec2(t);\n}\n", "\n    return (coord - 0.5) * 2.0;\n}\n\n// normalized fragment coordinate\nvec", "\n    // p = p - q\n    // q = (0, 0)\n    // p = (px, py)\n    // q = (qx, qy)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q = (0, 0)\n    // p = (px - qx, py - qy)\n    // p = (px, py)\n    // q", "\n    vec2 q = p * 0.5;\n    vec2 a = q - vec2(r, 0);\n    vec2 b = q - vec2(-r, 0);\n    vec2 c = q - vec2(0, r);\n    vec2 d = q - vec2(0, -r);\n    vec2 e = q - vec2(r, r);\n    vec2 f = q - vec2(-r, r);\n    vec2 g = q - vec2(r, -r);\n    vec2 h = q - vec2(-r, -r);\n    vec2 i = q - vec2(d, d);\n    vec2 j = q - vec2(d, -d);\n    vec2 k = q - vec2(-d, d);\n    vec2 l = q - vec2(-d, -d);\n    return vec3(\n        min(\n            min(\n                min(\n                    min(\n                        min(\n                            min(\n                                min(\n                                    min(\n                                        min(\n                                            min(\n                                                min(\n                                                    min(\n                                                        min(\n                                                            min(\n                                                                min(\n                                                                    min(\n                                                                        min(\n                                                                            min(\n                                                                                min(\n                                                                                    min(\n                                                                                        min(\n                                                                                            min(\n                                                                                                min(\n                                                                                                    min(\n                                                                                                        min(\n                                                                                                            min(\n                                                                                                                min(\n                                                                                                                    min(\n                                                                                                                        min(\n                                                                                                                            min(\n                                                                                                                                min(\n                                                                                                                                    min(\n                                                                                                                                        min(\n                                                                                                                                            min(\n                                                                                                                                                min(\n                                                                                                                                                    min(\n                                                                                                                                                        min(\n                                                                                                                                                            min(\n                                                                                                                                                                min(\n                                                                                                                                                                    min(\n                                                                                                                                                                        min(\n                                                                                                                                                                            min(\n                                                                                                                                                                                min(\n                                                                                                                                                                                    min(\n                                                                                                                                                                                        min(\n                                                                                                                                                                                            min(\n                               ", "\n    vec2 q = p * c;\n    vec2 d = abs( q ) - r;\n    return vec3( length( d ), d.x, d.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\n// c is the sin/cos of the angle. r is the radius\nvec", "\n    vec2 p0 = v[2] - v[0];\n    vec2 p1 = v[1] - v[0];\n    vec2 p2 = p - v[0];\n    \n    vec3 q = vec3(dot(p2,p1),dot(p2,p0),dot(p1,p0));\n    \n    vec3 r = sign(q.zyx) * sign(q.zxy);\n    \n    vec2 d = r.xy * q.xx - r.xz * q.yy;\n    \n    vec2 e = r.yz * q.xx - r.zz * q.yy;\n    \n    vec2 f = r.zy * q.xx - r.yx * q.yy;\n    \n    vec2 g = r.yz * q.zz - r.zz * q.zz;\n    \n    vec2 h = r.zy * q.zz - r.zz * q.zz;\n    \n    vec2 i = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 j = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 k = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 l = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 m = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 n = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 o = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 p = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 q = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 r = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 s = r.xy * q.zz - r.xz * q.zz;\n    \n    vec2 t = r.xy * q.zz - r.xz * q.zz;\n", "\n    vec2 q = p * sca - vec2(0.0, ra);\n    vec2 r = p * scb - vec2(rb, 0.0);\n    vec2 t = q * q + r * r;\n    vec2 u = q * r;\n    vec2 v = vec2(t.y, -t.x);\n    vec2 w = vec2(u.y, -u.x);\n    vec2 y = t * t - 4.0 * (t * u - v * v);\n    vec2 z = t * t - 4.0 * (v * u - w * w);\n    vec2 a = t * t - 4.0 * (u * u - v * w);\n    vec2 b = t * t - 4.0 * (u * w - v * v);\n    vec2 c = t * t - 4.0 * (v * v - u * w);\n    vec2 d = t * t - 4.0 * (v * w - u * u);\n    vec2 e = t * t - 4.0 * (w * w - v * u);\n    vec2 f = t * t - 4.0 * (w * u - v * v);\n    vec2 g = t * t - 4.0 * (w * v - u * u);\n    vec2 h = t * t - 4.0 * (w * u - v * v);\n    vec2 i = t * t - 4.0 * (w * v - u * u);\n    vec2 j = t * t - 4.0 * (w * u - v * v);\n    vec2 k = t * t - 4.0 * (w * v - u * u);\n    vec2 l = t * t - 4.0 * (w * u - v * v);\n    vec2 m = t * t - 4.0 * (w * v - u * u);\n    vec2 n = t * t - 4.0 * (w * u - v * v);\n    vec2 o = t * t - 4.0 * (w * v - u * u);\n    vec2", "\n    return a.x * b.y - a.y * b.x;\n}\n//.x = \u2202f(p)/\u2202x\n//.y = \u2202f(p)/\u2202y\n//.z = \u2202f(p)/\u2202z\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nfloat", "\n    vec2 d = p - ab * clamp( dot(p,ab), 0.0, 1.0 );\n    return vec3( length(d), d.x, d.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 d = vec2(length(p.xz)-ra,p.y);\n    return vec4(d.x*d.x+d.y*d.y-rb*rb,2.0*d.x,2.0*d.y,0.0);\n}\n", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec4( pa - ba*h, length(pa - ba*h) - r );\n}\n", "\n    vec2 q = p - vec2( wi * sk * 0.5, he * 0.5 );\n    return length( q - vec2( sk * q.y, q.x ) ) - wi * 0.5;\n}\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat", "\n    vec2 q = abs(p) - vec2(wi,he);\n    return vec3(max(q.x,q.y), sign(p.x)*q.x, sign(p.y)*q.y);\n}\n", "\n\tif ( p < c )\n\t\treturn p;\n\telse\n\t\treturn c;\n\t}\n\nfloat", "\n    if (k < 0.0f) {\n        return a;\n    }\n    if (k > 1.0f) {\n        return b;\n    }\n    return a + (b - a) * k;\n}\n\n// IQ's polynominal max\nfloat", "\n  vec2 r = p - size * floor(p / size);\n  if (r.x < 0.0) r.x += size.x;\n  if (r.y < 0.0) r.y += size.y;\n  return r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec", "\n    vec3 oc = ro - s.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - s.w * s.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n\n// IQ's ray box intersection\nvec", "\n    vec3 invDir = 1.0 / rd;\n    vec3 tMin = (boxSize - ro) * invDir;\n    vec3 tMax = (-boxSize - ro) * invDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    if (tNear < tFar && tFar > 0.0) {\n        outNormal = t1 - t2;\n        return tNear;\n    }\n    return vec2(-1.0);\n}\n\n// IQ's ray sphere intersection\nvec", "\n    //find the closest edge\n    if (p.x < d.x / 2.0) {\n        //left\n        e1 = vec2(-1.0, 0.0);\n        if (p.y < d.y / 2.0) {\n            //left top\n            e2 = vec2(0.0, 1.0);\n            if (p.y < d.y / 4.0) {\n                //left top front\n                e3 = vec2(1.0, 0.0);\n                //left top back\n                e4 = vec2(0.0, -1.0);\n            } else {\n                //left bottom front\n                e3 = vec2(1.0, 0.0);\n                //left bottom back\n                e4 = vec2(0.0, -1.0);\n            }\n        } else {\n            //left bottom\n            e2 = vec2(0.0, -1.0);\n            if (p.y < d.y * 3.0 / 4.0) {\n                //left bottom front\n                e3 = vec2(1.0, 0.0);\n                //left bottom back\n                e4 = vec2(0.0, 1.0);\n            } else {\n                //left top front\n                e3 = vec2(1.0, 0.0);\n                //left top back\n                e4 = vec2(0.0, 1.0);\n            }\n        }\n    } else {\n        //right\n        e1 = vec2(1.0, 0.0);\n        if (p.y < d.y / 2.0) {\n            //right top\n            e2 = vec2(0.0, 1.0);\n            if (p.y < d.y / 4.0) {\n                //right top front\n                e3 = vec2(-1.0, 0.0);\n                //right top back\n                e4 = vec2(0.0, -1.0);\n            } else {\n                //right bottom front\n                e3 = vec2(-1.0, 0", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 q = p;\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(1.0, 0.0);\n    vec2 c = vec2(1.0, 1.0);\n    vec2 d = vec2(0.0, 1.0);\n    vec2 e = vec2(0.0, 0.0);\n    vec2 f = vec2(1.0, 1.0);\n    vec2 g = vec2(1.0, 0.0);\n    vec2 h = vec2(0.0, 1.0);\n    vec2 i = vec2(0.0, 0.0);\n    vec2 j = vec2(1.0, 1.0);\n    vec2 k = vec2(1.0, 0.0);\n    vec2 l = vec2(0.0, 1.0);\n    vec2 m = vec2(0.0, 0.0);\n    vec2 n = vec2(1.0, 1.0);\n    vec2 o = vec2(1.0, 0.0);\n    vec2 p = vec2(0.0, 1.0);\n    vec2 q = vec2(0.0, 0.0);\n    vec2 r = vec2(1.0, 1.0);\n    vec2 s = vec2(1.0, 0.0);\n    vec2 t = vec2(0.0, 1.0);\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(1.0, 1.0);\n    vec2 w = vec2(1.0, ", "\n    // The arrow's body is a line segment.\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n    vec2  pab = pa - h * ba;\n    float d = length( pab ) - w1 * 0.5;\n\n    // The arrow head is a triangle.\n    if( d < 0.0 )\n    {\n        vec2  pab2 = pa - h * ba * 0.5;\n        vec2  pab3 = pa - h * ba * 1.5;\n        vec2  pab4 = pa - h * ba * 2.5;\n        float d1 = length( pab2 - p ) - w2 * 0.5;\n        float d2 = length( pab3 - p ) - w2 * 0.5;\n        float d3 = length( pab4 - p ) - w2 * 0.5;\n        d = min( d, min( d1, min( d2, d3 ) ) );\n    }\n\n    return d;\n}\n", "\n    vec2 q = vec2(length(ro.xz)-tor.x, ro.y);\n    vec2 p = q/tor.y;\n    float a = dot(rd.xz,rd.xz)-tor.y*tor.y;\n    float b = 2.0*(dot(rd.xz,ro.xz)-tor.y*p.x);\n    float c = dot(ro.xz,ro.xz)-tor.y*p.x*p.x-tor.x*tor.x;\n    float h = b*b-4.0*a*c;\n    if(h<0.0) return -1.0;\n    h = sqrt(h);\n    float t0 = (-b-h)/(2.0*a);\n    float t1 = (-b+h)/(2.0*a);\n    if(t0>t1) { float w=t0; t0=t1; t1=w; }\n    if(t0<0.0) t0 = t1;\n    if(t0<0.0) return -1.0;\n    return t0;\n}\n", "\n    vec2 t = tor * 2.0 * PI;\n    vec2 c = cos(t), s = sin(t);\n    mat2 m = mat2(c.x, s.x, s.x, c.x, c.y, s.y, s.y, c.y);\n    return normalize(pos - m * vec2(torusRadius, 0.0));\n}\n", "\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9 - x^11/11 +...\n  //\n  // The following is a Taylor series expansion of tanh(x)\n  // around x = 0.\n  //\n  // tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + x^9/9", "\n    vec3 c = col;\n    float a = 0.01;\n    float b = 0.01;\n    float c1 = 0.01;\n    float c2 = 0.01;\n    float c3 = 0.01;\n    float c4 = 0.01;\n    float c5 = 0.01;\n    float c6 = 0.01;\n    float c7 = 0.01;\n    float c8 = 0.01;\n    float c9 = 0.01;\n    float c10 = 0.01;\n    float c11 = 0.01;\n    float c12 = 0.01;\n    float c13 = 0.01;\n    float c14 = 0.01;\n    float c15 = 0.01;\n    float c16 = 0.01;\n    float c17 = 0.01;\n    float c18 = 0.01;\n    float c19 = 0.01;\n    float c20 = 0.01;\n    float c21 = 0.01;\n    float c22 = 0.01;\n    float c23 = 0.01;\n    float c24 = 0.01;\n    float c25 = 0.01;\n    float c26 = 0.01;\n    float c27 = 0.01;\n    float c28 = 0.01;\n    float c29 = 0.01;\n    float c30 = 0.01;\n    float c31 = 0.01;\n    float c32 = 0.01;\n    float c33 = 0.01;\n    float c34 = 0.01;\n    float c35 = 0.01;\n    float c36 = 0.01;\n    float c37 = 0.01;\n    float c38 = 0.", "\n  vec2 r = p - size * floor(p / size);\n  if (r.x < r.y) r.xy = r.yx;\n  return r;\n}\n\nvec", "\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    return length(p-c)-r;\n}\n\n// signed distance to a circle\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// distance to a line\nfloat", "\n    return a.x * b.y - a.y * b.x;\n}\n\n// signed distance to a 2D triangle\nfloat", "\n    vec2 q = abs(p)-vec2(s);\n    return min(max(q.x,q.y),0.0)+length(max(q,0.0))-r;\n}\n\n// s = side length\n// r = corner radius\nfloat", "\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// The filmic curve\nvec", "\n    return 1.0 - abs(x);\n}\n\n// s-curve\nvec", "\n    float a = atan( p.y, p.x ) * k;\n    return length( p ) * cos( a ) - w * a;\n}\n\n// p is the point\n// w is the width / distance from center to tip\n// k is the number of rotations\n// a is the angle of the spiral\nfloat", "\n    return vec3(1.0) - exp(-opticalDepth);\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec", "\n    // The optical depth of the ray.\n    float opticalDepth = 0.0;\n    // The total light that is scattered along the ray.\n    vec3 totalLight = vec3(0.0);\n    // The current position of the ray.\n    vec3 rayPos = rayStart;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    // The current direction of the ray.\n    vec3 rayDirNorm = rayDir;\n    //", "\n    vec3 p = p2 - vec3( 0.0, 0.0, d );\n    float r = length( p ) - ra;\n    return r - rb;\n}\n\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\n// t  = time\nfloat", "\n    // p = position\n    // r = sphere's radius\n    // h = cutting's plane's position\n    // t = thickness\n    \n    // distance to sphere\n    float d = length( p - h * vec3( 0.0, 1.0, 0.0 ) ) - r;\n    \n    // distance to cutting plane\n    float d2 = max( d - t, 0.0 );\n    \n    // distance to inside of sphere\n    return max( d2, -d );\n}\n", "\n    float res = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        float t = mix( tmin, tmax, float(i) / float(8) );\n        float h = texture( shadowMap, ro.xy + rd * t ).r;\n        res = min( res, h );\n    }\n    return res;\n}\n", "\n    float d = length( p - vec3( 0.0, h, 0.0 ) );\n    return d - r;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat", "\n    const float eps = 0.001;\n    return normalize(\n        pos - vec3(\n            SDF( vec3( pos.x - eps, pos.yz ) ),\n            SDF( vec3( pos.xy, pos.z - eps ) ),\n            SDF( vec3( pos.xz, pos.y - eps ) )\n        )\n    );\n}\n", "\n    // p = abs(p);\n    // p = p - vec2( h, 0.0 );\n    // p = p - vec2( 0.0, h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( -h, 0.0 );\n    // p = p - vec2( 0.0, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h, h );\n    // p = p - vec2( -h, -h );\n    // p = p - vec2( h, h );\n    // p = p - vec2( h, -h );\n    // p = p - vec2( -h,", "\n    vec3 p = floor(x);\n    vec3 f = smoothstep(vec3(0.0),vec3(1.0),fract(x));\n    vec2 uv = p.xy + vec2( f.x, f.z );\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.y );\n}\n\n// 3d perlin noise function\nfloat", "\n    float f = 0.0;\n    f += 0.5000 * noise( p );\n    p = p * 2.02;\n    f += 0.2500 * noise( p );\n    p = p * 2.03;\n    f += 0.1250 * noise( p );\n    p = p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat", "\n    p3  = fract(p3 *.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//value noise\nfloat", "\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code is a port of the original C code from\n    // https://www.shadertoy.com/view/4djSRW\n    \n    // The following code", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// From: https://www.shadertoy.com/view/4djSRW\nvec", "\n  p = mod(p, size);\n  if (p < -size * 0.5) p += size;\n  if (p >  size * 0.5) p -= size;\n  return p;\n}\n", "\n  co = fract(co *.1031);\n  co = co * co * co * (co * (co * 6. - 15.) + 10.);\n  return co;\n}\n\nfloat", "\n    return t < 0.0031308? t * 12.92 : 1.055 * pow(t, 1.0 / 2.4) - 0.055;\n}\nvec", "\n    return pow(c, vec3(1.0 / 2.2));\n}\nvec", "\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return a + k*h*(1.-h);\n}\n\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc,rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if(h<0.0) return dbuffer;\n    h = sqrt(h);\n    float t0 = -b - h;\n    float t1 = -b + h;\n    if(t0>t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if(t0>dbuffer) return dbuffer;\n    if(t1<dbuffer) return dbuffer;\n    return t0;\n}\n", "\n    return p * p * p * p - p * p * p + p * p - p + 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 p = vec4(uv, 0.0, 1.0);\n    for (int i = 0; i < 100; i++) {\n        p = formula(p);\n    }\n    fragColor = p.xyz;\n}\n", "\n    vec3 q = abs(p) - r;\n    return vec4( max(q.x,max(q.y,q.z)),\n        sign(p.x)*q.x,\n        sign(p.y)*q.y,\n        sign(p.z)*q.z );\n}\n", "\n  return vec4(\n    back.rgb * (1.0 - front.a) + front.rgb * front.a,\n    back.a * (1.0 - front.a) + front.a\n  );\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    return mix(back, front.rgb, front.a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec", "\n    vec2 q = abs(p);\n    return min(\n        max(q.x, q.y),\n        r * sqrt(2.0) - length(q - r * vec2(0.5, 0.5))\n    );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    v = v * (v + 0.055f) - 0.055f;\n    v = v / (v + 0.115f);\n    return v;\n}\n\nvec", "\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat", "\n    float T = Temp * 1.0e-3;\n    return vec3(\n        pow(T * 1.0e-3, 2.0) * (1.0 / (exp(1.4388 * 1.0e-2 / (T * 1.0e-3 * 1.0e-3)) - 1.0)) * 1.0e-6,\n        pow(T * 1.0e-3, 2.0) * (1.0 / (exp(1.4388 * 1.0e-2 / (T * 1.0e-3 * 1.0e-3)) - 1.0)) * 1.0e-6,\n        pow(T * 1.0e-3, 2.0) * (1.0 / (exp(1.4388 * 1.0e-2 / (T * 1.0e-3 * 1.0e-3)) - 1.0)) * 1.0e-6\n    );\n}\n", "\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    return vec2(-b - sqrt(h), -b + sqrt(h));\n}\n", "\n    vec2 q = abs(p) - n;\n    return vec3(length(max(q, 0.0)) + min(max(q.x, q.y), 0.0),\n                sign(p.x) * sign(p.y) * (n - length(p)),\n                sign(p.x) * (n - abs(p.y)) + sign(p.y) * (n - abs(p.x)));\n}\n", "\n    // t = 0 is a staircase\n    // t = 1 is a line\n    // t = 2 is a triangle\n    // t = 3 is a square\n    // t = 4 is a pentagon\n    // t = 5 is a hexagon\n    // t = 6 is a heptagon\n    // t = 7 is a octagon\n    // t = 8 is a nonagon\n    // t = 9 is a decagon\n    // t = 10 is a dodecagon\n    // t = 11 is a pentadecagon\n    // t = 12 is a hexadecagon\n    // t = 13 is a heptadecagon\n    // t = 14 is a octadecagon\n    // t = 15 is a enneadecagon\n    // t = 16 is a icosagon\n    // t = 17 is a icosadecagon\n    // t = 18 is a triacontagon\n    // t = 19 is a triacontaenagon\n    // t = 20 is a triacontahexagon\n    // t = 21 is a triacontaheptagon\n    // t = 22 is a triacontaoctagon\n    // t = 23 is a triacontaenneagon\n    // t = 24 is a triacontaicosaagon\n    // t = 25 is a triacontaicosaenagon\n    // t = 26 is a triacontaicosahexagon\n    // t = 27 is a triacontaicosaheptagon\n    // t = 28 is a triacontaicosaoctagon\n    // t = 29 is a triacontaicosaenneagon\n    // t = 30 is a triacontaicosaicosaagon\n    // t = 31 is a triacontaicosaicosaenagon\n    // t = 32 is a triacontaicosaicosahexagon\n    // t = 33 is a triacontaicosaicosaheptagon\n    // t = 34 is a triacontaicosaicosaoctagon\n    // t = 35 is a triacontaicosaicosaenneagon", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    float f = 0.0;\n    \n    // add a bunch of fractal functions\n    for (int i = 0; i < 10; i++) {\n        f += 0.5 * (1.0 - abs(sin(p.x * 10.0 + float(i * 10 + idx)))) *\n            (1.0 - abs(sin(p.y * 10.0 + float(i * 10 + idx)))) *\n            (1.0 - abs(sin(p.z * 10.0 + float(i * 10 + idx))));\n    }\n    \n    return f;\n}\n\n// main func\nvoid main() {\n    // get the position\n    vec3 p = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // get the color\n    vec3 col = vec3(0.0);\n    \n    // add a bunch of fractal functions\n    for (int i = 0; i < 10; i++) {\n        col += map(p, i) * vec3(0.1, 0.2, 0.3);\n    }\n    \n    // set the color\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float a = y / (x + 0.28f * x);\n    return a - 0.25f * a * a * a;\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\nvec", "\n    return log((vec2(1.0)+z)/(vec2(1.0)-z));\n}\n// Inverse hyperbolic tangent \nvec", "\n    return vec2(exp(z.x), exp(-z.y));\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\nvec", "\n    return vec2(cos(z), sin(z));\n}\n\n// My own attempt at a ctanh\nvec", "\n    // alpha = (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * contrast * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * contrast + 0.5;\n    // alpha = (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (alpha - 0.5) * (", "\n  vec3 q = abs(p);\n  float d = q.x + q.y + q.z - 1.;\n  if (d < 0.)\n    return length(p);\n  return d;\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat", "\n  vec3 v = uvw * 2. - 1.;\n  vec2 uv = v.xy;\n  vec2 w = v.zy;\n  vec2 v2 = v.xy * v.xy;\n  vec2 v3 = v.xy * v.xy * v.xy;\n  vec2 v4 = v.xy * v.xy * v.xy * v.xy;\n  vec2 v5 = v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v6 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v7 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v8 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v9 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v10 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v11 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v12 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v13 = v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy * v.xy;\n  vec2 v14 = v.xy * v.xy * v.xy * v.xy * v.xy *", "\n    vec3 uv = uvw.xy * gridRes;\n    vec3 w = uvw.z * gridRes;\n    vec3 v = w * vec3(1.0, 1.0, -1.0);\n    vec3 u = w * vec3(1.0, -1.0, 1.0);\n    vec3 p = (uv * vec2(1.0, -1.0) + v + u);\n    vec3 q = (uv * vec2(-1.0, 1.0) + v + u);\n    vec3 r = (uv * vec2(-1.0, -1.0) + v + u);\n    vec3 s = (uv * vec2(1.0, 1.0) + v + u);\n    vec3 t = (uv * vec2(-1.0, 1.0) + v - u);\n    vec3 u1 = (uv * vec2(1.0, -1.0) + v - u);\n    vec3 v1 = (uv * vec2(-1.0, -1.0) + v - u);\n    vec3 w1 = (uv * vec2(1.0, 1.0) + v - u);\n    vec3 x = (uv * vec2(-1.0, 1.0) + v + u);\n    vec3 y = (uv * vec2(1.0, -1.0) + v + u);\n    vec3 z = (uv * vec2(1.0, 1.0) + v + u);\n    vec3 a = (uv * vec2(-1.0, -1.0) + v + u);\n    vec3 b = (uv * vec2(-1.0, 1.0) + v - u);\n    vec3 c = (uv * vec2(1.0, -1.0) + v - u);\n    vec3 d = (uv * vec2(1.0, 1.0) + v - u);\n    vec3 e = (uv * vec2(-1.0, -1.0) + v - u);\n    vec3 f = (uv * vec2(-1.0", "\n  vec3 v = vec3(0);\n  for (int i = 0; i < 4; i++) {\n    vec3 p = uvw - vec3(\n      float(i) * gridRes * 0.5,\n      float(i & 1) * gridRes * 0.5,\n      float(i & 2) * gridRes * 0.5\n    );\n    float d = length(p);\n    float a = d * gridRes * contrast;\n    float b = 1.0 - a;\n    float c = 1.0 - a * a;\n    float s = smoothstep(b, a, d);\n    v += vec3(\n      mix(c * c * c, c * c * s, s),\n      mix(c * c * c, c * s * s, s),\n      mix(c * c * c, s * s * s, s)\n    );\n  }\n  return v * 0.25;\n}\n", "\n  //p = abs(p);\n  float a = length(p);\n  float b = length(p - vec3(0.0, 1.0, 0.0));\n  float c = length(p - vec3(0.0, 0.0, 1.0));\n  float d = length(p - vec3(1.0, 0.0, 0.0));\n  return min(min(min(a, b), c), d);\n}\n\n//Icosahedron\nfloat", "\n    // t = 1 - t;\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, 6));\n    // return vec3(pow(t, 6), pow(t, 2), pow(t, ", "\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    mat3 m = mat3(\n        c.y * c.z, s.x * s.y * c.z - s.z * c.x, s.z * s.y * c.z + s.x * c.x,\n        s.y * c.z, s.x * s.y * c.z + s.z * c.x, s.z * s.y * c.z - s.x * c.x,\n        -s.z * c.y, s.x * s.y * c.y + s.z * c.x, s.y * s.y * c.y - s.x * c.x\n    );\n    return m * v;\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat", "\n    // p = abs(p);\n    // p = p - 0.5 * sign(p);\n    // return length(p);\n    return length(p - 0.5 * sign(p));\n}\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat", "\n    // uv = uv * 2. - 1.;\n    // uv = uv * 1.5;\n    // uv = uv * 1.2;\n    // uv = uv * 1.1;\n    // uv = uv * 1.;\n    // uv = uv *.9;\n    // uv = uv *.8;\n    // uv = uv *.7;\n    // uv = uv *.6;\n    // uv = uv *.5;\n    // uv = uv *.4;\n    // uv = uv *.3;\n    // uv = uv *.2;\n    // uv = uv *.1;\n    // uv = uv *.05;\n    // uv = uv *.01;\n    // uv = uv *.005;\n    // uv = uv *.001;\n    // uv = uv *.0005;\n    // uv = uv *.0001;\n    // uv = uv *.00005;\n    // uv = uv *.00001;\n    // uv = uv *.000005;\n    // uv = uv *.000001;\n    // uv = uv *.0000005;\n    // uv = uv *.0000001;\n    // uv = uv *.00000005;\n    // uv = uv *.00000001;\n    // uv = uv *.000000005;\n    // uv = uv *.000000001;\n    // uv = uv *.0000000005;\n    // uv = uv *.0000000001;\n    // uv = uv *.00000000005;\n    // uv = uv *.00000000001;\n    // uv = uv *.000000000005;\n    // uv = uv *.000000000001;\n    // uv = uv *.00", "\n    return mix(\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n        pow(clamp(t, 0.0, 1.0), 1.0 / 2.5)\n    );\n}\n\n// makes a colormap with a given number of colors\nvec", "\n    return (x + 1.0f) * 0.5f;\n}\n\n//shifts value range from 0-1 to -1-1\nfloat", "\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv * 10.;\n    // uv = uv", "\n    vec2 uv0 = uv * gridRes - time * len;\n    vec2 uv1 = uv * gridRes + time * len;\n    vec2 uv2 = uv * gridRes - time * len * 0.5;\n    vec2 uv3 = uv * gridRes + time * len * 0.5;\n    vec2 uv4 = uv * gridRes - time * len * 0.25;\n    vec2 uv5 = uv * gridRes + time * len * 0.25;\n    vec2 uv6 = uv * gridRes - time * len * 0.125;\n    vec2 uv7 = uv * gridRes + time * len * 0.125;\n    return (\n        sin(uv0.x + uv0.y)\n        + sin(uv1.x - uv1.y)\n        + sin(uv2.x + uv2.y)\n        + sin(uv3.x - uv3.y)\n        + sin(uv4.x + uv4.y)\n        + sin(uv5.x - uv5.y)\n        + sin(uv6.x + uv6.y)\n        + sin(uv7.x - uv7.y)\n    );\n}\n", "\n    vec2 dir = point - vec2(0.5);\n    float dist = length(dir);\n    \n    if (dist < radius) {\n        float angle = atan(dir.y, dir.x);\n        float speed = 1.0 - (dist / radius);\n        \n        float t = time * speed;\n        \n        float newAngle = angle + t;\n        \n        return vec2(cos(newAngle), sin(newAngle));\n    }\n    \n    return vec2(0);\n}\n\n// makes a simple flowmap of a spiral\nvec", "\n    vec2 tile = floor(pos / arrowTileSize);\n    return tile * arrowTileSize + arrowTileSize * 0.5;\n}\n\n// Computes the center pixel of the tile containing pixel pos\nvec", "\n    vec2 v = p2 - p1;\n    vec2 w = p - p1;\n    float c1 = dot(w, v);\n    float c2 = dot(w, w);\n    float c3 = dot(v, v);\n    return c1 * c1 / c3 - c2;\n}\n\n// Computes the signed distance from a line\nfloat", "\n  // v = v * 1.0 / 10.0;\n  // p = p * 1.0 / 10.0;\n  float d = length(p);\n  if (d < 0.01) {\n    return 0.0;\n  }\n  float a = atan(v.y, v.x);\n  float b = atan(p.y, p.x);\n  float c = a - b;\n  if (c < -PI) {\n    c = c + 2.0 * PI;\n  }\n  if (c > PI) {\n    c = c - 2.0 * PI;\n  }\n  if (c < 0.0) {\n    c = c + PI;\n  }\n  // c = c * 180.0 / PI;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  // c = c * 10.0;\n  ", "\n    return (x + 1.) *.5;\n}\n\n//shifts value range from 0-1 to -1-1\nvec", "\n    vec2 p = point - offset;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    \n    float s = sin(a * spread);\n    float c = cos(a * spread);\n    \n    return vec2(c * r, s * r);\n}\n\n// makes a simple flowmap in the shape of a circle\nvec", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n    // the base shape\n    float s = sdBox( p, vec2(sp,sp) );\n    \n    // the offset\n    vec2 offset = id * sp * 2.;\n    \n    // the time offset\n    vec2 timeOffset = vec2( cos( time * 0.1 ), sin( time * 0.1 ) ) * sp * 0.1;\n    \n    // the final shape\n    return s + length( p - offset - timeOffset );\n}\n\n// the SDF we want to repeat\nfloat", "\n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is to make a circular repetition\n    // of a shape\n    \n    // the point of this function\n    // is", "\n    vec3 d = abs(uvw) - 0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.5;\n}\n\n//edge distance of a Sphere\nfloat", "\n    // uvw is in range -1 to 1\n    // return a value in range 0 to 1\n    \n    // TODO: Implement this function\n    \n    //return vec4(0.0);\n    \n    //return vec4(1.0);\n    \n    //return vec4(0.5);\n    \n    //return vec4(0.0, 1.0, 0.0, 1.0);\n    \n    //return vec4(1.0, 0.0, 0.0, 1.0);\n    \n    //return vec4(1.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(1.0, 1.0, 0.0, 1.0);\n    \n    //return vec4(0.0, 0.0, 1.0, 1.0);\n    \n    //return vec4(1.0, 0.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 0.0, 0.0, 1.0);\n    \n    //return vec4(1.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(1.0, 0.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 0.0, 1.0, 1.0);\n    \n    //return vec4(1.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 1.0, 1.0, 1.0);\n    \n    //return vec4(1.0, 0.0, 1.0, 1.0);\n    \n    //return vec4(0.0, 0.0", "\n    vec3 uv = uvw * gridRes - offset;\n    vec3 v = floor(uv);\n    vec3 w = fract(uv);\n    return vec4(w.x * w.y * w.z,\n                w.x * w.y * (1.0 - w.z),\n                w.x * (1.0 - w.y) * w.z,\n                (1.0 - w.x) * w.y * w.z);\n}\n\n// scaled with offset cube tiling\nvec", "\n    return mix(\n        mix(\n            vec3(0.0, 0.0, 0.0),\n            vec3(0.0, 0.0, 1.0),\n            pow(smoothstep(0.0, 0.1, t), 6.0)\n        ),\n        mix(\n            vec3(0.0, 0.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            pow(smoothstep(0.1, 0.4, t), 6.0)\n        ),\n        pow(smoothstep(0.4, 0.7, t), 6.0)\n    );\n}\n", "\n    vec3 q = abs(p);\n    return min(min(q.x + q.y + q.z - 1.0,\n        max(max(q.x - q.y - q.z + 1.0,\n            max(q.y - q.x - q.z + 1.0,\n                max(q.z - q.y - q.x + 1.0,\n                    max(q.x - q.y - q.z - 1.0,\n                        max(q.y - q.x - q.z - 1.0,\n                            max(q.z - q.y - q.x - 1.0,\n                                max(q.x - q.y + q.z - 1.0,\n                                    max(q.y - q.x + q.z - 1.0,\n                                        max(q.z - q.y + q.x - 1.0,\n                                            max(q.x + q.y - q.z - 1.0,\n                                                max(q.y + q.z - q.x - 1.0,\n                                                    max(q.z + q.x - q.y - 1.0,\n                                                        max(q.x + q.y + q.z - 3.0,\n                                                            max(q.x - q.y + q.z + 1.0,\n                                                                max(q.y - q.x + q.z + 1.0,\n                                                                    max(q.z - q.y + q.x + 1.0,\n                                                                        max(q.x + q.y - q.z + 1.0,\n                                                                            max(q.y + q.z - q.x + 1.0,\n                                                                                max(q.z + q.x - q.y + 1.0,\n                                                                                    max(q.x + q.y + q.z + 1.0,\n                                                                                        max(q.x - q.y - q.z - 1.0,\n                                                                                            max(q.y - q.x -", "\n    // t = 0..1\n    // 0 = blue\n    // 1 = white\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    // 6 = white\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    // 6 = white\n    // 7 = blue\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    // 6 = white\n    // 7 = blue\n    // 8 = white\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    // 6 = white\n    // 7 = blue\n    // 8 = white\n    // 9 = blue\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 = blue\n    // 4 = white\n    // 5 = blue\n    // 6 = white\n    // 7 = blue\n    // 8 = white\n    // 9 = blue\n    // 10 = white\n    \n    // 0 = blue\n    // 1 = white\n    // 2 = red\n    // 3 =", "\n    vec2 p = floor(uv);\n    return vec3(p, 1.0);\n}\n\n// simple square Tiling\nvec", "\n    vec2 p = uv * 2. - 1.;\n    vec2 q = p * vec2(1., 1. / 1.732);\n    return vec3(q.x * q.y, q.x * q.y, q.x * q.y);\n}\n\n//rhombic shape form Manhattan distance\nvec", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 gridPos = grid * (1. / gridRes);\n    vec2 gridOffset = (grid + offset) * (1. / gridRes);\n    return vec3(gridPos.x, gridPos.y, gridOffset.x);\n}\n\n// nakes a square pixelized pattern\nvec", "\n    vec2 grid = floor(uv * gridRes);\n    vec2 gridUV = grid / gridRes;\n    vec2 gridUV2 = gridUV * 2.0 - 1.0;\n    vec2 gridUV3 = gridUV2 * 0.5;\n    vec2 gridUV4 = gridUV2 * 0.5 * 0.5;\n    vec2 gridUV5 = gridUV2 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV6 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV7 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV8 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV9 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV10 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV11 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV12 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;\n    vec2 gridUV13 = gridUV2 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5 * 0.5;", "\n    vec2 uv2 = uv * gridRes + offset;\n    vec2 uv3 = fract(uv2);\n    vec2 uv4 = floor(uv2);\n    vec2 uv5 = vec2(uv3.x, uv3.y);\n    vec2 uv6 = vec2(uv3.y, uv3.x);\n    vec2 uv7 = vec2(uv3.x, 1. - uv3.y);\n    vec2 uv8 = vec2(uv3.y, 1. - uv3.x);\n    vec2 uv9 = vec2(1. - uv3.x, uv3.y);\n    vec2 uv10 = vec2(1. - uv3.y, uv3.x);\n    vec2 uv11 = vec2(1. - uv3.x, 1. - uv3.y);\n    vec2 uv12 = vec2(1. - uv3.y, 1. - uv3.x);\n    vec2 uv13 = vec2(uv3.x, uv3.y);\n    vec2 uv14 = vec2(uv3.y, uv3.x);\n    vec2 uv15 = vec2(uv3.x, 1. - uv3.y);\n    vec2 uv16 = vec2(uv3.y, 1. - uv3.x);\n    vec2 uv17 = vec2(1. - uv3.x, uv3.y);\n    vec2 uv18 = vec2(1. - uv3.y, uv3.x);\n    vec2 uv19 = vec2(1. - uv3.x, 1. - uv3.y);\n    vec2 uv20 = vec2(1. - uv3.y, 1. - uv3.x);\n    vec2 uv21 = vec2(uv3.x, uv3.y);\n    vec2 uv22 = vec2(uv3.y, uv3.x);\n    vec2 uv23 = vec2(uv3.x, 1. - uv3.y);\n    vec2 uv24 = vec2(uv3.y, 1. -", "\n    vec2 uv0 = uv * gridRes;\n    vec2 uv1 = uv0 - floor(uv0);\n    vec2 uv2 = uv1 * 2.0 - 1.0;\n    vec2 uv3 = uv2 * 0.5 - 0.5;\n    vec2 uv4 = uv3 * 2.0 - 1.0;\n    vec2 uv5 = uv4 * 0.5 - 0.5;\n    vec2 uv6 = uv5 * 2.0 - 1.0;\n    vec2 uv7 = uv6 * 0.5 - 0.5;\n    vec2 uv8 = uv7 * 2.0 - 1.0;\n    vec2 uv9 = uv8 * 0.5 - 0.5;\n    vec2 uv10 = uv9 * 2.0 - 1.0;\n    vec2 uv11 = uv10 * 0.5 - 0.5;\n    vec2 uv12 = uv11 * 2.0 - 1.0;\n    vec2 uv13 = uv12 * 0.5 - 0.5;\n    vec2 uv14 = uv13 * 2.0 - 1.0;\n    vec2 uv15 = uv14 * 0.5 - 0.5;\n    vec2 uv16 = uv15 * 2.0 - 1.0;\n    vec2 uv17 = uv16 * 0.5 - 0.5;\n    vec2 uv18 = uv17 * 2.0 - 1.0;\n    vec2 uv19 = uv18 * 0.5 - 0.5;\n    vec2 uv20 = uv19 * 2.0 - 1.0;\n    vec2 uv21 = uv20 * 0.5 - 0.5;\n    vec2 uv22 = uv21 * 2.0 - 1.0;\n    vec2 uv23 = uv22 * 0.5 - 0.5;\n    vec2 uv24 = uv23 * 2.0 - ", "\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f * f * ( 3.0 - 2.0 * f );\n    \n    return u.x * u.y * ( ddx * ddx + ddy * ddy );\n}\n\nfloat", "\n    float a = abs(p.x*sin(1.0/3.0*pi)+p.y*cos(1.0/3.0*pi)) - r;\n    float b = abs(p.x*sin(2.0/3.0*pi)+p.y*cos(2.0/3.0*pi)) - r;\n    return min(a, b);\n}\n", "\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    ", "\n    return x * x * ( 3. - 2. * x );\n}\n\nfloat", "\n    return t * t * (1.0 + t * t * t);\n}\nvec", "\n    return abs(mod(floor(p), 2.) -.5);\n}\n// Classic truchet pattern\nfloat", "\n    return abs(sin(p.x*p.y));\n}\nfloat", "\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n    vec2 d0 = p - p0;\n    vec2 d1 = p - p1;\n    vec2 d2 = p - p2;\n    float a0 = dot(d0, e0);\n    float a1 = dot(d1, e1);\n    float a2 = dot(d2, e2);\n    if (a0 < 0.0)\n    {\n        float a = dot(d0, d0);\n        float b = dot(d0, e1);\n        float c = dot(e1, e1);\n        float d = a - a1 * b / c;\n        return sqrt(d * d - a * dot(d0 - e1 * a1 / c, d0 - e1 * a1 / c));\n    }\n    else if (a1 < 0.0)\n    {\n        float a = dot(d1, d1);\n        float b = dot(d1, e2);\n        float c = dot(e2, e2);\n        float d = a - a2 * b / c;\n        return sqrt(d * d - a * dot(d1 - e2 * a2 / c, d1 - e2 * a2 / c));\n    }\n    else if (a2 < 0.0)\n    {\n        float a = dot(d2, d2);\n        float b = dot(d2, e0);\n        float c = dot(e0, e0);\n        float d = a - a0 * b / c;\n        return sqrt(d * d - a * dot(d2 - e0 * a0 / c, d2 - e0 * a0 / c));\n    }\n    else\n    {\n        float a = dot(d0, d0);\n        float b = dot(d0, e1);\n        float c = dot(e1, e1);\n        float d = a - a1 * b / c;\n        float e = a - a0 * b / c - a *", "\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h < 0.0 ) return 1e10;\n    return -b - sqrt( h );\n}\n\nfloat", "\n    return max(abs(p.x)-w+r, -p.y)+max(abs(p.y)-r, -p.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    vec2 q = abs(p);\n    return k * ( q.x + q.y - 1.0 ) - ( k * k * ( q.x * q.y - 1.0 ) ) / ( q.x + q.y + 1.0 );\n}\n\n// k in (0,1) range\nfloat", "\n    return abs( p.x - 1.0 / p.y );\n}\n\n// distance to y=1/x\nfloat", "\n    return a < b? pmin(a - b, k, k) + b : pmin(b - a, k, k) + a;\n}\n\nfloat", "\n    return a * (1. - smoothstep(k, k + 1., abs(a)));\n}\n", "\n    float a = length(p);\n    float b = length(p - vec2(0.0, -0.1));\n    return a * a * a - b * b * b;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat", "\n    vec2 p = pos - A;\n    vec2 q = B - A;\n    vec2 r = C - A;\n    \n    vec2 t = p / q;\n    vec2 u = p / r;\n    \n    vec2 v = t * u;\n    \n    vec2 w = vec2(\n        pow( v.x, 3.0 ) - v.x * v.y + ( 1.0 - v.x ) * v.y,\n        pow( v.y, 3.0 ) - v.x * v.y + ( 1.0 - v.y ) * v.x\n    );\n    \n    return vec3(\n        length( w - v ),\n        dot( w - v, q ) * ( 3.0 * pow( v.x, 2.0 ) - v.y + ( 1.0 - v.x ) ) / q.x,\n        dot( w - v, r ) * ( 3.0 * pow( v.y, 2.0 ) - v.x + ( 1.0 - v.y ) ) / r.y\n    );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 =\u263a 1\nvec", "\n    vec2 p = pos - vec2(0.0, he);\n    vec2 q = p * vec2(1.0, wi);\n    float d = length(q);\n    return vec3(d, q.x / d, -q.y / d);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 p = pos * k;\n    return vec3( p.x * p.y, p.x, p.y );\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec2 q = p - vec2(d);\n    vec2 r = q * vec2(ra, rb);\n    vec2 t = r * vec2(ra, rb);\n    vec2 u = t * vec2(ra, rb);\n    vec2 v = u * vec2(ra, rb);\n    vec2 w = v * vec2(ra, rb);\n    vec2 x = w * vec2(ra, rb);\n    vec2 y = x * vec2(ra, rb);\n    vec2 z = y * vec2(ra, rb);\n    vec2 a = z * vec2(ra, rb);\n    vec2 b = a * vec2(ra, rb);\n    vec2 c = b * vec2(ra, rb);\n    vec2 d = c * vec2(ra, rb);\n    vec2 e = d * vec2(ra, rb);\n    vec2 f = e * vec2(ra, rb);\n    vec2 g = f * vec2(ra, rb);\n    vec2 h = g * vec2(ra, rb);\n    vec2 i = h * vec2(ra, rb);\n    vec2 j = i * vec2(ra, rb);\n    vec2 k = j * vec2(ra, rb);\n    vec2 l = k * vec2(ra, rb);\n    vec2 m = l * vec2(ra, rb);\n    vec2 n = m * vec2(ra, rb);\n    vec2 o = n * vec2(ra, rb);\n    vec2 p = o * vec2(ra, rb);\n    vec2 q = p * vec2(ra, rb);\n    vec2 r = q * vec2(ra, rb);\n    vec2 s = r * vec2(ra, rb);\n    vec2 t = s * vec2(ra, rb);\n    vec2 u = t * vec2(ra, rb);\n    vec2 v = u * vec2(ra, rb);\n    vec2 w = v * vec2(ra, rb);\n    vec2 x = w * vec2(ra, rb);\n    vec2 y = x * vec2(ra, rb);\n    vec2", "\n    v = v * 16807 + ivec2(1);\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v, ivec2 w)\n{\n    v = v * 16807 + ivec2(1);\n    w = w * 16807 + ivec2(1);\n    return v + w;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v, ivec2 w, ivec2 x)\n{\n    v = v * 16807 + ivec2(1);\n    w = w * 16807 + ivec2(1);\n    x = x * 16807 + ivec2(1);\n    return v + w + x;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v, ivec2 w, ivec2 x, ivec2 y)\n{\n    v = v * 16807 + ivec2(1);\n    w = w * 16807 + ivec2(1);\n    x = x * 16807 + ivec2(1);\n    y = y * 16807 + ivec2(1);\n    return v + w + x + y;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec2 Pcg2(ivec2 v, ivec2 w, ivec2 x, ivec2 y, ivec2 z)\n{\n    v = v * 16807 + ivec2(1);\n    w = w", "\n    v = v * 16807 + 1;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 w)\n{\n    v = v * 16807 + w;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x)\n{\n    v = v * 16807 + w;\n    v = v * 16807 + x;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x, ivec3 y)\n{\n    v = v * 16807 + w;\n    v = v * 16807 + x;\n    v = v * 16807 + y;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3 w, ivec3 x, ivec3 y, ivec3 z)\n{\n    v = v * 16807 + w;\n    v = v * 16807 + x;\n    v = v * 16807 + y;\n    v = v * 16807 + z;\n    return v;\n}\n\n// Hash Functions for GPU Rendering - Jarzynski, Olano\n// https://www.jcgt.org/published/0009/03/02/\nivec3 Pcg3(ivec3 v, ivec3", "\n    vec2 p = pos - A;\n    vec2 q = B - A;\n    vec2 r = C - A;\n    vec2 s = p - q;\n    vec2 t = p - r;\n    vec2 u = q - r;\n    vec2 v = q - s;\n    vec2 w = r - s;\n    vec2 x = q - t;\n    vec2 y = r - t;\n    vec2 z = s - t;\n    vec2 a = vec2(dot(s, s), dot(s, t));\n    vec2 b = vec2(dot(t, t), dot(t, u));\n    vec2 c = vec2(dot(u, u), dot(u, v));\n    vec2 d = vec2(dot(v, v), dot(v, w));\n    vec2 e = vec2(dot(w, w), dot(w, x));\n    vec2 f = vec2(dot(x, x), dot(x, y));\n    vec2 g = vec2(dot(y, y), dot(y, z));\n    vec2 h = vec2(dot(z, z), dot(z, z));\n    vec2 i = vec2(dot(s, u), dot(s, v));\n    vec2 j = vec2(dot(t, v), dot(t, w));\n    vec2 k = vec2(dot(u, w), dot(u, x));\n    vec2 l = vec2(dot(v, x), dot(v, y));\n    vec2 m = vec2(dot(w, y), dot(w, z));\n    vec2 n = vec2(dot(x, z), dot(x, z));\n    vec2 o = vec2(dot(s, t), dot(s, u));\n    vec2 p = vec2(dot(t, u), dot(t, v));\n    vec2 q = vec2(dot(u, v), dot(u, w));\n    vec2 r = vec2(dot(v, w), dot(v, x));\n    vec2 s = vec2(dot(w, x), dot(w, y));\n    vec", "\n    return (b.y - a.y) * p.x + (a.x - b.x) * p.y + a.x * b.y - a.y * b.x;\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat", "\n    vec3  rd_abs = abs(rd);\n    vec3  rd_sign = sign(rd);\n    vec3  ro_sign = sign(ro);\n    vec3  ro_abs = abs(ro);\n    vec3  ro_rd = ro_sign - rd_sign;\n    vec3  ro_rd_abs = abs(ro_rd);\n    vec3  ro_rd_sign = sign(ro_rd);\n    vec3  ro_rd_abs_rd_abs = ro_rd_abs * rd_abs;\n    vec3  ro_rd_abs_rd_abs_sign = sign(ro_rd_abs_rd_abs);\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign = ro_rd_abs_rd_abs_sign * rd_sign;\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign = ro_rd_abs_rd_abs_sign_rd_sign * ro_rd_sign;\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd = ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign * ro_rd;\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd_ro_rd_abs = ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd * ro_rd_abs;\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd_ro_rd_abs_ro_rd_abs_rd_abs = ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd_ro_rd_abs * ro_rd_abs_rd_abs;\n    vec3  ro_rd_abs_rd_abs_sign_rd_sign_ro_rd_sign_ro_rd_ro_rd_abs_ro_rd_abs_rd_abs_ro_rd_abs_rd", "\n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n<<12) + (ret_n>>20); // ret_n = ret_n*2^12\n    \n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n<<12) + (ret_n>>20); // ret_n = ret_n*2^12\n    \n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n<<12) + (ret_n>>20); // ret_n = ret_n*2^12\n    \n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n<<12) + (ret_n>>20); // ret_n = ret_n*2^12\n    \n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n<<12) + (ret_n>>20); // ret_n = ret_n*2^12\n    \n    // a = (a<<12) + (a>>20); // a = a*2^12\n    // b = b*2^12;\n    // x = x*2^12;\n    // ret_n = (ret_n", "\n    vec3 d = b - a;\n    float h = clamp( dot( d, d ) - k * k, 0.0, 1.0 );\n    return a + d * h;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 < 1 unfortunatelly\nvec", "\n    float a = ab.x;\n    float b = ab.y;\n    \n    float x = p.x;\n    float y = p.y;\n    \n    return a*a*y*y - b*b*x*x;\n}\n\n//using the \"distance from a point to a line\" defn of hyperbola\nfloat", "\n  return a + b;\n}\n\nfloat", "\n    vec2 q = p - ab;\n    \n    float a = s1 * s1;\n    float b = s2 * s2;\n    \n    float a2 = a * a;\n    float b2 = b * b;\n    \n    float q2 = dot( q, q );\n    \n    float c = a2 * b2 - b2 * q2;\n    \n    if( c < 0.0 )\n        return vec2( 0.0 );\n    \n    float d = sqrt( c );\n    \n    return vec2(\n        ( a * b * q.x - d ) / ( a2 + b2 ),\n        ( a * b * q.y - d ) / ( a2 + b2 )\n    );\n}\n\n//for highlighting individual solutions\nvec", "\n    vec3 d = b - a;\n    vec3 q = p - a;\n    vec3 n = normalize(d);\n    vec3 t = q - dot(q, n)*n;\n    vec2 r = vec2(length(t), length(cross(t, n)));\n    vec2 s = r - vec2(ra, rb);\n    \n    vec4 ret;\n    ret.x = min(max(s.x, 0.0), s.y);\n    ret.yzw = a + d*clamp(dot(q, n), 0.0, 1.0);\n    \n    return ret;\n}\n", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec", "\n    return length(p - cen) - rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat", "\n    // Sample the SDF at the current position\n    float d = sampleSDF( pos );\n\n    // Sample the SDF at the current position + epsilon in each direction\n    vec3 n = vec3(\n        sampleSDF( pos + vec3( EPSILON, 0.0, 0.0 ) ) - d,\n        sampleSDF( pos + vec3( 0.0, EPSILON, 0.0 ) ) - d,\n        sampleSDF( pos + vec3( 0.0, 0.0, EPSILON ) ) - d\n    );\n\n    // Normalize the normal\n    n = normalize( n );\n\n    // If we're in the surface, flip the normal\n    if( showSurface )\n    {\n        if( d < 0.0 )\n        {\n            n = -n;\n        }\n    }\n\n    // Return the normal\n    return n;\n}\n", "\n    float res = 0.;\n    float t = 0.;\n    float tMax = 1.;\n    float tStep = 0.01;\n    \n    for (int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + t * rd;\n        float dist = length(samplePoint - p);\n        \n        res += dist * tStep;\n        \n        if (showSurface)\n        {\n            res += 0.001;\n        }\n        \n        if (dist < 0.001)\n        {\n            break;\n        }\n        \n        t += tStep;\n    }\n    \n    return res;\n}\n", "\n    vec2 q = abs(p);\n    vec2 r = q - vec2(ra, he);\n    vec2 s = q - vec2(rb, he);\n    vec2 t = q - vec2(ra, 0.);\n    vec2 u = q - vec2(rb, 0.);\n    vec2 v = q - vec2(ra, he);\n    vec2 w = q - vec2(rb, he);\n    vec2 x = q - vec2(ra, 0.);\n    vec2 y = q - vec2(rb, 0.);\n    vec2 z = q - vec2(ra, he);\n    vec2 a = vec2(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(", "\n    vec2 q = vec2( length( p.xz ) - ra, p.y );\n    return vec4( q.x*q.x + q.y*q.y - rb*rb, q.x, q.y, 0.0 );\n}\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat", "\n    return dot(v, v);\n}\n\nfloat", "\n    vec2 d = max(minCorner - p, 0.0) + max(p - maxCorner, 0.0);\n    return dot(d, d);\n}\n\n// AABB intersection\n// Returns true if the ray intersects the aabb\n// Returns the distance to the intersection\n// Returns the normal of the intersection\n// Returns the point of intersection\n// Returns the point of intersection in world space\nbool aabbIntersect( in vec2 rayStart, in vec2 rayEnd, in vec2 minCorner, in vec2 maxCorner, out float dist, out vec2 normal, out vec2 point, out vec2 pointWS )\n{\n    // Get the ray direction\n    vec2 rayDir = rayEnd - rayStart;\n    \n    // Get the ray length\n    float rayLength = length(rayDir);\n    \n    // Get the ray direction\n    rayDir /= rayLength;\n    \n    // Get the ray start\n    rayStart = rayStart - minCorner;\n    \n    // Get the ray end\n    rayEnd = rayEnd - minCorner;\n    \n    // Get the ray start\n    rayStart = rayStart / rayLength;\n    \n    // Get the ray end\n    rayEnd = rayEnd / rayLength;\n    \n    // Get the ray start\n    rayStart = rayStart * rayLength;\n    \n    // Get the ray end\n    rayEnd = rayEnd * rayLength;\n    \n    // Get the ray start\n    rayStart = rayStart + minCorner;\n    \n    // Get the ray end\n    rayEnd = rayEnd + minCorner;\n    \n    // Get the ray start\n    rayStart = rayStart - maxCorner;\n    \n    // Get the ray end\n    rayEnd = rayEnd - maxCorner;\n    \n    // Get the ray start\n    rayStart = rayStart * rayLength;\n    \n    // Get the ray end\n    rayEnd = rayEnd * rayLength;\n    \n    // Get the ray start\n    rayStart = rayStart + maxCorner;\n    \n    // Get the ray end\n    rayEnd = rayEnd + maxCorner;\n    \n    // Get the ray start\n    rayStart = rayStart * rayLength;\n    \n    // Get the ray end\n    ray", "\n    // The water is a simple perlin noise texture\n    // with a small amount of displacement\n    vec2 p = uv * 10.0;\n    vec2 q = uv * 10.0 + cdir * 0.1;\n    return vec3(perlin(p), perlin(q), 0.0);\n}\n", "\n    return vec3(\n        uv.x * 2.0 - 1.0,\n        uv.y * 2.0 - 1.0,\n        1.0\n    );\n}\n\n// Ray direction based on [0..1] viewport\nvec", "\n    return v + 2.0 * cross(q.xyz, v) + 2.0 * q.w * v;\n}\n\n// Quaternion-vector division\nvec", "\n    return length( p - c ) - r;\n}\n\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    if( d < a )\n        return vec2( a, m.y );\n    return vec2( d, m.y + 1.0 );\n}\n\nvec", "\n    vec2 oc = ro - vec2(0.0, 0.0);\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad * rad;\n    float h = b * b - c;\n    if( h < 0.0 )\n    {\n        p1 = vec4(-1.0);\n        p2 = vec4(-1.0);\n    }\n    else\n    {\n        h = sqrt(h);\n        vec2 q = vec2(-b - h, -b + h);\n        float t = min(q.x, q.y);\n        if( t < 0.0 )\n        {\n            t = max(q.x, q.y);\n            if( t < 0.0 )\n            {\n                p1 = vec4(-1.0);\n                p2 = vec4(-1.0);\n            }\n            else\n            {\n                p1 = vec4( t, ro + t * rd );\n                p2 = vec4(-1.0);\n            }\n        }\n        else\n        {\n            p1 = vec4( t, ro + t * rd );\n            p2 = vec4(-1.0);\n        }\n    }\n}\n", "\n    vec2 q = p - c;\n    float d = length( q ) - r;\n    return vec3( d, q / d );\n}\n\nvec", "\n    vec2 d = abs(p)-b;\n    return vec3(min(max(d.x,d.y),0.0)+length(max(d,0.0)),\n                sign(d.x)*sign(d.y),\n                sign(d.x)+sign(d.y));\n}\n\nvec", "\n    // p = (x, y)\n    // p = (r, \u03b8)\n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8)\n    // p = (r, \u03b8, 0)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p = (r, \u03b8, z)\n    \n    // p =", "\n  return a1 * x + b1 * x * x + a2 * x * x * x + b2 * x * x * x * x;\n}\n\n// Instant push -> wobble (blue)\n// https://www.desmos.com/calculator/1y1y1y1y1y\nfloat", "\n  return a * pow(abs(x), n) * sign(x) + b;\n}\n\n// Fast push -> wobble (red)\n// https://www.desmos.com/calculator/rwsnoaj9by\n// a: oscillation strength,  a > 0\n// b: oscillation amount,    b = anything\n// n: Superellipse strength, n = 2, 4, 6, etc.\nfloat", "\n                uv *= 1.0 / 10.0;\n                vec2 i = floor(uv);\n                vec2 f = smoothstep(0.0, 1.0, fract(uv));\n                vec2 u = f.xy * f.yx;\n                \n                float a = dot(i + u, vec2(1.0, 13.0));\n                float b = dot(i + u, vec2(5.0, 17.0));\n                float c = dot(i + u, vec2(3.0, 7.0));\n                \n                return a * u.x * u.y + b * (1.0 - u.x) * u.y + c * (1.0 - u.x) * (1.0 - u.y);\n            }\n            \n            // inspired from: https://www.shadertoy.com/view/4djSRW\n            float paperNoise(vec2 uv, float scale){\n                uv *= scale / 10.0;\n                vec2 i = floor(uv);\n                vec2 f = smoothstep(0.0, 1.0, fract(uv));\n                vec2 u = f.xy * f.yx;\n                \n                float a = dot(i + u, vec2(1.0, 13.0));\n                float b = dot(i + u, vec2(5.0, 17.0));\n                float c = dot(i + u, vec2(3.0, 7.0));\n                \n                return a * u.x * u.y + b * (1.0 - u.x) * u.y + c * (1.0 - u.x) * (1.0 - u.y);\n            }\n            \n            // inspired from: https://www.shadertoy.com/view/4djSRW\n            float paperNoise(vec2 uv, float scale, float offset){\n                uv *= scale / 10.0;\n                vec2 i = floor(uv);\n                vec2 f = smoothstep(0.0, 1.0, fract(uv));\n                vec2 u = f.xy * f.yx;\n                \n                ", "\n    int i = x + y;\n    int j = x * y;\n    int k = x - y;\n    int l = x / y;\n    int m = x % y;\n    int n = x ^ y;\n    int o = x & y;\n    int p = x | y;\n    int q = x << y;\n    int r = x >> y;\n    int s = x + i + j + k + l + m + n + o + p + q + r;\n    int t = x * i * j * k * l * m * n * o * p * q * r;\n    int u = x - i - j - k - l - m - n - o - p - q - r;\n    int v = x / i / j / k / l / m / n / o / p / q / r;\n    int w = x % i % j % k % l % m % n % o % p % q % r;\n    int x1 = x ^ i ^ j ^ k ^ l ^ m ^ n ^ o ^ p ^ q ^ r;\n    int y1 = x & i & j & k & l & m & n & o & p & q & r;\n    int z = x | i | j | k | l | m | n | o | p | q | r;\n    int a = x << i << j << k << l << m << n << o << p << q << r;\n    int b = x >> i >> j >> k >> l >> m >> n >> o >> p >> q >> r;\n    int c = x + i + j + k + l + m + n + o + p + q + r;\n    int d = x * i * j * k * l * m * n * o * p * q * r;\n    int e = x - i - j - k - l - m - n - o - p - q - r;\n    int f = x / i / j / k / l / m / n / o / p / q / r;\n    int g = x % i % j % k % l % m % n % o % p % q % r;\n    int h = x ^ i ^ j ^ k ^ l ^", "\n    return length(p-c)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 d = c - abs(p);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - b.x;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2(length(pa - ba*h), h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat", "\n    // a, b are the center of the arc\n    // h is the height of the arc\n    // d2min is the minimum distance to the center of the arc\n    // p is the point to be tested\n    \n    // compute the distance to the center of the arc\n    vec2 d = p - a;\n    float d2 = dot(d, d);\n    \n    // if the distance is too small, return the distance to the center\n    if( d2 < d2min )\n        return vec2( d2, 1.0 );\n    \n    // compute the distance to the edge of the arc\n    float t = dot( d, b - a ) / d2;\n    vec2 q = a + t * ( b - a );\n    vec2 r = p - q;\n    float d2e = dot( r, r ) - h * h;\n    \n    // if the distance is too small, return the distance to the edge\n    if( d2e < 0.0 )\n        return vec2( d2e, 0.0 );\n    \n    // return the distance to the edge and the distance to the center\n    return vec2( d2e, d2 );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec", "\n    float d = 1e10;\n    for( int i = 0; i < 7; i++ )\n    {\n        if( kType[i] == 0 )\n        {\n            d = min( d, sdLine( p, kPath[i*2], kPath[i*2+1] ) );\n        }\n        else\n        {\n            d = min( d, sdArc( p, kPath[i*2], kPath[i*2+1], kPath[i*2+2], kPath[i*2+3], kPath[i*2+4] ) );\n        }\n    }\n    return d;\n}\n", "\n    return length( p - vec2( 0.0, 0.0 ) ) - 0.5;\n}\n\n// correct inside, incorrect outside\nfloat", "\n    return 1.0 - smoothstep( 0.0, 1.0, length( p ) );\n}\n\n// correct inside, incorrect outside\nfloat", "\n    // The pattern is a grid of 10x10 squares.\n    vec2 grid = floor(uv * 10.0);\n    \n    // The pattern is a checkerboard of 10x10 squares.\n    vec2 check = mod(grid, 2.0);\n    \n    // The pattern is a grid of 10x10 squares, with a checkerboard of 10x10 squares\n    // in the middle of each square.\n    vec2 square = mod(grid, 2.0);\n    vec2 checkInSquare = mod(grid - 5.0, 2.0);\n    \n    // The pattern is a grid of 10x10 squares, with a checkerboard of 10x10 squares\n    // in the middle of each square, and a grid of 10x10 squares in the middle of\n    // each checkerboard square.\n    vec2 squareInCheck = mod(grid - 5.0, 2.0);\n    vec2 gridInCheck = mod(grid - 5.0, 10.0);\n    \n    // The pattern is a grid of 10x10 squares, with a checkerboard of 10x10 squares\n    // in the middle of each square, and a grid of 10x10 squares in the middle of\n    // each checkerboard square, and a checkerboard of 10x10 squares in the middle\n    // of each grid square.\n    vec2 squareInCheckInGrid = mod(grid - 5.0, 2.0);\n    vec2 gridInCheckInGrid = mod(grid - 5.0, 10.0);\n    vec2 checkInGridInCheck = mod(grid - 5.0, 20.0);\n    \n    // The pattern is a grid of 10x10 squares, with a checkerboard of 10x10 squares\n    // in the middle of each square, and a grid of 10x10 squares in the middle of\n    // each checkerboard square, and a checkerboard of 10x10 squares in the middle\n    // of each grid square, and a grid of 10x1", "\n    vec2 ab = b - a;\n    float t = max( 0.0, min( 1.0, dot( p - a, ab ) / dot( ab, ab ) ) );\n    return a + t * ab;\n}\n\n// Closest point on line\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - th;\n}\n\n// distance to line\nfloat", "\n    // p = point\n    // b = box size\n    // r = radius\n    \n    // get the distance from the center of the box\n    vec2 d = abs( p - b * 0.5 ) - b * 0.5 + r;\n    \n    // get the max distance\n    float max = max( d.x, d.y );\n    \n    // if the max distance is greater than the radius\n    // we are outside the box\n    if( max > 0.0 )\n    {\n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 c = b * 0.5 - r;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 e = b * 0.5 + r;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 s = p - c;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 t = p - e;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 u = p - s;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 v = p - t;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 w = p - u;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 x = p - v;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 y = p - w;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 z = p - x;\n        \n        // get the distance from the center of the box\n        // to the edge of the box\n        vec2 a = p - y;\n        \n        // get the distance from the center of the box\n        // to the edge of", "\n    vec2 q = abs(p)-b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n// distance to rounded box\nfloat", "\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// distance to circle\nfloat", "\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p.x)*p.y);\n}\n", "\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// A simple 2D noise function\nfloat", "\n    return fract(sin(st)*43758.5453123);\n}\n\n// From iq\nvec", "\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    // Four corners in 2D of a tile\n    vec2 u = f.xy * f.xy * (3.0 - 2.0 * f.xy);\n    \n    // Four corners in 2D of a tile\n    vec2 du = dFdx(u);\n    vec2 dv = dFdy(u);\n    \n    // Four corners in 2D of a tile\n    vec2 duu = dFdx(du);\n    vec2 dvv = dFdy(dv);\n    \n    // Four corners in 2D of a tile\n    vec2 duv = dFdx(dv);\n    vec2 dvu = dFdy(du);\n    \n    // Four corners in 2D of a tile\n    vec2 duuu = dFdx(duu);\n    vec2 dvvv = dFdy(dvv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuv = dFdx(duv);\n    vec2 dvuv = dFdy(dvu);\n    \n    // Four corners in 2D of a tile\n    vec2 duvv = dFdx(dvv);\n    vec2 dvuv = dFdy(duv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuuv = dFdx(duuv);\n    vec2 dvvuv = dFdy(dvuv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuvv = dFdx(duvv);\n    vec2 dvuuv = dFdy(dvuv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuvvv = dFdx(duuuv);\n    vec2 dvuuvv = dFdy(dvvuv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuvvvv = dFdx(duuvv);\n    vec2 dvuuvvv = dFdy(dvuuv);\n    \n    // Four corners in 2D of a tile\n    vec2 duuv", "\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    \n    for (int i = 0; i < 5; i++)\n    {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n// The main function\nvoid main()\n{\n    // Get the coordinates of the pixel\n    vec2 st = gl_FragCoord.xy / iResolution.xy;\n    \n    // The noise function\n    float n = fbm(st * 10.0);\n    \n    // The color\n    vec3 color = vec3(n);\n    \n    // Set the color\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 p = x * 1.0 / 10.0;\n    vec2 q = p - 0.5;\n    vec2 r = abs(q);\n    vec2 s = r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r * r *", "\n    return 0.5f * (y * y - x * x);\n}\n\nfloat", "\n    p3  = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract(vec3(.3183,.3137,.3089) * p3);\n}\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nfloat", "\n    // Skewing and unskewing factors for 3D\n    const vec3 F3 = vec3(1.0/3.0, 1.0/3.0, 1.0/6.0);\n    const vec3 G3 = vec3(1.0/6.0, 1.0/3.0, 1.0/3.0);\n    \n    // Skew the input space to determine which simplex cell we're in\n    vec3 s = p + dot(p, F3) * G3;\n    vec3 i = floor(s);\n    vec3 x0 = s - i;\n    \n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    // Offsets for second corner in (x,y,z) coords\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = vec3(l.z, l.y, l.x);\n    vec3 i2 = vec3(g.z, g.y, g.x);\n    \n    // A step of (0,0,1) in (i,j,k) means a step of (c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,c,-c) in (x,y,z), and\n    // a step of (1,0,0) in (i,j,k) means a step of (-c,-c,c) in (x,y,z), where\n    // c = 1/", "\n    return fract(sin(x)*1e4);\n}\n\n// this is a better hash, but still not great\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// for visualization purposes only\nfloat", "\n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0);\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0) - r.x;\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0) - r.x * 0.5;\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0) - r.x * 0.5;\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0) - r.x * 0.5;\n    \n    // p = p - b * 0.5;\n    // p = abs(p) - b * 0.5;\n    // return length(max(p, 0.0)) - min(max(p.x, p.y), 0.0) - r.x * 0.5;\n    \n    // p =", "\n    // The disk is centered at (0, 0) in the projection plane.\n    // The disk is rotated by the same angle as the camera.\n    // The disk is scaled by the same scale as the camera.\n    // The disk is translated by the same translation as the camera.\n    // The disk is projected by the same projection as the camera.\n    // The disk is projected by the same perspective as the camera.\n    // The disk is projected by the same fov as the camera.\n    // The disk is projected by the same aspect ratio as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far as the camera.\n    // The disk is projected by the same near as the camera.\n    // The disk is projected by the same far", "\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec", "\n    vec2 q = p - acs;\n    vec2 a = q * vec2(cos(an), sin(an)) / r;\n    vec2 b = q * vec2(cos(bn), sin(bn)) / r;\n    return length(max(a, b)) - m;\n}\n\n// Signed distance to a n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat", "\n    vec3 q = abs(p);\n    vec3 r = p * ( q - 1.0 ) * ( q - 1.0 ) * ( q - 1.0 );\n    return r * ( 1.0 - 2.0 * q ) + p;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat", "\n    float t = t0;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 p = ro + rd * t;\n        if (length(p - lightPos) < EPSILON)\n        {\n            res = min(res, 1.0);\n            break;\n        }\n        res = min(res, 1.0 - max(0.0, dot(normal(p), (lightPos - p))));\n        t += res * t * 0.5;\n    }\n    return res;\n}\n", "\n    float ao = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float d = 0.01 * float( i );\n        vec3 p = pos + nor * d;\n        ao += ( 1.0 - iSphere( p, vec3( 0.0, 0.0, 0.0 ), 0.5 ) ) * d;\n    }\n    return clamp( ao * 10.0, 0.0, 1.0 );\n}\n", "\n    float s = sinf(angle);\n    float c = cosf(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 dir = (uv - mouse) * 2.0;\n    return normalize(vec3(dir.x, dir.y, -1.0));\n}\n\n// Helper function that returns the distance to a sphere\nfloat", "\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Standard 3d noise\nfloat", "\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);\n}\n\n// Hash for 2d vectors\nfloat", "\n    vec3 p = floor(x);\n    vec3 f = smoothstep(vec3(0.0), vec3(1.0), x - p);\n    vec2 uv = p.xy + vec2(f.x, f.y);\n    vec2 u = p.xy + vec2(f.x, f.z);\n    vec2 v = p.xy + vec2(f.z, f.y);\n    vec2 w = p.xy + vec2(f.z, f.z);\n    vec2 d = f.z - vec2(f.x, f.y);\n    return mix(\n        mix(\n            mix(\n                noise2d(uv),\n                noise2d(u),\n                d.x\n            ),\n            mix(\n                noise2d(v),\n                noise2d(w),\n                d.x\n            ),\n            d.y\n        ),\n        mix(\n            mix(\n                noise2d(uv + vec2(1.0, 0.0)),\n                noise2d(u + vec2(1.0, 0.0)),\n                d.x\n            ),\n            mix(\n                noise2d(v + vec2(1.0, 0.0)),\n                noise2d(w + vec2(1.0, 0.0)),\n                d.x\n            ),\n            d.y\n        ),\n        d.z\n    );\n}\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    \n    // 8 corners\n    float a = supernoise(i);\n    float b = supernoise(i + vec3(1.0, 0.0, 0.0));\n    float c = supernoise(i + vec3(0.0, 1.0, 0.0));\n    float d = supernoise(i + vec3(1.0, 1.0, 0.0));\n    float e = supernoise(i + vec3(0.0, 0.0, 1.0));\n    float f = supernoise(i + vec3(1.0, 0.0, 1.0));\n    float g = supernoise(i + vec3(0.0, 1.0, 1.0));\n    float h = supernoise(i + vec3(1.0, 1.0, 1.0));\n    \n    // 6 faces\n    float aa = mix(a, b, f.x);\n    float bb = mix(c, d, f.x);\n    float cc = mix(e, f, f.x);\n    float dd = mix(g, h, f.x);\n    \n    float aaa = mix(aa, bb, f.y);\n    float bbb = mix(cc, dd, f.y);\n    \n    // 4 edges\n    float aaaa = mix(aaa, bbb, f.z);\n    \n    return aaaa;\n}\n", "\n    float f = 0.0;\n    float a = 1.0;\n    float d = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += a * noise(p);\n        p = p * 2.0 + d;\n        a *= 0.5;\n        d *= 2.0;\n    }\n    return f;\n}\n\n// A very simple cloud generator\n// The FBM is used to generate a heightmap\n// The heightmap is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate a cloud\n// The cloud is then used to generate", "\n    // get the cloud density\n    float density = texture(cloudDensity, pos).r;\n    // get the cloud color\n    vec3 color = texture(cloudColor, pos).rgb;\n    // return the density and color\n    return vec2(density, color.r);\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec", "\n    vec2 uv = point.xy * 0.01;\n    vec2 uv2 = point.xy * 0.01 + vec2(0.0, 0.01);\n    vec2 uv3 = point.xy * 0.01 + vec2(0.0, -0.01);\n    vec2 uv4 = point.xy * 0.01 + vec2(0.01, 0.0);\n    vec2 uv5 = point.xy * 0.01 + vec2(-0.01, 0.0);\n    vec2 uv6 = point.xy * 0.01 + vec2(0.01, 0.01);\n    vec2 uv7 = point.xy * 0.01 + vec2(0.01, -0.01);\n    vec2 uv8 = point.xy * 0.01 + vec2(-0.01, 0.01);\n    vec2 uv9 = point.xy * 0.01 + vec2(-0.01, -0.01);\n    vec2 uv10 = point.xy * 0.01 + vec2(0.0, 0.02);\n    vec2 uv11 = point.xy * 0.01 + vec2(0.0, -0.02);\n    vec2 uv12 = point.xy * 0.01 + vec2(0.02, 0.0);\n    vec2 uv13 = point.xy * 0.01 + vec2(-0.02, 0.0);\n    vec2 uv14 = point.xy * 0.01 + vec2(0.02, 0.02);\n    vec2 uv15 = point.xy * 0.01 + vec2(0.02, -0.02);\n    vec2 uv16 = point.xy * 0.01 + vec2(-0.02, 0.02);\n    vec2 uv17 = point.xy * 0.01 + vec2(-0.02, -0.02);", "\n    vec3 color = vec3(0.0);\n    float alpha = 1.0;\n    float fog = 1.0 - clamp((pointEnd.y - 1.0)/dist, 0.0, 1.0);\n    \n    // Raymarch\n    for(int i = 0; i < 100; i++){\n        vec3 point = pointStart + (pointEnd - pointStart) * float(i)/100.0;\n        float d = distance(point, vec3(0.0));\n        \n        // If we're too far away from the center, we're done\n        if(d > 1.0){\n            break;\n        }\n        \n        // If we're close to the center, we're done\n        if(d < 0.01){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.05){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.1){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.2){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.3){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.4){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.5){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.6){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(d < 0.7){\n            break;\n        }\n        \n        // If we're close to the surface, we're done\n        if(", "\n    // https://www.shadertoy.com/view/Msf3WH\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/4s23zN\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/MsGfWR\n    // https://www.shadertoy.com/view/Ms"]}